<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slot Racer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #a6f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 102, 255, 0.4); }
    h1 { color: #a6f; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 102, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a6f; }
    canvas {
      border: 2px solid #a6f;
      box-shadow: 0 0 20px rgba(170, 102, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a6f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SLOT RACER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">SLOT RACER</h2>
      <p id="overlayText">Hold SPACE or Click to accelerate<br>Release to brake. Don't fly off curves!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // ── Track Definition ──
    // Tracks are defined as arrays of segments: { type, ...params }
    // 'straight': { length, angle } - straight section at given angle (radians)
    // 'curve': { radius, sweep, dir } - arc, sweep in radians, dir: 1=right, -1=left

    const TRACK_LAYOUTS = [
      // Layout 0: Classic oval
      [
        { type: 'straight', length: 140, angle: 0 },
        { type: 'curve', radius: 80, sweep: Math.PI, dir: 1 },
        { type: 'straight', length: 140, angle: Math.PI },
        { type: 'curve', radius: 80, sweep: Math.PI, dir: 1 },
      ],
      // Layout 1: Figure-8 inspired
      [
        { type: 'straight', length: 80, angle: 0 },
        { type: 'curve', radius: 60, sweep: Math.PI * 0.75, dir: 1 },
        { type: 'straight', length: 60, angle: 0 },
        { type: 'curve', radius: 60, sweep: Math.PI * 0.75, dir: -1 },
        { type: 'straight', length: 80, angle: 0 },
        { type: 'curve', radius: 60, sweep: Math.PI * 0.75, dir: 1 },
        { type: 'straight', length: 60, angle: 0 },
        { type: 'curve', radius: 60, sweep: Math.PI * 0.75, dir: -1 },
      ],
      // Layout 2: Tight technical circuit
      [
        { type: 'straight', length: 120, angle: 0 },
        { type: 'curve', radius: 45, sweep: Math.PI * 0.5, dir: 1 },
        { type: 'straight', length: 60, angle: 0 },
        { type: 'curve', radius: 70, sweep: Math.PI * 0.5, dir: 1 },
        { type: 'straight', length: 120, angle: 0 },
        { type: 'curve', radius: 45, sweep: Math.PI * 0.5, dir: 1 },
        { type: 'straight', length: 60, angle: 0 },
        { type: 'curve', radius: 70, sweep: Math.PI * 0.5, dir: 1 },
      ],
    ];

    // ── Bake Track Points ──
    // Convert track layout into a polyline of evenly-spaced points
    // Each point: { x, y, angle, curvature } where curvature = 1/radius (0 for straights)

    function bakeTrack(layout) {
      const STEP = 2; // pixels between sample points
      const rawPoints = [];
      let cx = 0, cy = 0, heading = 0;

      for (const seg of layout) {
        if (seg.type === 'straight') {
          const len = seg.length;
          const steps = Math.ceil(len / STEP);
          const dx = Math.cos(heading) * STEP;
          const dy = Math.sin(heading) * STEP;
          for (let i = 0; i < steps; i++) {
            rawPoints.push({ x: cx, y: cy, angle: heading, curvature: 0 });
            cx += dx;
            cy += dy;
          }
        } else if (seg.type === 'curve') {
          const { radius, sweep, dir } = seg;
          const arcLen = radius * sweep;
          const steps = Math.ceil(arcLen / STEP);
          const dAngle = (sweep / steps) * dir;
          const curvature = 1 / radius;
          for (let i = 0; i < steps; i++) {
            rawPoints.push({ x: cx, y: cy, angle: heading, curvature });
            // Move along arc
            heading += dAngle;
            cx += Math.cos(heading) * STEP;
            cy += Math.sin(heading) * STEP;
          }
        }
      }

      // Center the track in the canvas
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (const p of rawPoints) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      const offsetX = (W - (minX + maxX)) / 2;
      const offsetY = (H - (minY + maxY)) / 2;
      for (const p of rawPoints) {
        p.x += offsetX;
        p.y += offsetY;
      }

      return rawPoints;
    }

    // ── Track State ──
    let trackPoints = [];
    let trackLength = 0;
    let currentLayout = 0;

    function loadTrack(idx) {
      currentLayout = idx % TRACK_LAYOUTS.length;
      trackPoints = bakeTrack(TRACK_LAYOUTS[currentLayout]);
      trackLength = trackPoints.length;
    }

    // Get point at fractional position along track (0..trackLength wraps)
    function getTrackPoint(dist) {
      const d = ((dist % trackLength) + trackLength) % trackLength;
      const i = Math.floor(d);
      const f = d - i;
      const p0 = trackPoints[i % trackLength];
      const p1 = trackPoints[(i + 1) % trackLength];
      return {
        x: p0.x + (p1.x - p0.x) * f,
        y: p0.y + (p1.y - p0.y) * f,
        angle: p0.angle + shortAngleDist(p0.angle, p1.angle) * f,
        curvature: p0.curvature + (p1.curvature - p0.curvature) * f,
      };
    }

    function shortAngleDist(a, b) {
      let d = ((b - a) % (Math.PI * 2) + Math.PI * 3) % (Math.PI * 2) - Math.PI;
      return d;
    }

    // ── Car Class ──
    const TRACK_WIDTH = 28;
    const LANE_OFFSET = 7; // offset from center for inner/outer lane

    class Car {
      constructor(lane, color, isPlayer) {
        this.lane = lane; // -1 = inner, +1 = outer
        this.color = color;
        this.isPlayer = isPlayer;
        this.dist = 0;
        this.speed = 0;
        this.maxSpeed = 5;
        this.accel = 0.08;
        this.decel = 0.06;
        this.brakeDecel = 0.12;
        this.laps = 0;
        this.lapStart = 0;
        this.bestLap = Infinity;
        this.lastLapTime = 0;
        this.offTrack = false;
        this.offTrackTimer = 0;
        this.offTrackX = 0;
        this.offTrackY = 0;
        this.offTrackAngle = 0;
        this.offTrackVx = 0;
        this.offTrackVy = 0;
        this.trail = [];
        this.crossedStart = false;
      }

      reset(startDist) {
        this.dist = startDist;
        this.speed = 0;
        this.laps = 0;
        this.lapStart = 0;
        this.bestLap = Infinity;
        this.lastLapTime = 0;
        this.offTrack = false;
        this.offTrackTimer = 0;
        this.trail = [];
        this.crossedStart = false;
      }

      getPosition() {
        if (this.offTrack) {
          return { x: this.offTrackX, y: this.offTrackY, angle: this.offTrackAngle };
        }
        const tp = getTrackPoint(this.dist);
        const nx = -Math.sin(tp.angle) * this.lane * LANE_OFFSET;
        const ny = Math.cos(tp.angle) * this.lane * LANE_OFFSET;
        return { x: tp.x + nx, y: tp.y + ny, angle: tp.angle };
      }
    }

    let player, cpu;
    let accelerating = false;
    let gameTime = 0;
    let skidMarks = [];
    let lastFrameTime = 0;
    let lapDisplay = '';
    let lapDisplayTimer = 0;

    // ── Difficulty ──
    let difficultyLevel = 0; // increases each lap
    const BASE_MAX_SPEED = 4.5;
    const SPEED_LIMIT_CURVE_BASE = 2.2; // max safe speed at curvature=1/45 (tightest curve)

    function getCurveSpeedLimit(curvature, difficulty) {
      if (curvature === 0) return 999;
      // Tighter curves = lower speed limit
      // As difficulty increases, the threshold tightens (less forgiveness)
      const baseLimit = SPEED_LIMIT_CURVE_BASE / (curvature * 50);
      const diffFactor = 1 + difficulty * 0.04; // each lap makes it 4% harder
      return baseLimit / diffFactor + 1.5;
    }

    // ── CPU AI ──
    function updateCPU(dt) {
      if (cpu.offTrack) {
        cpu.offTrackTimer -= dt;
        cpu.offTrackX += cpu.offTrackVx * dt * 60;
        cpu.offTrackY += cpu.offTrackVy * dt * 60;
        cpu.offTrackVx *= 0.96;
        cpu.offTrackVy *= 0.96;
        if (cpu.offTrackTimer <= 0) {
          cpu.offTrack = false;
          cpu.speed = 0.5;
        }
        return;
      }

      const tp = getTrackPoint(cpu.dist);
      // Look ahead for curves
      const lookAhead = getTrackPoint(cpu.dist + 30);
      const maxCurv = Math.max(tp.curvature, lookAhead.curvature);
      const safeSpeed = getCurveSpeedLimit(maxCurv, difficultyLevel) * 0.88; // CPU plays slightly safe

      // CPU target speed varies to create interesting races
      const cpuMaxSpeed = BASE_MAX_SPEED + difficultyLevel * 0.08;
      const targetSpeed = Math.min(cpuMaxSpeed, safeSpeed);

      if (cpu.speed < targetSpeed) {
        cpu.speed += cpu.accel * 0.9 * dt * 60;
      } else {
        cpu.speed -= cpu.brakeDecel * dt * 60;
      }
      cpu.speed = Math.max(0.2, cpu.speed);

      // Tiny chance CPU makes a mistake on tight curves at higher difficulties
      if (maxCurv > 0 && difficultyLevel > 2 && Math.random() < 0.0003) {
        cpu.speed += 1.5;
      }

      // Check if CPU flies off
      const speedLimit = getCurveSpeedLimit(tp.curvature, difficultyLevel);
      if (tp.curvature > 0 && cpu.speed > speedLimit * 1.1) {
        flyOff(cpu);
        return;
      }

      const prevDist = cpu.dist;
      cpu.dist += cpu.speed * dt * 60;

      // Lap detection
      if (cpu.dist >= trackLength && prevDist < trackLength) {
        cpu.dist -= trackLength;
        cpu.laps++;
      }

      // Trail
      const pos = cpu.getPosition();
      cpu.trail.push({ x: pos.x, y: pos.y, age: 0 });
      if (cpu.trail.length > 20) cpu.trail.shift();
    }

    function flyOff(car) {
      const pos = car.getPosition();
      car.offTrack = true;
      car.offTrackTimer = 1.5;
      car.offTrackX = pos.x;
      car.offTrackY = pos.y;
      car.offTrackAngle = pos.angle;
      car.offTrackVx = Math.cos(pos.angle) * car.speed * 0.5;
      car.offTrackVy = Math.sin(pos.angle) * car.speed * 0.5;
      car.speed = 0;
    }

    // ── Init ──
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SLOT RACER';
      overlayText.textContent = 'Hold SPACE or Click to accelerate\nRelease to brake. Don\'t fly off curves!';
      accelerating = false;
      gameTime = 0;
      skidMarks = [];
      difficultyLevel = 0;
      lapDisplay = '';
      lapDisplayTimer = 0;

      loadTrack(0);

      player = new Car(-1, '#a6f', true);
      player.reset(0);
      cpu = new Car(1, '#f44', false);
      cpu.reset(Math.floor(trackLength * 0.05));

      lastFrameTime = 0;
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      player.lapStart = performance.now();
      cpu.lapStart = performance.now();
      lastFrameTime = performance.now();
      requestAnimationFrame(loop);
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.05);
      lastFrameTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      gameTime += dt;

      // ── Update Player ──
      if (player.offTrack) {
        player.offTrackTimer -= dt;
        player.offTrackX += player.offTrackVx * dt * 60;
        player.offTrackY += player.offTrackVy * dt * 60;
        player.offTrackVx *= 0.96;
        player.offTrackVy *= 0.96;
        if (player.offTrackTimer <= 0) {
          player.offTrack = false;
          player.speed = 0.5;
        }
      } else {
        const maxSpd = BASE_MAX_SPEED + difficultyLevel * 0.06;
        if (accelerating) {
          player.speed += player.accel * dt * 60;
          if (player.speed > maxSpd) player.speed = maxSpd;
        } else {
          player.speed -= player.brakeDecel * dt * 60;
          if (player.speed < 0) player.speed = 0;
        }

        const tp = getTrackPoint(player.dist);

        // Check fly off
        const speedLimit = getCurveSpeedLimit(tp.curvature, difficultyLevel);
        if (tp.curvature > 0 && player.speed > speedLimit) {
          flyOff(player);
        } else {
          // Add skid marks when near speed limit on curves
          if (tp.curvature > 0 && player.speed > speedLimit * 0.75) {
            const pos = player.getPosition();
            const intensity = (player.speed - speedLimit * 0.75) / (speedLimit * 0.25);
            skidMarks.push({ x: pos.x, y: pos.y, age: 0, intensity: Math.min(1, intensity) });
          }

          const prevDist = player.dist;
          player.dist += player.speed * dt * 60;

          // Lap detection
          if (player.dist >= trackLength && prevDist < trackLength) {
            player.dist -= trackLength;
            player.laps++;
            const now = performance.now();
            player.lastLapTime = (now - player.lapStart) / 1000;
            if (player.lastLapTime < player.bestLap) {
              player.bestLap = player.lastLapTime;
            }
            player.lapStart = now;
            difficultyLevel = player.laps;

            // Score: laps * 1000 + time bonus
            const timeBonus = Math.max(0, Math.floor((30 - player.lastLapTime) * 20));
            score = player.laps * 1000 + timeBonus;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }

            lapDisplay = `LAP ${player.laps} - ${player.lastLapTime.toFixed(2)}s`;
            lapDisplayTimer = 2.5;

            // Change track every 3 laps
            if (player.laps > 0 && player.laps % 3 === 0) {
              const newLayout = (currentLayout + 1) % TRACK_LAYOUTS.length;
              loadTrack(newLayout);
              player.dist = 0;
              cpu.dist = Math.floor(trackLength * 0.3);
              skidMarks = [];
            }

            // End game after 10 laps
            if (player.laps >= 10) {
              gameOver();
              return;
            }
          }
        }

        // Trail
        if (!player.offTrack) {
          const pos = player.getPosition();
          player.trail.push({ x: pos.x, y: pos.y, age: 0 });
          if (player.trail.length > 20) player.trail.shift();
        }
      }

      // ── Update CPU ──
      updateCPU(dt);

      // CPU lap detection
      const cpuPrevDist = cpu.dist;
      // Already handled in updateCPU

      // ── Age trails and skid marks ──
      for (const t of player.trail) t.age += dt;
      for (const t of cpu.trail) t.age += dt;
      for (const s of skidMarks) s.age += dt;
      skidMarks = skidMarks.filter(s => s.age < 4);

      // Lap display timer
      if (lapDisplayTimer > 0) lapDisplayTimer -= dt;
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      const bestLapStr = player.bestLap < Infinity ? player.bestLap.toFixed(2) + 's' : '--';
      overlayText.textContent = `Score: ${score} | ${player.laps} Laps | Best: ${bestLapStr}\nPress SPACE to restart`;
    }

    // ── Drawing ──
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawTrack();
      drawSkidMarks();
      drawStartLine();
      drawCar(cpu);
      drawCar(player);
      drawHUD();
    }

    function drawTrack() {
      // Draw track surface (thick dark path)
      ctx.strokeStyle = '#222840';
      ctx.lineWidth = TRACK_WIDTH * 2 + 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      for (let i = 0; i < trackLength; i++) {
        const p = trackPoints[i];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();

      // Draw track borders
      ctx.strokeStyle = '#3a3a5e';
      ctx.lineWidth = TRACK_WIDTH * 2 + 4;
      ctx.beginPath();
      for (let i = 0; i < trackLength; i++) {
        const p = trackPoints[i];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();

      // Inner track (slightly darker)
      ctx.strokeStyle = '#1e1e36';
      ctx.lineWidth = TRACK_WIDTH * 2 - 2;
      ctx.beginPath();
      for (let i = 0; i < trackLength; i++) {
        const p = trackPoints[i];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();

      // Center slot line (dashed)
      ctx.strokeStyle = '#3a3a5e';
      ctx.lineWidth = 1;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      for (let i = 0; i < trackLength; i++) {
        const p = trackPoints[i];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);

      // Lane slots (thin lines where cars ride)
      for (const laneOff of [-LANE_OFFSET, LANE_OFFSET]) {
        ctx.strokeStyle = '#2a2a48';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < trackLength; i += 2) {
          const p = trackPoints[i];
          const nx = -Math.sin(p.angle) * laneOff;
          const ny = Math.cos(p.angle) * laneOff;
          if (i === 0) ctx.moveTo(p.x + nx, p.y + ny);
          else ctx.lineTo(p.x + nx, p.y + ny);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }

    function drawStartLine() {
      const p = trackPoints[0];
      const nx = -Math.sin(p.angle);
      const ny = Math.cos(p.angle);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(p.x + nx * TRACK_WIDTH, p.y + ny * TRACK_WIDTH);
      ctx.lineTo(p.x - nx * TRACK_WIDTH, p.y - ny * TRACK_WIDTH);
      ctx.stroke();

      // Checkerboard pattern on start line
      const len = TRACK_WIDTH * 2;
      const segments = 6;
      const segLen = len / segments;
      for (let i = 0; i < segments; i++) {
        if (i % 2 === 0) {
          const sx = p.x - nx * TRACK_WIDTH + nx * segLen * i;
          const sy = p.y - ny * TRACK_WIDTH + ny * segLen * i;
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.fillRect(sx - 2, sy - 2, 4, 4);
        }
      }
    }

    function drawSkidMarks() {
      for (const s of skidMarks) {
        const alpha = Math.max(0, (1 - s.age / 4) * s.intensity * 0.4);
        ctx.fillStyle = `rgba(60, 60, 60, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCar(car) {
      const pos = car.getPosition();

      // Trail glow
      for (let i = 0; i < car.trail.length; i++) {
        const t = car.trail[i];
        const alpha = ((i / car.trail.length) * 0.4) * Math.max(0, 1 - t.age * 3);
        if (alpha <= 0) continue;
        ctx.fillStyle = car.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      if (car.offTrack) {
        // Spinning off-track car
        const spinAngle = pos.angle + car.offTrackTimer * 10;
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(spinAngle);
        ctx.globalAlpha = 0.4 + car.offTrackTimer * 0.3;
        ctx.fillStyle = car.color;
        ctx.fillRect(-7, -4, 14, 8);
        ctx.globalAlpha = 1;
        ctx.restore();
        return;
      }

      // Car body
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(pos.angle);

      // Glow
      ctx.shadowColor = car.color;
      ctx.shadowBlur = 10;

      // Body
      ctx.fillStyle = car.color;
      ctx.fillRect(-8, -4, 16, 8);

      // Windshield
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(3, -3, 4, 6);

      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(-6, -5, 4, 2);
      ctx.fillRect(-6, 3, 4, 2);
      ctx.fillRect(3, -5, 4, 2);
      ctx.fillRect(3, 3, 4, 2);

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawHUD() {
      // Speed bar
      const barX = 15, barY = H - 60, barW = 100, barH = 12;
      const maxSpd = BASE_MAX_SPEED + difficultyLevel * 0.06;
      const speedRatio = player.offTrack ? 0 : player.speed / maxSpd;

      ctx.fillStyle = '#16213e';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.strokeStyle = '#3a3a5e';
      ctx.strokeRect(barX, barY, barW, barH);

      // Speed bar fill with color gradient (green to yellow to red)
      let barColor;
      if (speedRatio < 0.5) barColor = '#0f0';
      else if (speedRatio < 0.8) barColor = '#ff0';
      else barColor = '#f44';
      ctx.fillStyle = barColor;
      ctx.shadowColor = barColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(barX + 1, barY + 1, (barW - 2) * speedRatio, barH - 2);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.fillText('SPEED', barX, barY - 3);

      // Lap counter
      ctx.fillStyle = '#a6f';
      ctx.font = '14px Courier New';
      ctx.shadowColor = '#a6f';
      ctx.shadowBlur = 8;
      ctx.fillText(`LAP ${Math.min(player.laps + 1, 10)}/10`, barX, barY - 20);
      ctx.shadowBlur = 0;

      // Current lap time
      if (gameState === 'playing' && !player.offTrack) {
        const elapsed = (performance.now() - player.lapStart) / 1000;
        ctx.fillStyle = '#888';
        ctx.font = '12px Courier New';
        ctx.fillText(`Time: ${elapsed.toFixed(1)}s`, barX, barY + 30);
      }

      // Best lap
      if (player.bestLap < Infinity) {
        ctx.fillStyle = '#0f0';
        ctx.font = '11px Courier New';
        ctx.fillText(`Best: ${player.bestLap.toFixed(2)}s`, barX + 120, barY + 30);
      }

      // Position indicator (ahead or behind CPU)
      if (gameState === 'playing') {
        const playerProgress = player.laps * trackLength + player.dist;
        const cpuProgress = cpu.laps * trackLength + cpu.dist;
        const diff = playerProgress - cpuProgress;
        let posText, posColor;
        if (diff > 0) {
          posText = '1ST';
          posColor = '#0f0';
        } else {
          posText = '2ND';
          posColor = '#f44';
        }
        ctx.fillStyle = posColor;
        ctx.font = 'bold 16px Courier New';
        ctx.shadowColor = posColor;
        ctx.shadowBlur = 10;
        ctx.textAlign = 'right';
        ctx.fillText(posText, W - 15, H - 50);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
      }

      // Lap display notification
      if (lapDisplayTimer > 0) {
        const alpha = Math.min(1, lapDisplayTimer);
        ctx.fillStyle = `rgba(170, 102, 255, ${alpha})`;
        ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#a6f';
        ctx.shadowBlur = 12;
        ctx.fillText(lapDisplay, W / 2, 30);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
      }

      // Track layout indicator
      ctx.fillStyle = '#555';
      ctx.font = '10px Courier New';
      ctx.fillText(`Track ${currentLayout + 1}`, W - 60, 20);

      // Accelerating indicator
      if (accelerating && gameState === 'playing') {
        ctx.fillStyle = 'rgba(170, 102, 255, 0.5)';
        ctx.font = 'bold 11px Courier New';
        ctx.fillText('GAS', barX + barW + 10, barY + 10);
      }

      // Off-track warning
      if (player.offTrack) {
        const blink = Math.sin(performance.now() * 0.01) > 0;
        if (blink) {
          ctx.fillStyle = '#f44';
          ctx.font = 'bold 20px Courier New';
          ctx.textAlign = 'center';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 15;
          ctx.fillText('OFF TRACK!', W / 2, H / 2);
          ctx.shadowBlur = 0;
          ctx.textAlign = 'left';
        }
      }
    }

    // ── Input ──
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        if (e.key === ' ') accelerating = true;
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ') {
          accelerating = true;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === ' ') {
        accelerating = false;
      }
    });

    // Mouse/touch controls
    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (gameState === 'waiting') {
        accelerating = true;
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing') {
        accelerating = true;
      }
    });

    canvas.addEventListener('mouseup', () => {
      accelerating = false;
    });

    canvas.addEventListener('mouseleave', () => {
      accelerating = false;
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameState === 'waiting') {
        accelerating = true;
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing') {
        accelerating = true;
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      accelerating = false;
    });

    // Expose game data for ML
    window.gameData = {};
    setInterval(() => {
      if (gameState === 'playing' && player) {
        const pPos = player.getPosition();
        const cPos = cpu.getPosition();
        window.gameData = {
          playerX: pPos.x,
          playerY: pPos.y,
          playerSpeed: player.speed,
          playerLaps: player.laps,
          playerDist: player.dist,
          cpuX: cPos.x,
          cpuY: cPos.y,
          cpuSpeed: cpu.speed,
          cpuLaps: cpu.laps,
          accelerating: accelerating,
          offTrack: player.offTrack,
          difficulty: difficultyLevel,
        };
      }
    }, 200);

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

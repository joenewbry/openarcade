<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tempest</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #e4f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 68, 255, 0.4); }
    h1 { color: #e4f; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e4f; }
    canvas {
      border: 2px solid #e4f;
      box-shadow: 0 0 20px rgba(238, 68, 255, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e4f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TEMPEST</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">TEMPEST</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const CX = W / 2, CY = H / 2;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;
    let lives, level, playerLane, bullets, enemies, spikes, particles;
    let superzapperCount, superzapperFlash;
    let spawnTimer, spawnInterval, frameCount;
    let tubeShape, lanes, laneCount;
    let zoomPhase, zoomTimer;
    let deathFlash, deathTimer;
    let keys = {};

    // Tube shape definitions - each returns an array of points on the rim
    const TUBE_SHAPES = [
      // Circle (16 lanes)
      (n) => {
        const pts = [];
        for (let i = 0; i < n; i++) {
          const a = (i / n) * Math.PI * 2 - Math.PI / 2;
          pts.push({ x: CX + Math.cos(a) * 210, y: CY + Math.sin(a) * 210 });
        }
        return pts;
      },
      // Square (16 lanes)
      (n) => {
        const pts = [];
        const s = 200;
        const perSide = Math.floor(n / 4);
        const rem = n - perSide * 4;
        const sides = [perSide, perSide, perSide, perSide];
        for (let i = 0; i < rem; i++) sides[i]++;
        const corners = [
          { x: CX - s, y: CY - s }, { x: CX + s, y: CY - s },
          { x: CX + s, y: CY + s }, { x: CX - s, y: CY + s }
        ];
        for (let side = 0; side < 4; side++) {
          const c1 = corners[side], c2 = corners[(side + 1) % 4];
          for (let i = 0; i < sides[side]; i++) {
            const t = i / sides[side];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Pentagon (15 lanes)
      (n) => {
        const pts = [];
        const numSides = 5;
        const perSide = Math.floor(n / numSides);
        const rem = n - perSide * numSides;
        const sides = Array(numSides).fill(perSide);
        for (let i = 0; i < rem; i++) sides[i]++;
        const corners = [];
        for (let i = 0; i < numSides; i++) {
          const a = (i / numSides) * Math.PI * 2 - Math.PI / 2;
          corners.push({ x: CX + Math.cos(a) * 210, y: CY + Math.sin(a) * 210 });
        }
        for (let s = 0; s < numSides; s++) {
          const c1 = corners[s], c2 = corners[(s + 1) % numSides];
          for (let i = 0; i < sides[s]; i++) {
            const t = i / sides[s];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Star (20 lanes)
      (n) => {
        const pts = [];
        const spikes_count = 5;
        const outerR = 220, innerR = 100;
        const totalVerts = spikes_count * 2;
        const perSeg = Math.floor(n / totalVerts);
        const rem = n - perSeg * totalVerts;
        const segs = Array(totalVerts).fill(perSeg);
        for (let i = 0; i < rem; i++) segs[i]++;
        const verts = [];
        for (let i = 0; i < totalVerts; i++) {
          const a = (i / totalVerts) * Math.PI * 2 - Math.PI / 2;
          const r = i % 2 === 0 ? outerR : innerR;
          verts.push({ x: CX + Math.cos(a) * r, y: CY + Math.sin(a) * r });
        }
        for (let s = 0; s < totalVerts; s++) {
          const c1 = verts[s], c2 = verts[(s + 1) % totalVerts];
          for (let i = 0; i < segs[s]; i++) {
            const t = i / segs[s];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Cross / Plus (16 lanes)
      (n) => {
        const pts = [];
        const o = 200, i_val = 70;
        const crossVerts = [
          { x: CX - i_val, y: CY - o }, { x: CX + i_val, y: CY - o },
          { x: CX + i_val, y: CY - i_val }, { x: CX + o, y: CY - i_val },
          { x: CX + o, y: CY + i_val }, { x: CX + i_val, y: CY + i_val },
          { x: CX + i_val, y: CY + o }, { x: CX - i_val, y: CY + o },
          { x: CX - i_val, y: CY + i_val }, { x: CX - o, y: CY + i_val },
          { x: CX - o, y: CY - i_val }, { x: CX - i_val, y: CY - i_val }
        ];
        const numSegs = crossVerts.length;
        const perSeg = Math.floor(n / numSegs);
        const rem = n - perSeg * numSegs;
        const segs = Array(numSegs).fill(perSeg);
        for (let j = 0; j < rem; j++) segs[j]++;
        for (let s = 0; s < numSegs; s++) {
          const c1 = crossVerts[s], c2 = crossVerts[(s + 1) % numSegs];
          for (let j = 0; j < segs[s]; j++) {
            const t = j / segs[s];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Triangle (15 lanes)
      (n) => {
        const pts = [];
        const numSides = 3;
        const perSide = Math.floor(n / numSides);
        const rem = n - perSide * numSides;
        const sides = Array(numSides).fill(perSide);
        for (let i = 0; i < rem; i++) sides[i]++;
        const corners = [];
        for (let i = 0; i < numSides; i++) {
          const a = (i / numSides) * Math.PI * 2 - Math.PI / 2;
          corners.push({ x: CX + Math.cos(a) * 220, y: CY + Math.sin(a) * 220 });
        }
        for (let s = 0; s < numSides; s++) {
          const c1 = corners[s], c2 = corners[(s + 1) % numSides];
          for (let i = 0; i < sides[s]; i++) {
            const t = i / sides[s];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Hexagon (18 lanes)
      (n) => {
        const pts = [];
        const numSides = 6;
        const perSide = Math.floor(n / numSides);
        const rem = n - perSide * numSides;
        const sides = Array(numSides).fill(perSide);
        for (let i = 0; i < rem; i++) sides[i]++;
        const corners = [];
        for (let i = 0; i < numSides; i++) {
          const a = (i / numSides) * Math.PI * 2 - Math.PI / 2;
          corners.push({ x: CX + Math.cos(a) * 210, y: CY + Math.sin(a) * 210 });
        }
        for (let s = 0; s < numSides; s++) {
          const c1 = corners[s], c2 = corners[(s + 1) % numSides];
          for (let i = 0; i < sides[s]; i++) {
            const t = i / sides[s];
            pts.push({ x: c1.x + (c2.x - c1.x) * t, y: c1.y + (c2.y - c1.y) * t });
          }
        }
        return pts;
      },
      // Oval (16 lanes)
      (n) => {
        const pts = [];
        for (let i = 0; i < n; i++) {
          const a = (i / n) * Math.PI * 2 - Math.PI / 2;
          pts.push({ x: CX + Math.cos(a) * 220, y: CY + Math.sin(a) * 150 });
        }
        return pts;
      }
    ];

    // Lane counts per shape
    const LANE_COUNTS = [16, 16, 15, 20, 16, 15, 18, 16];

    function buildTube(levelNum) {
      const shapeIdx = (levelNum - 1) % TUBE_SHAPES.length;
      laneCount = LANE_COUNTS[shapeIdx];
      lanes = TUBE_SHAPES[shapeIdx](laneCount);
      tubeShape = shapeIdx;
    }

    // Get a point along a lane at depth t (0 = center, 1 = rim)
    function lanePoint(laneIdx, t) {
      const rim = lanes[laneIdx];
      return {
        x: CX + (rim.x - CX) * t,
        y: CY + (rim.y - CY) * t
      };
    }

    // Get midpoint between two adjacent lane points at depth t
    function laneMidpoint(laneIdx, t) {
      const p1 = lanePoint(laneIdx, t);
      const p2 = lanePoint((laneIdx + 1) % laneCount, t);
      return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    }

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TEMPEST';
      overlayText.textContent = 'Press SPACE to start\n\nLeft/Right: Move | Space: Fire | Shift: Superzapper';
      resetLevel();
      draw();
    }

    function resetLevel() {
      buildTube(level);
      playerLane = 0;
      bullets = [];
      enemies = [];
      spikes = [];
      particles = [];
      superzapperCount = 1;
      superzapperFlash = 0;
      spawnTimer = 0;
      spawnInterval = Math.max(30, 90 - level * 5);
      frameCount = 0;
      zoomPhase = 0;
      zoomTimer = 0;
      deathFlash = 0;
      deathTimer = 0;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function loop() {
      if (gameState !== 'playing' && gameState !== 'zooming' && gameState !== 'dying') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press SPACE to restart`;
    }

    function spawnEnemy() {
      const lane = Math.floor(Math.random() * laneCount);
      const r = Math.random();
      const difficultyMod = Math.min(level / 10, 1);
      let type;
      if (r < 0.4) {
        type = 'flipper';
      } else if (r < 0.6 + difficultyMod * 0.1) {
        type = 'tanker';
      } else if (r < 0.8 + difficultyMod * 0.05) {
        type = 'spiker';
      } else {
        type = 'fuseball';
      }

      const baseSpeed = 0.003 + level * 0.0005;
      let speed;
      switch (type) {
        case 'flipper': speed = baseSpeed * 1.5; break;
        case 'tanker': speed = baseSpeed * 0.7; break;
        case 'spiker': speed = baseSpeed * 0.9; break;
        case 'fuseball': speed = baseSpeed * 1.2; break;
      }

      enemies.push({
        type,
        lane,
        depth: 0.05,
        speed,
        flipDir: Math.random() < 0.5 ? 1 : -1,
        flipTimer: 0,
        alive: true,
        health: type === 'tanker' ? 2 : 1
      });
    }

    function fireBullet() {
      bullets.push({
        lane: playerLane,
        depth: 1.0,
        speed: 0.04
      });
    }

    function activateSuperzapper() {
      if (superzapperCount <= 0) return;
      superzapperCount--;
      superzapperFlash = 15;

      // Destroy all visible enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        addExplosion(enemies[i].lane, enemies[i].depth);
        score += getEnemyScore(enemies[i].type);
        scoreEl.textContent = score;
      }
      enemies = [];
    }

    function getEnemyScore(type) {
      switch (type) {
        case 'flipper': return 150;
        case 'tanker': return 200;
        case 'spiker': return 50;
        case 'fuseball': return 250;
        default: return 100;
      }
    }

    function addExplosion(lane, depth) {
      const p = lanePoint(lane, depth);
      for (let i = 0; i < 8; i++) {
        const a = Math.random() * Math.PI * 2;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x: p.x, y: p.y,
          vx: Math.cos(a) * spd,
          vy: Math.sin(a) * spd,
          life: 20 + Math.random() * 15,
          color: ['#e4f', '#f4f', '#fff', '#a2f', '#f8f'][Math.floor(Math.random() * 5)]
        });
      }
    }

    function update() {
      frameCount++;

      // Handle zoom transition between levels
      if (gameState === 'zooming') {
        zoomTimer++;
        zoomPhase = zoomTimer / 60; // 1 second zoom
        if (zoomTimer >= 60) {
          level++;
          levelEl.textContent = level;
          resetLevel();
          gameState = 'playing';
        }
        return;
      }

      // Handle death animation
      if (gameState === 'dying') {
        deathTimer++;
        deathFlash = deathTimer;
        if (deathTimer >= 45) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver();
            return;
          }
          // Reset the level but keep score and level number
          const curLevel = level;
          const curScore = score;
          resetLevel();
          level = curLevel;
          score = curScore;
          gameState = 'playing';
        }
        return;
      }

      // Player movement
      if (keys['ArrowLeft']) {
        if (frameCount % 4 === 0 || !keys._leftHeld) {
          playerLane = (playerLane - 1 + laneCount) % laneCount;
          keys._leftHeld = true;
        }
      } else {
        keys._leftHeld = false;
      }

      if (keys['ArrowRight']) {
        if (frameCount % 4 === 0 || !keys._rightHeld) {
          playerLane = (playerLane + 1) % laneCount;
          keys._rightHeld = true;
        }
      } else {
        keys._rightHeld = false;
      }

      // Spawn enemies
      spawnTimer++;
      const maxEnemies = 6 + Math.floor(level / 2);
      if (spawnTimer >= spawnInterval && enemies.length < maxEnemies) {
        spawnTimer = 0;
        spawnEnemy();
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.depth -= b.speed;
        if (b.depth <= 0.05) {
          // Check if bullet hits a spike
          let hitSpike = false;
          for (let s = spikes.length - 1; s >= 0; s--) {
            if (spikes[s].lane === b.lane) {
              spikes[s].depth -= 0.1;
              if (spikes[s].depth <= 0.05) {
                spikes.splice(s, 1);
              }
              hitSpike = true;
              break;
            }
          }
          bullets.splice(i, 1);
          continue;
        }

        // Bullet-enemy collision
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (e.lane === b.lane && Math.abs(e.depth - b.depth) < 0.06) {
            e.health--;
            if (e.health <= 0) {
              // Enemy destroyed
              addExplosion(e.lane, e.depth);
              score += getEnemyScore(e.type);
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }

              // Tanker splits into two flippers
              if (e.type === 'tanker') {
                const baseSpeed = 0.003 + level * 0.0005;
                enemies.push({
                  type: 'flipper', lane: (e.lane + 1) % laneCount,
                  depth: e.depth, speed: baseSpeed * 1.5,
                  flipDir: 1, flipTimer: 0, alive: true, health: 1
                });
                enemies.push({
                  type: 'flipper', lane: (e.lane - 1 + laneCount) % laneCount,
                  depth: e.depth, speed: baseSpeed * 1.5,
                  flipDir: -1, flipTimer: 0, alive: true, health: 1
                });
              }

              // Spiker leaves a spike
              if (e.type === 'spiker') {
                spikes.push({ lane: e.lane, depth: e.depth });
              }

              enemies.splice(j, 1);
            }
            hit = true;
            break;
          }
        }
        if (hit) {
          bullets.splice(i, 1);
        }
      }

      // Update enemies
      let playerHit = false;
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        // Move toward rim
        e.depth += e.speed;

        // Flipper behavior: when near the rim, move along it
        if (e.type === 'flipper' && e.depth > 0.85) {
          e.flipTimer++;
          if (e.flipTimer > 20) {
            e.flipTimer = 0;
            e.lane = (e.lane + e.flipDir + laneCount) % laneCount;
          }
        }

        // Fuseball behavior: move along rim once at the edge
        if (e.type === 'fuseball' && e.depth > 0.9) {
          e.depth = 0.95;
          e.flipTimer++;
          if (e.flipTimer > 8) {
            e.flipTimer = 0;
            e.lane = (e.lane + e.flipDir + laneCount) % laneCount;
          }
        }

        // Spiker deposits spike segments as it climbs
        if (e.type === 'spiker' && e.depth > 0.15 && frameCount % 30 === 0) {
          // Extend or create spike in this lane
          let existingSpike = spikes.find(s => s.lane === e.lane);
          if (existingSpike) {
            existingSpike.depth = Math.max(existingSpike.depth, e.depth);
          } else {
            spikes.push({ lane: e.lane, depth: e.depth });
          }
        }

        // Enemy reached the rim
        if (e.depth >= 1.0) {
          // Check if enemy is on player's lane
          if (e.lane === playerLane) {
            playerHit = true;
          }
          // Flippers and fuseballs move along the rim to reach the player
          if (e.type === 'flipper' || e.type === 'fuseball') {
            e.depth = 0.97;
            // If on player lane, hit
            if (e.lane === playerLane) {
              playerHit = true;
            }
          } else {
            // Other enemies that reach rim on player lane cause hit
            if (e.lane === playerLane) {
              playerHit = true;
            }
            // Remove non-flipping enemies that reach rim on other lanes
            if (e.type !== 'flipper' && e.type !== 'fuseball') {
              if (e.lane !== playerLane) {
                enemies.splice(i, 1);
                continue;
              }
            }
          }
        }
      }

      if (playerHit) {
        addExplosion(playerLane, 1.0);
        gameState = 'dying';
        deathTimer = 0;
        deathFlash = 0;
        return;
      }

      // Check level clear condition
      const totalEnemiesForLevel = 10 + level * 3;
      if (frameCount > totalEnemiesForLevel * spawnInterval && enemies.length === 0) {
        // Check if player would hit spikes during zoom
        // Remove spikes in player lane for zoom safety
        spikes = spikes.filter(s => s.lane !== playerLane);
        gameState = 'zooming';
        zoomTimer = 0;
        zoomPhase = 0;
        return;
      }

      // Superzapper flash decay
      if (superzapperFlash > 0) superzapperFlash--;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Superzapper flash
      if (superzapperFlash > 0) {
        ctx.fillStyle = `rgba(238, 68, 255, ${superzapperFlash / 30})`;
        ctx.fillRect(0, 0, W, H);
      }

      // Death flash
      if (gameState === 'dying' && deathFlash > 0) {
        const intensity = Math.sin(deathFlash * 0.5) * 0.3;
        if (intensity > 0) {
          ctx.fillStyle = `rgba(255, 100, 100, ${intensity})`;
          ctx.fillRect(0, 0, W, H);
        }
      }

      // Zoom animation
      if (gameState === 'zooming') {
        drawZoom();
        return;
      }

      // Draw tube/web with depth rings
      drawTube();

      // Draw spikes
      drawSpikes();

      // Draw enemies
      drawEnemies();

      // Draw bullets
      drawBullets();

      // Draw player
      drawPlayer();

      // Draw particles
      drawParticles();

      // Draw HUD indicators
      drawHUD();
    }

    function drawTube() {
      // Draw depth rings (5 rings from center to rim)
      for (let ring = 0; ring < 6; ring++) {
        const t = (ring + 1) / 6;
        const alpha = 0.15 + ring * 0.05;
        ctx.strokeStyle = `rgba(238, 68, 255, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= laneCount; i++) {
          const p = lanePoint(i % laneCount, t);
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Draw lane dividers (from center to rim)
      for (let i = 0; i < laneCount; i++) {
        const inner = lanePoint(i, 0.15);
        const outer = lanePoint(i, 1.0);
        ctx.strokeStyle = 'rgba(238, 68, 255, 0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(inner.x, inner.y);
        ctx.lineTo(outer.x, outer.y);
        ctx.stroke();
      }

      // Highlight the active lane on the rim
      const p1 = lanes[playerLane];
      const p2 = lanes[(playerLane + 1) % laneCount];
      ctx.strokeStyle = '#e4f';
      ctx.shadowColor = '#e4f';
      ctx.shadowBlur = 8;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawPlayer() {
      // Player is a claw/marker on the rim at their lane
      const p1 = lanes[playerLane];
      const p2 = lanes[(playerLane + 1) % laneCount];
      const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

      // Direction from center to midpoint (outward)
      const dx = mid.x - CX;
      const dy = mid.y - CY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const nx = dx / dist;
      const ny = dy / dist;

      // Perpendicular
      const px = -ny;
      const py = nx;

      // Draw claw shape
      const size = 14;
      const tip = { x: mid.x + nx * size, y: mid.y + ny * size };
      const left = { x: mid.x - px * size * 0.6, y: mid.y - py * size * 0.6 };
      const right = { x: mid.x + px * size * 0.6, y: mid.y + py * size * 0.6 };
      const back = { x: mid.x - nx * size * 0.3, y: mid.y - ny * size * 0.3 };

      ctx.strokeStyle = '#e4f';
      ctx.shadowColor = '#e4f';
      ctx.shadowBlur = 15;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(left.x, left.y);
      ctx.lineTo(tip.x, tip.y);
      ctx.lineTo(right.x, right.y);
      ctx.moveTo(left.x, left.y);
      ctx.lineTo(back.x, back.y);
      ctx.lineTo(right.x, right.y);
      ctx.stroke();

      // Inner fill
      ctx.fillStyle = 'rgba(238, 68, 255, 0.3)';
      ctx.beginPath();
      ctx.moveTo(left.x, left.y);
      ctx.lineTo(tip.x, tip.y);
      ctx.lineTo(right.x, right.y);
      ctx.lineTo(back.x, back.y);
      ctx.closePath();
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawBullets() {
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 8;
      bullets.forEach(b => {
        const p = laneMidpoint(b.lane, b.depth);
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();

        // Trail
        const p2 = laneMidpoint(b.lane, Math.min(1, b.depth + 0.04));
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      });
      ctx.shadowBlur = 0;
    }

    function drawEnemies() {
      enemies.forEach(e => {
        const p = laneMidpoint(e.lane, e.depth);
        // Scale enemy size based on depth for perspective
        const scale = 0.4 + e.depth * 0.6;

        switch (e.type) {
          case 'flipper':
            drawFlipper(p.x, p.y, scale, e);
            break;
          case 'tanker':
            drawTanker(p.x, p.y, scale, e);
            break;
          case 'spiker':
            drawSpiker(p.x, p.y, scale, e);
            break;
          case 'fuseball':
            drawFuseball(p.x, p.y, scale, e);
            break;
        }
      });
    }

    function drawFlipper(x, y, scale, e) {
      const s = 10 * scale;
      ctx.strokeStyle = '#0f0';
      ctx.shadowColor = '#0f0';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;
      // Diamond shape that flips
      const wobble = Math.sin(frameCount * 0.15 + e.depth * 10) * 0.3;
      ctx.beginPath();
      ctx.moveTo(x, y - s);
      ctx.lineTo(x + s * (1 + wobble), y);
      ctx.lineTo(x, y + s);
      ctx.lineTo(x - s * (1 - wobble), y);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawTanker(x, y, scale, e) {
      const s = 12 * scale;
      ctx.strokeStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;
      // Hexagonal shape
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2;
        const px = x + Math.cos(a) * s;
        const py = y + Math.sin(a) * s;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      // Inner circle
      ctx.beginPath();
      ctx.arc(x, y, s * 0.4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawSpiker(x, y, scale, e) {
      const s = 8 * scale;
      ctx.strokeStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;
      // Spikey shape
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2 + frameCount * 0.05;
        const r = i % 2 === 0 ? s : s * 0.4;
        const px = x + Math.cos(a) * r;
        const py = y + Math.sin(a) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawFuseball(x, y, scale, e) {
      const s = 9 * scale;
      ctx.strokeStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 12;
      ctx.lineWidth = 2;
      // Pulsing circle with electric arcs
      const pulse = 1 + Math.sin(frameCount * 0.2) * 0.2;
      ctx.beginPath();
      ctx.arc(x, y, s * pulse, 0, Math.PI * 2);
      ctx.stroke();
      // Electric arcs
      for (let i = 0; i < 4; i++) {
        const a = (i / 4) * Math.PI * 2 + frameCount * 0.1;
        ctx.beginPath();
        ctx.moveTo(x, y);
        const tx = x + Math.cos(a) * s * 1.5 + (Math.random() - 0.5) * 4;
        const ty = y + Math.sin(a) * s * 1.5 + (Math.random() - 0.5) * 4;
        ctx.lineTo(tx, ty);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }

    function drawSpikes() {
      spikes.forEach(s => {
        const inner = lanePoint(s.lane, 0.1);
        const outer = laneMidpoint(s.lane, s.depth);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 5;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(CX + (inner.x - CX), CY + (inner.y - CY));
        ctx.lineTo(outer.x, outer.y);
        ctx.stroke();
      });
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      particles.forEach(p => {
        const alpha = p.life / 35;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawZoom() {
      // Warp/zoom effect - tunnel rushing forward
      const t = zoomPhase;

      // Background pulse
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw tube at shrinking scale
      const zoomScale = 1 + t * 8;
      ctx.save();
      ctx.translate(CX, CY);
      ctx.scale(zoomScale, zoomScale);
      ctx.translate(-CX, -CY);

      // Draw tube structure fading out
      const alpha = Math.max(0, 1 - t * 1.5);
      for (let i = 0; i < laneCount; i++) {
        const inner = lanePoint(i, 0.15);
        const outer = lanePoint(i, 1.0);
        ctx.strokeStyle = `rgba(238, 68, 255, ${alpha * 0.3})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(inner.x, inner.y);
        ctx.lineTo(outer.x, outer.y);
        ctx.stroke();
      }

      // Rim
      ctx.strokeStyle = `rgba(238, 68, 255, ${alpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i <= laneCount; i++) {
        const p = lanes[i % laneCount];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();

      ctx.restore();

      // Speed lines
      for (let i = 0; i < 20; i++) {
        const a = (i / 20) * Math.PI * 2;
        const r1 = 30 + t * 200;
        const r2 = 80 + t * 400;
        ctx.strokeStyle = `rgba(238, 68, 255, ${0.5 - t * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(CX + Math.cos(a) * r1, CY + Math.sin(a) * r1);
        ctx.lineTo(CX + Math.cos(a) * r2, CY + Math.sin(a) * r2);
        ctx.stroke();
      }

      // Level text
      ctx.fillStyle = '#e4f';
      ctx.shadowColor = '#e4f';
      ctx.shadowBlur = 20;
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`LEVEL ${level + 1}`, CX, CY);
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Superzapper indicator
      const szText = superzapperCount > 0 ? 'SUPERZAPPER READY' : 'SUPERZAPPER USED';
      ctx.fillStyle = superzapperCount > 0 ? 'rgba(238, 68, 255, 0.8)' : 'rgba(100, 100, 100, 0.5)';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(szText, CX, H - 12);
    }

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
        if (e.key === ' ') {
          fireBullet();
        }
        if (e.key === 'Shift') {
          activateSuperzapper();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Expose game data for ML
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        playerLane,
        laneCount,
        level,
        lives,
        enemies: enemies.map(e => ({
          type: e.type, lane: e.lane, depth: e.depth
        })),
        bullets: bullets.map(b => ({
          lane: b.lane, depth: b.depth
        })),
        spikes: spikes.map(s => ({
          lane: s.lane, depth: s.depth
        })),
        superzapperReady: superzapperCount > 0
      };
    }

    // Wrap the original update to also update gameData
    const _origUpdate = update;
    update = function() {
      _origUpdate.call(this);
      updateGameData();
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lights Out</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #4fc; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 255, 204, 0.5); }
    h1 { color: #4fc; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 255, 204, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4fc; }
    canvas {
      border: 2px solid #4fc;
      box-shadow: 0 0 20px rgba(68, 255, 204, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4fc;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>LIGHTS OUT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="440"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:440px;">
      <h2 id="overlayTitle">LIGHTS OUT</h2>
      <p id="overlayText">Click or press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Prevent context menu on canvas
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Grid constants
    const GRID = 5;
    const CELL = 60;
    const GAP = 8;
    const GRID_SIZE = GRID * CELL + (GRID - 1) * GAP; // 5*60 + 4*8 = 332
    const GRID_X = Math.floor((W - GRID_SIZE) / 2);    // center horizontally
    const INFO_H = 50;                                   // space at top for level/clicks info
    const GRID_Y = INFO_H + Math.floor((H - INFO_H - GRID_SIZE) / 2); // center vertically in remaining space

    // Theme colors
    const THEME = '#4fc';
    const THEME_DIM = '#1a3a30';
    const THEME_RGB = '68, 255, 204';

    // Game state
    let score, best = 0, gameState;
    let grid = [];       // 5x5 array, true = light ON
    let level = 1;
    let clicks = 0;
    let totalClicks = 0;
    let hoverR = -1, hoverC = -1;

    // Generate a solvable puzzle by starting from all-off and toggling random cells
    function generatePuzzle(numToggles) {
      // Start with all lights off
      grid = [];
      for (let r = 0; r < GRID; r++) {
        grid[r] = [];
        for (let c = 0; c < GRID; c++) {
          grid[r][c] = false;
        }
      }
      // Perform random toggles to create a solvable puzzle
      let toggledCells = new Set();
      let attempts = 0;
      while (toggledCells.size < numToggles && attempts < numToggles * 10) {
        const r = Math.floor(Math.random() * GRID);
        const c = Math.floor(Math.random() * GRID);
        const key = r * GRID + c;
        if (!toggledCells.has(key)) {
          toggledCells.add(key);
          toggleCell(r, c);
        }
        attempts++;
      }
      // Make sure at least one light is on (should be guaranteed but just in case)
      let anyOn = false;
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c]) { anyOn = true; break; }
        }
        if (anyOn) break;
      }
      if (!anyOn) {
        // Force a simple puzzle
        const cr = Math.floor(GRID / 2);
        toggleCell(cr, cr);
      }
    }

    // Toggle a cell and its neighbors (no animation, used for puzzle generation)
    function toggleCell(r, c) {
      grid[r][c] = !grid[r][c];
      if (r > 0) grid[r - 1][c] = !grid[r - 1][c];
      if (r < GRID - 1) grid[r + 1][c] = !grid[r + 1][c];
      if (c > 0) grid[r][c - 1] = !grid[r][c - 1];
      if (c < GRID - 1) grid[r][c + 1] = !grid[r][c + 1];
    }

    // Check if all lights are off (puzzle solved)
    function isSolved() {
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c]) return false;
        }
      }
      return true;
    }

    // Count lights on
    function countLightsOn() {
      let count = 0;
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c]) count++;
        }
      }
      return count;
    }

    // Get number of initial toggles for a level
    function getTogglesForLevel(lvl) {
      // Start with fewer toggles, gradually increase
      // Level 1: 3 toggles, Level 2: 4, ... up to max of 15
      return Math.min(2 + lvl, 15);
    }

    // Max clicks allowed per level (generous but creates a fail condition)
    function getMaxClicks(lvl) {
      const toggles = getTogglesForLevel(lvl);
      // Allow roughly 3x the minimum possible solution
      return Math.max(toggles * 3, 15);
    }

    function init() {
      score = 0;
      totalClicks = 0;
      level = 1;
      clicks = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LIGHTS OUT';
      overlayText.textContent = 'Click or press SPACE to start';
      generatePuzzle(getTogglesForLevel(level));
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      draw();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.innerHTML = 'Level ' + level + ' &mdash; Score: ' + score + '<br>Click or press any key to restart';
    }

    function levelComplete() {
      // Award score: bonus for fewer clicks
      let levelScore = level * 1000 - clicks * 50;
      if (levelScore < level * 100) levelScore = level * 100; // minimum score per level
      score += levelScore;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Next level
      level++;
      totalClicks += clicks;
      clicks = 0;
      generatePuzzle(getTogglesForLevel(level));
      draw();
    }

    // Convert canvas pixel coords to grid row/col, or -1 if outside grid
    function pixelToGrid(px, py) {
      const gx = px - GRID_X;
      const gy = py - GRID_Y;
      if (gx < 0 || gy < 0) return { r: -1, c: -1 };
      const c = Math.floor(gx / (CELL + GAP));
      const r = Math.floor(gy / (CELL + GAP));
      if (r < 0 || r >= GRID || c < 0 || c >= GRID) return { r: -1, c: -1 };
      // Check if click is within the cell (not in the gap)
      const cellX = gx - c * (CELL + GAP);
      const cellY = gy - r * (CELL + GAP);
      if (cellX > CELL || cellY > CELL) return { r: -1, c: -1 };
      return { r, c };
    }

    // Handle a click on the grid during gameplay
    function handleGridClick(r, c) {
      if (r < 0 || c < 0) return;
      clicks++;
      totalClicks++;
      toggleCell(r, c);

      // Update score display (show running calculation)
      let runningScore = score + Math.max(level * 1000 - clicks * 50, level * 100);
      scoreEl.textContent = runningScore;

      draw();

      if (isSolved()) {
        // Brief delay before moving to next level so player sees the solved state
        setTimeout(() => {
          if (gameState === 'playing') {
            levelComplete();
          }
        }, 400);
      } else if (clicks >= getMaxClicks(level)) {
        // Too many clicks -- game over
        setTimeout(() => {
          if (gameState === 'playing') {
            gameOver();
          }
        }, 200);
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw info bar at top
      ctx.font = '16px "Courier New", monospace';

      // Level
      ctx.fillStyle = THEME;
      ctx.textAlign = 'left';
      ctx.fillText('Level ' + level, GRID_X, 24);

      // Lights remaining count
      const lightsOn = countLightsOn();
      ctx.textAlign = 'center';
      ctx.fillStyle = lightsOn === 0 ? '#4f4' : '#aaa';
      ctx.fillText(lightsOn + ' lights', W / 2, 24);

      // Clicks / max clicks with color coding
      const maxClicks = getMaxClicks(level);
      const remaining = maxClicks - clicks;
      if (remaining <= 3 && remaining > 0 && gameState === 'playing') {
        ctx.fillStyle = '#f44'; // red warning
      } else if (remaining <= 6 && gameState === 'playing') {
        ctx.fillStyle = '#f80'; // orange warning
      } else {
        ctx.fillStyle = '#aaa';
      }
      ctx.textAlign = 'right';
      ctx.fillText(clicks + '/' + maxClicks, GRID_X + GRID_SIZE, 24);
      ctx.textAlign = 'left';

      // Draw grid
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          const x = GRID_X + c * (CELL + GAP);
          const y = GRID_Y + r * (CELL + GAP);
          const isOn = grid[r][c];
          const isHover = (r === hoverR && c === hoverC && gameState === 'playing');

          if (isOn) {
            // Lit cell: bright neon glow
            ctx.shadowColor = 'rgba(' + THEME_RGB + ', 0.8)';
            ctx.shadowBlur = 20;
            ctx.fillStyle = THEME;
            ctx.fillRect(x, y, CELL, CELL);
            ctx.shadowBlur = 0;

            // Inner bright center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x + 8, y + 8, CELL - 16, CELL - 16);
          } else {
            // Dark cell
            ctx.fillStyle = THEME_DIM;
            ctx.fillRect(x, y, CELL, CELL);

            // Subtle border
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, CELL - 1, CELL - 1);
          }

          // Hover highlight
          if (isHover) {
            ctx.strokeStyle = 'rgba(' + THEME_RGB + ', 0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 1, y - 1, CELL + 2, CELL + 2);

            // Also highlight neighbors to show what will toggle
            const neighbors = [
              [r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]
            ];
            ctx.strokeStyle = 'rgba(' + THEME_RGB + ', 0.3)';
            ctx.lineWidth = 1;
            for (const [nr, nc] of neighbors) {
              if (nr >= 0 && nr < GRID && nc >= 0 && nc < GRID) {
                const nx = GRID_X + nc * (CELL + GAP);
                const ny = GRID_Y + nr * (CELL + GAP);
                ctx.strokeRect(nx - 1, ny - 1, CELL + 2, CELL + 2);
              }
            }
          }
        }
      }

      // Draw grid border
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      ctx.strokeRect(GRID_X - 6, GRID_Y - 6, GRID_SIZE + 12, GRID_SIZE + 12);
    }

    // Mouse handlers
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);
      const { r, c } = pixelToGrid(x, y);
      if (r !== hoverR || c !== hoverC) {
        hoverR = r;
        hoverC = c;
        draw();
      }
    });

    canvas.addEventListener('mouseleave', () => {
      hoverR = -1;
      hoverC = -1;
      draw();
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        const { r, c } = pixelToGrid(x, y);
        handleGridClick(r, c);
      }
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    // Expose game data for ML training
    window.gameData = {
      get grid() { return grid; },
      get level() { return level; },
      get clicks() { return clicks; },
      get lightsOn() { return countLightsOn(); }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

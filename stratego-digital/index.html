<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stratego Digital</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #d4a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(221, 68, 170, 0.5); }
    h1 { color: #d4a; font-size: 1.5rem; text-shadow: 0 0 15px rgba(221, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #d4a; }
    canvas {
      border: 2px solid #d4a;
      box-shadow: 0 0 20px rgba(221, 68, 170, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #d4a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(221, 68, 170, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
    .info {
      width: 500px;
      margin-top: 8px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }
    .info span { color: #d4a; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>STRATEGO DIGITAL</h1>
  </div>
  <div class="score-bar">
    <div>Captures: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:600px;">
      <h2 id="overlayTitle">STRATEGO DIGITAL</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>
  <div class="info" id="infoBar">Hidden-piece strategy &mdash; capture the enemy <span>Flag</span></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 500, H = 600;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const infoBar = document.getElementById('infoBar');

    const THEME = '#dd44aa';
    const THEME_GLOW = 'rgba(221, 68, 170, ';

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('stratego-best') || '0');
    bestEl.textContent = bestScore;

    // Board
    const COLS = 10, ROWS = 10;
    const CELL = 46;
    const BOARD_W = COLS * CELL;
    const BOARD_H = ROWS * CELL;
    const BOARD_X = Math.floor((W - BOARD_W) / 2);
    const BOARD_Y = 54;
    const PANEL_Y = BOARD_Y + BOARD_H + 4;

    // Lakes
    const LAKE_CELLS = new Set();
    for (let r = 4; r <= 5; r++) {
      for (let c = 2; c <= 3; c++) LAKE_CELLS.add(r * 10 + c);
      for (let c = 6; c <= 7; c++) LAKE_CELLS.add(r * 10 + c);
    }
    function isLake(r, c) { return LAKE_CELLS.has(r * 10 + c); }

    // Piece definitions: rank 1 = strongest combat. 0 = bomb, 99 = flag
    const PIECE_DEFS = [
      { name: 'Marshal',    rank: 1,  count: 1, abbr: 'Ma' },
      { name: 'General',    rank: 2,  count: 1, abbr: 'Ge' },
      { name: 'Colonel',    rank: 3,  count: 2, abbr: 'Co' },
      { name: 'Major',      rank: 4,  count: 3, abbr: 'Mj' },
      { name: 'Captain',    rank: 5,  count: 4, abbr: 'Ca' },
      { name: 'Lieutenant', rank: 6,  count: 4, abbr: 'Lt' },
      { name: 'Sergeant',   rank: 7,  count: 4, abbr: 'Sg' },
      { name: 'Miner',      rank: 8,  count: 5, abbr: 'Mi' },
      { name: 'Scout',      rank: 9,  count: 8, abbr: 'Sc' },
      { name: 'Spy',        rank: 10, count: 1, abbr: 'Sp' },
      { name: 'Bomb',       rank: 0,  count: 6, abbr: 'Bo' },
      { name: 'Flag',       rank: 99, count: 1, abbr: 'Fl' },
    ];

    // Colors
    const C_PLAYER      = '#4488ff';
    const C_PLAYER_DIM  = '#1a3366';
    const C_PLAYER_LITE = '#6699ff';
    const C_AI          = '#ee4444';
    const C_AI_DIM      = '#661a1a';
    const C_AI_LITE     = '#ff6666';
    const C_LAKE        = '#0d2844';
    const C_BOARD       = '#141e30';
    const C_GRID        = '#1e3050';

    // Game state
    let board, phase, selectedPiece, validMoves;
    let setupPieces, setupIndex;
    let turn, lastBattle, battleTimer;
    let message, messageTimer;
    let aiCaptured, playerCaptured;
    let aiKnownMovable; // Set of board positions AI has seen move

    function initBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = new Array(COLS).fill(null);
      }
    }

    function createPieceSet() {
      const pieces = [];
      for (const def of PIECE_DEFS) {
        for (let i = 0; i < def.count; i++) {
          pieces.push({ name: def.name, rank: def.rank, abbr: def.abbr });
        }
      }
      return pieces;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ===================== SETUP =====================

    function placeAIPieces() {
      let pieces = shuffle(createPieceSet());
      // Strategy: flag in back row, bombs nearby, scouts forward
      const flagIdx = pieces.findIndex(p => p.rank === 99);
      const flag = pieces.splice(flagIdx, 1)[0];
      const flagCol = 1 + Math.floor(Math.random() * 8);
      board[0][flagCol] = { owner: 1, ...flag, revealed: false };

      // Place up to 3 bombs adjacent to flag
      const bombIdxs = [];
      for (let i = pieces.length - 1; i >= 0; i--) {
        if (pieces[i].rank === 0 && bombIdxs.length < 3) bombIdxs.push(i);
      }
      const bombs = bombIdxs.map(i => pieces[i]);
      bombIdxs.sort((a, b) => b - a).forEach(i => pieces.splice(i, 1));

      const adjSlots = [
        { r: 0, c: flagCol - 1 }, { r: 0, c: flagCol + 1 }, { r: 1, c: flagCol }
      ].filter(p => p.c >= 0 && p.c < COLS && !board[p.r][p.c]);

      for (let i = 0; i < Math.min(bombs.length, adjSlots.length); i++) {
        board[adjSlots[i].r][adjSlots[i].c] = { owner: 1, ...bombs[i], revealed: false };
      }
      // Remaining bombs go back in pool
      pieces.push(...bombs.slice(adjSlots.length));
      shuffle(pieces);

      // Fill rows 0-3
      let pi = 0;
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!board[r][c] && pi < pieces.length) {
            board[r][c] = { owner: 1, ...pieces[pi++], revealed: false };
          }
        }
      }
    }

    function getSetupOrder() {
      const pieces = [];
      const order = [99, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      for (const rank of order) {
        const def = PIECE_DEFS.find(d => d.rank === rank);
        for (let i = 0; i < def.count; i++) {
          pieces.push({ name: def.name, rank: def.rank, abbr: def.abbr });
        }
      }
      return pieces;
    }

    function autoPlacePlayerPieces() {
      let pieces = shuffle(createPieceSet());
      const flagIdx = pieces.findIndex(p => p.rank === 99);
      const flag = pieces.splice(flagIdx, 1)[0];
      const flagCol = 1 + Math.floor(Math.random() * 8);
      board[9][flagCol] = { owner: 0, ...flag, revealed: false };

      const bombIdxs = [];
      for (let i = pieces.length - 1; i >= 0; i--) {
        if (pieces[i].rank === 0 && bombIdxs.length < 3) bombIdxs.push(i);
      }
      const bombs = bombIdxs.map(i => pieces[i]);
      bombIdxs.sort((a, b) => b - a).forEach(i => pieces.splice(i, 1));
      const adj = [
        { r: 9, c: flagCol - 1 }, { r: 9, c: flagCol + 1 }, { r: 8, c: flagCol }
      ].filter(p => p.c >= 0 && p.c < COLS && !board[p.r][p.c]);
      for (let i = 0; i < Math.min(bombs.length, adj.length); i++) {
        board[adj[i].r][adj[i].c] = { owner: 0, ...bombs[i], revealed: false };
      }
      pieces.push(...bombs.slice(adj.length));
      shuffle(pieces);

      let pi = 0;
      for (let r = 6; r < 10; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!board[r][c] && pi < pieces.length) {
            board[r][c] = { owner: 0, ...pieces[pi++], revealed: false };
          }
        }
      }
    }

    // ===================== MOVEMENT =====================

    function canMove(piece) {
      return piece.rank !== 0 && piece.rank !== 99;
    }

    function getValidMoves(r, c) {
      const piece = board[r][c];
      if (!piece || !canMove(piece)) return [];
      const moves = [];
      const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];

      if (piece.rank === 9) {
        // Scout: slide any distance in straight line
        for (const [dr, dc] of dirs) {
          for (let d = 1; d < 10; d++) {
            const nr = r + dr * d, nc = c + dc * d;
            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || isLake(nr, nc)) break;
            if (board[nr][nc]) {
              if (board[nr][nc].owner !== piece.owner) moves.push({ r: nr, c: nc, attack: true });
              break;
            }
            moves.push({ r: nr, c: nc, attack: false });
          }
        }
      } else {
        for (const [dr, dc] of dirs) {
          const nr = r + dr, nc = c + dc;
          if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || isLake(nr, nc)) continue;
          if (board[nr][nc]) {
            if (board[nr][nc].owner !== piece.owner) moves.push({ r: nr, c: nc, attack: true });
          } else {
            moves.push({ r: nr, c: nc, attack: false });
          }
        }
      }
      return moves;
    }

    // ===================== COMBAT =====================

    function resolveBattle(ar, ac, dr, dc) {
      const atk = board[ar][ac];
      const def = board[dr][dc];
      atk.revealed = true;
      def.revealed = true;

      let result;
      if (atk.rank === 10 && def.rank === 1)      result = 'attacker'; // Spy kills Marshal
      else if (atk.rank === 8 && def.rank === 0)   result = 'attacker'; // Miner defuses Bomb
      else if (def.rank === 0)                      result = 'defender'; // Bomb kills attacker
      else if (def.rank === 99)                     result = 'attacker'; // Flag captured
      else if (atk.rank < def.rank)                 result = 'attacker'; // Lower rank wins
      else if (atk.rank > def.rank)                 result = 'defender';
      else                                          result = 'both';     // Same rank

      lastBattle = {
        attacker: { ...atk }, defender: { ...def }, result,
        ar, ac, dr, dc
      };
      battleTimer = 100;

      // Track captures
      if (result === 'attacker') {
        if (def.owner === 1) { aiCaptured.push(def); score++; scoreEl.textContent = score; }
        else playerCaptured.push(def);
        board[dr][dc] = atk;
        board[ar][ac] = null;
        if (def.rank === 99) endGame(atk.owner === 0 ? 'win' : 'lose');
      } else if (result === 'defender') {
        if (atk.owner === 1) aiCaptured.push(atk);
        else playerCaptured.push(atk);
        board[ar][ac] = null;
      } else {
        if (atk.owner === 1) aiCaptured.push(atk); else playerCaptured.push(atk);
        if (def.owner === 1) { aiCaptured.push(def); score++; scoreEl.textContent = score; }
        else playerCaptured.push(def);
        board[ar][ac] = null;
        board[dr][dc] = null;
      }
      return result;
    }

    function doMove(fr, fc, tr, tc) {
      const piece = board[fr][fc];
      // Track that this piece has moved (AI knowledge)
      if (piece.owner === 0) aiKnownMovable.add(tr * 10 + tc);

      if (board[tr][tc] && board[tr][tc].owner !== piece.owner) {
        return resolveBattle(fr, fc, tr, tc);
      }
      board[tr][tc] = board[fr][fc];
      board[fr][fc] = null;
      return null;
    }

    function endGame(result) {
      phase = 'gameover';
      gameState = 'over';
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('stratego-best', bestScore);
        bestEl.textContent = bestScore;
      }
      // Reveal all
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (board[r][c]) board[r][c].revealed = true;

      setTimeout(() => {
        overlayTitle.textContent = result === 'win' ? 'VICTORY!' : 'DEFEAT';
        overlayText.textContent = 'Captures: ' + score + ' | Click to play again';
        overlay.style.display = 'flex';
      }, 1500);
    }

    function hasMovesLeft(owner) {
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (board[r][c] && board[r][c].owner === owner && canMove(board[r][c]))
            if (getValidMoves(r, c).length > 0) return true;
      return false;
    }

    // ===================== AI =====================

    function getRemainingCounts(owner) {
      const counts = {};
      for (const d of PIECE_DEFS) counts[d.rank] = d.count;
      const captured = owner === 0 ? playerCaptured : aiCaptured;
      for (const p of captured) counts[p.rank]--;
      // Subtract revealed on-board
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = board[r][c];
          if (p && p.owner === owner && p.revealed) counts[p.rank]--;
        }
      return counts;
    }

    function estimatePlayerPiece(r, c) {
      const p = board[r][c];
      if (!p || p.owner !== 0) return null;
      if (p.revealed) return { rank: p.rank, confidence: 1.0 };

      const remaining = getRemainingCounts(0);
      const hasMoved = aiKnownMovable.has(r * 10 + c);

      // Build probability distribution
      let totalWeight = 0;
      let weightedRank = 0;
      let bombProb = 0, flagProb = 0;

      for (const [rk, cnt] of Object.entries(remaining)) {
        const rank = parseInt(rk);
        if (cnt <= 0) continue;
        if (hasMoved && (rank === 0 || rank === 99)) continue; // moved => not bomb/flag
        totalWeight += cnt;
        weightedRank += rank * cnt;
        if (rank === 0) bombProb += cnt;
        if (rank === 99) flagProb += cnt;
      }
      if (totalWeight === 0) return { rank: 5, confidence: 0 };

      return {
        rank: weightedRank / totalWeight,
        confidence: 0.3,
        bombChance: bombProb / totalWeight,
        flagChance: flagProb / totalWeight,
        hasMoved
      };
    }

    function aiAttackScore(aiPiece, tr, tc) {
      const target = board[tr][tc];
      if (!target || target.owner !== 0) return 0;

      if (target.revealed) {
        if (target.rank === 99) return 10000;
        if (target.rank === 0) return aiPiece.rank === 8 ? 60 : -200;
        if (aiPiece.rank === 10 && target.rank === 1) return 90;
        if (aiPiece.rank < target.rank) return 40 + (target.rank - aiPiece.rank) * 8;
        if (aiPiece.rank === target.rank) return -15;
        return -40 - (aiPiece.rank - target.rank) * 12;
      }

      // Unknown target
      const est = estimatePlayerPiece(tr, tc);
      if (!est) return 0;

      // Miners should probe unmoved pieces (might be bombs protecting flag)
      if (aiPiece.rank === 8 && !est.hasMoved && est.bombChance > 0.15) return 35;

      // Scouts are expendable scouts
      if (aiPiece.rank === 9) return 12;

      // Valuable pieces avoid unknowns
      if (aiPiece.rank <= 2) return -20;
      if (aiPiece.rank <= 4) return -5;

      // Medium pieces take calculated risks
      const estWinChance = est.rank > aiPiece.rank ? 0.6 : 0.3;
      return estWinChance * 20 - (1 - estWinChance) * 15;
    }

    function aiScoreMove(r, c, move) {
      const piece = board[r][c];
      let s = 0;

      if (move.attack) {
        s += aiAttackScore(piece, move.r, move.c);
      } else {
        // Advancement bonus (move toward player side = higher row)
        const adv = move.r - r;
        s += adv * 3;

        // Center control
        s += (5 - Math.abs(move.c - 4.5)) * 0.6;

        // Scouts advance more aggressively
        if (piece.rank === 9) s += adv * 3;

        // Strong pieces advance moderately
        if (piece.rank <= 3) s += adv * 1.5;

        // Don't wander backwards too much
        if (adv < 0 && r > 5) s -= 3;
      }

      // Randomness for variety
      s += (Math.random() - 0.3) * 4;
      return s;
    }

    function aiTakeTurn() {
      let bestMove = null, bestS = -Infinity;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const p = board[r][c];
          if (!p || p.owner !== 1 || !canMove(p)) continue;
          for (const move of getValidMoves(r, c)) {
            const s = aiScoreMove(r, c, move);
            if (s > bestS) { bestS = s; bestMove = { fr: r, fc: c, tr: move.r, tc: move.c }; }
          }
        }
      }

      if (bestMove) {
        doMove(bestMove.fr, bestMove.fc, bestMove.tr, bestMove.tc);
      }

      if (phase !== 'gameover') {
        if (!hasMovesLeft(0)) { endGame('lose'); return; }
        turn = 0;
        phase = 'play';
        message = 'Your turn';
      }
    }

    // ===================== RENDERING =====================

    function drawRoundedRect(x, y, w, h, rad) {
      ctx.beginPath();
      ctx.moveTo(x + rad, y);
      ctx.lineTo(x + w - rad, y);
      ctx.arcTo(x + w, y, x + w, y + rad, rad);
      ctx.lineTo(x + w, y + h - rad);
      ctx.arcTo(x + w, y + h, x + w - rad, y + h, rad);
      ctx.lineTo(x + rad, y + h);
      ctx.arcTo(x, y + h, x, y + h - rad, rad);
      ctx.lineTo(x, y + rad);
      ctx.arcTo(x, y, x + rad, y, rad);
      ctx.closePath();
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Background
      ctx.fillStyle = '#0d0d18';
      ctx.fillRect(0, 0, W, H);

      // Top status area
      ctx.fillStyle = '#111122';
      ctx.fillRect(0, 0, W, BOARD_Y - 2);
      drawStatusBar();

      // Board bg
      ctx.fillStyle = C_BOARD;
      ctx.fillRect(BOARD_X, BOARD_Y, BOARD_W, BOARD_H);

      // Grid lines
      ctx.strokeStyle = C_GRID;
      ctx.lineWidth = 1;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(BOARD_X, BOARD_Y + r * CELL);
        ctx.lineTo(BOARD_X + BOARD_W, BOARD_Y + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(BOARD_X + c * CELL, BOARD_Y);
        ctx.lineTo(BOARD_X + c * CELL, BOARD_Y + BOARD_H);
        ctx.stroke();
      }

      // Lakes
      for (let r = 4; r <= 5; r++) {
        for (const cc of [[2,3],[6,7]]) {
          for (const c of cc) {
            const x = BOARD_X + c * CELL + 1, y = BOARD_Y + r * CELL + 1;
            ctx.fillStyle = C_LAKE;
            ctx.fillRect(x, y, CELL - 2, CELL - 2);
            // Water waves
            ctx.strokeStyle = '#1a4a6e';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
              const wy = y + 10 + i * 11;
              ctx.beginPath();
              ctx.moveTo(x + 5, wy);
              ctx.quadraticCurveTo(x + CELL * 0.25, wy - 4, x + CELL * 0.5, wy);
              ctx.quadraticCurveTo(x + CELL * 0.75, wy + 4, x + CELL - 7, wy);
              ctx.stroke();
            }
          }
        }
      }

      // Setup zone highlight
      if (phase === 'setup') {
        for (let r = 6; r < 10; r++) {
          for (let c = 0; c < COLS; c++) {
            if (!board[r][c] && !isLake(r, c)) {
              ctx.fillStyle = 'rgba(68, 136, 255, 0.06)';
              ctx.fillRect(BOARD_X + c * CELL + 1, BOARD_Y + r * CELL + 1, CELL - 2, CELL - 2);
            }
          }
        }
      }

      // Valid move highlights
      for (const m of validMoves) {
        const x = BOARD_X + m.c * CELL, y = BOARD_Y + m.r * CELL;
        if (m.attack) {
          ctx.fillStyle = 'rgba(255, 60, 60, 0.25)';
          ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
          ctx.strokeStyle = 'rgba(255, 60, 60, 0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 3, y + 3, CELL - 6, CELL - 6);
        } else {
          ctx.fillStyle = 'rgba(100, 255, 100, 0.15)';
          ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
          ctx.fillStyle = 'rgba(100, 255, 100, 0.4)';
          ctx.beginPath();
          ctx.arc(x + CELL / 2, y + CELL / 2, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Pieces
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (board[r][c]) drawPiece(r, c, board[r][c]);

      // Selected highlight
      if (selectedPiece) {
        const x = BOARD_X + selectedPiece.c * CELL;
        const y = BOARD_Y + selectedPiece.r * CELL;
        ctx.strokeStyle = THEME;
        ctx.lineWidth = 3;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 12;
        ctx.strokeRect(x + 2, y + 2, CELL - 4, CELL - 4);
        ctx.shadowBlur = 0;
      }

      // Battle popup
      if (lastBattle && battleTimer > 0) drawBattlePopup();

      // Captured panel
      drawCapturedPanel();
    }

    function drawStatusBar() {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (phase === 'setup') {
        const p = setupPieces[setupIndex];
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 8;
        ctx.font = 'bold 14px "Courier New"';
        ctx.fillText('SETUP: Place ' + p.name + ' (' + (setupIndex + 1) + '/' + setupPieces.length + ')', W / 2, 18);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#777';
        ctx.font = '11px "Courier New"';
        ctx.fillText('Click rows 7-10  |  Right-click: auto-place all', W / 2, 38);
      } else if (phase === 'play') {
        ctx.fillStyle = C_PLAYER;
        ctx.shadowColor = C_PLAYER;
        ctx.shadowBlur = 8;
        ctx.font = 'bold 14px "Courier New"';
        ctx.fillText('YOUR TURN', W / 2, 18);
        ctx.shadowBlur = 0;
        if (message) {
          ctx.fillStyle = '#777';
          ctx.font = '11px "Courier New"';
          ctx.fillText(message, W / 2, 38);
        }
      } else if (phase === 'aiTurn') {
        ctx.fillStyle = C_AI;
        ctx.shadowColor = C_AI;
        ctx.shadowBlur = 8;
        ctx.font = 'bold 14px "Courier New"';
        ctx.fillText('AI THINKING...', W / 2, 28);
        ctx.shadowBlur = 0;
      } else if (phase === 'gameover') {
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 10;
        ctx.font = 'bold 16px "Courier New"';
        ctx.fillText('GAME OVER', W / 2, 28);
        ctx.shadowBlur = 0;
      }
    }

    function drawPiece(r, c, piece) {
      const x = BOARD_X + c * CELL;
      const y = BOARD_Y + r * CELL;
      const pad = 3;
      const isPlayer = piece.owner === 0;
      const showInfo = isPlayer || piece.revealed || phase === 'gameover';

      // Background
      const baseColor = isPlayer ? (showInfo ? C_PLAYER : C_PLAYER_DIM) : (showInfo ? C_AI : C_AI_DIM);
      ctx.fillStyle = baseColor;
      if (showInfo) {
        ctx.shadowColor = isPlayer ? C_PLAYER : C_AI;
        ctx.shadowBlur = 6;
      }
      drawRoundedRect(x + pad, y + pad, CELL - pad * 2, CELL - pad * 2, 4);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Border
      ctx.strokeStyle = isPlayer ? C_PLAYER_LITE : C_AI_LITE;
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (showInfo) {
        if (piece.rank === 0) {
          // Bomb - asterisk symbol
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 20px "Courier New"';
          ctx.fillText('*', x + CELL / 2, y + CELL / 2 - 2);
          ctx.font = '8px "Courier New"';
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.fillText('BOMB', x + CELL / 2, y + CELL / 2 + 13);
        } else if (piece.rank === 99) {
          // Flag - triangle pennant
          ctx.fillStyle = '#ffdd44';
          ctx.font = 'bold 18px "Courier New"';
          ctx.fillText('F', x + CELL / 2, y + CELL / 2 - 2);
          ctx.font = '8px "Courier New"';
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.fillText('FLAG', x + CELL / 2, y + CELL / 2 + 13);
        } else {
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 17px "Courier New"';
          ctx.fillText('' + piece.rank, x + CELL / 2, y + CELL / 2 - 5);
          ctx.font = '8px "Courier New"';
          ctx.fillStyle = 'rgba(255,255,255,0.75)';
          ctx.fillText(piece.abbr, x + CELL / 2, y + CELL / 2 + 11);
        }
      } else {
        // Hidden: question mark
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.font = 'bold 20px "Courier New"';
        ctx.fillText('?', x + CELL / 2, y + CELL / 2);
      }
    }

    function drawBattlePopup() {
      const b = lastBattle;
      const alpha = Math.min(1.0, battleTimer / 25);
      ctx.save();
      ctx.globalAlpha = alpha;

      const px = W / 2, py = BOARD_Y + BOARD_H / 2;
      const pw = 240, ph = 80;

      ctx.fillStyle = 'rgba(8, 8, 16, 0.94)';
      ctx.strokeStyle = THEME;
      ctx.lineWidth = 2;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 20;
      drawRoundedRect(px - pw / 2, py - ph / 2, pw, ph, 8);
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Attacker
      ctx.fillStyle = b.attacker.owner === 0 ? C_PLAYER : C_AI;
      ctx.font = 'bold 12px "Courier New"';
      const atkLabel = b.attacker.name + ' (' + (b.attacker.rank === 0 ? 'B' : b.attacker.rank === 99 ? 'F' : b.attacker.rank) + ')';
      ctx.fillText(atkLabel, px - 60, py - 18);

      // VS
      ctx.fillStyle = '#888';
      ctx.font = 'bold 14px "Courier New"';
      ctx.fillText('vs', px, py - 18);

      // Defender
      ctx.fillStyle = b.defender.owner === 0 ? C_PLAYER : C_AI;
      ctx.font = 'bold 12px "Courier New"';
      const defLabel = b.defender.name + ' (' + (b.defender.rank === 0 ? 'B' : b.defender.rank === 99 ? 'F' : b.defender.rank) + ')';
      ctx.fillText(defLabel, px + 60, py - 18);

      // Result
      ctx.font = 'bold 14px "Courier New"';
      if (b.result === 'attacker') {
        const won = b.attacker.owner === 0;
        ctx.fillStyle = won ? '#44ff88' : '#ff4444';
        ctx.fillText(won ? 'You win the battle!' : 'AI wins the battle!', px, py + 15);
      } else if (b.result === 'defender') {
        const won = b.defender.owner === 0;
        ctx.fillStyle = won ? '#44ff88' : '#ff4444';
        ctx.fillText(won ? 'Your piece holds!' : 'AI piece holds!', px, py + 15);
      } else {
        ctx.fillStyle = '#ffcc44';
        ctx.fillText('Both destroyed!', px, py + 15);
      }

      ctx.restore();
    }

    function drawCapturedPanel() {
      ctx.fillStyle = '#0a0a14';
      ctx.fillRect(0, PANEL_Y, W, H - PANEL_Y);

      ctx.font = '10px "Courier New"';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      const y0 = PANEL_Y + 4;
      // Your captures
      ctx.fillStyle = C_PLAYER;
      ctx.fillText('Your captures:', BOARD_X, y0);
      for (let i = 0; i < Math.min(aiCaptured.length, 20); i++) {
        const p = aiCaptured[i];
        const bx = BOARD_X + i * 22, by = y0 + 14;
        ctx.fillStyle = 'rgba(255,68,68,0.25)';
        ctx.fillRect(bx, by, 20, 16);
        ctx.fillStyle = '#ff8888';
        ctx.textAlign = 'center';
        ctx.font = '9px "Courier New"';
        ctx.fillText(p.rank === 0 ? 'B' : p.rank === 99 ? 'F' : '' + p.rank, bx + 10, by + 3);
      }

      // AI captures
      ctx.textAlign = 'left';
      ctx.font = '10px "Courier New"';
      ctx.fillStyle = C_AI;
      ctx.fillText('AI captures:', BOARD_X + 260, y0);
      for (let i = 0; i < Math.min(playerCaptured.length, 10); i++) {
        const p = playerCaptured[i];
        const bx = BOARD_X + 260 + i * 22, by = y0 + 14;
        ctx.fillStyle = 'rgba(68,136,255,0.25)';
        ctx.fillRect(bx, by, 20, 16);
        ctx.fillStyle = '#88aaff';
        ctx.textAlign = 'center';
        ctx.font = '9px "Courier New"';
        ctx.fillText(p.rank === 0 ? 'B' : p.rank === 99 ? 'F' : '' + p.rank, bx + 10, by + 3);
      }
    }

    // ===================== INPUT =====================

    function getCellFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);
      const c = Math.floor((mx - BOARD_X) / CELL);
      const r = Math.floor((my - BOARD_Y) / CELL);
      if (r >= 0 && r < ROWS && c >= 0 && c < COLS) return { r, c };
      return null;
    }

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'over') {
        gameState = 'waiting';
        overlayTitle.textContent = 'STRATEGO DIGITAL';
        overlayText.textContent = 'Click to Start';
        overlay.style.display = 'flex';
        return;
      }

      const cell = getCellFromMouse(e);
      if (!cell) return;

      if (phase === 'setup') handleSetupClick(cell);
      else if (phase === 'play') handlePlayClick(cell);
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (phase === 'setup') autoPlaceRemaining();
    });

    function handleSetupClick(cell) {
      const { r, c } = cell;
      if (r < 6 || r > 9 || isLake(r, c) || board[r][c]) return;

      const piece = setupPieces[setupIndex];
      board[r][c] = { owner: 0, ...piece, revealed: false };
      setupIndex++;

      if (setupIndex >= setupPieces.length) finishSetup();
    }

    function autoPlaceRemaining() {
      const empties = [];
      for (let r = 6; r < 10; r++)
        for (let c = 0; c < COLS; c++)
          if (!board[r][c] && !isLake(r, c)) empties.push({ r, c });
      shuffle(empties);

      while (setupIndex < setupPieces.length && empties.length > 0) {
        const cell = empties.shift();
        board[cell.r][cell.c] = { owner: 0, ...setupPieces[setupIndex], revealed: false };
        setupIndex++;
      }
      if (setupIndex >= setupPieces.length) finishSetup();
    }

    function finishSetup() {
      phase = 'play';
      turn = 0;
      aiKnownMovable = new Set();
      message = 'Your turn - select a piece';
    }

    function handlePlayClick(cell) {
      const { r, c } = cell;

      // If we have a selection, check for valid move
      if (selectedPiece) {
        const vm = validMoves.find(m => m.r === r && m.c === c);
        if (vm) {
          doMove(selectedPiece.r, selectedPiece.c, r, c);
          selectedPiece = null;
          validMoves = [];

          if (phase !== 'gameover') {
            turn = 1;
            phase = 'aiTurn';
            message = '';
            setTimeout(() => { if (phase === 'aiTurn') aiTakeTurn(); }, 650);
          }
          return;
        }
      }

      // Select own piece
      if (board[r][c] && board[r][c].owner === 0) {
        if (canMove(board[r][c])) {
          const moves = getValidMoves(r, c);
          if (moves.length > 0) {
            selectedPiece = { r, c };
            validMoves = moves;
            message = board[r][c].name + ' selected';
          } else {
            message = 'No moves available';
            messageTimer = 60;
            selectedPiece = null;
            validMoves = [];
          }
        } else {
          message = board[r][c].name + ' cannot move';
          messageTimer = 60;
          selectedPiece = null;
          validMoves = [];
        }
      } else {
        selectedPiece = null;
        validMoves = [];
      }
    }

    // ===================== GAME INIT & LOOP =====================

    function startGame() {
      initBoard();
      placeAIPieces();
      setupPieces = getSetupOrder();
      setupIndex = 0;
      phase = 'setup';
      selectedPiece = null;
      validMoves = [];
      score = 0;
      scoreEl.textContent = '0';
      turn = 0;
      lastBattle = null;
      battleTimer = 0;
      aiCaptured = [];
      playerCaptured = [];
      aiKnownMovable = new Set();
      message = 'Place your pieces on rows 7-10';
      messageTimer = 0;
      overlay.style.display = 'none';
      gameState = 'playing';
    }

    function update() {
      if (battleTimer > 0) battleTimer--;
      if (messageTimer > 0) { messageTimer--; if (messageTimer === 0 && phase === 'play') message = 'Your turn'; }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    overlay.style.display = 'flex';
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

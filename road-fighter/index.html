<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Road Fighter</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #4ca; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 204, 170, 0.5); }
    h1 { color: #4ca; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 204, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4ca; }
    canvas {
      border: 2px solid #4ca;
      box-shadow: 0 0 20px rgba(68, 204, 170, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4ca;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ROAD FIGHTER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">ROAD FIGHTER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ── Theme ──
    const THEME = '#4ca';
    const THEME_RGB = '68, 204, 170';

    // ── Road geometry ──
    const ROAD_LEFT = 60;
    const ROAD_RIGHT = 340;
    const ROAD_W = ROAD_RIGHT - ROAD_LEFT;
    const LANE_COUNT = 4;
    const LANE_W = ROAD_W / LANE_COUNT;
    const SHOULDER_W = 10;

    // ── Player car ──
    const CAR_W = 32;
    const CAR_H = 56;
    const PLAYER_Y = H - 100;
    const STEER_SPEED = 4.5;
    const ACCEL_BOOST = 0.3;
    const BRAKE_SLOW = 0.4;

    // ── Game constants ──
    const BASE_SPEED = 3;
    const MAX_SPEED = 10;
    const SPEED_RAMP_TIME = 7200; // frames to reach max difficulty (~2 min at 60fps)

    const FUEL_MAX = 100;
    const FUEL_DRAIN_BASE = 0.015; // per frame at base speed
    const FUEL_PICKUP_AMOUNT = 25;

    const SPAWN_INTERVAL_START = 70; // frames between traffic spawns
    const SPAWN_INTERVAL_MIN = 20;

    const OBSTACLE_SPAWN_CHANCE = 0.12; // chance per spawn cycle to spawn obstacle instead of car
    const FUEL_SPAWN_INTERVAL = 300; // frames between fuel pickup spawns
    const BOOST_SPAWN_INTERVAL = 500; // frames between speed boost zone spawns

    const STAGE_LENGTH = 2000; // score points per stage

    // ── State ──
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let fuel, speed, playerX, stage, stageProgress;
    let trafficCars, obstacles, fuelPickups, boostZones;
    let roadOffset, spawnTimer, fuelSpawnTimer, boostSpawnTimer, frameCount;
    let keys = {};
    let crashTimer, crashX, crashY;
    let invincibleTimer;
    let speedBoostTimer;
    let screenShake;

    // ── Traffic car types ──
    const TRAFFIC_COLORS = [
      { body: '#e44', accent: '#f66' },
      { body: '#48f', accent: '#6af' },
      { body: '#fa0', accent: '#fc4' },
      { body: '#f0f', accent: '#f6f' },
      { body: '#ff0', accent: '#ff8' },
      { body: '#0f8', accent: '#4fa' }
    ];

    // ── Initialize ──
    function init() {
      score = 0;
      fuel = FUEL_MAX;
      speed = BASE_SPEED;
      playerX = W / 2 - CAR_W / 2;
      stage = 1;
      stageProgress = 0;
      trafficCars = [];
      obstacles = [];
      fuelPickups = [];
      boostZones = [];
      roadOffset = 0;
      spawnTimer = 0;
      fuelSpawnTimer = 0;
      boostSpawnTimer = 0;
      frameCount = 0;
      crashTimer = 0;
      invincibleTimer = 0;
      speedBoostTimer = 0;
      screenShake = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ROAD FIGHTER';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Stage: ${stage} — Press any key`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── Difficulty ──
    function difficulty() {
      return Math.min(frameCount / SPEED_RAMP_TIME, 1);
    }

    function currentMaxSpeed() {
      return BASE_SPEED + difficulty() * (MAX_SPEED - BASE_SPEED);
    }

    function spawnInterval() {
      return Math.max(SPAWN_INTERVAL_MIN, SPAWN_INTERVAL_START - difficulty() * (SPAWN_INTERVAL_START - SPAWN_INTERVAL_MIN));
    }

    // ── Spawn helpers ──
    function randomLaneX() {
      const lane = Math.floor(Math.random() * LANE_COUNT);
      return ROAD_LEFT + lane * LANE_W + (LANE_W - CAR_W) / 2;
    }

    function spawnTrafficCar() {
      const colorSet = TRAFFIC_COLORS[Math.floor(Math.random() * TRAFFIC_COLORS.length)];
      const x = randomLaneX();
      // Traffic moves slower than player (scroll relative speed)
      const relSpeed = 0.3 + Math.random() * 0.5;
      // Some cars swerve
      const swerve = Math.random() < 0.15 ? (Math.random() - 0.5) * 1.5 : 0;
      trafficCars.push({
        x, y: -CAR_H - Math.random() * 40,
        w: CAR_W, h: CAR_H,
        relSpeed,
        swerve,
        swervePhase: Math.random() * Math.PI * 2,
        color: colorSet
      });
    }

    function spawnObstacle() {
      const types = ['oil', 'rock', 'cone'];
      const type = types[Math.floor(Math.random() * types.length)];
      const x = ROAD_LEFT + SHOULDER_W + Math.random() * (ROAD_W - SHOULDER_W * 2 - 24);
      obstacles.push({
        x, y: -30,
        w: 24, h: 24,
        type
      });
    }

    function spawnFuelPickup() {
      const x = randomLaneX() + (CAR_W - 20) / 2;
      fuelPickups.push({
        x, y: -30,
        w: 20, h: 20,
        pulse: 0
      });
    }

    function spawnBoostZone() {
      const lane = Math.floor(Math.random() * LANE_COUNT);
      const x = ROAD_LEFT + lane * LANE_W;
      boostZones.push({
        x, y: -120,
        w: LANE_W, h: 100
      });
    }

    // ── Collision (AABB) ──
    function collides(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // ── Update ──
    function update() {
      frameCount++;

      // Handle crash animation
      if (crashTimer > 0) {
        crashTimer--;
        screenShake = crashTimer > 0 ? (Math.random() - 0.5) * 6 : 0;
        if (crashTimer === 0) {
          invincibleTimer = 90; // ~1.5 seconds of invincibility after crash
          fuel -= 15; // lose some fuel on crash
          if (fuel <= 0) {
            gameOver();
            return;
          }
        }
        return; // freeze gameplay during crash
      }

      // Invincibility countdown
      if (invincibleTimer > 0) invincibleTimer--;

      // Speed boost countdown
      if (speedBoostTimer > 0) speedBoostTimer--;

      // Player steering
      let effectiveSpeed = speed;
      if (keys['ArrowUp'] || keys['w']) {
        effectiveSpeed = Math.min(currentMaxSpeed(), speed + ACCEL_BOOST);
      }
      if (keys['ArrowDown'] || keys['s']) {
        effectiveSpeed = Math.max(BASE_SPEED * 0.5, speed - BRAKE_SLOW);
      }
      speed = effectiveSpeed;

      if (speedBoostTimer > 0) {
        speed = Math.min(MAX_SPEED * 1.2, speed + 1.5);
      }

      if (keys['ArrowLeft'] || keys['a']) playerX -= STEER_SPEED + speed * 0.15;
      if (keys['ArrowRight'] || keys['d']) playerX += STEER_SPEED + speed * 0.15;

      // Clamp player to road with slight penalty for shoulder
      if (playerX < ROAD_LEFT) {
        playerX = ROAD_LEFT;
        speed = Math.max(BASE_SPEED * 0.5, speed - 0.2);
      }
      if (playerX + CAR_W > ROAD_RIGHT) {
        playerX = ROAD_RIGHT - CAR_W;
        speed = Math.max(BASE_SPEED * 0.5, speed - 0.2);
      }

      // Fuel drain (faster at higher speeds)
      const fuelDrain = FUEL_DRAIN_BASE * (0.7 + speed / MAX_SPEED * 0.6);
      fuel -= fuelDrain;
      if (fuel <= 0) {
        fuel = 0;
        gameOver();
        return;
      }

      // Scroll road
      roadOffset = (roadOffset + speed * 3) % 40;

      // Score
      const scoreGain = Math.floor(speed * 0.5);
      score += scoreGain;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Stage progression
      stageProgress += scoreGain;
      if (stageProgress >= STAGE_LENGTH) {
        stageProgress -= STAGE_LENGTH;
        stage++;
      }

      // ── Spawn traffic ──
      spawnTimer++;
      if (spawnTimer >= spawnInterval()) {
        spawnTimer = 0;
        if (Math.random() < OBSTACLE_SPAWN_CHANCE) {
          spawnObstacle();
        } else {
          spawnTrafficCar();
          // At higher difficulty, sometimes spawn pairs
          if (difficulty() > 0.4 && Math.random() < 0.3) {
            spawnTrafficCar();
          }
        }
      }

      // Spawn fuel pickups
      fuelSpawnTimer++;
      if (fuelSpawnTimer >= FUEL_SPAWN_INTERVAL) {
        fuelSpawnTimer = 0;
        spawnFuelPickup();
      }

      // Spawn boost zones
      boostSpawnTimer++;
      if (boostSpawnTimer >= BOOST_SPAWN_INTERVAL) {
        boostSpawnTimer = 0;
        spawnBoostZone();
      }

      // ── Update traffic ──
      for (let i = trafficCars.length - 1; i >= 0; i--) {
        const car = trafficCars[i];
        car.y += speed * (1 - car.relSpeed) * 2;
        // Swerving
        if (car.swerve !== 0) {
          car.swervePhase += 0.03;
          car.x += Math.sin(car.swervePhase) * car.swerve;
          // Clamp to road
          car.x = Math.max(ROAD_LEFT, Math.min(ROAD_RIGHT - car.w, car.x));
        }
        // Remove off-screen
        if (car.y > H + 20) {
          trafficCars.splice(i, 1);
          continue;
        }
        // Collision with player
        if (invincibleTimer === 0 && collides(playerX, PLAYER_Y, CAR_W, CAR_H, car.x, car.y, car.w, car.h)) {
          crashTimer = 30;
          crashX = playerX;
          crashY = PLAYER_Y;
          trafficCars.splice(i, 1);
          speed = BASE_SPEED;
          continue;
        }
      }

      // ── Update obstacles ──
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.y += speed * 2;
        if (obs.y > H + 20) {
          obstacles.splice(i, 1);
          continue;
        }
        if (invincibleTimer === 0 && collides(playerX + 4, PLAYER_Y + 4, CAR_W - 8, CAR_H - 8, obs.x, obs.y, obs.w, obs.h)) {
          if (obs.type === 'oil') {
            // Oil slick: random slide
            playerX += (Math.random() - 0.5) * 60;
            playerX = Math.max(ROAD_LEFT, Math.min(ROAD_RIGHT - CAR_W, playerX));
          } else {
            // Rock/cone: small crash
            crashTimer = 15;
            crashX = playerX;
            crashY = PLAYER_Y;
            speed = Math.max(BASE_SPEED * 0.5, speed - 2);
          }
          obstacles.splice(i, 1);
          continue;
        }
      }

      // ── Update fuel pickups ──
      for (let i = fuelPickups.length - 1; i >= 0; i--) {
        const fp = fuelPickups[i];
        fp.y += speed * 2;
        fp.pulse += 0.1;
        if (fp.y > H + 20) {
          fuelPickups.splice(i, 1);
          continue;
        }
        if (collides(playerX, PLAYER_Y, CAR_W, CAR_H, fp.x, fp.y, fp.w, fp.h)) {
          fuel = Math.min(FUEL_MAX, fuel + FUEL_PICKUP_AMOUNT);
          score += 50;
          scoreEl.textContent = score;
          fuelPickups.splice(i, 1);
          continue;
        }
      }

      // ── Update boost zones ──
      for (let i = boostZones.length - 1; i >= 0; i--) {
        const bz = boostZones[i];
        bz.y += speed * 2;
        if (bz.y > H + 20) {
          boostZones.splice(i, 1);
          continue;
        }
        if (collides(playerX, PLAYER_Y, CAR_W, CAR_H, bz.x, bz.y, bz.w, bz.h)) {
          speedBoostTimer = 60; // 1 second of boost
          score += 20;
          scoreEl.textContent = score;
        }
      }

      // Update gameData for potential future ML extraction
      window.gameData = {
        playerX, speed, fuel, stage,
        trafficCount: trafficCars.length,
        obstacleCount: obstacles.length
      };
    }

    // ── Drawing ──
    function draw() {
      ctx.save();

      // Screen shake
      if (screenShake) {
        ctx.translate((Math.random() - 0.5) * screenShake * 2, (Math.random() - 0.5) * screenShake * 2);
      }

      // Sky / background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Road surface
      ctx.fillStyle = '#222';
      ctx.fillRect(ROAD_LEFT, 0, ROAD_W, H);

      // Road shoulder stripes (left)
      drawShoulderStripes(ROAD_LEFT, ROAD_LEFT + SHOULDER_W);
      // Road shoulder stripes (right)
      drawShoulderStripes(ROAD_RIGHT - SHOULDER_W, ROAD_RIGHT);

      // Lane dashes
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.setLineDash([20, 20]);
      for (let lane = 1; lane < LANE_COUNT; lane++) {
        const lx = ROAD_LEFT + lane * LANE_W;
        ctx.beginPath();
        ctx.moveTo(lx, -40 + (roadOffset % 40));
        for (let y = -40 + (roadOffset % 40); y < H + 40; y += 40) {
          ctx.moveTo(lx, y);
          ctx.lineTo(lx, y + 20);
        }
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Road edge lines (solid)
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(ROAD_LEFT, 0);
      ctx.lineTo(ROAD_LEFT, H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(ROAD_RIGHT, 0);
      ctx.lineTo(ROAD_RIGHT, H);
      ctx.stroke();

      // Grass/terrain on sides
      drawTerrain();

      // ── Draw boost zones ──
      boostZones.forEach(bz => {
        ctx.fillStyle = 'rgba(68, 204, 170, 0.12)';
        ctx.fillRect(bz.x, bz.y, bz.w, bz.h);
        // Chevrons
        ctx.strokeStyle = 'rgba(68, 204, 170, 0.4)';
        ctx.lineWidth = 2;
        const chevronSpacing = 20;
        const offset = (roadOffset * 2) % chevronSpacing;
        for (let cy = bz.y + offset; cy < bz.y + bz.h; cy += chevronSpacing) {
          if (cy < bz.y || cy > bz.y + bz.h) continue;
          ctx.beginPath();
          ctx.moveTo(bz.x + 5, cy + 8);
          ctx.lineTo(bz.x + bz.w / 2, cy);
          ctx.lineTo(bz.x + bz.w - 5, cy + 8);
          ctx.stroke();
        }
      });

      // ── Draw obstacles ──
      obstacles.forEach(obs => {
        if (obs.type === 'oil') {
          drawOilSlick(obs);
        } else if (obs.type === 'rock') {
          drawRock(obs);
        } else {
          drawCone(obs);
        }
      });

      // ── Draw fuel pickups ──
      fuelPickups.forEach(fp => {
        const glow = 0.5 + Math.sin(fp.pulse) * 0.3;
        ctx.fillStyle = `rgba(0, 255, 100, ${glow})`;
        ctx.shadowColor = '#0f8';
        ctx.shadowBlur = 12;
        // Fuel can shape
        const cx = fp.x + fp.w / 2;
        const cy = fp.y + fp.h / 2;
        ctx.beginPath();
        ctx.roundRect(fp.x + 2, fp.y + 4, fp.w - 4, fp.h - 4, 3);
        ctx.fill();
        // Handle
        ctx.fillRect(fp.x + 6, fp.y, 8, 6);
        // "F" label
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#1a1a2e';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('F', cx, cy + 2);
      });
      ctx.shadowBlur = 0;

      // ── Draw traffic cars ──
      trafficCars.forEach(car => {
        drawTrafficCar(car);
      });

      // ── Draw player car ──
      if (crashTimer > 0) {
        drawExplosion(crashX, crashY);
      } else {
        const blink = invincibleTimer > 0 && Math.floor(invincibleTimer / 4) % 2 === 0;
        if (!blink) {
          drawPlayerCar(playerX, PLAYER_Y);
        }
      }

      // ── HUD: Fuel bar ──
      drawFuelBar();

      // ── HUD: Speed indicator ──
      drawSpeedometer();

      // ── HUD: Stage indicator ──
      drawStageHUD();

      // ── Boost visual effect ──
      if (speedBoostTimer > 0) {
        ctx.fillStyle = `rgba(68, 204, 170, ${0.05 + Math.random() * 0.05})`;
        ctx.fillRect(0, 0, W, H);
        // Speed lines
        ctx.strokeStyle = `rgba(68, 204, 170, ${0.3 + Math.random() * 0.2})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 8; i++) {
          const lx = Math.random() * W;
          const ly = Math.random() * H;
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.lineTo(lx + (Math.random() - 0.5) * 4, ly + 30 + Math.random() * 40);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawShoulderStripes(x1, x2) {
      const stripeH = 10;
      const gap = 10;
      const total = stripeH + gap;
      const offset = (roadOffset * 2) % total;
      ctx.fillStyle = '#c33';
      for (let y = -total + offset; y < H + total; y += total) {
        ctx.fillRect(x1, y, x2 - x1, stripeH);
      }
      ctx.fillStyle = '#eee';
      for (let y = -total + offset + stripeH; y < H + total; y += total) {
        ctx.fillRect(x1, y, x2 - x1, gap);
      }
    }

    function drawTerrain() {
      // Left terrain
      const treeOffset = (roadOffset * 1.5) % 80;
      ctx.fillStyle = '#0a1a12';
      ctx.fillRect(0, 0, ROAD_LEFT, H);
      // Right terrain
      ctx.fillRect(ROAD_RIGHT, 0, W - ROAD_RIGHT, H);

      // Terrain details - small dots/grass
      ctx.fillStyle = '#1a3a2a';
      for (let y = -80 + treeOffset; y < H + 80; y += 80) {
        // Left side trees
        drawTree(20, y);
        drawTree(40, y + 40);
        // Right side trees
        drawTree(W - 20, y + 20);
        drawTree(W - 45, y + 60);
      }
    }

    function drawTree(x, y) {
      // Trunk
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(x - 2, y + 8, 4, 8);
      // Canopy
      ctx.fillStyle = '#1a4a2a';
      ctx.shadowColor = '#0f4';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.arc(x, y + 6, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawPlayerCar(x, y) {
      ctx.save();

      // Car body
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 15;

      // Main body
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 8, CAR_W - 4, CAR_H - 12, 4);
      ctx.fill();

      // Windshield
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#2a4a5a';
      ctx.beginPath();
      ctx.roundRect(x + 6, y + 14, CAR_W - 12, 14, 2);
      ctx.fill();

      // Cabin highlight
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(x + 6, y + 14, CAR_W - 12, 7);

      // Rear section
      ctx.fillStyle = '#3a9a7a';
      ctx.beginPath();
      ctx.roundRect(x + 4, y + CAR_H - 18, CAR_W - 8, 12, 2);
      ctx.fill();

      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(x - 1, y + 12, 5, 12);
      ctx.fillRect(x + CAR_W - 4, y + 12, 5, 12);
      ctx.fillRect(x - 1, y + CAR_H - 20, 5, 12);
      ctx.fillRect(x + CAR_W - 4, y + CAR_H - 20, 5, 12);

      // Headlights
      ctx.fillStyle = '#ff8';
      ctx.shadowColor = '#ff8';
      ctx.shadowBlur = 8;
      ctx.fillRect(x + 5, y + 2, 6, 4);
      ctx.fillRect(x + CAR_W - 11, y + 2, 6, 4);
      ctx.shadowBlur = 0;

      // Tail lights
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      ctx.fillRect(x + 4, y + CAR_H - 6, 6, 3);
      ctx.fillRect(x + CAR_W - 10, y + CAR_H - 6, 6, 3);
      ctx.shadowBlur = 0;

      // Speed boost exhaust
      if (speedBoostTimer > 0 || keys['ArrowUp'] || keys['w']) {
        const flameH = speedBoostTimer > 0 ? 12 + Math.random() * 8 : 4 + Math.random() * 4;
        ctx.fillStyle = speedBoostTimer > 0 ? `rgba(68, 204, 170, ${0.5 + Math.random() * 0.4})` : `rgba(255, 150, 50, ${0.4 + Math.random() * 0.3})`;
        ctx.shadowColor = speedBoostTimer > 0 ? THEME : '#f80';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(x + CAR_W / 2 - 5, y + CAR_H);
        ctx.lineTo(x + CAR_W / 2, y + CAR_H + flameH);
        ctx.lineTo(x + CAR_W / 2 + 5, y + CAR_H);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }

    function drawTrafficCar(car) {
      const x = car.x, y = car.y;

      // Body
      ctx.fillStyle = car.color.body;
      ctx.shadowColor = car.color.body;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 8, car.w - 4, car.h - 12, 4);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Accent stripe
      ctx.fillStyle = car.color.accent;
      ctx.fillRect(x + 6, y + car.h / 2 - 2, car.w - 12, 4);

      // Windshield (bottom for oncoming cars)
      ctx.fillStyle = '#2a3a4a';
      ctx.beginPath();
      ctx.roundRect(x + 6, y + car.h - 24, car.w - 12, 12, 2);
      ctx.fill();

      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(x - 1, y + 12, 5, 10);
      ctx.fillRect(x + car.w - 4, y + 12, 5, 10);
      ctx.fillRect(x - 1, y + car.h - 18, 5, 10);
      ctx.fillRect(x + car.w - 4, y + car.h - 18, 5, 10);

      // Headlights (at bottom since they face us)
      ctx.fillStyle = '#ff8';
      ctx.shadowColor = '#ff8';
      ctx.shadowBlur = 5;
      ctx.fillRect(x + 5, y + car.h - 6, 5, 3);
      ctx.fillRect(x + car.w - 10, y + car.h - 6, 5, 3);
      ctx.shadowBlur = 0;
    }

    function drawOilSlick(obs) {
      ctx.fillStyle = 'rgba(30, 30, 60, 0.7)';
      ctx.shadowColor = '#448';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.ellipse(obs.x + obs.w / 2, obs.y + obs.h / 2, obs.w / 2 + 2, obs.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      // Oily sheen
      ctx.fillStyle = 'rgba(80, 60, 140, 0.3)';
      ctx.beginPath();
      ctx.ellipse(obs.x + obs.w / 2 - 3, obs.y + obs.h / 2 - 2, obs.w / 3, obs.h / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawRock(obs) {
      ctx.fillStyle = '#667';
      ctx.shadowColor = '#99a';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.moveTo(obs.x + 4, obs.y + obs.h);
      ctx.lineTo(obs.x, obs.y + obs.h * 0.6);
      ctx.lineTo(obs.x + 6, obs.y);
      ctx.lineTo(obs.x + obs.w - 4, obs.y + 2);
      ctx.lineTo(obs.x + obs.w, obs.y + obs.h * 0.5);
      ctx.lineTo(obs.x + obs.w - 2, obs.y + obs.h);
      ctx.closePath();
      ctx.fill();
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath();
      ctx.moveTo(obs.x + 6, obs.y);
      ctx.lineTo(obs.x + obs.w - 4, obs.y + 2);
      ctx.lineTo(obs.x + obs.w / 2, obs.y + obs.h * 0.4);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawCone(obs) {
      // Orange cone
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.moveTo(obs.x + obs.w / 2, obs.y);
      ctx.lineTo(obs.x + obs.w - 2, obs.y + obs.h);
      ctx.lineTo(obs.x + 2, obs.y + obs.h);
      ctx.closePath();
      ctx.fill();
      // White stripes
      ctx.fillStyle = '#fff';
      ctx.fillRect(obs.x + obs.w / 2 - 5, obs.y + obs.h * 0.4, 10, 3);
      ctx.fillRect(obs.x + obs.w / 2 - 3, obs.y + obs.h * 0.2, 6, 2);
      ctx.shadowBlur = 0;
    }

    function drawExplosion(x, y) {
      const t = 1 - crashTimer / 30;
      const radius = 20 + t * 25;
      // Outer flash
      ctx.fillStyle = `rgba(255, ${Math.floor(150 - t * 150)}, 0, ${0.6 - t * 0.5})`;
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(x + CAR_W / 2, y + CAR_H / 2, radius, 0, Math.PI * 2);
      ctx.fill();
      // Inner core
      ctx.fillStyle = `rgba(255, 255, 200, ${0.8 - t * 0.8})`;
      ctx.beginPath();
      ctx.arc(x + CAR_W / 2, y + CAR_H / 2, radius * 0.4, 0, Math.PI * 2);
      ctx.fill();
      // Sparks
      ctx.fillStyle = '#ff8';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 + t * 2;
        const dist = radius * (0.6 + Math.random() * 0.5);
        const sx = x + CAR_W / 2 + Math.cos(angle) * dist;
        const sy = y + CAR_H / 2 + Math.sin(angle) * dist;
        ctx.fillRect(sx - 2, sy - 2, 4, 4);
      }
      ctx.shadowBlur = 0;
    }

    function drawFuelBar() {
      const barX = 8;
      const barY = 60;
      const barW = 14;
      const barH = 200;

      // Background
      ctx.fillStyle = '#111';
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(barX, barY, barW, barH, 4);
      ctx.fill();
      ctx.stroke();

      // Fuel level
      const fuelH = (fuel / FUEL_MAX) * (barH - 4);
      const fuelColor = fuel > 30 ? '#0f8' : fuel > 15 ? '#fa0' : '#f44';
      ctx.fillStyle = fuelColor;
      ctx.shadowColor = fuelColor;
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.roundRect(barX + 2, barY + (barH - 2 - fuelH), barW - 4, fuelH, 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Label
      ctx.fillStyle = '#888';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('F', barX + barW / 2, barY - 4);
      ctx.fillText('E', barX + barW / 2, barY + barH + 12);

      // Fuel warning flash
      if (fuel < 20 && Math.floor(frameCount / 15) % 2 === 0) {
        ctx.fillStyle = `rgba(255, 50, 50, 0.15)`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawSpeedometer() {
      const x = W - 50;
      const y = 70;
      const speedPct = (speed - BASE_SPEED * 0.5) / (MAX_SPEED * 1.2 - BASE_SPEED * 0.5);

      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('SPD', x, y - 8);

      // Speed bar (horizontal)
      ctx.fillStyle = '#111';
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(x - 16, y, 32, 8, 3);
      ctx.fill();
      ctx.stroke();

      const barColor = speedBoostTimer > 0 ? THEME : (speedPct > 0.7 ? '#f44' : '#4af');
      ctx.fillStyle = barColor;
      ctx.shadowColor = barColor;
      ctx.shadowBlur = 4;
      const sw = Math.max(0, speedPct * 28);
      ctx.beginPath();
      ctx.roundRect(x - 14, y + 2, sw, 4, 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // KMH text
      const kmh = Math.floor(speed * 20);
      ctx.fillStyle = barColor;
      ctx.font = 'bold 11px Courier New';
      ctx.fillText(kmh, x, y + 22);
      ctx.fillStyle = '#666';
      ctx.font = '8px Courier New';
      ctx.fillText('km/h', x, y + 32);
    }

    function drawStageHUD() {
      const x = W / 2;
      const y = 16;

      ctx.fillStyle = THEME;
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      ctx.fillText(`STAGE ${stage}`, x, y);
      ctx.shadowBlur = 0;

      // Progress bar
      const barW = 80;
      const barH = 4;
      const bx = x - barW / 2;
      const by = y + 6;
      ctx.fillStyle = '#222';
      ctx.fillRect(bx, by, barW, barH);
      ctx.fillStyle = THEME;
      ctx.fillRect(bx, by, barW * (stageProgress / STAGE_LENGTH), barH);
    }

    // ── Polyfill roundRect if needed ──
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (typeof r === 'number') r = [r, r, r, r];
        this.moveTo(x + r[0], y);
        this.lineTo(x + w - r[1], y);
        this.quadraticCurveTo(x + w, y, x + w, y + r[1]);
        this.lineTo(x + w, y + h - r[2]);
        this.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
        this.lineTo(x + r[3], y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r[3]);
        this.lineTo(x, y + r[0]);
        this.quadraticCurveTo(x, y, x + r[0], y);
        this.closePath();
        return this;
      };
    }

    // ── Keyboard handler ──
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
        e.preventDefault();
      }

      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

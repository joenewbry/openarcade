<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hex Empire</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f90; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 153, 0, 0.4); }
    h1 { color: #f90; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 153, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f90; }
    .turn-indicator {
      color: #aaa;
      font-size: 0.9rem;
    }
    .turn-indicator.player-turn { color: #4488ff; }
    .turn-indicator.ai-turn { color: #f90; }
    canvas {
      border: 2px solid #f90;
      box-shadow: 0 0 20px rgba(255, 153, 0, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f90;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>HEX EMPIRE</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="score">0</span> hexes</div>
    <div class="turn-indicator" id="turnIndicator"></div>
    <div>AI: <span id="aiScore">0</span> hexes</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">HEX EMPIRE</h2>
      <p id="overlayText">Click anywhere to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const turnIndicatorEl = document.getElementById('turnIndicator');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Prevent default on arrow keys and space
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ---- Constants ----
    const GRID_ROWS = 9;
    const GRID_COLS = 9;
    const HEX_SIZE = 28; // radius of hex (center to vertex)
    const OWNER_NONE = 0;
    const OWNER_PLAYER = 1;
    const OWNER_AI = 2;

    const COLOR_BG = '#1a1a2e';
    const COLOR_HEX_BORDER = '#16213e';
    const COLOR_NEUTRAL = '#333';
    const COLOR_NEUTRAL_BORDER = '#444';
    const COLOR_PLAYER = '#4488ff';
    const COLOR_PLAYER_GLOW = 'rgba(68, 136, 255, 0.35)';
    const COLOR_AI = '#f90';
    const COLOR_AI_GLOW = 'rgba(255, 153, 0, 0.35)';
    const COLOR_HIGHLIGHT = 'rgba(255, 255, 255, 0.25)';
    const COLOR_ATTACK_HIGHLIGHT = 'rgba(255, 80, 80, 0.35)';
    const COLOR_SELECTED = '#fff';

    // ---- Game State ----
    let gameState = 'waiting';
    let score = 0;
    let hexGrid = []; // 2D array of hex objects
    let selectedHex = null; // { row, col } of selected player hex
    let currentTurn = 'player'; // 'player' or 'ai'
    let turnNumber = 0;
    let playerCapital = null; // { row, col }
    let aiCapital = null; // { row, col }
    let validMoves = []; // array of { row, col } that are valid targets from selected hex
    let aiThinking = false;
    let animFrame = null;

    // ---- Hex Grid Geometry (flat-top hexagons) ----
    // Flat-top hex: pointy sides on left/right, flat on top/bottom
    // Width = 2 * size, Height = sqrt(3) * size
    const HEX_W = 2 * HEX_SIZE;
    const HEX_H = Math.sqrt(3) * HEX_SIZE;

    // Calculate grid offset to center it on canvas
    function getGridOffset() {
      // For flat-top hexagons:
      // Column spacing: 3/4 of hex width = 1.5 * size
      // Row spacing: hex height = sqrt(3) * size
      // Odd columns are shifted down by half a hex height
      const totalW = (GRID_COLS - 1) * 1.5 * HEX_SIZE + HEX_W;
      const totalH = GRID_ROWS * HEX_H + HEX_H * 0.5; // extra half for offset cols
      const ox = (W - totalW) / 2 + HEX_SIZE;
      const oy = (H - totalH) / 2 + HEX_H / 2;
      return { ox, oy };
    }

    function hexCenter(row, col) {
      const { ox, oy } = getGridOffset();
      const x = ox + col * 1.5 * HEX_SIZE;
      const y = oy + row * HEX_H + (col % 2 === 1 ? HEX_H / 2 : 0);
      return { x, y };
    }

    // Get hex neighbors (flat-top hex grid)
    function getNeighbors(row, col) {
      const neighbors = [];
      const even = col % 2 === 0;
      // Flat-top hex neighbors:
      // Same column: (row-1, col), (row+1, col)
      // Left column: (row + offset, col-1), (row + offset - 1, col-1)
      // Right column: (row + offset, col+1), (row + offset - 1, col+1)
      const dirs = even ? [
        [-1, 0], [1, 0],    // up, down
        [-1, -1], [0, -1],  // upper-left, lower-left
        [-1, 1], [0, 1]     // upper-right, lower-right
      ] : [
        [-1, 0], [1, 0],    // up, down
        [0, -1], [1, -1],   // upper-left, lower-left
        [0, 1], [1, 1]      // upper-right, lower-right
      ];
      for (const [dr, dc] of dirs) {
        const nr = row + dr;
        const nc = col + dc;
        if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < GRID_COLS) {
          neighbors.push({ row: nr, col: nc });
        }
      }
      return neighbors;
    }

    // ---- Hex Drawing ----
    function drawHexPath(cx, cy, size) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i);
        const vx = cx + size * Math.cos(angle);
        const vy = cy + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(vx, vy);
        else ctx.lineTo(vx, vy);
      }
      ctx.closePath();
    }

    function drawStar(cx, cy, spikes, outerR, innerR) {
      ctx.beginPath();
      let rot = -Math.PI / 2;
      for (let i = 0; i < spikes; i++) {
        const oAngle = rot + (i * 2 * Math.PI / spikes);
        const iAngle = oAngle + Math.PI / spikes;
        ctx.lineTo(cx + Math.cos(oAngle) * outerR, cy + Math.sin(oAngle) * outerR);
        ctx.lineTo(cx + Math.cos(iAngle) * innerR, cy + Math.sin(iAngle) * innerR);
      }
      ctx.closePath();
    }

    // ---- Game Initialization ----
    function createGrid() {
      hexGrid = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        hexGrid[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
          hexGrid[r][c] = {
            owner: OWNER_NONE,
            armies: 0,
            isCapital: false
          };
        }
      }
    }

    function init() {
      createGrid();
      selectedHex = null;
      validMoves = [];
      currentTurn = 'player';
      turnNumber = 0;
      aiThinking = false;
      score = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      turnIndicatorEl.textContent = '';
      turnIndicatorEl.className = 'turn-indicator';

      // Place capitals on opposite sides
      playerCapital = { row: Math.floor(GRID_ROWS / 2), col: 0 };
      aiCapital = { row: Math.floor(GRID_ROWS / 2), col: GRID_COLS - 1 };

      // Initialize player territory (capital + some adjacent)
      const pH = hexGrid[playerCapital.row][playerCapital.col];
      pH.owner = OWNER_PLAYER;
      pH.armies = 5;
      pH.isCapital = true;

      // Give player a couple starting hexes
      const pNeighbors = getNeighbors(playerCapital.row, playerCapital.col);
      for (let i = 0; i < Math.min(2, pNeighbors.length); i++) {
        const n = pNeighbors[i];
        hexGrid[n.row][n.col].owner = OWNER_PLAYER;
        hexGrid[n.row][n.col].armies = 2;
      }

      // Initialize AI territory (capital + some adjacent)
      const aH = hexGrid[aiCapital.row][aiCapital.col];
      aH.owner = OWNER_AI;
      aH.armies = 5;
      aH.isCapital = true;

      const aNeighbors = getNeighbors(aiCapital.row, aiCapital.col);
      for (let i = 0; i < Math.min(2, aNeighbors.length); i++) {
        const n = aNeighbors[i];
        hexGrid[n.row][n.col].owner = OWNER_AI;
        hexGrid[n.row][n.col].armies = 2;
      }

      // Give some neutral hexes starting armies
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (hexGrid[r][c].owner === OWNER_NONE) {
            hexGrid[r][c].armies = 1 + Math.floor(Math.random() * 2);
          }
        }
      }

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.style.color = '#f90';
      overlayTitle.textContent = 'HEX EMPIRE';
      overlayText.textContent = 'Click anywhere to start';
      updateScores();
      draw();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      currentTurn = 'player';
      updateTurnIndicator();
      generateArmies(OWNER_PLAYER);
      draw();
    }

    // ---- Army Generation ----
    function generateArmies(owner) {
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (hexGrid[r][c].owner === owner) {
            hexGrid[r][c].armies += 1;
            // Capitals generate extra
            if (hexGrid[r][c].isCapital) {
              hexGrid[r][c].armies += 1;
            }
          }
        }
      }
    }

    // ---- Combat ----
    function resolveAttack(fromRow, fromCol, toRow, toCol) {
      const attacker = hexGrid[fromRow][fromCol];
      const defender = hexGrid[toRow][toCol];

      if (attacker.armies <= 1) return false; // must leave at least 1 behind

      const attackForce = attacker.armies - 1; // leave 1 behind
      const defendForce = defender.armies;

      // Combat: attacker needs strictly more to capture
      // Add small random factor for unpredictability
      const atkRoll = attackForce + Math.random() * 1.5 - 0.75;
      const defRoll = defendForce + Math.random() * 1.5 - 0.75;

      if (atkRoll > defRoll) {
        // Attacker wins
        const survivingArmies = Math.max(1, Math.ceil(attackForce - defendForce * 0.6));
        const wasCapital = defender.isCapital;
        defender.owner = attacker.owner;
        defender.armies = survivingArmies;
        defender.isCapital = wasCapital ? false : defender.isCapital; // capture removes capital status from defender
        attacker.armies = 1;

        // If captured a capital, mark it as the attacker's normal hex
        if (wasCapital) {
          defender.isCapital = false;
        }
        return true;
      } else {
        // Defender wins - attacker loses armies
        const lostArmies = Math.max(1, Math.floor(attackForce * 0.5));
        attacker.armies = 1;
        defender.armies = Math.max(1, defender.armies - Math.floor(lostArmies * 0.3));
        return false;
      }
    }

    // ---- Move: expand into adjacent neutral hex ----
    function expandInto(fromRow, fromCol, toRow, toCol) {
      const source = hexGrid[fromRow][fromCol];
      const target = hexGrid[toRow][toCol];

      if (target.owner === OWNER_NONE) {
        // Expanding into neutral: treat neutral armies as defenders
        return resolveAttack(fromRow, fromCol, toRow, toCol);
      } else {
        // Attacking enemy
        return resolveAttack(fromRow, fromCol, toRow, toCol);
      }
    }

    // ---- Reinforce: move armies between own hexes ----
    function reinforce(fromRow, fromCol, toRow, toCol) {
      const source = hexGrid[fromRow][fromCol];
      const target = hexGrid[toRow][toCol];
      if (source.owner === target.owner && source.armies > 1) {
        const transfer = source.armies - 1;
        target.armies += transfer;
        source.armies = 1;
        return true;
      }
      return false;
    }

    // ---- Score Tracking ----
    function updateScores() {
      let playerCount = 0;
      let aiCount = 0;
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (hexGrid[r][c].owner === OWNER_PLAYER) playerCount++;
          else if (hexGrid[r][c].owner === OWNER_AI) aiCount++;
        }
      }
      score = playerCount;
      scoreEl.textContent = playerCount;
      aiScoreEl.textContent = aiCount;
      return { playerCount, aiCount };
    }

    function updateTurnIndicator() {
      if (currentTurn === 'player') {
        turnIndicatorEl.textContent = 'Your Turn';
        turnIndicatorEl.className = 'turn-indicator player-turn';
      } else {
        turnIndicatorEl.textContent = 'AI Thinking...';
        turnIndicatorEl.className = 'turn-indicator ai-turn';
      }
    }

    // ---- Victory Check ----
    function checkVictory() {
      const totalHexes = GRID_ROWS * GRID_COLS;
      const { playerCount, aiCount } = updateScores();

      // Check if player capital is captured
      if (hexGrid[playerCapital.row][playerCapital.col].owner === OWNER_AI) {
        endGame(false, 'Capital captured!');
        return true;
      }

      // Check if AI capital is captured
      if (hexGrid[aiCapital.row][aiCapital.col].owner === OWNER_PLAYER) {
        endGame(true, 'Enemy capital captured!');
        return true;
      }

      // Check 60% domination
      if (playerCount >= Math.ceil(totalHexes * 0.6)) {
        endGame(true, 'Territory domination!');
        return true;
      }
      if (aiCount >= Math.ceil(totalHexes * 0.6)) {
        endGame(false, 'AI achieved domination!');
        return true;
      }

      // Check if a side has no hexes left
      if (playerCount === 0) {
        endGame(false, 'All territory lost!');
        return true;
      }
      if (aiCount === 0) {
        endGame(true, 'AI eliminated!');
        return true;
      }

      return false;
    }

    function endGame(playerWon, reason) {
      gameState = 'over';
      overlay.style.display = 'flex';
      if (playerWon) {
        overlayTitle.textContent = 'VICTORY';
        overlayTitle.style.color = '#4488ff';
      } else {
        overlayTitle.textContent = 'DEFEAT';
        overlayTitle.style.color = '#f90';
      }
      overlayText.textContent = reason + ' Click to play again';
      turnIndicatorEl.textContent = '';
      draw();
    }

    // ---- Player Input ----
    function getHexAtPixel(px, py) {
      // Find which hex the point is in
      let closestDist = Infinity;
      let closestHex = null;
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const { x, y } = hexCenter(r, c);
          const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
          if (dist < HEX_SIZE * 0.9 && dist < closestDist) {
            closestDist = dist;
            closestHex = { row: r, col: c };
          }
        }
      }
      return closestHex;
    }

    function getValidTargets(row, col) {
      const hex = hexGrid[row][col];
      if (hex.owner !== OWNER_PLAYER || hex.armies <= 1) return [];
      const neighbors = getNeighbors(row, col);
      return neighbors.filter(n => {
        const target = hexGrid[n.row][n.col];
        return target.owner !== OWNER_PLAYER; // can attack neutral or AI hexes
      });
    }

    function getValidReinforceTargets(row, col) {
      const hex = hexGrid[row][col];
      if (hex.owner !== OWNER_PLAYER || hex.armies <= 1) return [];
      const neighbors = getNeighbors(row, col);
      return neighbors.filter(n => hexGrid[n.row][n.col].owner === OWNER_PLAYER);
    }

    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'over') {
        overlayTitle.style.color = '#f90';
        init();
        return;
      }
      if (gameState !== 'playing' || currentTurn !== 'player') return;

      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left) * (W / rect.width);
      const py = (e.clientY - rect.top) * (H / rect.height);
      const clicked = getHexAtPixel(px, py);
      if (!clicked) {
        // Clicked empty area - deselect
        selectedHex = null;
        validMoves = [];
        draw();
        return;
      }

      const clickedHex = hexGrid[clicked.row][clicked.col];

      if (e.button === 2) {
        // Right click - deselect
        selectedHex = null;
        validMoves = [];
        draw();
        return;
      }

      if (selectedHex) {
        // A hex is already selected, check if this is a valid target
        const isInMoveList = validMoves.some(m => m.row === clicked.row && m.col === clicked.col);
        const isNeighbor = getNeighbors(selectedHex.row, selectedHex.col).some(n => n.row === clicked.row && n.col === clicked.col);

        if (isInMoveList && isNeighbor && clickedHex.owner === OWNER_PLAYER) {
          // Reinforce adjacent friendly hex
          reinforce(selectedHex.row, selectedHex.col, clicked.row, clicked.col);
          selectedHex = null;
          validMoves = [];
          updateScores();
          draw();

          if (!checkVictory()) {
            endPlayerTurn();
          }
          return;
        } else if (isInMoveList && isNeighbor && clickedHex.owner !== OWNER_PLAYER) {
          // Execute attack/expansion
          expandInto(selectedHex.row, selectedHex.col, clicked.row, clicked.col);
          selectedHex = null;
          validMoves = [];
          updateScores();
          draw();

          if (!checkVictory()) {
            endPlayerTurn();
          }
          return;
        } else if (clickedHex.owner === OWNER_PLAYER && clickedHex.armies > 1) {
          // Select a different hex
          selectedHex = { row: clicked.row, col: clicked.col };
          validMoves = getValidTargets(clicked.row, clicked.col);
          // Also include friendly neighbors for reinforcement
          const friendly = getValidReinforceTargets(clicked.row, clicked.col);
          validMoves = validMoves.concat(friendly);
          draw();
          return;
        } else {
          // Invalid target - deselect
          selectedHex = null;
          validMoves = [];
          draw();
          return;
        }
      } else {
        // No hex selected yet
        if (clickedHex.owner === OWNER_PLAYER && clickedHex.armies > 1) {
          selectedHex = { row: clicked.row, col: clicked.col };
          validMoves = getValidTargets(clicked.row, clicked.col);
          const friendly = getValidReinforceTargets(clicked.row, clicked.col);
          validMoves = validMoves.concat(friendly);
          draw();
        }
      }
    });

    // Track mouse position for hover effects
    let hoverHex = null;
    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'playing' || currentTurn !== 'player') return;
      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left) * (W / rect.width);
      const py = (e.clientY - rect.top) * (H / rect.height);
      const newHover = getHexAtPixel(px, py);
      const changed = (!hoverHex && newHover) || (hoverHex && !newHover) ||
                      (hoverHex && newHover && (hoverHex.row !== newHover.row || hoverHex.col !== newHover.col));
      if (changed) {
        hoverHex = newHover;
        draw();
      }
    });

    // ---- Turn Management ----
    function endPlayerTurn() {
      currentTurn = 'ai';
      updateTurnIndicator();
      aiThinking = true;
      draw();

      // AI takes its turn after a short delay for visual feedback
      setTimeout(() => {
        aiTurn();
        aiThinking = false;
        if (gameState !== 'over') {
          turnNumber++;
          currentTurn = 'player';
          generateArmies(OWNER_PLAYER);
          updateTurnIndicator();
          updateScores();
          draw();
        }
      }, 400);
    }

    // ---- AI System ----
    function aiTurn() {
      generateArmies(OWNER_AI);

      // AI performs multiple actions per turn (up to 3)
      for (let action = 0; action < 3; action++) {
        if (gameState === 'over') return;
        const bestMove = findBestAIMove();
        if (!bestMove) break;

        if (bestMove.type === 'attack') {
          expandInto(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
        } else if (bestMove.type === 'reinforce') {
          reinforce(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
        }

        updateScores();
        if (checkVictory()) return;
      }
    }

    function findBestAIMove() {
      let bestScore = -Infinity;
      let bestMove = null;

      // Gather all AI hexes with armies > 1
      const aiHexes = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (hexGrid[r][c].owner === OWNER_AI && hexGrid[r][c].armies > 1) {
            aiHexes.push({ row: r, col: c });
          }
        }
      }

      for (const hex of aiHexes) {
        const neighbors = getNeighbors(hex.row, hex.col);
        const source = hexGrid[hex.row][hex.col];

        for (const n of neighbors) {
          const target = hexGrid[n.row][n.col];

          if (target.owner === OWNER_AI) {
            // Consider reinforcing toward the front line
            const reinforceScore = evaluateReinforce(hex, n);
            if (reinforceScore > bestScore) {
              bestScore = reinforceScore;
              bestMove = { type: 'reinforce', from: hex, to: n };
            }
          } else {
            // Consider attacking
            const attackScore = evaluateAttack(hex, n);
            if (attackScore > bestScore) {
              bestScore = attackScore;
              bestMove = { type: 'attack', from: hex, to: n };
            }
          }
        }
      }

      return bestMove;
    }

    function evaluateAttack(from, to) {
      const attacker = hexGrid[from.row][from.col];
      const defender = hexGrid[to.row][to.col];
      const attackForce = attacker.armies - 1;
      const defendForce = defender.armies;

      // Don't attack if we'd almost certainly lose
      if (attackForce <= defendForce * 0.6) return -100;

      let score = 0;

      // Base score: army advantage
      score += (attackForce - defendForce) * 5;

      // Huge bonus for attacking player capital
      if (to.row === playerCapital.row && to.col === playerCapital.col) {
        score += 200;
      }

      // Bonus for attacking player hexes vs neutral
      if (defender.owner === OWNER_PLAYER) {
        score += 30;
      } else {
        score += 10;
      }

      // Proximity to player capital bonus
      const distToPlayerCap = hexDistance(to.row, to.col, playerCapital.row, playerCapital.col);
      score += (GRID_COLS - distToPlayerCap) * 8;

      // Strategic value: hex with more enemy neighbors = more valuable
      const neighbors = getNeighbors(to.row, to.col);
      const enemyNeighborCount = neighbors.filter(n => hexGrid[n.row][n.col].owner === OWNER_PLAYER).length;
      score += enemyNeighborCount * 5;

      // Penalize attacking with insufficient force
      const ratio = attackForce / Math.max(1, defendForce);
      if (ratio < 1.3) score -= 20;
      if (ratio > 2) score += 15;

      // Defensive: protect AI capital
      const distFromAICap = hexDistance(from.row, from.col, aiCapital.row, aiCapital.col);
      if (distFromAICap <= 2 && attacker.armies <= 3) {
        score -= 30; // Don't strip capital defenses
      }

      return score;
    }

    function evaluateReinforce(from, to) {
      const source = hexGrid[from.row][from.col];
      const target = hexGrid[to.row][to.col];

      // Check if target is on the front line (adjacent to non-AI hex)
      const neighbors = getNeighbors(to.row, to.col);
      const frontLine = neighbors.some(n => hexGrid[n.row][n.col].owner !== OWNER_AI);

      if (!frontLine) return -50; // Don't reinforce rear hexes

      let score = 0;

      // Reinforce toward player capital direction
      const fromDist = hexDistance(from.row, from.col, playerCapital.row, playerCapital.col);
      const toDist = hexDistance(to.row, to.col, playerCapital.row, playerCapital.col);
      if (toDist < fromDist) score += 15;

      // Reinforce hexes that are near enemy territory
      const enemyAdjacent = neighbors.filter(n => hexGrid[n.row][n.col].owner === OWNER_PLAYER).length;
      score += enemyAdjacent * 10;

      // Bonus for reinforcing toward weak points
      if (target.armies < 3 && frontLine) score += 10;

      // Protect AI capital
      const targetDistToCap = hexDistance(to.row, to.col, aiCapital.row, aiCapital.col);
      if (targetDistToCap <= 2) {
        // Check if player is nearby
        const playerNear = neighbors.some(n => hexGrid[n.row][n.col].owner === OWNER_PLAYER);
        if (playerNear) score += 25;
      }

      // Don't reinforce if source barely has armies
      if (source.armies <= 2) score -= 15;

      return score;
    }

    function hexDistance(r1, c1, r2, c2) {
      // Convert offset coords to cube coords for distance
      const cube1 = offsetToCube(r1, c1);
      const cube2 = offsetToCube(r2, c2);
      return Math.max(
        Math.abs(cube1.x - cube2.x),
        Math.abs(cube1.y - cube2.y),
        Math.abs(cube1.z - cube2.z)
      );
    }

    function offsetToCube(row, col) {
      // Flat-top, even-column offset
      const x = col;
      const z = row - Math.floor(col / 2);
      const y = -x - z;
      return { x, y, z };
    }

    // ---- Rendering ----
    function draw() {
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, W, H);

      // Draw all hexes
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          drawHex(r, c);
        }
      }

      // Draw selection highlight
      if (selectedHex && gameState === 'playing') {
        const { x, y } = hexCenter(selectedHex.row, selectedHex.col);
        ctx.strokeStyle = COLOR_SELECTED;
        ctx.lineWidth = 3;
        ctx.shadowColor = COLOR_SELECTED;
        ctx.shadowBlur = 12;
        drawHexPath(x, y, HEX_SIZE - 1);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;
      }

      // Draw valid move highlights
      if (validMoves.length > 0 && gameState === 'playing') {
        for (const m of validMoves) {
          const { x, y } = hexCenter(m.row, m.col);
          const target = hexGrid[m.row][m.col];
          if (target.owner === OWNER_PLAYER) {
            // Reinforce target - green highlight
            ctx.fillStyle = 'rgba(100, 255, 100, 0.15)';
          } else {
            // Attack target - red highlight
            ctx.fillStyle = COLOR_ATTACK_HIGHLIGHT;
          }
          drawHexPath(x, y, HEX_SIZE - 2);
          ctx.fill();

          // Pulsing border
          const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 300);
          ctx.strokeStyle = target.owner === OWNER_PLAYER ?
            `rgba(100, 255, 100, ${0.3 + pulse * 0.4})` :
            `rgba(255, 80, 80, ${0.3 + pulse * 0.4})`;
          ctx.lineWidth = 2;
          drawHexPath(x, y, HEX_SIZE - 2);
          ctx.stroke();
          ctx.lineWidth = 1;
        }
      }

      // Hover highlight
      if (hoverHex && gameState === 'playing' && currentTurn === 'player') {
        const hex = hexGrid[hoverHex.row][hoverHex.col];
        const isSelectable = hex.owner === OWNER_PLAYER && hex.armies > 1;
        const isValidTarget = validMoves.some(m => m.row === hoverHex.row && m.col === hoverHex.col);

        if (isSelectable || isValidTarget) {
          const { x, y } = hexCenter(hoverHex.row, hoverHex.col);
          ctx.fillStyle = COLOR_HIGHLIGHT;
          drawHexPath(x, y, HEX_SIZE - 2);
          ctx.fill();
        }
      }

      // Turn info on canvas
      if (gameState === 'playing') {
        ctx.fillStyle = '#555';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Turn ' + (turnNumber + 1), 10, 10);
      }

      // Request animation frame for pulse effects on valid move highlights
      if (animFrame) cancelAnimationFrame(animFrame);
      animFrame = null;
      if (gameState === 'playing' && validMoves.length > 0) {
        animFrame = requestAnimationFrame(() => draw());
      }
    }

    function drawHex(row, col) {
      const hex = hexGrid[row][col];
      const { x, y } = hexCenter(row, col);

      // Fill color based on owner
      let fillColor, glowColor, borderColor;
      switch (hex.owner) {
        case OWNER_PLAYER:
          fillColor = COLOR_PLAYER;
          glowColor = COLOR_PLAYER_GLOW;
          borderColor = '#3366cc';
          break;
        case OWNER_AI:
          fillColor = COLOR_AI;
          glowColor = COLOR_AI_GLOW;
          borderColor = '#cc7700';
          break;
        default:
          fillColor = COLOR_NEUTRAL;
          glowColor = null;
          borderColor = COLOR_NEUTRAL_BORDER;
      }

      // Glow effect for owned hexes
      if (glowColor) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 8;
      }

      // Fill hex
      drawHexPath(x, y, HEX_SIZE - 2);
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.shadowBlur = 0;

      // Border
      drawHexPath(x, y, HEX_SIZE - 2);
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Inner gradient/shine for owned hexes
      if (hex.owner !== OWNER_NONE) {
        const grad = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, HEX_SIZE);
        grad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
        drawHexPath(x, y, HEX_SIZE - 3);
        ctx.fillStyle = grad;
        ctx.fill();
      }

      // Capital star
      if (hex.isCapital) {
        ctx.fillStyle = hex.owner === OWNER_PLAYER ? '#fff' : '#fff';
        ctx.shadowColor = hex.owner === OWNER_PLAYER ? '#4488ff' : '#f90';
        ctx.shadowBlur = 10;
        drawStar(x, y - 2, 5, 10, 4);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Army count
      if (hex.armies > 0) {
        ctx.fillStyle = hex.owner === OWNER_NONE ? '#999' : '#fff';
        ctx.shadowColor = hex.owner === OWNER_NONE ? 'transparent' : (hex.owner === OWNER_PLAYER ? '#4488ff' : '#f90');
        ctx.shadowBlur = hex.owner === OWNER_NONE ? 0 : 4;
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const textY = hex.isCapital ? y + 10 : y;
        ctx.fillText(String(hex.armies), x, textY);
        ctx.shadowBlur = 0;
      }
    }

    // ---- Expose game data ----
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState,
        score,
        turnNumber,
        currentTurn,
        grid: hexGrid.map(row => row.map(h => ({ ...h })))
      };
    }

    // ---- Initialize ----
    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

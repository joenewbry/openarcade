<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Card MMO</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #ee44aa; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 68, 170, 0.4); }
    h1 { color: #ee44aa; font-size: 1.6rem; text-shadow: 0 0 15px rgba(238, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #ee44aa; }
    canvas {
      border: 2px solid #ee44aa;
      box-shadow: 0 0 20px rgba(238, 68, 170, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ee44aa;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.92);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(238, 68, 170, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TRADING CARD MMO</h1>
  </div>
  <div class="score-bar">
    <div>Wins: <span id="score">0</span></div>
    <div>Gold: <span id="goldDisplay">0</span></div>
    <div>Cards: <span id="cardCount">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">TRADING CARD MMO</h2>
      <p id="overlayText">Click anywhere to start</p>
    </div>
  </div>
  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const goldEl = document.getElementById('goldDisplay');
    const cardCountEl = document.getElementById('cardCount');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { resetAll(); return; }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    const PINK = '#ee44aa';
    const GOLD = '#ffd700';
    const BG = '#1a1a2e';
    const RARITY_COLORS = { Common: '#aaaaaa', Rare: '#4488ff', Epic: '#aa44ff', Legendary: '#ffd700' };

    let gameState = 'waiting';
    let score = 0;
    let gold = 0;
    let wins = 0;
    let playerCollection = [];
    let playerDeck = [];
    let aiCollection = [];
    let aiDeck = [];
    let view = 'menu';
    let battleState = null;
    let tournamentState = null;
    let packCards = [];
    let packRevealIdx = 0;
    let hoverCard = null;
    let deckScrollY = 0;
    let collScrollY = 0;
    let menuButtons = [];
    let battleLog = [];
    let tradeOfferPlayer = [];
    let tradeOfferAI = [];
    let tradePhase = 'select';
    let mouseX = 0, mouseY = 0;

    const CARD_TEMPLATES = [];

    function makeCards() {
      const creatures = [
        { name: 'Goblin Scout', atk: 2, def: 1, cost: 1, rarity: 'Common' },
        { name: 'Forest Sprite', atk: 1, def: 2, cost: 1, rarity: 'Common' },
        { name: 'Iron Golem', atk: 3, def: 4, cost: 3, rarity: 'Common' },
        { name: 'Shadow Cat', atk: 3, def: 2, cost: 2, rarity: 'Common' },
        { name: 'River Nymph', atk: 2, def: 3, cost: 2, rarity: 'Common' },
        { name: 'Stone Guard', atk: 1, def: 5, cost: 3, rarity: 'Common' },
        { name: 'Flame Imp', atk: 4, def: 1, cost: 2, rarity: 'Common' },
        { name: 'Moss Turtle', atk: 1, def: 4, cost: 2, rarity: 'Common' },
        { name: 'Ember Fox', atk: 2, def: 2, cost: 1, rarity: 'Common' },
        { name: 'Bone Warrior', atk: 3, def: 3, cost: 3, rarity: 'Common' },
        { name: 'Wind Hawk', atk: 3, def: 3, cost: 3, rarity: 'Rare' },
        { name: 'Crystal Knight', atk: 4, def: 4, cost: 4, rarity: 'Rare' },
        { name: 'Lava Drake', atk: 5, def: 3, cost: 4, rarity: 'Rare' },
        { name: 'Frost Giant', atk: 4, def: 6, cost: 5, rarity: 'Rare' },
        { name: 'Thunder Eagle', atk: 5, def: 4, cost: 5, rarity: 'Rare' },
        { name: 'Plague Rat', atk: 4, def: 2, cost: 3, rarity: 'Rare' },
        { name: 'Void Stalker', atk: 6, def: 3, cost: 5, rarity: 'Epic' },
        { name: 'Sun Phoenix', atk: 5, def: 5, cost: 6, rarity: 'Epic' },
        { name: 'Abyssal Leviathan', atk: 7, def: 6, cost: 7, rarity: 'Epic' },
        { name: 'Storm Elemental', atk: 6, def: 4, cost: 6, rarity: 'Epic' },
        { name: 'Ancient Dragon', atk: 8, def: 7, cost: 8, rarity: 'Legendary' },
        { name: 'Celestial Titan', atk: 9, def: 9, cost: 9, rarity: 'Legendary' },
        { name: 'World Serpent', atk: 7, def: 8, cost: 8, rarity: 'Legendary' },
      ];
      const spells = [
        { name: 'Spark', effect: 'Deal 1 dmg', cost: 1, rarity: 'Common', dmg: 1 },
        { name: 'Mend', effect: 'Heal 2 HP', cost: 1, rarity: 'Common', heal: 2 },
        { name: 'Fireball', effect: 'Deal 3 dmg', cost: 2, rarity: 'Common', dmg: 3 },
        { name: 'Heal', effect: 'Heal 4 HP', cost: 2, rarity: 'Common', heal: 4 },
        { name: 'Lightning', effect: 'Deal 4 dmg', cost: 3, rarity: 'Rare', dmg: 4 },
        { name: 'Blizzard', effect: '2 dmg to all', cost: 4, rarity: 'Rare', aoe: 2 },
        { name: 'Divine Light', effect: 'Heal 6 HP', cost: 4, rarity: 'Rare', heal: 6 },
        { name: 'Meteor', effect: 'Deal 6 dmg', cost: 5, rarity: 'Epic', dmg: 6 },
        { name: 'Resurrect', effect: 'Heal 8 HP', cost: 5, rarity: 'Epic', heal: 8 },
        { name: 'Apocalypse', effect: '4 dmg to all', cost: 7, rarity: 'Legendary', aoe: 4 },
      ];
      const equips = [
        { name: 'Rusty Sword', effect: '+2 ATK', cost: 1, rarity: 'Common', atkBuff: 2 },
        { name: 'Wood Shield', effect: '+2 DEF', cost: 1, rarity: 'Common', defBuff: 2 },
        { name: 'Steel Armor', effect: '+3 DEF', cost: 2, rarity: 'Common', defBuff: 3 },
        { name: 'Flame Blade', effect: '+3 ATK', cost: 3, rarity: 'Rare', atkBuff: 3 },
        { name: 'Dragon Scale', effect: '+4 DEF', cost: 3, rarity: 'Rare', defBuff: 4 },
        { name: 'Excalibur', effect: '+5 ATK', cost: 5, rarity: 'Epic', atkBuff: 5 },
        { name: 'Aegis Shield', effect: '+5 DEF', cost: 5, rarity: 'Epic', defBuff: 5 },
        { name: 'Crown of Stars', effect: '+4/+4', cost: 7, rarity: 'Legendary', atkBuff: 4, defBuff: 4 },
      ];
      let id = 0;
      creatures.forEach(c => CARD_TEMPLATES.push({ id: id++, ...c, type: 'Creature' }));
      spells.forEach(s => CARD_TEMPLATES.push({ id: id++, ...s, type: 'Spell' }));
      equips.forEach(e => CARD_TEMPLATES.push({ id: id++, ...e, type: 'Equipment' }));
    }
    makeCards();

    function cloneCard(t) { return { ...t, uid: Math.random().toString(36).slice(2, 10) }; }
    function cardValue(c) { return { Common: 1, Rare: 3, Epic: 8, Legendary: 20 }[c.rarity] || 1; }
    function collectionValue(co) { return co.reduce((s, c) => s + cardValue(c), 0); }

    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeStarterDeck() {
      const st = CARD_TEMPLATES.filter(c => c.rarity === 'Common');
      const d = [];
      for (let i = 0; i < 20; i++) d.push(cloneCard(st[i % st.length]));
      return d;
    }

    function makeAICollection() {
      const co = [];
      for (let i = 0; i < 30; i++) {
        const r = Math.random();
        let pool;
        if (r < 0.5) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Common');
        else if (r < 0.8) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Rare');
        else if (r < 0.95) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Epic');
        else pool = CARD_TEMPLATES.filter(c => c.rarity === 'Legendary');
        co.push(cloneCard(pool[Math.floor(Math.random() * pool.length)]));
      }
      return co;
    }

    function aiBuildDeck(collection) {
      const sorted = [...collection].sort((a, b) => {
        const va = (a.type === 'Creature' ? (a.atk + a.def) : cardValue(a) * 2) / Math.max(1, a.cost);
        const vb = (b.type === 'Creature' ? (b.atk + b.def) : cardValue(b) * 2) / Math.max(1, b.cost);
        return vb - va;
      });
      return sorted.slice(0, 20);
    }

    function generatePack() {
      const cards = [];
      for (let i = 0; i < 3; i++) {
        const r = Math.random();
        let pool;
        if (r < 0.55) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Common');
        else if (r < 0.82) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Rare');
        else if (r < 0.95) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Epic');
        else pool = CARD_TEMPLATES.filter(c => c.rarity === 'Legendary');
        cards.push(cloneCard(pool[Math.floor(Math.random() * pool.length)]));
      }
      return cards;
    }

    function resetAll() {
      score = 0; wins = 0; gold = 100;
      playerCollection = makeStarterDeck();
      playerDeck = playerCollection.slice(0, 20);
      aiCollection = makeAICollection();
      aiDeck = aiBuildDeck(aiCollection);
      view = 'menu';
      battleState = null;
      tournamentState = null;
      packCards = [];
      tradeOfferPlayer = [];
      tradeOfferAI = [];
      tradePhase = 'select';
      gameState = 'playing';
      overlay.style.display = 'none';
      updateUI();
    }

    function startGame() { resetAll(); }

    function updateUI() {
      scoreEl.textContent = wins;
      goldEl.textContent = gold;
      cardCountEl.textContent = playerCollection.length;
    }

    // Drawing helpers
    function roundRect(x, y, w, h, r, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
    }

    function drawCard(card, x, y, w, h, hl, sm) {
      const rc = RARITY_COLORS[card.rarity];
      roundRect(x, y, w, h, 5, hl ? '#2a2a4e' : '#1e1e38', rc);
      if (card.rarity === 'Legendary') {
        ctx.shadowColor = GOLD; ctx.shadowBlur = 12;
        roundRect(x, y, w, h, 5, null, GOLD);
        ctx.shadowBlur = 0;
      } else if (card.rarity === 'Epic') {
        ctx.shadowColor = '#aa44ff'; ctx.shadowBlur = 8;
        roundRect(x, y, w, h, 5, null, '#aa44ff');
        ctx.shadowBlur = 0;
      }
      const fs = sm ? 8 : 11;
      ctx.font = 'bold ' + fs + 'px Courier New';
      ctx.fillStyle = rc;
      const nm = card.name;
      const nw = ctx.measureText(nm).width;
      if (nw > w - 22) ctx.font = 'bold ' + Math.max(6, fs - 2) + 'px Courier New';
      ctx.fillText(nm, x + 3, y + (sm ? 12 : 16));
      ctx.font = 'bold ' + (sm ? 8 : 11) + 'px Courier New';
      ctx.fillStyle = '#4af';
      ctx.fillText(card.cost + '\u2666', x + w - (sm ? 16 : 22), y + (sm ? 12 : 16));
      // Type symbol
      ctx.font = (sm ? 12 : 18) + 'px serif';
      ctx.fillStyle = '#ddd';
      const icons = { Creature: '\u2694', Spell: '\u2728', Equipment: '\u26E8' };
      ctx.fillText(icons[card.type] || '?', x + w / 2 - 6, y + (sm ? 26 : 38));
      if (card.type === 'Creature') {
        ctx.font = 'bold ' + (sm ? 8 : 11) + 'px Courier New';
        ctx.fillStyle = '#ff5555';
        ctx.fillText('ATK:' + (card.curAtk !== undefined ? card.curAtk : card.atk), x + 3, y + h - (sm ? 12 : 18));
        ctx.fillStyle = '#55ff55';
        ctx.fillText('DEF:' + (card.curDef !== undefined ? card.curDef : card.def), x + 3, y + h - (sm ? 3 : 6));
      } else {
        ctx.font = (sm ? 7 : 9) + 'px Courier New';
        ctx.fillStyle = '#ccc';
        ctx.fillText(card.effect || '', x + 3, y + h - (sm ? 5 : 10));
      }
      ctx.font = 'bold ' + (sm ? 6 : 8) + 'px Courier New';
      ctx.fillStyle = rc;
      ctx.fillText(card.rarity[0], x + w - (sm ? 9 : 13), y + h - (sm ? 3 : 5));
    }

    function drawBtn(x, y, w, h, text, color, hov) {
      roundRect(x, y, w, h, 8, hov ? '#2e2e4e' : '#1a1a2e', color || PINK);
      if (hov) {
        ctx.shadowColor = color || PINK; ctx.shadowBlur = 10;
        roundRect(x, y, w, h, 8, null, color || PINK);
        ctx.shadowBlur = 0;
      }
      ctx.font = 'bold 13px Courier New';
      ctx.fillStyle = color || PINK;
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, x + w / 2 - tw / 2, y + h / 2 + 5);
      return { x, y, w, h };
    }

    function inRect(px, py, r) { return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h; }

    // ========== VIEWS ==========

    function drawMenu() {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 26px Courier New';
      ctx.fillStyle = PINK;
      ctx.shadowColor = PINK; ctx.shadowBlur = 20;
      const t = 'TRADING CARD MMO';
      ctx.fillText(t, W / 2 - ctx.measureText(t).width / 2, 55);
      ctx.shadowBlur = 0;
      ctx.font = '11px Courier New';
      ctx.fillStyle = '#777';
      ctx.fillText('Collect \u2022 Build \u2022 Battle \u2022 Trade', W / 2 - 115, 75);
      ctx.font = '11px Courier New';
      ctx.fillStyle = '#aaa';
      ctx.fillText('Collection: ' + playerCollection.length + ' cards  |  Value: ' + collectionValue(playerCollection), 40, 100);
      ctx.fillText('Deck: ' + playerDeck.length + '/20  |  Wins: ' + wins + '  |  Gold: ' + gold, 40, 116);

      menuButtons = [];
      const bw = 200, bh = 38, bx = W / 2 - bw / 2;
      const items = [
        { label: '\u2694 QUICK BATTLE', action: 'battle', color: '#ff4444' },
        { label: '\u2606 TOURNAMENT', action: 'tournament', color: GOLD },
        { label: '\u25A0 BUY PACK (50g)', action: 'buypack', color: '#4af' },
        { label: '\u25CF COLLECTION', action: 'collection', color: '#55ff55' },
        { label: '\u25B2 DECK BUILDER', action: 'deckbuilder', color: '#ffaa44' },
        { label: '\u2660 TRADE', action: 'trade', color: '#aa44ff' },
      ];
      items.forEach((item, i) => {
        const by = 135 + i * 48;
        const hov = mouseX >= bx && mouseX <= bx + bw && mouseY >= by && mouseY <= by + bh;
        const btn = drawBtn(bx, by, bw, bh, item.label, item.color, hov);
        menuButtons.push({ ...btn, action: item.action });
      });

      // Preview cards
      const prev = playerDeck.slice(0, 5);
      for (let i = 0; i < prev.length; i++) {
        drawCard(prev[i], 55 + i * 105, 425, 90, 65, false, true);
      }
    }

    function drawCollection() {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 16px Courier New';
      ctx.fillStyle = PINK;
      ctx.fillText('COLLECTION (' + playerCollection.length + ' cards)', 20, 26);
      menuButtons = [];
      const bh = mouseX >= 520 && mouseX <= 590 && mouseY >= 5 && mouseY <= 32;
      menuButtons.push({ ...drawBtn(520, 5, 70, 27, 'BACK', '#888', bh), action: 'menu' });

      const sorted = [...playerCollection].sort((a, b) => {
        const ro = { Legendary: 0, Epic: 1, Rare: 2, Common: 3 };
        return (ro[a.rarity] - ro[b.rarity]) || a.cost - b.cost;
      });
      const cw = 90, ch = 105, gap = 8, cols = 6;
      for (let i = 0; i < sorted.length; i++) {
        const col = i % cols, row = Math.floor(i / cols);
        const cx = 8 + col * (cw + gap);
        const cy = 40 + row * (ch + gap) + collScrollY;
        if (cy + ch < 35 || cy > H) continue;
        const inDeck = playerDeck.some(d => d.uid === sorted[i].uid);
        drawCard(sorted[i], cx, cy, cw, ch, inDeck, true);
        if (inDeck) {
          ctx.font = 'bold 7px Courier New'; ctx.fillStyle = '#55ff55';
          ctx.fillText('IN DECK', cx + 3, cy + ch - 1);
        }
      }
      if (sorted.length > 24) {
        ctx.font = '10px Courier New'; ctx.fillStyle = '#555';
        ctx.fillText('Scroll to see more', W / 2 - 55, H - 4);
      }
    }

    function drawDeckBuilder() {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 15px Courier New'; ctx.fillStyle = PINK;
      ctx.fillText('DECK BUILDER (' + playerDeck.length + '/20)', 20, 22);
      menuButtons = [];
      const bh2 = mouseX >= 520 && mouseX <= 590 && mouseY >= 5 && mouseY <= 30;
      menuButtons.push({ ...drawBtn(520, 5, 70, 25, 'BACK', '#888', bh2), action: 'menu' });

      // Deck list on left
      ctx.font = 'bold 11px Courier New'; ctx.fillStyle = '#55ff55';
      ctx.fillText('YOUR DECK', 10, 45);
      for (let i = 0; i < playerDeck.length; i++) {
        const c = playerDeck[i];
        const dy = 52 + i * 21 + deckScrollY;
        if (dy < 38 || dy > H - 5) continue;
        const rc = RARITY_COLORS[c.rarity];
        const hov = mouseX >= 5 && mouseX <= 238 && mouseY >= dy && mouseY <= dy + 19;
        ctx.fillStyle = hov ? '#2a2a4e' : '#1a1a2e';
        ctx.fillRect(5, dy, 233, 19);
        ctx.strokeStyle = rc; ctx.lineWidth = 1; ctx.strokeRect(5, dy, 233, 19);
        ctx.font = '9px Courier New';
        ctx.fillStyle = '#4af'; ctx.fillText(c.cost + '\u2666', 9, dy + 14);
        ctx.fillStyle = rc; ctx.fillText(c.name, 28, dy + 14);
        if (c.type === 'Creature') { ctx.fillStyle = '#f55'; ctx.fillText(c.atk + '/' + c.def, 185, dy + 14); }
        ctx.fillStyle = '#f44'; ctx.fillText('X', 222, dy + 14);
      }

      // Available on right
      ctx.font = 'bold 11px Courier New'; ctx.fillStyle = '#ffaa44';
      ctx.fillText('AVAILABLE', 255, 45);
      const avail = playerCollection.filter(c => !playerDeck.some(d => d.uid === c.uid));
      const sa = avail.sort((a, b) => a.cost - b.cost);
      for (let i = 0; i < sa.length; i++) {
        const c = sa[i];
        const dy = 52 + i * 21 + deckScrollY;
        if (dy < 38 || dy > H - 5) continue;
        const rc = RARITY_COLORS[c.rarity];
        const hov = mouseX >= 250 && mouseX <= 593 && mouseY >= dy && mouseY <= dy + 19;
        ctx.fillStyle = hov ? '#2a2a4e' : '#1a1a2e';
        ctx.fillRect(250, dy, 343, 19);
        ctx.strokeStyle = rc; ctx.lineWidth = 1; ctx.strokeRect(250, dy, 343, 19);
        ctx.font = '9px Courier New';
        ctx.fillStyle = '#4af'; ctx.fillText(c.cost + '\u2666', 254, dy + 14);
        ctx.fillStyle = rc; ctx.fillText(c.name, 274, dy + 14);
        if (c.type === 'Creature') { ctx.fillStyle = '#f55'; ctx.fillText(c.atk + '/' + c.def, 415, dy + 14); }
        ctx.fillStyle = '#aaa'; ctx.fillText(c.type, 465, dy + 14);
        if (playerDeck.length < 20) { ctx.fillStyle = '#55ff55'; ctx.fillText('+', 575, dy + 14); }
      }
    }

    // ========== BATTLE ==========

    function initBattle(aiD) {
      const pd = shuffle([...playerDeck].map(c => ({ ...c, curAtk: c.atk, curDef: c.def })));
      const ad = shuffle([...(aiD || aiDeck)].map(c => ({ ...c, curAtk: c.atk, curDef: c.def })));
      battleState = {
        playerHP: 20, aiHP: 20,
        playerMana: 1, aiMana: 1, maxMana: 1, aiMaxMana: 1,
        playerHand: pd.splice(0, 4),
        aiHand: ad.splice(0, 4),
        playerField: [], aiField: [],
        playerDeckPile: pd, aiDeckPile: ad,
        turn: 'player', selectedFieldCard: null, attackTarget: null,
        turnNum: 1, gameOver: false, winner: null,
        aiThinking: false, aiThinkTimer: 0,
        msg: 'Your turn! Play cards or attack.',
      };
      battleLog = [];
      view = 'battle';
    }

    function drawBattle() {
      if (!battleState) return;
      const bs = battleState;
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

      // AI HP bar
      ctx.fillStyle = '#333'; ctx.fillRect(W - 160, 6, 150, 13);
      ctx.fillStyle = '#ff4444'; ctx.fillRect(W - 160, 6, Math.max(0, bs.aiHP / 20) * 150, 13);
      ctx.font = 'bold 10px Courier New'; ctx.fillStyle = '#fff';
      ctx.fillText('AI: ' + Math.max(0, bs.aiHP) + '/20', W - 158, 16);

      // Player HP bar
      ctx.fillStyle = '#333'; ctx.fillRect(10, H - 20, 150, 13);
      ctx.fillStyle = '#55ff55'; ctx.fillRect(10, H - 20, Math.max(0, bs.playerHP / 20) * 150, 13);
      ctx.fillText('YOU: ' + Math.max(0, bs.playerHP) + '/20', 12, H - 10);

      // Mana
      ctx.fillStyle = '#4af';
      ctx.fillText('Mana:' + bs.playerMana + '/' + bs.maxMana, 175, H - 10);
      ctx.fillStyle = '#a4f';
      ctx.fillText('Mana:' + bs.aiMana + '/' + bs.aiMaxMana, 175, 16);

      // Decks
      ctx.fillStyle = '#666';
      ctx.fillText('Deck:' + bs.playerDeckPile.length, 300, H - 10);
      ctx.fillText('Deck:' + bs.aiDeckPile.length, 300, 16);

      // Turn
      ctx.font = 'bold 11px Courier New';
      ctx.fillStyle = bs.turn === 'player' ? '#4af' : '#fa4';
      ctx.fillText(bs.turn === 'player' ? '\u25B6 YOUR TURN' : '\u25B6 AI TURN', 420, H - 10);
      ctx.fillStyle = '#555'; ctx.fillText('Turn ' + bs.turnNum, 420, 16);

      // AI field
      ctx.font = 'bold 9px Courier New'; ctx.fillStyle = '#ff5555';
      ctx.fillText('AI FIELD', 10, 32);
      for (let i = 0; i < bs.aiField.length; i++) {
        const cx = 10 + i * 100, cy = 38;
        const tgt = bs.attackTarget === i;
        drawCard(bs.aiField[i], cx, cy, 92, 76, tgt, true);
        if (tgt) { ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 3; ctx.strokeRect(cx - 1, cy - 1, 94, 78); }
      }

      // AI hand
      ctx.fillStyle = '#666'; ctx.font = '9px Courier New';
      ctx.fillText('AI Hand: ' + bs.aiHand.length, 10, 124);

      // Divider
      ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, 135); ctx.lineTo(W, 135); ctx.stroke();

      // Player field
      ctx.font = 'bold 9px Courier New'; ctx.fillStyle = '#55ff55';
      ctx.fillText('YOUR FIELD', 10, 150);
      for (let i = 0; i < bs.playerField.length; i++) {
        const cx = 10 + i * 100, cy = 158;
        const sel = bs.selectedFieldCard === i;
        drawCard(bs.playerField[i], cx, cy, 92, 76, sel, true);
        if (sel) { ctx.strokeStyle = '#4af'; ctx.lineWidth = 3; ctx.strokeRect(cx - 1, cy - 1, 94, 78); }
        if (bs.turn === 'player' && bs.playerField[i] && !bs.playerField[i].attacked) {
          ctx.fillStyle = '#55ff55'; ctx.font = 'bold 7px Courier New';
          ctx.fillText('\u2694 READY', cx + 24, cy + 74);
        }
      }

      // Divider
      ctx.strokeStyle = '#333';
      ctx.beginPath(); ctx.moveTo(0, 248); ctx.lineTo(W, 248); ctx.stroke();

      // Player hand
      ctx.font = 'bold 9px Courier New'; ctx.fillStyle = PINK;
      ctx.fillText('YOUR HAND', 10, 263);
      const hw = Math.min(95, (W - 20) / Math.max(1, bs.playerHand.length));
      for (let i = 0; i < bs.playerHand.length; i++) {
        const cx = 10 + i * hw, cy = 270;
        const canPlay = bs.playerHand[i].cost <= bs.playerMana && bs.turn === 'player';
        drawCard(bs.playerHand[i], cx, cy, hw - 4, 95, canPlay, true);
        if (!canPlay) {
          ctx.fillStyle = 'rgba(0,0,0,0.45)';
          ctx.fillRect(cx, cy, hw - 4, 95);
        }
      }

      // Message
      ctx.font = 'bold 10px Courier New'; ctx.fillStyle = '#eeee88';
      ctx.fillText(bs.msg, 10, 382);

      // Log
      ctx.font = '8px Courier New'; ctx.fillStyle = '#555';
      const ls = Math.max(0, battleLog.length - 4);
      for (let i = ls; i < battleLog.length; i++) {
        ctx.fillText(battleLog[i], 10, 395 + (i - ls) * 11);
      }

      // End turn btn
      menuButtons = [];
      if (bs.turn === 'player' && !bs.gameOver) {
        const eh = mouseX >= 460 && mouseX <= 590 && mouseY >= 440 && mouseY <= 468;
        menuButtons.push({ ...drawBtn(460, 440, 130, 28, 'END TURN', '#ffaa44', eh), action: 'endturn' });
      }

      // Game over
      if (bs.gameOver) {
        ctx.fillStyle = 'rgba(26,26,46,0.82)'; ctx.fillRect(0, 0, W, H);
        ctx.font = 'bold 30px Courier New';
        ctx.fillStyle = bs.winner === 'player' ? '#55ff55' : '#ff4444';
        ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 20;
        const msg = bs.winner === 'player' ? 'VICTORY!' : 'DEFEAT!';
        ctx.fillText(msg, W / 2 - ctx.measureText(msg).width / 2, H / 2 - 15);
        ctx.shadowBlur = 0;
        ctx.font = '13px Courier New'; ctx.fillStyle = '#aaa';
        ctx.fillText('Click to continue', W / 2 - 60, H / 2 + 20);
      }
    }

    function battlePlayCard(idx) {
      const bs = battleState;
      if (bs.turn !== 'player' || bs.gameOver) return;
      const card = bs.playerHand[idx];
      if (!card || card.cost > bs.playerMana) return;
      bs.playerMana -= card.cost;

      if (card.type === 'Creature') {
        if (bs.playerField.length >= 5) { bs.msg = 'Field full!'; bs.playerMana += card.cost; return; }
        card.attacked = false; card.curAtk = card.atk; card.curDef = card.def;
        bs.playerField.push(card);
        bs.playerHand.splice(idx, 1);
        battleLog.push('You play ' + card.name);
        bs.msg = 'Played ' + card.name;
      } else if (card.type === 'Spell') {
        if (card.dmg) {
          if (bs.aiField.length > 0 && !card.aoe) {
            let best = 0;
            bs.aiField.forEach((c, i) => { if ((c.curAtk || c.atk) > (bs.aiField[best].curAtk || bs.aiField[best].atk)) best = i; });
            bs.aiField[best].curDef -= card.dmg;
            battleLog.push(card.name + ' hits ' + bs.aiField[best].name + ' for ' + card.dmg);
            if (bs.aiField[best].curDef <= 0) { battleLog.push(bs.aiField[best].name + ' destroyed!'); bs.aiField.splice(best, 1); }
          } else if (card.aoe) {
            for (let i = bs.aiField.length - 1; i >= 0; i--) {
              bs.aiField[i].curDef -= card.aoe;
              if (bs.aiField[i].curDef <= 0) { battleLog.push(bs.aiField[i].name + ' destroyed!'); bs.aiField.splice(i, 1); }
            }
            battleLog.push(card.name + ' hits all for ' + card.aoe);
          } else {
            bs.aiHP -= card.dmg;
            battleLog.push(card.name + ' deals ' + card.dmg + ' to AI');
          }
        }
        if (card.heal) {
          bs.playerHP = Math.min(20, bs.playerHP + card.heal);
          battleLog.push(card.name + ' heals ' + card.heal);
        }
        bs.playerHand.splice(idx, 1);
        bs.msg = 'Cast ' + card.name;
      } else if (card.type === 'Equipment') {
        if (bs.playerField.length > 0) {
          let best = 0;
          bs.playerField.forEach((c, i) => { if ((c.curAtk || 0) > (bs.playerField[best].curAtk || 0)) best = i; });
          if (card.atkBuff) bs.playerField[best].curAtk += card.atkBuff;
          if (card.defBuff) bs.playerField[best].curDef += card.defBuff;
          battleLog.push(card.name + ' on ' + bs.playerField[best].name);
          bs.playerHand.splice(idx, 1);
          bs.msg = 'Equipped ' + card.name;
        } else { bs.msg = 'No creatures!'; bs.playerMana += card.cost; return; }
      }
      checkBattleEnd();
    }

    function battleAttack(fi, ti) {
      const bs = battleState;
      const atk = bs.playerField[fi];
      if (!atk || atk.attacked) return;
      if (ti === -1) {
        if (bs.aiField.length > 0) { bs.msg = 'Attack creatures first!'; return; }
        bs.aiHP -= (atk.curAtk || atk.atk);
        battleLog.push(atk.name + ' hits AI for ' + (atk.curAtk || atk.atk));
        atk.attacked = true;
      } else if (ti >= 0 && ti < bs.aiField.length) {
        const def = bs.aiField[ti];
        def.curDef -= (atk.curAtk || atk.atk);
        atk.curDef -= (def.curAtk || def.atk);
        battleLog.push(atk.name + ' vs ' + def.name);
        if (def.curDef <= 0) { battleLog.push(def.name + ' destroyed!'); bs.aiField.splice(ti, 1); }
        if (atk.curDef <= 0) { battleLog.push(atk.name + ' destroyed!'); bs.playerField.splice(fi, 1); }
        atk.attacked = true;
      }
      bs.selectedFieldCard = null;
      bs.attackTarget = null;
      bs.msg = 'Select creature or end turn.';
      checkBattleEnd();
    }

    function endPlayerTurn() {
      const bs = battleState;
      bs.turn = 'ai';
      bs.aiThinking = true;
      bs.aiThinkTimer = 35;
      bs.msg = 'AI thinking...';
      bs.playerField.forEach(c => c.attacked = false);
    }

    function aiTurn() {
      const bs = battleState;
      bs.aiMaxMana = Math.min(10, bs.aiMaxMana + 1);
      bs.aiMana = bs.aiMaxMana;
      if (bs.aiDeckPile.length > 0 && bs.aiHand.length < 8) bs.aiHand.push(bs.aiDeckPile.pop());

      // AI plays cards
      let played = true;
      while (played) {
        played = false;
        const playable = bs.aiHand.filter(c => c.cost <= bs.aiMana).sort((a, b) => b.cost - a.cost);
        for (const card of playable) {
          const idx = bs.aiHand.indexOf(card);
          if (idx < 0) continue;
          if (card.type === 'Creature' && bs.aiField.length < 5) {
            bs.aiMana -= card.cost;
            card.curAtk = card.atk; card.curDef = card.def; card.attacked = false;
            bs.aiField.push(card); bs.aiHand.splice(idx, 1);
            battleLog.push('AI plays ' + card.name); played = true; break;
          } else if (card.type === 'Spell') {
            bs.aiMana -= card.cost;
            if (card.dmg && bs.playerField.length > 0 && !card.aoe) {
              let best = 0;
              bs.playerField.forEach((c, i) => { if ((c.curAtk || c.atk) > (bs.playerField[best].curAtk || bs.playerField[best].atk)) best = i; });
              bs.playerField[best].curDef -= card.dmg;
              battleLog.push('AI ' + card.name + ' on ' + bs.playerField[best].name);
              if (bs.playerField[best].curDef <= 0) { battleLog.push(bs.playerField[best].name + ' destroyed!'); bs.playerField.splice(best, 1); }
            } else if (card.aoe) {
              for (let i = bs.playerField.length - 1; i >= 0; i--) {
                bs.playerField[i].curDef -= card.aoe;
                if (bs.playerField[i].curDef <= 0) { battleLog.push(bs.playerField[i].name + ' destroyed!'); bs.playerField.splice(i, 1); }
              }
              battleLog.push('AI casts ' + card.name);
            } else if (card.dmg) {
              bs.playerHP -= card.dmg;
              battleLog.push('AI ' + card.name + ' for ' + card.dmg);
            } else if (card.heal) {
              bs.aiHP = Math.min(20, bs.aiHP + card.heal);
              battleLog.push('AI heals ' + card.heal);
            }
            bs.aiHand.splice(idx, 1); played = true; break;
          } else if (card.type === 'Equipment' && bs.aiField.length > 0) {
            bs.aiMana -= card.cost;
            let best = 0;
            bs.aiField.forEach((c, i) => { if ((c.curAtk || 0) > (bs.aiField[best].curAtk || 0)) best = i; });
            if (card.atkBuff) bs.aiField[best].curAtk += card.atkBuff;
            if (card.defBuff) bs.aiField[best].curDef += card.defBuff;
            battleLog.push('AI equips ' + card.name);
            bs.aiHand.splice(idx, 1); played = true; break;
          }
        }
      }

      // AI attacks
      const attackers = [...bs.aiField];
      for (const creature of attackers) {
        if (creature.attacked) continue;
        if (!bs.aiField.includes(creature)) continue;
        creature.attacked = true;
        if (bs.playerField.length > 0) {
          let weakest = 0;
          bs.playerField.forEach((c, i) => {
            if ((c.curDef || c.def) < (bs.playerField[weakest].curDef || bs.playerField[weakest].def)) weakest = i;
          });
          const def = bs.playerField[weakest];
          def.curDef -= (creature.curAtk || creature.atk);
          creature.curDef -= (def.curAtk || def.atk);
          battleLog.push('AI ' + creature.name + ' vs ' + def.name);
          if (def.curDef <= 0) { battleLog.push(def.name + ' destroyed!'); bs.playerField.splice(weakest, 1); }
          if (creature.curDef <= 0) {
            battleLog.push(creature.name + ' destroyed!');
            const ci = bs.aiField.indexOf(creature);
            if (ci >= 0) bs.aiField.splice(ci, 1);
          }
        } else {
          bs.playerHP -= (creature.curAtk || creature.atk);
          battleLog.push('AI ' + creature.name + ' hits you for ' + (creature.curAtk || creature.atk));
        }
        if (bs.playerHP <= 0 || bs.aiHP <= 0) break;
      }

      checkBattleEnd();
      if (!bs.gameOver) {
        bs.turn = 'player';
        bs.turnNum++;
        bs.maxMana = Math.min(10, bs.maxMana + 1);
        bs.playerMana = bs.maxMana;
        if (bs.playerDeckPile.length > 0 && bs.playerHand.length < 8) bs.playerHand.push(bs.playerDeckPile.pop());
        bs.playerField.forEach(c => c.attacked = false);
        bs.aiField.forEach(c => c.attacked = false);
        bs.msg = 'Your turn! Play cards or attack.';
      }
    }

    function checkBattleEnd() {
      const bs = battleState;
      if (bs.aiHP <= 0) { bs.gameOver = true; bs.winner = 'player'; bs.msg = 'Victory!'; }
      else if (bs.playerHP <= 0) { bs.gameOver = true; bs.winner = 'ai'; bs.msg = 'Defeat!'; }
    }

    function finishBattle() {
      const bs = battleState;
      if (bs.winner === 'player') {
        wins++;
        gold += 75;
        score = wins * 10 + collectionValue(playerCollection);
        packCards = generatePack();
        packRevealIdx = -1;
        view = 'packopen';
      } else {
        gold += 15;
        if (tournamentState) { tournamentState.eliminated = true; view = 'tournament'; }
        else view = 'menu';
      }
      updateUI();
    }

    // ========== PACK OPENING ==========

    function drawPackOpen() {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 22px Courier New'; ctx.fillStyle = GOLD;
      ctx.shadowColor = GOLD; ctx.shadowBlur = 15;
      ctx.fillText('BOOSTER PACK!', W / 2 - 90, 50);
      ctx.shadowBlur = 0;

      menuButtons = [];
      if (packRevealIdx < 0) {
        // Closed pack
        roundRect(W / 2 - 60, 100, 120, 180, 12, '#2a1a3e', GOLD);
        ctx.font = 'bold 40px serif'; ctx.fillStyle = GOLD;
        ctx.fillText('?', W / 2 - 12, 210);
        ctx.font = '13px Courier New'; ctx.fillStyle = '#aaa';
        ctx.fillText('Click to open!', W / 2 - 55, 320);
        menuButtons.push({ x: W / 2 - 60, y: 100, w: 120, h: 180, action: 'openpack' });
      } else {
        for (let i = 0; i < packCards.length; i++) {
          const cx = 80 + i * 160, cy = 90;
          if (i <= packRevealIdx) {
            const rc = RARITY_COLORS[packCards[i].rarity];
            ctx.shadowColor = rc; ctx.shadowBlur = 18;
            drawCard(packCards[i], cx, cy, 130, 190, true, false);
            ctx.shadowBlur = 0;
            ctx.font = 'bold 12px Courier New'; ctx.fillStyle = rc;
            ctx.fillText(packCards[i].rarity, cx + 35, cy + 215);
          } else {
            roundRect(cx, cy, 130, 190, 8, '#2a1a3e', '#555');
            ctx.font = 'bold 36px serif'; ctx.fillStyle = '#555';
            ctx.fillText('?', cx + 52, cy + 110);
          }
        }
        if (packRevealIdx < packCards.length - 1) {
          ctx.font = '13px Courier New'; ctx.fillStyle = '#aaa';
          ctx.fillText('Click to reveal next', W / 2 - 70, 370);
          menuButtons.push({ x: 0, y: 0, w: W, h: H, action: 'revealnext' });
        } else {
          ctx.font = '13px Courier New'; ctx.fillStyle = '#55ff55';
          ctx.fillText('Cards added to collection!', W / 2 - 95, 370);
          const ch2 = mouseX >= W / 2 - 60 && mouseX <= W / 2 + 60 && mouseY >= 390 && mouseY <= 425;
          menuButtons.push({ ...drawBtn(W / 2 - 60, 390, 120, 35, 'CONTINUE', PINK, ch2), action: 'packcontinue' });
        }
      }
    }

    // ========== TOURNAMENT ==========

    function initTournament() {
      tournamentState = { round: 1, maxRounds: 4, opponents: [], results: [], eliminated: false, rewards: [100, 200, 400, 800] };
      for (let i = 0; i < 4; i++) {
        const opp = [];
        const rc = 0.3 + i * 0.15;
        for (let j = 0; j < 25; j++) {
          const r = Math.random();
          let pool;
          if (r < (1 - rc)) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Common');
          else if (r < (1 - rc * 0.4)) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Rare');
          else if (r < (1 - rc * 0.1)) pool = CARD_TEMPLATES.filter(c => c.rarity === 'Epic');
          else pool = CARD_TEMPLATES.filter(c => c.rarity === 'Legendary');
          opp.push(cloneCard(pool[Math.floor(Math.random() * pool.length)]));
        }
        tournamentState.opponents.push(aiBuildDeck(opp));
      }
      view = 'tournament';
    }

    function drawTournament() {
      if (!tournamentState) return;
      const ts = tournamentState;
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 22px Courier New'; ctx.fillStyle = GOLD;
      ctx.shadowColor = GOLD; ctx.shadowBlur = 15;
      ctx.fillText('\u2606 TOURNAMENT', W / 2 - 90, 42);
      ctx.shadowBlur = 0;

      menuButtons = [];
      const oppNames = ['Novice Collector', 'Card Trader', 'Deck Master', 'Grand Champion'];
      for (let i = 0; i < ts.maxRounds; i++) {
        const y = 65 + i * 90;
        const isCur = i === ts.round - 1;
        const isPast = i < ts.round - 1;
        const rc = isPast ? '#55ff55' : (isCur ? GOLD : '#444');
        ctx.font = 'bold 14px Courier New'; ctx.fillStyle = rc;
        ctx.fillText('Round ' + (i + 1) + (isPast ? ' \u2714' : ''), 40, y);
        ctx.font = '12px Courier New'; ctx.fillStyle = '#aaa';
        ctx.fillText('vs ' + oppNames[i], 40, y + 18);
        ctx.fillStyle = '#4af';
        ctx.fillText('Reward: ' + ts.rewards[i] + 'g + Pack', 40, y + 35);
        if (isPast) {
          ctx.fillStyle = ts.results[i] ? '#55ff55' : '#ff4444';
          ctx.fillText(ts.results[i] ? 'WON' : 'LOST', 350, y + 10);
        }
        if (isCur && !ts.eliminated) {
          const fh = mouseX >= 350 && mouseX <= 500 && mouseY >= y - 5 && mouseY <= y + 30;
          menuButtons.push({ ...drawBtn(350, y - 5, 150, 35, '\u2694 FIGHT!', '#ff4444', fh), action: 'tournfight', round: i });
        }
      }
      if (ts.eliminated) {
        ctx.font = 'bold 18px Courier New'; ctx.fillStyle = '#ff4444';
        ctx.fillText('ELIMINATED!', W / 2 - 60, 435);
        ctx.font = '11px Courier New'; ctx.fillStyle = '#888';
        ctx.fillText('Better luck next time.', W / 2 - 70, 455);
        const bh2 = mouseX >= W / 2 - 50 && mouseX <= W / 2 + 50 && mouseY >= 462 && mouseY <= 490;
        menuButtons.push({ ...drawBtn(W / 2 - 50, 462, 100, 28, 'BACK', '#888', bh2), action: 'menu' });
      } else if (ts.round > ts.maxRounds) {
        ctx.font = 'bold 22px Courier New'; ctx.fillStyle = GOLD;
        ctx.shadowColor = GOLD; ctx.shadowBlur = 20;
        ctx.fillText('CHAMPION!', W / 2 - 65, 435);
        ctx.shadowBlur = 0;
        const bh2 = mouseX >= W / 2 - 50 && mouseX <= W / 2 + 50 && mouseY >= 462 && mouseY <= 490;
        menuButtons.push({ ...drawBtn(W / 2 - 50, 462, 100, 28, 'BACK', GOLD, bh2), action: 'menu' });
      }
      const bh3 = mouseX >= 10 && mouseX <= 80 && mouseY >= 465 && mouseY <= 490;
      menuButtons.push({ ...drawBtn(10, 465, 70, 25, 'BACK', '#666', bh3), action: 'menu' });
    }

    // ========== TRADE ==========

    function drawTrade() {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      ctx.font = 'bold 16px Courier New'; ctx.fillStyle = '#aa44ff';
      ctx.fillText('\u2660 TRADE WITH AI', 20, 26);
      menuButtons = [];
      const bh2 = mouseX >= 520 && mouseX <= 590 && mouseY >= 5 && mouseY <= 30;
      menuButtons.push({ ...drawBtn(520, 5, 70, 25, 'BACK', '#888', bh2), action: 'menu' });

      if (tradePhase === 'select') {
        ctx.font = 'bold 10px Courier New'; ctx.fillStyle = PINK;
        ctx.fillText('YOUR CARDS (click to offer):', 10, 50);
        const pc = playerCollection.filter(c => !tradeOfferPlayer.some(o => o.uid === c.uid));
        const sorted = pc.sort((a, b) => cardValue(b) - cardValue(a));
        for (let i = 0; i < Math.min(sorted.length, 18); i++) {
          const col = i % 6, row = Math.floor(i / 6);
          const cx = 8 + col * 97, cy = 58 + row * 48;
          const rc = RARITY_COLORS[sorted[i].rarity];
          const hov = mouseX >= cx && mouseX <= cx + 92 && mouseY >= cy && mouseY <= cy + 43;
          roundRect(cx, cy, 92, 43, 4, hov ? '#2a2a4e' : '#1e1e38', rc);
          ctx.font = '8px Courier New'; ctx.fillStyle = rc;
          ctx.fillText(sorted[i].name, cx + 3, cy + 13);
          ctx.fillStyle = '#4af'; ctx.fillText(sorted[i].cost + '\u2666 Val:' + cardValue(sorted[i]), cx + 3, cy + 26);
          ctx.fillStyle = '#888'; ctx.fillText(sorted[i].type, cx + 3, cy + 38);
        }

        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, 210); ctx.lineTo(W, 210); ctx.stroke();

        ctx.font = 'bold 10px Courier New'; ctx.fillStyle = '#55ff55';
        ctx.fillText('YOUR OFFER (val: ' + tradeOfferPlayer.reduce((s, c) => s + cardValue(c), 0) + '):', 10, 228);
        for (let i = 0; i < tradeOfferPlayer.length; i++) {
          const cx = 10 + i * 97;
          roundRect(cx, 235, 92, 32, 4, '#1a2a1a', RARITY_COLORS[tradeOfferPlayer[i].rarity]);
          ctx.font = '8px Courier New'; ctx.fillStyle = RARITY_COLORS[tradeOfferPlayer[i].rarity];
          ctx.fillText(tradeOfferPlayer[i].name, cx + 3, 252);
          ctx.fillStyle = '#ff4444'; ctx.fillText('X', cx + 80, 252);
        }

        ctx.strokeStyle = '#333';
        ctx.beginPath(); ctx.moveTo(0, 280); ctx.lineTo(W, 280); ctx.stroke();
        ctx.font = 'bold 10px Courier New'; ctx.fillStyle = '#ffaa44';
        ctx.fillText('AI OFFERS (val: ' + tradeOfferAI.reduce((s, c) => s + cardValue(c), 0) + '):', 10, 298);

        if (tradeOfferPlayer.length > 0 && tradeOfferAI.length === 0) generateAITradeOffer();

        for (let i = 0; i < tradeOfferAI.length; i++) {
          const cx = 10 + i * 97;
          roundRect(cx, 305, 92, 43, 4, '#1a1a2a', RARITY_COLORS[tradeOfferAI[i].rarity]);
          ctx.font = '8px Courier New'; ctx.fillStyle = RARITY_COLORS[tradeOfferAI[i].rarity];
          ctx.fillText(tradeOfferAI[i].name, cx + 3, 322);
          ctx.fillStyle = '#4af'; ctx.fillText('Val:' + cardValue(tradeOfferAI[i]), cx + 3, 338);
        }

        if (tradeOfferPlayer.length > 0 && tradeOfferAI.length > 0) {
          const ah = mouseX >= 160 && mouseX <= 290 && mouseY >= 380 && mouseY <= 415;
          menuButtons.push({ ...drawBtn(160, 380, 130, 35, 'ACCEPT', '#55ff55', ah), action: 'tradeaccept' });
          const dh = mouseX >= 310 && mouseX <= 440 && mouseY >= 380 && mouseY <= 415;
          menuButtons.push({ ...drawBtn(310, 380, 130, 35, 'DECLINE', '#ff4444', dh), action: 'tradedecline' });
        }
        ctx.font = '9px Courier New'; ctx.fillStyle = '#555';
        ctx.fillText('Select cards to trade. AI will counter-offer.', 10, 470);
      } else if (tradePhase === 'done') {
        ctx.font = 'bold 20px Courier New'; ctx.fillStyle = '#55ff55';
        ctx.fillText('Trade Complete!', W / 2 - 80, H / 2);
        ctx.font = '12px Courier New'; ctx.fillStyle = '#aaa';
        ctx.fillText('Click to continue', W / 2 - 55, H / 2 + 25);
      }
    }

    function generateAITradeOffer() {
      const pv = tradeOfferPlayer.reduce((s, c) => s + cardValue(c), 0);
      const tv = Math.max(1, pv - 1 + Math.floor(Math.random() * 3));
      const avail = aiCollection.filter(c => !aiDeck.some(d => d.uid === c.uid));
      tradeOfferAI = [];
      if (avail.length === 0) {
        for (let i = 0; i < 2; i++) {
          const pool = CARD_TEMPLATES.filter(c => cardValue(c) <= tv);
          if (pool.length) tradeOfferAI.push(cloneCard(pool[Math.floor(Math.random() * pool.length)]));
        }
        return;
      }
      const sh = shuffle([...avail]);
      let val = 0;
      for (const c of sh) {
        if (val >= tv || tradeOfferAI.length >= 3) break;
        tradeOfferAI.push(c); val += cardValue(c);
      }
    }

    function executeTrade() {
      for (const c of tradeOfferPlayer) {
        const idx = playerCollection.findIndex(p => p.uid === c.uid);
        if (idx >= 0) playerCollection.splice(idx, 1);
        const di = playerDeck.findIndex(d => d.uid === c.uid);
        if (di >= 0) playerDeck.splice(di, 1);
      }
      for (const c of tradeOfferAI) {
        playerCollection.push(c);
        const ai = aiCollection.findIndex(a => a.uid === c.uid);
        if (ai >= 0) aiCollection.splice(ai, 1);
      }
      for (const c of tradeOfferPlayer) aiCollection.push(c);
      tradePhase = 'done';
      updateUI();
    }

    // ========== INPUT ==========

    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      mouseX = (e.clientX - r.left) * (W / r.width);
      mouseY = (e.clientY - r.top) * (H / r.height);
    });

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      if (view === 'collection') { collScrollY -= e.deltaY * 0.5; collScrollY = Math.min(0, collScrollY); }
      else if (view === 'deckbuilder') { deckScrollY -= e.deltaY * 0.5; deckScrollY = Math.min(0, deckScrollY); }
    }, { passive: false });

    canvas.addEventListener('click', e => {
      const r = canvas.getBoundingClientRect();
      const cx = (e.clientX - r.left) * (W / r.width);
      const cy = (e.clientY - r.top) * (H / r.height);
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { resetAll(); return; }
      for (const btn of menuButtons) {
        if (inRect(cx, cy, btn)) { handleAction(btn.action, btn); return; }
      }
      if (view === 'battle') handleBattleClick(cx, cy);
      else if (view === 'deckbuilder') handleDeckBuilderClick(cx, cy);
      else if (view === 'trade') handleTradeClick(cx, cy);
      else if (view === 'packopen' && tradePhase === 'done') { tradePhase = 'select'; view = 'menu'; }
    });

    function handleAction(action, btn) {
      switch (action) {
        case 'battle':
          if (playerDeck.length < 10) { battleState = null; view = 'menu'; return; }
          aiDeck = aiBuildDeck(aiCollection);
          initBattle();
          break;
        case 'tournament':
          if (playerDeck.length < 10) return;
          initTournament();
          break;
        case 'buypack':
          if (gold >= 50) { gold -= 50; packCards = generatePack(); packRevealIdx = -1; view = 'packopen'; updateUI(); }
          break;
        case 'collection': collScrollY = 0; view = 'collection'; break;
        case 'deckbuilder': deckScrollY = 0; view = 'deckbuilder'; break;
        case 'trade': tradeOfferPlayer = []; tradeOfferAI = []; tradePhase = 'select'; view = 'trade'; break;
        case 'menu': view = 'menu'; break;
        case 'openpack': packRevealIdx = 0; break;
        case 'revealnext': if (packRevealIdx < packCards.length - 1) packRevealIdx++; break;
        case 'packcontinue':
          for (const c of packCards) playerCollection.push(c);
          updateUI();
          if (tournamentState && !tournamentState.eliminated) {
            tournamentState.results.push(true);
            tournamentState.round++;
            gold += tournamentState.rewards[tournamentState.round - 2] || 0;
            updateUI();
            view = 'tournament';
          } else view = 'menu';
          break;
        case 'endturn': endPlayerTurn(); break;
        case 'tournfight':
          const rd = btn.round !== undefined ? btn.round : tournamentState.round - 1;
          initBattle(tournamentState.opponents[rd]);
          break;
        case 'tradeaccept': executeTrade(); break;
        case 'tradedecline': tradeOfferPlayer = []; tradeOfferAI = []; break;
      }
    }

    function handleBattleClick(cx, cy) {
      const bs = battleState;
      if (!bs || bs.gameOver) { if (bs && bs.gameOver) finishBattle(); return; }
      if (bs.turn !== 'player') return;

      // Hand
      const hw = Math.min(95, (W - 20) / Math.max(1, bs.playerHand.length));
      for (let i = 0; i < bs.playerHand.length; i++) {
        if (cx >= 10 + i * hw && cx <= 10 + i * hw + hw - 4 && cy >= 270 && cy <= 365) {
          battlePlayCard(i); return;
        }
      }

      // Player field
      for (let i = 0; i < bs.playerField.length; i++) {
        if (cx >= 10 + i * 100 && cx <= 102 + i * 100 && cy >= 158 && cy <= 234) {
          if (bs.selectedFieldCard === i) bs.selectedFieldCard = null;
          else { bs.selectedFieldCard = i; bs.attackTarget = null; }
          if (bs.selectedFieldCard !== null) {
            bs.msg = bs.aiField.length === 0 ? 'Click AI HP bar to attack!' : 'Select enemy to attack!';
          }
          return;
        }
      }

      // AI field (attack target)
      if (bs.selectedFieldCard !== null) {
        for (let i = 0; i < bs.aiField.length; i++) {
          if (cx >= 10 + i * 100 && cx <= 102 + i * 100 && cy >= 38 && cy <= 114) {
            battleAttack(bs.selectedFieldCard, i); return;
          }
        }
        // Direct attack
        if (cy < 30 && bs.aiField.length === 0) { battleAttack(bs.selectedFieldCard, -1); return; }
      }
    }

    function handleDeckBuilderClick(cx, cy) {
      // Remove from deck (X button)
      for (let i = 0; i < playerDeck.length; i++) {
        const dy = 52 + i * 21 + deckScrollY;
        if (cx >= 215 && cx <= 240 && cy >= dy && cy <= dy + 19) {
          playerDeck.splice(i, 1); updateUI(); return;
        }
      }
      // Add to deck (+ button)
      const avail = playerCollection.filter(c => !playerDeck.some(d => d.uid === c.uid)).sort((a, b) => a.cost - b.cost);
      for (let i = 0; i < avail.length; i++) {
        const dy = 52 + i * 21 + deckScrollY;
        if (cx >= 560 && cx <= 590 && cy >= dy && cy <= dy + 19 && playerDeck.length < 20) {
          playerDeck.push(avail[i]); updateUI(); return;
        }
      }
    }

    function handleTradeClick(cx, cy) {
      if (tradePhase === 'done') { tradeOfferPlayer = []; tradeOfferAI = []; tradePhase = 'select'; view = 'menu'; return; }
      if (tradePhase !== 'select') return;
      const pc = playerCollection.filter(c => !tradeOfferPlayer.some(o => o.uid === c.uid));
      const sorted = pc.sort((a, b) => cardValue(b) - cardValue(a));
      for (let i = 0; i < Math.min(sorted.length, 18); i++) {
        const col = i % 6, row = Math.floor(i / 6);
        const cardX = 8 + col * 97, cardY = 58 + row * 48;
        if (cx >= cardX && cx <= cardX + 92 && cy >= cardY && cy <= cardY + 43) {
          if (tradeOfferPlayer.length < 3) { tradeOfferPlayer.push(sorted[i]); tradeOfferAI = []; }
          return;
        }
      }
      for (let i = 0; i < tradeOfferPlayer.length; i++) {
        const cardX = 10 + i * 97;
        if (cx >= cardX + 72 && cx <= cardX + 92 && cy >= 235 && cy <= 267) {
          tradeOfferPlayer.splice(i, 1); tradeOfferAI = []; return;
        }
      }
    }

    // ========== GAME LOOP ==========

    function update() {
      if (gameState !== 'playing') return;
      if (view === 'battle' && battleState) {
        if (battleState.aiThinking) {
          battleState.aiThinkTimer--;
          if (battleState.aiThinkTimer <= 0) { battleState.aiThinking = false; aiTurn(); }
        }
      }
    }

    function draw() {
      if (gameState !== 'playing') return;
      switch (view) {
        case 'menu': drawMenu(); break;
        case 'collection': drawCollection(); break;
        case 'deckbuilder': drawDeckBuilder(); break;
        case 'battle': drawBattle(); break;
        case 'packopen': drawPackOpen(); break;
        case 'tournament': drawTournament(); break;
        case 'trade': drawTrade(); break;
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    overlay.style.display = 'flex';
    gameLoop();
  </script>
</body>
</html>

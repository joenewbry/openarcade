<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }
    .back { color: #f0f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }
    h1 { color: #f0f; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 0, 255, 0.4); }
    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .side-panel {
      width: 130px;
    }
    .panel-box {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: center;
    }
    .panel-box label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }
    .panel-box .value {
      font-size: 1.4rem;
      color: #f0f;
    }
    #nextCanvas {
      display: block;
      margin: 0 auto;
    }
    canvas#game {
      border: 2px solid #f0f;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f0f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TETRIS</h1>
  </div>
  <div class="game-area">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="300" height="600"></canvas>
      <div class="overlay" id="overlay" style="width:300px;height:600px;">
        <h2 id="overlayTitle">TETRIS</h2>
        <p id="overlayText">Press any key to start</p>
      </div>
    </div>
    <div class="side-panel">
      <div class="panel-box">
        <label>NEXT</label>
        <canvas id="nextCanvas" width="100" height="80"></canvas>
      </div>
      <div class="panel-box">
        <label>SCORE</label>
        <div class="value" id="score">0</div>
      </div>
      <div class="panel-box">
        <label>LINES</label>
        <div class="value" id="lines">0</div>
      </div>
      <div class="panel-box">
        <label>LEVEL</label>
        <div class="value" id="level">1</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nctx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const linesEl = document.getElementById('lines');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const CELL = 30;
    const COLS = 10;
    const ROWS = 20;

    const PIECES = {
      I: { shape: [[0,0],[1,0],[2,0],[3,0]], color: '#0ff' },
      O: { shape: [[0,0],[1,0],[0,1],[1,1]], color: '#ff0' },
      T: { shape: [[0,0],[1,0],[2,0],[1,1]], color: '#a0f' },
      S: { shape: [[1,0],[2,0],[0,1],[1,1]], color: '#0f0' },
      Z: { shape: [[0,0],[1,0],[1,1],[2,1]], color: '#f00' },
      J: { shape: [[0,0],[0,1],[1,1],[2,1]], color: '#00f' },
      L: { shape: [[2,0],[0,1],[1,1],[2,1]], color: '#f90' }
    };
    const PIECE_NAMES = Object.keys(PIECES);

    let board, current, next, pos, score, lines, level, gameState, timer, dropInterval;
    let flashRows = [], flashTimer = 0, flashPhase = 0, showTetrisText = 0;
    let softDropping = false;
    const SOFT_DROP_INTERVAL = 50; // ms between drops when holding ArrowDown

    function init() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      score = 0; lines = 0; level = 1;
      dropInterval = 800;
      scoreEl.textContent = '0';
      linesEl.textContent = '0';
      levelEl.textContent = '1';
      next = randomPiece();
      spawnPiece();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TETRIS';
      overlayText.textContent = 'Press any key to start';
      draw();
      drawNext();
    }

    function randomPiece() {
      const name = PIECE_NAMES[Math.floor(Math.random() * PIECE_NAMES.length)];
      return { name, shape: PIECES[name].shape.map(p => [...p]), color: PIECES[name].color };
    }

    function spawnPiece() {
      current = next;
      next = randomPiece();
      // Center the piece
      const minX = Math.min(...current.shape.map(p => p[0]));
      const maxX = Math.max(...current.shape.map(p => p[0]));
      pos = { x: Math.floor((COLS - (maxX - minX + 1)) / 2) - minX, y: 0 };

      // Adjust y so piece starts with its topmost row at y=0
      const minY = Math.min(...current.shape.map(p => p[1]));
      pos.y = -minY;

      if (collides(current.shape, pos)) {
        gameOver();
      }
    }

    function collides(shape, p) {
      return shape.some(([sx, sy]) => {
        const nx = p.x + sx, ny = p.y + sy;
        return nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0 && board[ny][nx]);
      });
    }

    function lock() {
      current.shape.forEach(([sx, sy]) => {
        const nx = pos.x + sx, ny = pos.y + sy;
        if (ny >= 0 && ny < ROWS) board[ny][nx] = current.color;
      });

      // Find full rows
      flashRows = [];
      for (let r = 0; r < ROWS; r++) {
        if (board[r].every(c => c !== null)) flashRows.push(r);
      }

      if (flashRows.length > 0) {
        // Pause game and run flash animation
        clearTimeout(timer);
        gameState = 'animating';
        flashPhase = 0;
        if (flashRows.length === 4) showTetrisText = 1;
        animateFlash();
      } else {
        spawnPiece();
        drawNext();
      }
    }

    function animateFlash() {
      flashPhase++;
      draw();

      if (flashPhase <= 12) {
        setTimeout(animateFlash, 40);
      } else {
        // Remove rows and update score
        const cleared = flashRows.length;
        flashRows.sort((a, b) => b - a).forEach(r => {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(null));
        });
        const points = [0, 100, 300, 500, 800];
        score += points[cleared] * level;
        lines += cleared;
        level = Math.floor(lines / 10) + 1;
        dropInterval = Math.max(100, 800 - (level - 1) * 70);
        scoreEl.textContent = score;
        linesEl.textContent = lines;
        levelEl.textContent = level;
        flashRows = [];
        showTetrisText = 0;
        spawnPiece();
        drawNext();
        gameState = 'playing';
        draw();
        timer = setTimeout(tick, dropInterval);
      }
    }

    function rotate() {
      // Rotate 90 degrees clockwise around center of bounding box
      const maxX = Math.max(...current.shape.map(p => p[0]));
      const maxY = Math.max(...current.shape.map(p => p[1]));
      const newShape = current.shape.map(([x, y]) => [maxY - y, x]);

      // Wall kick attempts
      const kicks = [{ x: 0, y: 0 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: -2, y: 0 }, { x: 2, y: 0 }, { x: 0, y: -1 }];
      for (const kick of kicks) {
        const testPos = { x: pos.x + kick.x, y: pos.y + kick.y };
        if (!collides(newShape, testPos)) {
          current.shape = newShape;
          pos.x = testPos.x;
          pos.y = testPos.y;
          return;
        }
      }
    }

    function drop(isSoftDrop) {
      pos.y++;
      if (collides(current.shape, pos)) {
        pos.y--;
        lock();
      } else if (isSoftDrop) {
        score += 1;
        scoreEl.textContent = score;
      }
    }

    function hardDrop() {
      while (!collides(current.shape, { x: pos.x, y: pos.y + 1 })) {
        pos.y++;
        score += 2;
      }
      scoreEl.textContent = score;
      lock();
    }

    function ghostY() {
      let gy = pos.y;
      while (!collides(current.shape, { x: pos.x, y: gy + 1 })) gy++;
      return gy;
    }

    function move(dx) {
      pos.x += dx;
      if (collides(current.shape, pos)) pos.x -= dx;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      tick();
    }

    function tick() {
      clearTimeout(timer);
      if (gameState !== 'playing') return;
      drop(softDropping);
      draw();
      timer = setTimeout(tick, softDropping ? SOFT_DROP_INTERVAL : dropInterval);
    }

    function gameOver() {
      gameState = 'over';
      clearTimeout(timer);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function drawBlock(context, x, y, color, size) {
      context.fillStyle = color;
      context.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);
      // Highlight
      context.fillStyle = 'rgba(255,255,255,0.15)';
      context.fillRect(x * size + 1, y * size + 1, size - 2, 3);
      context.fillRect(x * size + 1, y * size + 1, 3, size - 2);
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= canvas.width; x += CELL) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += CELL) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
      }

      // Board
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) drawBlock(ctx, c, r, board[r][c], CELL);
        }
      }

      // Flash animation on cleared rows
      if (flashRows.length > 0 && flashPhase > 0) {
        const pulse = Math.sin(flashPhase * 0.8) * 0.5 + 0.5;
        flashRows.forEach(r => {
          ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.8})`;
          ctx.fillRect(0, r * CELL, canvas.width, CELL);
        });

        // "TETRIS!" text for 4-line clear
        if (showTetrisText) {
          const scale = 1 + Math.sin(flashPhase * 0.6) * 0.15;
          ctx.save();
          ctx.translate(canvas.width / 2, canvas.height / 2);
          ctx.scale(scale, scale);
          ctx.font = 'bold 48px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
          ctx.shadowColor = '#f0f';
          ctx.shadowBlur = 30;
          ctx.fillText('TETRIS!', 0, 0);
          ctx.shadowBlur = 0;
          ctx.restore();
        }
      }

      if (gameState === 'playing' || gameState === 'waiting') {
        // Ghost
        const gy = ghostY();
        current.shape.forEach(([sx, sy]) => {
          const gx = pos.x + sx, gpy = gy + sy;
          if (gpy >= 0) {
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(gx * CELL + 1, gpy * CELL + 1, CELL - 2, CELL - 2);
          }
        });

        // Current piece
        current.shape.forEach(([sx, sy]) => {
          const px = pos.x + sx, py = pos.y + sy;
          if (py >= 0) drawBlock(ctx, px, py, current.color, CELL);
        });
      }
    }

    function drawNext() {
      nctx.fillStyle = '#16213e';
      nctx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
      const size = 20;
      const minX = Math.min(...next.shape.map(p => p[0]));
      const maxX = Math.max(...next.shape.map(p => p[0]));
      const minY = Math.min(...next.shape.map(p => p[1]));
      const maxY = Math.max(...next.shape.map(p => p[1]));
      const pw = (maxX - minX + 1) * size;
      const ph = (maxY - minY + 1) * size;
      const ox = Math.floor((nextCanvas.width - pw) / 2) / size - minX;
      const oy = Math.floor((nextCanvas.height - ph) / 2) / size - minY;
      next.shape.forEach(([sx, sy]) => {
        drawBlock(nctx, ox + sx, oy + sy, next.color, size);
      });
    }

    document.addEventListener('keydown', (e) => {
      const gameKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '];
      if (gameKeys.includes(e.key)) e.preventDefault();

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowLeft': move(-1); break;
          case 'ArrowRight': move(1); break;
          case 'ArrowDown':
            if (!softDropping) {
              softDropping = true;
              // Restart tick at fast rate immediately
              clearTimeout(timer);
              tick();
            }
            break;
          case 'ArrowUp': rotate(); break;
          case ' ': hardDrop(); break;
        }
        draw();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown' && softDropping) {
        softDropping = false;
        // Resume normal speed
        clearTimeout(timer);
        timer = setTimeout(tick, dropInterval);
      }
    });

    init();
  </script>
</body>
</html>

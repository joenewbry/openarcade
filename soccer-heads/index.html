<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soccer Heads</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4d4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 221, 68, 0.5); }
    h1 { color: #4d4; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 221, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4d4; }
    canvas {
      border: 2px solid #4d4;
      box-shadow: 0 0 20px rgba(68, 221, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4d4;
      text-align: center;
      pointer-events: none;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(68, 221, 68, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SOCCER HEADS</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="playerScore">0</span></div>
    <div id="timer" style="color:#aaa;">0:00</div>
    <div>CPU: <span id="cpuScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="350"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:350px;">
      <h2 id="overlayTitle">SOCCER HEADS</h2>
      <p id="overlayText">Arrow Keys = Move, Up = Jump, Space = Kick<br>First to 5 goals wins!<br><br>Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerScoreEl = document.getElementById('playerScore');
    const cpuScoreEl = document.getElementById('cpuScore');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const W = 600, H = 350;
    const GRAVITY = 0.45;
    const GROUND_Y = H - 40;
    const WIN_SCORE = 5;

    // Goal dimensions
    const GOAL_W = 40;
    const GOAL_H = 80;
    const GOAL_TOP = GROUND_Y - GOAL_H;

    // Character dimensions
    const CHAR_RADIUS = 22; // head radius
    const CHAR_BODY_H = 20; // body height below head
    const CHAR_W = 28;

    // Ball
    const BALL_R = 10;

    let gameState = 'waiting';
    let score = 0;
    let keys = {};
    let elapsed = 0;
    let lastTime = 0;
    let goalPause = 0;
    let goalMessage = '';

    // Ball trail
    let trail = [];
    const TRAIL_MAX = 12;

    // Particles
    let particles = [];

    // Player object
    let player, cpu, ball;

    function createPlayer(x, facingRight) {
      return {
        x: x,
        y: GROUND_Y,
        vx: 0,
        vy: 0,
        w: CHAR_W,
        radius: CHAR_RADIUS,
        onGround: true,
        facingRight: facingRight,
        kickTimer: 0,
        kickCooldown: 0,
        color: facingRight ? '#4af' : '#f54',
        headColor: facingRight ? '#5bf' : '#f65',
        isKicking: false
      };
    }

    function createBall(x, y) {
      return {
        x: x, y: y,
        vx: 0, vy: 0,
        r: BALL_R
      };
    }

    function init() {
      player = createPlayer(150, true);
      cpu = createPlayer(450, false);
      ball = createBall(W / 2, 100);
      ball.vx = 0;
      ball.vy = 0;
      score = 0;
      elapsed = 0;
      lastTime = 0;
      goalPause = 0;
      goalMessage = '';
      trail = [];
      particles = [];
      playerScoreEl.textContent = '0';
      cpuScoreEl.textContent = '0';
      timerEl.textContent = '0:00';
      player.score = 0;
      cpu.score = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SOCCER HEADS';
      overlayText.innerHTML = 'Arrow Keys = Move, Up = Jump, Space = Kick<br>First to 5 goals wins!<br><br>Press SPACE to start';
      draw();
    }

    function resetAfterGoal() {
      player.x = 150;
      player.y = GROUND_Y;
      player.vx = 0;
      player.vy = 0;
      player.onGround = true;
      cpu.x = 450;
      cpu.y = GROUND_Y;
      cpu.vx = 0;
      cpu.vy = 0;
      cpu.onGround = true;
      ball.x = W / 2;
      ball.y = 120;
      ball.vx = (Math.random() - 0.5) * 2;
      ball.vy = -2;
      trail = [];
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function loop(timestamp) {
      if (gameState !== 'playing' && gameState !== 'goalPause') return;
      const dt = Math.min((timestamp - lastTime) / 16.67, 2); // normalized to ~60fps
      lastTime = timestamp;

      if (gameState === 'goalPause') {
        goalPause -= dt;
        if (goalPause <= 0) {
          if (player.score >= WIN_SCORE || cpu.score >= WIN_SCORE) {
            gameState = 'over';
            overlay.style.display = 'flex';
            if (player.score >= WIN_SCORE) {
              overlayTitle.textContent = 'YOU WIN!';
            } else {
              overlayTitle.textContent = 'CPU WINS!';
            }
            overlayText.textContent = player.score + ' - ' + cpu.score + ' -- Press SPACE to play again';
            return;
          }
          resetAfterGoal();
          gameState = 'playing';
        }
        draw();
        requestAnimationFrame(loop);
        return;
      }

      elapsed += dt / 60;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      // Player input
      const MOVE_SPEED = 4;
      const JUMP_SPEED = -8.5;

      if (keys['ArrowLeft']) player.vx = -MOVE_SPEED;
      else if (keys['ArrowRight']) player.vx = MOVE_SPEED;
      else player.vx *= 0.7;

      if (keys['ArrowUp'] && player.onGround) {
        player.vy = JUMP_SPEED;
        player.onGround = false;
      }

      if (keys[' '] && player.kickCooldown <= 0) {
        player.isKicking = true;
        player.kickTimer = 8;
        player.kickCooldown = 20;
      }

      // AI logic
      updateAI(dt);

      // Update characters
      updateChar(player, dt);
      updateChar(cpu, dt);

      // Update ball
      updateBall(dt);

      // Character-ball collisions
      handleCharBallCollision(player);
      handleCharBallCollision(cpu);

      // Kick collisions
      if (player.kickTimer > 0) {
        handleKick(player, ball);
        player.kickTimer -= dt;
        if (player.kickTimer <= 0) player.isKicking = false;
      }
      if (player.kickCooldown > 0) player.kickCooldown -= dt;

      if (cpu.kickTimer > 0) {
        handleKick(cpu, ball);
        cpu.kickTimer -= dt;
        if (cpu.kickTimer <= 0) cpu.isKicking = false;
      }
      if (cpu.kickCooldown > 0) cpu.kickCooldown -= dt;

      // Character-character collision
      handleCharCharCollision(player, cpu);

      // Check goals
      checkGoals();

      // Update timer display
      const mins = Math.floor(elapsed / 60);
      const secs = Math.floor(elapsed % 60);
      timerEl.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;

      // Update trail
      trail.push({ x: ball.x, y: ball.y });
      if (trail.length > TRAIL_MAX) trail.shift();

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 0.2 * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function updateAI(dt) {
      const AI_SPEED = 3.2;
      const AI_JUMP_SPEED = -8.5;

      // Determine AI state based on ball position
      const ballDist = Math.abs(ball.x - cpu.x);
      const ballIsOnMySide = ball.x > W / 2 - 30;
      const ballComingToMe = ball.vx > 0;
      const ballAboveMe = ball.y < cpu.y - 30;

      let targetX = cpu.x;

      if (ballIsOnMySide || ballComingToMe) {
        // Move toward ball
        targetX = ball.x + (ball.vx > 0 ? ball.vx * 5 : 0);
        // Position slightly behind ball relative to own goal
        if (ball.x > cpu.x) {
          targetX = ball.x - 15;
        } else {
          targetX = ball.x + 15;
        }
      } else {
        // Return to defensive position
        targetX = 420;
      }

      // Move toward target
      const diff = targetX - cpu.x;
      if (Math.abs(diff) > 5) {
        cpu.vx = Math.sign(diff) * AI_SPEED;
      } else {
        cpu.vx *= 0.7;
      }

      // Jump logic
      const shouldJump = (
        (ballDist < 80 && ballAboveMe && ball.y < GROUND_Y - 50) ||
        (ballDist < 60 && ball.y < cpu.y - 20) ||
        (ball.y < GROUND_Y - 100 && ballDist < 100 && ball.vy < 0)
      );

      if (shouldJump && cpu.onGround) {
        cpu.vy = AI_JUMP_SPEED;
        cpu.onGround = false;
      }

      // Kick logic
      const kickDist = Math.hypot(ball.x - cpu.x, ball.y - (cpu.y - CHAR_RADIUS));
      if (kickDist < 50 && cpu.kickCooldown <= 0 && ball.x < cpu.x) {
        cpu.isKicking = true;
        cpu.kickTimer = 8;
        cpu.kickCooldown = 25;
      }
    }

    function updateChar(ch, dt) {
      // Apply gravity
      ch.vy += GRAVITY * dt;

      // Move
      ch.x += ch.vx * dt;
      ch.y += ch.vy * dt;

      // Floor collision
      if (ch.y >= GROUND_Y) {
        ch.y = GROUND_Y;
        ch.vy = 0;
        ch.onGround = true;
      }

      // Wall collision - keep characters on field but allow going near goals
      const minX = GOAL_W + ch.w / 2;
      const maxX = W - GOAL_W - ch.w / 2;
      ch.x = Math.max(minX, Math.min(maxX, ch.x));

      // Update facing
      if (ch === player) {
        if (ch.vx > 0.5) ch.facingRight = true;
        else if (ch.vx < -0.5) ch.facingRight = false;
      } else {
        if (ch.vx > 0.5) ch.facingRight = true;
        else if (ch.vx < -0.5) ch.facingRight = false;
      }
    }

    function updateBall(dt) {
      ball.vy += GRAVITY * dt;
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Floor bounce
      if (ball.y + ball.r > GROUND_Y) {
        ball.y = GROUND_Y - ball.r;
        ball.vy = -ball.vy * 0.7;
        ball.vx *= 0.95;
        if (Math.abs(ball.vy) < 0.5) ball.vy = 0;
      }

      // Ceiling bounce
      if (ball.y - ball.r < 0) {
        ball.y = ball.r;
        ball.vy = Math.abs(ball.vy) * 0.8;
      }

      // Wall bounces (but not in goal areas)
      // Left wall
      if (ball.x - ball.r < 0) {
        // Check if in goal area
        if (ball.y > GOAL_TOP && ball.y < GROUND_Y) {
          // Ball in goal area - let it through for scoring
        } else {
          ball.x = ball.r;
          ball.vx = Math.abs(ball.vx) * 0.8;
        }
      }

      // Right wall
      if (ball.x + ball.r > W) {
        if (ball.y > GOAL_TOP && ball.y < GROUND_Y) {
          // Ball in goal area
        } else {
          ball.x = W - ball.r;
          ball.vx = -Math.abs(ball.vx) * 0.8;
        }
      }

      // Goal post collisions (top bar)
      // Left goal
      if (ball.x - ball.r < GOAL_W && ball.x + ball.r > 0) {
        if (Math.abs(ball.y - GOAL_TOP) < ball.r + 3 && ball.y < GOAL_TOP) {
          ball.y = GOAL_TOP - ball.r;
          ball.vy = -Math.abs(ball.vy) * 0.7;
        }
      }
      // Right goal
      if (ball.x + ball.r > W - GOAL_W && ball.x - ball.r < W) {
        if (Math.abs(ball.y - GOAL_TOP) < ball.r + 3 && ball.y < GOAL_TOP) {
          ball.y = GOAL_TOP - ball.r;
          ball.vy = -Math.abs(ball.vy) * 0.7;
        }
      }

      // Goal side post collisions
      // Left goal right post
      if (ball.y > GOAL_TOP && ball.y < GROUND_Y) {
        if (Math.abs(ball.x - GOAL_W) < ball.r + 2 && ball.x > GOAL_W) {
          ball.x = GOAL_W + ball.r + 2;
          ball.vx = Math.abs(ball.vx) * 0.7;
        }
      }
      // Right goal left post
      if (ball.y > GOAL_TOP && ball.y < GROUND_Y) {
        if (Math.abs(ball.x - (W - GOAL_W)) < ball.r + 2 && ball.x < W - GOAL_W) {
          ball.x = W - GOAL_W - ball.r - 2;
          ball.vx = -Math.abs(ball.vx) * 0.7;
        }
      }

      // Cap ball speed
      const speed = Math.hypot(ball.vx, ball.vy);
      const MAX_BALL_SPEED = 12;
      if (speed > MAX_BALL_SPEED) {
        ball.vx = (ball.vx / speed) * MAX_BALL_SPEED;
        ball.vy = (ball.vy / speed) * MAX_BALL_SPEED;
      }

      // Damping
      ball.vx *= 0.999;
    }

    function handleCharBallCollision(ch) {
      // Head (circle) collision with ball
      const headX = ch.x;
      const headY = ch.y - CHAR_BODY_H - ch.radius;

      const dx = ball.x - headX;
      const dy = ball.y - headY;
      const dist = Math.hypot(dx, dy);
      const minDist = ch.radius + ball.r;

      if (dist < minDist && dist > 0) {
        // Separate
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;

        ball.x += nx * overlap;
        ball.y += ny * overlap;

        // Relative velocity
        const relVx = ball.vx - ch.vx;
        const relVy = ball.vy - ch.vy;
        const relDot = relVx * nx + relVy * ny;

        if (relDot < 0) {
          const bounce = 1.3;
          ball.vx -= relDot * nx * bounce;
          ball.vy -= relDot * ny * bounce;

          // Add some of character velocity
          ball.vx += ch.vx * 0.5;
          ball.vy += ch.vy * 0.3;

          // Particles
          spawnParticles(ball.x, ball.y, '#fff', 4);
        }
      }

      // Body collision (simple rectangle approximation)
      const bodyTop = ch.y - CHAR_BODY_H;
      const bodyLeft = ch.x - ch.w / 2;
      const bodyRight = ch.x + ch.w / 2;

      if (ball.x + ball.r > bodyLeft && ball.x - ball.r < bodyRight &&
          ball.y + ball.r > bodyTop && ball.y - ball.r < ch.y) {
        // Push ball out
        const fromLeft = ball.x - bodyLeft;
        const fromRight = bodyRight - ball.x;
        const fromTop = ball.y - bodyTop;

        if (fromTop < fromLeft && fromTop < fromRight) {
          ball.y = bodyTop - ball.r;
          ball.vy = Math.min(ball.vy, ch.vy - 3);
        } else if (fromLeft < fromRight) {
          ball.x = bodyLeft - ball.r;
          ball.vx = Math.min(ball.vx, -2);
        } else {
          ball.x = bodyRight + ball.r;
          ball.vx = Math.max(ball.vx, 2);
        }
      }
    }

    function handleKick(ch, ball) {
      // Kick has a forward arc in front of the character
      const kickDir = ch === player ? (ch.facingRight ? 1 : -1) : (ch.facingRight ? 1 : -1);
      const kickX = ch.x + kickDir * (ch.w / 2 + 10);
      const kickY = ch.y - CHAR_BODY_H / 2;

      const dx = ball.x - kickX;
      const dy = ball.y - kickY;
      const dist = Math.hypot(dx, dy);

      if (dist < 35) {
        const power = 8;
        const angle = Math.atan2(dy - 5, dx);
        ball.vx = Math.cos(angle) * power + ch.vx * 0.5;
        ball.vy = Math.sin(angle) * power - 2;

        // Kick particles
        spawnParticles(kickX, kickY, '#ff0', 6);

        // Reset kick timer so it only hits once
        ch.kickTimer = 0;
        ch.isKicking = false;
      }
    }

    function handleCharCharCollision(a, b) {
      const dx = b.x - a.x;
      const dist = Math.abs(dx);
      const minDist = a.w / 2 + b.w / 2 + 4;

      if (dist < minDist) {
        const push = (minDist - dist) / 2;
        const dir = dx > 0 ? 1 : -1;
        a.x -= dir * push;
        b.x += dir * push;
        // Transfer some momentum
        const avgVx = (a.vx + b.vx) / 2;
        a.vx = avgVx - dir * 0.5;
        b.vx = avgVx + dir * 0.5;
      }
    }

    function checkGoals() {
      // Left goal (CPU scores)
      if (ball.x < GOAL_W - 5 && ball.y > GOAL_TOP && ball.y < GROUND_Y) {
        cpu.score++;
        cpuScoreEl.textContent = cpu.score;
        goalMessage = 'CPU GOAL!';
        gameState = 'goalPause';
        goalPause = 90;
        spawnParticles(ball.x, ball.y, '#f54', 20);
        return;
      }

      // Right goal (Player scores)
      if (ball.x > W - GOAL_W + 5 && ball.y > GOAL_TOP && ball.y < GROUND_Y) {
        player.score++;
        score = player.score;
        playerScoreEl.textContent = player.score;
        goalMessage = 'GOAL!';
        gameState = 'goalPause';
        goalPause = 90;
        spawnParticles(ball.x, ball.y, '#4af', 20);
        return;
      }
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x: x, y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          color: color,
          life: 20 + Math.random() * 20,
          maxLife: 40
        });
      }
    }

    // ======================== DRAWING ========================

    function draw() {
      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      skyGrad.addColorStop(0, '#0a0a1e');
      skyGrad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, GROUND_Y);

      // Ground
      ctx.fillStyle = '#2a5a1a';
      ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

      // Ground line
      ctx.strokeStyle = '#4d4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(W, GROUND_Y);
      ctx.stroke();

      // Field markings
      ctx.strokeStyle = 'rgba(68, 221, 68, 0.15)';
      ctx.lineWidth = 1;
      // Center line
      ctx.beginPath();
      ctx.moveTo(W / 2, GROUND_Y - 2);
      ctx.lineTo(W / 2, H);
      ctx.stroke();
      // Center circle
      ctx.beginPath();
      ctx.arc(W / 2, GROUND_Y, 40, Math.PI, 2 * Math.PI);
      ctx.stroke();

      // Draw goals
      drawGoal(0, true);
      drawGoal(W - GOAL_W, false);

      // Ball trail
      for (let i = 0; i < trail.length; i++) {
        const alpha = (i / trail.length) * 0.4;
        const r = ball.r * (i / trail.length) * 0.7;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw ball
      drawBall();

      // Draw characters
      drawCharacter(player, '#4af', '#5bf', 'P1');
      drawCharacter(cpu, '#f54', '#f65', 'CPU');

      // Draw kick effects
      if (player.isKicking) drawKickArc(player);
      if (cpu.isKicking) drawKickArc(cpu);

      // Particles
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;

      // Goal message
      if (gameState === 'goalPause' && goalMessage) {
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = goalMessage === 'GOAL!' ? '#4af' : '#f54';
        ctx.shadowBlur = 25;
        ctx.fillText(goalMessage, W / 2, H / 2 - 20);
        ctx.shadowBlur = 0;
        ctx.restore();

        // Show score
        ctx.fillStyle = '#aaa';
        ctx.font = '18px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(player.score + ' - ' + cpu.score, W / 2, H / 2 + 15);
      }

      // Big score watermark
      ctx.fillStyle = 'rgba(68, 221, 68, 0.05)';
      ctx.font = 'bold 100px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(player.score + ' - ' + cpu.score, W / 2, 140);
    }

    function drawGoal(x, isLeft) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;

      if (isLeft) {
        // Left goal
        ctx.beginPath();
        ctx.moveTo(x + GOAL_W, GOAL_TOP);
        ctx.lineTo(x, GOAL_TOP);
        ctx.lineTo(x, GROUND_Y);
        ctx.stroke();

        // Net pattern
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i < GOAL_H; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x, GOAL_TOP + i);
          ctx.lineTo(x + GOAL_W, GOAL_TOP + i);
          ctx.stroke();
        }
        for (let i = 0; i < GOAL_W; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x + i, GOAL_TOP);
          ctx.lineTo(x + i, GROUND_Y);
          ctx.stroke();
        }
      } else {
        // Right goal
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, GOAL_TOP);
        ctx.lineTo(x + GOAL_W, GOAL_TOP);
        ctx.lineTo(x + GOAL_W, GROUND_Y);
        ctx.stroke();

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i < GOAL_H; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x, GOAL_TOP + i);
          ctx.lineTo(x + GOAL_W, GOAL_TOP + i);
          ctx.stroke();
        }
        for (let i = 0; i < GOAL_W; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x + i, GOAL_TOP);
          ctx.lineTo(x + i, GROUND_Y);
          ctx.stroke();
        }
      }
    }

    function drawBall() {
      ctx.save();
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(ball.x, GROUND_Y + 2, ball.r * 0.8, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Ball glow
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Ball pattern (hexagon marks)
      ctx.fillStyle = '#ccc';
      ctx.beginPath();
      ctx.arc(ball.x - 2, ball.y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ball.x + 4, ball.y + 1, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ball.x - 1, ball.y + 4, 2, 0, Math.PI * 2);
      ctx.fill();

      // Outline
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawCharacter(ch, bodyColor, headColor, label) {
      const x = ch.x;
      const y = ch.y;
      const headY = y - CHAR_BODY_H - ch.radius;

      ctx.save();

      // Shadow on ground
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(x, GROUND_Y + 2, ch.w / 2, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Legs
      const legSpread = Math.sin(Date.now() / 100) * (Math.abs(ch.vx) > 0.5 ? 6 : 0);
      ctx.strokeStyle = bodyColor;
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      // Left leg
      ctx.beginPath();
      ctx.moveTo(x - 5, y - 4);
      ctx.lineTo(x - 8 - legSpread, y);
      ctx.stroke();
      // Right leg
      ctx.beginPath();
      ctx.moveTo(x + 5, y - 4);
      ctx.lineTo(x + 8 + legSpread, y);
      ctx.stroke();

      // Body
      ctx.fillStyle = bodyColor;
      ctx.shadowColor = bodyColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(x - ch.w / 2 + 4, y - CHAR_BODY_H, ch.w - 8, CHAR_BODY_H - 2);
      ctx.shadowBlur = 0;

      // Arms
      const armAngle = ch.isKicking ? -0.8 : Math.sin(Date.now() / 120) * 0.3;
      ctx.strokeStyle = bodyColor;
      ctx.lineWidth = 3;
      const dir = ch.facingRight ? 1 : -1;
      // Back arm
      ctx.beginPath();
      ctx.moveTo(x - dir * 4, y - CHAR_BODY_H + 4);
      ctx.lineTo(x - dir * 14, y - CHAR_BODY_H + 10 + Math.sin(armAngle + 1) * 5);
      ctx.stroke();
      // Front arm
      ctx.beginPath();
      ctx.moveTo(x + dir * 4, y - CHAR_BODY_H + 4);
      if (ch.isKicking) {
        ctx.lineTo(x + dir * 20, y - CHAR_BODY_H - 2);
      } else {
        ctx.lineTo(x + dir * 14, y - CHAR_BODY_H + 10 + Math.sin(armAngle) * 5);
      }
      ctx.stroke();

      // Head (big!)
      ctx.fillStyle = headColor;
      ctx.shadowColor = headColor;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(x, headY, ch.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Face
      const eyeDir = ch.facingRight ? 1 : -1;
      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x + eyeDir * 6, headY - 4, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + eyeDir * 14, headY - 4, 4, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(x + eyeDir * 7, headY - 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + eyeDir * 15, headY - 4, 2, 0, Math.PI * 2);
      ctx.fill();
      // Mouth
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      if (ch.isKicking) {
        ctx.arc(x + eyeDir * 10, headY + 6, 4, 0, Math.PI);
      } else {
        ctx.moveTo(x + eyeDir * 6, headY + 7);
        ctx.lineTo(x + eyeDir * 14, headY + 7);
      }
      ctx.stroke();

      // Hair / headband
      ctx.strokeStyle = ch === player ? '#2a8af5' : '#d42';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, headY, ch.radius, -Math.PI * 0.85, -Math.PI * 0.15);
      ctx.stroke();

      // Label
      ctx.fillStyle = '#fff';
      ctx.font = '10px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(label, x, headY - ch.radius - 6);

      ctx.restore();
    }

    function drawKickArc(ch) {
      const dir = ch.facingRight ? 1 : -1;
      const kickX = ch.x + dir * (ch.w / 2 + 5);
      const kickY = ch.y - CHAR_BODY_H / 2;

      ctx.save();
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(kickX, kickY, 20, dir > 0 ? -0.8 : Math.PI - 0.8, dir > 0 ? 0.8 : Math.PI + 0.8);
      ctx.stroke();

      // Shoe / foot
      ctx.fillStyle = ch === player ? '#4af' : '#f54';
      ctx.beginPath();
      ctx.arc(ch.x + dir * 18, ch.y - 6, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // ======================== INPUT ========================

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
      keys[e.key] = true;

      if (gameState === 'waiting' && e.key === ' ') {
        start();
        return;
      }
      if (gameState === 'over' && e.key === ' ') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lemmings</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #8af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 170, 255, 0.4); }
    h1 { color: #8af; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8af; }
    canvas {
      border: 2px solid #8af;
      box-shadow: 0 0 20px rgba(136, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .ability-bar {
      display: flex;
      gap: 6px;
      width: 600px;
      margin-top: 10px;
    }
    .ability-btn {
      flex: 1;
      background: #16213e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      padding: 6px 4px;
      text-align: center;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      color: #888;
      cursor: pointer;
      transition: all 0.1s;
    }
    .ability-btn.selected {
      border-color: #8af;
      color: #8af;
      background: rgba(136, 170, 255, 0.15);
      box-shadow: 0 0 10px rgba(136, 170, 255, 0.3);
    }
    .ability-btn .key { font-size: 1.1rem; display: block; color: #8af; margin-bottom: 2px; }
    .ability-btn .count { font-size: 0.9rem; color: #8af; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>LEMMINGS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">LEMMINGS</h2>
      <p id="overlayText">Click to start</p>
    </div>
  </div>
  <div class="ability-bar">
    <div class="ability-btn" id="ab-1" data-ability="1"><span class="key">1</span>Digger<br><span class="count" id="cnt-1">5</span></div>
    <div class="ability-btn" id="ab-2" data-ability="2"><span class="key">2</span>Builder<br><span class="count" id="cnt-2">5</span></div>
    <div class="ability-btn" id="ab-3" data-ability="3"><span class="key">3</span>Blocker<br><span class="count" id="cnt-3">3</span></div>
    <div class="ability-btn" id="ab-4" data-ability="4"><span class="key">4</span>Basher<br><span class="count" id="cnt-4">5</span></div>
    <div class="ability-btn" id="ab-5" data-ability="5"><span class="key">5</span>Climber<br><span class="count" id="cnt-5">3</span></div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = parseInt(localStorage.getItem('lemmings-best')) || 0;
    bestEl.textContent = best;

    // Pixel-based terrain map
    const TERRAIN_W = 1200;
    const TERRAIN_H = 400;
    let terrain; // Uint8Array, 1 = solid, 0 = air

    // Camera / scroll
    let camX = 0;
    const CAM_SPEED = 4;
    let keys = {};

    // Level config
    let level = 1;
    let entryX, entryY, exitX, exitY;
    let totalLemmings, neededToSave, spawnRate, spawnTimer, spawnedCount;
    let lemmings = [];
    let savedCount, deadCount;
    let selectedLemming = null;
    let selectedAbility = 0;

    // Ability counts
    let abilities = {};

    // Particle effects
    let particles = [];

    function terrainGet(x, y) {
      if (x < 0 || x >= TERRAIN_W || y < 0 || y >= TERRAIN_H) return 0;
      return terrain[y * TERRAIN_W + x];
    }

    function terrainSet(x, y, val) {
      if (x < 0 || x >= TERRAIN_W || y < 0 || y >= TERRAIN_H) return;
      terrain[y * TERRAIN_W + x] = val;
    }

    function terrainRect(x, y, w, h, val) {
      for (let py = y; py < y + h; py++) {
        for (let px = x; px < x + w; px++) {
          terrainSet(px, py, val);
        }
      }
    }

    function generateLevel() {
      terrain = new Uint8Array(TERRAIN_W * TERRAIN_H);

      // Base ground
      terrainRect(0, TERRAIN_H - 30, TERRAIN_W, 30, 1);

      const seed = level * 7 + 13;
      function seededRand(i) {
        let v = Math.sin(seed * 9301 + i * 49297 + 233) * 10000;
        return v - Math.floor(v);
      }
      let ri = 0;
      function rand() { return seededRand(ri++); }

      // Generate platforms at various heights
      const numPlatforms = 6 + Math.min(level, 8);
      for (let i = 0; i < numPlatforms; i++) {
        const px = Math.floor(rand() * (TERRAIN_W - 200)) + 50;
        const py = 80 + Math.floor(rand() * (TERRAIN_H - 150));
        const pw = 60 + Math.floor(rand() * 140);
        const ph = 12 + Math.floor(rand() * 8);
        terrainRect(px, py, pw, ph, 1);
      }

      // Walls
      const numWalls = 3 + Math.min(level, 5);
      for (let i = 0; i < numWalls; i++) {
        const wx = Math.floor(rand() * (TERRAIN_W - 100)) + 50;
        const wy = 60 + Math.floor(rand() * (TERRAIN_H - 140));
        const ww = 10 + Math.floor(rand() * 8);
        const wh = 50 + Math.floor(rand() * 100);
        terrainRect(wx, wy, ww, wh, 1);
      }

      // Create gaps in the ground
      const numGaps = 2 + Math.min(level, 4);
      for (let i = 0; i < numGaps; i++) {
        const gx = 100 + Math.floor(rand() * (TERRAIN_W - 300));
        const gw = 30 + Math.floor(rand() * 50);
        terrainRect(gx, TERRAIN_H - 30, gw, 30, 0);
      }

      // Connect some platforms with slopes/ramps
      const numRamps = 2 + Math.floor(rand() * 3);
      for (let i = 0; i < numRamps; i++) {
        const rx = Math.floor(rand() * (TERRAIN_W - 200)) + 80;
        const ry = 100 + Math.floor(rand() * 200);
        const rLen = 40 + Math.floor(rand() * 60);
        const dir = rand() > 0.5 ? 1 : -1;
        for (let s = 0; s < rLen; s++) {
          const sx = rx + s * dir;
          const sy = ry + Math.floor(s * 0.5);
          terrainRect(sx, sy, 3, 4, 1);
        }
      }

      // Entry point - clear area around it
      entryX = 60 + Math.floor(rand() * 100);
      entryY = 40;
      terrainRect(entryX - 10, entryY, 20, 15, 0);

      // Exit point - place on ground or a platform
      exitX = TERRAIN_W - 100 - Math.floor(rand() * 150);
      // Find ground level at exit
      exitY = TERRAIN_H - 31;
      for (let y = 50; y < TERRAIN_H; y++) {
        if (terrainGet(exitX, y)) {
          exitY = y - 1;
          break;
        }
      }
      // Clear space above exit
      terrainRect(exitX - 8, exitY - 20, 16, 20, 0);

      // Difficulty scaling
      totalLemmings = 10 + level * 3;
      neededToSave = Math.ceil(totalLemmings * (0.4 + Math.min(level * 0.05, 0.4)));
      spawnRate = Math.max(40, 80 - level * 5);

      abilities = {
        1: 5 + Math.floor(level * 0.5),  // Digger
        2: 5 + Math.floor(level * 0.5),  // Builder
        3: 3 + Math.floor(level * 0.3),  // Blocker
        4: 5 + Math.floor(level * 0.5),  // Basher
        5: 3 + Math.floor(level * 0.3),  // Climber
      };
      updateAbilityUI();
    }

    function updateAbilityUI() {
      for (let i = 1; i <= 5; i++) {
        document.getElementById('cnt-' + i).textContent = abilities[i] || 0;
      }
    }

    function init() {
      score = 0;
      level = 1;
      scoreEl.textContent = '0';
      resetLevel();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LEMMINGS';
      overlayText.textContent = 'Click to start';
    }

    function resetLevel() {
      lemmings = [];
      particles = [];
      savedCount = 0;
      deadCount = 0;
      spawnedCount = 0;
      spawnTimer = 0;
      selectedLemming = null;
      selectedAbility = 0;
      camX = 0;
      generateLevel();
      clearAbilitySelection();
    }

    function start() {
      resetLevel();
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    function gameOver(won) {
      gameState = 'over';
      if (won) {
        score += savedCount * 10 + level * 5;
      } else {
        score += savedCount * 5;
      }
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
        localStorage.setItem('lemmings-best', best);
      }
      overlay.style.display = 'flex';
      if (won) {
        overlayTitle.textContent = 'LEVEL ' + level + ' COMPLETE!';
        overlayText.textContent = 'Saved ' + savedCount + '/' + totalLemmings + ' (needed ' + neededToSave + ') - Click for next level';
      } else {
        overlayTitle.textContent = 'LEVEL FAILED';
        overlayText.textContent = 'Saved ' + savedCount + '/' + neededToSave + ' needed - Click to retry';
      }
    }

    function nextLevel() {
      level++;
      resetLevel();
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    // Lemming object
    function createLemming(x, y) {
      return {
        x, y,
        dir: 1,           // 1 = right, -1 = left
        velY: 0,
        alive: true,
        saved: false,
        state: 'falling',  // walking, falling, digging, building, blocking, bashing, climbing, dying
        animFrame: 0,
        buildCount: 0,     // steps built
        digTimer: 0,
        bashTimer: 0,
        climbFail: 0,
        fallDist: 0,
      };
    }

    function spawnLemming() {
      if (spawnedCount < totalLemmings) {
        lemmings.push(createLemming(entryX, entryY + 14));
        spawnedCount++;
      }
    }

    function updateLemming(lem) {
      if (!lem.alive || lem.saved) return;

      const GRAV = 0.5;
      const WALK_SPEED = 1;
      const MAX_FALL = 6;
      const LETHAL_FALL = 80;

      lem.animFrame++;

      // Check if fallen off map
      if (lem.y > TERRAIN_H + 10 || lem.x < -10 || lem.x > TERRAIN_W + 10) {
        killLemming(lem);
        return;
      }

      // Check exit
      if (Math.abs(lem.x - exitX) < 12 && Math.abs(lem.y - exitY) < 15 && lem.state !== 'blocking') {
        lem.saved = true;
        lem.alive = false;
        savedCount++;
        spawnParticles(lem.x, lem.y, '#8af', 8);
        return;
      }

      switch (lem.state) {
        case 'falling': {
          lem.velY = Math.min(lem.velY + GRAV, MAX_FALL);
          lem.y += lem.velY;
          lem.fallDist += Math.abs(lem.velY);
          // Check ground
          if (terrainGet(Math.floor(lem.x), Math.floor(lem.y))) {
            // Land on surface
            while (terrainGet(Math.floor(lem.x), Math.floor(lem.y))) {
              lem.y -= 1;
            }
            if (lem.fallDist > LETHAL_FALL) {
              killLemming(lem);
              return;
            }
            lem.velY = 0;
            lem.fallDist = 0;
            lem.state = 'walking';
          }
          break;
        }

        case 'walking': {
          // Check if ground below feet disappeared
          if (!terrainGet(Math.floor(lem.x), Math.floor(lem.y + 1))) {
            lem.state = 'falling';
            lem.velY = 0;
            lem.fallDist = 0;
            break;
          }

          // Move forward
          const nextX = Math.floor(lem.x + lem.dir * WALK_SPEED);
          const headY = Math.floor(lem.y - 6);
          const feetY = Math.floor(lem.y);

          // Check for blocker collision
          for (const other of lemmings) {
            if (other === lem || !other.alive || other.saved) continue;
            if (other.state === 'blocking' && Math.abs(other.x - nextX) < 6 && Math.abs(other.y - lem.y) < 10) {
              lem.dir *= -1;
              break;
            }
          }

          // Check wall ahead
          let wallHit = false;
          for (let cy = feetY - 1; cy >= feetY - 6; cy--) {
            if (terrainGet(nextX, cy)) {
              wallHit = true;
              break;
            }
          }

          if (wallHit) {
            // Try to step up (1-2 pixels)
            let canStep = false;
            for (let step = 1; step <= 3; step++) {
              let blocked = false;
              for (let cy = feetY - step - 1; cy >= feetY - step - 6; cy--) {
                if (terrainGet(nextX, cy)) { blocked = true; break; }
              }
              if (!blocked && terrainGet(nextX, feetY - step + 1)) {
                lem.x = nextX;
                lem.y -= step;
                canStep = true;
                break;
              }
            }
            if (!canStep) {
              lem.dir *= -1; // Turn around at wall
            }
          } else {
            lem.x += lem.dir * WALK_SPEED;
            // Walk down slopes
            if (!terrainGet(Math.floor(lem.x), Math.floor(lem.y + 1))) {
              // Check for small drop (slope)
              let dropped = false;
              for (let d = 1; d <= 3; d++) {
                if (terrainGet(Math.floor(lem.x), Math.floor(lem.y + 1 + d))) {
                  lem.y += d;
                  dropped = true;
                  break;
                }
              }
              if (!dropped) {
                lem.state = 'falling';
                lem.velY = 0;
                lem.fallDist = 0;
              }
            }
          }
          break;
        }

        case 'digging': {
          lem.digTimer++;
          if (lem.digTimer % 6 === 0) {
            // Dig a column below
            let dugSomething = false;
            for (let dx = -3; dx <= 3; dx++) {
              const tx = Math.floor(lem.x) + dx;
              const ty = Math.floor(lem.y + 1);
              if (terrainGet(tx, ty)) {
                terrainSet(tx, ty, 0);
                terrainSet(tx, ty + 1, 0);
                dugSomething = true;
              }
            }
            if (dugSomething) {
              lem.y += 2;
              spawnParticles(lem.x, lem.y, '#a86', 2);
            } else {
              lem.state = 'walking';
            }
          }
          break;
        }

        case 'building': {
          lem.digTimer++;
          if (lem.digTimer % 10 === 0) {
            if (lem.buildCount >= 10) {
              lem.state = 'walking';
              break;
            }
            // Place a stair block
            const bx = Math.floor(lem.x) + lem.dir * 3;
            const by = Math.floor(lem.y) - 1;
            terrainRect(bx, by, 5, 2, 1);
            lem.x += lem.dir * 3;
            lem.y -= 2;
            lem.buildCount++;
            spawnParticles(bx + 2, by, '#8af', 1);

            // Check if hit ceiling
            if (terrainGet(Math.floor(lem.x), Math.floor(lem.y - 8))) {
              lem.state = 'walking';
            }
          }
          break;
        }

        case 'blocking': {
          // Just stand there, handled in other lemmings' walk logic
          break;
        }

        case 'bashing': {
          lem.bashTimer++;
          if (lem.bashTimer % 4 === 0) {
            const bx = Math.floor(lem.x) + lem.dir * 2;
            let bashedSomething = false;
            for (let dy = -6; dy <= 0; dy++) {
              const by = Math.floor(lem.y) + dy;
              for (let dx = 0; dx < 3; dx++) {
                if (terrainGet(bx + dx * lem.dir, by)) {
                  terrainSet(bx + dx * lem.dir, by, 0);
                  bashedSomething = true;
                }
              }
            }
            if (bashedSomething) {
              lem.x += lem.dir * 1;
              spawnParticles(lem.x + lem.dir * 4, lem.y - 3, '#a86', 2);
            } else {
              lem.state = 'walking';
            }
          }
          // Check ground
          if (!terrainGet(Math.floor(lem.x), Math.floor(lem.y + 1))) {
            lem.state = 'falling';
            lem.velY = 0;
            lem.fallDist = 0;
          }
          break;
        }

        case 'climbing': {
          // Move up
          const cx = Math.floor(lem.x + lem.dir * 2);
          const cy = Math.floor(lem.y - 1);
          if (terrainGet(cx, cy)) {
            // Still wall ahead, keep climbing
            lem.y -= 1;
            lem.climbFail++;
            if (lem.climbFail > 80) {
              // Too high, fall
              lem.dir *= -1;
              lem.state = 'falling';
              lem.velY = 0;
              lem.fallDist = 0;
            }
          } else {
            // Reached top of wall - hop over
            lem.x += lem.dir * 3;
            lem.state = 'walking';
            lem.climbFail = 0;
          }
          // If nothing below while climbing, fall
          if (!terrainGet(Math.floor(lem.x + lem.dir), Math.floor(lem.y)) &&
              !terrainGet(Math.floor(lem.x + lem.dir * 2), Math.floor(lem.y))) {
            lem.state = 'falling';
            lem.velY = 0;
            lem.fallDist = 0;
          }
          break;
        }

        case 'dying': {
          lem.digTimer++;
          if (lem.digTimer > 30) {
            lem.alive = false;
            deadCount++;
          }
          break;
        }
      }
    }

    function killLemming(lem) {
      lem.state = 'dying';
      lem.digTimer = 0;
      spawnParticles(lem.x, lem.y, '#f66', 10);
    }

    function assignAbility(lem, abilityNum) {
      if (!lem || !lem.alive || lem.saved) return false;
      if (lem.state === 'blocking' || lem.state === 'dying') return false;
      if (!abilities[abilityNum] || abilities[abilityNum] <= 0) return false;

      switch (abilityNum) {
        case 1: // Digger
          if (lem.state === 'digging') return false;
          lem.state = 'digging';
          lem.digTimer = 0;
          break;
        case 2: // Builder
          if (lem.state === 'building') return false;
          lem.state = 'building';
          lem.digTimer = 0;
          lem.buildCount = 0;
          break;
        case 3: // Blocker
          if (lem.state === 'blocking') return false;
          lem.state = 'blocking';
          break;
        case 4: // Basher
          if (lem.state === 'bashing') return false;
          lem.state = 'bashing';
          lem.bashTimer = 0;
          break;
        case 5: // Climber
          if (lem.state === 'climbing') return false;
          // Climber ability: when hitting a wall, climb instead of turning
          // Immediately start climbing if at a wall, otherwise mark as walker with climb ability
          lem.state = 'climbing';
          lem.climbFail = 0;
          break;
        default:
          return false;
      }
      abilities[abilityNum]--;
      updateAbilityUI();
      spawnParticles(lem.x, lem.y - 5, '#8af', 4);
      return true;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 1) * 3,
          life: 20 + Math.random() * 20,
          maxLife: 40,
          color,
          size: 1 + Math.random() * 2,
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function clearAbilitySelection() {
      selectedAbility = 0;
      for (let i = 1; i <= 5; i++) {
        document.getElementById('ab-' + i).classList.remove('selected');
      }
    }

    // ---- Drawing ----

    function drawTerrain() {
      // Render terrain as an image
      const startX = Math.floor(camX);
      const endX = Math.min(startX + W, TERRAIN_W);

      // Draw terrain pixel blocks (using larger blocks for performance)
      const BLOCK = 2;
      for (let y = 0; y < TERRAIN_H; y += BLOCK) {
        for (let x = startX; x < endX; x += BLOCK) {
          if (terrainGet(x, y)) {
            // Color varies by depth for visual interest
            const depth = y / TERRAIN_H;
            const r = Math.floor(30 + depth * 40);
            const g = Math.floor(50 + depth * 30);
            const b = Math.floor(20 + depth * 20);
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(x - startX, y, BLOCK, BLOCK);
          }
        }
      }

      // Surface highlights
      ctx.fillStyle = 'rgba(136, 170, 255, 0.08)';
      for (let x = startX; x < endX; x += 2) {
        for (let y = 0; y < TERRAIN_H - 1; y++) {
          if (terrainGet(x, y + 1) && !terrainGet(x, y)) {
            ctx.fillRect(x - startX, y + 1, 2, 1);
          }
        }
      }
    }

    function drawDoor(x, y, label, color) {
      const sx = x - camX;
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 15;
      // Door frame
      ctx.fillRect(sx - 8, y - 18, 16, 18);
      ctx.shadowBlur = 0;

      // Door detail
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(sx - 5, y - 15, 10, 15);

      // Label
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(label, sx, y - 20);
      ctx.shadowBlur = 0;
    }

    function drawLemmings() {
      for (const lem of lemmings) {
        if (!lem.alive && !lem.saved) continue;
        if (lem.saved) continue;

        const sx = lem.x - camX;
        const sy = lem.y;

        // Skip if off screen
        if (sx < -10 || sx > W + 10) continue;

        const isSelected = lem === selectedLemming;

        // Selection highlight
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = 8;
          ctx.lineWidth = 1;
          ctx.strokeRect(sx - 6, sy - 12, 12, 14);
          ctx.shadowBlur = 0;
        }

        // Lemming body
        let bodyColor = '#8af';
        let hairColor = '#6d8fcc';

        switch (lem.state) {
          case 'digging': bodyColor = '#fa4'; hairColor = '#c80'; break;
          case 'building': bodyColor = '#4fa'; hairColor = '#2a8'; break;
          case 'blocking': bodyColor = '#f66'; hairColor = '#a33'; break;
          case 'bashing': bodyColor = '#ff8'; hairColor = '#aa5'; break;
          case 'climbing': bodyColor = '#f8f'; hairColor = '#a5a'; break;
          case 'dying': bodyColor = '#f33'; hairColor = '#900'; break;
        }

        ctx.shadowColor = bodyColor;
        ctx.shadowBlur = 6;

        // Head
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.arc(sx, sy - 8, 3, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = hairColor;
        ctx.fillRect(sx - 3, sy - 12, 6, 2);

        // Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(sx - 2, sy - 5, 4, 5);

        // Legs (animated)
        const legAnim = Math.sin(lem.animFrame * 0.3) * 2;
        ctx.fillRect(sx - 2, sy, 1, 2 + (lem.state === 'walking' ? legAnim : 0));
        ctx.fillRect(sx + 1, sy, 1, 2 - (lem.state === 'walking' ? legAnim : 0));

        // Direction indicator
        if (lem.state === 'walking' || lem.state === 'bashing') {
          ctx.fillStyle = '#fff';
          ctx.fillRect(sx + lem.dir * 2, sy - 8, 1, 1);
        }

        // State-specific visuals
        if (lem.state === 'digging') {
          // Digging animation
          const pickY = sy + 2 + Math.sin(lem.animFrame * 0.5) * 2;
          ctx.strokeStyle = '#fa4';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx, pickY);
          ctx.stroke();
        } else if (lem.state === 'building') {
          // Building brick
          ctx.fillStyle = '#4fa';
          ctx.fillRect(sx + lem.dir * 4, sy - 3, 3, 2);
        } else if (lem.state === 'blocking') {
          // Arms out
          ctx.strokeStyle = '#f66';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(sx - 5, sy - 4);
          ctx.lineTo(sx + 5, sy - 4);
          ctx.stroke();
        } else if (lem.state === 'climbing') {
          // Climbing arms
          const armY = -6 + Math.sin(lem.animFrame * 0.4) * 2;
          ctx.strokeStyle = '#f8f';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(sx, sy - 5);
          ctx.lineTo(sx + lem.dir * 4, sy + armY);
          ctx.stroke();
        } else if (lem.state === 'dying') {
          // Death animation
          const alpha = 1 - lem.digTimer / 30;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = '#f33';
          ctx.lineWidth = 2;
          const spread = lem.digTimer * 0.5;
          ctx.beginPath();
          ctx.moveTo(sx - spread, sy - 8 - spread);
          ctx.lineTo(sx + spread, sy - 8 + spread);
          ctx.moveTo(sx + spread, sy - 8 - spread);
          ctx.lineTo(sx - spread, sy - 8 + spread);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        ctx.shadowBlur = 0;
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const sx = p.x - camX;
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(sx - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Level info
      ctx.fillStyle = '#8af';
      ctx.shadowColor = '#8af';
      ctx.shadowBlur = 6;
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('LVL ' + level, 8, 16);

      ctx.textAlign = 'center';
      ctx.fillText('Saved: ' + savedCount + ' / ' + neededToSave + ' needed', W / 2, 16);

      ctx.textAlign = 'right';
      const remaining = totalLemmings - spawnedCount;
      const alive = lemmings.filter(l => l.alive && !l.saved).length;
      ctx.fillText('Left: ' + remaining + '  Active: ' + alive, W - 8, 16);
      ctx.shadowBlur = 0;

      // Scroll indicator
      const scrollPct = camX / (TERRAIN_W - W);
      const barW = 80;
      const barX = (W - barW) / 2;
      const barY = H - 8;
      ctx.fillStyle = '#16213e';
      ctx.fillRect(barX, barY, barW, 4);
      ctx.fillStyle = '#8af';
      ctx.fillRect(barX + scrollPct * (barW - 16), barY, 16, 4);

      // Selected ability indicator
      if (selectedAbility > 0) {
        const names = { 1: 'DIGGER', 2: 'BUILDER', 3: 'BLOCKER', 4: 'BASHER', 5: 'CLIMBER' };
        ctx.fillStyle = '#8af';
        ctx.shadowColor = '#8af';
        ctx.shadowBlur = 8;
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('[ ' + names[selectedAbility] + ' ]', W / 2, 32);
        ctx.shadowBlur = 0;
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      // Sky gradient
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#0a0e24');
      grad.addColorStop(1, '#0a0a1e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      drawTerrain();
      drawDoor(entryX, entryY + 14, 'IN', '#4f4');
      drawDoor(exitX, exitY, 'EXIT', '#ff0');
      drawLemmings();
      drawParticles();
      drawHUD();
    }

    // ---- Input ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        if (savedCount >= neededToSave) {
          nextLevel();
        } else {
          init();
          start();
        }
        return;
      }

      if (gameState === 'playing') {
        const num = parseInt(e.key);
        if (num >= 1 && num <= 5) {
          if (selectedAbility === num) {
            clearAbilitySelection();
          } else {
            selectedAbility = num;
            for (let i = 1; i <= 5; i++) {
              document.getElementById('ab-' + i).classList.toggle('selected', i === num);
            }
          }
          // If a lemming is already selected, apply immediately
          if (selectedLemming && selectedAbility > 0) {
            if (assignAbility(selectedLemming, selectedAbility)) {
              selectedLemming = null;
            }
          }
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Mouse/click handling
    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width) + camX;
      const my = (e.clientY - rect.top) * (H / rect.height);

      // Find closest lemming to click
      let closest = null;
      let closestDist = 15; // click radius
      for (const lem of lemmings) {
        if (!lem.alive || lem.saved) continue;
        const dist = Math.sqrt((lem.x - mx) ** 2 + ((lem.y - 4) - my) ** 2);
        if (dist < closestDist) {
          closestDist = dist;
          closest = lem;
        }
      }

      if (closest) {
        selectedLemming = closest;
        // If ability is selected, apply it
        if (selectedAbility > 0) {
          if (assignAbility(closest, selectedAbility)) {
            selectedLemming = null;
          }
        }
      } else {
        selectedLemming = null;
      }
    });

    // Ability button clicks
    for (let i = 1; i <= 5; i++) {
      document.getElementById('ab-' + i).addEventListener('click', () => {
        if (gameState !== 'playing') return;
        if (selectedAbility === i) {
          clearAbilitySelection();
        } else {
          selectedAbility = i;
          for (let j = 1; j <= 5; j++) {
            document.getElementById('ab-' + j).classList.toggle('selected', j === i);
          }
        }
      });
    }

    // ---- Game Loop ----

    function update() {
      if (gameState !== 'playing') return;

      // Camera scrolling
      if (keys['ArrowLeft']) camX = Math.max(0, camX - CAM_SPEED);
      if (keys['ArrowRight']) camX = Math.min(TERRAIN_W - W, camX + CAM_SPEED);
      if (keys['ArrowUp']) camX = Math.max(0, camX - CAM_SPEED * 3);
      if (keys['ArrowDown']) camX = Math.min(TERRAIN_W - W, camX + CAM_SPEED * 3);

      // Spawn lemmings
      spawnTimer++;
      if (spawnTimer >= spawnRate && spawnedCount < totalLemmings) {
        spawnTimer = 0;
        spawnLemming();
      }

      // Update lemmings
      for (const lem of lemmings) {
        updateLemming(lem);
      }

      // Update particles
      updateParticles();

      // Check game over conditions
      const activeLemmings = lemmings.filter(l => l.alive && !l.saved).length;
      const allSpawned = spawnedCount >= totalLemmings;

      if (allSpawned && activeLemmings === 0) {
        if (savedCount >= neededToSave) {
          gameOver(true);
        } else {
          gameOver(false);
        }
      }

      // Early failure check: impossible to save enough
      if (allSpawned) {
        const canStillSave = activeLemmings + savedCount;
        if (canStillSave < neededToSave && activeLemmings > 0) {
          // Let remaining die naturally, or could end early
        }
      }

      // Update score display
      scoreEl.textContent = score + savedCount * 10;
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>
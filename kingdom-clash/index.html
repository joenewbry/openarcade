<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kingdom Clash</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 6px;
      width: 900px;
    }
    .back { color: #da4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(221,170,68,0.4); }
    h1 { color: #da4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(221,170,68,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 900px;
      margin-bottom: 4px;
      font-size: 0.85rem;
    }
    .score-bar span { color: #da4; }
    .res-bar {
      display: flex;
      gap: 16px;
      width: 900px;
      margin-bottom: 4px;
      font-size: 0.8rem;
    }
    .res-bar div { padding: 2px 6px; border-radius: 4px; background: rgba(221,170,68,0.1); }
    .res-bar .food { color: #6c6; }
    .res-bar .wood { color: #a86; }
    .res-bar .gold { color: #dd4; }
    .res-bar .pop { color: #8bf; }
    .res-bar .age { color: #da4; font-weight: bold; }
    canvas {
      border: 2px solid #da4;
      box-shadow: 0 0 20px rgba(221,170,68,0.2);
      display: block;
      cursor: pointer;
    }
    .game-area {
      position: relative;
      display: flex;
      gap: 6px;
    }
    .sidebar {
      width: 180px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.75rem;
    }
    .panel {
      background: rgba(221,170,68,0.08);
      border: 1px solid rgba(221,170,68,0.3);
      border-radius: 4px;
      padding: 6px;
    }
    .panel h3 { color: #da4; font-size: 0.8rem; margin-bottom: 4px; }
    .btn {
      display: block;
      width: 100%;
      background: rgba(221,170,68,0.15);
      border: 1px solid rgba(221,170,68,0.4);
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      font-size: 0.7rem;
      padding: 3px 5px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 3px;
      text-align: left;
    }
    .btn:hover { background: rgba(221,170,68,0.3); }
    .btn.disabled { opacity: 0.4; cursor: not-allowed; }
    .btn .cost { color: #aaa; font-size: 0.6rem; }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 720px;
      height: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #da4;
      text-align: center;
      pointer-events: none;
      background: rgba(26,26,46,0.9);
      z-index: 10;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(221,170,68,0.5); }
    .overlay p { font-size: 0.9rem; color: #aaa; margin: 4px; }
    .overlay .start-btn {
      margin-top: 16px;
      padding: 10px 30px;
      font-size: 1.1rem;
      background: rgba(221,170,68,0.2);
      border: 2px solid #da4;
      color: #da4;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 6px;
      pointer-events: all;
    }
    .overlay .start-btn:hover { background: rgba(221,170,68,0.4); }
    .minimap-box {
      border: 1px solid rgba(221,170,68,0.4);
      background: #111;
      width: 168px;
      height: 112px;
    }
    .info-text { color: #aaa; font-size: 0.65rem; line-height: 1.3; }
    .hotkey { color: #da4; }
    #selInfo { min-height: 60px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>KINGDOM CLASH</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="scoreDisplay">0</span></div>
    <div id="timer" style="color:#da4">10:00</div>
    <div>Killed: <span id="killDisplay">0</span> | Built: <span id="builtDisplay">0</span></div>
  </div>
  <div class="res-bar">
    <div class="food">Food: <span id="foodDisplay">200</span></div>
    <div class="wood">Wood: <span id="woodDisplay">200</span></div>
    <div class="gold">Gold: <span id="goldDisplay">100</span></div>
    <div class="pop">Pop: <span id="popDisplay">3/10</span></div>
    <div class="age" id="ageDisplay">Dark Age</div>
  </div>
  <div class="game-area">
    <canvas id="game" width="720" height="500"></canvas>
    <div class="sidebar">
      <div class="panel">
        <h3>Minimap</h3>
        <canvas id="minimap" class="minimap-box" width="168" height="112"></canvas>
      </div>
      <div class="panel" id="selInfo">
        <h3>Selection</h3>
        <div class="info-text" id="selText">Click units/buildings</div>
      </div>
      <div class="panel" id="buildPanel">
        <h3>Build <span class="hotkey">[B]</span></h3>
        <div id="buildButtons"></div>
      </div>
      <div class="panel">
        <h3>Actions</h3>
        <button class="btn" id="ageUpBtn" onclick="tryAgeUp()">Age Up [A]<br><span class="cost"></span></button>
        <button class="btn" onclick="trainUnit('villager')">Train Villager [V]<br><span class="cost">F50</span></button>
        <div id="trainButtons"></div>
      </div>
      <div class="panel">
        <h3>Hotkeys</h3>
        <div class="info-text">
          <span class="hotkey">LClick</span> Select/Move<br>
          <span class="hotkey">RClick</span> Move/Attack<br>
          <span class="hotkey">Shift</span>+Click Multi-sel<br>
          <span class="hotkey">B</span> Build mode<br>
          <span class="hotkey">A</span> Age up<br>
          <span class="hotkey">V</span> Train Villager<br>
          <span class="hotkey">1-4</span> Train units<br>
          <span class="hotkey">Esc</span> Cancel
        </div>
      </div>
    </div>
    <div class="overlay" id="overlay">
      <h2>KINGDOM CLASH</h2>
      <p>Build your kingdom. Train your army. Crush the enemy.</p>
      <p style="font-size:0.8rem;color:#888;">Gather Food, Wood, Gold. Age up to unlock units.</p>
      <p style="font-size:0.8rem;color:#888;">Destroy the enemy Town Center to win!</p>
      <button class="start-btn" onclick="startGame()">START BATTLE</button>
    </div>
  </div>

<script>
// ===== GLOBALS =====
let gameState = 'menu'; // menu, playing, won, lost
let score = 0;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');
const CW = 720, CH = 500;

// Map
const MAP_W = 2400, MAP_H = 1600;
const TILE = 32;
const TILES_X = MAP_W / TILE, TILES_Y = MAP_H / TILE;
let camera = { x: 0, y: 0 };
let tiles = []; // 0=grass,1=tree,2=gold,3=stone,4=water

// Resources per player
const AGES = ['Dark', 'Feudal', 'Castle'];
const AGE_COST = [
  null,
  { food: 500, gold: 0 },
  { food: 800, gold: 200 }
];

function newPlayer(id) {
  return {
    id, food: 200, wood: 200, gold: 100,
    age: 0, pop: 0, maxPop: 10,
    units: [], buildings: [],
    kills: 0, built: 0
  };
}

let players = [];
let selected = []; // indices into players[0].units
let selectedBuilding = null; // index into players[0].buildings
let buildMode = null; // building type string or null
let gameTime = 0; // seconds
const MAX_TIME = 600; // 10 min
let tickCount = 0;

// ===== BUILDING DEFS =====
const BLDG = {
  townCenter: { name: 'Town Center', w: 3, h: 3, hp: 2000, age: 0, cost: { wood: 300, food: 0, gold: 0 }, popAdd: 5, symbol: 'TC', color: '#da4' },
  house: { name: 'House', w: 2, h: 2, hp: 300, age: 0, cost: { wood: 30, food: 0, gold: 0 }, popAdd: 5, symbol: 'H', color: '#a86' },
  farm: { name: 'Farm', w: 2, h: 2, hp: 200, age: 0, cost: { wood: 60, food: 0, gold: 0 }, popAdd: 0, symbol: 'F', color: '#6a4' },
  barracks: { name: 'Barracks', w: 2, h: 2, hp: 600, age: 1, cost: { wood: 150, food: 0, gold: 0 }, popAdd: 0, symbol: 'BK', color: '#c55' },
  archery: { name: 'Archery Range', w: 2, h: 2, hp: 500, age: 1, cost: { wood: 175, food: 0, gold: 0 }, popAdd: 0, symbol: 'AR', color: '#5a5' },
  stable: { name: 'Stable', w: 3, h: 2, hp: 600, age: 2, cost: { wood: 150, food: 0, gold: 50 }, popAdd: 0, symbol: 'ST', color: '#86c' },
  blacksmith: { name: 'Blacksmith', w: 2, h: 2, hp: 500, age: 1, cost: { wood: 100, food: 0, gold: 50 }, popAdd: 0, symbol: 'BS', color: '#888' },
  wall: { name: 'Wall', w: 1, h: 1, hp: 400, age: 1, cost: { wood: 5, food: 0, gold: 0 }, popAdd: 0, symbol: 'W', color: '#777' }
};

// ===== UNIT DEFS =====
const UNIT = {
  villager: { name: 'Villager', hp: 25, atk: 3, range: 1, speed: 1.5, cost: { food: 50 }, popCost: 1, age: 0, trainAt: 'townCenter', trainTime: 15, symbol: 'V', color: '#8cf' },
  militia: { name: 'Militia', hp: 40, atk: 6, range: 1, speed: 1.3, cost: { food: 60, gold: 20 }, popCost: 1, age: 0, trainAt: 'barracks', trainTime: 18, symbol: 'M', color: '#f66' },
  swordsman: { name: 'Swordsman', hp: 60, atk: 10, range: 1, speed: 1.2, cost: { food: 60, gold: 30 }, popCost: 1, age: 1, trainAt: 'barracks', trainTime: 20, symbol: 'S', color: '#f44' },
  archer: { name: 'Archer', hp: 30, atk: 5, range: 5, speed: 1.4, cost: { food: 25, gold: 45 }, popCost: 1, age: 1, trainAt: 'archery', trainTime: 20, symbol: 'A', color: '#4f4' },
  knight: { name: 'Knight', hp: 120, atk: 14, range: 1, speed: 2.2, cost: { food: 60, gold: 75 }, popCost: 2, age: 2, trainAt: 'stable', trainTime: 25, symbol: 'K', color: '#c6f' }
};

// ===== MAP GENERATION =====
function generateMap() {
  tiles = [];
  for (let y = 0; y < TILES_Y; y++) {
    tiles[y] = [];
    for (let x = 0; x < TILES_X; x++) {
      tiles[y][x] = 0; // grass
    }
  }
  // Water edges
  for (let y = 0; y < TILES_Y; y++) {
    for (let x = 0; x < TILES_X; x++) {
      if (x === 0 || x === TILES_X-1 || y === 0 || y === TILES_Y-1) tiles[y][x] = 4;
    }
  }
  // Tree clusters
  for (let i = 0; i < 30; i++) {
    let cx = 3 + Math.random() * (TILES_X - 6) | 0;
    let cy = 3 + Math.random() * (TILES_Y - 6) | 0;
    let r = 2 + Math.random() * 4 | 0;
    for (let dy = -r; dy <= r; dy++) {
      for (let dx = -r; dx <= r; dx++) {
        let nx = cx + dx, ny = cy + dy;
        if (nx > 1 && nx < TILES_X-2 && ny > 1 && ny < TILES_Y-2 && Math.random() < 0.6) {
          if (dx*dx + dy*dy < r*r) tiles[ny][nx] = 1;
        }
      }
    }
  }
  // Gold mines
  for (let i = 0; i < 12; i++) {
    let cx = 4 + Math.random() * (TILES_X - 8) | 0;
    let cy = 4 + Math.random() * (TILES_Y - 8) | 0;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (Math.random() < 0.5) {
          let nx = cx + dx, ny = cy + dy;
          if (nx > 1 && nx < TILES_X-2 && ny > 1 && ny < TILES_Y-2) tiles[ny][nx] = 2;
        }
      }
    }
  }
  // Clear starting areas
  clearArea(3, 3, 10, 10);
  clearArea(TILES_X - 13, TILES_Y - 13, 10, 10);
  // Ensure resources near starts
  for (let i = 0; i < 3; i++) {
    let tx = 10 + (Math.random()*6|0), ty = 3 + (Math.random()*8|0);
    for (let d = 0; d < 6; d++) tiles[ty + (Math.random()*3|0)][tx + (Math.random()*3|0)] = 1;
    tx = TILES_X - 18 + (Math.random()*6|0); ty = TILES_Y - 12 + (Math.random()*8|0);
    for (let d = 0; d < 6; d++) tiles[Math.min(TILES_Y-2,ty + (Math.random()*3|0))][Math.min(TILES_X-2,tx + (Math.random()*3|0))] = 1;
  }
  // Gold near starts
  tiles[6][12] = 2; tiles[7][12] = 2; tiles[6][13] = 2;
  tiles[TILES_Y-7][TILES_X-13] = 2; tiles[TILES_Y-8][TILES_X-13] = 2; tiles[TILES_Y-7][TILES_X-14] = 2;
}

function clearArea(sx, sy, w, h) {
  for (let y = sy; y < sy + h && y < TILES_Y; y++)
    for (let x = sx; x < sx + w && x < TILES_X; x++)
      tiles[y][x] = 0;
}

// ===== ENTITY HELPERS =====
function createBuilding(player, type, tx, ty) {
  const def = BLDG[type];
  const b = {
    type, tx, ty, hp: def.hp, maxHp: def.hp,
    owner: player.id, built: false, buildProgress: 0,
    buildTime: 30, queue: [], queueTimers: []
  };
  player.buildings.push(b);
  player.maxPop += def.popAdd;
  player.built++;
  // Mark tiles occupied
  for (let dy = 0; dy < def.h; dy++)
    for (let dx = 0; dx < def.w; dx++)
      tiles[ty + dy][tx + dx] = 10 + player.id; // occupied
  return b;
}

function createUnit(player, type, x, y) {
  const def = UNIT[type];
  const u = {
    type, x, y, hp: def.maxHp || def.hp, maxHp: def.hp,
    owner: player.id, target: null, moveTarget: null,
    gatherTarget: null, gatherType: null, carrying: 0, carryType: null,
    attackTarget: null, attackCooldown: 0, state: 'idle',
    buildTarget: null
  };
  player.units.push(u);
  player.pop += def.popCost;
  return u;
}

// ===== INIT GAME =====
function initGame() {
  generateMap();
  players = [newPlayer(0), newPlayer(1)];

  // Player 0 start (top-left)
  let tc0 = createBuilding(players[0], 'townCenter', 4, 4);
  tc0.built = true; tc0.buildProgress = 1;
  for (let i = 0; i < 3; i++) {
    createUnit(players[0], 'villager', (5 + i) * TILE, 8 * TILE);
  }

  // Player 1 (AI) start (bottom-right)
  let tc1 = createBuilding(players[1], 'townCenter', TILES_X - 7, TILES_Y - 7);
  tc1.built = true; tc1.buildProgress = 1;
  for (let i = 0; i < 3; i++) {
    createUnit(players[1], 'villager', (TILES_X - 6 + i) * TILE, (TILES_Y - 4) * TILE);
  }

  camera = { x: 0, y: 0 };
  selected = [];
  selectedBuilding = null;
  buildMode = null;
  gameTime = 0;
  tickCount = 0;
  score = 0;
}

// ===== RESOURCE & COST HELPERS =====
function canAfford(player, cost) {
  return (player.food >= (cost.food || 0)) && (player.wood >= (cost.wood || 0)) && (player.gold >= (cost.gold || 0));
}
function payCost(player, cost) {
  player.food -= (cost.food || 0);
  player.wood -= (cost.wood || 0);
  player.gold -= (cost.gold || 0);
}

function canPlaceBuilding(type, tx, ty, playerId) {
  const def = BLDG[type];
  for (let dy = 0; dy < def.h; dy++) {
    for (let dx = 0; dx < def.w; dx++) {
      let nx = tx + dx, ny = ty + dy;
      if (nx < 1 || nx >= TILES_X - 1 || ny < 1 || ny >= TILES_Y - 1) return false;
      if (tiles[ny][nx] !== 0) return false;
    }
  }
  return true;
}

// ===== DISTANCE =====
function dist(a, b) {
  let ax = a.x || (a.tx * TILE + TILE), ay = a.y || (a.ty * TILE + TILE);
  let bx = b.x || (b.tx * TILE + TILE), by = b.y || (b.ty * TILE + TILE);
  return Math.hypot(ax - bx, ay - by);
}

function bldgCenter(b) {
  const def = BLDG[b.type];
  return { x: (b.tx + def.w / 2) * TILE, y: (b.ty + def.h / 2) * TILE };
}

// ===== PATHFINDING (simplified) =====
function moveToward(unit, tx, ty, speed) {
  const dx = tx - unit.x, dy = ty - unit.y;
  const d = Math.hypot(dx, dy);
  if (d < speed * 2) { unit.x = tx; unit.y = ty; return true; }
  unit.x += (dx / d) * speed * 2;
  unit.y += (dy / d) * speed * 2;
  // Avoid water/occupied tiles (simple)
  let tileX = unit.x / TILE | 0, tileY = unit.y / TILE | 0;
  if (tileX >= 0 && tileX < TILES_X && tileY >= 0 && tileY < TILES_Y) {
    if (tiles[tileY][tileX] === 4) {
      unit.x -= (dx / d) * speed * 2;
      unit.y -= (dy / d) * speed * 2;
    }
  }
  return false;
}

// ===== FIND NEAREST =====
function findNearestResource(unit, type) {
  let best = null, bestD = Infinity;
  let tileType = type === 'wood' ? 1 : type === 'gold' ? 2 : -1;
  if (tileType < 0) return null;
  let ux = unit.x / TILE | 0, uy = unit.y / TILE | 0;
  for (let r = 1; r < 30; r++) {
    for (let dy = -r; dy <= r; dy++) {
      for (let dx = -r; dx <= r; dx++) {
        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
        let nx = ux + dx, ny = uy + dy;
        if (nx >= 0 && nx < TILES_X && ny >= 0 && ny < TILES_Y && tiles[ny][nx] === tileType) {
          let d = Math.abs(dx) + Math.abs(dy);
          if (d < bestD) { bestD = d; best = { tx: nx, ty: ny }; }
        }
      }
    }
    if (best) break;
  }
  return best;
}

function findNearestDropoff(unit) {
  const p = players[unit.owner];
  let best = null, bestD = Infinity;
  for (const b of p.buildings) {
    if (!b.built) continue;
    if (b.type === 'townCenter') {
      let d = dist(unit, bldgCenter(b));
      if (d < bestD) { bestD = d; best = b; }
    }
  }
  return best;
}

function findNearestFarm(unit) {
  const p = players[unit.owner];
  let best = null, bestD = Infinity;
  for (const b of p.buildings) {
    if (b.type === 'farm' && b.built && b.hp > 0) {
      let d = dist(unit, bldgCenter(b));
      if (d < bestD) { bestD = d; best = b; }
    }
  }
  return best;
}

// ===== UNIT AI (per tick) =====
function updateUnit(unit, dt) {
  const def = UNIT[unit.type];
  const player = players[unit.owner];
  unit.attackCooldown = Math.max(0, unit.attackCooldown - dt);

  // Clamp position
  unit.x = Math.max(TILE, Math.min(MAP_W - TILE, unit.x));
  unit.y = Math.max(TILE, Math.min(MAP_H - TILE, unit.y));

  // Attack target
  if (unit.attackTarget) {
    const tgt = unit.attackTarget;
    if (!tgt || tgt.hp <= 0) { unit.attackTarget = null; unit.state = 'idle'; return; }
    const d = dist(unit, tgt);
    const range = def.range * TILE;
    if (d <= range + TILE) {
      unit.state = 'attacking';
      if (unit.attackCooldown <= 0) {
        tgt.hp -= def.atk;
        unit.attackCooldown = 1;
        if (tgt.hp <= 0) {
          // Kill
          const enemyId = tgt.owner !== undefined ? tgt.owner : (unit.owner === 0 ? 1 : 0);
          const enemy = players[enemyId];
          if (tgt.type && UNIT[tgt.type]) {
            enemy.units = enemy.units.filter(u => u !== tgt);
            enemy.pop -= UNIT[tgt.type].popCost;
            player.kills++;
          } else if (tgt.type && BLDG[tgt.type]) {
            // Building destroyed
            const bdef = BLDG[tgt.type];
            for (let dy = 0; dy < bdef.h; dy++)
              for (let dx = 0; dx < bdef.w; dx++)
                if (tgt.ty+dy < TILES_Y && tgt.tx+dx < TILES_X) tiles[tgt.ty + dy][tgt.tx + dx] = 0;
            enemy.buildings = enemy.buildings.filter(b => b !== tgt);
            enemy.maxPop -= bdef.popAdd;
            player.kills++;
          }
          unit.attackTarget = null;
          unit.state = 'idle';
        }
      }
    } else {
      unit.state = 'moving';
      let tx = tgt.x || (tgt.tx * TILE + TILE);
      let ty = tgt.y || (tgt.ty * TILE + TILE);
      moveToward(unit, tx, ty, def.speed);
    }
    return;
  }

  // Move target
  if (unit.moveTarget) {
    unit.state = 'moving';
    if (moveToward(unit, unit.moveTarget.x, unit.moveTarget.y, def.speed)) {
      unit.moveTarget = null;
      unit.state = 'idle';
    }
    return;
  }

  // Build target (villager)
  if (unit.buildTarget && unit.type === 'villager') {
    const b = unit.buildTarget;
    if (b.built || b.hp <= 0) { unit.buildTarget = null; unit.state = 'idle'; return; }
    const d = dist(unit, bldgCenter(b));
    if (d < TILE * 3) {
      unit.state = 'building';
      b.buildProgress += dt / b.buildTime;
      if (b.buildProgress >= 1) {
        b.built = true;
        b.buildProgress = 1;
        unit.buildTarget = null;
        unit.state = 'idle';
      }
    } else {
      unit.state = 'moving';
      const c = bldgCenter(b);
      moveToward(unit, c.x, c.y, def.speed);
    }
    return;
  }

  // Gather (villager)
  if (unit.type === 'villager' && unit.gatherTarget) {
    const gt = unit.gatherTarget;
    // Dropping off
    if (unit.carrying >= 10) {
      const drop = findNearestDropoff(unit);
      if (drop) {
        const dc = bldgCenter(drop);
        const d = dist(unit, dc);
        if (d < TILE * 2.5) {
          // Drop off
          if (unit.carryType === 'food') player.food += unit.carrying;
          else if (unit.carryType === 'wood') player.wood += unit.carrying;
          else if (unit.carryType === 'gold') player.gold += unit.carrying;
          unit.carrying = 0;
          unit.state = 'gathering';
        } else {
          unit.state = 'moving';
          moveToward(unit, dc.x, dc.y, def.speed);
        }
      }
      return;
    }
    // Gathering from farm
    if (unit.gatherType === 'food' && gt.type === 'farm') {
      const fc = bldgCenter(gt);
      const d = dist(unit, fc);
      if (d < TILE * 2.5) {
        unit.state = 'gathering';
        unit.carrying += dt * 3;
        unit.carryType = 'food';
        gt.hp -= dt * 0.5;
        if (gt.hp <= 0) { unit.gatherTarget = null; }
      } else {
        unit.state = 'moving';
        moveToward(unit, fc.x, fc.y, def.speed);
      }
      return;
    }
    // Gathering from tile
    let tx = gt.tx !== undefined ? gt.tx : (gt.x / TILE | 0);
    let ty = gt.ty !== undefined ? gt.ty : (gt.y / TILE | 0);
    if (tx >= 0 && tx < TILES_X && ty >= 0 && ty < TILES_Y) {
      let tileV = tiles[ty][tx];
      let expectedTile = unit.gatherType === 'wood' ? 1 : 2;
      if (tileV !== expectedTile) {
        // Resource depleted, find another
        let next = findNearestResource(unit, unit.gatherType);
        if (next) { unit.gatherTarget = next; } else { unit.gatherTarget = null; unit.state = 'idle'; }
        return;
      }
      let px = tx * TILE + TILE / 2, py = ty * TILE + TILE / 2;
      let d = Math.hypot(unit.x - px, unit.y - py);
      if (d < TILE * 1.5) {
        unit.state = 'gathering';
        unit.carrying += dt * 3;
        unit.carryType = unit.gatherType;
        if (unit.carrying >= 10) {
          // Chance to deplete
          if (Math.random() < 0.15) tiles[ty][tx] = 0;
        }
      } else {
        unit.state = 'moving';
        moveToward(unit, px, py, def.speed);
      }
    }
    return;
  }

  // Auto-fight: if enemy unit/building nearby and not a villager gathering
  if (unit.type !== 'villager' || !unit.gatherTarget) {
    const enemyId = unit.owner === 0 ? 1 : 0;
    const enemy = players[enemyId];
    let closest = null, closestD = TILE * 8;
    for (const eu of enemy.units) {
      const d = dist(unit, eu);
      if (d < closestD) { closestD = d; closest = eu; }
    }
    for (const eb of enemy.buildings) {
      if (eb.hp <= 0) continue;
      const d = dist(unit, bldgCenter(eb));
      if (d < closestD) { closestD = d; closest = eb; }
    }
    if (closest) {
      unit.attackTarget = closest;
      return;
    }
  }

  unit.state = 'idle';
}

// ===== BUILDING QUEUE =====
function updateBuildingQueues(player, dt) {
  for (const b of player.buildings) {
    if (!b.built) continue;
    if (b.queue.length > 0) {
      b.queueTimers[0] -= dt;
      if (b.queueTimers[0] <= 0) {
        const unitType = b.queue.shift();
        b.queueTimers.shift();
        const def = UNIT[unitType];
        if (player.pop + def.popCost <= player.maxPop) {
          const c = bldgCenter(b);
          createUnit(player, unitType, c.x + TILE, c.y + TILE * 2);
        } else {
          // Can't spawn, refund
          if (def.cost.food) player.food += def.cost.food;
          if (def.cost.gold) player.gold += def.cost.gold;
        }
      }
    }
  }
}

// ===== TRAIN UNIT =====
function trainUnit(type) {
  if (gameState !== 'playing') return;
  const p = players[0];
  const def = UNIT[type];
  if (!def) return;
  if (p.age < def.age) return;
  if (!canAfford(p, def.cost)) return;
  if (p.pop + def.popCost > p.maxPop) return;
  // Find building
  let trainBldg = null;
  for (const b of p.buildings) {
    if (b.type === def.trainAt && b.built) { trainBldg = b; break; }
  }
  if (!trainBldg) return;
  payCost(p, def.cost);
  trainBldg.queue.push(type);
  trainBldg.queueTimers.push(def.trainTime);
}

// ===== AGE UP =====
function tryAgeUp() {
  if (gameState !== 'playing') return;
  const p = players[0];
  if (p.age >= 2) return;
  const cost = AGE_COST[p.age + 1];
  if (!canAfford(p, cost)) return;
  payCost(p, cost);
  p.age++;
  updateBuildButtons();
  updateTrainButtons();
}

// ===== AI =====
let aiTimer = 0;
let aiState = 'eco'; // eco, military, attack
let aiWaveCount = 0;

function aiUpdate(dt) {
  const ai = players[1];
  aiTimer += dt;
  if (aiTimer < 3) return;
  aiTimer = 0;

  // Auto-assign idle villagers
  for (const u of ai.units) {
    if (u.type === 'villager' && u.state === 'idle' && !u.gatherTarget && !u.buildTarget && !u.attackTarget) {
      // Prioritize: if we need food, farm; else wood; else gold
      if (ai.food < 200) {
        let farm = findNearestFarm(u);
        if (farm) {
          u.gatherTarget = farm;
          u.gatherType = 'food';
        } else {
          // Try to build a farm
          let done = false;
          for (const b of ai.buildings) {
            if (b.type === 'townCenter' && b.built) {
              for (let attempt = 0; attempt < 10; attempt++) {
                let fx = b.tx + (Math.random() * 8 - 4) | 0;
                let fy = b.ty + (Math.random() * 8 - 2) | 0;
                if (canPlaceBuilding('farm', fx, fy, 1) && canAfford(ai, BLDG.farm.cost)) {
                  payCost(ai, BLDG.farm.cost);
                  let nb = createBuilding(ai, 'farm', fx, fy);
                  u.buildTarget = nb;
                  done = true;
                  break;
                }
              }
              if (done) break;
            }
          }
          if (!done) {
            // Gather from trees as fallback food? No, gather wood
            let tree = findNearestResource(u, 'wood');
            if (tree) { u.gatherTarget = tree; u.gatherType = 'wood'; }
          }
        }
      } else if (ai.wood < 200) {
        let tree = findNearestResource(u, 'wood');
        if (tree) { u.gatherTarget = tree; u.gatherType = 'wood'; }
      } else if (ai.gold < 100) {
        let mine = findNearestResource(u, 'gold');
        if (mine) { u.gatherTarget = mine; u.gatherType = 'gold'; }
      } else {
        // Balanced - send to least
        let types = ['wood', 'gold'];
        let type = types[Math.random() * 2 | 0];
        let res = findNearestResource(u, type);
        if (res) { u.gatherTarget = res; u.gatherType = type; }
      }
    }
  }

  // Build order
  let hasBarracks = ai.buildings.some(b => b.type === 'barracks' && b.built);
  let hasArchery = ai.buildings.some(b => b.type === 'archery' && b.built);
  let hasStable = ai.buildings.some(b => b.type === 'stable' && b.built);
  let hasBsmith = ai.buildings.some(b => b.type === 'blacksmith' && b.built);
  let houseCount = ai.buildings.filter(b => b.type === 'house').length;

  // Need houses?
  if (ai.pop >= ai.maxPop - 2 && houseCount < 8 && canAfford(ai, BLDG.house.cost)) {
    let tc = ai.buildings.find(b => b.type === 'townCenter');
    if (tc) {
      for (let attempt = 0; attempt < 20; attempt++) {
        let hx = tc.tx + (Math.random() * 12 - 6) | 0;
        let hy = tc.ty + (Math.random() * 12 - 6) | 0;
        if (canPlaceBuilding('house', hx, hy, 1)) {
          payCost(ai, BLDG.house.cost);
          let nb = createBuilding(ai, 'house', hx, hy);
          let vill = ai.units.find(u => u.type === 'villager' && u.state === 'idle');
          if (vill) vill.buildTarget = nb;
          break;
        }
      }
    }
  }

  // Train villagers (up to 8-10)
  let villCount = ai.units.filter(u => u.type === 'villager').length;
  if (villCount < 8 && canAfford(ai, UNIT.villager.cost) && ai.pop < ai.maxPop) {
    let tc = ai.buildings.find(b => b.type === 'townCenter' && b.built);
    if (tc && tc.queue.length < 2) {
      payCost(ai, UNIT.villager.cost);
      tc.queue.push('villager');
      tc.queueTimers.push(UNIT.villager.trainTime);
    }
  }

  // Age up logic
  if (ai.age === 0 && ai.food >= 500 && villCount >= 5) {
    let cost = AGE_COST[1];
    if (canAfford(ai, cost)) { payCost(ai, cost); ai.age = 1; }
  }
  if (ai.age === 1 && ai.food >= 800 && ai.gold >= 200 && gameTime > 180) {
    let cost = AGE_COST[2];
    if (canAfford(ai, cost)) { payCost(ai, cost); ai.age = 2; }
  }

  // Build military buildings
  if (ai.age >= 1 && !hasBarracks && canAfford(ai, BLDG.barracks.cost)) {
    aiBuild(ai, 'barracks');
  }
  if (ai.age >= 1 && !hasArchery && canAfford(ai, BLDG.archery.cost) && hasBarracks) {
    aiBuild(ai, 'archery');
  }
  if (ai.age >= 2 && !hasStable && canAfford(ai, BLDG.stable.cost)) {
    aiBuild(ai, 'stable');
  }
  if (ai.age >= 1 && !hasBsmith && canAfford(ai, BLDG.blacksmith.cost) && hasBarracks) {
    aiBuild(ai, 'blacksmith');
  }

  // Train military
  let militaryCount = ai.units.filter(u => u.type !== 'villager').length;
  if (ai.age >= 1 && ai.pop < ai.maxPop) {
    // Composition: swordsmen > archers > knights
    if (hasBarracks) {
      let type = ai.age >= 1 ? 'swordsman' : 'militia';
      if (canAfford(ai, UNIT[type].cost)) {
        let bk = ai.buildings.find(b => b.type === 'barracks' && b.built && b.queue.length < 3);
        if (bk) { payCost(ai, UNIT[type].cost); bk.queue.push(type); bk.queueTimers.push(UNIT[type].trainTime); }
      }
    }
    if (hasArchery && canAfford(ai, UNIT.archer.cost)) {
      let ar = ai.buildings.find(b => b.type === 'archery' && b.built && b.queue.length < 2);
      if (ar) { payCost(ai, UNIT.archer.cost); ar.queue.push('archer'); ar.queueTimers.push(UNIT.archer.trainTime); }
    }
    if (hasStable && canAfford(ai, UNIT.knight.cost)) {
      let st = ai.buildings.find(b => b.type === 'stable' && b.built && b.queue.length < 2);
      if (st) { payCost(ai, UNIT.knight.cost); st.queue.push('knight'); st.queueTimers.push(UNIT.knight.trainTime); }
    }
  }

  // Attack waves
  if (militaryCount >= 5 + aiWaveCount * 3 || (gameTime > 360 && militaryCount >= 3)) {
    // Send military to attack
    let tc0 = players[0].buildings.find(b => b.type === 'townCenter');
    if (tc0) {
      for (const u of ai.units) {
        if (u.type !== 'villager' && !u.attackTarget) {
          u.attackTarget = tc0;
        }
      }
      aiWaveCount++;
    }
  }
}

function aiBuild(ai, type) {
  let tc = ai.buildings.find(b => b.type === 'townCenter');
  if (!tc) return;
  for (let attempt = 0; attempt < 30; attempt++) {
    let bx = tc.tx + (Math.random() * 16 - 8) | 0;
    let by = tc.ty + (Math.random() * 16 - 8) | 0;
    if (canPlaceBuilding(type, bx, by, 1)) {
      payCost(ai, BLDG[type].cost);
      let nb = createBuilding(ai, type, bx, by);
      let vill = ai.units.find(u => u.type === 'villager' && (u.state === 'idle' || u.state === 'gathering'));
      if (vill) {
        vill.buildTarget = nb;
        vill.gatherTarget = null;
      } else {
        // Auto-build for AI convenience
        nb.buildProgress = 0.5;
      }
      return;
    }
  }
}

// ===== INPUT =====
let mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
let keys = {};
let dragStart = null;
let isDragging = false;
let scrollEdge = { x: 0, y: 0 };

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  mouse.worldX = mouse.x + camera.x;
  mouse.worldY = mouse.y + camera.y;

  // Edge scrolling
  const edgeSize = 30;
  scrollEdge.x = mouse.x < edgeSize ? -1 : mouse.x > CW - edgeSize ? 1 : 0;
  scrollEdge.y = mouse.y < edgeSize ? -1 : mouse.y > CH - edgeSize ? 1 : 0;
});

canvas.addEventListener('mousedown', e => {
  if (gameState !== 'playing') return;
  e.preventDefault();
  if (e.button === 0) {
    if (buildMode) {
      // Place building
      let tx = (mouse.worldX / TILE | 0);
      let ty = (mouse.worldY / TILE | 0);
      const def = BLDG[buildMode];
      if (canPlaceBuilding(buildMode, tx, ty, 0) && canAfford(players[0], def.cost) && players[0].age >= def.age) {
        payCost(players[0], def.cost);
        let nb = createBuilding(players[0], buildMode, tx, ty);
        // Send selected villagers to build
        for (const idx of selected) {
          const u = players[0].units[idx];
          if (u && u.type === 'villager') {
            u.buildTarget = nb;
            u.gatherTarget = null;
            u.moveTarget = null;
            u.attackTarget = null;
          }
        }
        if (selected.length === 0) {
          // Find nearest idle villager
          let best = null, bestD = Infinity;
          for (const u of players[0].units) {
            if (u.type === 'villager') {
              let d = dist(u, bldgCenter(nb));
              if (d < bestD) { bestD = d; best = u; }
            }
          }
          if (best) { best.buildTarget = nb; best.gatherTarget = null; }
        }
        if (!e.shiftKey) buildMode = null;
      }
      return;
    }

    // Select
    dragStart = { x: mouse.worldX, y: mouse.worldY };
    if (!e.shiftKey) {
      selected = [];
      selectedBuilding = null;
    }

    // Check units
    for (let i = 0; i < players[0].units.length; i++) {
      const u = players[0].units[i];
      if (Math.hypot(u.x - mouse.worldX, u.y - mouse.worldY) < TILE * 0.7) {
        if (!selected.includes(i)) selected.push(i);
        return;
      }
    }
    // Check buildings
    for (let i = 0; i < players[0].buildings.length; i++) {
      const b = players[0].buildings[i];
      const def = BLDG[b.type];
      if (mouse.worldX >= b.tx * TILE && mouse.worldX < (b.tx + def.w) * TILE &&
          mouse.worldY >= b.ty * TILE && mouse.worldY < (b.ty + def.h) * TILE) {
        selectedBuilding = i;
        return;
      }
    }
  }
});

canvas.addEventListener('mouseup', e => {
  if (gameState !== 'playing') return;
  if (e.button === 0 && dragStart) {
    // Box select
    let x1 = Math.min(dragStart.x, mouse.worldX), y1 = Math.min(dragStart.y, mouse.worldY);
    let x2 = Math.max(dragStart.x, mouse.worldX), y2 = Math.max(dragStart.y, mouse.worldY);
    if (x2 - x1 > 10 || y2 - y1 > 10) {
      if (!e.shiftKey) selected = [];
      for (let i = 0; i < players[0].units.length; i++) {
        const u = players[0].units[i];
        if (u.x >= x1 && u.x <= x2 && u.y >= y1 && u.y <= y2) {
          if (!selected.includes(i)) selected.push(i);
        }
      }
    }
    dragStart = null;
  }
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (gameState !== 'playing') return;
  if (selected.length === 0) return;

  // Right click: move, attack, or gather
  let wx = mouse.worldX, wy = mouse.worldY;

  // Check if clicking on enemy unit
  for (const eu of players[1].units) {
    if (Math.hypot(eu.x - wx, eu.y - wy) < TILE) {
      for (const idx of selected) {
        const u = players[0].units[idx];
        if (u) { u.attackTarget = eu; u.moveTarget = null; u.gatherTarget = null; u.buildTarget = null; }
      }
      return;
    }
  }
  // Check if clicking on enemy building
  for (const eb of players[1].buildings) {
    const def = BLDG[eb.type];
    if (wx >= eb.tx * TILE && wx < (eb.tx + def.w) * TILE &&
        wy >= eb.ty * TILE && wy < (eb.ty + def.h) * TILE) {
      for (const idx of selected) {
        const u = players[0].units[idx];
        if (u) { u.attackTarget = eb; u.moveTarget = null; u.gatherTarget = null; u.buildTarget = null; }
      }
      return;
    }
  }

  // Check resource tile
  let tx = wx / TILE | 0, ty = wy / TILE | 0;
  if (tx >= 0 && tx < TILES_X && ty >= 0 && ty < TILES_Y) {
    let t = tiles[ty][tx];
    if (t === 1 || t === 2) {
      for (const idx of selected) {
        const u = players[0].units[idx];
        if (u && u.type === 'villager') {
          u.gatherTarget = { tx, ty };
          u.gatherType = t === 1 ? 'wood' : 'gold';
          u.moveTarget = null;
          u.attackTarget = null;
          u.buildTarget = null;
          u.carrying = 0;
        }
      }
      return;
    }
    // Check own farm
    for (const b of players[0].buildings) {
      if (b.type === 'farm' && b.built) {
        const def = BLDG.farm;
        if (wx >= b.tx * TILE && wx < (b.tx + def.w) * TILE &&
            wy >= b.ty * TILE && wy < (b.ty + def.h) * TILE) {
          for (const idx of selected) {
            const u = players[0].units[idx];
            if (u && u.type === 'villager') {
              u.gatherTarget = b;
              u.gatherType = 'food';
              u.moveTarget = null;
              u.attackTarget = null;
              u.buildTarget = null;
              u.carrying = 0;
            }
          }
          return;
        }
      }
    }
  }

  // Move
  for (const idx of selected) {
    const u = players[0].units[idx];
    if (u) {
      u.moveTarget = { x: wx, y: wy };
      u.attackTarget = null;
      u.gatherTarget = null;
      u.buildTarget = null;
    }
  }
});

// Minimap click
miniCanvas.addEventListener('mousedown', e => {
  if (gameState !== 'playing') return;
  const rect = miniCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  camera.x = (mx / 168) * MAP_W - CW / 2;
  camera.y = (my / 112) * MAP_H - CH / 2;
  clampCamera();
});

document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (gameState !== 'playing') return;
  if (e.key === 'Escape') { buildMode = null; selected = []; selectedBuilding = null; }
  if (e.key.toLowerCase() === 'b') { buildMode = buildMode ? null : 'house'; }
  if (e.key.toLowerCase() === 'a') tryAgeUp();
  if (e.key.toLowerCase() === 'v') trainUnit('villager');
  if (e.key === '1') trainUnit('militia');
  if (e.key === '2') trainUnit('swordsman');
  if (e.key === '3') trainUnit('archer');
  if (e.key === '4') trainUnit('knight');
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

function clampCamera() {
  camera.x = Math.max(0, Math.min(MAP_W - CW, camera.x));
  camera.y = Math.max(0, Math.min(MAP_H - CH, camera.y));
}

// ===== BUILD PANEL =====
function updateBuildButtons() {
  const p = players[0];
  const panel = document.getElementById('buildButtons');
  let html = '';
  for (const [key, def] of Object.entries(BLDG)) {
    if (key === 'townCenter') continue;
    const canBuild = p.age >= def.age;
    const afford = canAfford(p, def.cost);
    let costStr = [];
    if (def.cost.food) costStr.push('F' + def.cost.food);
    if (def.cost.wood) costStr.push('W' + def.cost.wood);
    if (def.cost.gold) costStr.push('G' + def.cost.gold);
    html += `<button class="btn ${(!canBuild || !afford) ? 'disabled' : ''}" onclick="setBuildMode('${key}')" ${!canBuild ? 'title="Need ' + AGES[def.age] + ' Age"' : ''}>${def.name}<br><span class="cost">${costStr.join(' ')}${!canBuild ? ' [' + AGES[def.age] + ']' : ''}</span></button>`;
  }
  panel.innerHTML = html;
}

function updateTrainButtons() {
  const p = players[0];
  const panel = document.getElementById('trainButtons');
  let html = '';
  const trainTypes = ['militia', 'swordsman', 'archer', 'knight'];
  const hotkeys = ['1', '2', '3', '4'];
  for (let i = 0; i < trainTypes.length; i++) {
    const type = trainTypes[i];
    const def = UNIT[type];
    const canTrain = p.age >= def.age;
    const hasBldg = p.buildings.some(b => b.type === def.trainAt && b.built);
    const afford = canAfford(p, def.cost);
    let costStr = [];
    if (def.cost.food) costStr.push('F' + def.cost.food);
    if (def.cost.gold) costStr.push('G' + def.cost.gold);
    html += `<button class="btn ${(!canTrain || !hasBldg || !afford) ? 'disabled' : ''}" onclick="trainUnit('${type}')">${def.name} [${hotkeys[i]}]<br><span class="cost">${costStr.join(' ')}${!canTrain ? ' [' + AGES[def.age] + ']' : ''}</span></button>`;
  }
  panel.innerHTML = html;
}

function setBuildMode(type) {
  if (gameState !== 'playing') return;
  const p = players[0];
  const def = BLDG[type];
  if (p.age < def.age) return;
  if (!canAfford(p, def.cost)) return;
  buildMode = type;
}

// ===== RENDERING =====
const TILE_COLORS = {
  0: '#2a4a1a', // grass
  1: '#1a5a1a', // tree
  2: '#8a7a2a', // gold
  3: '#6a6a6a', // stone
  4: '#1a2a4a', // water
};

function render() {
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, CW, CH);

  // Tiles
  let startTX = Math.max(0, camera.x / TILE | 0);
  let startTY = Math.max(0, camera.y / TILE | 0);
  let endTX = Math.min(TILES_X, ((camera.x + CW) / TILE | 0) + 1);
  let endTY = Math.min(TILES_Y, ((camera.y + CH) / TILE | 0) + 1);

  for (let ty = startTY; ty < endTY; ty++) {
    for (let tx = startTX; tx < endTX; tx++) {
      let px = tx * TILE - camera.x, py = ty * TILE - camera.y;
      let t = tiles[ty][tx];
      if (t >= 10) {
        ctx.fillStyle = '#2a4a1a';
      } else {
        ctx.fillStyle = TILE_COLORS[t] || '#2a4a1a';
      }
      ctx.fillRect(px, py, TILE, TILE);

      // Draw tree
      if (t === 1) {
        ctx.fillStyle = '#0a3a0a';
        ctx.beginPath();
        ctx.arc(px + TILE/2, py + TILE/2, TILE * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#2a6a2a';
        ctx.beginPath();
        ctx.arc(px + TILE/2, py + TILE/2 - 3, TILE * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      // Gold
      if (t === 2) {
        ctx.fillStyle = '#cc3';
        ctx.beginPath();
        ctx.arc(px + TILE/2, py + TILE/2, TILE * 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fa4';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('$', px + TILE/2, py + TILE/2 + 4);
      }
      // Water
      if (t === 4) {
        ctx.fillStyle = 'rgba(30,60,120,0.3)';
        ctx.fillRect(px, py, TILE, TILE);
      }
    }
  }

  // Grid lines (subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 0.5;
  for (let tx = startTX; tx <= endTX; tx++) {
    let px = tx * TILE - camera.x;
    ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, CH); ctx.stroke();
  }
  for (let ty = startTY; ty <= endTY; ty++) {
    let py = ty * TILE - camera.y;
    ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(CW, py); ctx.stroke();
  }

  // Buildings
  for (const p of players) {
    for (const b of p.buildings) {
      drawBuilding(b, p.id);
    }
  }

  // Units
  for (const p of players) {
    for (let i = 0; i < p.units.length; i++) {
      drawUnit(p.units[i], p.id, p.id === 0 && selected.includes(i));
    }
  }

  // Build mode ghost
  if (buildMode && gameState === 'playing') {
    const def = BLDG[buildMode];
    let tx = mouse.worldX / TILE | 0, ty = mouse.worldY / TILE | 0;
    let px = tx * TILE - camera.x, py = ty * TILE - camera.y;
    let valid = canPlaceBuilding(buildMode, tx, ty, 0);
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = valid ? '#4a4' : '#a44';
    ctx.fillRect(px, py, def.w * TILE, def.h * TILE);
    ctx.strokeStyle = valid ? '#6f6' : '#f66';
    ctx.lineWidth = 2;
    ctx.strokeRect(px, py, def.w * TILE, def.h * TILE);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#fff';
    ctx.font = '10px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(def.name, px + def.w * TILE / 2, py + def.h * TILE / 2 + 4);
  }

  // Selection box
  if (dragStart && gameState === 'playing') {
    let x1 = dragStart.x - camera.x, y1 = dragStart.y - camera.y;
    let x2 = mouse.x, y2 = mouse.y;
    ctx.strokeStyle = '#da4';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    ctx.setLineDash([]);
  }

  // Minimap
  renderMinimap();
}

function drawBuilding(b, playerId) {
  const def = BLDG[b.type];
  let px = b.tx * TILE - camera.x, py = b.ty * TILE - camera.y;
  let w = def.w * TILE, h = def.h * TILE;
  if (px + w < 0 || px > CW || py + h < 0 || py > CH) return;

  let baseColor = playerId === 0 ? def.color : shiftColor(def.color, playerId);
  ctx.fillStyle = baseColor;
  if (!b.built) {
    // Under construction
    let builtH = h * b.buildProgress;
    ctx.globalAlpha = 0.4;
    ctx.fillRect(px, py + h - builtH, w, builtH);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.strokeRect(px, py, w, h);
    ctx.fillStyle = '#aaa';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(Math.floor(b.buildProgress * 100) + '%', px + w/2, py + h/2 + 3);
  } else {
    ctx.fillRect(px + 2, py + 2, w - 4, h - 4);
    ctx.strokeStyle = playerId === 0 ? '#da4' : '#f44';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(px + 1, py + 1, w - 2, h - 2);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(def.symbol, px + w/2, py + h/2 + 4);
    // Flags / details for town center
    if (b.type === 'townCenter') {
      ctx.fillStyle = playerId === 0 ? '#48f' : '#f44';
      ctx.fillRect(px + w/2 - 2, py + 2, 4, 10);
      ctx.fillRect(px + w/2 + 2, py + 2, 8, 6);
    }
  }

  // HP bar
  if (b.hp < b.maxHp) {
    let hpPct = b.hp / b.maxHp;
    ctx.fillStyle = '#300';
    ctx.fillRect(px, py - 5, w, 3);
    ctx.fillStyle = hpPct > 0.5 ? '#0a0' : hpPct > 0.25 ? '#aa0' : '#a00';
    ctx.fillRect(px, py - 5, w * hpPct, 3);
  }

  // Queue indicator
  if (b.queue && b.queue.length > 0 && playerId === 0) {
    ctx.fillStyle = '#da4';
    ctx.font = '8px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('Q:' + b.queue.length, px + 1, py + h + 10);
  }

  // Selected building highlight
  if (playerId === 0 && selectedBuilding !== null && players[0].buildings[selectedBuilding] === b) {
    ctx.strokeStyle = '#4f4';
    ctx.lineWidth = 2;
    ctx.strokeRect(px - 2, py - 2, w + 4, h + 4);
  }
}

function drawUnit(u, playerId, isSelected) {
  let px = u.x - camera.x, py = u.y - camera.y;
  if (px < -TILE || px > CW + TILE || py < -TILE || py > CH + TILE) return;

  const def = UNIT[u.type];
  let r = TILE * 0.4;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(px, py + r * 0.5, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body
  let color = playerId === 0 ? def.color : shiftColor(def.color, playerId);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(px, py, r, 0, Math.PI * 2);
  ctx.fill();

  // Team outline
  ctx.strokeStyle = playerId === 0 ? '#48f' : '#f44';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Symbol
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(def.symbol, px, py + 1);

  // HP bar
  let hpPct = u.hp / u.maxHp;
  if (hpPct < 1) {
    ctx.fillStyle = '#300';
    ctx.fillRect(px - r, py - r - 5, r * 2, 3);
    ctx.fillStyle = hpPct > 0.5 ? '#0a0' : hpPct > 0.25 ? '#aa0' : '#a00';
    ctx.fillRect(px - r, py - r - 5, r * 2 * hpPct, 3);
  }

  // Carrying indicator
  if (u.carrying > 0) {
    ctx.fillStyle = u.carryType === 'food' ? '#6c6' : u.carryType === 'wood' ? '#a86' : '#dd4';
    ctx.beginPath();
    ctx.arc(px + r, py - r, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Selection ring
  if (isSelected) {
    ctx.strokeStyle = '#4f4';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(px, py, r + 4, 0, Math.PI * 2);
    ctx.stroke();
  }

  // State indicator
  if (u.state === 'attacking') {
    ctx.strokeStyle = '#f44';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(px, py, r + 6, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function shiftColor(hex, id) {
  // Make enemy colors reddish
  if (id === 1) {
    let r = parseInt(hex.slice(1, 2), 16) * 17;
    let g = parseInt(hex.slice(2, 3), 16) * 17;
    let b = parseInt(hex.slice(3, 4), 16) * 17;
    r = Math.min(255, r + 80);
    g = Math.max(0, g - 40);
    b = Math.max(0, b - 40);
    return `rgb(${r},${g},${b})`;
  }
  return hex;
}

function renderMinimap() {
  miniCtx.fillStyle = '#111';
  miniCtx.fillRect(0, 0, 168, 112);
  const sx = 168 / MAP_W, sy = 112 / MAP_H;

  // Terrain (simplified)
  for (let ty = 0; ty < TILES_Y; ty += 2) {
    for (let tx = 0; tx < TILES_X; tx += 2) {
      let t = tiles[ty][tx];
      let px = tx * TILE * sx, py = ty * TILE * sy;
      if (t === 1) miniCtx.fillStyle = '#1a4a1a';
      else if (t === 2) miniCtx.fillStyle = '#8a7a2a';
      else if (t === 4) miniCtx.fillStyle = '#1a2a4a';
      else if (t >= 10) miniCtx.fillStyle = t === 10 ? '#336' : '#633';
      else continue;
      miniCtx.fillRect(px, py, TILE * 2 * sx + 1, TILE * 2 * sy + 1);
    }
  }

  // Buildings
  for (const p of players) {
    miniCtx.fillStyle = p.id === 0 ? '#48f' : '#f44';
    for (const b of p.buildings) {
      miniCtx.fillRect(b.tx * TILE * sx, b.ty * TILE * sy, BLDG[b.type].w * TILE * sx + 1, BLDG[b.type].h * TILE * sy + 1);
    }
  }

  // Units
  for (const p of players) {
    miniCtx.fillStyle = p.id === 0 ? '#8bf' : '#f88';
    for (const u of p.units) {
      miniCtx.fillRect(u.x * sx - 1, u.y * sy - 1, 2, 2);
    }
  }

  // Camera viewport
  miniCtx.strokeStyle = '#da4';
  miniCtx.lineWidth = 1;
  miniCtx.strokeRect(camera.x * sx, camera.y * sy, CW * sx, CH * sy);
}

// ===== SELECTION INFO =====
function updateSelectionInfo() {
  const el = document.getElementById('selText');
  if (selected.length > 0) {
    let units = selected.map(i => players[0].units[i]).filter(u => u);
    if (units.length === 1) {
      const u = units[0];
      const def = UNIT[u.type];
      el.innerHTML = `<b style="color:${def.color}">${def.name}</b><br>HP: ${Math.ceil(u.hp)}/${u.maxHp}<br>ATK: ${def.atk} | RNG: ${def.range}<br>State: ${u.state}${u.carrying > 0 ? '<br>Carry: ' + Math.floor(u.carrying) + ' ' + u.carryType : ''}`;
    } else {
      let counts = {};
      for (const u of units) { counts[u.type] = (counts[u.type] || 0) + 1; }
      let str = Object.entries(counts).map(([t, c]) => c + 'x ' + UNIT[t].name).join('<br>');
      el.innerHTML = `<b>${units.length} units</b><br>${str}`;
    }
  } else if (selectedBuilding !== null && players[0].buildings[selectedBuilding]) {
    const b = players[0].buildings[selectedBuilding];
    const def = BLDG[b.type];
    let qStr = b.queue.length > 0 ? '<br>Queue: ' + b.queue.map(t => UNIT[t].symbol).join(',') : '';
    el.innerHTML = `<b style="color:${def.color}">${def.name}</b><br>HP: ${Math.ceil(b.hp)}/${b.maxHp}${!b.built ? '<br>Building: ' + Math.floor(b.buildProgress * 100) + '%' : ''}${qStr}`;
  } else {
    el.innerHTML = 'Click units/buildings<br>RClick to move/attack';
  }
}

// ===== HUD =====
function updateHUD() {
  const p = players[0];
  document.getElementById('foodDisplay').textContent = Math.floor(p.food);
  document.getElementById('woodDisplay').textContent = Math.floor(p.wood);
  document.getElementById('goldDisplay').textContent = Math.floor(p.gold);
  document.getElementById('popDisplay').textContent = p.pop + '/' + p.maxPop;
  document.getElementById('ageDisplay').textContent = AGES[p.age] + ' Age';
  document.getElementById('scoreDisplay').textContent = score;
  document.getElementById('killDisplay').textContent = p.kills;
  document.getElementById('builtDisplay').textContent = p.built;

  let remaining = Math.max(0, MAX_TIME - gameTime);
  let min = Math.floor(remaining / 60);
  let sec = Math.floor(remaining % 60);
  document.getElementById('timer').textContent = min + ':' + (sec < 10 ? '0' : '') + sec;

  // Age up button
  const ageBtn = document.getElementById('ageUpBtn');
  if (p.age >= 2) {
    ageBtn.classList.add('disabled');
    ageBtn.innerHTML = 'Max Age';
  } else {
    const cost = AGE_COST[p.age + 1];
    let costStr = 'F' + cost.food;
    if (cost.gold) costStr += ' G' + cost.gold;
    ageBtn.querySelector('.cost').textContent = costStr;
    ageBtn.classList.toggle('disabled', !canAfford(p, cost));
  }
}

// ===== GAME LOOP =====
let lastTime = 0;
function gameLoop(now) {
  let dt = Math.min(0.1, (now - lastTime) / 1000);
  lastTime = now;

  if (gameState === 'playing') {
    gameTime += dt;
    tickCount++;

    // Camera scrolling
    const scrollSpeed = 8;
    if (keys['arrowleft'] || scrollEdge.x < 0) camera.x -= scrollSpeed;
    if (keys['arrowright'] || scrollEdge.x > 0) camera.x += scrollSpeed;
    if (keys['arrowup'] || scrollEdge.y < 0) camera.y -= scrollSpeed;
    if (keys['arrowdown'] || scrollEdge.y > 0) camera.y += scrollSpeed;
    clampCamera();

    // Update units
    for (const p of players) {
      for (const u of p.units) {
        updateUnit(u, dt);
      }
      updateBuildingQueues(p, dt);
      // AI auto-build progress
      if (p.id === 1) {
        for (const b of p.buildings) {
          if (!b.built) {
            b.buildProgress += dt / (b.buildTime * 0.7);
            if (b.buildProgress >= 1) { b.built = true; b.buildProgress = 1; }
          }
        }
      }
    }

    // AI
    aiUpdate(dt);

    // Score
    score = players[0].kills * 10 + players[0].built * 5;

    // Win/loss check
    let enemyTC = players[1].buildings.find(b => b.type === 'townCenter');
    let playerTC = players[0].buildings.find(b => b.type === 'townCenter');
    if (!enemyTC || (enemyTC.hp <= 0)) {
      gameState = 'won';
      score += 500;
      showEndOverlay('VICTORY!', 'You destroyed the enemy kingdom!');
    } else if (!playerTC || (playerTC.hp <= 0)) {
      gameState = 'lost';
      showEndOverlay('DEFEAT', 'Your Town Center was destroyed!');
    } else if (gameTime >= MAX_TIME) {
      // Compare scores
      let aiScore = players[1].kills * 10 + players[1].built * 5;
      if (score >= aiScore) {
        gameState = 'won';
        score += 200;
        showEndOverlay('VICTORY!', 'Time up - you had the higher score!');
      } else {
        gameState = 'lost';
        showEndOverlay('DEFEAT', 'Time up - the AI had a higher score.');
      }
    }

    // Update UI periodically
    if (tickCount % 10 === 0) {
      updateHUD();
      updateSelectionInfo();
      updateBuildButtons();
      updateTrainButtons();
    }
  }

  render();
  requestAnimationFrame(gameLoop);
}

function showEndOverlay(title, msg) {
  const ov = document.getElementById('overlay');
  ov.style.display = 'flex';
  ov.innerHTML = `<h2>${title}</h2><p>Score: ${score}</p><p>${msg}</p><p style="font-size:0.8rem;color:#888;">Kills: ${players[0].kills} | Buildings: ${players[0].built} | Age: ${AGES[players[0].age]}</p><button class="start-btn" onclick="startGame()">PLAY AGAIN</button>`;
}

function startGame() {
  initGame();
  gameState = 'playing';
  document.getElementById('overlay').style.display = 'none';
  updateBuildButtons();
  updateTrainButtons();
  updateHUD();
}

// ===== EXPOSE & INIT =====
window.gameData = {};
function updateGameData() {
  window.gameData = { gameState, score, gameTime, players: players.map(p => ({ id: p.id, food: Math.floor(p.food), wood: Math.floor(p.wood), gold: Math.floor(p.gold), age: p.age, pop: p.pop, maxPop: p.maxPop, units: p.units.length, buildings: p.buildings.length, kills: p.kills })) };
}
setInterval(updateGameData, 1000);

// Start
initGame();
updateBuildButtons();
updateTrainButtons();
updateHUD();
requestAnimationFrame(gameLoop);
</script>
<script src="../recorder.js?v=2"></script>
</body>
</html>

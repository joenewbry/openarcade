<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Night Driver</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #c4a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 68, 170, 0.5); }
    h1 { color: #c4a; font-size: 2rem; text-shadow: 0 0 15px rgba(204, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #c4a; }
    canvas {
      border: 2px solid #c4a;
      box-shadow: 0 0 20px rgba(204, 68, 170, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c4a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>NIGHT DRIVER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">NIGHT DRIVER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // Road parameters
    const HORIZON_Y = 120;           // vanishing point Y
    const ROAD_BOTTOM_Y = H - 80;    // bottom of road (above dashboard)
    const DASH_Y = H - 80;           // top of dashboard
    const VANISH_X = W / 2;          // vanishing point X (center)
    const NUM_SEGMENTS = 200;         // road segments for curve definition
    const DRAW_DISTANCE = 120;        // how many segments to draw
    const SEGMENT_LENGTH = 5;         // virtual length per segment
    const ROAD_HALF_WIDTH = 300;      // half-width of road at camera position

    // Marker posts
    const MARKER_SPACING = 8;         // draw a marker post every N segments
    const MARKER_HEIGHT_BASE = 16;    // height of marker at bottom of screen

    // Player state
    let playerX;        // lateral offset from road center (-1 to 1 range roughly)
    let playerSpeed;    // current speed
    let position;       // distance traveled along road
    let steerAngle;     // current steering angle

    // Road definition
    let roadSegments;   // array of curve values for each segment
    let roadSeed;       // controls road generation

    // Oncoming cars
    let oncomingCars;
    let nextCarSpawn;

    // Speed / difficulty
    const MIN_SPEED = 0;
    const MAX_SPEED = 12;
    const ACCEL = 0.08;
    const BRAKE = 0.15;
    const FRICTION = 0.02;
    const STEER_SPEED = 0.045;
    const STEER_RETURN = 0.03;
    const MAX_STEER = 1.0;

    // Scoring
    let scoreTimer;
    let distanceTraveled;
    let frameCount;

    // Crash state
    let crashTimer;
    let crashFlash;

    // Keys
    let keys = {};

    // Generate road segments with smooth curves
    function generateRoad() {
      roadSegments = [];
      let curvature = 0;
      let curveTarget = 0;
      let curveChangeTimer = 0;
      const baseDifficulty = 0.003;

      for (let i = 0; i < NUM_SEGMENTS * 3; i++) {
        curveChangeTimer--;
        if (curveChangeTimer <= 0) {
          // Increase max curvature based on distance
          const difficultyScale = Math.min(1 + (i / NUM_SEGMENTS) * 0.5, 3.0);
          const maxCurve = baseDifficulty * difficultyScale;
          curveTarget = (Math.random() - 0.5) * 2 * maxCurve;
          curveChangeTimer = 30 + Math.floor(Math.random() * 60);
        }
        curvature += (curveTarget - curvature) * 0.02;
        roadSegments.push(curvature);
      }
    }

    function spawnOncomingCar(segmentAhead) {
      const lane = (Math.random() < 0.5) ? -0.4 : -0.6; // oncoming lane (left side)
      oncomingCars.push({
        segmentPos: Math.floor(position / SEGMENT_LENGTH) + segmentAhead,
        lane: lane,
        speed: 3 + Math.random() * 4,
        headlightPhase: Math.random() * Math.PI * 2
      });
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      playerX = 0;
      playerSpeed = 0;
      position = 0;
      steerAngle = 0;
      distanceTraveled = 0;
      frameCount = 0;
      crashTimer = 0;
      crashFlash = 0;
      oncomingCars = [];
      nextCarSpawn = 60 + Math.floor(Math.random() * 120);
      generateRoad();

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'NIGHT DRIVER';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Steering
      if (keys['ArrowLeft']) {
        steerAngle -= STEER_SPEED;
        if (steerAngle < -MAX_STEER) steerAngle = -MAX_STEER;
      } else if (keys['ArrowRight']) {
        steerAngle += STEER_SPEED;
        if (steerAngle > MAX_STEER) steerAngle = MAX_STEER;
      } else {
        // Return to center
        if (steerAngle > STEER_RETURN) steerAngle -= STEER_RETURN;
        else if (steerAngle < -STEER_RETURN) steerAngle += STEER_RETURN;
        else steerAngle = 0;
      }

      // Acceleration / braking
      if (keys['ArrowUp']) {
        playerSpeed += ACCEL;
        if (playerSpeed > MAX_SPEED) playerSpeed = MAX_SPEED;
      } else if (keys['ArrowDown']) {
        playerSpeed -= BRAKE;
        if (playerSpeed < MIN_SPEED) playerSpeed = MIN_SPEED;
      } else {
        playerSpeed -= FRICTION;
        if (playerSpeed < MIN_SPEED) playerSpeed = MIN_SPEED;
      }

      // Get current road curvature at player position
      const currentSegIndex = Math.floor(position / SEGMENT_LENGTH);
      const curvature = roadSegments[currentSegIndex % roadSegments.length] || 0;

      // Move player laterally based on steering and road curvature
      playerX += steerAngle * playerSpeed * 0.015;
      // Road curvature pushes player outward (centrifugal effect)
      playerX += curvature * playerSpeed * 80;

      // Move forward
      position += playerSpeed;
      distanceTraveled += playerSpeed;

      // Scoring based on speed and distance
      if (frameCount % 6 === 0 && playerSpeed > 1) {
        const speedBonus = Math.floor(playerSpeed);
        score += speedBonus;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
      }

      // Check if player is off road
      const offRoadThreshold = 1.05;
      if (Math.abs(playerX) > offRoadThreshold) {
        crashTimer++;
        if (crashTimer > 10) {
          gameOver();
          return;
        }
        // Slow down when off road
        playerSpeed *= 0.95;
        playerX = Math.sign(playerX) * Math.min(Math.abs(playerX), 1.3);
      } else {
        crashTimer = 0;
      }

      // Spawn oncoming cars
      nextCarSpawn--;
      if (nextCarSpawn <= 0) {
        const spawnDist = DRAW_DISTANCE - 10 + Math.floor(Math.random() * 20);
        spawnOncomingCar(spawnDist);
        // Increase frequency with distance
        const minSpawn = Math.max(30, 100 - Math.floor(distanceTraveled / 500));
        nextCarSpawn = minSpawn + Math.floor(Math.random() * minSpawn);
      }

      // Update oncoming cars
      for (let i = oncomingCars.length - 1; i >= 0; i--) {
        const car = oncomingCars[i];
        car.segmentPos -= car.speed / SEGMENT_LENGTH;

        // Remove cars that have passed the player
        if (car.segmentPos < currentSegIndex - 5) {
          oncomingCars.splice(i, 1);
          continue;
        }

        // Collision with oncoming car
        const relSegment = car.segmentPos - currentSegIndex;
        if (relSegment >= -1 && relSegment <= 1) {
          const carLateralDist = Math.abs(playerX - car.lane);
          if (carLateralDist < 0.3) {
            gameOver();
            return;
          }
        }
      }

      // Expose game state for ML
      window.gameData = {
        playerX: playerX,
        speed: playerSpeed,
        steer: steerAngle,
        curvature: curvature,
        score: score,
        position: position
      };
    }

    function projectPoint(segIndex, lateralOffset, currentSegIdx) {
      // Project a road point to screen coordinates
      const relSegment = segIndex - currentSegIdx;
      if (relSegment <= 0) return null;

      // Accumulate horizontal offset from road curves
      let horizOffset = 0;
      for (let i = currentSegIdx; i < segIndex; i++) {
        const c = roadSegments[i % roadSegments.length] || 0;
        horizOffset += c * (segIndex - i) * 2;
      }

      // Perspective projection
      const depth = relSegment * SEGMENT_LENGTH;
      const scale = 600 / (depth + 10);

      const screenX = VANISH_X + (lateralOffset + horizOffset * 1000) * scale;
      const screenY = HORIZON_Y + (ROAD_BOTTOM_Y - HORIZON_Y) * (1 - 1 / (1 + relSegment * 0.05));

      return { x: screenX, y: screenY, scale: scale };
    }

    function draw() {
      // Clear - pure black for night driving
      ctx.fillStyle = '#0a0a12';
      ctx.fillRect(0, 0, W, H);

      const currentSegIdx = Math.floor(position / SEGMENT_LENGTH);

      // Stars in the sky
      ctx.fillStyle = '#334';
      ctx.fillRect(0, 0, W, HORIZON_Y);

      // Draw a few static stars
      const starSeed = 42;
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + starSeed * 31) % W);
        const sy = ((i * 97 + starSeed * 17) % HORIZON_Y);
        const brightness = 0.3 + (i % 5) * 0.15;
        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
        ctx.fillRect(sx, sy, 1, 1);
      }

      // Draw horizon glow
      const horizGrad = ctx.createLinearGradient(0, HORIZON_Y - 30, 0, HORIZON_Y + 10);
      horizGrad.addColorStop(0, 'rgba(204, 68, 170, 0.0)');
      horizGrad.addColorStop(0.5, 'rgba(204, 68, 170, 0.05)');
      horizGrad.addColorStop(1, 'rgba(204, 68, 170, 0.0)');
      ctx.fillStyle = horizGrad;
      ctx.fillRect(0, HORIZON_Y - 30, W, 40);

      // Build projected road points for left and right edges
      const leftPoints = [];
      const rightPoints = [];
      const centerPoints = [];
      const segFraction = (position % SEGMENT_LENGTH) / SEGMENT_LENGTH;

      for (let i = 1; i <= DRAW_DISTANCE; i++) {
        const segIdx = currentSegIdx + i;
        const relSeg = i - segFraction;
        if (relSeg <= 0) continue;

        // Accumulate curve offset
        let horizOffset = 0;
        for (let j = currentSegIdx; j < segIdx; j++) {
          const c = roadSegments[j % roadSegments.length] || 0;
          horizOffset += c * (segIdx - j) * 1.5;
        }

        // Perspective
        const perspScale = 1 / (relSeg * 0.04 + 0.1);
        const screenY = HORIZON_Y + (ROAD_BOTTOM_Y - HORIZON_Y) * (1 - 1 / (1 + relSeg * 0.06));

        const roadCenterX = VANISH_X + horizOffset * 800 * perspScale - playerX * perspScale * 60;
        const halfWidth = ROAD_HALF_WIDTH * perspScale * 0.015;

        leftPoints.push({ x: roadCenterX - halfWidth, y: screenY, seg: segIdx, perspScale });
        rightPoints.push({ x: roadCenterX + halfWidth, y: screenY, seg: segIdx, perspScale });
        centerPoints.push({ x: roadCenterX, y: screenY, seg: segIdx, perspScale, halfWidth });
      }

      // Draw road surface (subtle dark gray fill)
      if (leftPoints.length > 1 && rightPoints.length > 1) {
        ctx.beginPath();
        ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
        for (let i = 1; i < leftPoints.length; i++) {
          ctx.lineTo(leftPoints[i].x, leftPoints[i].y);
        }
        for (let i = rightPoints.length - 1; i >= 0; i--) {
          ctx.lineTo(rightPoints[i].x, rightPoints[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = '#111118';
        ctx.fill();
      }

      // Draw center dashed line
      ctx.strokeStyle = 'rgba(255, 255, 100, 0.3)';
      for (let i = 0; i < centerPoints.length - 1; i++) {
        const seg = centerPoints[i].seg;
        // Dashed pattern: draw every other 4 segments
        if (Math.floor(seg / 4) % 2 === 0) {
          const lineWidth = Math.max(0.5, centerPoints[i].perspScale * 0.3);
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(centerPoints[i].x, centerPoints[i].y);
          ctx.lineTo(centerPoints[i + 1].x, centerPoints[i + 1].y);
          ctx.stroke();
        }
      }

      // Draw road edge markers (posts on left and right)
      for (let i = 0; i < leftPoints.length; i++) {
        const segIdx = leftPoints[i].seg;
        if (segIdx % MARKER_SPACING !== 0) continue;

        const lp = leftPoints[i];
        const rp = rightPoints[i];
        const ps = lp.perspScale;
        const markerH = Math.max(1, MARKER_HEIGHT_BASE * ps * 0.02);
        const markerW = Math.max(1, 4 * ps * 0.015);

        // Left marker (white)
        if (lp.y > HORIZON_Y && lp.y < ROAD_BOTTOM_Y) {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = Math.min(8, ps * 0.1);
          ctx.fillRect(lp.x - markerW / 2, lp.y - markerH, markerW, markerH);
          ctx.shadowBlur = 0;
        }

        // Right marker (white)
        if (rp.y > HORIZON_Y && rp.y < ROAD_BOTTOM_Y) {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = Math.min(8, ps * 0.1);
          ctx.fillRect(rp.x - markerW / 2, rp.y - markerH, markerW, markerH);
          ctx.shadowBlur = 0;
        }
      }

      // Draw road edge lines (subtle continuous lines connecting markers)
      if (leftPoints.length > 1) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
        for (let i = 1; i < leftPoints.length; i++) {
          if (leftPoints[i].y > HORIZON_Y) {
            ctx.lineTo(leftPoints[i].x, leftPoints[i].y);
          }
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(rightPoints[0].x, rightPoints[0].y);
        for (let i = 1; i < rightPoints.length; i++) {
          if (rightPoints[i].y > HORIZON_Y) {
            ctx.lineTo(rightPoints[i].x, rightPoints[i].y);
          }
        }
        ctx.stroke();
      }

      // Draw oncoming cars (headlights only)
      for (const car of oncomingCars) {
        const relSeg = car.segmentPos - currentSegIdx;
        if (relSeg <= 0 || relSeg > DRAW_DISTANCE) continue;

        // Find position on road
        let horizOffset = 0;
        for (let j = currentSegIdx; j < Math.floor(car.segmentPos); j++) {
          const c = roadSegments[j % roadSegments.length] || 0;
          horizOffset += c * (car.segmentPos - j) * 1.5;
        }

        const perspScale = 1 / (relSeg * 0.04 + 0.1);
        const screenY = HORIZON_Y + (ROAD_BOTTOM_Y - HORIZON_Y) * (1 - 1 / (1 + relSeg * 0.06));
        const roadCenterX = VANISH_X + horizOffset * 800 * perspScale - playerX * perspScale * 60;
        const carScreenX = roadCenterX + car.lane * perspScale * 60;

        if (screenY <= HORIZON_Y || screenY >= ROAD_BOTTOM_Y) continue;

        // Size based on distance
        const headlightSize = Math.max(1, 5 * perspScale * 0.02);
        const headlightSpacing = Math.max(2, 15 * perspScale * 0.015);
        const glowSize = headlightSize * 4;

        // Flickering
        car.headlightPhase += 0.1;
        const flicker = 0.85 + Math.sin(car.headlightPhase) * 0.15;

        // Headlight glow
        const glowAlpha = Math.min(0.6, 0.1 + (1 / (relSeg * 0.1 + 1)) * 0.5) * flicker;

        // Left headlight
        ctx.beginPath();
        const lgrd = ctx.createRadialGradient(
          carScreenX - headlightSpacing, screenY, 0,
          carScreenX - headlightSpacing, screenY, glowSize
        );
        lgrd.addColorStop(0, `rgba(255, 255, 200, ${glowAlpha})`);
        lgrd.addColorStop(0.3, `rgba(255, 255, 150, ${glowAlpha * 0.5})`);
        lgrd.addColorStop(1, 'rgba(255, 255, 100, 0)');
        ctx.fillStyle = lgrd;
        ctx.fillRect(carScreenX - headlightSpacing - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);

        // Left headlight bright center
        ctx.fillStyle = `rgba(255, 255, 230, ${Math.min(1, glowAlpha * 2)})`;
        ctx.shadowColor = '#ffa';
        ctx.shadowBlur = headlightSize * 3;
        ctx.beginPath();
        ctx.arc(carScreenX - headlightSpacing, screenY, headlightSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Right headlight
        ctx.beginPath();
        const rgrd = ctx.createRadialGradient(
          carScreenX + headlightSpacing, screenY, 0,
          carScreenX + headlightSpacing, screenY, glowSize
        );
        rgrd.addColorStop(0, `rgba(255, 255, 200, ${glowAlpha})`);
        rgrd.addColorStop(0.3, `rgba(255, 255, 150, ${glowAlpha * 0.5})`);
        rgrd.addColorStop(1, 'rgba(255, 255, 100, 0)');
        ctx.fillStyle = rgrd;
        ctx.fillRect(carScreenX + headlightSpacing - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);

        ctx.fillStyle = `rgba(255, 255, 230, ${Math.min(1, glowAlpha * 2)})`;
        ctx.shadowColor = '#ffa';
        ctx.shadowBlur = headlightSize * 3;
        ctx.beginPath();
        ctx.arc(carScreenX + headlightSpacing, screenY, headlightSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw headlight beams from player car
      drawHeadlights();

      // Draw dashboard
      drawDashboard();

      // Off-road warning flash
      if (crashTimer > 0) {
        const flashAlpha = 0.15 + Math.sin(frameCount * 0.5) * 0.1;
        ctx.fillStyle = `rgba(255, 50, 50, ${flashAlpha})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawHeadlights() {
      // Two light cones from bottom center going up
      const beamBottomY = DASH_Y;
      const beamTopY = HORIZON_Y + 40;
      const beamBottomSpread = 60;
      const beamTopSpread = 20;
      const playerScreenOffset = -steerAngle * 15;

      const leftBeamX = W / 2 - 40 + playerScreenOffset;
      const rightBeamX = W / 2 + 40 + playerScreenOffset;

      // Left headlight beam
      const lGrad = ctx.createLinearGradient(0, beamBottomY, 0, beamTopY);
      lGrad.addColorStop(0, 'rgba(255, 255, 200, 0.06)');
      lGrad.addColorStop(0.5, 'rgba(255, 255, 180, 0.03)');
      lGrad.addColorStop(1, 'rgba(255, 255, 150, 0)');

      ctx.fillStyle = lGrad;
      ctx.beginPath();
      ctx.moveTo(leftBeamX - beamBottomSpread, beamBottomY);
      ctx.lineTo(leftBeamX + beamBottomSpread, beamBottomY);
      ctx.lineTo(leftBeamX + beamTopSpread, beamTopY);
      ctx.lineTo(leftBeamX - beamTopSpread, beamTopY);
      ctx.closePath();
      ctx.fill();

      // Right headlight beam
      const rGrad = ctx.createLinearGradient(0, beamBottomY, 0, beamTopY);
      rGrad.addColorStop(0, 'rgba(255, 255, 200, 0.06)');
      rGrad.addColorStop(0.5, 'rgba(255, 255, 180, 0.03)');
      rGrad.addColorStop(1, 'rgba(255, 255, 150, 0)');

      ctx.fillStyle = rGrad;
      ctx.beginPath();
      ctx.moveTo(rightBeamX - beamBottomSpread, beamBottomY);
      ctx.lineTo(rightBeamX + beamBottomSpread, beamBottomY);
      ctx.lineTo(rightBeamX + beamTopSpread, beamTopY);
      ctx.lineTo(rightBeamX - beamTopSpread, beamTopY);
      ctx.closePath();
      ctx.fill();
    }

    function drawDashboard() {
      const dashH = H - DASH_Y;

      // Dashboard background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, DASH_Y, W, dashH);

      // Dashboard top edge - chrome strip
      ctx.fillStyle = '#333';
      ctx.fillRect(0, DASH_Y, W, 2);
      ctx.fillStyle = '#555';
      ctx.fillRect(0, DASH_Y, W, 1);

      // Steering wheel (simplified)
      const wheelCX = W / 2;
      const wheelCY = DASH_Y + dashH * 0.6;
      const wheelR = 35;

      // Wheel shadow
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.arc(wheelCX, wheelCY, wheelR, 0, Math.PI * 2);
      ctx.stroke();

      // Wheel
      ctx.save();
      ctx.translate(wheelCX, wheelCY);
      ctx.rotate(steerAngle * 0.8);

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(0, 0, wheelR, 0, Math.PI * 2);
      ctx.stroke();

      // Wheel spokes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 4;
      for (let a = 0; a < 3; a++) {
        const angle = (a / 3) * Math.PI * 2 - Math.PI / 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * wheelR, Math.sin(angle) * wheelR);
        ctx.stroke();
      }

      // Center hub
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Speed indicator (left side)
      const speedPct = playerSpeed / MAX_SPEED;
      const speedBarX = 30;
      const speedBarY = DASH_Y + 15;
      const speedBarW = 80;
      const speedBarH = 10;

      ctx.fillStyle = '#222';
      ctx.fillRect(speedBarX, speedBarY, speedBarW, speedBarH);

      // Speed bar color: green -> yellow -> red
      let speedColor;
      if (speedPct < 0.5) speedColor = `rgb(${Math.floor(speedPct * 2 * 255)}, 255, 0)`;
      else speedColor = `rgb(255, ${Math.floor((1 - speedPct) * 2 * 255)}, 0)`;

      ctx.fillStyle = speedColor;
      ctx.shadowColor = speedColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(speedBarX, speedBarY, speedBarW * speedPct, speedBarH);
      ctx.shadowBlur = 0;

      // Speed label
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('SPEED', speedBarX, speedBarY + speedBarH + 14);

      // Speed number
      const mph = Math.floor(playerSpeed * 15);
      ctx.fillStyle = '#c4a';
      ctx.shadowColor = '#c4a';
      ctx.shadowBlur = 4;
      ctx.font = 'bold 16px Courier New';
      ctx.fillText(mph + ' mph', speedBarX, speedBarY + speedBarH + 32);
      ctx.shadowBlur = 0;

      // Distance indicator (right side)
      const distMiles = (distanceTraveled / 100).toFixed(1);
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('DISTANCE', W - 30, speedBarY + speedBarH + 14);
      ctx.fillStyle = '#c4a';
      ctx.shadowColor = '#c4a';
      ctx.shadowBlur = 4;
      ctx.font = 'bold 16px Courier New';
      ctx.fillText(distMiles + ' mi', W - 30, speedBarY + speedBarH + 32);
      ctx.shadowBlur = 0;

      // Headlight indicators
      const hlX = W / 2;
      const hlY = DASH_Y + 15;
      ctx.fillStyle = playerSpeed > 0 ? '#ffa' : '#333';
      ctx.shadowColor = playerSpeed > 0 ? '#ffa' : 'transparent';
      ctx.shadowBlur = playerSpeed > 0 ? 6 : 0;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('\u25cf LIGHTS', hlX, hlY + 8);
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

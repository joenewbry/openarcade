<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Micro Machines</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f80; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 0, 0.5); }
    h1 { color: #f80; font-size: 1.8rem; text-shadow: 0 0 15px rgba(255, 136, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f80; }
    canvas {
      border: 2px solid #f80;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f80;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255,136,0,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>MICRO MACHINES</h1>
  </div>
  <div class="score-bar">
    <div>Lap: <span id="lapDisplay">0/3</span> | Item: <span id="itemDisplay">None</span></div>
    <div>Points: <span id="score">0</span> | Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">MICRO MACHINES</h2>
      <p id="overlayText">Arrows to drive, SPACE for items<br>Race tiny cars on household surfaces!<br><br>Press ENTER to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const lapEl = document.getElementById('lapDisplay');
    const itemEl = document.getElementById('itemDisplay');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'menu';
    let score = 0;
    let best = parseInt(localStorage.getItem('microMachinesBest')) || 0;
    bestEl.textContent = best;

    // ── Constants ──
    const CAR_LEN = 14, CAR_WID = 8;
    const FRICTION = 0.97;
    const TURN_SPEED = 0.045;
    const ACCEL = 0.18;
    const BRAKE = 0.12;
    const MAX_SPEED = 3.8;
    const BOOST_MULT = 1.8;
    const LAPS_TO_WIN = 3;
    const POINTS_TO_WIN = 5;
    const ITEM_TYPES = ['boost', 'oil', 'missile', 'shield'];
    const ITEM_COLORS = { boost: '#0f0', oil: '#840', missile: '#f00', shield: '#08f' };
    const ITEM_NAMES = { boost: 'BOOST', oil: 'OIL SLICK', missile: 'MISSILE', shield: 'SHIELD' };
    const CAR_COLORS = ['#f33', '#3cf', '#3f3', '#ff3'];
    const CAR_NAMES = ['Red', 'Blue', 'Green', 'Yellow'];

    // ── Track Definitions ──
    // Tracks are defined as arrays of waypoints forming a loop.
    // The track surface is drawn as a wide path between these points.
    const TRACKS = [];

    // Track 0: Kitchen Table - simple oval with household items
    TRACKS.push({
      name: 'Kitchen Table',
      bg: '#8B6F47',
      trackColor: '#a08060',
      borderColor: '#604020',
      waypoints: [
        {x:300,y:420},{x:160,y:400},{x:80,y:340},{x:60,y:250},
        {x:80,y:160},{x:160,y:100},{x:300,y:80},{x:440,y:100},
        {x:520,y:160},{x:540,y:250},{x:520,y:340},{x:440,y:400}
      ],
      width: 60,
      obstacles: [
        {type:'book',x:200,y:250,w:50,h:35,color:'#c44',angle:0.2},
        {type:'cup',x:400,y:200,r:18,color:'#ddd'},
        {type:'pen',x:350,y:350,w:60,h:5,color:'#229',angle:-0.4},
        {type:'eraser',x:150,y:180,w:25,h:15,color:'#f9a',angle:0.5}
      ],
      itemSpawns: [{x:300,y:420},{x:80,y:250},{x:300,y:80},{x:520,y:250}],
      startX: 300, startY: 450, startAngle: -Math.PI/2
    });

    // Track 1: Desk - figure 8
    TRACKS.push({
      name: 'Study Desk',
      bg: '#5a4a3a',
      trackColor: '#7a6a5a',
      borderColor: '#3a2a1a',
      waypoints: [
        {x:150,y:430},{x:70,y:370},{x:60,y:280},{x:100,y:200},
        {x:200,y:160},{x:300,y:200},{x:400,y:300},{x:500,y:340},
        {x:540,y:280},{x:530,y:200},{x:480,y:140},{x:380,y:100},
        {x:300,y:120},{x:200,y:200},{x:140,y:320},{x:150,y:400}
      ],
      width: 52,
      obstacles: [
        {type:'book',x:320,y:380,w:55,h:40,color:'#48a',angle:-0.1},
        {type:'cup',x:450,y:230,r:16,color:'#eee'},
        {type:'pen',x:180,y:300,w:55,h:5,color:'#333',angle:0.8},
        {type:'eraser',x:400,y:160,w:20,h:12,color:'#fca',angle:-0.3},
        {type:'book',x:120,y:140,w:40,h:30,color:'#6a4',angle:0.4}
      ],
      itemSpawns: [{x:150,y:430},{x:100,y:200},{x:480,y:140},{x:540,y:280}],
      startX: 200, startY: 450, startAngle: -Math.PI/2
    });

    // Track 2: Bathroom Counter
    TRACKS.push({
      name: 'Bathroom Counter',
      bg: '#607080',
      trackColor: '#8090a0',
      borderColor: '#405060',
      waypoints: [
        {x:100,y:440},{x:60,y:360},{x:80,y:260},{x:140,y:180},
        {x:240,y:120},{x:360,y:90},{x:460,y:120},{x:520,y:200},
        {x:540,y:300},{x:500,y:380},{x:420,y:420},{x:340,y:380},
        {x:280,y:320},{x:250,y:260},{x:280,y:200},{x:340,y:180},
        {x:400,y:220},{x:400,y:300},{x:350,y:360},{x:260,y:400},
        {x:180,y:430}
      ],
      width: 48,
      obstacles: [
        {type:'cup',x:180,y:260,r:20,color:'#faf'},
        {type:'book',x:440,y:300,w:35,h:50,color:'#fff',angle:0},
        {type:'eraser',x:320,y:260,w:30,h:18,color:'#afa',angle:0.7},
        {type:'cup',x:130,y:350,r:14,color:'#ff8'}
      ],
      itemSpawns: [{x:100,y:440},{x:240,y:120},{x:520,y:200},{x:350,y:360}],
      startX: 140, startY: 460, startAngle: -Math.PI/2
    });

    // ── Game State ──
    let cars = [];
    let items = [];        // items on track (pickups)
    let projectiles = [];  // missiles, oil slicks in-world
    let currentTrack = 0;
    let track = TRACKS[0];
    let raceCountdown = 0;
    let cameraX = 0, cameraY = 0;
    let particles = [];
    let playerPoints = [0,0,0,0];
    let raceOver = false;
    let raceWinner = -1;
    let raceEndTimer = 0;
    let matchOver = false;
    let numPlayers = 4; // 1 human + 3 AI

    // ── Keys ──
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === 'Enter' && (gameState === 'menu' || gameState === 'matchEnd')) {
        startMatch();
      }
      if (e.key === ' ') e.preventDefault();
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // ── Utility ──
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function angleDiff(a, b) { let d = b - a; while (d > Math.PI) d -= 2*Math.PI; while (d < -Math.PI) d += 2*Math.PI; return d; }
    function randRange(a, b) { return a + Math.random() * (b - a); }

    // ── Point on track check ──
    function nearestWaypointSegment(px, py) {
      const wp = track.waypoints;
      let bestDist = Infinity, bestIdx = 0, bestT = 0;
      for (let i = 0; i < wp.length; i++) {
        const j = (i + 1) % wp.length;
        const ax = wp[i].x, ay = wp[i].y;
        const bx = wp[j].x, by = wp[j].y;
        const dx = bx - ax, dy = by - ay;
        const len2 = dx*dx + dy*dy;
        let t = len2 === 0 ? 0 : ((px-ax)*dx + (py-ay)*dy) / len2;
        t = Math.max(0, Math.min(1, t));
        const cx = ax + t*dx, cy = ay + t*dy;
        const d = Math.hypot(px-cx, py-cy);
        if (d < bestDist) { bestDist = d; bestIdx = i; bestT = t; }
      }
      return { dist: bestDist, idx: bestIdx, t: bestT };
    }

    function isOnTrack(px, py) {
      return nearestWaypointSegment(px, py).dist < track.width / 2 + 5;
    }

    function getTrackProgress(px, py) {
      const r = nearestWaypointSegment(px, py);
      return (r.idx + r.t) / track.waypoints.length;
    }

    // ── Car Factory ──
    function createCar(idx, isPlayer) {
      const wp = track.waypoints;
      // Stagger start positions behind start line
      const sx = track.startX + (idx % 2) * 25 - 12;
      const sy = track.startY + Math.floor(idx / 2) * 25;
      return {
        x: sx, y: sy,
        vx: 0, vy: 0,
        angle: track.startAngle,
        speed: 0,
        idx: idx,
        isPlayer: isPlayer,
        color: CAR_COLORS[idx],
        item: null,
        shieldTimer: 0,
        boostTimer: 0,
        spinTimer: 0,
        lap: 0,
        lastProgress: 0,
        crossedStart: false,
        alive: true,
        offscreenTimer: 0,
        finished: false,
        finishOrder: -1,
        // AI state
        aiTargetWP: 2,
        aiItemCooldown: 0,
        aiSteerNoise: 0
      };
    }

    // ── Match / Race Start ──
    function startMatch() {
      gameState = 'racing';
      overlay.style.display = 'none';
      playerPoints = [0,0,0,0];
      score = 0;
      currentTrack = 0;
      startRace();
    }

    function startRace() {
      track = TRACKS[currentTrack % TRACKS.length];
      cars = [];
      for (let i = 0; i < numPlayers; i++) {
        cars.push(createCar(i, i === 0));
      }
      items = [];
      projectiles = [];
      particles = [];
      raceOver = false;
      raceWinner = -1;
      raceEndTimer = 0;
      raceCountdown = 180; // 3 seconds at 60fps
      spawnItems();
      updateScoreBar();
    }

    function spawnItems() {
      items = [];
      for (const sp of track.itemSpawns) {
        items.push({
          x: sp.x + randRange(-15, 15),
          y: sp.y + randRange(-15, 15),
          type: ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)],
          respawnTimer: 0
        });
      }
    }

    // ── Update ──
    function update() {
      if (gameState !== 'racing') return;

      // Countdown
      if (raceCountdown > 0) {
        raceCountdown--;
        return;
      }

      // Race over timer
      if (raceOver) {
        raceEndTimer++;
        if (raceEndTimer > 150) {
          // Award points
          let finishOrder = cars.filter(c => c.finished).sort((a,b) => a.finishOrder - b.finishOrder);
          let unfinished = cars.filter(c => !c.finished);
          // Points: 1st=3, 2nd=2, 3rd=1, 4th=0
          const pts = [3, 2, 1, 0];
          let order = [...finishOrder, ...unfinished];
          for (let i = 0; i < order.length; i++) {
            playerPoints[order[i].idx] += pts[i] || 0;
          }
          score = playerPoints[0];
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; localStorage.setItem('microMachinesBest', best); }

          // Check match end
          if (playerPoints.some(p => p >= POINTS_TO_WIN)) {
            let winner = playerPoints.indexOf(Math.max(...playerPoints));
            gameState = 'matchEnd';
            overlayTitle.textContent = winner === 0 ? 'YOU WIN!' : CAR_NAMES[winner].toUpperCase() + ' WINS!';
            overlayText.innerHTML = 'Final Scores:<br>' +
              cars.map((c,i) => CAR_NAMES[i] + ': ' + playerPoints[i] + ' pts').join('<br>') +
              '<br><br>Press ENTER to play again';
            overlay.style.display = 'flex';
            return;
          }

          // Next race
          currentTrack++;
          startRace();
          return;
        }
        // Still update particles
        updateParticles();
        return;
      }

      // Update cars
      let finishCount = 0;
      for (const car of cars) {
        if (car.finished) { finishCount++; continue; }
        updateCar(car);
      }

      // Check if race is done (first car finishes 3 laps)
      if (finishCount > 0 && !raceOver) {
        // Give remaining cars a moment, but mark race over
        let allDoneOrTimeout = finishCount >= numPlayers;
        if (finishCount >= 1) {
          // End race when first finishes
          raceOver = true;
          // Mark unfinished cars as finished in current order
          let nextOrder = finishCount;
          let remaining = cars.filter(c => !c.finished)
            .sort((a,b) => {
              let pa = a.lap + getTrackProgress(a.x, a.y);
              let pb = b.lap + getTrackProgress(b.x, b.y);
              return pb - pa;
            });
          for (const c of remaining) {
            c.finished = true;
            c.finishOrder = nextOrder++;
          }
        }
      }

      // Update items
      for (const item of items) {
        if (item.respawnTimer > 0) {
          item.respawnTimer--;
          if (item.respawnTimer === 0) {
            item.type = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
          }
        }
      }

      // Update projectiles
      updateProjectiles();

      // Update particles
      updateParticles();

      // Camera follows leader (or player)
      let leader = cars[0]; // default player
      let bestProgress = -1;
      for (const c of cars) {
        let p = c.lap * 100 + getTrackProgress(c.x, c.y) * 100;
        if (p > bestProgress) { bestProgress = p; leader = c; }
      }
      let targetCX = leader.x - W/2;
      let targetCY = leader.y - H/2;
      cameraX = lerp(cameraX, targetCX, 0.08);
      cameraY = lerp(cameraY, targetCY, 0.08);

      // Check off-screen for point loss
      for (const car of cars) {
        if (car.finished) continue;
        let sx = car.x - cameraX, sy = car.y - cameraY;
        if (sx < -30 || sx > W + 30 || sy < -30 || sy > H + 30) {
          car.offscreenTimer++;
          if (car.offscreenTimer > 60) {
            // Respawn on track near last known good position
            respawnCar(car);
            car.offscreenTimer = 0;
          }
        } else {
          car.offscreenTimer = 0;
        }
      }

      // Update HUD
      updateScoreBar();
    }

    function updateCar(car) {
      if (car.spinTimer > 0) {
        car.spinTimer--;
        car.angle += 0.2;
        car.vx *= 0.95;
        car.vy *= 0.95;
        car.x += car.vx;
        car.y += car.vy;
        return;
      }

      let accel = 0, steer = 0, useItem = false;

      if (car.isPlayer) {
        if (keys['ArrowUp']) accel = 1;
        if (keys['ArrowDown']) accel = -0.6;
        if (keys['ArrowLeft']) steer = -1;
        if (keys['ArrowRight']) steer = 1;
        if (keys[' ']) { useItem = true; keys[' '] = false; }
      } else {
        // AI
        const ai = getAIInput(car);
        accel = ai.accel;
        steer = ai.steer;
        useItem = ai.useItem;
      }

      // Boost
      let maxSpd = MAX_SPEED;
      if (car.boostTimer > 0) {
        car.boostTimer--;
        maxSpd *= BOOST_MULT;
        if (Math.random() < 0.3) {
          particles.push({
            x: car.x - Math.cos(car.angle)*8, y: car.y - Math.sin(car.angle)*8,
            vx: randRange(-1,1), vy: randRange(-1,1),
            life: 15, color: '#f80', size: 3
          });
        }
      }
      if (car.shieldTimer > 0) car.shieldTimer--;

      // Steering (only when moving)
      let speed = Math.hypot(car.vx, car.vy);
      if (speed > 0.3) {
        car.angle += steer * TURN_SPEED * Math.min(speed / 2, 1);
      }

      // Acceleration
      if (accel > 0) {
        car.vx += Math.cos(car.angle) * ACCEL * accel;
        car.vy += Math.sin(car.angle) * ACCEL * accel;
      } else if (accel < 0) {
        car.vx += Math.cos(car.angle) * BRAKE * accel;
        car.vy += Math.sin(car.angle) * BRAKE * accel;
      }

      // Friction
      car.vx *= FRICTION;
      car.vy *= FRICTION;

      // Speed cap
      speed = Math.hypot(car.vx, car.vy);
      if (speed > maxSpd) {
        car.vx = (car.vx / speed) * maxSpd;
        car.vy = (car.vy / speed) * maxSpd;
      }

      // Off-track penalty (slow down)
      if (!isOnTrack(car.x, car.y)) {
        car.vx *= 0.93;
        car.vy *= 0.93;
        // Dust particles
        if (Math.random() < 0.2) {
          particles.push({
            x: car.x, y: car.y,
            vx: randRange(-0.5,0.5), vy: randRange(-0.5,0.5),
            life: 20, color: '#a98', size: 4
          });
        }
      }

      // Move
      car.x += car.vx;
      car.y += car.vy;

      // Obstacle collision
      for (const obs of track.obstacles) {
        if (obs.type === 'cup') {
          if (dist(car, obs) < obs.r + 6) {
            // Bounce off
            let dx = car.x - obs.x, dy = car.y - obs.y;
            let d = Math.hypot(dx, dy) || 1;
            car.x = obs.x + dx/d * (obs.r + 7);
            car.y = obs.y + dy/d * (obs.r + 7);
            car.vx = dx/d * speed * 0.5;
            car.vy = dy/d * speed * 0.5;
          }
        } else {
          // Rectangle obstacle (simplified AABB with rotation)
          let co = Math.cos(-obs.angle || 0), si = Math.sin(-obs.angle || 0);
          let rx = (car.x - obs.x) * co - (car.y - obs.y) * si;
          let ry = (car.x - obs.x) * si + (car.y - obs.y) * co;
          let hw = (obs.w || 40)/2 + 5, hh = (obs.h || 20)/2 + 5;
          if (Math.abs(rx) < hw && Math.abs(ry) < hh) {
            // Push out
            if (Math.abs(rx)/hw > Math.abs(ry)/hh) {
              rx = rx > 0 ? hw : -hw;
            } else {
              ry = ry > 0 ? hh : -hh;
            }
            let co2 = Math.cos(obs.angle || 0), si2 = Math.sin(obs.angle || 0);
            car.x = obs.x + rx * co2 - ry * si2;
            car.y = obs.y + rx * si2 + ry * co2;
            car.vx *= -0.3;
            car.vy *= -0.3;
          }
        }
      }

      // Car-car collision
      for (const other of cars) {
        if (other === car || other.finished) continue;
        let d = dist(car, other);
        if (d < 12 && d > 0) {
          let dx = car.x - other.x, dy = car.y - other.y;
          let push = (12 - d) / 2;
          car.x += dx/d * push;
          car.y += dy/d * push;
          other.x -= dx/d * push;
          other.y -= dy/d * push;
          // Exchange some velocity
          let tvx = car.vx, tvy = car.vy;
          car.vx = lerp(car.vx, other.vx, 0.3);
          car.vy = lerp(car.vy, other.vy, 0.3);
          other.vx = lerp(other.vx, tvx, 0.3);
          other.vy = lerp(other.vy, tvy, 0.3);
        }
      }

      // Item pickup
      for (const item of items) {
        if (item.respawnTimer > 0) continue;
        if (dist(car, item) < 18 && !car.item) {
          car.item = item.type;
          item.respawnTimer = 300; // 5 sec respawn
          if (car.isPlayer) itemEl.textContent = ITEM_NAMES[car.item];
        }
      }

      // Use item
      if (useItem && car.item) {
        activateItem(car);
      }

      // Lap tracking
      let progress = getTrackProgress(car.x, car.y);
      // Detect crossing start line (progress wraps from ~1 to ~0)
      if (car.lastProgress > 0.8 && progress < 0.2) {
        car.lap++;
        if (car.lap >= LAPS_TO_WIN) {
          car.finished = true;
          car.finishOrder = cars.filter(c => c.finished).length - 1;
        }
        // Particles for lap
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: car.x, y: car.y,
            vx: randRange(-2,2), vy: randRange(-2,2),
            life: 30, color: car.color, size: 3
          });
        }
      } else if (car.lastProgress < 0.2 && progress > 0.8) {
        // Going backwards
        car.lap = Math.max(0, car.lap - 1);
      }
      car.lastProgress = progress;

      // Tire smoke when turning hard
      if (Math.abs(steer) > 0.5 && speed > 2) {
        particles.push({
          x: car.x - Math.cos(car.angle)*5, y: car.y - Math.sin(car.angle)*5,
          vx: randRange(-0.3,0.3), vy: randRange(-0.3,0.3),
          life: 12, color: '#888', size: 2
        });
      }
    }

    function activateItem(car) {
      const type = car.item;
      car.item = null;
      if (car.isPlayer) itemEl.textContent = 'None';

      switch (type) {
        case 'boost':
          car.boostTimer = 45;
          break;
        case 'oil':
          projectiles.push({
            type: 'oil',
            x: car.x - Math.cos(car.angle) * 15,
            y: car.y - Math.sin(car.angle) * 15,
            vx: 0, vy: 0,
            owner: car.idx,
            life: 600, // 10 sec
            r: 12
          });
          break;
        case 'missile':
          projectiles.push({
            type: 'missile',
            x: car.x + Math.cos(car.angle) * 10,
            y: car.y + Math.sin(car.angle) * 10,
            vx: Math.cos(car.angle) * 6,
            vy: Math.sin(car.angle) * 6,
            owner: car.idx,
            life: 120,
            r: 4
          });
          break;
        case 'shield':
          car.shieldTimer = 300; // 5 sec
          break;
      }
    }

    function updateProjectiles() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life--;
        if (p.life <= 0) { projectiles.splice(i, 1); continue; }

        if (p.type === 'missile') {
          p.x += p.vx;
          p.y += p.vy;
          // Trail
          particles.push({
            x: p.x, y: p.y,
            vx: randRange(-0.5,0.5), vy: randRange(-0.5,0.5),
            life: 10, color: '#f80', size: 2
          });
        }

        // Hit check
        for (const car of cars) {
          if (car.idx === p.owner || car.finished || car.spinTimer > 0) continue;
          if (dist(car, p) < p.r + 6) {
            if (car.shieldTimer > 0) {
              // Shield blocks
              car.shieldTimer = Math.max(0, car.shieldTimer - 60);
              for (let j = 0; j < 8; j++) {
                particles.push({
                  x: car.x, y: car.y,
                  vx: randRange(-2,2), vy: randRange(-2,2),
                  life: 20, color: '#08f', size: 3
                });
              }
            } else {
              // Hit!
              if (p.type === 'missile') {
                car.spinTimer = 40;
                car.vx = p.vx * 0.5;
                car.vy = p.vy * 0.5;
                for (let j = 0; j < 15; j++) {
                  particles.push({
                    x: car.x, y: car.y,
                    vx: randRange(-3,3), vy: randRange(-3,3),
                    life: 25, color: '#f80', size: 4
                  });
                }
              } else if (p.type === 'oil') {
                car.spinTimer = 30;
                // Don't remove oil, it persists
                continue;
              }
            }
            if (p.type === 'missile') {
              projectiles.splice(i, 1);
              break;
            }
          }
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function respawnCar(car) {
      // Put car back on nearest track waypoint
      const r = nearestWaypointSegment(car.x, car.y);
      const wp = track.waypoints;
      const i = r.idx, j = (i+1) % wp.length;
      car.x = lerp(wp[i].x, wp[j].x, r.t);
      car.y = lerp(wp[i].y, wp[j].y, r.t);
      car.vx = 0;
      car.vy = 0;
      // Face towards next waypoint
      const ni = (r.idx + 2) % wp.length;
      car.angle = Math.atan2(wp[ni].y - car.y, wp[ni].x - car.x);
      car.spinTimer = 0;
    }

    // ── AI ──
    function getAIInput(car) {
      const wp = track.waypoints;
      const target = wp[car.aiTargetWP % wp.length];
      const dx = target.x - car.x, dy = target.y - car.y;
      const distToTarget = Math.hypot(dx, dy);

      // Advance waypoint when close
      if (distToTarget < 40) {
        car.aiTargetWP = (car.aiTargetWP + 1) % wp.length;
      }

      // Desired angle
      const desiredAngle = Math.atan2(dy, dx);
      const diff = angleDiff(car.angle, desiredAngle);

      // Add slight randomness for variety
      if (Math.random() < 0.02) car.aiSteerNoise = randRange(-0.3, 0.3);

      let steer = 0;
      if (diff > 0.05) steer = Math.min(1, diff * 2 + car.aiSteerNoise);
      else if (diff < -0.05) steer = Math.max(-1, diff * 2 + car.aiSteerNoise);

      // Slow down for sharp turns
      let speed = Math.hypot(car.vx, car.vy);
      let accel = 1;
      if (Math.abs(diff) > 0.8 && speed > 2) accel = -0.3; // brake for sharp turns
      else if (Math.abs(diff) > 0.4 && speed > 2.5) accel = 0.3;

      // Item usage AI
      let useItem = false;
      if (car.item && car.aiItemCooldown <= 0) {
        if (car.item === 'boost') {
          // Use boost on straights
          if (Math.abs(diff) < 0.3) { useItem = true; car.aiItemCooldown = 60; }
        } else if (car.item === 'missile') {
          // Fire if car ahead is in line of sight
          for (const other of cars) {
            if (other.idx === car.idx) continue;
            let toDist = dist(car, other);
            if (toDist < 120 && toDist > 20) {
              let toAngle = Math.atan2(other.y - car.y, other.x - car.x);
              if (Math.abs(angleDiff(car.angle, toAngle)) < 0.3) {
                useItem = true;
                car.aiItemCooldown = 90;
              }
            }
          }
        } else if (car.item === 'oil') {
          // Drop if someone is close behind
          for (const other of cars) {
            if (other.idx === car.idx) continue;
            let toDist = dist(car, other);
            let toAngle = Math.atan2(other.y - car.y, other.x - car.x);
            let behind = Math.abs(angleDiff(car.angle, toAngle)) > 2;
            if (toDist < 60 && behind) {
              useItem = true;
              car.aiItemCooldown = 90;
            }
          }
          // Random drop
          if (Math.random() < 0.005) { useItem = true; car.aiItemCooldown = 90; }
        } else if (car.item === 'shield') {
          // Use shield when near other cars
          let nearCar = cars.some(c => c.idx !== car.idx && dist(c, car) < 80);
          if (nearCar && Math.random() < 0.02) { useItem = true; car.aiItemCooldown = 60; }
        }
      }
      if (car.aiItemCooldown > 0) car.aiItemCooldown--;

      return { accel, steer, useItem };
    }

    // ── Drawing ──
    function draw() {
      ctx.save();

      // Clear
      ctx.fillStyle = track.bg;
      ctx.fillRect(0, 0, W, H);

      // Camera transform
      ctx.translate(-cameraX, -cameraY);

      // Draw track surface
      drawTrack();

      // Draw obstacles
      drawObstacles();

      // Draw start/finish line
      drawStartLine();

      // Draw items
      drawItems();

      // Draw projectiles
      drawProjectiles();

      // Draw particles
      drawParticles();

      // Draw cars
      for (const car of cars) {
        drawCar(car);
      }

      ctx.restore();

      // HUD overlay
      drawHUD();
    }

    function drawTrack() {
      const wp = track.waypoints;

      // Track border (wider)
      ctx.beginPath();
      ctx.moveTo(wp[0].x, wp[0].y);
      for (let i = 1; i <= wp.length; i++) {
        const p = wp[i % wp.length];
        ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.strokeStyle = track.borderColor;
      ctx.lineWidth = track.width + 8;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.stroke();

      // Track surface
      ctx.strokeStyle = track.trackColor;
      ctx.lineWidth = track.width;
      ctx.stroke();

      // Center dashed line
      ctx.setLineDash([8, 12]);
      ctx.strokeStyle = '#fff3';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.setLineDash([]);

      // Track edge detail (grain texture hint)
      ctx.strokeStyle = track.borderColor + '40';
      ctx.lineWidth = track.width + 4;
      ctx.stroke();
    }

    function drawStartLine() {
      const sx = track.startX, sy = track.startY;
      const a = track.startAngle + Math.PI / 2;
      const hw = track.width / 2;
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(a);
      // Checkered pattern
      const sq = 6;
      const n = Math.floor(hw * 2 / sq);
      for (let i = 0; i < n; i++) {
        ctx.fillStyle = i % 2 === 0 ? '#fff' : '#111';
        ctx.fillRect(-hw + i * sq, -2, sq, 4);
      }
      ctx.restore();
    }

    function drawObstacles() {
      for (const obs of track.obstacles) {
        ctx.save();
        ctx.translate(obs.x, obs.y);
        ctx.rotate(obs.angle || 0);

        if (obs.type === 'cup') {
          // Cup (circle with rim)
          ctx.beginPath();
          ctx.arc(0, 0, obs.r, 0, Math.PI * 2);
          ctx.fillStyle = obs.color;
          ctx.fill();
          ctx.strokeStyle = '#0003';
          ctx.lineWidth = 2;
          ctx.stroke();
          // Inner shadow
          ctx.beginPath();
          ctx.arc(0, 0, obs.r - 4, 0, Math.PI * 2);
          ctx.fillStyle = '#0002';
          ctx.fill();
          // Handle
          ctx.beginPath();
          ctx.arc(obs.r - 2, 0, 6, -Math.PI/2, Math.PI/2);
          ctx.strokeStyle = obs.color;
          ctx.lineWidth = 3;
          ctx.stroke();
        } else if (obs.type === 'book') {
          ctx.fillStyle = obs.color;
          ctx.fillRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
          ctx.strokeStyle = '#0004';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
          // Pages
          ctx.fillStyle = '#ffe';
          ctx.fillRect(-obs.w/2 + 3, -obs.h/2 + 2, obs.w - 6, obs.h - 4);
          ctx.fillStyle = obs.color;
          ctx.fillRect(-obs.w/2, -obs.h/2, obs.w, 5);
          // Title line
          ctx.fillStyle = '#0005';
          ctx.fillRect(-obs.w/4, -obs.h/2 + 1.5, obs.w/2, 2);
        } else if (obs.type === 'pen') {
          ctx.fillStyle = obs.color;
          ctx.fillRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
          // Tip
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.moveTo(obs.w/2, -obs.h/2);
          ctx.lineTo(obs.w/2 + 6, 0);
          ctx.lineTo(obs.w/2, obs.h/2);
          ctx.fill();
          // Clip
          ctx.fillStyle = '#ccc';
          ctx.fillRect(-obs.w/2 + 2, -obs.h/2 - 2, 8, obs.h + 4);
        } else if (obs.type === 'eraser') {
          ctx.fillStyle = obs.color;
          ctx.fillRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
          ctx.strokeStyle = '#0003';
          ctx.strokeRect(-obs.w/2, -obs.h/2, obs.w, obs.h);
          // Band
          ctx.fillStyle = '#0002';
          ctx.fillRect(-obs.w/2 + obs.w * 0.3, -obs.h/2, obs.w * 0.15, obs.h);
        }

        ctx.restore();
      }
    }

    function drawItems() {
      for (const item of items) {
        if (item.respawnTimer > 0) continue;
        ctx.save();
        ctx.translate(item.x, item.y);

        // Glowing pickup
        const t = Date.now() / 300;
        const pulse = 0.8 + Math.sin(t) * 0.2;
        const r = 8 * pulse;

        ctx.beginPath();
        ctx.arc(0, 0, r + 4, 0, Math.PI * 2);
        ctx.fillStyle = ITEM_COLORS[item.type] + '30';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = ITEM_COLORS[item.type];
        ctx.fill();

        // Icon
        ctx.fillStyle = '#fff';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icons = { boost: 'B', oil: 'O', missile: 'M', shield: 'S' };
        ctx.fillText(icons[item.type], 0, 0);

        ctx.restore();
      }
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        ctx.save();
        ctx.translate(p.x, p.y);

        if (p.type === 'oil') {
          // Brown slick
          ctx.beginPath();
          ctx.arc(0, 0, p.r, 0, Math.PI * 2);
          ctx.fillStyle = '#420a';
          ctx.fill();
          ctx.beginPath();
          ctx.arc(2, -2, p.r * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = '#5308';
          ctx.fill();
        } else if (p.type === 'missile') {
          const angle = Math.atan2(p.vy, p.vx);
          ctx.rotate(angle);
          ctx.fillStyle = '#f44';
          ctx.fillRect(-5, -2, 10, 4);
          ctx.fillStyle = '#ff0';
          ctx.fillRect(4, -1.5, 3, 3);
        }

        ctx.restore();
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = p.life / 30;
        ctx.globalAlpha = Math.min(1, alpha);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
      }
      ctx.globalAlpha = 1;
    }

    function drawCar(car) {
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.angle);

      // Shadow
      ctx.fillStyle = '#0004';
      ctx.fillRect(-CAR_LEN/2 + 1, -CAR_WID/2 + 1, CAR_LEN, CAR_WID);

      // Car body
      ctx.fillStyle = car.color;
      ctx.fillRect(-CAR_LEN/2, -CAR_WID/2, CAR_LEN, CAR_WID);

      // Windshield
      ctx.fillStyle = '#0008';
      ctx.fillRect(CAR_LEN/2 - 5, -CAR_WID/2 + 1, 3, CAR_WID - 2);

      // Headlights
      ctx.fillStyle = '#ff8';
      ctx.fillRect(CAR_LEN/2, -CAR_WID/2 + 1, 2, 2);
      ctx.fillRect(CAR_LEN/2, CAR_WID/2 - 3, 2, 2);

      // Tail lights
      ctx.fillStyle = '#f00';
      ctx.fillRect(-CAR_LEN/2 - 1, -CAR_WID/2 + 1, 2, 2);
      ctx.fillRect(-CAR_LEN/2 - 1, CAR_WID/2 - 3, 2, 2);

      ctx.restore();

      // Shield effect
      if (car.shieldTimer > 0) {
        ctx.save();
        ctx.translate(car.x, car.y);
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.strokeStyle = '#08f';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100) * 0.2;
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Item indicator above car
      if (car.item && !car.isPlayer) {
        ctx.save();
        ctx.translate(car.x, car.y - 14);
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = ITEM_COLORS[car.item];
        ctx.fill();
        ctx.restore();
      }

      // Player indicator
      if (car.isPlayer) {
        ctx.save();
        ctx.translate(car.x, car.y - 16);
        ctx.fillStyle = '#fff';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('P1', 0, 0);
        ctx.restore();
      }
    }

    function drawHUD() {
      // Countdown
      if (raceCountdown > 0) {
        let sec = Math.ceil(raceCountdown / 60);
        ctx.save();
        ctx.fillStyle = '#f80';
        ctx.font = 'bold 48px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 20;
        if (sec > 0) {
          ctx.fillText(sec, W/2, H/2);
        }
        ctx.restore();
        return;
      }

      // Race position info
      ctx.save();

      // Track name
      ctx.fillStyle = '#f80';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(track.name, 8, 16);

      // Mini standings
      let sorted = [...cars].sort((a,b) => {
        let pa = a.lap * 100 + getTrackProgress(a.x, a.y) * 100;
        let pb = b.lap * 100 + getTrackProgress(b.x, b.y) * 100;
        return pb - pa;
      });

      ctx.font = '10px Courier New';
      for (let i = 0; i < sorted.length; i++) {
        const c = sorted[i];
        ctx.fillStyle = c.color;
        const pos = ['1st','2nd','3rd','4th'][i];
        const name = c.isPlayer ? 'YOU' : CAR_NAMES[c.idx];
        ctx.fillText(pos + ' ' + name, W - 90, 16 + i * 14);
      }

      // Points display
      ctx.fillStyle = '#fff8';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      for (let i = 0; i < numPlayers; i++) {
        ctx.fillStyle = CAR_COLORS[i];
        let name = i === 0 ? 'YOU' : CAR_NAMES[i];
        ctx.fillText(name + ':' + playerPoints[i], 8 + i * 70, H - 8);
      }

      // Race over banner
      if (raceOver) {
        ctx.fillStyle = '#000a';
        ctx.fillRect(0, H/2 - 30, W, 60);
        ctx.fillStyle = '#f80';
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        let winner = cars.find(c => c.finishOrder === 0);
        let name = winner.isPlayer ? 'YOU' : CAR_NAMES[winner.idx];
        ctx.fillText(name + (winner.isPlayer ? ' WIN!' : ' WINS!'), W/2, H/2 + 8);
      }

      // Minimap (top-right corner)
      const mmX = W - 80, mmY = 30, mmScale = 0.1;
      ctx.fillStyle = '#0006';
      ctx.fillRect(mmX - 35, mmY - 25, 70, 60);

      ctx.save();
      ctx.translate(mmX, mmY);
      ctx.scale(mmScale, mmScale);
      ctx.translate(-300, -250);

      // Mini track
      const wp = track.waypoints;
      ctx.beginPath();
      ctx.moveTo(wp[0].x, wp[0].y);
      for (let i = 1; i <= wp.length; i++) {
        ctx.lineTo(wp[i % wp.length].x, wp[i % wp.length].y);
      }
      ctx.closePath();
      ctx.strokeStyle = '#fff4';
      ctx.lineWidth = 20;
      ctx.stroke();

      // Mini cars
      for (const car of cars) {
        ctx.beginPath();
        ctx.arc(car.x, car.y, 15, 0, Math.PI * 2);
        ctx.fillStyle = car.color;
        ctx.fill();
      }
      ctx.restore();

      ctx.restore();
    }

    function updateScoreBar() {
      const car = cars[0];
      if (car) {
        lapEl.textContent = Math.min(car.lap + 1, LAPS_TO_WIN) + '/' + LAPS_TO_WIN;
      }
      scoreEl.textContent = playerPoints[0];
    }

    // ── Game Loop ──
    let lastTime = 0;
    function gameLoop(time) {
      requestAnimationFrame(gameLoop);
      const dt = time - lastTime;
      if (dt < 14) return; // ~60fps cap
      lastTime = time;

      update();
      draw();
    }

    // ── Init ──
    function init() {
      cameraX = TRACKS[0].startX - W/2;
      cameraY = TRACKS[0].startY - H/2;
      // Draw initial menu scene
      draw();
    }

    init();
    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blokus</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #a6f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 102, 255, 0.4); }
    h1 { color: #a6f; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 102, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar .player-score { color: #4488ff; }
    .score-bar .ai-score { color: #a6f; }
    canvas#game {
      border: 2px solid #a6f;
      box-shadow: 0 0 20px rgba(170, 102, 255, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a6f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .controls {
      width: 600px;
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      color: #888;
    }
    .controls span { color: #a6f; }
    #passBtn {
      background: #16213e;
      color: #a6f;
      border: 1px solid #a6f;
      padding: 6px 16px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      cursor: pointer;
      border-radius: 4px;
    }
    #passBtn:hover { background: rgba(170, 102, 255, 0.2); }
    #passBtn:disabled { opacity: 0.3; cursor: default; }
    #turnIndicator {
      width: 600px;
      text-align: center;
      font-size: 0.9rem;
      margin-bottom: 6px;
      height: 18px;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BLOKUS</h1>
  </div>
  <div class="score-bar">
    <div class="player-score">Player: <span id="score">0</span> sq (<span id="piecesLeft">21</span> left)</div>
    <div class="ai-score">AI: <span id="aiScore">0</span> sq (<span id="aiPiecesLeft">21</span> left)</div>
  </div>
  <div id="turnIndicator" style="color:#4488ff;">Your turn</div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">BLOKUS</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>
  <div class="controls">
    <div><span>R</span> Rotate | <span>F</span> Flip | <span>Click</span> Place</div>
    <button id="passBtn" disabled>PASS</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const piecesLeftEl = document.getElementById('piecesLeft');
    const aiPiecesLeftEl = document.getElementById('aiPiecesLeft');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const passBtn = document.getElementById('passBtn');
    const turnIndicator = document.getElementById('turnIndicator');

    // Grid settings
    const GRID = 14;
    const CELL = 28;
    const BOARD_X = Math.floor((W - GRID * CELL) / 2);
    const BOARD_Y = 8;
    const BOARD_PX = GRID * CELL;
    const PANEL_Y = BOARD_Y + BOARD_PX + 14;
    const PANEL_H = H - PANEL_Y;

    // Colors
    const PLAYER_COLOR = '#4488ff';
    const PLAYER_LIGHT = 'rgba(68, 136, 255, 0.4)';
    const PLAYER_INVALID = 'rgba(255, 60, 60, 0.35)';
    const AI_COLOR = '#a6f';
    const GRID_COLOR = '#16213e';
    const EMPTY_COLOR = '#222';
    const CORNER_DOT = 'rgba(68, 136, 255, 0.55)';

    // Standard Blokus 21 pieces: 1 monomino, 1 domino, 2 triominoes, 5 tetrominoes, 12 pentominoes
    const PIECE_DEFS = [
      { name: '1',  cells: [[0,0]] },
      { name: 'I2', cells: [[0,0],[1,0]] },
      { name: 'I3', cells: [[0,0],[1,0],[2,0]] },
      { name: 'V3', cells: [[0,0],[1,0],[1,1]] },
      { name: 'I4', cells: [[0,0],[1,0],[2,0],[3,0]] },
      { name: 'L4', cells: [[0,0],[1,0],[2,0],[2,1]] },
      { name: 'T4', cells: [[0,0],[1,0],[2,0],[1,1]] },
      { name: 'S4', cells: [[0,0],[1,0],[1,1],[2,1]] },
      { name: 'O4', cells: [[0,0],[1,0],[0,1],[1,1]] },
      { name: 'I5', cells: [[0,0],[1,0],[2,0],[3,0],[4,0]] },
      { name: 'L5', cells: [[0,0],[1,0],[2,0],[3,0],[3,1]] },
      { name: 'Y5', cells: [[0,0],[1,0],[2,0],[3,0],[1,1]] },
      { name: 'N5', cells: [[0,0],[1,0],[1,1],[2,1],[3,1]] },
      { name: 'P5', cells: [[0,0],[1,0],[2,0],[0,1],[1,1]] },
      { name: 'F5', cells: [[1,0],[2,0],[0,1],[1,1],[1,2]] },
      { name: 'T5', cells: [[0,0],[1,0],[2,0],[1,1],[1,2]] },
      { name: 'U5', cells: [[0,0],[2,0],[0,1],[1,1],[2,1]] },
      { name: 'V5', cells: [[0,0],[0,1],[0,2],[1,2],[2,2]] },
      { name: 'W5', cells: [[0,0],[0,1],[1,1],[1,2],[2,2]] },
      { name: 'X5', cells: [[1,0],[0,1],[1,1],[2,1],[1,2]] },
      { name: 'Z5', cells: [[0,0],[1,0],[1,1],[1,2],[2,2]] },
    ];

    let gameState, score;
    let board;
    let playerPieces, aiPieces;
    let selectedPieceIdx;
    let currentRotation;
    let turn;
    let mouseGridX, mouseGridY;
    let playerPassed, aiPassed;
    let hoverValid;
    let aiThinking;

    // --- Piece geometry helpers ---

    function deepCopy(cells) {
      return cells.map(c => [c[0], c[1]]);
    }

    function rotateCW(cells) {
      let r = cells.map(([x, y]) => [-y, x]);
      let mx = Math.min(...r.map(c => c[0]));
      let my = Math.min(...r.map(c => c[1]));
      return r.map(([x, y]) => [x - mx, y - my]);
    }

    function flipH(cells) {
      let f = cells.map(([x, y]) => [-x, y]);
      let mx = Math.min(...f.map(c => c[0]));
      return f.map(([x, y]) => [x - mx, y]);
    }

    function normalize(cells) {
      let mx = Math.min(...cells.map(c => c[0]));
      let my = Math.min(...cells.map(c => c[1]));
      let n = cells.map(([x, y]) => [x - mx, y - my]);
      n.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
      return n;
    }

    function cellsKey(cells) {
      return normalize(cells).map(c => c[0] + ',' + c[1]).join('|');
    }

    function getAllOrientations(cells) {
      let seen = new Set();
      let result = [];
      let base = deepCopy(cells);
      for (let f = 0; f < 2; f++) {
        let c = deepCopy(base);
        for (let r = 0; r < 4; r++) {
          let n = normalize(c);
          let k = cellsKey(n);
          if (!seen.has(k)) {
            seen.add(k);
            result.push(n);
          }
          c = rotateCW(c);
        }
        base = flipH(base);
      }
      return result;
    }

    // Pre-compute all orientations for each piece
    let PIECE_ORIENTATIONS = PIECE_DEFS.map(d => getAllOrientations(d.cells));

    function makePieceSet() {
      return PIECE_DEFS.map(d => ({
        name: d.name,
        cells: deepCopy(d.cells),
        used: false
      }));
    }

    // --- Board helpers ---

    function getCell(x, y) {
      if (x < 0 || x >= GRID || y < 0 || y >= GRID) return -1;
      return board[y * GRID + x];
    }

    function setCell(x, y, v) {
      board[y * GRID + x] = v;
    }

    function hasPlacedAny(player) {
      for (let i = 0; i < GRID * GRID; i++) {
        if (board[i] === player) return true;
      }
      return false;
    }

    // Get diagonal-corner positions that are valid attachment points
    function getValidCorners(player) {
      let corners = new Set();
      let edges = new Set();
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          if (getCell(x, y) !== player) continue;
          // edges (blocked)
          for (let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
            let nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < GRID && ny >= 0 && ny < GRID)
              edges.add(ny * GRID + nx);
          }
          // diagonal corners (potential)
          for (let [dx, dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]) {
            let nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < GRID && ny >= 0 && ny < GRID && getCell(nx, ny) === 0)
              corners.add(ny * GRID + nx);
          }
        }
      }
      for (let e of edges) corners.delete(e);
      return corners;
    }

    function isValidPlacement(cells, ox, oy, player) {
      let placed = hasPlacedAny(player);
      let startX = player === 1 ? 0 : GRID - 1;
      let startY = player === 1 ? 0 : GRID - 1;
      let coversStart = false;
      let touchesCorner = false;
      let touchesEdge = false;

      for (let [cx, cy] of cells) {
        let gx = ox + cx, gy = oy + cy;
        if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID) return false;
        if (getCell(gx, gy) !== 0) return false;
        if (gx === startX && gy === startY) coversStart = true;
        for (let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
          if (getCell(gx + dx, gy + dy) === player) touchesEdge = true;
        }
        for (let [dx, dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]) {
          if (getCell(gx + dx, gy + dy) === player) touchesCorner = true;
        }
      }

      if (!placed) return coversStart;
      return touchesCorner && !touchesEdge;
    }

    function placePiece(cells, ox, oy, player) {
      for (let [cx, cy] of cells) setCell(ox + cx, oy + cy, player);
    }

    function countSquares(player) {
      let s = 0;
      for (let i = 0; i < GRID * GRID; i++) if (board[i] === player) s++;
      return s;
    }

    function piecesRemaining(pieces) {
      let c = 0;
      for (let p of pieces) if (!p.used) c++;
      return c;
    }

    // --- Move generation ---

    function getFirstMovesList(pieces, player, pieceOrientations) {
      let sx = player === 1 ? 0 : GRID - 1;
      let sy = player === 1 ? 0 : GRID - 1;
      let moves = [];
      let seen = new Set();
      for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].used) continue;
        for (let oCells of pieceOrientations[i]) {
          for (let [cx, cy] of oCells) {
            let ox = sx - cx, oy = sy - cy;
            let key = cellsKey(oCells) + '@' + ox + ',' + oy;
            if (seen.has(key)) continue;
            seen.add(key);
            if (isValidPlacement(oCells, ox, oy, player)) {
              moves.push({ pieceIdx: i, cells: oCells, ox, oy });
            }
          }
        }
      }
      return moves;
    }

    function getAllMoves(pieces, player, pieceOrientations) {
      if (!hasPlacedAny(player)) return getFirstMovesList(pieces, player, pieceOrientations);
      let corners = getValidCorners(player);
      if (corners.size === 0) return [];
      let cornerList = [];
      for (let c of corners) cornerList.push([c % GRID, Math.floor(c / GRID)]);

      let moves = [];
      let seen = new Set();
      for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].used) continue;
        for (let oCells of pieceOrientations[i]) {
          for (let [cornerX, cornerY] of cornerList) {
            for (let [cx, cy] of oCells) {
              let ox = cornerX - cx, oy = cornerY - cy;
              let key = i + '|' + cellsKey(oCells) + '|' + ox + ',' + oy;
              if (seen.has(key)) continue;
              seen.add(key);
              if (isValidPlacement(oCells, ox, oy, player)) {
                moves.push({ pieceIdx: i, cells: oCells, ox, oy });
              }
            }
          }
        }
      }
      return moves;
    }

    function hasAnyMove(pieces, player, pieceOrientations) {
      if (!hasPlacedAny(player)) {
        let sx = player === 1 ? 0 : GRID - 1;
        let sy = player === 1 ? 0 : GRID - 1;
        for (let i = 0; i < pieces.length; i++) {
          if (pieces[i].used) continue;
          for (let oCells of pieceOrientations[i]) {
            for (let [cx, cy] of oCells) {
              if (isValidPlacement(oCells, sx - cx, sy - cy, player)) return true;
            }
          }
        }
        return false;
      }
      let corners = getValidCorners(player);
      if (corners.size === 0) return false;
      let cornerList = [];
      for (let c of corners) cornerList.push([c % GRID, Math.floor(c / GRID)]);
      for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].used) continue;
        for (let oCells of pieceOrientations[i]) {
          for (let [cornerX, cornerY] of cornerList) {
            for (let [cx, cy] of oCells) {
              if (isValidPlacement(oCells, cornerX - cx, cornerY - cy, player)) return true;
            }
          }
        }
      }
      return false;
    }

    // --- AI ---

    function aiMove() {
      let moves = getAllMoves(aiPieces, 2, PIECE_ORIENTATIONS);
      if (moves.length === 0) return null;

      // Pre-compute corners before move
      let myCornersBefore = getValidCorners(2).size;
      let oppCornersBefore = getValidCorners(1).size;
      let totalPiecesUsed = 0;
      for (let p of aiPieces) if (p.used) totalPiecesUsed++;

      let bestScore = -Infinity;
      let bestMoves = [];

      for (let move of moves) {
        let { cells, ox, oy, pieceIdx } = move;
        let pieceSize = cells.length;

        // Temporarily place
        for (let [cx, cy] of cells) setCell(ox + cx, oy + cy, 2);

        let myCorners = getValidCorners(2).size;
        let oppCorners = getValidCorners(1).size;

        // Undo
        for (let [cx, cy] of cells) setCell(ox + cx, oy + cy, 0);

        let cornerGain = myCorners - myCornersBefore;
        let oppLoss = oppCornersBefore - oppCorners;

        // Heuristic: prefer big pieces early, maximize own corners, block opponent
        let earlyGame = totalPiecesUsed < 8;
        let sc = pieceSize * (earlyGame ? 4 : 2)
               + cornerGain * 2.5
               + oppLoss * 1.5;

        // Slight center bias early
        if (earlyGame) {
          let cd = 0;
          for (let [cx, cy] of cells) {
            let dx = (ox + cx) - 6.5, dy = (oy + cy) - 6.5;
            cd += Math.sqrt(dx * dx + dy * dy);
          }
          sc -= cd * 0.15;
        }

        if (sc > bestScore) {
          bestScore = sc;
          bestMoves = [move];
        } else if (sc === bestScore) {
          bestMoves.push(move);
        }
      }

      // Pick randomly among tied best moves
      return bestMoves[Math.floor(Math.random() * bestMoves.length)];
    }

    // --- Drawing ---

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);
      drawBoard();
      drawCornerDots();
      drawHoverPreview();
      drawPiecePanel();
    }

    function drawBoard() {
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          let px = BOARD_X + x * CELL;
          let py = BOARD_Y + y * CELL;
          let v = getCell(x, y);
          ctx.fillStyle = v === 1 ? PLAYER_COLOR : v === 2 ? AI_COLOR : EMPTY_COLOR;
          ctx.fillRect(px, py, CELL, CELL);
          ctx.strokeStyle = GRID_COLOR;
          ctx.lineWidth = 1;
          ctx.strokeRect(px, py, CELL, CELL);

          // Inner highlight for placed pieces
          if (v === 1) {
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(px + 1, py + 1, CELL / 2 - 1, CELL / 2 - 1);
          } else if (v === 2) {
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            ctx.fillRect(px + 1, py + 1, CELL / 2 - 1, CELL / 2 - 1);
          }
        }
      }

      // Starting corner highlights
      if (!hasPlacedAny(1)) {
        ctx.fillStyle = 'rgba(68, 136, 255, 0.3)';
        ctx.fillRect(BOARD_X + 2, BOARD_Y + 2, CELL - 4, CELL - 4);
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 1;
        ctx.strokeRect(BOARD_X + 1, BOARD_Y + 1, CELL - 2, CELL - 2);
      }
      if (!hasPlacedAny(2)) {
        let px = BOARD_X + (GRID - 1) * CELL;
        let py = BOARD_Y + (GRID - 1) * CELL;
        ctx.fillStyle = 'rgba(170, 102, 255, 0.3)';
        ctx.fillRect(px + 2, py + 2, CELL - 4, CELL - 4);
        ctx.strokeStyle = '#a6f';
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 1, py + 1, CELL - 2, CELL - 2);
      }

      // Board border
      ctx.strokeStyle = '#a6f';
      ctx.lineWidth = 2;
      ctx.strokeRect(BOARD_X - 1, BOARD_Y - 1, BOARD_PX + 2, BOARD_PX + 2);
    }

    function drawCornerDots() {
      if (gameState !== 'playing' || turn !== 1) return;
      if (!hasPlacedAny(1)) return; // first move shows the start square instead
      let corners = getValidCorners(1);
      ctx.fillStyle = CORNER_DOT;
      for (let c of corners) {
        let x = c % GRID, y = Math.floor(c / GRID);
        ctx.beginPath();
        ctx.arc(BOARD_X + x * CELL + CELL / 2, BOARD_Y + y * CELL + CELL / 2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawHoverPreview() {
      if (gameState !== 'playing' || turn !== 1 || aiThinking) return;
      if (selectedPieceIdx < 0 || !currentRotation) return;
      if (mouseGridX < 0 || mouseGridY < 0) return;

      let valid = isValidPlacement(currentRotation, mouseGridX, mouseGridY, 1);
      hoverValid = valid;

      for (let [cx, cy] of currentRotation) {
        let gx = mouseGridX + cx, gy = mouseGridY + cy;
        if (gx < 0 || gx >= GRID || gy < 0 || gy >= GRID) continue;
        let px = BOARD_X + gx * CELL;
        let py = BOARD_Y + gy * CELL;
        ctx.fillStyle = valid ? PLAYER_LIGHT : PLAYER_INVALID;
        ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
        if (valid) {
          ctx.strokeStyle = PLAYER_COLOR;
          ctx.lineWidth = 2;
          ctx.strokeRect(px + 2, py + 2, CELL - 4, CELL - 4);
        } else {
          ctx.strokeStyle = 'rgba(255,60,60,0.5)';
          ctx.lineWidth = 1;
          ctx.strokeRect(px + 2, py + 2, CELL - 4, CELL - 4);
        }
      }
    }

    // Piece panel: two rows of pieces
    function drawPiecePanel() {
      ctx.fillStyle = '#111';
      ctx.fillRect(0, PANEL_Y - 6, W, PANEL_H + 10);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, PANEL_Y - 6);
      ctx.lineTo(W, PANEL_Y - 6);
      ctx.stroke();

      ctx.fillStyle = '#666';
      ctx.font = '9px Courier New';
      ctx.fillText('YOUR PIECES  [click=select  R=rotate  F=flip]', 10, PANEL_Y + 4);

      let cs = 9; // cell size for mini pieces
      let gap = 6;
      let startY = PANEL_Y + 10;
      let rowH = 52;
      let x = 10;
      let y = startY;
      let row = 0;

      for (let i = 0; i < playerPieces.length; i++) {
        let p = playerPieces[i];
        let bounds = getPieceBounds(p.cells);
        let pw = (bounds.maxX + 1) * cs + gap;

        // Wrap to next row
        if (x + pw > W - 10 && x > 20) {
          row++;
          x = 10;
          y = startY + row * rowH;
        }

        let selected = (i === selectedPieceIdx && !p.used);
        if (selected) {
          let bw = (bounds.maxX + 1) * cs + 8;
          let bh = (bounds.maxY + 1) * cs + 8;
          ctx.fillStyle = 'rgba(68, 136, 255, 0.15)';
          ctx.fillRect(x - 4, y - 4, bw, bh);
          ctx.strokeStyle = '#4488ff';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(x - 4, y - 4, bw, bh);
        }

        let color = p.used ? 'rgba(80,80,80,0.2)' : selected ? '#fff' : PLAYER_COLOR;
        for (let [cx, cy] of p.cells) {
          ctx.fillStyle = color;
          ctx.fillRect(x + cx * cs, y + cy * cs, cs - 1, cs - 1);
        }

        // Store hit area for click detection
        p._panelX = x - 4;
        p._panelY = y - 4;
        p._panelW = (bounds.maxX + 1) * cs + 8;
        p._panelH = (bounds.maxY + 1) * cs + 8;

        x += pw + 2;
      }
    }

    function getPieceBounds(cells) {
      let maxX = 0, maxY = 0;
      for (let [x, y] of cells) {
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      return { maxX, maxY };
    }

    function getPanelPieceAt(mx, my) {
      for (let i = 0; i < playerPieces.length; i++) {
        let p = playerPieces[i];
        if (p.used || !p._panelX) continue;
        if (mx >= p._panelX && mx <= p._panelX + p._panelW &&
            my >= p._panelY && my <= p._panelY + p._panelH) {
          return i;
        }
      }
      return -1;
    }

    // --- Game flow ---

    function init() {
      board = new Uint8Array(GRID * GRID);
      playerPieces = makePieceSet();
      aiPieces = makePieceSet();
      selectedPieceIdx = -1;
      currentRotation = null;
      turn = 1;
      score = 0;
      mouseGridX = -1;
      mouseGridY = -1;
      playerPassed = false;
      aiPassed = false;
      hoverValid = false;
      aiThinking = false;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      piecesLeftEl.textContent = '21';
      aiPiecesLeftEl.textContent = '21';
      turnIndicator.textContent = 'Your turn';
      turnIndicator.style.color = '#4488ff';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BLOKUS';
      overlayText.textContent = 'Click to Start';
      passBtn.disabled = true;
      draw();
    }

    function selectNextAvailable() {
      for (let i = 0; i < playerPieces.length; i++) {
        if (!playerPieces[i].used) {
          selectedPieceIdx = i;
          currentRotation = deepCopy(playerPieces[i].cells);
          return;
        }
      }
      selectedPieceIdx = -1;
      currentRotation = null;
    }

    function updateScores() {
      let ps = countSquares(1);
      let as2 = countSquares(2);
      score = ps;
      scoreEl.textContent = ps;
      aiScoreEl.textContent = as2;
      piecesLeftEl.textContent = piecesRemaining(playerPieces);
      aiPiecesLeftEl.textContent = piecesRemaining(aiPieces);
    }

    function doAiTurn() {
      if (gameState !== 'playing') return;
      aiThinking = true;
      turnIndicator.textContent = 'AI thinking...';
      turnIndicator.style.color = '#a6f';
      draw();

      setTimeout(function() {
        let move = aiMove();
        if (move) {
          placePiece(move.cells, move.ox, move.oy, 2);
          aiPieces[move.pieceIdx].used = true;
          aiPassed = false;
          updateScores();
        } else {
          aiPassed = true;
        }

        aiThinking = false;
        turn = 1;

        // Check if player can move
        if (!hasAnyMove(playerPieces, 1, PIECE_ORIENTATIONS)) {
          playerPassed = true;
          if (aiPassed) {
            endGame();
            return;
          }
          // Check if AI can still move
          if (!hasAnyMove(aiPieces, 2, PIECE_ORIENTATIONS)) {
            endGame();
            return;
          }
          turnIndicator.textContent = 'No moves - auto-passing...';
          turnIndicator.style.color = '#888';
          turn = 2;
          draw();
          setTimeout(doAiTurn, 600);
          return;
        }

        playerPassed = false;
        turnIndicator.textContent = 'Your turn';
        turnIndicator.style.color = '#4488ff';

        // Ensure a piece is selected
        if (selectedPieceIdx < 0 || playerPieces[selectedPieceIdx].used) {
          selectNextAvailable();
        }
        draw();
      }, 300);
    }

    function endGame() {
      gameState = 'over';
      passBtn.disabled = true;
      aiThinking = false;
      let ps = countSquares(1);
      let as2 = countSquares(2);

      overlay.style.display = 'flex';
      if (ps > as2) {
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = ps + ' vs ' + as2 + ' squares -- Click to play again';
      } else if (as2 > ps) {
        overlayTitle.textContent = 'AI WINS!';
        overlayText.textContent = as2 + ' vs ' + ps + ' squares -- Click to play again';
      } else {
        overlayTitle.textContent = 'TIE!';
        overlayText.textContent = ps + ' squares each -- Click to play again';
      }
      turnIndicator.textContent = 'Game over';
      turnIndicator.style.color = '#888';
      draw();
    }

    // --- Input ---

    canvas.addEventListener('mousemove', function(e) {
      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      let my = (e.clientY - rect.top) * (H / rect.height);

      let gx = Math.floor((mx - BOARD_X) / CELL);
      let gy = Math.floor((my - BOARD_Y) / CELL);

      if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && my < PANEL_Y - 6) {
        mouseGridX = gx;
        mouseGridY = gy;
      } else {
        mouseGridX = -1;
        mouseGridY = -1;
      }
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('mouseleave', function() {
      mouseGridX = -1;
      mouseGridY = -1;
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('click', function(e) {
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        passBtn.disabled = false;
        selectNextAvailable();
        draw();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState !== 'playing' || turn !== 1 || aiThinking) return;

      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      let my = (e.clientY - rect.top) * (H / rect.height);

      // Click in piece panel
      if (my >= PANEL_Y - 6) {
        let idx = getPanelPieceAt(mx, my);
        if (idx >= 0 && !playerPieces[idx].used) {
          selectedPieceIdx = idx;
          currentRotation = deepCopy(playerPieces[idx].cells);
          draw();
        }
        return;
      }

      // Click on board to place
      if (selectedPieceIdx >= 0 && currentRotation && mouseGridX >= 0 && mouseGridY >= 0) {
        if (isValidPlacement(currentRotation, mouseGridX, mouseGridY, 1)) {
          placePiece(currentRotation, mouseGridX, mouseGridY, 1);
          playerPieces[selectedPieceIdx].used = true;
          playerPassed = false;
          updateScores();

          selectedPieceIdx = -1;
          currentRotation = null;
          selectNextAvailable();

          turn = 2;
          draw();
          setTimeout(doAiTurn, 300);
        }
      }
    });

    document.addEventListener('keydown', function(e) {
      if (gameState !== 'playing' || turn !== 1 || aiThinking) return;
      if ((e.key === 'r' || e.key === 'R') && currentRotation) {
        currentRotation = rotateCW(currentRotation);
        draw();
      } else if ((e.key === 'f' || e.key === 'F') && currentRotation) {
        currentRotation = flipH(currentRotation);
        draw();
      }
    });

    passBtn.addEventListener('click', function() {
      if (gameState !== 'playing' || turn !== 1 || aiThinking) return;
      playerPassed = true;
      turn = 2;
      if (aiPassed) {
        endGame();
      } else {
        draw();
        setTimeout(doAiTurn, 300);
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

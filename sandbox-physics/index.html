<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sandbox Physics - OpenArcade</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Courier New', monospace; overflow: hidden; display: flex; flex-direction: column; align-items: center; height: 100vh; }
#topBar { width: 600px; display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: #16213e; border-bottom: 2px solid #8a4; }
#topBar a { color: #8a4; text-decoration: none; font-size: 14px; }
#topBar a:hover { text-shadow: 0 0 8px #8a4; }
#scoreBar { color: #8a4; font-size: 13px; text-shadow: 0 0 6px #8a4; }
#game { border: 2px solid #8a4; display: block; cursor: crosshair; box-shadow: 0 0 20px rgba(136,170,68,0.3); }
#overlay { position: absolute; top: 0; left: 0; width: 600px; height: 500px; background: rgba(26,26,46,0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; pointer-events: auto; }
#overlay.hidden { display: none; }
#overlay h1 { color: #8a4; font-size: 28px; text-shadow: 0 0 15px #8a4; margin-bottom: 10px; }
#overlay h2 { color: #cda; font-size: 16px; margin-bottom: 18px; font-weight: normal; }
#overlay p { color: #aab; font-size: 13px; margin-bottom: 6px; max-width: 500px; text-align: center; line-height: 1.5; }
#overlay button { margin-top: 16px; padding: 10px 30px; background: transparent; color: #8a4; border: 2px solid #8a4; font-family: 'Courier New', monospace; font-size: 16px; cursor: pointer; transition: all 0.2s; }
#overlay button:hover { background: #8a4; color: #1a1a2e; box-shadow: 0 0 15px #8a4; }
#toolbar { width: 600px; display: flex; justify-content: center; gap: 4px; padding: 5px; background: #16213e; border-top: 2px solid #8a4; flex-wrap: wrap; }
.tool-btn { padding: 4px 10px; background: transparent; color: #8a4; border: 1px solid #8a4; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer; transition: all 0.15s; }
.tool-btn:hover, .tool-btn.active { background: #8a4; color: #1a1a2e; }
#statusBar { width: 600px; padding: 4px 10px; background: #0f0f23; color: #8a4; font-size: 11px; text-align: center; border-top: 1px solid #333; }
#gameWrap { position: relative; }
</style>
</head>
<body>
<div id="topBar">
  <a href="../index.html">&larr; OpenArcade</a>
  <span id="scoreBar">P1: 0 | AI: 0 | Challenge 0/5</span>
</div>
<div id="gameWrap">
  <canvas id="game" width="600" height="500"></canvas>
  <div id="overlay">
    <h1>SANDBOX PHYSICS</h1>
    <h2>Build Machines. Defy Gravity. Outsmart AI.</h2>
    <p>Place blocks, wheels, springs, rockets, hinges &amp; ropes to build contraptions. Complete 5 physics challenges against an AI opponent.</p>
    <p>Click to place objects. Drag between objects to connect with hinges/ropes. Build phase (30s) then watch physics play out!</p>
    <button id="startBtn">START GAME</button>
  </div>
</div>
<div id="toolbar">
  <span class="tool-btn active" data-tool="wood">Wood</span>
  <span class="tool-btn" data-tool="metal">Metal</span>
  <span class="tool-btn" data-tool="rubber">Rubber</span>
  <span class="tool-btn" data-tool="wheel">Wheel</span>
  <span class="tool-btn" data-tool="spring">Spring</span>
  <span class="tool-btn" data-tool="rocket">Rocket</span>
  <span class="tool-btn" data-tool="hinge">Hinge</span>
  <span class="tool-btn" data-tool="rope">Rope</span>
  <span class="tool-btn" data-tool="delete" style="border-color:#f55;color:#f55;">Delete</span>
</div>
<div id="statusBar">Select a tool and click in your build zone to place objects</div>
<script>
// ========== GAME STATE ==========
let gameState = 'menu';
let score = { p1: 0, ai: 0 };
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 600, H = 500;
const HALF = W / 2;
const GRAVITY = 0.35;
const FRICTION = 0.985;
const BOUNCE = 0.4;
const DT = 1;
let currentTool = 'wood';
let challengeIndex = 0;
let buildTimer = 30;
let testTimer = 0;
let phase = 'build'; // build, test, results
let timerInterval = null;
let p1Objects = [];
let aiObjects = [];
let p1Connections = [];
let aiConnections = [];
let dragStart = null;
let dragObj = null;
let mouseX = 0, mouseY = 0;
let testFrames = 0;
let maxTestFrames = 300;
let challengeResult = { p1: 0, ai: 0 };
let particles = [];
let showForces = false;

// ========== CHALLENGES ==========
const challenges = [
  { name: "Launch Ball to Target", desc: "Build a launcher to send the ball to the target zone", type: "launch",
    setup: (side) => ({ ball: { x: side === 'left' ? 60 : HALF + 60, y: 380, r: 8 }, target: { x: side === 'left' ? 220 : HALF + 220, y: 100, w: 50, h: 50 } }) },
  { name: "Build Tallest Tower", desc: "Stack objects as high as possible - height measured after test", type: "tower",
    setup: (side) => ({ base: { x: side === 'left' ? 150 : HALF + 150, y: 440 } }) },
  { name: "Bridge the Gap", desc: "Build a bridge so the ball rolls across the gap", type: "bridge",
    setup: (side) => ({ gap: { x: side === 'left' ? 80 : HALF + 80, w: 140 }, ball: { x: side === 'left' ? 30 : HALF + 30, y: 350, r: 8 } }) },
  { name: "Protect the Egg", desc: "Build a structure to cushion the falling egg", type: "protect",
    setup: (side) => ({ egg: { x: side === 'left' ? 150 : HALF + 150, y: 40, r: 10 }, zone: { x: side === 'left' ? 100 : HALF + 100, y: 420, w: 100, h: 30 } }) },
  { name: "Rube Goldberg", desc: "Chain reactions! Move ball from start to finish zone", type: "rube",
    setup: (side) => ({ ball: { x: side === 'left' ? 40 : HALF + 40, y: 80, r: 8 }, finish: { x: side === 'left' ? 220 : HALF + 220, y: 420, w: 50, h: 40 } }) }
];

// ========== PHYSICS OBJECTS ==========
class PhysObj {
  constructor(x, y, type, w, h) {
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.type = type;
    this.w = w || 40; this.h = h || 20;
    this.r = type === 'wheel' ? 14 : (type === 'ball' || type === 'egg') ? (h || 8) : 0;
    this.angle = 0; this.va = 0;
    this.mass = type === 'metal' ? 3 : type === 'rubber' ? 0.8 : type === 'wheel' ? 1.5 : type === 'rocket' ? 0.5 : 1;
    this.bounce = type === 'rubber' ? 0.75 : type === 'metal' ? 0.2 : BOUNCE;
    this.friction = type === 'rubber' ? 0.95 : FRICTION;
    this.fixed = false;
    this.rocketFuel = type === 'rocket' ? 120 : 0;
    this.rocketDir = -1; // up
    this.color = this.getColor();
    this.id = Math.random().toString(36).substr(2, 6);
    this.alive = true;
  }
  getColor() {
    switch(this.type) {
      case 'wood': return '#c97';
      case 'metal': return '#99a';
      case 'rubber': return '#e74';
      case 'wheel': return '#555';
      case 'spring': return '#4ce';
      case 'rocket': return '#f84';
      case 'ball': return '#ff5';
      case 'egg': return '#ffe';
      default: return '#8a4';
    }
  }
  get cx() { return this.r > 0 ? this.x : this.x + this.w/2; }
  get cy() { return this.r > 0 ? this.y : this.y + this.h/2; }
}

class Connection {
  constructor(a, b, type) {
    this.a = a; this.b = b;
    this.type = type; // hinge, rope, spring
    this.restLen = dist(a.cx, a.cy, b.cx, b.cy);
    this.stiffness = type === 'spring' ? 0.05 : type === 'rope' ? 0.3 : 0.8;
    this.damping = 0.98;
  }
}

function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }

// ========== TOOLBAR ==========
document.querySelectorAll('.tool-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTool = btn.dataset.tool;
    updateStatus();
  });
});

function updateStatus() {
  const s = document.getElementById('statusBar');
  if (phase === 'build') {
    if (currentTool === 'hinge' || currentTool === 'rope') {
      s.textContent = `Drag between two objects to connect with ${currentTool} | Time: ${buildTimer}s`;
    } else if (currentTool === 'delete') {
      s.textContent = `Click an object to delete it | Time: ${buildTimer}s`;
    } else {
      s.textContent = `Click in your zone (left half) to place ${currentTool} | Time: ${buildTimer}s`;
    }
  } else if (phase === 'test') {
    s.textContent = `Testing physics... Watch your contraption! | ${Math.ceil((maxTestFrames - testFrames) / 60)}s`;
  } else {
    s.textContent = 'Results!';
  }
}

// ========== MOUSE HANDLING ==========
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', (e) => {
  if (gameState !== 'playing' || phase !== 'build') return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  if (mx >= HALF) return; // only left side for player

  if (currentTool === 'delete') {
    // find and remove object
    for (let i = p1Objects.length - 1; i >= 0; i--) {
      const o = p1Objects[i];
      if (o.type === 'ball' || o.type === 'egg') continue; // can't delete challenge objects
      if (hitTest(o, mx, my)) {
        p1Connections = p1Connections.filter(c => c.a !== o && c.b !== o);
        p1Objects.splice(i, 1);
        break;
      }
    }
    return;
  }

  if (currentTool === 'hinge' || currentTool === 'rope' || currentTool === 'spring') {
    // start drag for connection
    for (const o of p1Objects) {
      if (hitTest(o, mx, my)) {
        dragStart = o;
        dragObj = { x: mx, y: my };
        return;
      }
    }
    return;
  }

  // Place object
  if (p1Objects.length >= 20) return; // limit
  let obj;
  if (currentTool === 'wheel') {
    obj = new PhysObj(mx, my, 'wheel', 0, 14);
  } else if (currentTool === 'spring') {
    obj = new PhysObj(mx - 5, my - 15, 'spring', 10, 30);
  } else if (currentTool === 'rocket') {
    obj = new PhysObj(mx - 8, my - 20, 'rocket', 16, 40);
  } else {
    obj = new PhysObj(mx - 20, my - 10, currentTool, 40, 20);
  }
  // clamp to left side
  if (obj.r > 0) {
    obj.x = Math.max(obj.r, Math.min(HALF - obj.r - 2, obj.x));
  } else {
    obj.x = Math.max(0, Math.min(HALF - obj.w - 2, obj.x));
  }
  obj.y = Math.max(40, Math.min(H - (obj.r > 0 ? obj.r : obj.h) - 10, obj.y));
  p1Objects.push(obj);
});

canvas.addEventListener('mouseup', (e) => {
  if (!dragStart) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  for (const o of p1Objects) {
    if (o !== dragStart && hitTest(o, mx, my)) {
      p1Connections.push(new Connection(dragStart, o, currentTool === 'spring' ? 'spring' : currentTool));
      break;
    }
  }
  dragStart = null;
  dragObj = null;
});

function hitTest(obj, mx, my) {
  if (obj.r > 0) {
    return dist(obj.x, obj.y, mx, my) < obj.r + 8;
  }
  return mx >= obj.x - 4 && mx <= obj.x + obj.w + 4 && my >= obj.y - 4 && my <= obj.y + obj.h + 4;
}

// ========== AI BUILDER ==========
function aiBuilds(ch) {
  aiObjects = aiObjects.filter(o => o.type === 'ball' || o.type === 'egg');
  aiConnections = [];
  const setup = ch.setup('right');
  const ox = HALF; // offset for right side

  switch(ch.type) {
    case 'launch': {
      // Build a catapult-like launcher: ramp + rocket
      const ramp1 = new PhysObj(ox + 40, 370, 'wood', 50, 12);
      const ramp2 = new PhysObj(ox + 50, 355, 'wood', 50, 12);
      ramp2.angle = -0.3;
      const ramp3 = new PhysObj(ox + 60, 335, 'metal', 50, 12);
      ramp3.angle = -0.4;
      const base1 = new PhysObj(ox + 30, 400, 'metal', 50, 20);
      const base2 = new PhysObj(ox + 30, 420, 'metal', 60, 20);
      const rocket1 = new PhysObj(ox + 55, 295, 'rocket', 16, 40);
      const spring1 = new PhysObj(ox + 80, 380, 'spring', 10, 30);
      aiObjects.push(base1, base2, ramp1, ramp2, ramp3, rocket1, spring1);
      aiConnections.push(new Connection(base1, ramp1, 'hinge'));
      aiConnections.push(new Connection(ramp1, ramp2, 'hinge'));
      aiConnections.push(new Connection(ramp2, ramp3, 'hinge'));
      aiConnections.push(new Connection(ramp3, rocket1, 'rope'));
      break;
    }
    case 'tower': {
      // Build a tall supported tower
      for (let i = 0; i < 7; i++) {
        const block = new PhysObj(ox + 130 + (i % 2) * 5, 430 - i * 22, i % 3 === 0 ? 'metal' : 'wood', 44, 20);
        aiObjects.push(block);
        if (i > 0) aiConnections.push(new Connection(aiObjects[aiObjects.length-2], block, 'hinge'));
      }
      // side supports
      const sup1 = new PhysObj(ox + 110, 390, 'wood', 15, 60);
      const sup2 = new PhysObj(ox + 175, 390, 'wood', 15, 60);
      aiObjects.push(sup1, sup2);
      aiConnections.push(new Connection(sup1, aiObjects[1], 'hinge'));
      aiConnections.push(new Connection(sup2, aiObjects[1], 'hinge'));
      break;
    }
    case 'bridge': {
      // Build planks across the gap with supports
      const gx = ox + 80;
      for (let i = 0; i < 5; i++) {
        const plank = new PhysObj(gx + i * 30, 395, i % 2 === 0 ? 'metal' : 'wood', 34, 10);
        aiObjects.push(plank);
        if (i > 0) aiConnections.push(new Connection(aiObjects[aiObjects.length-2], plank, 'hinge'));
      }
      // support under
      const s1 = new PhysObj(gx + 20, 410, 'metal', 40, 15);
      const s2 = new PhysObj(gx + 80, 410, 'metal', 40, 15);
      const s3 = new PhysObj(gx + 50, 420, 'metal', 50, 12);
      aiObjects.push(s1, s2, s3);
      aiConnections.push(new Connection(s1, aiObjects[1], 'rope'));
      aiConnections.push(new Connection(s2, aiObjects[3], 'rope'));
      break;
    }
    case 'protect': {
      // Build a cushion net below the egg
      const ex = ox + 120;
      const r1 = new PhysObj(ex, 350, 'rubber', 50, 15);
      const r2 = new PhysObj(ex + 20, 370, 'rubber', 50, 15);
      const r3 = new PhysObj(ex - 10, 380, 'rubber', 50, 15);
      const r4 = new PhysObj(ex + 10, 395, 'rubber', 60, 15);
      const s1 = new PhysObj(ex - 20, 320, 'spring', 10, 30);
      const s2 = new PhysObj(ex + 60, 320, 'spring', 10, 30);
      const w1 = new PhysObj(ex - 10, 410, 'metal', 80, 15);
      w1.fixed = true;
      aiObjects.push(r1, r2, r3, r4, s1, s2, w1);
      aiConnections.push(new Connection(s1, r1, 'spring'));
      aiConnections.push(new Connection(s2, r1, 'spring'));
      aiConnections.push(new Connection(r1, r2, 'rope'));
      aiConnections.push(new Connection(r2, r3, 'rope'));
      aiConnections.push(new Connection(r3, r4, 'rope'));
      break;
    }
    case 'rube': {
      // Rube Goldberg chain: ramps + springs + wheel
      const bx = ox + 20;
      const ramp1 = new PhysObj(bx + 40, 120, 'wood', 60, 10);
      ramp1.angle = 0.3;
      const ramp2 = new PhysObj(bx + 120, 200, 'wood', 60, 10);
      ramp2.angle = -0.3;
      const ramp3 = new PhysObj(bx + 40, 280, 'wood', 60, 10);
      ramp3.angle = 0.3;
      const ramp4 = new PhysObj(bx + 120, 350, 'wood', 70, 10);
      ramp4.angle = -0.2;
      const spring1 = new PhysObj(bx + 100, 160, 'spring', 10, 30);
      const spring2 = new PhysObj(bx + 30, 240, 'spring', 10, 30);
      const wh = new PhysObj(bx + 180, 400, 'wheel', 0, 14);
      aiObjects.push(ramp1, ramp2, ramp3, ramp4, spring1, spring2, wh);
      aiConnections.push(new Connection(ramp1, spring1, 'hinge'));
      aiConnections.push(new Connection(ramp2, spring2, 'hinge'));
      break;
    }
  }
}

// ========== PHYSICS ENGINE ==========
function stepPhysics(objects, connections, sideMin, sideMax) {
  // Apply gravity and update
  for (const o of objects) {
    if (o.fixed) continue;
    o.vy += GRAVITY * o.mass;
    // Rockets
    if (o.type === 'rocket' && o.rocketFuel > 0) {
      o.vy -= 1.2;
      o.rocketFuel--;
      // particles
      particles.push({ x: o.x + 8, y: o.y + 40, vx: (Math.random()-0.5)*2, vy: Math.random()*3+1, life: 20, color: Math.random() > 0.5 ? '#f84' : '#ff5' });
    }
    o.vx *= o.friction;
    o.vy *= o.friction;
    o.x += o.vx * DT;
    o.y += o.vy * DT;
    if (o.r > 0) {
      o.va *= 0.98;
      o.angle += o.va;
    }

    // Bounds
    const floor = H - 10;
    if (o.r > 0) {
      if (o.y + o.r > floor) { o.y = floor - o.r; o.vy *= -o.bounce; o.vx *= 0.92; }
      if (o.x - o.r < sideMin) { o.x = sideMin + o.r; o.vx *= -o.bounce; }
      if (o.x + o.r > sideMax) { o.x = sideMax - o.r; o.vx *= -o.bounce; }
      if (o.y - o.r < 0) { o.y = o.r; o.vy *= -o.bounce; }
    } else {
      if (o.y + o.h > floor) { o.y = floor - o.h; o.vy *= -o.bounce; o.vx *= 0.92; }
      if (o.x < sideMin) { o.x = sideMin; o.vx *= -o.bounce; }
      if (o.x + o.w > sideMax) { o.x = sideMax - o.w; o.vx *= -o.bounce; }
      if (o.y < 0) { o.y = 0; o.vy *= -o.bounce; }
    }
  }

  // Bridge gap collision for bridge challenge
  if (challenges[challengeIndex].type === 'bridge') {
    const gapSetup = challenges[challengeIndex].setup(sideMin < HALF ? 'left' : 'right');
    const gx = gapSetup.gap.x;
    const gw = gapSetup.gap.w;
    for (const o of objects) {
      if (o.fixed) continue;
      const cx = o.r > 0 ? o.x : o.x + o.w/2;
      const cy = o.r > 0 ? o.y : o.y + o.h/2;
      const bottom = o.r > 0 ? o.y + o.r : o.y + o.h;
      // If object is in the gap area, the floor is lower (gap)
      if (cx > gx && cx < gx + gw) {
        // gap - floor is at H (no floor support here, objects fall into gap unless bridged)
        // re-set floor boundary lower
        if (bottom > H - 10) {
          // fell through gap - mark as lost
        }
      } else {
        // normal floor ledge at y=400
        if (bottom > 400 && cy < 405) {
          if (o.r > 0) { o.y = 400 - o.r; o.vy *= -o.bounce; o.vx *= 0.92; }
          else { o.y = 400 - o.h; o.vy *= -o.bounce; o.vx *= 0.92; }
        }
      }
    }
  }

  // Connections (constraints)
  for (const c of connections) {
    const a = c.a, b = c.b;
    if (!a.alive || !b.alive) continue;
    const dx = b.cx - a.cx;
    const dy = b.cy - a.cy;
    const d = Math.sqrt(dx*dx + dy*dy) || 1;
    const diff = (d - c.restLen) / d;
    const nx = dx * diff * c.stiffness;
    const ny = dy * diff * c.stiffness;
    if (!a.fixed) { a.x += nx; a.y += ny; a.vx += nx * 0.5; a.vy += ny * 0.5; }
    if (!b.fixed) { b.x -= nx; b.y -= ny; b.vx -= nx * 0.5; b.vy -= ny * 0.5; }
  }

  // Collisions between objects
  for (let i = 0; i < objects.length; i++) {
    for (let j = i + 1; j < objects.length; j++) {
      const a = objects[i], b = objects[j];
      if (a.fixed && b.fixed) continue;
      resolveCollision(a, b);
    }
  }
}

function resolveCollision(a, b) {
  // AABB vs AABB for rect objects, circle vs circle/rect
  const acx = a.cx, acy = a.cy;
  const bcx = b.cx, bcy = b.cy;

  if (a.r > 0 && b.r > 0) {
    // Circle vs circle
    const d = dist(a.x, a.y, b.x, b.y);
    const minD = a.r + b.r;
    if (d < minD && d > 0) {
      const nx = (b.x - a.x) / d;
      const ny = (b.y - a.y) / d;
      const overlap = minD - d;
      const totalMass = a.mass + b.mass;
      if (!a.fixed) { a.x -= nx * overlap * (b.mass/totalMass); a.y -= ny * overlap * (b.mass/totalMass); }
      if (!b.fixed) { b.x += nx * overlap * (a.mass/totalMass); b.y += ny * overlap * (a.mass/totalMass); }
      // bounce
      const relV = (a.vx - b.vx) * nx + (a.vy - b.vy) * ny;
      if (relV > 0) {
        const bounce = Math.min(a.bounce, b.bounce);
        const imp = relV * (1 + bounce) / totalMass;
        if (!a.fixed) { a.vx -= imp * b.mass * nx; a.vy -= imp * b.mass * ny; }
        if (!b.fixed) { b.vx += imp * a.mass * nx; b.vy += imp * a.mass * ny; }
      }
    }
  } else if (a.r > 0 || b.r > 0) {
    // Circle vs rect
    const circ = a.r > 0 ? a : b;
    const rect = a.r > 0 ? b : a;
    const closestX = Math.max(rect.x, Math.min(circ.x, rect.x + rect.w));
    const closestY = Math.max(rect.y, Math.min(circ.y, rect.y + rect.h));
    const d = dist(circ.x, circ.y, closestX, closestY);
    if (d < circ.r && d > 0) {
      const nx = (circ.x - closestX) / d;
      const ny = (circ.y - closestY) / d;
      const overlap = circ.r - d;
      if (!circ.fixed) { circ.x += nx * overlap * 0.7; circ.y += ny * overlap * 0.7; }
      if (!rect.fixed) { rect.x -= nx * overlap * 0.3; rect.y -= ny * overlap * 0.3; }
      const relV = circ.vx * nx + circ.vy * ny;
      if (relV < 0) {
        const bounce = Math.min(circ.bounce, rect.bounce);
        if (!circ.fixed) { circ.vx -= nx * relV * (1 + bounce); circ.vy -= ny * relV * (1 + bounce); }
        if (!rect.fixed) { rect.vx += nx * relV * 0.3; rect.vy += ny * relV * 0.3; }
        // wheel rolling
        if (circ.type === 'wheel') circ.va += (circ.vx * ny - circ.vy * nx) * 0.02;
      }
    }
  } else {
    // Rect vs rect AABB
    const overlapX = Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x);
    const overlapY = Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y);
    if (overlapX > 0 && overlapY > 0) {
      if (overlapX < overlapY) {
        const sign = acx < bcx ? -1 : 1;
        if (!a.fixed) a.x += sign * overlapX * 0.5;
        if (!b.fixed) b.x -= sign * overlapX * 0.5;
        const relV = a.vx - b.vx;
        const bounce = Math.min(a.bounce, b.bounce);
        if (!a.fixed) a.vx -= relV * (1+bounce) * 0.5;
        if (!b.fixed) b.vx += relV * (1+bounce) * 0.5;
      } else {
        const sign = acy < bcy ? -1 : 1;
        if (!a.fixed) a.y += sign * overlapY * 0.5;
        if (!b.fixed) b.y -= sign * overlapY * 0.5;
        const relV = a.vy - b.vy;
        const bounce = Math.min(a.bounce, b.bounce);
        if (!a.fixed) a.vy -= relV * (1+bounce) * 0.5;
        if (!b.fixed) b.vy += relV * (1+bounce) * 0.5;
      }
    }
  }
}

// ========== SCORING ==========
function evaluateChallenge() {
  const ch = challenges[challengeIndex];
  let s1 = 0, s2 = 0;

  switch(ch.type) {
    case 'launch': {
      // How close ball is to target
      const t1 = ch.setup('left');
      const t2 = ch.setup('right');
      const ball1 = p1Objects.find(o => o.type === 'ball');
      const ball2 = aiObjects.find(o => o.type === 'ball');
      if (ball1) {
        const d1 = dist(ball1.x, ball1.y, t1.target.x + t1.target.w/2, t1.target.y + t1.target.h/2);
        s1 = Math.max(0, 100 - d1 * 0.5);
        if (d1 < 40) s1 = 100;
      }
      if (ball2) {
        const d2 = dist(ball2.x, ball2.y, t2.target.x + t2.target.w/2, t2.target.y + t2.target.h/2);
        s2 = Math.max(0, 100 - d2 * 0.5);
        if (d2 < 40) s2 = 100;
      }
      break;
    }
    case 'tower': {
      // Highest point of any object
      let minY1 = H, minY2 = H;
      for (const o of p1Objects) {
        if (o.type === 'ball' || o.type === 'egg') continue;
        const top = o.r > 0 ? o.y - o.r : o.y;
        if (top < minY1) minY1 = top;
      }
      for (const o of aiObjects) {
        if (o.type === 'ball' || o.type === 'egg') continue;
        const top = o.r > 0 ? o.y - o.r : o.y;
        if (top < minY2) minY2 = top;
      }
      s1 = Math.max(0, (440 - minY1) * 0.4);
      s2 = Math.max(0, (440 - minY2) * 0.4);
      break;
    }
    case 'bridge': {
      // Did ball make it across (x position)
      const ball1 = p1Objects.find(o => o.type === 'ball');
      const ball2 = aiObjects.find(o => o.type === 'ball');
      if (ball1) {
        const sx = challenges[challengeIndex].setup('left');
        s1 = Math.max(0, (ball1.x - sx.ball.x) * 0.6);
        if (ball1.y > H - 20) s1 *= 0.2; // fell
      }
      if (ball2) {
        const sx = challenges[challengeIndex].setup('right');
        s2 = Math.max(0, (ball2.x - sx.ball.x) * 0.6);
        if (ball2.y > H - 20) s2 *= 0.2;
      }
      break;
    }
    case 'protect': {
      // Egg intact (low velocity) and in zone
      const egg1 = p1Objects.find(o => o.type === 'egg');
      const egg2 = aiObjects.find(o => o.type === 'egg');
      if (egg1) {
        const speed1 = Math.sqrt(egg1.vx**2 + egg1.vy**2);
        s1 = Math.max(0, 100 - speed1 * 10);
        const setup = ch.setup('left');
        if (egg1.x > setup.zone.x && egg1.x < setup.zone.x + setup.zone.w) s1 += 20;
        if (egg1.y > H - 50) s1 *= 0.5; // hit floor hard
      }
      if (egg2) {
        const speed2 = Math.sqrt(egg2.vx**2 + egg2.vy**2);
        s2 = Math.max(0, 100 - speed2 * 10);
        const setup = ch.setup('right');
        if (egg2.x > setup.zone.x && egg2.x < setup.zone.x + setup.zone.w) s2 += 20;
        if (egg2.y > H - 50) s2 *= 0.5;
      }
      break;
    }
    case 'rube': {
      // Ball proximity to finish
      const ball1 = p1Objects.find(o => o.type === 'ball');
      const ball2 = aiObjects.find(o => o.type === 'ball');
      if (ball1) {
        const f = ch.setup('left').finish;
        const d = dist(ball1.x, ball1.y, f.x + f.w/2, f.y + f.h/2);
        s1 = Math.max(0, 100 - d * 0.3);
        if (d < 35) s1 = 100;
      }
      if (ball2) {
        const f = ch.setup('right').finish;
        const d = dist(ball2.x, ball2.y, f.x + f.w/2, f.y + f.h/2);
        s2 = Math.max(0, 100 - d * 0.3);
        if (d < 35) s2 = 100;
      }
      break;
    }
  }
  return { p1: Math.round(Math.min(100, Math.max(0, s1))), ai: Math.round(Math.min(100, Math.max(0, s2))) };
}

// ========== GAME FLOW ==========
function startGame() {
  gameState = 'playing';
  score = { p1: 0, ai: 0 };
  challengeIndex = 0;
  document.getElementById('overlay').classList.add('hidden');
  startChallenge();
}

function startChallenge() {
  phase = 'build';
  buildTimer = 30;
  testFrames = 0;
  p1Objects = [];
  aiObjects = [];
  p1Connections = [];
  aiConnections = [];
  particles = [];

  const ch = challenges[challengeIndex];

  // Place challenge objects
  if (ch.type === 'launch' || ch.type === 'bridge' || ch.type === 'rube') {
    const s1 = ch.setup('left');
    const s2 = ch.setup('right');
    const ball1 = new PhysObj(s1.ball.x, s1.ball.y, 'ball', 0, s1.ball.r);
    ball1.fixed = true;
    const ball2 = new PhysObj(s2.ball.x, s2.ball.y, 'ball', 0, s2.ball.r);
    ball2.fixed = true;
    p1Objects.push(ball1);
    aiObjects.push(ball2);
  }
  if (ch.type === 'protect') {
    const s1 = ch.setup('left');
    const s2 = ch.setup('right');
    const egg1 = new PhysObj(s1.egg.x, s1.egg.y, 'egg', 0, s1.egg.r);
    egg1.fixed = true;
    const egg2 = new PhysObj(s2.egg.x, s2.egg.y, 'egg', 0, s2.egg.r);
    egg2.fixed = true;
    p1Objects.push(egg1);
    aiObjects.push(egg2);
  }

  // AI builds
  aiBuilds(ch);

  // Build timer
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (phase === 'build') {
      buildTimer--;
      updateStatus();
      if (buildTimer <= 0) {
        startTest();
      }
    }
  }, 1000);

  updateScoreBar();
  updateStatus();
}

function startTest() {
  phase = 'test';
  testFrames = 0;
  clearInterval(timerInterval);

  // Unfix challenge objects (balls, eggs) so physics applies
  for (const o of p1Objects) { if (o.type === 'ball' || o.type === 'egg') o.fixed = false; }
  for (const o of aiObjects) { if (o.type === 'ball' || o.type === 'egg') o.fixed = false; }

  // Give ball initial push for bridge
  if (challenges[challengeIndex].type === 'bridge') {
    const b1 = p1Objects.find(o => o.type === 'ball');
    const b2 = aiObjects.find(o => o.type === 'ball');
    if (b1) b1.vx = 2;
    if (b2) b2.vx = 2;
  }

  updateStatus();
}

function endTest() {
  phase = 'results';
  challengeResult = evaluateChallenge();
  score.p1 += challengeResult.p1;
  score.ai += challengeResult.ai;
  updateScoreBar();

  setTimeout(() => {
    challengeIndex++;
    if (challengeIndex >= challenges.length) {
      showFinalResults();
    } else {
      startChallenge();
    }
  }, 2500);
}

function showFinalResults() {
  gameState = 'menu';
  const ov = document.getElementById('overlay');
  ov.classList.remove('hidden');
  const winner = score.p1 > score.ai ? 'YOU WIN!' : score.p1 < score.ai ? 'AI WINS!' : 'TIE!';
  ov.innerHTML = `
    <h1>${winner}</h1>
    <h2>Final Score: You ${score.p1} - AI ${score.ai}</h2>
    <p>5 challenges completed. ${score.p1 > score.ai ? 'Your engineering skills prevailed!' : score.p1 < score.ai ? 'The AI built better contraptions this time.' : 'Perfectly matched builders!'}</p>
    <button id="startBtn">PLAY AGAIN</button>
  `;
  document.getElementById('startBtn').addEventListener('click', startGame);
}

function updateScoreBar() {
  document.getElementById('scoreBar').textContent = `P1: ${score.p1} | AI: ${score.ai} | Challenge ${challengeIndex + 1}/5`;
}

// ========== RENDERING ==========
function drawObj(o) {
  ctx.save();
  if (o.r > 0) {
    // Circle object (wheel, ball, egg)
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
    ctx.fillStyle = o.color;
    if (o.type === 'egg') {
      ctx.fillStyle = '#ffe8c0';
      ctx.fill();
      ctx.strokeStyle = '#dda';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      // crack lines
      ctx.beginPath();
      ctx.moveTo(o.x - 3, o.y - 4);
      ctx.lineTo(o.x, o.y);
      ctx.lineTo(o.x + 2, o.y - 3);
      ctx.strokeStyle = '#bb9';
      ctx.lineWidth = 0.8;
      ctx.stroke();
    } else {
      ctx.fill();
      ctx.strokeStyle = '#fff3';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    if (o.type === 'wheel') {
      // spokes
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const a = o.angle + i * Math.PI / 2;
        ctx.moveTo(o.x, o.y);
        ctx.lineTo(o.x + Math.cos(a) * o.r * 0.8, o.y + Math.sin(a) * o.r * 0.8);
      }
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.stroke();
      // tire
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    if (o.type === 'ball') {
      ctx.shadowColor = '#ff5';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = '#ff8';
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  } else {
    // Rectangle object
    ctx.translate(o.x + o.w/2, o.y + o.h/2);
    ctx.rotate(o.angle);
    ctx.fillStyle = o.color;

    if (o.type === 'rocket') {
      // Rocket body
      ctx.fillStyle = '#f84';
      ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h);
      // Nose cone
      ctx.beginPath();
      ctx.moveTo(-o.w/2, -o.h/2);
      ctx.lineTo(0, -o.h/2 - 8);
      ctx.lineTo(o.w/2, -o.h/2);
      ctx.fillStyle = '#f55';
      ctx.fill();
      // Fins
      ctx.fillStyle = '#c44';
      ctx.fillRect(-o.w/2 - 4, o.h/2 - 8, 4, 8);
      ctx.fillRect(o.w/2, o.h/2 - 8, 4, 8);
      // fuel indicator
      if (o.rocketFuel > 0) {
        ctx.fillStyle = '#ff0';
        ctx.fillRect(-o.w/4, o.h/2 - 2, o.w/2, 2);
      }
    } else if (o.type === 'spring') {
      // Spring coils
      ctx.strokeStyle = '#4ce';
      ctx.lineWidth = 2;
      ctx.beginPath();
      const coils = 5;
      for (let i = 0; i <= coils; i++) {
        const t = i / coils;
        const sx = (i % 2 === 0 ? -1 : 1) * o.w * 0.4;
        ctx.lineTo(sx, -o.h/2 + t * o.h);
      }
      ctx.stroke();
      // end caps
      ctx.fillStyle = '#3ab';
      ctx.fillRect(-o.w/2, -o.h/2, o.w, 3);
      ctx.fillRect(-o.w/2, o.h/2 - 3, o.w, 3);
    } else {
      ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h);
      // detail lines
      ctx.strokeStyle = '#0003';
      ctx.lineWidth = 1;
      if (o.type === 'wood') {
        // wood grain
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(-o.w/2, -o.h/2 + (i+1) * o.h/4);
          ctx.lineTo(o.w/2, -o.h/2 + (i+1) * o.h/4 + 2);
          ctx.stroke();
        }
      } else if (o.type === 'metal') {
        // rivets
        ctx.fillStyle = '#bbc';
        ctx.beginPath(); ctx.arc(-o.w/3, 0, 2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(o.w/3, 0, 2, 0, Math.PI*2); ctx.fill();
      } else if (o.type === 'rubber') {
        // stipple
        ctx.fillStyle = '#c63';
        for (let i = 0; i < 4; i++) {
          ctx.beginPath();
          ctx.arc(-o.w/3 + i * o.w/4, (i%2-0.5)*o.h/3, 1.5, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.strokeStyle = '#fff2';
      ctx.lineWidth = 1;
      ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h);
    }
  }
  ctx.restore();
}

function drawConnection(c) {
  ctx.save();
  const ax = c.a.cx, ay = c.a.cy;
  const bx = c.b.cx, by = c.b.cy;

  if (c.type === 'hinge') {
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();
    ctx.setLineDash([]);
    // hinge point
    const mx = (ax+bx)/2, my = (ay+by)/2;
    ctx.beginPath();
    ctx.arc(mx, my, 4, 0, Math.PI*2);
    ctx.fillStyle = '#ccc';
    ctx.fill();
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.stroke();
  } else if (c.type === 'rope') {
    ctx.strokeStyle = '#a86';
    ctx.lineWidth = 2;
    // slightly curved rope
    const mx = (ax+bx)/2;
    const my = (ay+by)/2 + 10;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.quadraticCurveTo(mx, my, bx, by);
    ctx.stroke();
  } else if (c.type === 'spring') {
    ctx.strokeStyle = '#4ce';
    ctx.lineWidth = 2;
    const dx = bx - ax, dy = by - ay;
    const len = Math.sqrt(dx*dx + dy*dy) || 1;
    const nx = dx/len, ny = dy/len;
    const px = -ny, py = nx;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    const segs = 8;
    for (let i = 1; i < segs; i++) {
      const t = i / segs;
      const sx = ax + dx * t + px * Math.sin(i * Math.PI) * 6;
      const sy = ay + dy * t + py * Math.sin(i * Math.PI) * 6;
      ctx.lineTo(sx, sy);
    }
    ctx.lineTo(bx, by);
    ctx.stroke();
  }
  ctx.restore();
}

function drawChallenge() {
  const ch = challenges[challengeIndex];

  // Left side setup
  drawChallengeSetup(ch, 'left', 0);
  // Right side setup
  drawChallengeSetup(ch, 'right', 0);
}

function drawChallengeSetup(ch, side, ox) {
  const setup = ch.setup(side);
  ctx.save();

  if (ch.type === 'launch' && setup.target) {
    // Target zone
    ctx.fillStyle = '#8a422';
    ctx.shadowColor = '#8a4';
    ctx.shadowBlur = 10;
    ctx.fillStyle = 'rgba(136,170,68,0.25)';
    ctx.fillRect(setup.target.x, setup.target.y, setup.target.w, setup.target.h);
    ctx.strokeStyle = '#8a4';
    ctx.lineWidth = 2;
    ctx.strokeRect(setup.target.x, setup.target.y, setup.target.w, setup.target.h);
    ctx.shadowBlur = 0;
    // bullseye
    ctx.beginPath();
    ctx.arc(setup.target.x + setup.target.w/2, setup.target.y + setup.target.h/2, 10, 0, Math.PI*2);
    ctx.strokeStyle = '#f55';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(setup.target.x + setup.target.w/2, setup.target.y + setup.target.h/2, 4, 0, Math.PI*2);
    ctx.fillStyle = '#f55';
    ctx.fill();
  }

  if (ch.type === 'bridge' && setup.gap) {
    // Draw gap (hole in ground)
    const gx = setup.gap.x;
    const gw = setup.gap.w;
    const sideMin = side === 'left' ? 0 : HALF;
    const sideMax = side === 'left' ? HALF : W;
    // Left ledge
    ctx.fillStyle = '#543';
    ctx.fillRect(sideMin, 400, gx - sideMin, H - 400);
    // Right ledge
    ctx.fillRect(gx + gw, 400, sideMax - (gx + gw), H - 400);
    // Gap void
    ctx.fillStyle = '#0a0a1e';
    ctx.fillRect(gx, 400, gw, H - 400);
    // edge lines
    ctx.strokeStyle = '#765';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(gx, 400); ctx.lineTo(gx, H);
    ctx.moveTo(gx+gw, 400); ctx.lineTo(gx+gw, H);
    ctx.stroke();
    // arrow showing direction
    ctx.fillStyle = '#8a4';
    ctx.font = '10px Courier New';
    ctx.fillText('→', gx + gw + 5, 395);
  }

  if (ch.type === 'protect' && setup.zone) {
    // Safe zone
    ctx.fillStyle = 'rgba(68,204,136,0.2)';
    ctx.fillRect(setup.zone.x, setup.zone.y, setup.zone.w, setup.zone.h);
    ctx.strokeStyle = '#4c8';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4,3]);
    ctx.strokeRect(setup.zone.x, setup.zone.y, setup.zone.w, setup.zone.h);
    ctx.setLineDash([]);
    // arrow pointing down
    ctx.fillStyle = '#fa5';
    ctx.font = '14px Courier New';
    ctx.fillText('↓', setup.egg.x - 4, setup.egg.y + 30);
  }

  if (ch.type === 'rube' && setup.finish) {
    // Finish zone
    ctx.fillStyle = 'rgba(136,170,68,0.25)';
    ctx.fillRect(setup.finish.x, setup.finish.y, setup.finish.w, setup.finish.h);
    ctx.strokeStyle = '#8a4';
    ctx.lineWidth = 2;
    ctx.strokeRect(setup.finish.x, setup.finish.y, setup.finish.w, setup.finish.h);
    ctx.fillStyle = '#8a4';
    ctx.font = '10px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('FINISH', setup.finish.x + setup.finish.w/2, setup.finish.y + setup.finish.h/2 + 4);
    ctx.textAlign = 'left';
  }

  if (ch.type === 'tower' && setup.base) {
    // Ground line with height markers
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.setLineDash([2,4]);
    for (let h = 400; h > 50; h -= 50) {
      ctx.beginPath();
      const sideMin = side === 'left' ? 0 : HALF;
      ctx.moveTo(sideMin + 5, h);
      ctx.lineTo(sideMin + 15, h);
      ctx.stroke();
      ctx.fillStyle = '#555';
      ctx.font = '8px Courier New';
      ctx.fillText(`${440 - h}`, sideMin + 2, h - 2);
    }
    ctx.setLineDash([]);
  }

  ctx.restore();
}

function render() {
  // Background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  // Grid pattern
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 20) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += 20) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Divider line
  ctx.strokeStyle = '#8a4';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(HALF, 0);
  ctx.lineTo(HALF, H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Floor
  ctx.fillStyle = '#2a2a3e';
  if (challenges[challengeIndex] && challenges[challengeIndex].type !== 'bridge') {
    ctx.fillRect(0, H - 10, W, 10);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, H - 10);
    ctx.lineTo(W, H - 10);
    ctx.stroke();
  }

  // Labels
  ctx.fillStyle = '#8a4';
  ctx.font = '12px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('YOUR BUILD', HALF/2, 16);
  ctx.fillStyle = '#e74';
  ctx.fillText('AI BUILD', HALF + HALF/2, 16);
  ctx.textAlign = 'left';

  // Build zone highlight during build phase
  if (phase === 'build') {
    ctx.fillStyle = 'rgba(136,170,68,0.04)';
    ctx.fillRect(0, 20, HALF - 1, H - 30);
    ctx.fillStyle = 'rgba(231,68,68,0.04)';
    ctx.fillRect(HALF + 1, 20, HALF - 1, H - 30);
  }

  // Draw challenge setup
  if (challenges[challengeIndex]) {
    drawChallenge();
  }

  // Draw connections
  for (const c of p1Connections) drawConnection(c);
  for (const c of aiConnections) drawConnection(c);

  // Draw objects
  for (const o of p1Objects) drawObj(o);
  for (const o of aiObjects) drawObj(o);

  // Draw drag line for connections
  if (dragStart && dragObj) {
    ctx.strokeStyle = currentTool === 'spring' ? '#4ce' : currentTool === 'rope' ? '#a86' : '#aaa';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(dragStart.cx, dragStart.cy);
    ctx.lineTo(mouseX, mouseY);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Particles
  ctx.save();
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.life--;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / 20;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // Timer display
  if (phase === 'build') {
    ctx.fillStyle = buildTimer <= 5 ? '#f55' : '#8a4';
    ctx.font = 'bold 20px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`BUILD: ${buildTimer}s`, W/2, 44);
    ctx.textAlign = 'left';
  } else if (phase === 'test') {
    ctx.fillStyle = '#ff5';
    ctx.font = 'bold 20px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('TESTING...', W/2, 44);
    ctx.textAlign = 'left';
  }

  // Challenge name
  if (challenges[challengeIndex]) {
    ctx.fillStyle = '#cda';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(challenges[challengeIndex].name.toUpperCase(), W/2, 62);
    ctx.textAlign = 'left';
  }

  // Results overlay
  if (phase === 'results') {
    ctx.fillStyle = 'rgba(26,26,46,0.7)';
    ctx.fillRect(W/4, H/2 - 50, W/2, 100);
    ctx.strokeStyle = '#8a4';
    ctx.lineWidth = 2;
    ctx.strokeRect(W/4, H/2 - 50, W/2, 100);

    ctx.fillStyle = '#8a4';
    ctx.font = 'bold 16px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('CHALLENGE RESULTS', W/2, H/2 - 28);

    ctx.fillStyle = challengeResult.p1 >= challengeResult.ai ? '#8a4' : '#aaa';
    ctx.font = '14px Courier New';
    ctx.fillText(`You: +${challengeResult.p1}pts`, W/2, H/2);

    ctx.fillStyle = challengeResult.ai >= challengeResult.p1 ? '#e74' : '#aaa';
    ctx.fillText(`AI: +${challengeResult.ai}pts`, W/2, H/2 + 22);

    const winner = challengeResult.p1 > challengeResult.ai ? 'You win this round!' : challengeResult.ai > challengeResult.p1 ? 'AI wins this round!' : 'Tie!';
    ctx.fillStyle = '#ff5';
    ctx.font = '11px Courier New';
    ctx.fillText(winner, W/2, H/2 + 42);
    ctx.textAlign = 'left';
  }

  // Ghost preview during build
  if (phase === 'build' && mouseX < HALF && mouseX > 0 && mouseY > 20 && mouseY < H - 10) {
    if (currentTool !== 'hinge' && currentTool !== 'rope' && currentTool !== 'spring' && currentTool !== 'delete') {
      ctx.globalAlpha = 0.35;
      if (currentTool === 'wheel') {
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#555';
        ctx.fill();
      } else if (currentTool === 'rocket') {
        ctx.fillStyle = '#f84';
        ctx.fillRect(mouseX - 8, mouseY - 20, 16, 40);
      } else {
        const colors = { wood: '#c97', metal: '#99a', rubber: '#e74' };
        ctx.fillStyle = colors[currentTool] || '#8a4';
        ctx.fillRect(mouseX - 20, mouseY - 10, 40, 20);
      }
      ctx.globalAlpha = 1;
    }
  }
}

// ========== GAME LOOP ==========
function gameLoop() {
  if (gameState === 'playing') {
    if (phase === 'test') {
      // Step physics
      stepPhysics(p1Objects, p1Connections, 0, HALF);
      stepPhysics(aiObjects, aiConnections, HALF, W);
      testFrames++;
      updateStatus();
      if (testFrames >= maxTestFrames) {
        endTest();
      }
    }
  }
  render();
  requestAnimationFrame(gameLoop);
}

// ========== START ==========
document.getElementById('startBtn').addEventListener('click', startGame);
gameLoop();

// ========== RECORDER (OpenArcade standard) ==========
try {
  const rs = document.createElement('script');
  rs.src = '../recorder.js';
  document.head.appendChild(rs);
} catch(e) {}
</script>
</body>
</html>

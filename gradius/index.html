<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gradius</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 512px;
    }
    .back { color: #8ef; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 238, 255, 0.4); }
    h1 { color: #8ef; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 238, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 512px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8ef; }
    canvas {
      border: 2px solid #8ef;
      box-shadow: 0 0 20px rgba(136, 238, 255, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8ef;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>GRADIUS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="512" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:512px;height:400px;">
      <h2 id="overlayTitle">GRADIUS</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;
    let lives;
    let player;
    let bullets, enemyBullets, enemies, particles, capsules, options;
    let keys = {};
    let tick, scrollX;
    let powerBar, powerIndex; // power-up selection bar
    let speedLevel, hasMissile, hasDouble, hasLaser, shieldHP;
    let lastFireTick, fireInterval;
    let terrainTop, terrainBot; // scrolling terrain
    let bossActive, boss;
    let waveTimer, waveNum, enemySpawnTimer;
    let starField;

    // Power-up bar: Speed Up, Missile, Double, Laser, Option, Shield
    const POWER_NAMES = ['SPEED', 'MISSILE', 'DOUBLE', 'LASER', 'OPTION', 'SHIELD'];
    const POWER_COLORS = ['#fff', '#f80', '#8ef', '#f44', '#fa0', '#4f4'];
    const MAX_OPTIONS = 4;
    const MAX_SPEED = 5;

    // Terrain generation
    function generateTerrain() {
      terrainTop = [];
      terrainBot = [];
      for (let i = 0; i < 200; i++) {
        terrainTop.push(0);
        terrainBot.push(0);
      }
      // Generate varied terrain with smooth hills
      let topH = 0, botH = 0;
      for (let i = 20; i < 200; i++) {
        topH += (Math.random() - 0.52) * 3;
        topH = Math.max(0, Math.min(60, topH));
        botH += (Math.random() - 0.52) * 3;
        botH = Math.max(0, Math.min(60, botH));
        terrainTop[i] = topH;
        terrainBot[i] = botH;
      }
    }

    function createStarField() {
      starField = [];
      for (let i = 0; i < 80; i++) {
        starField.push({
          x: Math.random() * W,
          y: Math.random() * H,
          speed: 0.3 + Math.random() * 1.5,
          size: Math.random() > 0.7 ? 2 : 1,
          brightness: 0.3 + Math.random() * 0.7
        });
      }
    }

    function init() {
      score = 0;
      lives = 3;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GRADIUS';
      overlayText.textContent = 'Arrows: move | Space: fire | Shift: power-up';
      player = { x: 60, y: H / 2, w: 28, h: 14, invincible: 0 };
      bullets = [];
      enemyBullets = [];
      enemies = [];
      particles = [];
      capsules = [];
      options = [];
      keys = {};
      tick = 0;
      scrollX = 0;
      powerIndex = 0;
      speedLevel = 0;
      hasMissile = false;
      hasDouble = false;
      hasLaser = false;
      shieldHP = 0;
      lastFireTick = 0;
      fireInterval = 8;
      bossActive = false;
      boss = null;
      waveTimer = 0;
      waveNum = 0;
      enemySpawnTimer = 0;
      generateTerrain();
      createStarField();
      draw();
    }

    function resetPowerups() {
      powerIndex = 0;
      speedLevel = 0;
      hasMissile = false;
      hasDouble = false;
      hasLaser = false;
      shieldHP = 0;
      options = [];
      fireInterval = 8;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ---- UPDATE ----

    function update() {
      tick++;
      scrollX += 1.5;

      // Stars scroll
      for (const s of starField) {
        s.x -= s.speed;
        if (s.x < 0) { s.x = W; s.y = Math.random() * H; }
      }

      // Player movement
      const spd = 2 + speedLevel * 0.8;
      if (keys['ArrowUp']) player.y -= spd;
      if (keys['ArrowDown']) player.y += spd;
      if (keys['ArrowLeft']) player.x -= spd;
      if (keys['ArrowRight']) player.x += spd;
      player.x = Math.max(4, Math.min(W - player.w - 4, player.x));
      player.y = Math.max(4, Math.min(H - player.h - 4, player.y));

      // Update options (follow player with delay)
      for (let i = 0; i < options.length; i++) {
        const target = i === 0 ? player : options[i - 1];
        options[i].x += (target.x - 20 - i * 8 - options[i].x) * 0.15;
        options[i].y += (target.y - options[i].y) * 0.15;
      }

      // Auto-fire if space held
      if (keys[' '] && tick - lastFireTick >= fireInterval) {
        lastFireTick = tick;
        fireWeapons(player.x + player.w, player.y + player.h / 2);
        // Options also fire
        for (const o of options) {
          fireWeapons(o.x + 6, o.y + 4);
        }
      }

      // Invincibility timer
      if (player.invincible > 0) player.invincible--;

      // Terrain collision
      const terrIdx = Math.floor(scrollX / 16) % terrainTop.length;
      const topHeight = getTerrainHeight(terrainTop, player.x + player.w / 2);
      const botHeight = getTerrainHeight(terrainBot, player.x + player.w / 2);
      if (player.y < topHeight || player.y + player.h > H - botHeight) {
        if (player.invincible <= 0) {
          playerDeath();
          return;
        }
      }

      // Spawn enemies
      enemySpawnTimer++;
      waveTimer++;

      // Wave progression
      if (waveTimer > 600) {
        waveTimer = 0;
        waveNum++;
      }

      // Boss every 5 waves
      if (waveNum > 0 && waveNum % 5 === 0 && !bossActive && !boss) {
        spawnBoss();
      }

      spawnWaveEnemies();

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.update(e);
        e.x += e.vx;
        e.y += e.vy;

        // Enemy shoots
        if (e.shootTimer !== undefined) {
          e.shootTimer--;
          if (e.shootTimer <= 0) {
            e.shootTimer = e.shootInterval;
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            enemyBullets.push({
              x: e.x, y: e.y + e.h / 2,
              vx: (dx / dist) * 3,
              vy: (dy / dist) * 3
            });
          }
        }

        // Off-screen removal
        if (e.x < -60 || e.x > W + 60 || e.y < -60 || e.y > H + 60) {
          enemies.splice(i, 1);
        }
      }

      // Update boss
      if (boss) {
        boss.tick++;
        boss.x += Math.sin(boss.tick * 0.02) * 1;
        boss.y = H / 2 + Math.sin(boss.tick * 0.015) * 80;

        // Boss shoots
        boss.shootTimer--;
        if (boss.shootTimer <= 0) {
          boss.shootTimer = 30;
          // Spread shot
          for (let a = -2; a <= 2; a++) {
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + a * 0.2;
            enemyBullets.push({
              x: boss.x, y: boss.y + boss.h / 2,
              vx: Math.cos(angle) * 3,
              vy: Math.sin(angle) * 3
            });
          }
        }

        // Boss weak point flashing
        boss.weakFlash = Math.sin(boss.tick * 0.1) > 0;
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x > W + 10 || b.x < -10 || b.y < -10 || b.y > H + 10) {
          bullets.splice(i, 1);
          continue;
        }

        // Bullet vs enemies
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (rectCollide(b.x - 2, b.y - 2, 4, 4, e.x, e.y, e.w, e.h)) {
            e.hp--;
            if (e.hp <= 0) {
              score += e.points;
              scoreEl.textContent = score;
              if (score > best) { best = score; bestEl.textContent = best; }
              spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color);
              // Red enemies drop capsules
              if (e.dropCapsule) {
                capsules.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: -1 });
              }
              enemies.splice(j, 1);
            } else {
              spawnSpark(b.x, b.y);
            }
            if (!b.pierce) {
              bullets.splice(i, 1);
              hit = true;
            }
            break;
          }
        }
        if (hit) continue;

        // Bullet vs boss
        if (boss) {
          // Weak point: center of boss
          const wx = boss.x + boss.w * 0.3;
          const wy = boss.y + boss.h * 0.3;
          const ww = boss.w * 0.4;
          const wh = boss.h * 0.4;
          if (rectCollide(b.x - 2, b.y - 2, 4, 4, wx, wy, ww, wh)) {
            boss.hp--;
            spawnSpark(b.x, b.y);
            if (!b.pierce) bullets.splice(i, 1);
            if (boss.hp <= 0) {
              score += 500;
              scoreEl.textContent = score;
              if (score > best) { best = score; bestEl.textContent = best; }
              spawnExplosion(boss.x + boss.w / 2, boss.y + boss.h / 2, '#fd0');
              spawnExplosion(boss.x + boss.w * 0.3, boss.y + boss.h * 0.3, '#f80');
              spawnExplosion(boss.x + boss.w * 0.7, boss.y + boss.h * 0.7, '#f44');
              boss = null;
              bossActive = false;
              waveNum++;
              waveTimer = 0;
            }
          }
        }
      }

      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10) {
          enemyBullets.splice(i, 1);
          continue;
        }
        // Hit player
        if (rectCollide(b.x - 3, b.y - 3, 6, 6, player.x, player.y, player.w, player.h)) {
          enemyBullets.splice(i, 1);
          if (shieldHP > 0) {
            shieldHP--;
            spawnSpark(b.x, b.y);
          } else if (player.invincible <= 0) {
            playerDeath();
            return;
          }
        }
      }

      // Enemy collision with player
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (rectCollide(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          if (shieldHP > 0) {
            shieldHP--;
            e.hp = 0;
            score += e.points;
            scoreEl.textContent = score;
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color);
            enemies.splice(i, 1);
          } else if (player.invincible <= 0) {
            playerDeath();
            return;
          }
        }
      }

      // Boss collision with player
      if (boss && rectCollide(player.x, player.y, player.w, player.h, boss.x, boss.y, boss.w, boss.h)) {
        if (player.invincible <= 0) {
          if (shieldHP > 0) {
            shieldHP--;
          } else {
            playerDeath();
            return;
          }
        }
      }

      // Capsules
      for (let i = capsules.length - 1; i >= 0; i--) {
        const c = capsules[i];
        c.x += c.vx;
        if (c.x < -20) { capsules.splice(i, 1); continue; }
        if (rectCollide(player.x, player.y, player.w, player.h, c.x - 6, c.y - 6, 12, 12)) {
          capsules.splice(i, 1);
          powerIndex = Math.min(powerIndex + 1, POWER_NAMES.length - 1);
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vy *= 0.98;
        p.vx *= 0.98;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function fireWeapons(x, y) {
      if (hasLaser) {
        // Laser: long piercing beam
        bullets.push({ x: x, y: y, vx: 10, vy: 0, isLaser: true, pierce: true, life: 30 });
      } else if (hasDouble) {
        // Double shot: two bullets at slight angles
        bullets.push({ x: x, y: y - 4, vx: 8, vy: -0.5 });
        bullets.push({ x: x, y: y + 4, vx: 8, vy: 0.5 });
      } else {
        // Normal shot
        bullets.push({ x: x, y: y, vx: 8, vy: 0 });
      }

      if (hasMissile) {
        // Missile: drops down then seeks ground enemies
        bullets.push({ x: x, y: y + 6, vx: 3, vy: 2, isMissile: true });
      }
    }

    function activatePowerUp() {
      if (powerIndex < 0) return;
      const power = powerIndex;
      powerIndex = -1; // Reset bar after activation

      switch (power) {
        case 0: // Speed Up
          if (speedLevel < MAX_SPEED) speedLevel++;
          break;
        case 1: // Missile
          hasMissile = true;
          break;
        case 2: // Double
          hasDouble = true;
          hasLaser = false; // Double and Laser are mutually exclusive
          break;
        case 3: // Laser
          hasLaser = true;
          hasDouble = false;
          fireInterval = 10;
          break;
        case 4: // Option
          if (options.length < MAX_OPTIONS) {
            options.push({ x: player.x - 20, y: player.y });
          }
          break;
        case 5: // Shield
          shieldHP = 3;
          break;
      }
    }

    function playerDeath() {
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, '#8ef');
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
        return;
      }
      // Reset player position and power-ups
      player.x = 60;
      player.y = H / 2;
      player.invincible = 120;
      resetPowerups();
      bullets = [];
      enemyBullets = [];
    }

    // ---- ENEMY SPAWNING ----

    function spawnWaveEnemies() {
      const diff = Math.min(waveNum, 20);

      // Formation waves
      if (enemySpawnTimer % (Math.max(60 - diff * 2, 20)) === 0) {
        const type = Math.random();
        if (type < 0.3) {
          spawnFormationLine();
        } else if (type < 0.6) {
          spawnFormationSine();
        } else if (type < 0.8) {
          spawnFormationV();
        } else {
          spawnFormationCircle();
        }
      }

      // Solo enemies
      if (enemySpawnTimer % (Math.max(40 - diff, 15)) === 0) {
        spawnSoloEnemy();
      }
    }

    function makeEnemy(x, y, type) {
      const e = {
        x, y, vx: -2, vy: 0, w: 20, h: 16,
        hp: 1, points: 100, color: '#f44',
        dropCapsule: false,
        update: (e) => {},
        shootTimer: undefined
      };

      switch (type) {
        case 'grunt':
          e.color = '#88f';
          e.hp = 1;
          e.points = 50;
          e.w = 18; e.h = 14;
          e.update = (e) => { e.vx = -2.5; };
          break;
        case 'red': // Red enemies drop capsules
          e.color = '#f44';
          e.hp = 1;
          e.points = 100;
          e.dropCapsule = true;
          e.w = 20; e.h = 16;
          e.update = (e) => { e.vx = -2; };
          break;
        case 'sine':
          e.color = '#ff0';
          e.hp = 1;
          e.points = 75;
          e.w = 16; e.h = 12;
          e.phase = Math.random() * Math.PI * 2;
          e.startY = y;
          e.update = (e) => {
            e.vx = -2.5;
            e.y = e.startY + Math.sin(tick * 0.05 + e.phase) * 40;
          };
          break;
        case 'turret':
          e.color = '#f80';
          e.hp = 2;
          e.points = 150;
          e.w = 22; e.h = 18;
          e.shootTimer = 60 + Math.floor(Math.random() * 40);
          e.shootInterval = 80;
          e.update = (e) => { e.vx = -1.5; };
          break;
        case 'fast':
          e.color = '#0ff';
          e.hp = 1;
          e.points = 120;
          e.w = 14; e.h = 10;
          e.update = (e) => { e.vx = -4.5; };
          break;
        case 'heavy':
          e.color = '#c4f';
          e.hp = 4;
          e.points = 200;
          e.w = 26; e.h = 22;
          e.shootTimer = 40;
          e.shootInterval = 60;
          e.update = (e) => { e.vx = -1; };
          break;
      }
      return e;
    }

    function spawnFormationLine() {
      const y = 40 + Math.random() * (H - 80);
      const isRed = Math.random() < 0.3;
      for (let i = 0; i < 5; i++) {
        const e = makeEnemy(W + 30 + i * 30, y, isRed ? 'red' : 'grunt');
        enemies.push(e);
      }
    }

    function spawnFormationSine() {
      const baseY = H / 2;
      const isRed = Math.random() < 0.25;
      for (let i = 0; i < 6; i++) {
        const e = makeEnemy(W + 30 + i * 25, baseY, isRed ? 'red' : 'sine');
        e.phase = i * 0.5;
        e.startY = baseY;
        enemies.push(e);
      }
    }

    function spawnFormationV() {
      const cy = H / 2 + (Math.random() - 0.5) * 100;
      const isRed = Math.random() < 0.2;
      for (let i = 0; i < 5; i++) {
        const dy = (i < 3 ? i : 4 - i) * 20;
        const e = makeEnemy(W + 30 + i * 25, cy + dy, isRed ? 'red' : 'grunt');
        enemies.push(e);
        if (dy > 0) {
          const e2 = makeEnemy(W + 30 + i * 25, cy - dy, isRed ? 'red' : 'grunt');
          enemies.push(e2);
        }
      }
    }

    function spawnFormationCircle() {
      const cx = W + 60;
      const cy = 60 + Math.random() * (H - 120);
      const isRed = Math.random() < 0.3;
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 / 8) * i;
        const e = makeEnemy(cx + Math.cos(angle) * 30, cy + Math.sin(angle) * 30, isRed ? 'red' : 'grunt');
        e.circleAngle = angle;
        e.circleCX = cx;
        e.circleCY = cy;
        const baseUpdate = e.update;
        e.update = (e) => {
          e.circleCX -= 2;
          e.circleAngle += 0.03;
          e.x = e.circleCX + Math.cos(e.circleAngle) * 30;
          e.y = e.circleCY + Math.sin(e.circleAngle) * 30;
          e.vx = 0;
          e.vy = 0;
        };
        enemies.push(e);
      }
    }

    function spawnSoloEnemy() {
      const diff = Math.min(waveNum, 20);
      const types = ['grunt', 'red', 'sine'];
      if (diff >= 3) types.push('turret');
      if (diff >= 5) types.push('fast');
      if (diff >= 8) types.push('heavy');
      const type = types[Math.floor(Math.random() * types.length)];
      const y = 30 + Math.random() * (H - 60);
      enemies.push(makeEnemy(W + 20, y, type));
    }

    function spawnBoss() {
      bossActive = true;
      const diff = Math.min(waveNum, 20);
      boss = {
        x: W - 80,
        y: H / 2 - 40,
        w: 64,
        h: 80,
        hp: 20 + diff * 5,
        maxHp: 20 + diff * 5,
        tick: 0,
        shootTimer: 60,
        weakFlash: false
      };
    }

    // ---- HELPERS ----

    function rectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    function getTerrainHeight(terrain, worldX) {
      const idx = Math.floor(((scrollX + worldX) / 16)) % terrain.length;
      const idx2 = (idx + 1) % terrain.length;
      const frac = ((scrollX + worldX) / 16) % 1;
      return terrain[Math.abs(idx) % terrain.length] * (1 - frac) +
             terrain[Math.abs(idx2) % terrain.length] * frac;
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 10; i++) {
        const ang = (Math.PI * 2 / 10) * i + Math.random() * 0.5;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.random() * 10,
          color
        });
      }
    }

    function spawnSpark(x, y) {
      for (let i = 0; i < 4; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 6,
          color: '#fff'
        });
      }
    }

    // ---- DRAW ----

    function draw() {
      // Background
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      // Stars
      for (const s of starField || []) {
        const alpha = s.brightness * (0.5 + 0.5 * Math.sin(tick * 0.03 + s.x));
        ctx.fillStyle = `rgba(200, 220, 255, ${alpha})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      // Terrain (top)
      ctx.fillStyle = '#0f3460';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      for (let px = 0; px <= W; px += 4) {
        const h = getTerrainHeight(terrainTop, px);
        ctx.lineTo(px, h);
      }
      ctx.lineTo(W, 0);
      ctx.closePath();
      ctx.fill();

      // Terrain surface glow (top)
      ctx.strokeStyle = '#1a5a8a';
      ctx.lineWidth = 1;
      ctx.shadowColor = '#2af';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      for (let px = 0; px <= W; px += 4) {
        const h = getTerrainHeight(terrainTop, px);
        if (px === 0) ctx.moveTo(px, h);
        else ctx.lineTo(px, h);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Terrain (bottom)
      ctx.fillStyle = '#0f3460';
      ctx.beginPath();
      ctx.moveTo(0, H);
      for (let px = 0; px <= W; px += 4) {
        const h = getTerrainHeight(terrainBot, px);
        ctx.lineTo(px, H - h);
      }
      ctx.lineTo(W, H);
      ctx.closePath();
      ctx.fill();

      // Terrain surface glow (bottom)
      ctx.strokeStyle = '#1a5a8a';
      ctx.lineWidth = 1;
      ctx.shadowColor = '#2af';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      for (let px = 0; px <= W; px += 4) {
        const h = getTerrainHeight(terrainBot, px);
        if (px === 0) ctx.moveTo(px, H - h);
        else ctx.lineTo(px, H - h);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Capsules
      for (const c of capsules) {
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ff0';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('P', c.x, c.y + 3);
        ctx.shadowBlur = 0;
      }

      // Enemies
      for (const e of enemies) {
        drawEnemy(e);
      }

      // Boss
      if (boss) {
        drawBoss();
      }

      // Bullets
      for (const b of bullets) {
        if (b.isLaser) {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 10;
          ctx.fillRect(b.x, b.y - 1, 20, 3);
        } else if (b.isMissile) {
          ctx.fillStyle = '#f80';
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.moveTo(b.x + 8, b.y);
          ctx.lineTo(b.x, b.y - 3);
          ctx.lineTo(b.x, b.y + 3);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = '#8ef';
          ctx.shadowColor = '#8ef';
          ctx.shadowBlur = 6;
          ctx.fillRect(b.x, b.y - 1, 8, 3);
        }
      }
      ctx.shadowBlur = 0;

      // Enemy bullets
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      for (const b of enemyBullets) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Options
      for (const o of options) {
        ctx.fillStyle = '#fa0';
        ctx.shadowColor = '#fa0';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(o.x + 5, o.y + 4, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Player
      if (player.invincible <= 0 || Math.floor(tick / 3) % 2 === 0) {
        drawPlayer();
      }

      // Shield visual
      if (shieldHP > 0) {
        ctx.strokeStyle = `rgba(68, 255, 68, ${0.3 + shieldHP * 0.2})`;
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 10;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x + player.w / 2, player.y + player.h / 2, 18, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Particles
      for (const p of particles) {
        const alpha = Math.min(1, p.life / 15);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;

      // Power-up bar at bottom
      drawPowerBar();

      // Boss HP bar
      if (boss) {
        const barW = 120;
        const barH = 6;
        const bx = W / 2 - barW / 2;
        const by = 10;
        ctx.fillStyle = '#333';
        ctx.fillRect(bx, by, barW, barH);
        ctx.fillStyle = '#f44';
        ctx.fillRect(bx, by, barW * (boss.hp / boss.maxHp), barH);
        ctx.strokeStyle = '#888';
        ctx.strokeRect(bx, by, barW, barH);
        ctx.fillStyle = '#fff';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS', W / 2, by + barH + 12);
      }
    }

    function drawPlayer() {
      const px = player.x, py = player.y;
      ctx.fillStyle = '#8ef';
      ctx.shadowColor = '#8ef';
      ctx.shadowBlur = 10;

      // Main body
      ctx.beginPath();
      ctx.moveTo(px + player.w, py + player.h / 2);  // Nose
      ctx.lineTo(px + player.w - 8, py);               // Top front
      ctx.lineTo(px + 4, py);                           // Top back
      ctx.lineTo(px, py + player.h / 2 - 2);            // Back indent top
      ctx.lineTo(px + 4, py + player.h / 2);            // Back center
      ctx.lineTo(px, py + player.h / 2 + 2);            // Back indent bot
      ctx.lineTo(px + 4, py + player.h);                // Bottom back
      ctx.lineTo(px + player.w - 8, py + player.h);     // Bottom front
      ctx.closePath();
      ctx.fill();

      // Wing details
      ctx.fillStyle = '#5ac';
      ctx.fillRect(px + 6, py + 2, 12, 3);
      ctx.fillRect(px + 6, py + player.h - 5, 12, 3);

      // Engine glow
      ctx.fillStyle = '#fa0';
      ctx.shadowColor = '#fa0';
      ctx.shadowBlur = 8;
      const flicker = Math.random() * 4;
      ctx.fillRect(px - 2 - flicker, py + player.h / 2 - 2, 4 + flicker, 4);
      ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
      ctx.fillStyle = e.color;
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 6;

      if (e.dropCapsule) {
        // Red enemies: distinctive shape
        ctx.beginPath();
        ctx.moveTo(e.x, e.y + e.h / 2);
        ctx.lineTo(e.x + e.w * 0.4, e.y);
        ctx.lineTo(e.x + e.w, e.y + e.h * 0.3);
        ctx.lineTo(e.x + e.w, e.y + e.h * 0.7);
        ctx.lineTo(e.x + e.w * 0.4, e.y + e.h);
        ctx.closePath();
        ctx.fill();
      } else {
        // Standard enemy shape
        ctx.beginPath();
        ctx.moveTo(e.x, e.y + e.h / 2);
        ctx.lineTo(e.x + e.w * 0.3, e.y);
        ctx.lineTo(e.x + e.w, e.y + e.h * 0.2);
        ctx.lineTo(e.x + e.w * 0.8, e.y + e.h / 2);
        ctx.lineTo(e.x + e.w, e.y + e.h * 0.8);
        ctx.lineTo(e.x + e.w * 0.3, e.y + e.h);
        ctx.closePath();
        ctx.fill();
      }

      // Eye
      ctx.fillStyle = '#1a1a2e';
      ctx.beginPath();
      ctx.arc(e.x + e.w * 0.4, e.y + e.h / 2, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawBoss() {
      const b = boss;
      // Main body
      ctx.fillStyle = '#666';
      ctx.shadowColor = '#888';
      ctx.shadowBlur = 12;
      ctx.fillRect(b.x + 10, b.y, b.w - 10, b.h);

      // Front armor
      ctx.fillStyle = '#888';
      ctx.beginPath();
      ctx.moveTo(b.x, b.y + b.h / 2);
      ctx.lineTo(b.x + 15, b.y + 10);
      ctx.lineTo(b.x + 15, b.y + b.h - 10);
      ctx.closePath();
      ctx.fill();

      // Cannons
      ctx.fillStyle = '#555';
      ctx.fillRect(b.x + 5, b.y - 4, 30, 8);
      ctx.fillRect(b.x + 5, b.y + b.h - 4, 30, 8);

      // Weak point (glowing core)
      const coreColor = b.weakFlash ? '#f44' : '#a22';
      ctx.fillStyle = coreColor;
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(b.x + b.w * 0.5, b.y + b.h * 0.5, 12, 0, Math.PI * 2);
      ctx.fill();

      // Inner core
      ctx.fillStyle = '#ff8';
      ctx.beginPath();
      ctx.arc(b.x + b.w * 0.5, b.y + b.h * 0.5, 5, 0, Math.PI * 2);
      ctx.fill();

      // Detail lines
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 0;
      for (let i = 0; i < 4; i++) {
        const ly = b.y + 15 + i * (b.h - 30) / 3;
        ctx.beginPath();
        ctx.moveTo(b.x + 15, ly);
        ctx.lineTo(b.x + b.w - 5, ly);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }

    function drawPowerBar() {
      const barW = POWER_NAMES.length * 60;
      const barX = (W - barW) / 2;
      const barY = H - 22;

      // Background
      ctx.fillStyle = 'rgba(10, 10, 30, 0.8)';
      ctx.fillRect(barX - 4, barY - 4, barW + 8, 22);
      ctx.strokeStyle = '#335';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX - 4, barY - 4, barW + 8, 22);

      for (let i = 0; i < POWER_NAMES.length; i++) {
        const x = barX + i * 60;
        const isHighlighted = i === powerIndex;

        // Box
        if (isHighlighted) {
          ctx.fillStyle = 'rgba(136, 238, 255, 0.25)';
          ctx.fillRect(x, barY, 56, 14);
          ctx.strokeStyle = '#8ef';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, barY, 56, 14);
        } else {
          ctx.strokeStyle = '#335';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, barY, 56, 14);
        }

        // Label
        ctx.fillStyle = isHighlighted ? POWER_COLORS[i] : '#555';
        ctx.font = isHighlighted ? 'bold 9px Courier New' : '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(POWER_NAMES[i], x + 28, barY + 11);
      }

      // Show active power-ups as small indicators above the bar
      const indicators = [];
      if (speedLevel > 0) indicators.push({ label: `SPD${speedLevel}`, color: '#fff' });
      if (hasMissile) indicators.push({ label: 'MSL', color: '#f80' });
      if (hasDouble) indicators.push({ label: 'DBL', color: '#8ef' });
      if (hasLaser) indicators.push({ label: 'LSR', color: '#f44' });
      if (options.length > 0) indicators.push({ label: `OPT${options.length}`, color: '#fa0' });
      if (shieldHP > 0) indicators.push({ label: `SHD${shieldHP}`, color: '#4f4' });

      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      for (let i = 0; i < indicators.length; i++) {
        ctx.fillStyle = indicators[i].color;
        ctx.fillText(indicators[i].label, barX + 20 + i * 40, barY - 8);
      }
    }

    // ---- INPUT ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === 'Shift') {
          activatePowerUp();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

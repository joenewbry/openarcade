<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Golf It</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #8f4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 255, 68, 0.5); }
    h1 { color: #8f4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(136, 255, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8f4; }
    canvas {
      border: 2px solid #8f4;
      box-shadow: 0 0 20px rgba(136, 255, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8f4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(136, 255, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>GOLF IT</h1>
  </div>
  <div class="score-bar">
    <div>Hole: <span id="score">1</span>/9</div>
    <div>Best: <span id="best">--</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">GOLF IT</h2>
      <p id="overlayText">Click to Start<br><br>Competitive mini-golf: You vs CPU<br>Click your ball, drag to aim, release to putt</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 500, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    // Colors
    const THEME = '#8f4';
    const FAIRWAY = '#1a3a1a';
    const WALL_COLOR = '#556';
    const WATER_COLOR = 'rgba(30,80,180,0.6)';
    const WATER_EDGE = 'rgba(60,120,220,0.4)';
    const CUP_COLOR = '#111';
    const FLAG_COLOR = '#f44';

    // Physics
    const FRICTION = 0.985;
    const MIN_SPEED = 0.15;
    const MAX_POWER = 12;
    const BALL_R = 5;
    const CUP_R = 8;
    const WALL_BOUNCE = 0.7;
    const BUMPER_BOUNCE = 1.3;

    // Players
    const players = [
      { name: 'You', color: '#fff', scores: [], isAI: false },
      { name: 'CPU', color: '#f84', scores: [], isAI: true }
    ];
    let currentPlayer = 0;
    let turnOrder = [0, 1];

    // Game state
    let currentHole = 0;
    let strokes = [0, 0];
    let balls = [{x:0,y:0,vx:0,vy:0,sunk:false},{x:0,y:0,vx:0,vy:0,sunk:false}];
    let lastPositions = [{x:0,y:0},{x:0,y:0}];
    let ballTrails = [[],[]];
    let ballMoving = false;
    let showScorecard = false;
    let holeComplete = false;
    let allSunk = false;
    let aiThinking = false;
    let aiThinkTimer = 0;
    let windmillAngle = 0;
    let animTime = 0;
    let sinkAnimations = [];
    let splashAnimations = [];

    // Aiming
    let aiming = false;
    let aimStart = {x:0, y:0};
    let aimEnd = {x:0, y:0};
    let mousePos = {x:0, y:0};

    // Course definitions
    const courses = [
      // Hole 1: Straight shot (Par 2)
      {
        par: 2,
        tee: {x: 250, y: 420},
        cup: {x: 250, y: 80},
        walls: [
          {x:100,y:30,w:300,h:10},
          {x:100,y:460,w:300,h:10},
          {x:100,y:30,w:10,h:440},
          {x:390,y:30,w:10,h:440},
        ],
        bumpers: [],
        water: [],
        windmills: [],
        fairways: [{x:110,y:40,w:280,h:420}],
      },
      // Hole 2: L-shaped (Par 3)
      {
        par: 3,
        tee: {x: 150, y: 420},
        cup: {x: 380, y: 100},
        walls: [
          {x:60,y:50,w:440,h:10},
          {x:60,y:460,w:180,h:10},
          {x:60,y:50,w:10,h:420},
          {x:230,y:50,w:10,h:230},
          {x:230,y:280,w:220,h:10},
          {x:440,y:50,w:10,h:240},
          {x:230,y:460,w:10,h:10},
        ],
        bumpers: [{x:150,y:250,r:10}],
        water: [],
        windmills: [],
        fairways: [{x:70,y:60,w:160,h:400},{x:240,y:60,w:200,h:230}],
      },
      // Hole 3: Water hazard (Par 3)
      {
        par: 3,
        tee: {x: 250, y: 430},
        cup: {x: 250, y: 70},
        walls: [
          {x:80,y:30,w:340,h:10},
          {x:80,y:460,w:340,h:10},
          {x:80,y:30,w:10,h:440},
          {x:410,y:30,w:10,h:440},
        ],
        bumpers: [],
        water: [{x:140,y:200,w:220,h:80}],
        windmills: [],
        fairways: [{x:90,y:40,w:320,h:420}],
      },
      // Hole 4: Bumper alley (Par 3)
      {
        par: 3,
        tee: {x: 250, y: 430},
        cup: {x: 250, y: 70},
        walls: [
          {x:100,y:30,w:300,h:10},
          {x:100,y:460,w:300,h:10},
          {x:100,y:30,w:10,h:440},
          {x:390,y:30,w:10,h:440},
        ],
        bumpers: [
          {x:180,y:180,r:12},{x:320,y:180,r:12},
          {x:250,y:250,r:12},
          {x:180,y:320,r:12},{x:320,y:320,r:12},
        ],
        water: [],
        windmills: [],
        fairways: [{x:110,y:40,w:280,h:420}],
      },
      // Hole 5: Windmill (Par 3)
      {
        par: 3,
        tee: {x: 250, y: 430},
        cup: {x: 250, y: 80},
        walls: [
          {x:80,y:30,w:340,h:10},
          {x:80,y:460,w:340,h:10},
          {x:80,y:30,w:10,h:440},
          {x:410,y:30,w:10,h:440},
        ],
        bumpers: [],
        water: [],
        windmills: [{x:250,y:250,armLen:60,armW:10,speed:0.02}],
        fairways: [{x:90,y:40,w:320,h:420}],
      },
      // Hole 6: Zigzag corridor (Par 4)
      {
        par: 4,
        tee: {x: 130, y: 430},
        cup: {x: 380, y: 70},
        walls: [
          {x:60,y:30,w:390,h:10},
          {x:60,y:460,w:390,h:10},
          {x:60,y:30,w:10,h:440},
          {x:440,y:30,w:10,h:440},
          {x:200,y:40,w:10,h:200},
          {x:60,y:300,w:200,h:10},
          {x:310,y:150,w:10,h:200},
          {x:310,y:340,w:140,h:10},
        ],
        bumpers: [],
        water: [{x:65,y:140,w:130,h:60}],
        windmills: [],
        fairways: [{x:70,y:40,w:130,h:260},{x:70,y:310,w:240,h:150},{x:210,y:40,w:100,h:270},{x:320,y:40,w:120,h:310},{x:320,y:350,w:120,h:110}],
      },
      // Hole 7: Island green (Par 3)
      {
        par: 3,
        tee: {x: 250, y: 430},
        cup: {x: 250, y: 130},
        walls: [
          {x:70,y:30,w:360,h:10},
          {x:70,y:460,w:360,h:10},
          {x:70,y:30,w:10,h:440},
          {x:420,y:30,w:10,h:440},
        ],
        bumpers: [{x:170,y:130,r:8},{x:330,y:130,r:8}],
        water: [{x:130,y:60,w:240,h:140}],
        windmills: [],
        fairways: [{x:80,y:40,w:340,h:420}],
        island: {x:210,y:90,w:80,h:80},
      },
      // Hole 8: Double windmill (Par 4)
      {
        par: 4,
        tee: {x: 250, y: 440},
        cup: {x: 250, y: 60},
        walls: [
          {x:90,y:20,w:320,h:10},
          {x:90,y:460,w:320,h:10},
          {x:90,y:20,w:10,h:450},
          {x:400,y:20,w:10,h:450},
        ],
        bumpers: [],
        water: [{x:150,y:340,w:200,h:40}],
        windmills: [
          {x:200,y:170,armLen:45,armW:8,speed:0.025},
          {x:300,y:270,armLen:45,armW:8,speed:-0.02},
        ],
        fairways: [{x:100,y:30,w:300,h:430}],
      },
      // Hole 9: The gauntlet (Par 5)
      {
        par: 5,
        tee: {x: 130, y: 440},
        cup: {x: 370, y: 60},
        walls: [
          {x:50,y:20,w:410,h:10},
          {x:50,y:460,w:410,h:10},
          {x:50,y:20,w:10,h:450},
          {x:450,y:20,w:10,h:450},
          {x:160,y:20,w:10,h:160},
          {x:160,y:280,w:10,h:180},
          {x:290,y:100,w:10,h:200},
          {x:290,y:380,w:10,h:80},
        ],
        bumpers: [
          {x:120,y:250,r:10},{x:220,y:350,r:10},
          {x:370,y:200,r:10},{x:370,y:350,r:10},
        ],
        water: [{x:300,y:250,w:90,h:70}],
        windmills: [{x:220,y:150,armLen:40,armW:8,speed:0.018}],
        fairways: [{x:60,y:30,w:100,h:430},{x:170,y:30,w:120,h:430},{x:300,y:30,w:150,h:430}],
      },
    ];

    function init() {
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      overlay.style.cursor = 'pointer';
      overlayTitle.textContent = 'GOLF IT';
      overlayText.innerHTML = 'Click to Start<br><br>Competitive mini-golf: You vs CPU<br>Click your ball, drag to aim, release to putt';
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      currentHole = 0;
      currentPlayer = 0;
      turnOrder = [0, 1];
      players[0].scores = [];
      players[1].scores = [];
      score = 0;
      setupHole();
    }

    function setupHole() {
      const course = courses[currentHole];
      strokes = [0, 0];
      holeComplete = false;
      allSunk = false;
      ballTrails = [[], []];
      sinkAnimations = [];
      splashAnimations = [];
      for (let i = 0; i < 2; i++) {
        balls[i] = {
          x: course.tee.x + (i === 0 ? -12 : 12),
          y: course.tee.y,
          vx: 0, vy: 0,
          sunk: false
        };
        lastPositions[i] = {x: balls[i].x, y: balls[i].y};
      }
      currentPlayer = turnOrder[0];
      aiming = false;
      ballMoving = false;
      aiThinking = false;
      scoreEl.textContent = (currentHole + 1);
      if (currentPlayer === 1) {
        startAITurn();
      }
    }

    function getActiveBall() {
      return balls[currentPlayer];
    }

    function isBallMoving(b) {
      return Math.abs(b.vx) > MIN_SPEED || Math.abs(b.vy) > MIN_SPEED;
    }

    function anyBallMoving() {
      return balls.some(b => !b.sunk && isBallMoving(b));
    }

    // Physics update
    function updateBall(idx) {
      const b = balls[idx];
      if (b.sunk) return;
      if (!isBallMoving(b)) { b.vx = 0; b.vy = 0; return; }

      b.x += b.vx;
      b.y += b.vy;
      b.vx *= FRICTION;
      b.vy *= FRICTION;

      if (Math.abs(b.vx) < MIN_SPEED * 0.5 && Math.abs(b.vy) < MIN_SPEED * 0.5) {
        b.vx = 0;
        b.vy = 0;
      }

      // Trail
      if (isBallMoving(b)) {
        ballTrails[idx].push({x: b.x, y: b.y, life: 20});
      }

      const course = courses[currentHole];

      // Wall collisions
      for (const wall of course.walls) {
        resolveWallCollision(b, wall);
      }

      // Windmill collisions
      for (const wm of course.windmills) {
        resolveWindmillCollision(b, wm);
      }

      // Bumper collisions
      for (const bmp of course.bumpers) {
        const dx = b.x - bmp.x;
        const dy = b.y - bmp.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < BALL_R + bmp.r) {
          const nx = dx / dist;
          const ny = dy / dist;
          const dot = b.vx * nx + b.vy * ny;
          b.vx = (b.vx - 2 * dot * nx) * BUMPER_BOUNCE;
          b.vy = (b.vy - 2 * dot * ny) * BUMPER_BOUNCE;
          const overlap = BALL_R + bmp.r - dist;
          b.x += nx * overlap;
          b.y += ny * overlap;
        }
      }

      // Water hazard check
      for (const w of course.water) {
        if (course.island) {
          const isl = course.island;
          if (b.x > isl.x && b.x < isl.x + isl.w && b.y > isl.y && b.y < isl.y + isl.h) {
            continue;
          }
        }
        if (b.x > w.x + BALL_R && b.x < w.x + w.w - BALL_R &&
            b.y > w.y + BALL_R && b.y < w.y + w.h - BALL_R) {
          splashAnimations.push({x: b.x, y: b.y, life: 30});
          b.x = lastPositions[idx].x;
          b.y = lastPositions[idx].y;
          b.vx = 0;
          b.vy = 0;
          strokes[idx]++;
          return;
        }
      }

      // Cup check
      const dx = b.x - course.cup.x;
      const dy = b.y - course.cup.y;
      const distToCup = Math.sqrt(dx*dx + dy*dy);
      const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
      if (distToCup < CUP_R && speed < 5) {
        b.sunk = true;
        b.x = course.cup.x;
        b.y = course.cup.y;
        b.vx = 0;
        b.vy = 0;
        sinkAnimations.push({x: course.cup.x, y: course.cup.y, life: 40, player: idx});
      }
    }

    function resolveWallCollision(b, wall) {
      const left = wall.x;
      const right = wall.x + wall.w;
      const top = wall.y;
      const bottom = wall.y + wall.h;

      const cx = Math.max(left, Math.min(b.x, right));
      const cy = Math.max(top, Math.min(b.y, bottom));
      const dx = b.x - cx;
      const dy = b.y - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < BALL_R && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const dot = b.vx * nx + b.vy * ny;
        if (dot < 0) {
          b.vx = (b.vx - 2 * dot * nx) * WALL_BOUNCE;
          b.vy = (b.vy - 2 * dot * ny) * WALL_BOUNCE;
        }
        const overlap = BALL_R - dist;
        b.x += nx * overlap;
        b.y += ny * overlap;
      }
    }

    function resolveWindmillCollision(b, wm) {
      const realAngle = windmillAngle;
      for (let a = 0; a < 2; a++) {
        const armAngle = realAngle + a * Math.PI;
        const cosA = Math.cos(armAngle);
        const sinA = Math.sin(armAngle);
        const ax = wm.x;
        const ay = wm.y;
        const bx2 = wm.x + cosA * wm.armLen;
        const by2 = wm.y + sinA * wm.armLen;
        const segDx = bx2 - ax;
        const segDy = by2 - ay;
        const len2 = segDx*segDx + segDy*segDy;
        let t = ((b.x - ax) * segDx + (b.y - ay) * segDy) / len2;
        t = Math.max(0, Math.min(1, t));
        const cx = ax + t * segDx;
        const cy = ay + t * segDy;
        const dx = b.x - cx;
        const dy = b.y - cy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < BALL_R + wm.armW/2) {
          const nx = dist > 0 ? dx/dist : 1;
          const ny = dist > 0 ? dy/dist : 0;
          const dot = b.vx * nx + b.vy * ny;
          if (dot < 0) {
            b.vx = (b.vx - 2 * dot * nx) * WALL_BOUNCE;
            b.vy = (b.vy - 2 * dot * ny) * WALL_BOUNCE;
            const pushSpeed = wm.speed * wm.armLen * 0.5;
            b.vx += -sinA * pushSpeed;
            b.vy += cosA * pushSpeed;
          }
          const overlap = BALL_R + wm.armW/2 - dist;
          b.x += nx * overlap * 1.5;
          b.y += ny * overlap * 1.5;
        }
      }
    }

    // Ball-to-ball collision
    function ballBallCollision() {
      if (balls[0].sunk || balls[1].sunk) return;
      const dx = balls[1].x - balls[0].x;
      const dy = balls[1].y - balls[0].y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < BALL_R * 2 && dist > 0) {
        const nx = dx/dist;
        const ny = dy/dist;
        const dv0 = balls[0].vx * nx + balls[0].vy * ny;
        const dv1 = balls[1].vx * nx + balls[1].vy * ny;
        balls[0].vx += (dv1 - dv0) * nx * 0.8;
        balls[0].vy += (dv1 - dv0) * ny * 0.8;
        balls[1].vx += (dv0 - dv1) * nx * 0.8;
        balls[1].vy += (dv0 - dv1) * ny * 0.8;
        const overlap = BALL_R * 2 - dist;
        balls[0].x -= nx * overlap/2;
        balls[0].y -= ny * overlap/2;
        balls[1].x += nx * overlap/2;
        balls[1].y += ny * overlap/2;
      }
    }

    // AI logic
    function startAITurn() {
      aiThinking = true;
      aiThinkTimer = 45;
    }

    function executeAIShot() {
      const b = balls[1];
      const course = courses[currentHole];
      const cup = course.cup;

      let targetX = cup.x;
      let targetY = cup.y;
      const dxC = targetX - b.x;
      const dyC = targetY - b.y;
      const distC = Math.sqrt(dxC*dxC + dyC*dyC);

      let directPath = true;
      for (const wall of course.walls) {
        if (lineIntersectsRect(b.x, b.y, targetX, targetY, wall)) {
          directPath = false;
          break;
        }
      }
      if (directPath) {
        for (const wm of course.windmills) {
          const wmDist = Math.sqrt((b.x-wm.x)**2 + (b.y-wm.y)**2);
          if (wmDist < wm.armLen + 30) { directPath = false; break; }
        }
      }
      if (directPath) {
        for (const w of course.water) {
          if (lineIntersectsRect(b.x, b.y, targetX, targetY, w)) {
            if (!course.island) { directPath = false; break; }
          }
        }
      }

      let power, angle;

      if (directPath) {
        angle = Math.atan2(dyC, dxC);
        power = Math.min(distC * 0.06, MAX_POWER * 0.85);
        angle += (Math.random() - 0.5) * 0.12;
        power *= 0.9 + Math.random() * 0.2;
      } else {
        const candidates = [];
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 12) {
          for (let d = 60; d < 200; d += 40) {
            const tx = b.x + Math.cos(a) * d;
            const ty = b.y + Math.sin(a) * d;
            if (tx < 60 || tx > 440 || ty < 30 || ty > 470) continue;
            let inWater = false;
            for (const w of course.water) {
              if (tx > w.x && tx < w.x+w.w && ty > w.y && ty < w.y+w.h) { inWater = true; break; }
            }
            if (inWater) continue;
            let pathClear = true;
            for (const wall of course.walls) {
              if (lineIntersectsRect(b.x, b.y, tx, ty, wall)) { pathClear = false; break; }
            }
            if (!pathClear) continue;
            const distToCup = Math.sqrt((tx-cup.x)**2 + (ty-cup.y)**2);
            candidates.push({x:tx, y:ty, score: -distToCup});
          }
        }
        if (candidates.length > 0) {
          candidates.sort((a,b) => b.score - a.score);
          const best = candidates[0];
          const bdx = best.x - b.x;
          const bdy = best.y - b.y;
          angle = Math.atan2(bdy, bdx);
          const bDist = Math.sqrt(bdx*bdx + bdy*bdy);
          power = Math.min(bDist * 0.055, MAX_POWER * 0.7);
        } else {
          angle = Math.atan2(dyC, dxC);
          power = Math.min(distC * 0.05, MAX_POWER * 0.6);
        }
        angle += (Math.random() - 0.5) * 0.18;
        power *= 0.85 + Math.random() * 0.3;
      }

      power = Math.max(2, Math.min(power, MAX_POWER));
      lastPositions[1] = {x: b.x, y: b.y};
      b.vx = Math.cos(angle) * power;
      b.vy = Math.sin(angle) * power;
      strokes[1]++;
      ballMoving = true;
      aiThinking = false;
    }

    function lineIntersectsRect(x1, y1, x2, y2, rect) {
      const left = rect.x, right = rect.x + rect.w;
      const top = rect.y, bottom = rect.y + rect.h;
      function outcode(x, y) {
        let code = 0;
        if (x < left) code |= 1; else if (x > right) code |= 2;
        if (y < top) code |= 4; else if (y > bottom) code |= 8;
        return code;
      }
      let oc1 = outcode(x1, y1), oc2 = outcode(x2, y2);
      if (oc1 & oc2) return false;
      if (!(oc1 | oc2)) return true;
      return lineIntersectsSegment(x1,y1,x2,y2,left,top,right,top) ||
             lineIntersectsSegment(x1,y1,x2,y2,right,top,right,bottom) ||
             lineIntersectsSegment(x1,y1,x2,y2,left,bottom,right,bottom) ||
             lineIntersectsSegment(x1,y1,x2,y2,left,top,left,bottom);
    }

    function lineIntersectsSegment(x1,y1,x2,y2,x3,y3,x4,y4) {
      const d = (x2-x1)*(y4-y3) - (y2-y1)*(x4-x3);
      if (Math.abs(d) < 0.001) return false;
      const t = ((x3-x1)*(y4-y3) - (y3-y1)*(x4-x3)) / d;
      const u = ((x3-x1)*(y2-y1) - (y3-y1)*(x2-x1)) / d;
      return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    // Input handling
    canvas.addEventListener('mousedown', (e) => {
      if (gameState !== 'playing') return;
      if (ballMoving || holeComplete || showScorecard) return;
      if (players[currentPlayer].isAI) return;

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);
      const b = getActiveBall();
      if (b.sunk) return;

      const dx = mx - b.x;
      const dy = my - b.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 35) {
        aiming = true;
        aimStart = {x: mx, y: my};
        aimEnd = {x: mx, y: my};
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mousePos.x = (e.clientX - rect.left) * (W / rect.width);
      mousePos.y = (e.clientY - rect.top) * (H / rect.height);
      if (aiming) {
        aimEnd = {x: mousePos.x, y: mousePos.y};
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!aiming) return;
      aiming = false;

      const b = getActiveBall();
      const dx = aimStart.x - aimEnd.x;
      const dy = aimStart.y - aimEnd.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < 5) return;

      const power = Math.min(dist * 0.1, MAX_POWER);
      const angle = Math.atan2(dy, dx);

      lastPositions[currentPlayer] = {x: b.x, y: b.y};
      b.vx = Math.cos(angle) * power;
      b.vy = Math.sin(angle) * power;
      strokes[currentPlayer]++;
      ballMoving = true;
    });

    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Overlay click
    overlay.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        startGame();
      } else if (gameState === 'over') {
        startGame();
      }
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    // Scorecard click
    canvas.addEventListener('click', (e) => {
      if (showScorecard) {
        handleScorecardClick();
      }
    });

    function scoreLabel(s, par) {
      const diff = s - par;
      if (s === 1) return 'ACE!';
      if (diff <= -3) return 'Albatross';
      if (diff === -2) return 'Eagle';
      if (diff === -1) return 'Birdie';
      if (diff === 0) return 'Par';
      if (diff === 1) return 'Bogey';
      if (diff === 2) return 'Dbl Bogey';
      return '+' + diff;
    }

    function totalScore(idx) {
      return players[idx].scores.reduce((a,b) => a+b, 0);
    }

    function totalPar() {
      let p = 0;
      for (let i = 0; i < players[0].scores.length; i++) p += courses[i].par;
      return p;
    }

    function relativeScore(idx) {
      const t = totalScore(idx);
      const p = totalPar();
      if (p === 0) return 'E';
      const diff = t - p;
      if (diff === 0) return 'E';
      if (diff > 0) return '+' + diff;
      return '' + diff;
    }

    // Drawing
    function draw() {
      ctx.fillStyle = '#0a0a18';
      ctx.fillRect(0, 0, W, H);

      if (showScorecard) {
        drawScorecard();
        return;
      }

      const course = courses[currentHole];

      // Draw fairways
      ctx.fillStyle = FAIRWAY;
      for (const f of course.fairways) {
        ctx.fillRect(f.x, f.y, f.w, f.h);
      }

      // Fairway grass texture
      ctx.fillStyle = 'rgba(30,70,30,0.3)';
      for (const f of course.fairways) {
        for (let gx = f.x + 8; gx < f.x + f.w; gx += 16) {
          for (let gy = f.y + 8; gy < f.y + f.h; gy += 16) {
            const ox = ((gx * 7 + gy * 13) % 11) - 5;
            const oy = ((gx * 3 + gy * 17) % 9) - 4;
            ctx.fillRect(gx + ox, gy + oy, 1, 3);
          }
        }
      }

      // Island
      if (course.island) {
        const isl = course.island;
        ctx.fillStyle = '#1a4a1a';
        ctx.fillRect(isl.x, isl.y, isl.w, isl.h);
        ctx.strokeStyle = '#2a5a2a';
        ctx.lineWidth = 1;
        ctx.strokeRect(isl.x, isl.y, isl.w, isl.h);
      }

      // Water
      for (const w of course.water) {
        ctx.fillStyle = WATER_COLOR;
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeStyle = WATER_EDGE;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const offset = (animTime * 0.5 + i * 20) % 60;
          ctx.beginPath();
          ctx.moveTo(w.x + offset, w.y + 10 + i * 25);
          ctx.quadraticCurveTo(w.x + w.w/2, w.y + 5 + i * 25 + Math.sin(animTime*0.05)*5,
                               w.x + w.w - offset, w.y + 10 + i * 25);
          ctx.stroke();
        }
      }

      // Walls
      for (const wall of course.walls) {
        ctx.fillStyle = WALL_COLOR;
        ctx.shadowColor = '#888';
        ctx.shadowBlur = 3;
        ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#778';
        if (wall.h <= wall.w) {
          ctx.fillRect(wall.x, wall.y, wall.w, 2);
        } else {
          ctx.fillRect(wall.x, wall.y, 2, wall.h);
        }
      }

      // Bumpers
      for (const bmp of course.bumpers) {
        ctx.beginPath();
        ctx.arc(bmp.x, bmp.y, bmp.r, 0, Math.PI * 2);
        ctx.fillStyle = '#d44';
        ctx.shadowColor = '#f66';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#faa';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      // Windmills
      for (const wm of course.windmills) {
        ctx.beginPath();
        ctx.arc(wm.x, wm.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#886';
        ctx.fill();
        ctx.strokeStyle = '#aa8';
        ctx.lineWidth = 1;
        ctx.stroke();
        for (let a = 0; a < 2; a++) {
          const armAngle = windmillAngle + a * Math.PI;
          ctx.save();
          ctx.translate(wm.x, wm.y);
          ctx.rotate(armAngle);
          ctx.fillStyle = '#a86';
          ctx.shadowColor = '#da8';
          ctx.shadowBlur = 4;
          ctx.fillRect(0, -wm.armW/2, wm.armLen, wm.armW);
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#c98';
          ctx.lineWidth = 1;
          ctx.strokeRect(0, -wm.armW/2, wm.armLen, wm.armW);
          ctx.restore();
        }
      }

      // Cup
      ctx.beginPath();
      ctx.arc(course.cup.x, course.cup.y, CUP_R, 0, Math.PI * 2);
      ctx.fillStyle = CUP_COLOR;
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(course.cup.x, course.cup.y, CUP_R - 3, 0, Math.PI * 2);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.stroke();
      // Flag
      ctx.beginPath();
      ctx.moveTo(course.cup.x, course.cup.y);
      ctx.lineTo(course.cup.x, course.cup.y - 20);
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(course.cup.x, course.cup.y - 20);
      ctx.lineTo(course.cup.x + 10, course.cup.y - 16);
      ctx.lineTo(course.cup.x, course.cup.y - 12);
      ctx.fillStyle = FLAG_COLOR;
      ctx.fill();

      // Ball trails
      for (let p = 0; p < 2; p++) {
        for (let i = 0; i < ballTrails[p].length; i++) {
          const t = ballTrails[p][i];
          const alpha = t.life / 20;
          ctx.beginPath();
          ctx.arc(t.x, t.y, BALL_R * alpha * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = p === 0 ? `rgba(255,255,255,${alpha*0.3})` : `rgba(255,136,68,${alpha*0.3})`;
          ctx.shadowColor = players[p].color;
          ctx.shadowBlur = alpha * 6;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // Splash animations
      for (const sp of splashAnimations) {
        const progress = 1 - sp.life / 30;
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI * 2 / 6) * i + progress * 2;
          const r = 5 + progress * 20;
          const sx = sp.x + Math.cos(angle) * r;
          const sy = sp.y + Math.sin(angle) * r;
          ctx.beginPath();
          ctx.arc(sx, sy, 2 * (1-progress), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(80,160,255,${(1-progress)*0.8})`;
          ctx.fill();
        }
      }

      // Sink animations
      for (const sa of sinkAnimations) {
        const progress = 1 - sa.life / 40;
        ctx.beginPath();
        ctx.arc(sa.x, sa.y, CUP_R + progress * 15, 0, Math.PI * 2);
        ctx.strokeStyle = sa.player === 0 ? `rgba(136,255,68,${(1-progress)*0.8})` : `rgba(255,136,68,${(1-progress)*0.8})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = sa.player === 0 ? THEME : '#f84';
        ctx.shadowBlur = (1-progress) * 10;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Balls
      for (let p = 0; p < 2; p++) {
        const b = balls[p];
        if (b.sunk) continue;
        // Glow
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_R + 3, 0, Math.PI * 2);
        ctx.fillStyle = p === 0 ? 'rgba(255,255,255,0.15)' : 'rgba(255,136,68,0.15)';
        ctx.shadowColor = players[p].color;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
        // Ball
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_R, 0, Math.PI * 2);
        ctx.fillStyle = players[p].color;
        ctx.fill();
        ctx.strokeStyle = p === 0 ? '#ccc' : '#c64';
        ctx.lineWidth = 1;
        ctx.stroke();
        // Label
        ctx.fillStyle = '#000';
        ctx.font = 'bold 7px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p === 0 ? 'P' : 'C', b.x, b.y + 0.5);
      }

      // Aiming line
      if (aiming && !players[currentPlayer].isAI) {
        const b = getActiveBall();
        const dx = aimStart.x - aimEnd.x;
        const dy = aimStart.y - aimEnd.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const power = Math.min(dist * 0.1, MAX_POWER);
        const angle = Math.atan2(dy, dx);
        const lineLen = power * 8;

        // Dotted aim line
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + Math.cos(angle) * lineLen, b.y + Math.sin(angle) * lineLen);
        ctx.strokeStyle = `rgba(136,255,68,0.7)`;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 6;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;

        // Arrow head
        const arrowX = b.x + Math.cos(angle) * lineLen;
        const arrowY = b.y + Math.sin(angle) * lineLen;
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - Math.cos(angle - 0.3) * 8, arrowY - Math.sin(angle - 0.3) * 8);
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - Math.cos(angle + 0.3) * 8, arrowY - Math.sin(angle + 0.3) * 8);
        ctx.strokeStyle = THEME;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Drag line (from ball to mouse, faded)
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(aimEnd.x, aimEnd.y);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Power bar
        const pct = power / MAX_POWER;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(10, H - 28, 120, 14);
        const barColor = pct < 0.5 ? THEME : (pct < 0.8 ? '#ff4' : '#f44');
        ctx.fillStyle = barColor;
        ctx.shadowColor = barColor;
        ctx.shadowBlur = 4;
        ctx.fillRect(10, H - 28, 120 * pct, 14);
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.strokeRect(10, H - 28, 120, 14);
        ctx.fillStyle = '#fff';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText('POWER', 14, H - 21);
      }

      drawHUD();

      // AI thinking indicator
      if (aiThinking) {
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(W/2 - 65, H/2 - 16, 130, 32);
        ctx.strokeStyle = '#f84';
        ctx.lineWidth = 1;
        ctx.strokeRect(W/2 - 65, H/2 - 16, 130, 32);
        ctx.fillStyle = '#f84';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const dots = '.'.repeat((Math.floor(animTime / 15) % 3) + 1);
        ctx.fillText('CPU thinking' + dots, W/2, H/2);
      }
    }

    function drawHUD() {
      const course = courses[currentHole];

      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(0, 0, W, 28);

      ctx.font = '11px Courier New';
      ctx.textBaseline = 'middle';

      ctx.textAlign = 'left';
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      ctx.fillText('Hole ' + (currentHole+1) + '/9  Par ' + course.par, 8, 14);
      ctx.shadowBlur = 0;

      ctx.textAlign = 'center';
      if (!holeComplete) {
        const turnColor = currentPlayer === 0 ? '#fff' : '#f84';
        ctx.fillStyle = turnColor;
        ctx.fillText(players[currentPlayer].name + "'s turn", W/2, 14);
      } else {
        ctx.fillStyle = THEME;
        ctx.fillText('Hole Complete!', W/2, 14);
      }

      ctx.textAlign = 'right';
      ctx.fillStyle = '#fff';
      ctx.fillText('You:' + strokes[0], W - 80, 14);
      ctx.fillStyle = '#f84';
      ctx.fillText('CPU:' + strokes[1], W - 8, 14);

      if (players[0].scores.length > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, H - 14, W, 14);
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Total: You ' + relativeScore(0) + ' (' + totalScore(0) + ')  |  CPU ' + relativeScore(1) + ' (' + totalScore(1) + ')', W/2, H - 7);
      }
    }

    function drawScorecard() {
      ctx.fillStyle = 'rgba(10, 10, 25, 0.95)';
      ctx.fillRect(0, 0, W, H);

      ctx.font = 'bold 16px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 10;
      ctx.fillText('SCORECARD', W/2, 30);
      ctx.shadowBlur = 0;

      const startX = 30;
      const startY = 60;
      const colW = 42;
      const rowH = 26;
      const labelW = 50;

      // Header row
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#888';
      ctx.fillText('Hole', startX + labelW/2, startY + rowH/2);
      for (let i = 0; i < 9; i++) {
        ctx.fillStyle = i <= currentHole ? '#aaa' : '#444';
        ctx.fillText(i+1, startX + labelW + i * colW + colW/2, startY + rowH/2);
      }
      ctx.fillStyle = THEME;
      ctx.fillText('TOT', startX + labelW + 9 * colW + colW/2, startY + rowH/2);

      // Par row
      const parY = startY + rowH;
      ctx.fillStyle = '#666';
      ctx.fillText('Par', startX + labelW/2, parY + rowH/2);
      let totalParVal = 0;
      for (let i = 0; i < 9; i++) {
        ctx.fillStyle = i <= currentHole ? '#777' : '#333';
        ctx.fillText(courses[i].par, startX + labelW + i * colW + colW/2, parY + rowH/2);
        totalParVal += courses[i].par;
      }
      ctx.fillStyle = '#777';
      ctx.fillText(totalParVal, startX + labelW + 9 * colW + colW/2, parY + rowH/2);

      // Player rows
      for (let p = 0; p < 2; p++) {
        const py = startY + (p + 2) * rowH;
        ctx.fillStyle = players[p].color;
        ctx.fillText(players[p].name, startX + labelW/2, py + rowH/2);
        let total = 0;
        for (let i = 0; i < 9; i++) {
          if (i < players[p].scores.length) {
            const s = players[p].scores[i];
            total += s;
            const diff = s - courses[i].par;
            if (diff <= -2) ctx.fillStyle = '#4cf';
            else if (diff === -1) ctx.fillStyle = '#4f4';
            else if (diff === 0) ctx.fillStyle = '#fff';
            else if (diff === 1) ctx.fillStyle = '#fa4';
            else ctx.fillStyle = '#f44';
            ctx.fillText(s, startX + labelW + i * colW + colW/2, py + rowH/2);
          } else {
            ctx.fillStyle = '#333';
            ctx.fillText('-', startX + labelW + i * colW + colW/2, py + rowH/2);
          }
        }
        if (players[p].scores.length > 0) {
          ctx.fillStyle = players[p].color;
          ctx.fillText(total, startX + labelW + 9 * colW + colW/2, py + rowH/2);
        }

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(startX, py + rowH);
        ctx.lineTo(startX + labelW + 10 * colW + colW, py + rowH);
        ctx.stroke();
      }

      // Grid lines
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= 10; i++) {
        const x = startX + labelW + i * colW;
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, startY + 4 * rowH);
        ctx.stroke();
      }
      for (let i = 0; i <= 4; i++) {
        ctx.beginPath();
        ctx.moveTo(startX, startY + i * rowH);
        ctx.lineTo(startX + labelW + 10 * colW + colW, startY + i * rowH);
        ctx.stroke();
      }

      // Hole result summary
      const summY = startY + 5 * rowH + 20;
      ctx.font = '14px Courier New';
      for (let p = 0; p < 2; p++) {
        if (currentHole < players[p].scores.length) {
          const s = players[p].scores[currentHole];
          const label = scoreLabel(s, courses[currentHole].par);
          ctx.fillStyle = players[p].color;
          ctx.fillText(players[p].name + ': ' + s + ' strokes (' + label + ')', W/2, summY + p * 24);
        }
      }

      ctx.font = '12px Courier New';
      ctx.fillStyle = '#666';
      if (currentHole < 8) {
        ctx.fillText('Click to continue to next hole', W/2, H - 40);
      } else {
        const s0 = totalScore(0);
        const s1 = totalScore(1);
        ctx.font = 'bold 18px Courier New';
        if (s0 < s1) {
          ctx.fillStyle = THEME;
          ctx.shadowColor = THEME;
          ctx.shadowBlur = 12;
          ctx.fillText('YOU WIN!', W/2, H - 80);
        } else if (s1 < s0) {
          ctx.fillStyle = '#f84';
          ctx.shadowColor = '#f84';
          ctx.shadowBlur = 12;
          ctx.fillText('CPU WINS!', W/2, H - 80);
        } else {
          ctx.fillStyle = '#ff4';
          ctx.shadowColor = '#ff4';
          ctx.shadowBlur = 12;
          ctx.fillText('TIE GAME!', W/2, H - 80);
        }
        ctx.shadowBlur = 0;
        ctx.font = '12px Courier New';
        ctx.fillStyle = '#666';
        ctx.fillText('Click to play again', W/2, H - 40);
      }
    }

    function handleScorecardClick() {
      if (currentHole < 8) {
        if (players[0].scores[currentHole] <= players[1].scores[currentHole]) {
          turnOrder = [0, 1];
        } else {
          turnOrder = [1, 0];
        }
        currentHole++;
        showScorecard = false;
        setupHole();
      } else {
        const s0 = totalScore(0);
        const best = localStorage.getItem('golfIt_best');
        if (!best || s0 < parseInt(best)) {
          localStorage.setItem('golfIt_best', s0);
          bestEl.textContent = s0;
        }
        showScorecard = false;
        gameState = 'over';
        score = s0;
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
        overlayTitle.textContent = 'GAME OVER';
        const s1 = totalScore(1);
        const winner = s0 < s1 ? 'You win!' : (s1 < s0 ? 'CPU wins!' : 'Tie game!');
        overlayText.innerHTML = winner + '<br>You: ' + s0 + ' (' + relativeScore(0) + ') | CPU: ' + s1 + ' (' + relativeScore(1) + ')<br><br>Click to play again';
      }
    }

    // Game loop
    function update() {
      if (gameState !== 'playing') return;

      animTime++;
      windmillAngle += 0.02;

      // Update trails
      for (let p = 0; p < 2; p++) {
        for (let i = ballTrails[p].length - 1; i >= 0; i--) {
          ballTrails[p][i].life--;
          if (ballTrails[p][i].life <= 0) ballTrails[p].splice(i, 1);
        }
      }

      // Update animations
      for (let i = sinkAnimations.length - 1; i >= 0; i--) {
        sinkAnimations[i].life--;
        if (sinkAnimations[i].life <= 0) sinkAnimations.splice(i, 1);
      }
      for (let i = splashAnimations.length - 1; i >= 0; i--) {
        splashAnimations[i].life--;
        if (splashAnimations[i].life <= 0) splashAnimations.splice(i, 1);
      }

      if (showScorecard) return;

      // AI thinking
      if (aiThinking) {
        aiThinkTimer--;
        if (aiThinkTimer <= 0) {
          executeAIShot();
        }
        return;
      }

      // Update ball physics
      if (ballMoving) {
        updateBall(currentPlayer);
        const otherPlayer = 1 - currentPlayer;
        if (isBallMoving(balls[otherPlayer]) && !balls[otherPlayer].sunk) {
          updateBall(otherPlayer);
        }
        ballBallCollision();

        if (!anyBallMoving()) {
          ballMoving = false;
          balls[0].vx = 0; balls[0].vy = 0;
          balls[1].vx = 0; balls[1].vy = 0;

          // Both sunk?
          if (balls[0].sunk && balls[1].sunk) {
            allSunk = true;
            holeComplete = true;
            players[0].scores.push(strokes[0]);
            players[1].scores.push(strokes[1]);
            score = totalScore(0);
            scoreEl.textContent = (currentHole + 1);
            setTimeout(() => { showScorecard = true; }, 800);
            return;
          }

          // Current player sunk?
          if (balls[currentPlayer].sunk) {
            if (!balls[1 - currentPlayer].sunk) {
              currentPlayer = 1 - currentPlayer;
              if (players[currentPlayer].isAI) startAITurn();
            }
            return;
          }

          // Max strokes (10)
          if (strokes[currentPlayer] >= 10) {
            balls[currentPlayer].sunk = true;
            if (balls[0].sunk && balls[1].sunk) {
              allSunk = true;
              holeComplete = true;
              players[0].scores.push(strokes[0]);
              players[1].scores.push(strokes[1]);
              score = totalScore(0);
              setTimeout(() => { showScorecard = true; }, 800);
              return;
            }
            if (!balls[1 - currentPlayer].sunk) {
              currentPlayer = 1 - currentPlayer;
              if (players[currentPlayer].isAI) startAITurn();
            }
            return;
          }

          // Alternate turns
          const nextPlayer = 1 - currentPlayer;
          if (!balls[nextPlayer].sunk) {
            currentPlayer = nextPlayer;
          }
          if (players[currentPlayer].isAI && !balls[currentPlayer].sunk) {
            startAITurn();
          }
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Load best score
    const savedBest = localStorage.getItem('golfIt_best');
    if (savedBest) bestEl.textContent = savedBest;

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

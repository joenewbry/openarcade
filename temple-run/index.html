<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Temple Run 2D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #d84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(221, 136, 68, 0.5); }
    h1 { color: #d84; font-size: 2rem; text-shadow: 0 0 15px rgba(221, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #d84; }
    canvas {
      border: 2px solid #d84;
      box-shadow: 0 0 20px rgba(221, 136, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #d84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TEMPLE RUN 2D</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">TEMPLE RUN 2D</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const LANE_COUNT = 3;
    const LANE_WIDTH = 100;
    const CORRIDOR_WIDTH = LANE_COUNT * LANE_WIDTH; // 300
    const CORRIDOR_LEFT = (W - CORRIDOR_WIDTH) / 2;  // 50
    const PLAYER_W = 30;
    const PLAYER_H = 40;
    const PLAYER_Y = H - 100;
    const LANE_SWITCH_SPEED = 12;

    // Obstacle types
    const OBS_ROOT = 'root';      // jump over (low obstacle)
    const OBS_FIRE = 'fire';      // slide under (high obstacle)
    const OBS_GAP = 'gap';        // avoid lane (gap in floor)
    // Coins are stored in a separate array, not as obstacles

    // Timing
    const BASE_SPEED = 3;
    const MAX_SPEED = 10;
    const SPEED_RAMP_FRAMES = 7200; // ~2 minutes to max speed
    const MIN_SPAWN_DIST = 140;
    const MAX_SPAWN_DIST = 280;

    // Jump / slide
    const JUMP_DURATION = 30;  // frames
    const JUMP_HEIGHT = 50;
    const SLIDE_DURATION = 24; // frames

    // --- State ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let playerLane;       // 0, 1, 2
    let playerX;          // actual X position (smooth interpolation)
    let targetX;          // target X for current lane
    let scrollSpeed;
    let frameCount;
    let obstacles;
    let coins;
    let nextSpawnY;
    let isJumping, jumpFrame;
    let isSliding, slideFrame;
    let distanceTraveled;
    let coinBonus;
    let particles;

    // Wall decoration scroll offset
    let wallOffset;

    // Tile pattern offset
    let tileOffset;

    function laneX(lane) {
      return CORRIDOR_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      playerLane = 1;
      playerX = laneX(1);
      targetX = playerX;
      scrollSpeed = BASE_SPEED;
      frameCount = 0;
      obstacles = [];
      coins = [];
      nextSpawnY = -200;
      isJumping = false;
      jumpFrame = 0;
      isSliding = false;
      slideFrame = 0;
      distanceTraveled = 0;
      coinBonus = 0;
      particles = [];
      wallOffset = 0;
      tileOffset = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TEMPLE RUN 2D';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      // Death particles
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: playerX,
          y: PLAYER_Y + PLAYER_H / 2,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 30 + Math.random() * 20,
          color: '#d84'
        });
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Increase speed over time
      const t = Math.min(frameCount / SPEED_RAMP_FRAMES, 1);
      scrollSpeed = BASE_SPEED + t * (MAX_SPEED - BASE_SPEED);

      // Distance and score
      distanceTraveled += scrollSpeed;
      score = Math.floor(distanceTraveled / 10) + coinBonus;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Smooth lane switching
      targetX = laneX(playerLane);
      const dx = targetX - playerX;
      if (Math.abs(dx) < LANE_SWITCH_SPEED) {
        playerX = targetX;
      } else {
        playerX += Math.sign(dx) * LANE_SWITCH_SPEED;
      }

      // Jump
      if (isJumping) {
        jumpFrame++;
        if (jumpFrame >= JUMP_DURATION) {
          isJumping = false;
          jumpFrame = 0;
        }
      }

      // Slide
      if (isSliding) {
        slideFrame++;
        if (slideFrame >= SLIDE_DURATION) {
          isSliding = false;
          slideFrame = 0;
        }
      }

      // Scroll offsets
      wallOffset = (wallOffset + scrollSpeed) % 40;
      tileOffset = (tileOffset + scrollSpeed) % 50;

      // Spawn obstacles and coins
      while (nextSpawnY < 0) {
        spawnRow(nextSpawnY);
        nextSpawnY -= MIN_SPAWN_DIST + Math.random() * (MAX_SPAWN_DIST - MIN_SPAWN_DIST);
      }

      // Move obstacles down
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].y += scrollSpeed;
        if (obstacles[i].y > H + 50) {
          obstacles.splice(i, 1);
          continue;
        }
        // Collision
        if (checkCollision(obstacles[i])) {
          gameOver();
          return;
        }
      }

      // Move coins down
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].y += scrollSpeed;
        if (coins[i].y > H + 50) {
          coins.splice(i, 1);
          continue;
        }
        // Collect
        if (checkCoinCollect(coins[i])) {
          // Coin particles
          for (let j = 0; j < 6; j++) {
            particles.push({
              x: coins[i].x,
              y: coins[i].y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 15 + Math.random() * 10,
              color: '#ff0'
            });
          }
          coinBonus += 50;
          coins.splice(i, 1);
        }
      }

      // Update nextSpawnY
      nextSpawnY += scrollSpeed;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life--;
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function spawnRow(y) {
      // Decide what to spawn
      const r = Math.random();
      if (r < 0.25) {
        // Root obstacle - spans 1-2 lanes (always leaves at least 1 safe lane)
        const lane = Math.floor(Math.random() * 3);
        obstacles.push({ type: OBS_ROOT, lane, y, width: 1 });
        if (Math.random() < 0.3) {
          // Add a second root in an adjacent lane (max 2 of 3 blocked)
          const adj = lane === 0 ? 1 : (lane === 2 ? 1 : (Math.random() < 0.5 ? 0 : 2));
          obstacles.push({ type: OBS_ROOT, lane: adj, y, width: 1 });
        }
      } else if (r < 0.45) {
        // Fire trap - spans 1-2 lanes (always leaves at least 1 safe lane)
        const lane = Math.floor(Math.random() * 3);
        obstacles.push({ type: OBS_FIRE, lane, y, width: 1 });
        if (Math.random() < 0.25) {
          const adj = lane === 0 ? 1 : (lane === 2 ? 1 : (Math.random() < 0.5 ? 0 : 2));
          obstacles.push({ type: OBS_FIRE, lane: adj, y, width: 1 });
        }
      } else if (r < 0.6) {
        // Gap - one lane missing (only ever 1 gap lane at a time)
        const lane = Math.floor(Math.random() * 3);
        obstacles.push({ type: OBS_GAP, lane, y, width: 1 });
      } else {
        // Coins in a lane
        const lane = Math.floor(Math.random() * 3);
        const count = 1 + Math.floor(Math.random() * 3);
        for (let c = 0; c < count; c++) {
          coins.push({
            x: laneX(lane),
            y: y - c * 40,
            bobPhase: Math.random() * Math.PI * 2
          });
        }
      }
    }

    function getJumpOffset() {
      if (!isJumping) return 0;
      // Parabolic arc
      const t = jumpFrame / JUMP_DURATION;
      return -JUMP_HEIGHT * Math.sin(t * Math.PI);
    }

    function checkCollision(obs) {
      const obsX = laneX(obs.lane);
      const obsW = LANE_WIDTH * 0.7;
      const px = playerX;
      const py = PLAYER_Y;
      const pw = PLAYER_W;
      const ph = PLAYER_H;

      // Each obstacle type has its own collision height
      let obsH;
      if (obs.type === OBS_GAP) obsH = 50;
      else if (obs.type === OBS_FIRE) obsH = 30;
      else obsH = 18;

      // Check if in same horizontal area
      if (Math.abs(px - obsX) > (pw + obsW) / 2) return false;

      // Vertical overlap
      const obsTop = obs.y;
      const obsBottom = obs.y + obsH;
      if (obsBottom < py || obsTop > py + ph) return false;

      // Type-specific checks
      if (obs.type === OBS_ROOT) {
        // Can jump over roots
        if (isJumping && jumpFrame > 3 && jumpFrame < JUMP_DURATION - 3) return false;
        return true;
      }
      if (obs.type === OBS_FIRE) {
        // Can slide under fire
        if (isSliding && slideFrame > 2 && slideFrame < SLIDE_DURATION - 2) return false;
        return true;
      }
      if (obs.type === OBS_GAP) {
        // Must jump over gap
        if (isJumping && jumpFrame > 3 && jumpFrame < JUMP_DURATION - 3) return false;
        return true;
      }
      return true;
    }

    function checkCoinCollect(coin) {
      const dx = playerX - coin.x;
      const dy = (PLAYER_Y + PLAYER_H / 2) - coin.y;
      return Math.sqrt(dx * dx + dy * dy) < 30;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw temple walls (left and right)
      drawWalls();

      // Draw corridor floor tiles
      drawFloor();

      // Draw gaps (dark pits)
      obstacles.forEach(obs => {
        if (obs.type === OBS_GAP) drawGap(obs);
      });

      // Draw coins
      coins.forEach(coin => {
        coin.bobPhase += 0.08;
        const bobY = Math.sin(coin.bobPhase) * 3;
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(coin.x, coin.y + bobY, 8, 0, Math.PI * 2);
        ctx.fill();
        // Inner highlight
        ctx.fillStyle = '#ffa';
        ctx.beginPath();
        ctx.arc(coin.x - 2, coin.y + bobY - 2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Draw obstacles (roots and fire)
      obstacles.forEach(obs => {
        if (obs.type === OBS_ROOT) drawRoot(obs);
        if (obs.type === OBS_FIRE) drawFire(obs);
      });

      // Draw player
      drawPlayer();

      // Draw particles
      particles.forEach(p => {
        const alpha = p.life / 40;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, alpha);
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // Draw speed indicator
      if (gameState === 'playing') {
        const speedPct = (scrollSpeed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED);
        ctx.fillStyle = '#888';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`SPD ${Math.floor(scrollSpeed * 10)}`, CORRIDOR_LEFT, H - 10);
      }
    }

    function drawWalls() {
      // Left wall
      const wallW = CORRIDOR_LEFT;
      const gradient1 = ctx.createLinearGradient(0, 0, wallW, 0);
      gradient1.addColorStop(0, '#0d0d1a');
      gradient1.addColorStop(1, '#16213e');
      ctx.fillStyle = gradient1;
      ctx.fillRect(0, 0, wallW, H);

      // Right wall
      const rightX = CORRIDOR_LEFT + CORRIDOR_WIDTH;
      const gradient2 = ctx.createLinearGradient(rightX, 0, W, 0);
      gradient2.addColorStop(0, '#16213e');
      gradient2.addColorStop(1, '#0d0d1a');
      ctx.fillStyle = gradient2;
      ctx.fillRect(rightX, 0, wallW, H);

      // Wall decorations (stone blocks)
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      for (let y = -wallOffset; y < H; y += 40) {
        const offset = (Math.floor((y + wallOffset) / 40) % 2) * 20;
        // Left wall blocks
        for (let x = 0; x < wallW; x += 40) {
          ctx.strokeRect(x + offset * 0.5, y, 40, 40);
        }
        // Right wall blocks
        for (let x = rightX; x < W; x += 40) {
          ctx.strokeRect(x + offset * 0.5, y, 40, 40);
        }
      }

      // Wall edge glow
      ctx.fillStyle = 'rgba(221, 136, 68, 0.08)';
      ctx.fillRect(wallW - 3, 0, 6, H);
      ctx.fillRect(rightX - 3, 0, 6, H);

      // Wall inner borders
      ctx.strokeStyle = '#d84';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(wallW, 0);
      ctx.lineTo(wallW, H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rightX, 0);
      ctx.lineTo(rightX, H);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Lane dividers
      ctx.strokeStyle = 'rgba(221, 136, 68, 0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([8, 12]);
      for (let i = 1; i < LANE_COUNT; i++) {
        const lx = CORRIDOR_LEFT + i * LANE_WIDTH;
        ctx.beginPath();
        ctx.moveTo(lx, 0);
        ctx.lineTo(lx, H);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawFloor() {
      // Tile pattern
      ctx.strokeStyle = 'rgba(15, 52, 96, 0.4)';
      ctx.lineWidth = 0.5;
      const tileSize = 50;
      for (let y = -tileOffset; y < H; y += tileSize) {
        const row = Math.floor((y + tileOffset) / tileSize);
        const off = (row % 2) * (tileSize / 2);
        for (let x = CORRIDOR_LEFT + off; x < CORRIDOR_LEFT + CORRIDOR_WIDTH; x += tileSize) {
          ctx.strokeRect(x, y, tileSize, tileSize);
        }
      }
    }

    function drawRoot(obs) {
      const cx = laneX(obs.lane);
      const y = obs.y;
      const w = LANE_WIDTH * 0.7;
      const h = 18;

      // Root body (brown, gnarled)
      ctx.fillStyle = '#5a3a1a';
      ctx.shadowColor = '#d84';
      ctx.shadowBlur = 6;

      // Draw organic root shape
      ctx.beginPath();
      ctx.moveTo(cx - w / 2, y + h);
      ctx.quadraticCurveTo(cx - w / 3, y - 4, cx - w / 6, y + h * 0.3);
      ctx.quadraticCurveTo(cx, y - 6, cx + w / 6, y + h * 0.4);
      ctx.quadraticCurveTo(cx + w / 3, y - 3, cx + w / 2, y + h);
      ctx.closePath();
      ctx.fill();

      // Root highlight
      ctx.fillStyle = '#7a5a3a';
      ctx.beginPath();
      ctx.ellipse(cx, y + h * 0.3, w * 0.25, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Label
      ctx.fillStyle = '#d84';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('ROOT', cx, y - 4);
    }

    function drawFire(obs) {
      const cx = laneX(obs.lane);
      const y = obs.y;
      const w = LANE_WIDTH * 0.6;

      // Fire base
      ctx.fillStyle = '#331100';
      ctx.fillRect(cx - w / 2, y - 5, w, 35);

      // Animated flames
      const time = frameCount * 0.15;
      ctx.shadowColor = '#f40';
      ctx.shadowBlur = 15;

      for (let i = 0; i < 5; i++) {
        const fx = cx - w / 3 + (i * w / 3.5);
        const fh = 20 + Math.sin(time + i * 1.5) * 8;
        const fy = y + 25 - fh;

        // Outer flame (red)
        ctx.fillStyle = '#f40';
        ctx.beginPath();
        ctx.moveTo(fx - 8, y + 25);
        ctx.quadraticCurveTo(fx - 6, fy + fh * 0.3, fx, fy);
        ctx.quadraticCurveTo(fx + 6, fy + fh * 0.3, fx + 8, y + 25);
        ctx.closePath();
        ctx.fill();

        // Inner flame (yellow)
        ctx.fillStyle = '#fa0';
        ctx.beginPath();
        ctx.moveTo(fx - 4, y + 25);
        ctx.quadraticCurveTo(fx - 3, fy + fh * 0.5, fx, fy + fh * 0.3);
        ctx.quadraticCurveTo(fx + 3, fy + fh * 0.5, fx + 4, y + 25);
        ctx.closePath();
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Label
      ctx.fillStyle = '#f40';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('FIRE', cx, y - 10);
    }

    function drawGap(obs) {
      const cx = laneX(obs.lane);
      const y = obs.y;
      const w = LANE_WIDTH - 6;
      const h = 50;

      // Dark pit
      ctx.fillStyle = '#050510';
      ctx.fillRect(cx - w / 2, y, w, h);

      // Edge glow
      ctx.strokeStyle = 'rgba(221, 136, 68, 0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx - w / 2, y, w, h);

      // Depth lines
      ctx.strokeStyle = 'rgba(100, 50, 20, 0.3)';
      ctx.lineWidth = 1;
      for (let i = 4; i < w - 4; i += 12) {
        ctx.beginPath();
        ctx.moveTo(cx - w / 2 + i, y + 2);
        ctx.lineTo(cx - w / 2 + i + 4, y + h - 2);
        ctx.stroke();
      }

      // Label
      ctx.fillStyle = '#d84';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('GAP', cx, y - 4);
    }

    function drawPlayer() {
      const jumpOff = getJumpOffset();
      const px = playerX;
      let py = PLAYER_Y + jumpOff;
      let pw = PLAYER_W;
      let ph = PLAYER_H;

      // Sliding makes the player shorter and wider
      if (isSliding) {
        ph = PLAYER_H * 0.4;
        pw = PLAYER_W * 1.3;
        py = PLAYER_Y + PLAYER_H - ph;
      }

      // Shadow on ground when jumping
      if (isJumping) {
        const shadowScale = 1 + jumpOff / JUMP_HEIGHT * 0.3;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(px, PLAYER_Y + PLAYER_H, pw * shadowScale * 0.6, 4, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Player body (explorer)
      ctx.shadowColor = '#d84';
      ctx.shadowBlur = 12;

      // Torso
      ctx.fillStyle = '#d84';
      ctx.fillRect(px - pw / 2, py, pw, ph);

      // Inner detail - vest
      ctx.fillStyle = '#a62';
      ctx.fillRect(px - pw / 2 + 4, py + 4, pw - 8, ph - 8);

      // Head
      if (!isSliding) {
        ctx.fillStyle = '#d84';
        ctx.beginPath();
        ctx.arc(px, py - 6, 8, 0, Math.PI * 2);
        ctx.fill();

        // Hat
        ctx.fillStyle = '#863';
        ctx.fillRect(px - 10, py - 14, 20, 4);
        ctx.fillRect(px - 6, py - 18, 12, 6);
      }

      ctx.shadowBlur = 0;

      // Running legs animation
      if (gameState === 'playing' && !isSliding && !isJumping) {
        const legPhase = Math.sin(frameCount * 0.3);
        ctx.fillStyle = '#863';
        ctx.fillRect(px - 5 + legPhase * 4, py + ph, 4, 8);
        ctx.fillRect(px + 1 - legPhase * 4, py + ph, 4, 8);
      }

      // Jump effect
      if (isJumping) {
        ctx.strokeStyle = 'rgba(221, 136, 68, 0.3)';
        ctx.lineWidth = 2;
        const trailY = PLAYER_Y + PLAYER_H;
        for (let i = 0; i < 3; i++) {
          ctx.globalAlpha = 0.3 - i * 0.1;
          ctx.beginPath();
          ctx.moveTo(px - 10 - i * 3, trailY + i * 4);
          ctx.lineTo(px + 10 + i * 3, trailY + i * 4);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      // Slide sparks
      if (isSliding) {
        for (let i = 0; i < 2; i++) {
          const sx = px + (Math.random() - 0.5) * pw;
          const sy = py + ph - 2;
          ctx.fillStyle = '#ff0';
          ctx.fillRect(sx, sy, 2, 2);
        }
      }
    }

    // --- Input ---
    let keys = {};

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowLeft':
            if (playerLane > 0 && !keys['ArrowLeft']) {
              playerLane--;
            }
            break;
          case 'ArrowRight':
            if (playerLane < 2 && !keys['ArrowRight']) {
              playerLane++;
            }
            break;
          case 'ArrowUp':
          case ' ':
            if (!isJumping && !isSliding) {
              isJumping = true;
              jumpFrame = 0;
            }
            break;
          case 'ArrowDown':
            if (!isSliding && !isJumping) {
              isSliding = true;
              slideFrame = 0;
            }
            break;
        }
      }
      keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Expose game data for ML training
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        playerLane,
        playerX,
        playerY: PLAYER_Y,
        isJumping,
        isSliding,
        scrollSpeed,
        obstacles: obstacles.map(o => ({ type: o.type, lane: o.lane, y: o.y })),
        coins: coins.map(c => ({ x: c.x, y: c.y })),
        score,
        distanceTraveled
      };
    }

    // Override the update to also push game data
    const _origUpdate = update;
    update = function() {
      _origUpdate();
      updateGameData();
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

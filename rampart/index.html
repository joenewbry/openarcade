<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rampart</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #4ec; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 238, 204, 0.4); }
    h1 { color: #4ec; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 238, 204, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4ec; }
    canvas {
      border: 2px solid #4ec;
      box-shadow: 0 0 20px rgba(68, 238, 204, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4ec;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>RAMPART</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">RAMPART</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const COLS = 25;
    const ROWS = 25;
    const CELL = W / COLS; // 20px

    // Cell types
    const EMPTY = 0;
    const LAND = 1;
    const WATER = 2;
    const WALL = 3;
    const CASTLE = 4;
    const RUBBLE = 5;
    const CANNON = 6;

    // Tetris-like wall pieces (relative coords)
    const WALL_PIECES = [
      [[0,0],[1,0],[0,1],[1,1]],           // 2x2 square
      [[0,0],[1,0],[2,0]],                  // horizontal bar
      [[0,0],[0,1],[0,2]],                  // vertical bar
      [[0,0],[1,0],[1,1]],                  // L shape
      [[0,0],[0,1],[1,1]],                  // reverse L
      [[0,0],[1,0],[2,0],[2,1]],            // big L
      [[0,0],[1,0],[1,1],[2,1]],            // S shape
      [[0,0],[0,1],[1,0]],                  // corner
      [[0,0],[1,0],[2,0],[1,1]],            // T shape
      [[0,0],[1,0],[2,0],[0,1]],            // J shape
    ];

    // Game state
    let score, best = 0, gameState;
    let grid;
    let phase; // 'build', 'battle', 'repair'
    let phaseTimer;
    let wave;

    // Build/Repair phase
    let currentPiece;
    let pieceX, pieceY;
    let nextPiece;

    // Battle phase
    let crosshairX, crosshairY;
    let cannonCooldown;
    let projectiles;
    let explosions;

    // Ships
    let ships;
    let enemyProjectiles;

    // Castles
    let castles;
    let enclosedCastles;

    // Cannons
    let cannons;

    // Phase durations (in seconds)
    const BUILD_TIME = 15;
    const BATTLE_TIME = 18;
    const REPAIR_TIME = 12;

    // Animation
    let lastTime = 0;
    let phaseFlashTimer = 0;
    let keys = {};

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      wave = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'RAMPART';
      overlayText.textContent = 'Build walls, fire cannons, defend!\nPress SPACE to start';

      initGrid();
      ships = [];
      projectiles = [];
      explosions = [];
      enemyProjectiles = [];
      cannons = [];
      enclosedCastles = new Set();

      draw();
    }

    function initGrid() {
      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(EMPTY));

      // Create terrain: left 60% is land, right 40% is water
      // With a jagged coastline
      for (let r = 0; r < ROWS; r++) {
        const coastX = 14 + Math.floor(Math.sin(r * 0.8) * 2) + Math.floor(Math.random() * 2);
        for (let c = 0; c < COLS; c++) {
          if (c < coastX) {
            grid[r][c] = LAND;
          } else {
            grid[r][c] = WATER;
          }
        }
      }

      // Place castles (3x3 areas on land)
      castles = [
        { x: 3, y: 4 },
        { x: 7, y: 12 },
        { x: 3, y: 19 },
      ];

      for (const castle of castles) {
        for (let dy = 0; dy < 3; dy++) {
          for (let dx = 0; dx < 3; dx++) {
            if (castle.y + dy < ROWS && castle.x + dx < COLS) {
              grid[castle.y + dy][castle.x + dx] = CASTLE;
            }
          }
        }
      }
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      wave = 1;
      spawnShips();
      startBuildPhase();
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function startBuildPhase() {
      phase = 'build';
      phaseTimer = BUILD_TIME;
      phaseFlashTimer = 0;
      currentPiece = getRandomPiece();
      nextPiece = getRandomPiece();
      pieceX = 5;
      pieceY = 5;
    }

    function startBattlePhase() {
      // Check enclosure before battle
      checkEnclosures();

      // Place cannons in enclosed areas
      placeCannons();

      phase = 'battle';
      phaseTimer = BATTLE_TIME + Math.min(wave * 2, 10);
      phaseFlashTimer = 0;
      crosshairX = 18;
      crosshairY = 12;
      cannonCooldown = 0;
      projectiles = [];
      explosions = [];
      enemyProjectiles = [];
    }

    function startRepairPhase() {
      phase = 'repair';
      phaseTimer = REPAIR_TIME;
      phaseFlashTimer = 0;
      currentPiece = getRandomPiece();
      nextPiece = getRandomPiece();
      pieceX = 5;
      pieceY = 5;
    }

    function getRandomPiece() {
      const idx = Math.floor(Math.random() * WALL_PIECES.length);
      return WALL_PIECES[idx].map(([x, y]) => [x, y]);
    }

    function rotatePiece(piece) {
      // Rotate 90 degrees clockwise
      const maxX = Math.max(...piece.map(p => p[0]));
      const maxY = Math.max(...piece.map(p => p[1]));
      return piece.map(([x, y]) => [maxY - y, x]);
    }

    function canPlacePiece(piece, px, py) {
      for (const [dx, dy] of piece) {
        const gx = px + dx;
        const gy = py + dy;
        if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return false;
        const cell = grid[gy][gx];
        // Can place on land or rubble, not on water, wall, castle, or cannon
        if (cell !== LAND && cell !== RUBBLE) return false;
      }
      return true;
    }

    function placePiece(piece, px, py) {
      for (const [dx, dy] of piece) {
        const gx = px + dx;
        const gy = py + dy;
        if (gx >= 0 && gx < COLS && gy >= 0 && gy < ROWS) {
          grid[gy][gx] = WALL;
        }
      }
    }

    function checkEnclosures() {
      // Flood fill from edges to find non-enclosed areas
      // Walls and castles are barriers
      // Any castle not reachable from the edge is "enclosed"

      const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      const queue = [];

      // Start flood fill from all edge cells that are land
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
            const cell = grid[r][c];
            if (cell !== WALL && cell !== CASTLE && cell !== CANNON) {
              queue.push([r, c]);
              visited[r][c] = true;
            }
          }
        }
      }

      while (queue.length > 0) {
        const [r, c] = queue.shift();
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        for (const [dr, dc] of dirs) {
          const nr = r + dr;
          const nc = c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc]) {
            const cell = grid[nr][nc];
            if (cell !== WALL && cell !== CASTLE && cell !== CANNON) {
              visited[nr][nc] = true;
              queue.push([nr, nc]);
            }
          }
        }
      }

      // Check which castles are enclosed (not reachable from edges)
      enclosedCastles = new Set();
      for (let i = 0; i < castles.length; i++) {
        const castle = castles[i];
        // Check if any adjacent land cell around the castle is NOT visited
        // A castle is enclosed if the land around it is not reachable from edge
        let enclosed = true;
        for (let dy = -1; dy <= 3; dy++) {
          for (let dx = -1; dx <= 3; dx++) {
            const cy = castle.y + dy;
            const cx = castle.x + dx;
            if (cy >= 0 && cy < ROWS && cx >= 0 && cx < COLS) {
              const cell = grid[cy][cx];
              if ((cell === LAND || cell === RUBBLE) && visited[cy][cx]) {
                enclosed = false;
              }
            }
          }
        }
        if (enclosed) {
          enclosedCastles.add(i);
          // Score for enclosure
          score += 50;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
        }
      }
    }

    function placeCannons() {
      // Remove old cannons from grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] === CANNON) grid[r][c] = LAND;
        }
      }
      cannons = [];

      // Place a cannon near each enclosed castle
      for (const idx of enclosedCastles) {
        const castle = castles[idx];
        // Try to place cannon to the right of castle
        const positions = [
          [castle.x + 3, castle.y + 1],
          [castle.x + 3, castle.y],
          [castle.x + 3, castle.y + 2],
          [castle.x - 1, castle.y + 1],
          [castle.x + 1, castle.y - 1],
          [castle.x + 1, castle.y + 3],
        ];
        for (const [cx, cy] of positions) {
          if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS) {
            const cell = grid[cy][cx];
            if (cell === LAND || cell === RUBBLE) {
              grid[cy][cx] = CANNON;
              cannons.push({ x: cx, y: cy });
              break;
            }
          }
        }
      }
    }

    function spawnShips() {
      ships = [];
      const numShips = Math.min(2 + wave, 6);
      for (let i = 0; i < numShips; i++) {
        const sy = 2 + Math.floor(Math.random() * (ROWS - 4));
        ships.push({
          x: COLS - 1 + Math.random() * 3,
          y: sy,
          hp: 2 + Math.floor(wave / 3),
          maxHp: 2 + Math.floor(wave / 3),
          fireTimer: Math.random() * 3 + 1,
          speed: 0.002 + Math.random() * 0.003,
          bobPhase: Math.random() * Math.PI * 2,
        });
      }
    }

    function fireCannon() {
      if (cannons.length === 0) return;
      if (cannonCooldown > 0) return;

      // Find closest cannon to target
      let bestCannon = cannons[0];
      let bestDist = Infinity;
      for (const c of cannons) {
        const dx = crosshairX - c.x;
        const dy = crosshairY - c.y;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          bestCannon = c;
        }
      }

      projectiles.push({
        x: (bestCannon.x + 0.5) * CELL,
        y: (bestCannon.y + 0.5) * CELL,
        tx: (crosshairX + 0.5) * CELL,
        ty: (crosshairY + 0.5) * CELL,
        speed: 250, // pixels per second
        active: true,
      });

      cannonCooldown = 0.5;
    }

    function update(dt) {
      if (gameState !== 'playing') return;

      phaseTimer -= dt;
      phaseFlashTimer += dt;

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].timer -= dt;
        if (explosions[i].timer <= 0) {
          explosions.splice(i, 1);
        }
      }

      if (phase === 'build' || phase === 'repair') {
        if (phaseTimer <= 0) {
          if (phase === 'build') {
            startBattlePhase();
          } else {
            // Check if player has enclosed at least one castle
            checkEnclosures();
            if (enclosedCastles.size === 0) {
              gameOver();
              return;
            }
            // Next wave
            wave++;
            spawnShips();
            startBattlePhase();
          }
        }
      }

      if (phase === 'battle') {
        cannonCooldown = Math.max(0, cannonCooldown - dt);

        // Update player projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          if (!p.active) { projectiles.splice(i, 1); continue; }

          const dx = p.tx - p.x;
          const dy = p.ty - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 5) {
            // Hit target area
            p.active = false;
            explosions.push({
              x: p.tx, y: p.ty,
              radius: CELL * 1.5,
              timer: 0.4,
              maxTimer: 0.4,
              color: '#4ec',
            });

            // Check ship hits
            for (let j = ships.length - 1; j >= 0; j--) {
              const s = ships[j];
              const sx = (s.x + 0.5) * CELL;
              const sy = (s.y + 0.5) * CELL;
              const hitDist = Math.sqrt((sx - p.tx) ** 2 + (sy - p.ty) ** 2);
              if (hitDist < CELL * 2) {
                s.hp--;
                if (s.hp <= 0) {
                  explosions.push({
                    x: sx, y: sy,
                    radius: CELL * 2.5,
                    timer: 0.6,
                    maxTimer: 0.6,
                    color: '#f80',
                  });
                  ships.splice(j, 1);
                  score += 100;
                  scoreEl.textContent = score;
                  if (score > best) { best = score; bestEl.textContent = best; }
                }
              }
            }
            projectiles.splice(i, 1);
            continue;
          }

          const vx = (dx / dist) * p.speed * dt;
          const vy = (dy / dist) * p.speed * dt;
          p.x += vx;
          p.y += vy;
        }

        // Update enemy ships
        for (const s of ships) {
          // Bob up and down
          s.bobPhase += dt * 2;

          // Move toward coast slowly
          const coastTarget = 15;
          if (s.x > coastTarget) {
            s.x -= s.speed * dt * 60;
          }

          // Fire at walls
          s.fireTimer -= dt;
          if (s.fireTimer <= 0) {
            s.fireTimer = 2 + Math.random() * 3 - Math.min(wave * 0.2, 1.5);

            // Target a wall or castle on land
            let targetX = 2 + Math.floor(Math.random() * 12);
            let targetY = Math.floor(Math.random() * ROWS);

            enemyProjectiles.push({
              x: s.x * CELL,
              y: (s.y + 0.5) * CELL,
              tx: targetX * CELL + CELL / 2,
              ty: targetY * CELL + CELL / 2,
              speed: 120 + wave * 10,
              active: true,
            });
          }
        }

        // Update enemy projectiles
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
          const p = enemyProjectiles[i];
          if (!p.active) { enemyProjectiles.splice(i, 1); continue; }

          const dx = p.tx - p.x;
          const dy = p.ty - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 5) {
            p.active = false;
            explosions.push({
              x: p.tx, y: p.ty,
              radius: CELL * 1.2,
              timer: 0.35,
              maxTimer: 0.35,
              color: '#f44',
            });

            // Destroy walls in blast radius
            const gcx = Math.floor(p.tx / CELL);
            const gcy = Math.floor(p.ty / CELL);
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                const nr = gcy + dr;
                const nc = gcx + dc;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                  if (grid[nr][nc] === WALL) {
                    grid[nr][nc] = RUBBLE;
                  }
                }
              }
            }
            enemyProjectiles.splice(i, 1);
            continue;
          }

          const vx = (dx / dist) * p.speed * dt;
          const vy = (dy / dist) * p.speed * dt;
          p.x += vx;
          p.y += vy;
        }

        // End battle phase
        if (phaseTimer <= 0) {
          startRepairPhase();
        }
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = c * CELL;
          const y = r * CELL;
          const cell = grid[r][c];

          switch (cell) {
            case LAND:
              ctx.fillStyle = '#1a2a1e';
              ctx.fillRect(x, y, CELL, CELL);
              // Subtle grid line
              ctx.strokeStyle = '#1e3322';
              ctx.lineWidth = 0.5;
              ctx.strokeRect(x, y, CELL, CELL);
              break;
            case WATER:
              const waterShade = 0.08 + Math.sin((r + c) * 0.5 + phaseFlashTimer * 1.5) * 0.02;
              ctx.fillStyle = `rgba(30, 60, 120, ${0.6 + waterShade})`;
              ctx.fillRect(x, y, CELL, CELL);
              break;
            case WALL:
              ctx.fillStyle = '#4ec';
              ctx.shadowColor = '#4ec';
              ctx.shadowBlur = 4;
              ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
              ctx.shadowBlur = 0;
              // Brick pattern
              ctx.strokeStyle = '#2a8a7a';
              ctx.lineWidth = 0.5;
              ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
              break;
            case CASTLE:
              ctx.fillStyle = '#b8860b';
              ctx.shadowColor = '#b8860b';
              ctx.shadowBlur = 6;
              ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
              ctx.shadowBlur = 0;
              // Castle pattern
              ctx.fillStyle = '#daa520';
              ctx.fillRect(x + 3, y + 3, CELL - 6, CELL - 6);
              break;
            case RUBBLE:
              ctx.fillStyle = '#1a2a1e';
              ctx.fillRect(x, y, CELL, CELL);
              // Rubble dots
              ctx.fillStyle = '#555';
              ctx.fillRect(x + 3, y + 5, 3, 3);
              ctx.fillRect(x + 9, y + 2, 4, 3);
              ctx.fillRect(x + 6, y + 11, 3, 4);
              break;
            case CANNON:
              ctx.fillStyle = '#1a2a1e';
              ctx.fillRect(x, y, CELL, CELL);
              // Cannon body
              ctx.fillStyle = '#888';
              ctx.shadowColor = '#4ec';
              ctx.shadowBlur = 6;
              ctx.beginPath();
              ctx.arc(x + CELL / 2, y + CELL / 2, CELL / 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
              // Barrel
              ctx.fillStyle = '#aaa';
              ctx.fillRect(x + CELL / 2, y + CELL / 2 - 2, CELL / 2, 4);
              break;
          }
        }
      }

      // Draw enclosure highlights
      if (enclosedCastles.size > 0) {
        for (const idx of enclosedCastles) {
          const castle = castles[idx];
          ctx.strokeStyle = '#4ec';
          ctx.shadowColor = '#4ec';
          ctx.shadowBlur = 8;
          ctx.lineWidth = 2;
          ctx.strokeRect(
            castle.x * CELL - 2,
            castle.y * CELL - 2,
            3 * CELL + 4,
            3 * CELL + 4
          );
          ctx.shadowBlur = 0;
        }
      }

      // Draw ships
      for (const s of ships) {
        const sx = s.x * CELL;
        const sy = (s.y + Math.sin(s.bobPhase) * 0.15) * CELL;

        // Ship hull
        ctx.fillStyle = '#c44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(sx - CELL * 0.3, sy + CELL * 0.6);
        ctx.lineTo(sx + CELL * 1.3, sy + CELL * 0.6);
        ctx.lineTo(sx + CELL, sy + CELL);
        ctx.lineTo(sx, sy + CELL);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Mast
        ctx.strokeStyle = '#a33';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sx + CELL * 0.5, sy + CELL * 0.6);
        ctx.lineTo(sx + CELL * 0.5, sy - CELL * 0.2);
        ctx.stroke();

        // Sail
        ctx.fillStyle = '#faa';
        ctx.beginPath();
        ctx.moveTo(sx + CELL * 0.5, sy - CELL * 0.1);
        ctx.lineTo(sx + CELL * 0.1, sy + CELL * 0.3);
        ctx.lineTo(sx + CELL * 0.5, sy + CELL * 0.5);
        ctx.closePath();
        ctx.fill();

        // HP bar
        const hpRatio = s.hp / s.maxHp;
        ctx.fillStyle = '#400';
        ctx.fillRect(sx, sy - CELL * 0.4, CELL, 3);
        ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : '#f80';
        ctx.fillRect(sx, sy - CELL * 0.4, CELL * hpRatio, 3);
      }

      // Draw player projectiles
      for (const p of projectiles) {
        ctx.fillStyle = '#4ec';
        ctx.shadowColor = '#4ec';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw enemy projectiles
      for (const p of enemyProjectiles) {
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw explosions
      for (const e of explosions) {
        const progress = 1 - (e.timer / e.maxTimer);
        const alpha = 1 - progress;
        const r = e.radius * (0.5 + progress * 0.5);
        ctx.fillStyle = e.color;
        ctx.globalAlpha = alpha * 0.6;
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = alpha * 0.3;
        ctx.beginPath();
        ctx.arc(e.x, e.y, r * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      // Draw piece preview during build/repair
      if ((phase === 'build' || phase === 'repair') && gameState === 'playing' && currentPiece) {
        const canPlace = canPlacePiece(currentPiece, pieceX, pieceY);
        for (const [dx, dy] of currentPiece) {
          const px = (pieceX + dx) * CELL;
          const py = (pieceY + dy) * CELL;
          if (canPlace) {
            ctx.fillStyle = 'rgba(68, 238, 204, 0.5)';
            ctx.shadowColor = '#4ec';
            ctx.shadowBlur = 8;
          } else {
            ctx.fillStyle = 'rgba(255, 68, 68, 0.5)';
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 8;
          }
          ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
          ctx.shadowBlur = 0;
        }

        // Draw next piece preview in top-right corner
        ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
        ctx.fillRect(W - 90, 5, 85, 70);
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 1;
        ctx.strokeRect(W - 90, 5, 85, 70);
        ctx.fillStyle = '#888';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('NEXT', W - 48, 18);

        if (nextPiece) {
          for (const [dx, dy] of nextPiece) {
            const px = W - 72 + dx * 14;
            const py = 28 + dy * 14;
            ctx.fillStyle = '#4ec';
            ctx.fillRect(px, py, 12, 12);
          }
        }
      }

      // Draw crosshair during battle
      if (phase === 'battle' && gameState === 'playing') {
        const cx = (crosshairX + 0.5) * CELL;
        const cy = (crosshairY + 0.5) * CELL;
        const pulse = Math.sin(phaseFlashTimer * 6) * 2 + 10;

        ctx.strokeStyle = '#4ec';
        ctx.shadowColor = '#4ec';
        ctx.shadowBlur = 8;
        ctx.lineWidth = 2;

        // Crosshair lines
        ctx.beginPath();
        ctx.moveTo(cx - pulse, cy);
        ctx.lineTo(cx - 4, cy);
        ctx.moveTo(cx + 4, cy);
        ctx.lineTo(cx + pulse, cy);
        ctx.moveTo(cx, cy - pulse);
        ctx.lineTo(cx, cy - 4);
        ctx.moveTo(cx, cy + 4);
        ctx.lineTo(cx, cy + pulse);
        ctx.stroke();

        // Crosshair circle
        ctx.beginPath();
        ctx.arc(cx, cy, 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Phase & Timer HUD
      if (gameState === 'playing') {
        // Phase banner at top
        ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
        ctx.fillRect(0, 0, W, 24);

        let phaseLabel = '';
        let phaseColor = '#4ec';
        if (phase === 'build') { phaseLabel = 'BUILD PHASE'; phaseColor = '#4ec'; }
        else if (phase === 'battle') { phaseLabel = 'BATTLE PHASE'; phaseColor = '#f44'; }
        else if (phase === 'repair') { phaseLabel = 'REPAIR PHASE'; phaseColor = '#ff0'; }

        // Flash warning when time is low
        const timeLeft = Math.max(0, Math.ceil(phaseTimer));
        const showText = timeLeft > 3 || Math.floor(phaseFlashTimer * 4) % 2 === 0;

        if (showText) {
          ctx.fillStyle = phaseColor;
          ctx.shadowColor = phaseColor;
          ctx.shadowBlur = 10;
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'left';
          ctx.fillText(phaseLabel, 8, 17);
          ctx.shadowBlur = 0;
        }

        // Timer
        ctx.fillStyle = timeLeft <= 3 ? '#f44' : '#e0e0e0';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(`TIME: ${timeLeft}s`, W - 8, 17);

        // Wave indicator
        ctx.fillStyle = '#888';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`WAVE ${wave}`, W / 2, 17);

        // Controls hint at bottom
        ctx.fillStyle = 'rgba(22, 33, 62, 0.75)';
        ctx.fillRect(0, H - 22, W, 22);
        ctx.fillStyle = '#666';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';

        if (phase === 'build' || phase === 'repair') {
          ctx.fillText('ARROWS: Move  Z: Rotate  SPACE: Place', W / 2, H - 7);
        } else if (phase === 'battle') {
          ctx.fillText('ARROWS: Aim  SPACE: Fire', W / 2, H - 7);
        }

        // Enclosed castles count
        ctx.fillStyle = '#4ec';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`Castles: ${enclosedCastles.size}/${castles.length}`, W / 2, H - 30);
      }
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;

      const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
      lastTime = timestamp;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Wave ${wave} â€” Score: ${score}\nNo castles enclosed!\nPress any key to restart`;
      if (score > best) { best = score; bestEl.textContent = best; }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'Z'].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (phase === 'build' || phase === 'repair') {
          switch (e.key) {
            case 'ArrowLeft':
              pieceX = Math.max(0, pieceX - 1);
              break;
            case 'ArrowRight':
              pieceX = Math.min(COLS - 1, pieceX + 1);
              break;
            case 'ArrowUp':
              pieceY = Math.max(0, pieceY - 1);
              break;
            case 'ArrowDown':
              pieceY = Math.min(ROWS - 1, pieceY + 1);
              break;
            case 'z':
            case 'Z':
              currentPiece = rotatePiece(currentPiece);
              break;
            case ' ':
              if (canPlacePiece(currentPiece, pieceX, pieceY)) {
                placePiece(currentPiece, pieceX, pieceY);
                score += 10;
                scoreEl.textContent = score;
                if (score > best) { best = score; bestEl.textContent = best; }
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
              }
              break;
          }
        } else if (phase === 'battle') {
          switch (e.key) {
            case 'ArrowLeft':
              crosshairX = Math.max(0, crosshairX - 1);
              break;
            case 'ArrowRight':
              crosshairX = Math.min(COLS - 1, crosshairX + 1);
              break;
            case 'ArrowUp':
              crosshairY = Math.max(0, crosshairY - 1);
              break;
            case 'ArrowDown':
              crosshairY = Math.min(ROWS - 1, crosshairY + 1);
              break;
            case ' ':
              fireCannon();
              break;
          }
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

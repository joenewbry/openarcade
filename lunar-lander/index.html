<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lunar Lander</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #48f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 136, 255, 0.4); }
    h1 { color: #48f; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 136, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #48f; }
    canvas {
      border: 2px solid #48f;
      box-shadow: 0 0 20px rgba(68, 136, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #48f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>LUNAR LANDER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">LUNAR LANDER</h2>
      <p id="overlayText">Press SPACE to start<br>LEFT/RIGHT: rotate | UP: thrust | Land gently on the pad!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Physics constants
    const GRAVITY = 0.02;
    const THRUST_POWER = 0.06;
    const ROTATION_SPEED = 0.04;
    const MAX_SAFE_VY = 1.2;
    const MAX_SAFE_VX = 0.8;
    const MAX_SAFE_ANGLE = 0.3; // radians from vertical
    const FUEL_MAX = 200;

    // Ship dimensions
    const SHIP_W = 16;
    const SHIP_H = 20;

    // Game state
    let score, best = 0, gameState;
    let ship, terrain, stars, padLeft, padRight, padY;
    let level, explosionParticles, landingParticles;
    let successTimer;
    let keys = {};

    // Generate stars
    function generateStars() {
      stars = [];
      for (let i = 0; i < 120; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * (H * 0.7),
          size: Math.random() * 1.5 + 0.5,
          brightness: Math.random() * 0.5 + 0.5,
          twinkleSpeed: Math.random() * 0.02 + 0.005,
          twinkleOffset: Math.random() * Math.PI * 2
        });
      }
    }

    // Generate terrain with a flat landing pad
    function generateTerrain(lvl) {
      terrain = [];
      const segments = 50;
      const segW = W / segments;

      // Determine pad size (gets smaller with level)
      const padSize = Math.max(3, 8 - lvl); // segments wide
      const padStart = Math.floor(Math.random() * (segments - padSize - 10)) + 5;

      // Base height range gets more extreme with level
      const baseY = H - 80;
      const roughness = Math.min(60, 20 + lvl * 8);

      let points = [];
      let currentY = baseY;

      for (let i = 0; i <= segments; i++) {
        if (i >= padStart && i <= padStart + padSize) {
          // Flat landing pad
          if (i === padStart) {
            padY = currentY;
          }
          points.push({ x: i * segW, y: padY });
        } else {
          // Rough terrain
          currentY += (Math.random() - 0.5) * roughness;
          currentY = Math.max(H - 150, Math.min(H - 30, currentY));
          points.push({ x: i * segW, y: currentY });
        }
      }

      terrain = points;
      padLeft = padStart * segW;
      padRight = (padStart + padSize) * segW;
    }

    // Get terrain height at a given x position
    function getTerrainY(x) {
      if (x < 0 || x > W) return H;
      const segW = W / 50;
      const idx = Math.floor(x / segW);
      if (idx >= terrain.length - 1) return terrain[terrain.length - 1].y;
      const t = (x - terrain[idx].x) / segW;
      return terrain[idx].y * (1 - t) + terrain[idx + 1].y * t;
    }

    // Check if ship is over the pad
    function isOverPad(x) {
      return x >= padLeft && x <= padRight;
    }

    function resetShip() {
      ship = {
        x: W / 2 + (Math.random() - 0.5) * 100,
        y: 50,
        vx: (Math.random() - 0.5) * 1.5,
        vy: 0,
        angle: 0, // 0 = upright
        fuel: FUEL_MAX,
        thrusting: false
      };
    }

    function init() {
      score = 0;
      level = 1;
      scoreEl.textContent = '0';
      explosionParticles = [];
      landingParticles = [];
      successTimer = 0;
      generateStars();
      generateTerrain(level);
      resetShip();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LUNAR LANDER';
      overlayText.innerHTML = 'Press SPACE to start<br>LEFT/RIGHT: rotate | UP: thrust | Land gently on the pad!';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop(ts) {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver(message) {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.innerHTML = `${message}<br>Score: ${score} -- Press any key to restart`;
    }

    function successLanding() {
      // Calculate landing bonus
      const fuelBonus = Math.floor(ship.fuel * 2);
      const velocityBonus = Math.floor((MAX_SAFE_VY - Math.abs(ship.vy)) * 50);
      const accuracyBonus = Math.floor(50 - Math.abs(ship.x - (padLeft + padRight) / 2));
      const levelBonus = level * 100;
      const landingScore = Math.max(0, fuelBonus + velocityBonus + accuracyBonus + levelBonus);

      score += landingScore;
      scoreEl.textContent = score;

      // Generate success particles
      for (let i = 0; i < 20; i++) {
        landingParticles.push({
          x: ship.x + (Math.random() - 0.5) * 20,
          y: ship.y + SHIP_H / 2,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 3 - 1,
          life: 40 + Math.random() * 30,
          color: Math.random() > 0.5 ? '#48f' : '#0f8'
        });
      }

      successTimer = 90; // frames to show success before next level
    }

    function spawnExplosion(x, y) {
      for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        const colors = ['#f44', '#f80', '#ff0', '#48f', '#fff'];
        explosionParticles.push({
          x: x + (Math.random() - 0.5) * 10,
          y: y + (Math.random() - 0.5) * 10,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 1,
          life: 30 + Math.random() * 40,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: Math.random() * 3 + 1
        });
      }
    }

    function update() {
      // Handle success timer (between levels)
      if (successTimer > 0) {
        successTimer--;

        // Update landing particles
        for (let i = landingParticles.length - 1; i >= 0; i--) {
          landingParticles[i].x += landingParticles[i].vx;
          landingParticles[i].y += landingParticles[i].vy;
          landingParticles[i].vy += 0.05;
          landingParticles[i].life--;
          if (landingParticles[i].life <= 0) landingParticles.splice(i, 1);
        }

        if (successTimer === 0) {
          // Advance to next level
          level++;
          landingParticles = [];
          generateTerrain(level);
          resetShip();
        }
        return;
      }

      // Update explosion particles (during game over display, before overlay)
      for (let i = explosionParticles.length - 1; i >= 0; i--) {
        explosionParticles[i].x += explosionParticles[i].vx;
        explosionParticles[i].y += explosionParticles[i].vy;
        explosionParticles[i].vy += 0.04;
        explosionParticles[i].vx *= 0.98;
        explosionParticles[i].life--;
        if (explosionParticles[i].life <= 0) explosionParticles.splice(i, 1);
      }

      // Update landing particles
      for (let i = landingParticles.length - 1; i >= 0; i--) {
        landingParticles[i].x += landingParticles[i].vx;
        landingParticles[i].y += landingParticles[i].vy;
        landingParticles[i].vy += 0.05;
        landingParticles[i].life--;
        if (landingParticles[i].life <= 0) landingParticles.splice(i, 1);
      }

      // Skip ship physics if crashed (fuel = -1 flag)
      if (ship.fuel < 0) return;

      // Ship rotation
      if (keys['ArrowLeft']) ship.angle -= ROTATION_SPEED;
      if (keys['ArrowRight']) ship.angle += ROTATION_SPEED;

      // Clamp angle to reasonable range
      ship.angle = Math.max(-Math.PI, Math.min(Math.PI, ship.angle));

      // Thrust
      ship.thrusting = keys['ArrowUp'] && ship.fuel > 0;
      if (ship.thrusting) {
        // Thrust pushes in the direction the ship faces (up = -angle from vertical)
        ship.vx += Math.sin(ship.angle) * THRUST_POWER;
        ship.vy -= Math.cos(ship.angle) * THRUST_POWER;
        ship.fuel -= 0.3;
        if (ship.fuel < 0) ship.fuel = 0;
      }

      // Gravity
      ship.vy += GRAVITY;

      // Apply velocity
      ship.x += ship.vx;
      ship.y += ship.vy;

      // Wall boundaries
      if (ship.x < 10) { ship.x = 10; ship.vx = Math.abs(ship.vx) * 0.3; }
      if (ship.x > W - 10) { ship.x = W - 10; ship.vx = -Math.abs(ship.vx) * 0.3; }
      if (ship.y < 5) { ship.y = 5; ship.vy = Math.abs(ship.vy) * 0.3; }

      // Check terrain collision
      const terrainY = getTerrainY(ship.x);
      const shipBottom = ship.y + SHIP_H / 2;

      if (shipBottom >= terrainY) {
        // We hit something
        const onPad = isOverPad(ship.x);
        const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
        const angleOk = Math.abs(ship.angle) < MAX_SAFE_ANGLE;
        const vyOk = ship.vy < MAX_SAFE_VY && ship.vy >= 0;
        const vxOk = Math.abs(ship.vx) < MAX_SAFE_VX;

        if (onPad && angleOk && vyOk && vxOk) {
          // Successful landing
          ship.y = terrainY - SHIP_H / 2;
          ship.vx = 0;
          ship.vy = 0;
          ship.angle = 0;
          successLanding();
        } else {
          // Crash!
          spawnExplosion(ship.x, ship.y);
          // Short delay so player sees explosion, then show game over
          ship.vx = 0;
          ship.vy = 0;
          let crashMsg = 'CRASHED!';
          if (!onPad) crashMsg = 'Missed the landing pad!';
          else if (!vyOk) crashMsg = 'Too fast! Descend slower.';
          else if (!vxOk) crashMsg = 'Too much horizontal speed!';
          else if (!angleOk) crashMsg = 'Ship not upright enough!';
          setTimeout(() => {
            if (gameState === 'playing') gameOver(crashMsg);
          }, 600);
          // Disable ship updates
          ship.y = terrainY - SHIP_H / 2;
          ship.fuel = -1; // flag to stop ship update
        }
      }

      // Check off-screen bottom (shouldn't happen with terrain, but safety)
      if (ship.y > H + 50) {
        gameOver('Lost in space!');
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Stars with twinkle
      const time = Date.now() * 0.001;
      for (const s of stars) {
        const alpha = s.brightness * (0.6 + 0.4 * Math.sin(time * s.twinkleSpeed * 100 + s.twinkleOffset));
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      // Terrain
      ctx.beginPath();
      ctx.moveTo(0, H);
      for (const p of terrain) {
        ctx.lineTo(p.x, p.y);
      }
      ctx.lineTo(W, H);
      ctx.closePath();
      ctx.fillStyle = '#16213e';
      ctx.fill();

      // Terrain outline
      ctx.beginPath();
      for (let i = 0; i < terrain.length; i++) {
        if (i === 0) ctx.moveTo(terrain[i].x, terrain[i].y);
        else ctx.lineTo(terrain[i].x, terrain[i].y);
      }
      ctx.strokeStyle = '#48f';
      ctx.shadowColor = '#48f';
      ctx.shadowBlur = 4;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Landing pad (highlighted)
      ctx.beginPath();
      ctx.moveTo(padLeft, padY);
      ctx.lineTo(padRight, padY);
      ctx.strokeStyle = '#0f8';
      ctx.shadowColor = '#0f8';
      ctx.shadowBlur = 12;
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Pad markers
      const padCx = (padLeft + padRight) / 2;
      ctx.fillStyle = '#0f8';
      ctx.shadowColor = '#0f8';
      ctx.shadowBlur = 6;
      ctx.fillRect(padLeft + 2, padY - 6, 3, 6);
      ctx.fillRect(padRight - 5, padY - 6, 3, 6);
      // Center marker (small triangle)
      ctx.beginPath();
      ctx.moveTo(padCx, padY - 8);
      ctx.lineTo(padCx - 4, padY - 2);
      ctx.lineTo(padCx + 4, padY - 2);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Ship (only draw if fuel >= 0, which indicates no crash)
      if (ship.fuel >= 0) {
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);

        // Main body (triangle/pentagon shape)
        ctx.beginPath();
        ctx.moveTo(0, -SHIP_H / 2);          // nose
        ctx.lineTo(-SHIP_W / 2, SHIP_H / 3); // bottom left
        ctx.lineTo(-SHIP_W / 4, SHIP_H / 2); // landing leg left
        ctx.lineTo(SHIP_W / 4, SHIP_H / 2);  // landing leg right
        ctx.lineTo(SHIP_W / 2, SHIP_H / 3);  // bottom right
        ctx.closePath();
        ctx.strokeStyle = '#48f';
        ctx.shadowColor = '#48f';
        ctx.shadowBlur = 12;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Cockpit window
        ctx.beginPath();
        ctx.arc(0, -SHIP_H / 6, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#8bf';
        ctx.fill();

        // Landing legs
        ctx.strokeStyle = '#48f';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-SHIP_W / 4, SHIP_H / 2);
        ctx.lineTo(-SHIP_W / 2 - 2, SHIP_H / 2 + 4);
        ctx.moveTo(SHIP_W / 4, SHIP_H / 2);
        ctx.lineTo(SHIP_W / 2 + 2, SHIP_H / 2 + 4);
        ctx.stroke();

        // Thrust flame
        if (ship.thrusting) {
          const flameLen = 8 + Math.random() * 12;
          const flameW = 4 + Math.random() * 3;
          ctx.beginPath();
          ctx.moveTo(-flameW, SHIP_H / 2);
          ctx.lineTo(0, SHIP_H / 2 + flameLen);
          ctx.lineTo(flameW, SHIP_H / 2);
          ctx.strokeStyle = '#f80';
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 15;
          ctx.lineWidth = 2;
          ctx.stroke();

          // Inner flame
          const innerLen = flameLen * 0.6;
          ctx.beginPath();
          ctx.moveTo(-flameW * 0.4, SHIP_H / 2);
          ctx.lineTo(0, SHIP_H / 2 + innerLen);
          ctx.lineTo(flameW * 0.4, SHIP_H / 2);
          ctx.strokeStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 8;
          ctx.stroke();
        }

        ctx.restore();
        ctx.shadowBlur = 0;
      }

      // Explosion particles
      for (const p of explosionParticles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, p.life / 20);
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Landing success particles
      for (const p of landingParticles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, p.life / 25);
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // HUD - Fuel gauge
      const fuelPct = Math.max(0, ship.fuel) / FUEL_MAX;
      const fuelBarW = 100;
      const fuelBarH = 8;
      const fuelX = 10;
      const fuelY = 10;

      ctx.fillStyle = '#aaa';
      ctx.font = '11px Courier New';
      ctx.fillText('FUEL', fuelX, fuelY + fuelBarH + 14);

      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(fuelX, fuelY, fuelBarW, fuelBarH);

      const fuelColor = fuelPct > 0.3 ? '#0f8' : (fuelPct > 0.1 ? '#f80' : '#f44');
      ctx.fillStyle = fuelColor;
      ctx.shadowColor = fuelColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(fuelX + 1, fuelY + 1, (fuelBarW - 2) * fuelPct, fuelBarH - 2);
      ctx.shadowBlur = 0;

      // HUD - Velocity
      const vx = ship.vx || 0;
      const vy = ship.vy || 0;
      const speed = Math.sqrt(vx * vx + vy * vy);

      ctx.fillStyle = '#aaa';
      ctx.font = '11px Courier New';
      const vyColor = Math.abs(vy) > MAX_SAFE_VY ? '#f44' : '#0f8';
      const vxColor = Math.abs(vx) > MAX_SAFE_VX ? '#f44' : '#0f8';

      ctx.fillStyle = '#aaa';
      ctx.fillText('VX:', W - 110, 18);
      ctx.fillStyle = vxColor;
      ctx.shadowColor = vxColor;
      ctx.shadowBlur = 4;
      ctx.fillText(vx.toFixed(1), W - 80, 18);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#aaa';
      ctx.fillText('VY:', W - 110, 34);
      ctx.fillStyle = vyColor;
      ctx.shadowColor = vyColor;
      ctx.shadowBlur = 4;
      ctx.fillText(vy.toFixed(1), W - 80, 34);
      ctx.shadowBlur = 0;

      // HUD - Altitude
      const altitude = Math.max(0, Math.floor(getTerrainY(ship.x) - ship.y - SHIP_H / 2));
      ctx.fillStyle = '#aaa';
      ctx.fillText('ALT:', W - 110, 50);
      ctx.fillStyle = '#48f';
      ctx.shadowColor = '#48f';
      ctx.shadowBlur = 4;
      ctx.fillText(altitude.toString(), W - 72, 50);
      ctx.shadowBlur = 0;

      // HUD - Level
      ctx.fillStyle = '#aaa';
      ctx.fillText('LEVEL:', 10, 42);
      ctx.fillStyle = '#48f';
      ctx.shadowColor = '#48f';
      ctx.shadowBlur = 4;
      ctx.fillText(level.toString(), 62, 42);
      ctx.shadowBlur = 0;

      // Success message
      if (successTimer > 0) {
        ctx.fillStyle = '#0f8';
        ctx.shadowColor = '#0f8';
        ctx.shadowBlur = 15;
        ctx.font = '24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LANDED!', W / 2, H / 2 - 30);
        ctx.font = '14px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.shadowBlur = 0;
        ctx.fillText(`Level ${level} complete`, W / 2, H / 2);
        ctx.textAlign = 'left';
      }

      // Angle indicator (small arc near top center)
      const indicatorX = W / 2;
      const indicatorY = 18;
      const indicatorR = 12;
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, indicatorR, -Math.PI, 0);
      ctx.stroke();

      // Angle needle
      const needleAngle = -Math.PI / 2 + ship.angle;
      const angleOk = Math.abs(ship.angle) < MAX_SAFE_ANGLE;
      ctx.strokeStyle = angleOk ? '#0f8' : '#f44';
      ctx.shadowColor = angleOk ? '#0f8' : '#f44';
      ctx.shadowBlur = 4;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(indicatorX, indicatorY);
      ctx.lineTo(
        indicatorX + Math.cos(needleAngle) * indicatorR,
        indicatorY + Math.sin(needleAngle) * indicatorR
      );
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

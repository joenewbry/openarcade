<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Breaker Roguelike</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #e48; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 68, 136, 0.5); }
    h1 { color: #e48; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 68, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e48; }
    canvas {
      border: 2px solid #e48;
      box-shadow: 0 0 20px rgba(238, 68, 136, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e48;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BRICK BREAKER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Room: <span id="room">1</span></div>
    <div>Lives: <span id="lives">3</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">BRICK BREAKER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const roomEl = document.getElementById('room');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Theme
    const THEME = '#e48';
    const THEME_RGBA = 'rgba(238, 68, 136, ';

    // Paddle constants
    const BASE_PADDLE_W = 80;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 40;
    const PADDLE_SPEED = 7;

    // Ball constants
    const BALL_R = 6;
    const BASE_BALL_SPEED = 4;

    // Brick constants
    const BRICK_COLS = 10;
    const BRICK_W = (W - 20) / BRICK_COLS;
    const BRICK_H = 18;
    const BRICK_TOP = 60;
    const BRICK_PAD = 2;

    // Brick colors by type
    const BRICK_COLORS = {
      normal: '#e48',
      tough: '#f80',
      hard: '#f44',
      gold: '#ff0'
    };

    // Power-up definitions
    const POWERUPS = [
      { id: 'multiball', name: 'MULTI-BALL', desc: 'Split into 3 balls', icon: '***', color: '#0ff' },
      { id: 'wide', name: 'WIDE PADDLE', desc: 'Paddle 50% wider', icon: '<->', color: '#0f0' },
      { id: 'fireball', name: 'FIREBALL', desc: 'Ball destroys without bouncing', icon: '(~)', color: '#f44' },
      { id: 'sticky', name: 'STICKY PADDLE', desc: 'Ball sticks on catch', icon: '[=]', color: '#ff0' },
      { id: 'extralife', name: 'EXTRA LIFE', desc: '+1 life', icon: '<3', color: '#f0f' },
      { id: 'speeddown', name: 'SLOW BALL', desc: 'Ball moves slower', icon: '>>>', color: '#88f' }
    ];

    // Game state
    let score, best = 0, gameState;
    let lives, room, scoreMultiplier;
    let paddleX, paddleW;
    let balls; // array of {x, y, vx, vy, speed, fireball, stuck, stuckOffset}
    let bricks; // array of {x, y, w, h, hp, maxHp, type, alive}
    let keys = {};
    let mouseX = null;
    let useMouse = false;

    // Active power-ups
    let hasFireball, hasSticky;
    let stickyBall; // ball currently stuck to paddle

    // Power-up selection state
    let choosingPowerup, powerupChoices, selectedPowerup;

    // Room patterns
    function generateRoom(roomNum) {
      const brickArr = [];
      const pattern = (roomNum - 1) % 7;
      const rows = Math.min(5 + Math.floor(roomNum / 2), 10);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          let hp = 1;
          let type = 'normal';
          let alive = true;

          // Different patterns per room
          switch (pattern) {
            case 0: // Full grid
              if (roomNum > 2 && r < 2) { hp = 2; type = 'tough'; }
              break;
            case 1: // Checkerboard
              if ((r + c) % 2 === 0) { alive = false; }
              if (r === 0) { hp = 2; type = 'tough'; }
              break;
            case 2: // Diamond
              {
                const midR = rows / 2, midC = BRICK_COLS / 2;
                const dist = Math.abs(r - midR) + Math.abs(c - midC);
                if (dist > Math.max(midR, midC)) { alive = false; }
                if (dist <= 2) { hp = 3; type = 'hard'; }
              }
              break;
            case 3: // Stripes
              if (c % 3 === 1) { alive = false; }
              if (r < 2) { hp = 2; type = 'tough'; }
              break;
            case 4: // Fortress walls
              if (r >= 2 && r <= rows - 3 && c >= 2 && c <= BRICK_COLS - 3) { alive = false; }
              if (r === 0 || r === rows - 1 || c === 0 || c === BRICK_COLS - 1) { hp = 2; type = 'tough'; }
              if ((r === 0 || r === rows - 1) && (c === 0 || c === BRICK_COLS - 1)) { hp = 3; type = 'hard'; }
              break;
            case 5: // Zigzag
              if ((r % 2 === 0 && c < 2) || (r % 2 === 1 && c >= BRICK_COLS - 2)) { alive = false; }
              if (r % 3 === 0) { hp = 2; type = 'tough'; }
              break;
            case 6: // Cross
              {
                const midR2 = Math.floor(rows / 2), midC2 = Math.floor(BRICK_COLS / 2);
                if (r !== midR2 && c !== midC2 && c !== midC2 - 1) { alive = false; }
                if (r === midR2 && (c === midC2 || c === midC2 - 1)) { hp = 3; type = 'hard'; }
                else if (r === midR2 || c === midC2 || c === midC2 - 1) { hp = 2; type = 'tough'; }
              }
              break;
          }

          // Scale difficulty with room number
          if (roomNum > 4 && alive && Math.random() < 0.1 * (roomNum - 4)) {
            hp = Math.min(hp + 1, 3);
            type = hp === 3 ? 'hard' : 'tough';
          }

          // Rare gold bricks worth bonus points
          if (alive && Math.random() < 0.05) {
            type = 'gold';
            hp = 1;
          }

          if (alive) {
            const bx = 10 + c * BRICK_W + BRICK_PAD;
            const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
            const bw = BRICK_W - BRICK_PAD * 2;
            const bh = BRICK_H - BRICK_PAD * 2;
            brickArr.push({ x: bx, y: by, w: bw, h: bh, hp, maxHp: hp, type, alive: true });
          }
        }
      }
      return brickArr;
    }

    function resetBall() {
      const speed = BASE_BALL_SPEED;
      if (hasSticky) {
        const ball = {
          x: paddleX + paddleW / 2,
          y: PADDLE_Y - BALL_R - 1,
          vx: 0, vy: 0, speed,
          fireball: hasFireball,
          stuck: true,
          stuckOffset: 0
        };
        balls = [ball];
        stickyBall = ball;
      } else {
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
        balls = [{
          x: paddleX + paddleW / 2,
          y: PADDLE_Y - BALL_R - 2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          speed,
          fireball: hasFireball,
          stuck: false,
          stuckOffset: 0
        }];
        stickyBall = null;
      }
    }

    function init() {
      score = 0;
      lives = 3;
      room = 1;
      scoreMultiplier = 1;
      paddleW = BASE_PADDLE_W;
      paddleX = W / 2 - paddleW / 2;
      hasFireball = false;
      hasSticky = false;
      stickyBall = null;
      choosingPowerup = false;
      powerupChoices = [];
      selectedPowerup = 0;
      bricks = generateRoom(1);
      resetBall();
      scoreEl.textContent = '0';
      roomEl.textContent = '1';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BRICK BREAKER';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function updateGameData() {
      window.gameData = {
        paddleX,
        paddleW,
        balls: balls.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, fireball: b.fireball, stuck: b.stuck })),
        bricksAlive: bricks.filter(b => b.alive).length,
        lives,
        room,
        scoreMultiplier,
        hasFireball,
        hasSticky,
        choosingPowerup
      };
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      updateGameData();
      requestAnimationFrame(loop);
    }

    function launchStuckBall() {
      if (stickyBall && stickyBall.stuck) {
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
        stickyBall.vx = Math.cos(angle) * stickyBall.speed;
        stickyBall.vy = Math.sin(angle) * stickyBall.speed;
        stickyBall.stuck = false;
        stickyBall = null;
      }
    }

    function update() {
      if (choosingPowerup) return;

      // Move paddle
      if (useMouse && mouseX !== null) {
        paddleX = mouseX - paddleW / 2;
      } else {
        if (keys['ArrowLeft'] || keys['a']) paddleX -= PADDLE_SPEED;
        if (keys['ArrowRight'] || keys['d']) paddleX += PADDLE_SPEED;
      }
      paddleX = Math.max(0, Math.min(W - paddleW, paddleX));

      // Update stuck ball position
      if (stickyBall && stickyBall.stuck) {
        stickyBall.x = paddleX + paddleW / 2 + stickyBall.stuckOffset;
        stickyBall.y = PADDLE_Y - BALL_R - 1;
      }

      // Update each ball
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        if (ball.stuck) continue;

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall collisions
        if (ball.x - BALL_R <= 0) { ball.x = BALL_R; ball.vx = Math.abs(ball.vx); }
        if (ball.x + BALL_R >= W) { ball.x = W - BALL_R; ball.vx = -Math.abs(ball.vx); }
        if (ball.y - BALL_R <= 0) { ball.y = BALL_R; ball.vy = Math.abs(ball.vy); }

        // Paddle collision
        if (ball.vy > 0 && ball.y + BALL_R >= PADDLE_Y && ball.y + BALL_R <= PADDLE_Y + PADDLE_H + 4 &&
            ball.x >= paddleX - 2 && ball.x <= paddleX + paddleW + 2) {
          if (hasSticky && !stickyBall) {
            ball.stuck = true;
            ball.stuckOffset = ball.x - (paddleX + paddleW / 2);
            ball.vx = 0;
            ball.vy = 0;
            ball.y = PADDLE_Y - BALL_R - 1;
            stickyBall = ball;
          } else {
            ball.y = PADDLE_Y - BALL_R;
            const hit = (ball.x - paddleX) / paddleW;
            const angle = -Math.PI * (0.15 + 0.7 * (1 - hit));
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            ball.vx = Math.cos(angle) * speed;
            ball.vy = Math.sin(angle) * speed;
          }
        }

        // Ball falls below paddle
        if (ball.y - BALL_R > H) {
          balls.splice(i, 1);
          continue;
        }

        // Brick collisions
        for (let j = bricks.length - 1; j >= 0; j--) {
          const brick = bricks[j];
          if (!brick.alive) continue;

          if (ball.x + BALL_R > brick.x && ball.x - BALL_R < brick.x + brick.w &&
              ball.y + BALL_R > brick.y && ball.y - BALL_R < brick.y + brick.h) {

            brick.hp--;
            if (brick.hp <= 0) {
              brick.alive = false;
              const points = brick.type === 'gold' ? 50 : (brick.maxHp * 10);
              score += Math.round(points * scoreMultiplier);
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
              }
            }

            if (!ball.fireball) {
              // Determine bounce direction
              const overlapLeft = (ball.x + BALL_R) - brick.x;
              const overlapRight = (brick.x + brick.w) - (ball.x - BALL_R);
              const overlapTop = (ball.y + BALL_R) - brick.y;
              const overlapBottom = (brick.y + brick.h) - (ball.y - BALL_R);
              const minOverlapX = Math.min(overlapLeft, overlapRight);
              const minOverlapY = Math.min(overlapTop, overlapBottom);
              if (minOverlapX < minOverlapY) {
                ball.vx = -ball.vx;
              } else {
                ball.vy = -ball.vy;
              }
              break; // Only one brick collision per frame for normal balls
            }
            // Fireball plows through -- no bounce, no break
          }
        }
      }

      // All balls lost
      if (balls.length === 0) {
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          gameState = 'over';
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'GAME OVER';
          overlayText.textContent = `Score: ${score} | Room ${room} -- Press SPACE`;
          return;
        }
        hasFireball = false;
        stickyBall = null;
        resetBall();
      }

      // Check room clear
      const allDead = bricks.every(b => !b.alive);
      if (allDead) {
        startPowerupChoice();
      }
    }

    function startPowerupChoice() {
      choosingPowerup = true;
      // Pick 3 random unique power-ups
      const shuffled = [...POWERUPS].sort(() => Math.random() - 0.5);
      powerupChoices = shuffled.slice(0, 3);
      selectedPowerup = 0;
    }

    function applyPowerup(pu) {
      switch (pu.id) {
        case 'multiball':
          // Will split balls when next room starts after launch
          // Mark for split on next update
          break;
        case 'wide':
          paddleW = Math.min(paddleW * 1.5, W * 0.6);
          paddleX = Math.max(0, Math.min(W - paddleW, paddleX));
          break;
        case 'fireball':
          hasFireball = true;
          break;
        case 'sticky':
          hasSticky = true;
          break;
        case 'extralife':
          lives++;
          livesEl.textContent = lives;
          break;
        case 'speeddown':
          // Ball speed reduced -- applied when new ball is created
          break;
      }

      // Advance room
      room++;
      scoreMultiplier = 1 + (room - 1) * 0.25;
      roomEl.textContent = room;
      bricks = generateRoom(room);
      choosingPowerup = false;

      // Reset ball for new room
      resetBall();

      // Handle multi-ball: add 2 extra balls
      if (pu.id === 'multiball' && balls.length > 0) {
        const base = balls[0];
        if (base.stuck) {
          // Launch the base ball first
          launchStuckBall();
        }
        for (let i = 0; i < 2; i++) {
          const angle = -Math.PI / 2 + (i === 0 ? -0.5 : 0.5);
          balls.push({
            x: base.x,
            y: base.y,
            vx: Math.cos(angle) * base.speed,
            vy: Math.sin(angle) * base.speed,
            speed: base.speed,
            fireball: hasFireball,
            stuck: false,
            stuckOffset: 0
          });
        }
      }

      // Handle speed down
      if (pu.id === 'speeddown') {
        balls.forEach(b => {
          const currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
          if (currentSpeed > 0) {
            const newSpeed = Math.max(currentSpeed * 0.7, 2);
            b.vx = (b.vx / currentSpeed) * newSpeed;
            b.vy = (b.vy / currentSpeed) * newSpeed;
            b.speed = newSpeed;
          }
        });
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw bricks
      for (const brick of bricks) {
        if (!brick.alive) continue;
        let color;
        if (brick.type === 'gold') {
          color = BRICK_COLORS.gold;
        } else if (brick.hp >= 3) {
          color = BRICK_COLORS.hard;
        } else if (brick.hp >= 2) {
          color = BRICK_COLORS.tough;
        } else {
          color = BRICK_COLORS.normal;
        }
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.fillRect(brick.x, brick.y, brick.w, brick.h);

        // Show HP indicator for multi-hit bricks
        if (brick.maxHp > 1 && brick.hp > 0) {
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#1a1a2e';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(brick.hp, brick.x + brick.w / 2, brick.y + brick.h / 2 + 3);
        }
      }
      ctx.shadowBlur = 0;

      // Draw paddle
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 12;
      ctx.fillRect(paddleX, PADDLE_Y, paddleW, PADDLE_H);
      ctx.shadowBlur = 0;

      // Sticky indicator on paddle
      if (hasSticky) {
        ctx.fillStyle = '#ff0';
        ctx.fillRect(paddleX, PADDLE_Y, paddleW, 2);
      }

      // Draw balls
      for (const ball of balls) {
        if (ball.fireball) {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 20;
        } else {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = THEME;
          ctx.shadowBlur = 15;
        }
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Lives indicator
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(W - 20 - i * 18, H - 15, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Room multiplier display
      if (scoreMultiplier > 1) {
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 4;
        ctx.font = '12px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText('x' + scoreMultiplier.toFixed(2), 10, H - 12);
        ctx.shadowBlur = 0;
      }

      // Active power-up indicators
      let puY = 30;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      if (hasFireball) {
        ctx.fillStyle = '#f44';
        ctx.fillText('FIRE', W - 8, puY);
        puY += 14;
      }
      if (hasSticky) {
        ctx.fillStyle = '#ff0';
        ctx.fillText('STICKY', W - 8, puY);
        puY += 14;
      }
      if (paddleW > BASE_PADDLE_W) {
        ctx.fillStyle = '#0f0';
        ctx.fillText('WIDE', W - 8, puY);
      }

      // Power-up selection screen
      if (choosingPowerup) {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.88)';
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 10;
        ctx.font = '24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('ROOM ' + room + ' CLEARED!', W / 2, 140);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#aaa';
        ctx.font = '14px Courier New';
        ctx.fillText('Choose a power-up (1/2/3 or Left/Right + Space)', W / 2, 175);

        // Draw power-up cards
        const cardW = 130;
        const cardH = 140;
        const gap = 15;
        const totalW = powerupChoices.length * cardW + (powerupChoices.length - 1) * gap;
        const startX = (W - totalW) / 2;

        for (let i = 0; i < powerupChoices.length; i++) {
          const pu = powerupChoices[i];
          const cx = startX + i * (cardW + gap);
          const cy = 210;

          // Card background
          const isSelected = i === selectedPowerup;
          ctx.fillStyle = isSelected ? '#16213e' : '#0d1525';
          ctx.strokeStyle = isSelected ? pu.color : '#0f3460';
          ctx.lineWidth = isSelected ? 3 : 1;
          if (isSelected) {
            ctx.shadowColor = pu.color;
            ctx.shadowBlur = 15;
          }
          ctx.fillRect(cx, cy, cardW, cardH);
          ctx.strokeRect(cx, cy, cardW, cardH);
          ctx.shadowBlur = 0;

          // Number label
          ctx.fillStyle = isSelected ? pu.color : '#555';
          ctx.font = '12px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('[' + (i + 1) + ']', cx + cardW / 2, cy + 20);

          // Icon
          ctx.fillStyle = pu.color;
          ctx.font = '20px Courier New';
          ctx.fillText(pu.icon, cx + cardW / 2, cy + 52);

          // Name
          ctx.fillStyle = pu.color;
          ctx.font = 'bold 11px Courier New';
          ctx.fillText(pu.name, cx + cardW / 2, cy + 80);

          // Description
          ctx.fillStyle = '#aaa';
          ctx.font = '10px Courier New';
          // Word wrap description
          const words = pu.desc.split(' ');
          let line = '';
          let lineY = cy + 100;
          for (const word of words) {
            const test = line + (line ? ' ' : '') + word;
            if (ctx.measureText(test).width > cardW - 16) {
              ctx.fillText(line, cx + cardW / 2, lineY);
              line = word;
              lineY += 14;
            } else {
              line = test;
            }
          }
          if (line) ctx.fillText(line, cx + cardW / 2, lineY);
        }
      }
    }

    // Keyboard input
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') {
          init();
        }
        return;
      }

      if (gameState === 'playing') {
        // Launch stuck ball
        if (e.key === ' ') {
          launchStuckBall();
        }

        // Power-up selection
        if (choosingPowerup) {
          if (e.key === 'ArrowLeft') {
            selectedPowerup = (selectedPowerup - 1 + powerupChoices.length) % powerupChoices.length;
          } else if (e.key === 'ArrowRight') {
            selectedPowerup = (selectedPowerup + 1) % powerupChoices.length;
          } else if (e.key === ' ' || e.key === 'Enter') {
            applyPowerup(powerupChoices[selectedPowerup]);
          } else if (e.key === '1' || e.key === '2' || e.key === '3') {
            const idx = parseInt(e.key) - 1;
            if (idx < powerupChoices.length) {
              applyPowerup(powerupChoices[idx]);
            }
          }
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Mouse input
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      useMouse = true;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'playing') {
        launchStuckBall();

        // Power-up selection via click
        if (choosingPowerup) {
          const rect = canvas.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;

          const cardW = 130;
          const cardH = 140;
          const gap = 15;
          const totalW = powerupChoices.length * cardW + (powerupChoices.length - 1) * gap;
          const startX = (W - totalW) / 2;
          const cy = 210;

          for (let i = 0; i < powerupChoices.length; i++) {
            const cx = startX + i * (cardW + gap);
            if (clickX >= cx && clickX <= cx + cardW && clickY >= cy && clickY <= cy + cardH) {
              applyPowerup(powerupChoices[i]);
              break;
            }
          }
        }
      }
    });

    // Disable keyboard movement when mouse is actively used
    canvas.addEventListener('mouseleave', () => {
      useMouse = false;
    });

    window.gameData = {};

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

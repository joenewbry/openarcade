<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moon Patrol</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #48e; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68,136,238,0.5); }
    h1 { color: #48e; font-size: 2rem; text-shadow: 0 0 15px rgba(68,136,238,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #48e; }
    canvas {
      border: 2px solid #48e;
      box-shadow: 0 0 20px rgba(68,136,238,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #48e;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>MOON PATROL</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">MOON PATROL</h2>
      <p id="overlayText">Press SPACE to start<br>SPACE/UP: Jump | Z: Fire forward | X: Fire up</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Theme
    const THEME = '#48e';
    const THEME_DIM = '#246';

    // Ground
    const GROUND_Y = 320;
    const GROUND_THICK = 4;

    // Buggy
    const BUGGY_X = 100; // fixed screen x
    const BUGGY_W = 40;
    const BUGGY_H = 20;
    const WHEEL_R = 8;
    const JUMP_VEL = -8;
    const GRAVITY = 0.35;

    // Scroll
    const BASE_SCROLL = 2.5;
    const MAX_SCROLL = 5.5;

    // Checkpoints
    const CHECKPOINT_DIST = 800;

    let score, best = 0, lives, gameState;
    let buggy, scrollX, scrollSpeed, frameCount;
    let terrain, craters, rocks, mines, ufos, bombs;
    let bulletsF, bulletsU, particles;
    let checkpoint, checkpointLetter;
    let keys = {};
    let fireCooldownF, fireCooldownU;
    let lastSpawnX;
    let difficulty;

    // Parallax mountains
    let mountains = [];
    function generateMountains() {
      mountains = [];
      let x = 0;
      while (x < 1800) {
        const w = 60 + Math.random() * 120;
        const h = 30 + Math.random() * 60;
        mountains.push({ x, w, h });
        x += w * 0.6 + Math.random() * 40;
      }
    }

    // Stars
    let stars = [];
    function generateStars() {
      stars = [];
      for (let i = 0; i < 80; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * (GROUND_Y - 40),
          size: Math.random() < 0.3 ? 2 : 1,
          twinkle: Math.random() * Math.PI * 2
        });
      }
    }

    // Terrain generation: create surface segments with craters
    function generateTerrain(startX, endX) {
      // Remove terrain behind us
      craters = craters.filter(c => c.x + c.w > scrollX - 100);
      rocks = rocks.filter(r => r.x > scrollX - 100);
      mines = mines.filter(m => m.x > scrollX - 100);

      const segStart = Math.max(startX, lastSpawnX);
      let x = segStart;
      while (x < endX) {
        const roll = Math.random();
        if (roll < 0.15 * difficulty) {
          // Crater
          const w = 30 + Math.random() * 40;
          craters.push({ x, w, depth: 15 + Math.random() * 15 });
          x += w + 40 + Math.random() * 60;
        } else if (roll < 0.25 * difficulty) {
          // Rock
          const h = 12 + Math.random() * 14;
          rocks.push({ x, w: 16 + Math.random() * 10, h, hit: false });
          x += 60 + Math.random() * 80;
        } else if (roll < 0.32 * difficulty) {
          // Mine
          mines.push({ x, timer: 0, active: true });
          x += 80 + Math.random() * 100;
        } else {
          x += 40 + Math.random() * 60;
        }
      }
      lastSpawnX = x;
    }

    function spawnUFO() {
      if (Math.random() < 0.012 * difficulty && ufos.length < 2 + Math.floor(difficulty)) {
        const ufoX = scrollX + W + 20;
        const ufoY = 40 + Math.random() * 80;
        const speed = 1.5 + Math.random() * 1.5 * difficulty;
        ufos.push({
          x: ufoX, y: ufoY,
          vx: -speed,
          vy: Math.sin(Math.random() * Math.PI) * 0.5,
          bombTimer: 60 + Math.floor(Math.random() * 80),
          alive: true
        });
      }
    }

    function init() {
      score = 0;
      lives = 3;
      scrollX = 0;
      scrollSpeed = BASE_SCROLL;
      frameCount = 0;
      difficulty = 1;
      buggy = { y: GROUND_Y, vy: 0, grounded: true, alive: true, wheelPhase: 0, suspF: 0, suspR: 0 };
      craters = [];
      rocks = [];
      mines = [];
      ufos = [];
      bombs = [];
      bulletsF = [];
      bulletsU = [];
      particles = [];
      checkpoint = CHECKPOINT_DIST;
      checkpointLetter = 0;
      fireCooldownF = 0;
      fireCooldownU = 0;
      lastSpawnX = W + 50;

      generateMountains();
      generateStars();
      generateTerrain(W + 50, scrollX + W * 3);

      scoreEl.textContent = '0';
      livesEl.textContent = lives;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'MOON PATROL';
      overlayText.innerHTML = 'Press SPACE to start<br>SPACE/UP: Jump | Z: Fire forward | X: Fire up';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function respawn() {
      buggy.y = GROUND_Y;
      buggy.vy = 0;
      buggy.grounded = true;
      buggy.alive = true;
      buggy.suspF = 0;
      buggy.suspR = 0;
      // Clear nearby hazards
      const bx = scrollX + BUGGY_X;
      craters = craters.filter(c => Math.abs(c.x + c.w / 2 - bx) > 80);
      rocks = rocks.filter(r => Math.abs(r.x - bx) > 80);
      mines = mines.filter(m => Math.abs(m.x - bx) > 80);
      bombs = [];
    }

    function addParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 1,
          life: 15 + Math.random() * 15,
          color
        });
      }
    }

    function killBuggy() {
      if (!buggy.alive) return;
      buggy.alive = false;
      addParticles(BUGGY_X + BUGGY_W / 2, buggy.y - BUGGY_H / 2, 20, THEME);
      addParticles(BUGGY_X + BUGGY_W / 2, buggy.y - BUGGY_H / 2, 10, '#fff');
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        setTimeout(gameOver, 600);
      } else {
        setTimeout(respawn, 800);
      }
    }

    // Get ground height at a world-x position (accounts for craters)
    function getGroundAt(wx) {
      for (const c of craters) {
        if (wx > c.x && wx < c.x + c.w) {
          return GROUND_Y + c.depth;
        }
      }
      return GROUND_Y;
    }

    function update() {
      frameCount++;

      // Difficulty scales with distance
      difficulty = 1 + Math.min(scrollX / 5000, 2.5);
      scrollSpeed = BASE_SCROLL + (MAX_SCROLL - BASE_SCROLL) * Math.min(scrollX / 8000, 1);

      // Scroll
      if (buggy.alive) {
        scrollX += scrollSpeed;
      }

      // Score = distance
      const distScore = Math.floor(scrollX / 10);
      if (distScore > score) {
        score = distScore;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
      }

      // Checkpoints
      if (scrollX > checkpoint && checkpointLetter < 26) {
        addParticles(W / 2, GROUND_Y - 40, 8, '#ff0');
        score += 100;
        scoreEl.textContent = score;
        checkpointLetter++;
        checkpoint += CHECKPOINT_DIST;
      }

      // Generate more terrain ahead
      if (lastSpawnX < scrollX + W * 2) {
        generateTerrain(lastSpawnX, scrollX + W * 3);
      }

      // Spawn UFOs
      spawnUFO();

      // Buggy physics
      if (buggy.alive) {
        // Wheel animation
        buggy.wheelPhase += scrollSpeed * 0.15;

        // Jump
        if ((keys[' '] || keys['ArrowUp']) && buggy.grounded) {
          buggy.vy = JUMP_VEL;
          buggy.grounded = false;
        }

        // Gravity
        buggy.vy += GRAVITY;
        buggy.y += buggy.vy;

        // Ground collision
        const buggyWorldX = scrollX + BUGGY_X;
        const groundFront = getGroundAt(buggyWorldX + BUGGY_W);
        const groundRear = getGroundAt(buggyWorldX);
        const groundCenter = getGroundAt(buggyWorldX + BUGGY_W / 2);
        const effectiveGround = Math.min(groundFront, groundRear, groundCenter);

        if (buggy.y >= effectiveGround) {
          buggy.y = effectiveGround;
          buggy.vy = 0;
          buggy.grounded = true;
        } else {
          buggy.grounded = false;
        }

        // Check if buggy fell into crater
        const deepFront = getGroundAt(buggyWorldX + BUGGY_W);
        const deepRear = getGroundAt(buggyWorldX);
        if (buggy.grounded && deepFront > GROUND_Y + 5 && deepRear > GROUND_Y + 5) {
          // Both wheels in crater
          if (buggy.y > GROUND_Y + 8) {
            killBuggy();
          }
        }

        // Suspension animation
        const targetSuspF = buggy.grounded ? (groundFront - GROUND_Y) * 0.3 : 0;
        const targetSuspR = buggy.grounded ? (groundRear - GROUND_Y) * 0.3 : 0;
        buggy.suspF += (targetSuspF - buggy.suspF) * 0.3;
        buggy.suspR += (targetSuspR - buggy.suspR) * 0.3;

        // Rock collision
        for (let i = rocks.length - 1; i >= 0; i--) {
          const r = rocks[i];
          if (r.hit) continue;
          const rx = r.x - scrollX;
          if (rx > BUGGY_X - 5 && rx < BUGGY_X + BUGGY_W + 5) {
            if (buggy.y > GROUND_Y - r.h + 5) {
              killBuggy();
              break;
            }
          }
        }

        // Mine collision
        for (const m of mines) {
          if (!m.active) continue;
          const mx = m.x - scrollX;
          if (mx > BUGGY_X - 10 && mx < BUGGY_X + BUGGY_W + 10) {
            if (buggy.grounded || buggy.y > GROUND_Y - 15) {
              m.active = false;
              addParticles(BUGGY_X + BUGGY_W / 2, GROUND_Y - 5, 12, '#f80');
              killBuggy();
              break;
            }
          }
        }

        // Bomb collision
        for (let i = bombs.length - 1; i >= 0; i--) {
          const b = bombs[i];
          const bx = b.x - scrollX;
          const by = b.y;
          if (bx > BUGGY_X - 8 && bx < BUGGY_X + BUGGY_W + 8 &&
              by > buggy.y - BUGGY_H - 8 && by < buggy.y + 8) {
            bombs.splice(i, 1);
            addParticles(bx, by, 10, '#f44');
            killBuggy();
            break;
          }
        }

        // Fire forward
        if (fireCooldownF > 0) fireCooldownF--;
        if (keys['z'] && fireCooldownF === 0 && buggy.alive) {
          bulletsF.push({ x: scrollX + BUGGY_X + BUGGY_W + 5, y: buggy.y - BUGGY_H / 2 });
          fireCooldownF = 12;
        }

        // Fire up
        if (fireCooldownU > 0) fireCooldownU--;
        if (keys['x'] && fireCooldownU === 0 && buggy.alive) {
          bulletsU.push({ x: scrollX + BUGGY_X + BUGGY_W / 2, y: buggy.y - BUGGY_H });
          fireCooldownU = 15;
        }
      }

      // Update forward bullets
      for (let i = bulletsF.length - 1; i >= 0; i--) {
        bulletsF[i].x += 7;
        if (bulletsF[i].x > scrollX + W + 20) {
          bulletsF.splice(i, 1);
          continue;
        }
        // Hit rocks
        for (let j = rocks.length - 1; j >= 0; j--) {
          const r = rocks[j];
          if (r.hit) continue;
          if (Math.abs(bulletsF[i].x - r.x) < r.w / 2 + 5 &&
              bulletsF[i].y > GROUND_Y - r.h - 5 && bulletsF[i].y < GROUND_Y + 5) {
            r.hit = true;
            addParticles(r.x - scrollX, GROUND_Y - r.h / 2, 8, '#888');
            score += 25;
            scoreEl.textContent = score;
            bulletsF.splice(i, 1);
            break;
          }
        }
      }

      // Update upward bullets
      for (let i = bulletsU.length - 1; i >= 0; i--) {
        bulletsU[i].y -= 6;
        if (bulletsU[i].y < -20) {
          bulletsU.splice(i, 1);
          continue;
        }
        // Hit UFOs
        for (let j = ufos.length - 1; j >= 0; j--) {
          const u = ufos[j];
          if (!u.alive) continue;
          if (Math.abs(bulletsU[i].x - u.x) < 20 && Math.abs(bulletsU[i].y - u.y) < 15) {
            u.alive = false;
            addParticles(u.x - scrollX, u.y, 12, '#f44');
            score += 50;
            scoreEl.textContent = score;
            bulletsU.splice(i, 1);
            break;
          }
        }
      }

      // Update UFOs
      for (let i = ufos.length - 1; i >= 0; i--) {
        const u = ufos[i];
        if (!u.alive) { ufos.splice(i, 1); continue; }
        u.x += u.vx + scrollSpeed * 0.2; // UFOs move relative to ground somewhat
        u.y += Math.sin(frameCount * 0.05 + i) * 0.5;

        // Drop bombs
        u.bombTimer--;
        if (u.bombTimer <= 0) {
          u.bombTimer = 50 + Math.floor(Math.random() * 60 / difficulty);
          bombs.push({ x: u.x, y: u.y + 10, vy: 2 + Math.random() });
        }

        // Remove if off screen left
        if (u.x < scrollX - 60) {
          ufos.splice(i, 1);
        }
      }

      // Update bombs
      for (let i = bombs.length - 1; i >= 0; i--) {
        bombs[i].y += bombs[i].vy;
        bombs[i].vy += 0.08;
        if (bombs[i].y > GROUND_Y + 10) {
          addParticles(bombs[i].x - scrollX, GROUND_Y, 6, '#f80');
          bombs.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].vy += 0.05;
        particles[i].life--;
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      // Clean up destroyed rocks
      rocks = rocks.filter(r => !r.hit || r.x > scrollX - 100);
    }

    function draw() {
      // Sky gradient
      const grad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      grad.addColorStop(0, '#0a0a1a');
      grad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, GROUND_Y);

      // Below ground
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

      // Stars
      for (const s of stars) {
        const twinkle = Math.sin(frameCount * 0.03 + s.twinkle);
        const alpha = 0.3 + twinkle * 0.3;
        ctx.fillStyle = `rgba(255,255,255,${Math.max(0.1, alpha)})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      // Parallax mountains (back layer)
      const mOffset = (scrollX * 0.15) % 1200;
      ctx.fillStyle = '#0f1525';
      for (const m of mountains) {
        const mx = m.x - mOffset;
        const screenX = mx < -200 ? mx + 1200 : mx;
        if (screenX > W + 200 || screenX + m.w < -200) continue;
        ctx.beginPath();
        ctx.moveTo(screenX, GROUND_Y);
        ctx.lineTo(screenX + m.w * 0.3, GROUND_Y - m.h);
        ctx.lineTo(screenX + m.w * 0.5, GROUND_Y - m.h * 0.8);
        ctx.lineTo(screenX + m.w * 0.7, GROUND_Y - m.h * 0.95);
        ctx.lineTo(screenX + m.w, GROUND_Y);
        ctx.fill();
      }

      // Parallax mountains (front layer)
      const mOffset2 = (scrollX * 0.3) % 1400;
      ctx.fillStyle = '#141830';
      for (const m of mountains) {
        const mx = m.x * 1.3 + 200 - mOffset2;
        const screenX = mx < -200 ? mx + 1400 : mx;
        if (screenX > W + 200 || screenX + m.w * 0.7 < -200) continue;
        const mw = m.w * 0.7;
        const mh = m.h * 0.5;
        ctx.beginPath();
        ctx.moveTo(screenX, GROUND_Y);
        ctx.lineTo(screenX + mw * 0.4, GROUND_Y - mh);
        ctx.lineTo(screenX + mw * 0.6, GROUND_Y - mh * 0.7);
        ctx.lineTo(screenX + mw, GROUND_Y);
        ctx.fill();
      }

      // Draw ground line
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;

      // Draw terrain with craters
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      let px = 0;
      while (px <= W) {
        const wx = scrollX + px;
        let inCrater = false;
        for (const c of craters) {
          if (wx >= c.x && wx <= c.x + c.w) {
            inCrater = true;
            const cx = (wx - c.x) / c.w; // 0 to 1
            const craterY = GROUND_Y + Math.sin(cx * Math.PI) * c.depth;
            ctx.lineTo(px, craterY);
            break;
          }
        }
        if (!inCrater) {
          ctx.lineTo(px, GROUND_Y);
        }
        px += 2;
      }
      ctx.lineTo(W, H);
      ctx.lineTo(0, H);
      ctx.closePath();
      ctx.fillStyle = '#16213e';
      ctx.fill();

      // Ground surface line
      ctx.strokeStyle = THEME;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 4;
      ctx.beginPath();
      px = 0;
      while (px <= W) {
        const wx = scrollX + px;
        let gy = GROUND_Y;
        for (const c of craters) {
          if (wx >= c.x && wx <= c.x + c.w) {
            const cx = (wx - c.x) / c.w;
            gy = GROUND_Y + Math.sin(cx * Math.PI) * c.depth;
            break;
          }
        }
        if (px === 0) ctx.moveTo(px, gy);
        else ctx.lineTo(px, gy);
        px += 2;
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Draw rocks
      for (const r of rocks) {
        if (r.hit) continue;
        const rx = r.x - scrollX;
        if (rx < -30 || rx > W + 30) continue;
        ctx.fillStyle = '#556';
        ctx.shadowColor = '#48e';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(rx - r.w / 2, GROUND_Y);
        ctx.lineTo(rx - r.w / 3, GROUND_Y - r.h * 0.7);
        ctx.lineTo(rx, GROUND_Y - r.h);
        ctx.lineTo(rx + r.w / 3, GROUND_Y - r.h * 0.6);
        ctx.lineTo(rx + r.w / 2, GROUND_Y);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw mines
      for (const m of mines) {
        if (!m.active) continue;
        const mx = m.x - scrollX;
        if (mx < -20 || mx > W + 20) continue;
        const pulse = Math.sin(frameCount * 0.1) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(255, 100, 0, ${pulse})`;
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(mx, GROUND_Y - 6, 6, 0, Math.PI * 2);
        ctx.fill();
        // Spikes
        ctx.strokeStyle = '#f80';
        ctx.lineWidth = 1.5;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
          ctx.beginPath();
          ctx.moveTo(mx + Math.cos(a) * 6, GROUND_Y - 6 + Math.sin(a) * 6);
          ctx.lineTo(mx + Math.cos(a) * 10, GROUND_Y - 6 + Math.sin(a) * 10);
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
      }

      // Draw checkpoints
      for (let i = 0; i <= checkpointLetter; i++) {
        const cpX = (i + 1) * CHECKPOINT_DIST - scrollX;
        if (cpX < -20 || cpX > W + 20) continue;
        const passed = i < checkpointLetter;
        ctx.strokeStyle = passed ? '#333' : '#ff0';
        ctx.shadowColor = passed ? '#333' : '#ff0';
        ctx.shadowBlur = passed ? 0 : 6;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cpX, GROUND_Y);
        ctx.lineTo(cpX, GROUND_Y - 50);
        ctx.stroke();
        ctx.font = 'bold 14px Courier New';
        ctx.fillStyle = passed ? '#444' : '#ff0';
        ctx.textAlign = 'center';
        ctx.fillText(String.fromCharCode(65 + i), cpX, GROUND_Y - 55);
        ctx.shadowBlur = 0;
      }

      // Draw UFOs
      for (const u of ufos) {
        if (!u.alive) continue;
        const ux = u.x - scrollX;
        const uy = u.y;
        if (ux < -30 || ux > W + 30) continue;
        // Saucer body
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.ellipse(ux, uy, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        // Dome
        ctx.fillStyle = '#f88';
        ctx.beginPath();
        ctx.ellipse(ux, uy - 4, 10, 8, 0, Math.PI, 0);
        ctx.fill();
        // Lights
        const blink = Math.sin(frameCount * 0.15 + u.x) > 0;
        ctx.fillStyle = blink ? '#ff0' : '#880';
        ctx.beginPath();
        ctx.arc(ux - 10, uy + 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(ux + 10, uy + 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw bombs
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      for (const b of bombs) {
        const bx = b.x - scrollX;
        ctx.beginPath();
        ctx.arc(bx, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Draw buggy
      if (buggy.alive) {
        const bx = BUGGY_X;
        const by = buggy.y;

        // Wheel positions
        const rearWheelX = bx + 6;
        const frontWheelX = bx + BUGGY_W - 6;
        const rearWheelY = by - WHEEL_R + buggy.suspR;
        const frontWheelY = by - WHEEL_R + buggy.suspF;

        // Body - tilts based on suspension
        const bodyAngle = Math.atan2(buggy.suspF - buggy.suspR, BUGGY_W - 12);
        ctx.save();
        ctx.translate(bx + BUGGY_W / 2, (rearWheelY + frontWheelY) / 2 - WHEEL_R - 2);
        ctx.rotate(bodyAngle);

        // Main body
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 10;
        ctx.fillRect(-BUGGY_W / 2 + 4, -BUGGY_H / 2, BUGGY_W - 8, BUGGY_H / 2 + 2);

        // Cabin
        ctx.fillStyle = '#5af';
        ctx.fillRect(-BUGGY_W / 2 + 8, -BUGGY_H / 2 - 6, BUGGY_W / 2 - 4, 8);

        // Antenna
        ctx.strokeStyle = THEME;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-BUGGY_W / 2 + 10, -BUGGY_H / 2 - 6);
        ctx.lineTo(-BUGGY_W / 2 + 6, -BUGGY_H / 2 - 16);
        ctx.stroke();
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(-BUGGY_W / 2 + 6, -BUGGY_H / 2 - 17, 2, 0, Math.PI * 2);
        ctx.fill();

        // Gun barrel (forward)
        ctx.fillStyle = '#aaa';
        ctx.fillRect(BUGGY_W / 2 - 8, -2, 12, 3);

        ctx.restore();
        ctx.shadowBlur = 0;

        // Wheels
        drawWheel(rearWheelX, rearWheelY);
        drawWheel(frontWheelX, frontWheelY);

        // Suspension links
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        const bodyBaseY = (rearWheelY + frontWheelY) / 2 - WHEEL_R + 2;
        ctx.beginPath();
        ctx.moveTo(rearWheelX, bodyBaseY);
        ctx.lineTo(rearWheelX, rearWheelY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(frontWheelX, bodyBaseY);
        ctx.lineTo(frontWheelX, frontWheelY);
        ctx.stroke();
      }

      // Draw forward bullets
      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 6;
      for (const b of bulletsF) {
        const bx = b.x - scrollX;
        ctx.fillRect(bx - 4, b.y - 1, 8, 2);
      }

      // Draw upward bullets
      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 6;
      for (const b of bulletsU) {
        const bx = b.x - scrollX;
        ctx.fillRect(bx - 1, b.y - 4, 2, 8);
      }
      ctx.shadowBlur = 0;

      // Draw particles
      for (const p of particles) {
        const alpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, alpha);
        ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
      }
      ctx.globalAlpha = 1;

      // HUD: checkpoint progress bar
      const progress = (scrollX % CHECKPOINT_DIST) / CHECKPOINT_DIST;
      const barW = 100;
      const barH = 6;
      const barX = W - barW - 10;
      const barY = 10;
      ctx.fillStyle = '#16213e';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = THEME;
      ctx.fillRect(barX, barY, barW * progress, barH);
      ctx.strokeStyle = THEME_DIM;
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barW, barH);

      // Current checkpoint letter
      const currentLetter = String.fromCharCode(65 + Math.min(checkpointLetter, 25));
      const nextLetter = String.fromCharCode(65 + Math.min(checkpointLetter + 1, 25));
      ctx.font = '10px Courier New';
      ctx.fillStyle = '#888';
      ctx.textAlign = 'left';
      ctx.fillText(currentLetter, barX - 12, barY + 6);
      ctx.textAlign = 'right';
      ctx.fillText(nextLetter, barX + barW + 14, barY + 6);

      // Lives display on canvas
      for (let i = 0; i < lives; i++) {
        const lx = 12 + i * 20;
        const ly = 12;
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 4;
        ctx.fillRect(lx, ly, 12, 6);
        ctx.beginPath();
        ctx.arc(lx + 2, ly + 8, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(lx + 10, ly + 8, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawWheel(x, y) {
      ctx.strokeStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, WHEEL_R, 0, Math.PI * 2);
      ctx.stroke();
      // Spokes
      ctx.lineWidth = 1;
      for (let a = 0; a < 4; a++) {
        const angle = buggy.wheelPhase + (a * Math.PI / 2);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * (WHEEL_R - 2), y + Math.sin(angle) * (WHEEL_R - 2));
        ctx.stroke();
      }
      // Hub
      ctx.fillStyle = THEME;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'x'].includes(e.key)) {
        e.preventDefault();
      }

      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Donkey Kong</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #e82; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 136, 34, 0.5); }
    h1 { color: #e82; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 136, 34, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e82; }
    canvas {
      border: 2px solid #e82;
      box-shadow: 0 0 20px rgba(238, 136, 34, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e82;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DONKEY KONG</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">DONKEY KONG</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let level = 1;
    let lives = 3;

    // Theme color
    const THEME = '#e82';
    const THEME_RGB = [238, 136, 34];

    // Physics
    const GRAVITY = 0.45;
    const JUMP_VEL = -8.5;
    const MOVE_SPEED = 3;
    const CLIMB_SPEED = 2.5;

    // Player
    let player = {};
    // Gorilla
    let gorilla = {};
    // Princess
    let princess = {};
    // Barrels
    let barrels = [];
    // Platforms
    let platforms = [];
    // Ladders
    let ladders = [];

    let keys = {};
    let barrelTimer = 0;
    let barrelInterval = 120; // frames between barrel throws
    let frameCount = 0;
    let animFrame = 0;
    let jumpedBarrels = new Set();
    let reachedTop = false;
    let levelTransition = 0;
    let deathTimer = 0;

    // Build level layout
    function buildLevel() {
      platforms = [];
      ladders = [];

      const PH = 8; // platform height
      const pw = W;

      // Ground platform (level 0) - flat
      platforms.push({ x: 0, y: H - 30, w: pw, h: PH, slope: 0 });

      // Platform 1 - slopes right (going up from left to right)
      platforms.push({ x: 0, y: H - 120, w: pw, h: PH, slope: 0.04 });

      // Platform 2 - slopes left
      platforms.push({ x: 0, y: H - 210, w: pw, h: PH, slope: -0.04 });

      // Platform 3 - slopes right
      platforms.push({ x: 0, y: H - 300, w: pw, h: PH, slope: 0.04 });

      // Platform 4 - slopes left
      platforms.push({ x: 0, y: H - 390, w: pw, h: PH, slope: -0.04 });

      // Top platform (gorilla + princess) - short
      platforms.push({ x: 60, y: H - 470, w: 200, h: PH, slope: 0 });

      // Ladders connecting platforms
      // Between ground and platform 1
      ladders.push({ x: 400, y: H - 120, h: 90 });
      ladders.push({ x: 120, y: H - 120, h: 90, broken: true, breakGap: 30 });

      // Between platform 1 and platform 2
      ladders.push({ x: 80, y: H - 210, h: 90 });
      ladders.push({ x: 340, y: H - 210, h: 90, broken: true, breakGap: 25 });

      // Between platform 2 and platform 3
      ladders.push({ x: 380, y: H - 300, h: 90 });
      ladders.push({ x: 200, y: H - 300, h: 90, broken: true, breakGap: 30 });

      // Between platform 3 and platform 4
      ladders.push({ x: 100, y: H - 390, h: 90 });
      ladders.push({ x: 320, y: H - 390, h: 90, broken: true, breakGap: 28 });

      // Between platform 4 and top
      ladders.push({ x: 130, y: H - 470, h: 80 });
    }

    function getPlatformYAt(plat, x) {
      // Return the y position (top of platform) at a given x coordinate
      let relX = x - plat.x;
      return plat.y - plat.slope * relX;
    }

    function resetPlayer() {
      player = {
        x: 40,
        y: H - 30 - 28,
        w: 20,
        h: 28,
        vx: 0,
        vy: 0,
        onGround: true,
        climbing: false,
        facingRight: true,
        walkFrame: 0,
        climbFrame: 0
      };
    }

    function init() {
      score = 0;
      level = 1;
      lives = 3;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DONKEY KONG';
      overlayText.textContent = 'Press SPACE to start';
      buildLevel();
      resetPlayer();
      barrels = [];
      barrelTimer = 0;
      frameCount = 0;
      jumpedBarrels = new Set();
      reachedTop = false;
      levelTransition = 0;
      deathTimer = 0;
      barrelInterval = 120;

      gorilla = { x: 70, y: H - 470 - 48, w: 50, h: 48, throwAnim: 0 };
      princess = { x: 190, y: H - 470 - 26, w: 20, h: 26 };

      draw();
    }

    function startLevel() {
      buildLevel();
      resetPlayer();
      barrels = [];
      barrelTimer = 0;
      frameCount = 0;
      jumpedBarrels = new Set();
      reachedTop = false;
      levelTransition = 0;
      deathTimer = 0;
      // Difficulty: barrel interval decreases with level
      barrelInterval = Math.max(40, 120 - (level - 1) * 15);

      gorilla = { x: 70, y: H - 470 - 48, w: 50, h: 48, throwAnim: 0 };
      princess = { x: 190, y: H - 470 - 26, w: 20, h: 26 };
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startLevel();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function die() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      } else {
        deathTimer = 60; // 1 second pause
        resetPlayer();
        barrels = [];
        barrelTimer = 0;
        jumpedBarrels = new Set();
      }
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function isOnLadder(entity, allowPartial) {
      const eCX = entity.x + entity.w / 2;
      const eBottom = entity.y + entity.h;
      for (let lad of ladders) {
        const ladRight = lad.x + 20;
        const ladBottom = lad.y + lad.h;
        if (eCX > lad.x && eCX < ladRight) {
          if (allowPartial) {
            // For checking if can start climbing: feet near ladder
            if (eBottom >= lad.y - 5 && eBottom <= ladBottom + 5) {
              return lad;
            }
          } else {
            // Currently on a ladder
            if (entity.y + entity.h > lad.y && entity.y < ladBottom) {
              return lad;
            }
          }
        }
      }
      return null;
    }

    function isOnLadderTop(entity) {
      const eCX = entity.x + entity.w / 2;
      const eBottom = entity.y + entity.h;
      for (let lad of ladders) {
        const ladRight = lad.x + 20;
        if (eCX > lad.x && eCX < ladRight) {
          if (Math.abs(eBottom - lad.y) < 8) {
            return lad;
          }
        }
      }
      return null;
    }

    function getGroundY(entity) {
      let groundY = null;
      const eCX = entity.x + entity.w / 2;
      const eBottom = entity.y + entity.h;

      for (let plat of platforms) {
        if (eCX >= plat.x && eCX <= plat.x + plat.w) {
          let platYAtX = getPlatformYAt(plat, eCX);
          // Check if entity is above or at platform level
          if (eBottom <= platYAtX + 10 && eBottom >= platYAtX - 20) {
            if (groundY === null || platYAtX < groundY) {
              groundY = platYAtX;
            }
          }
        }
      }
      return groundY;
    }

    function getStandingPlatformY(entity) {
      const eCX = entity.x + entity.w / 2;
      const eBottom = entity.y + entity.h;

      for (let plat of platforms) {
        if (eCX >= plat.x && eCX <= plat.x + plat.w) {
          let platYAtX = getPlatformYAt(plat, eCX);
          if (eBottom >= platYAtX - 4 && eBottom <= platYAtX + 8) {
            return platYAtX;
          }
        }
      }
      return null;
    }

    function getLandingPlatform(entity) {
      const eCX = entity.x + entity.w / 2;
      const eBottom = entity.y + entity.h;

      let bestPlat = null;
      let bestDist = Infinity;

      for (let plat of platforms) {
        if (eCX >= plat.x && eCX <= plat.x + plat.w) {
          let platYAtX = getPlatformYAt(plat, eCX);
          let dist = platYAtX - eBottom;
          if (dist >= -4 && dist < bestDist) {
            bestDist = dist;
            bestPlat = plat;
          }
        }
      }
      return bestPlat;
    }

    function throwBarrel() {
      gorilla.throwAnim = 20;
      let barrel = {
        x: gorilla.x + gorilla.w / 2 - 8,
        y: gorilla.y + gorilla.h - 16,
        w: 16,
        h: 16,
        vx: 1.5 + level * 0.2,
        vy: 0,
        onGround: false,
        rollDir: 1, // 1 = right, -1 = left
        rotation: 0,
        id: frameCount,
        scored: false
      };
      barrels.push(barrel);
    }

    function update() {
      frameCount++;
      animFrame++;

      // Death pause
      if (deathTimer > 0) {
        deathTimer--;
        return;
      }

      // Level transition
      if (levelTransition > 0) {
        levelTransition--;
        if (levelTransition === 0) {
          level++;
          levelEl.textContent = level;
          score += 100;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          startLevel();
        }
        return;
      }

      // Barrel throwing
      barrelTimer++;
      if (barrelTimer >= barrelInterval) {
        barrelTimer = 0;
        throwBarrel();
      }

      // Gorilla animation
      if (gorilla.throwAnim > 0) gorilla.throwAnim--;

      // Player movement
      let moving = false;

      if (player.climbing) {
        // Climbing controls
        player.vx = 0;
        player.vy = 0;
        if (keys['ArrowUp']) {
          player.y -= CLIMB_SPEED;
          player.climbFrame += 0.15;
          moving = true;
        }
        if (keys['ArrowDown']) {
          player.y += CLIMB_SPEED;
          player.climbFrame += 0.15;
          moving = true;
        }

        // Check if reached top or bottom of ladder
        let lad = isOnLadder(player, false);
        if (!lad) {
          player.climbing = false;
          player.vy = 0;
          // Snap to platform
          let platY = getStandingPlatformY(player);
          if (platY !== null) {
            player.y = platY - player.h;
            player.onGround = true;
          }
        }
      } else {
        // Normal movement
        if (keys['ArrowLeft']) {
          player.vx = -MOVE_SPEED;
          player.facingRight = false;
          moving = true;
        } else if (keys['ArrowRight']) {
          player.vx = MOVE_SPEED;
          player.facingRight = true;
          moving = true;
        } else {
          player.vx = 0;
        }

        // Jumping
        if (keys[' '] && player.onGround && !player.climbing) {
          player.vy = JUMP_VEL;
          player.onGround = false;
        }

        // Climbing
        if (keys['ArrowUp'] && !player.climbing) {
          let lad = isOnLadder(player, true);
          if (lad) {
            // Check if it's a broken ladder - only allow if we're at a part that exists
            if (!lad.broken || canUseBrokenLadder(lad, player)) {
              player.climbing = true;
              player.onGround = false;
              player.vx = 0;
              player.vy = 0;
              // Center on ladder
              player.x = lad.x + 10 - player.w / 2;
            }
          }
        }

        if (keys['ArrowDown'] && !player.climbing) {
          let lad = isOnLadderTop(player);
          if (lad) {
            if (!lad.broken || canUseBrokenLadder(lad, player)) {
              player.climbing = true;
              player.onGround = false;
              player.vx = 0;
              player.vy = 0;
              player.x = lad.x + 10 - player.w / 2;
            }
          }
        }

        // Apply gravity
        if (!player.onGround) {
          player.vy += GRAVITY;
        }

        // Move player
        player.x += player.vx;
        player.y += player.vy;

        // Walk animation
        if (moving && player.onGround) {
          player.walkFrame += 0.2;
        }

        // Platform collision
        if (player.vy >= 0) {
          let plat = getLandingPlatform(player);
          if (plat) {
            let platYAtX = getPlatformYAt(plat, player.x + player.w / 2);
            if (player.y + player.h >= platYAtX - 2) {
              player.y = platYAtX - player.h;
              player.vy = 0;
              player.onGround = true;
            }
          }
        }

        // Adjust y for slopes when on ground
        if (player.onGround && player.vy === 0) {
          let plat = getLandingPlatform(player);
          if (plat) {
            let platYAtX = getPlatformYAt(plat, player.x + player.w / 2);
            player.y = platYAtX - player.h;
          }
        }
      }

      // Bounds
      if (player.x < 0) player.x = 0;
      if (player.x + player.w > W) player.x = W - player.w;

      // Fall off screen
      if (player.y > H + 50) {
        die();
        return;
      }

      // Update barrels
      for (let i = barrels.length - 1; i >= 0; i--) {
        let b = barrels[i];

        if (!b.onGround) {
          b.vy += GRAVITY;
        }

        b.x += b.vx * b.rollDir;
        b.y += b.vy;
        b.rotation += b.rollDir * 0.15;

        // Barrel platform collision
        let bPlat = getLandingPlatform(b);
        if (bPlat && b.vy >= 0) {
          let platYAtB = getPlatformYAt(bPlat, b.x + b.w / 2);
          if (b.y + b.h >= platYAtB - 2) {
            b.y = platYAtB - b.h;
            b.vy = 0;
            b.onGround = true;
          }
        }

        // Barrel slides along slope when on ground
        if (b.onGround) {
          let bPlat2 = getLandingPlatform(b);
          if (bPlat2) {
            let platYAtB = getPlatformYAt(bPlat2, b.x + b.w / 2);
            b.y = platYAtB - b.h;

            // Roll direction follows slope
            if (bPlat2.slope > 0) b.rollDir = 1;
            else if (bPlat2.slope < 0) b.rollDir = -1;

            // Speed on slope
            let speed = 2 + level * 0.3;
            b.vx = speed;
          }
        }

        // Barrel falls off edges
        if (b.onGround) {
          let nextPlat = getLandingPlatform(b);
          if (!nextPlat) {
            b.onGround = false;
            b.vy = 0;
            // When falling off edge, check for ladder to fall down
          }
        }

        // Barrel falls off screen
        if (b.y > H + 50 || b.x < -50 || b.x > W + 50) {
          barrels.splice(i, 1);
          continue;
        }

        // Barrel-player collision
        let dx = (player.x + player.w / 2) - (b.x + b.w / 2);
        let dy = (player.y + player.h / 2) - (b.y + b.h / 2);
        if (Math.abs(dx) < (player.w + b.w) / 2 - 4 && Math.abs(dy) < (player.h + b.h) / 2 - 4) {
          die();
          return;
        }

        // Score for jumping over barrels
        if (!b.scored && player.onGround === false && player.vy < 0) {
          // Player is above barrel while jumping
          if (Math.abs(player.x - b.x) < 30 && player.y + player.h < b.y + 5) {
            b.scored = true;
            score += 100;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
          }
        }
      }

      // Check if player reached the princess
      let dx = Math.abs((player.x + player.w / 2) - (princess.x + princess.w / 2));
      let dy = Math.abs((player.y + player.h / 2) - (princess.y + princess.h / 2));
      if (dx < 30 && dy < 30) {
        reachedTop = true;
        levelTransition = 90; // 1.5 second transition
        score += 200;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
      }

      // Update game data for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerVX: player.vx,
        playerVY: player.vy,
        climbing: player.climbing,
        onGround: player.onGround,
        barrels: barrels.map(b => ({ x: b.x, y: b.y, vx: b.vx * b.rollDir, vy: b.vy })),
        level: level,
        lives: lives
      };
    }

    function canUseBrokenLadder(lad, entity) {
      // Broken ladders only have rungs at top and bottom segments
      // Allow climbing from bottom section and top section
      let eBottom = entity.y + entity.h;
      let ladBottom = lad.y + lad.h;
      let gapStart = lad.y + lad.h * 0.35;
      let gapEnd = lad.y + lad.h * 0.65;
      // Can start climbing if feet are NOT in the gap area
      return eBottom < gapStart || eBottom > gapEnd;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw platforms
      for (let plat of platforms) {
        drawPlatform(plat);
      }

      // Draw ladders
      for (let lad of ladders) {
        drawLadder(lad);
      }

      // Draw barrels
      for (let b of barrels) {
        drawBarrel(b);
      }

      // Draw gorilla
      drawGorilla();

      // Draw princess
      drawPrincess();

      // Draw player
      drawPlayer();

      // Level transition flash
      if (levelTransition > 0) {
        let alpha = Math.sin(levelTransition * 0.2) * 0.3 + 0.2;
        ctx.fillStyle = `rgba(238, 136, 34, ${alpha})`;
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = THEME;
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 20;
        ctx.fillText('LEVEL COMPLETE!', W / 2, H / 2 - 10);
        ctx.font = '16px Courier New';
        ctx.fillText(`+200 BONUS`, W / 2, H / 2 + 20);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
      }

      // Death pause indicator
      if (deathTimer > 0) {
        let alpha = 0.5;
        ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawPlatform(plat) {
      ctx.save();
      ctx.beginPath();

      // Draw sloped platform
      let leftY = getPlatformYAt(plat, plat.x);
      let rightY = getPlatformYAt(plat, plat.x + plat.w);

      ctx.moveTo(plat.x, leftY);
      ctx.lineTo(plat.x + plat.w, rightY);
      ctx.lineTo(plat.x + plat.w, rightY + plat.h);
      ctx.lineTo(plat.x, leftY + plat.h);
      ctx.closePath();

      // Steel girder look
      ctx.fillStyle = '#c44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 4;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Girder cross pattern
      ctx.strokeStyle = '#822';
      ctx.lineWidth = 1;
      let step = 20;
      for (let sx = plat.x; sx < plat.x + plat.w; sx += step) {
        let yAtSx = getPlatformYAt(plat, sx);
        let yAtSx2 = getPlatformYAt(plat, Math.min(sx + step, plat.x + plat.w));
        ctx.beginPath();
        ctx.moveTo(sx, yAtSx);
        ctx.lineTo(Math.min(sx + step, plat.x + plat.w), yAtSx2 + plat.h);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(sx, yAtSx + plat.h);
        ctx.lineTo(Math.min(sx + step, plat.x + plat.w), yAtSx2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawLadder(lad) {
      ctx.save();
      let lw = 20;
      let x = lad.x;
      let y = lad.y;
      let h = lad.h;

      ctx.strokeStyle = '#6cf';
      ctx.shadowColor = '#6cf';
      ctx.shadowBlur = 4;
      ctx.lineWidth = 2;

      if (lad.broken) {
        // Draw only top and bottom sections
        let gapStart = y + h * 0.35;
        let gapEnd = y + h * 0.65;

        // Top section
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, gapStart);
        ctx.moveTo(x + lw, y);
        ctx.lineTo(x + lw, gapStart);
        ctx.stroke();
        for (let ry = y + 10; ry < gapStart; ry += 15) {
          ctx.beginPath();
          ctx.moveTo(x, ry);
          ctx.lineTo(x + lw, ry);
          ctx.stroke();
        }

        // Bottom section
        ctx.beginPath();
        ctx.moveTo(x, gapEnd);
        ctx.lineTo(x, y + h);
        ctx.moveTo(x + lw, gapEnd);
        ctx.lineTo(x + lw, y + h);
        ctx.stroke();
        for (let ry = gapEnd + 10; ry < y + h; ry += 15) {
          ctx.beginPath();
          ctx.moveTo(x, ry);
          ctx.lineTo(x + lw, ry);
          ctx.stroke();
        }
      } else {
        // Full ladder
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + h);
        ctx.moveTo(x + lw, y);
        ctx.lineTo(x + lw, y + h);
        ctx.stroke();

        // Rungs
        for (let ry = y + 10; ry < y + h; ry += 15) {
          ctx.beginPath();
          ctx.moveTo(x, ry);
          ctx.lineTo(x + lw, ry);
          ctx.stroke();
        }
      }

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBarrel(b) {
      ctx.save();
      ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
      ctx.rotate(b.rotation);

      // Barrel body
      ctx.fillStyle = '#e82';
      ctx.shadowColor = '#e82';
      ctx.shadowBlur = 8;
      ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);

      // Barrel stripes
      ctx.fillStyle = '#a52';
      ctx.fillRect(-b.w / 2, -2, b.w, 4);
      ctx.fillRect(-2, -b.h / 2, 4, b.h);

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawGorilla() {
      let g = gorilla;
      ctx.save();

      // Body
      ctx.fillStyle = '#a52';
      ctx.shadowColor = '#e82';
      ctx.shadowBlur = 10;

      // Torso
      ctx.fillRect(g.x + 8, g.y + 14, 34, 26);

      // Head
      ctx.fillStyle = '#c64';
      ctx.beginPath();
      ctx.arc(g.x + g.w / 2, g.y + 12, 16, 0, Math.PI * 2);
      ctx.fill();

      // Face
      ctx.fillStyle = '#e8b';
      ctx.beginPath();
      ctx.arc(g.x + g.w / 2, g.y + 14, 9, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(g.x + 18, g.y + 8, 5, 5);
      ctx.fillRect(g.x + 28, g.y + 8, 5, 5);
      ctx.fillStyle = '#000';
      ctx.fillRect(g.x + 20, g.y + 10, 3, 3);
      ctx.fillRect(g.x + 30, g.y + 10, 3, 3);

      // Mouth
      ctx.fillStyle = '#800';
      ctx.fillRect(g.x + 20, g.y + 18, 10, 3);

      // Arms
      ctx.fillStyle = '#a52';
      if (g.throwAnim > 10) {
        // Arms up (throwing)
        ctx.fillRect(g.x - 2, g.y + 4, 12, 8);
        ctx.fillRect(g.x + g.w - 10, g.y + 4, 12, 8);
      } else {
        // Arms down
        ctx.fillRect(g.x, g.y + 18, 10, 18);
        ctx.fillRect(g.x + g.w - 10, g.y + 18, 10, 18);
      }

      // Legs
      ctx.fillRect(g.x + 12, g.y + 38, 10, 10);
      ctx.fillRect(g.x + 28, g.y + 38, 10, 10);

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawPrincess() {
      let p = princess;
      ctx.save();
      ctx.shadowColor = '#f8d';
      ctx.shadowBlur = 12;

      // Dress
      ctx.fillStyle = '#f6a';
      ctx.beginPath();
      ctx.moveTo(p.x, p.y + p.h);
      ctx.lineTo(p.x + p.w, p.y + p.h);
      ctx.lineTo(p.x + p.w - 2, p.y + 10);
      ctx.lineTo(p.x + 2, p.y + 10);
      ctx.closePath();
      ctx.fill();

      // Head
      ctx.fillStyle = '#fc8';
      ctx.beginPath();
      ctx.arc(p.x + p.w / 2, p.y + 7, 7, 0, Math.PI * 2);
      ctx.fill();

      // Hair
      ctx.fillStyle = '#fd0';
      ctx.beginPath();
      ctx.arc(p.x + p.w / 2, p.y + 4, 7, Math.PI, Math.PI * 2);
      ctx.fill();

      // HELP text above
      if (Math.sin(frameCount * 0.08) > 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('HELP!', p.x + p.w / 2, p.y - 8);
        ctx.textAlign = 'left';
      }

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawPlayer() {
      let p = player;
      ctx.save();

      // Mario-style character
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 8;

      if (p.climbing) {
        // Climbing pose
        let offset = Math.floor(p.climbFrame) % 2 === 0 ? -2 : 2;

        // Body
        ctx.fillStyle = '#e22';
        ctx.fillRect(p.x + 4, p.y + 8, 12, 10);

        // Head
        ctx.fillStyle = '#fc8';
        ctx.beginPath();
        ctx.arc(p.x + p.w / 2, p.y + 6, 6, 0, Math.PI * 2);
        ctx.fill();

        // Hat
        ctx.fillStyle = '#e22';
        ctx.fillRect(p.x + 3, p.y - 1, 14, 5);

        // Arms (reaching up alternately)
        ctx.fillStyle = '#fc8';
        ctx.fillRect(p.x + offset, p.y + 4, 6, 4);
        ctx.fillRect(p.x + p.w - 6 - offset, p.y + 10, 6, 4);

        // Legs
        ctx.fillStyle = '#22e';
        ctx.fillRect(p.x + 4 + offset, p.y + 18, 5, 10);
        ctx.fillRect(p.x + 11 - offset, p.y + 18, 5, 10);
      } else {
        let dir = p.facingRight ? 1 : -1;
        let cx = p.x + p.w / 2;

        // Legs (walk animation)
        ctx.fillStyle = '#22e';
        if (p.onGround && Math.abs(p.vx) > 0) {
          let step = Math.sin(p.walkFrame * 3) * 4;
          ctx.fillRect(cx - 7, p.y + 18, 5, 10);
          ctx.fillRect(cx + 2, p.y + 18, 5, 10);
          // Walking leg offsets
          if (Math.floor(p.walkFrame) % 2 === 0) {
            ctx.fillRect(cx - 7 + step, p.y + 18, 5, 10);
          }
        } else {
          ctx.fillRect(cx - 7, p.y + 18, 5, 10);
          ctx.fillRect(cx + 2, p.y + 18, 5, 10);
        }

        // Body / shirt
        ctx.fillStyle = '#e22';
        ctx.fillRect(p.x + 3, p.y + 8, 14, 12);

        // Overalls
        ctx.fillStyle = '#22e';
        ctx.fillRect(p.x + 5, p.y + 12, 10, 8);

        // Overall straps
        ctx.fillStyle = '#22e';
        ctx.fillRect(p.x + 6, p.y + 8, 3, 6);
        ctx.fillRect(p.x + 11, p.y + 8, 3, 6);

        // Head
        ctx.fillStyle = '#fc8';
        ctx.beginPath();
        ctx.arc(cx, p.y + 6, 6, 0, Math.PI * 2);
        ctx.fill();

        // Hat
        ctx.fillStyle = '#e22';
        ctx.fillRect(cx - 8, p.y - 2, 16, 5);
        ctx.fillRect(cx + (dir > 0 ? -3 : -8), p.y - 4, 11, 4);

        // Hat brim
        ctx.fillStyle = '#c00';
        ctx.fillRect(cx + (dir > 0 ? 2 : -10), p.y + 1, 8, 2);

        // Eye
        ctx.fillStyle = '#000';
        ctx.fillRect(cx + (dir > 0 ? 2 : -4), p.y + 4, 2, 2);

        // Mustache
        ctx.fillStyle = '#420';
        ctx.fillRect(cx + (dir > 0 ? 0 : -5), p.y + 8, 5, 2);

        // Arms
        ctx.fillStyle = '#fc8';
        if (!p.onGround) {
          // Arms up when jumping
          ctx.fillRect(p.x - 2, p.y + 4, 5, 4);
          ctx.fillRect(p.x + p.w - 3, p.y + 4, 5, 4);
        } else {
          ctx.fillRect(p.x - 1, p.y + 10, 4, 6);
          ctx.fillRect(p.x + p.w - 3, p.y + 10, 4, 6);
        }

        // Shoes
        ctx.fillStyle = '#620';
        ctx.fillRect(p.x + 2, p.y + 26, 7, 2);
        ctx.fillRect(p.x + 11, p.y + 26, 7, 2);
      }

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

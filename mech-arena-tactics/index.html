<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mech Arena Tactics - OpenArcade</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  color: #eee;
  font-family: 'Courier New', monospace;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
}
a { color: #8af; text-decoration: none; }
a:hover { text-decoration: underline; }
#back-link {
  position: absolute;
  top: 12px;
  left: 16px;
  font-size: 14px;
  z-index: 100;
}
#score-bar {
  width: 600px;
  max-width: 95vw;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background: rgba(136,170,255,0.08);
  border-bottom: 2px solid #8af;
  font-size: 15px;
  margin-top: 48px;
}
#score-bar .label { color: #8af; text-shadow: 0 0 8px #8af55; }
#score-bar .value { color: #fff; font-weight: bold; }
#game-container {
  position: relative;
  width: 600px;
  max-width: 95vw;
}
canvas#game {
  display: block;
  width: 600px;
  height: 500px;
  max-width: 95vw;
  background: #0d0d1a;
  border: 1px solid #8af33;
}
#overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(26,26,46,0.92);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 50;
  text-align: center;
}
#overlay h1 {
  font-size: 28px;
  color: #8af;
  text-shadow: 0 0 20px #8af, 0 0 40px #8af55;
  margin-bottom: 12px;
}
#overlay h2 {
  font-size: 20px;
  color: #8af;
  text-shadow: 0 0 12px #8af88;
  margin-bottom: 8px;
}
#overlay p {
  font-size: 13px;
  color: #aab;
  max-width: 420px;
  line-height: 1.5;
  margin-bottom: 16px;
}
#overlay button, .btn {
  background: transparent;
  color: #8af;
  border: 2px solid #8af;
  padding: 10px 32px;
  font-family: 'Courier New', monospace;
  font-size: 16px;
  cursor: pointer;
  margin-top: 8px;
  text-shadow: 0 0 8px #8af88;
  box-shadow: 0 0 12px #8af33;
  transition: all 0.2s;
}
#overlay button:hover, .btn:hover {
  background: #8af22;
  box-shadow: 0 0 20px #8af66;
}
#status-bar {
  width: 600px;
  max-width: 95vw;
  padding: 6px 16px;
  background: rgba(136,170,255,0.05);
  border-top: 1px solid #8af33;
  font-size: 12px;
  color: #8af;
  text-align: center;
  min-height: 28px;
}
</style>
</head>
<body>
<a id="back-link" href="../">&#8592; OpenArcade</a>
<div id="score-bar">
  <span><span class="label">SCORE: </span><span class="value" id="score-display">0</span></span>
  <span><span class="label">TURN: </span><span class="value" id="turn-display">-</span></span>
  <span><span class="label">PHASE: </span><span class="value" id="phase-display">LOADOUT</span></span>
</div>
<div id="game-container">
  <canvas id="game" width="600" height="500"></canvas>
  <div id="overlay">
    <h1>MECH ARENA TACTICS</h1>
    <p>Customize your mechs with weapons and armor, then battle on a destructible grid. Outmaneuver the AI to win!</p>
    <p style="font-size:11px;color:#889;">2 mechs each &bull; Turn-based combat &bull; Destructible terrain<br>Manage heat or overheat and skip turns!</p>
    <button onclick="startGame()">DEPLOY MECHS</button>
  </div>
</div>
<div id="status-bar" id="status-text">Ready for deployment...</div>
<script>
// ============================================================
// MECH ARENA TACTICS — OpenArcade
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const statusBar = document.getElementById('status-bar');

let gameState = 'menu'; // menu, loadout, combat, gameover
let score = 0;
let turnNumber = 0;

// --- CONSTANTS ---
const GRID_COLS = 10;
const GRID_ROWS = 10;
const CELL = 44;
const GRID_OX = 40;
const GRID_OY = 28;
const THEME = '#8af';

const WEAPONS = {
  laser:   { name:'Laser',   dmg:18, range:6, heat:12, accuracy:0.92, splash:false, color:'#f44' },
  missile: { name:'Missile', dmg:22, range:5, heat:18, accuracy:0.75, splash:true,  color:'#fa0' },
  cannon:  { name:'Cannon',  dmg:30, range:4, heat:22, accuracy:0.80, splash:false, color:'#ff0' },
  mg:      { name:'MG',      dmg:10, range:3, heat:6,  accuracy:0.88, splash:false, color:'#0f8', shots:3 }
};

const ARMORS = {
  light:  { name:'Light',  hp:60,  move:4, heatCap:50, coolRate:18, color:'#5f5' },
  medium: { name:'Medium', hp:85,  move:3, heatCap:65, coolRate:14, color:'#8af' },
  heavy:  { name:'Heavy',  hp:120, move:2, heatCap:80, coolRate:10, color:'#c8f' }
};

const WEAPON_KEYS = Object.keys(WEAPONS);
const ARMOR_KEYS = Object.keys(ARMORS);

// --- GAME DATA ---
let grid = []; // 0=empty, 1=wall, 2=cover(half), 3=destroyed
let mechs = []; // {id, owner, x, y, weapon, armor, hp, maxHp, heat, overheated, alive}
let currentMechIdx = 0;
let phase = 'move'; // move, attack, done
let selectedCell = null;
let validMoves = [];
let validTargets = [];
let animations = [];
let turnLog = [];
let playerLoadout = [{weapon:'laser',armor:'medium'},{weapon:'missile',armor:'medium'}];
let loadoutSlot = 0;
let aiThinking = false;
let combatLog = [];

// --- LOADOUT UI STATE ---
let loadoutHover = null;

function setStatus(txt) { statusBar.textContent = txt; }

function updateHUD() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('turn-display').textContent = turnNumber || '-';
  document.getElementById('phase-display').textContent =
    gameState === 'loadout' ? 'LOADOUT' :
    gameState === 'combat' ? 'COMBAT' :
    gameState === 'gameover' ? 'GAME OVER' : 'MENU';
}

// ============================================================
// GRID GENERATION
// ============================================================
function generateGrid() {
  grid = [];
  for (let r = 0; r < GRID_ROWS; r++) {
    grid[r] = [];
    for (let c = 0; c < GRID_COLS; c++) {
      grid[r][c] = 0;
    }
  }
  // Place walls (1) and cover (2)
  let wallCount = 10 + Math.floor(Math.random() * 6);
  let coverCount = 6 + Math.floor(Math.random() * 4);
  let forbidden = new Set();
  // Reserve spawn zones
  for (let i = 0; i < 2; i++) {
    forbidden.add(`0,${i}`); forbidden.add(`1,${i}`);
    forbidden.add(`${GRID_COLS-1},${GRID_ROWS-1-i}`); forbidden.add(`${GRID_COLS-2},${GRID_ROWS-1-i}`);
  }
  function placeRandom(type, count) {
    let placed = 0;
    while (placed < count) {
      let c = Math.floor(Math.random() * GRID_COLS);
      let r = Math.floor(Math.random() * GRID_ROWS);
      if (grid[r][c] === 0 && !forbidden.has(`${c},${r}`)) {
        grid[r][c] = type;
        placed++;
      }
    }
  }
  placeRandom(1, wallCount);
  placeRandom(2, coverCount);
}

// ============================================================
// MECH CREATION
// ============================================================
function createMech(id, owner, x, y, weaponKey, armorKey) {
  let w = WEAPONS[weaponKey];
  let a = ARMORS[armorKey];
  return {
    id, owner, x, y,
    weapon: weaponKey, armor: armorKey,
    hp: a.hp, maxHp: a.hp,
    heat: 0, heatCap: a.heatCap, coolRate: a.coolRate,
    move: a.move, range: w.range,
    overheated: false, alive: true,
    hasMoved: false, hasAttacked: false
  };
}

// ============================================================
// PATHFINDING / MOVEMENT
// ============================================================
function isBlocked(c, r) {
  if (c < 0 || c >= GRID_COLS || r < 0 || r >= GRID_ROWS) return true;
  if (grid[r][c] === 1) return true;
  for (let m of mechs) {
    if (m.alive && m.x === c && m.y === r) return true;
  }
  return false;
}

function getReachable(mech) {
  let start = `${mech.x},${mech.y}`;
  let visited = new Map();
  visited.set(start, 0);
  let queue = [{x:mech.x, y:mech.y, dist:0}];
  let result = [];
  while (queue.length) {
    let cur = queue.shift();
    if (cur.dist > 0) result.push({x:cur.x, y:cur.y});
    if (cur.dist >= mech.move) continue;
    for (let [dx,dy] of [[0,-1],[0,1],[-1,0],[1,0]]) {
      let nx = cur.x+dx, ny = cur.y+dy;
      let key = `${nx},${ny}`;
      if (!isBlocked(nx,ny) && !visited.has(key)) {
        visited.set(key, cur.dist+1);
        queue.push({x:nx,y:ny,dist:cur.dist+1});
      }
    }
  }
  return result;
}

// ============================================================
// LINE OF SIGHT
// ============================================================
function hasLOS(x1,y1,x2,y2) {
  let dx = x2-x1, dy = y2-y1;
  let steps = Math.max(Math.abs(dx),Math.abs(dy));
  if (steps === 0) return true;
  for (let i = 1; i < steps; i++) {
    let cx = Math.round(x1 + dx*i/steps);
    let cy = Math.round(y1 + dy*i/steps);
    if (grid[cy] && grid[cy][cx] === 1) return false;
  }
  return true;
}

function dist(x1,y1,x2,y2) { return Math.abs(x2-x1)+Math.abs(y2-y1); }

function getTargets(mech) {
  let targets = [];
  let w = WEAPONS[mech.weapon];
  for (let m of mechs) {
    if (!m.alive || m.owner === mech.owner) continue;
    let d = dist(mech.x, mech.y, m.x, m.y);
    if (d <= w.range && hasLOS(mech.x, mech.y, m.x, m.y)) {
      targets.push(m);
    }
  }
  return targets;
}

// ============================================================
// COMBAT RESOLUTION
// ============================================================
function resolveAttack(attacker, target) {
  let w = WEAPONS[attacker.weapon];
  let inCover = grid[target.y][target.x] === 2;
  let acc = w.accuracy * (inCover ? 0.6 : 1.0);
  let results = [];
  let shots = w.shots || 1;

  for (let s = 0; s < shots; s++) {
    let hit = Math.random() < acc;
    if (hit) {
      let dmg = w.dmg + Math.floor(Math.random()*5) - 2;
      if (w.shots) dmg = Math.floor(dmg); // MG per-shot
      target.hp -= dmg;
      score += dmg;
      results.push({hit:true, dmg});
      if (target.hp <= 0) { target.hp = 0; target.alive = false; }
    } else {
      results.push({hit:false, dmg:0});
    }
  }

  // Splash damage to adjacent mechs
  if (w.splash) {
    for (let m of mechs) {
      if (!m.alive || m.id === target.id || m.owner === attacker.owner) continue;
      if (dist(target.x,target.y,m.x,m.y) <= 1) {
        let sdmg = Math.floor(w.dmg * 0.4);
        m.hp -= sdmg;
        score += sdmg;
        if (m.hp <= 0) { m.hp = 0; m.alive = false; }
        results.push({hit:true, dmg:sdmg, splash:true, targetId:m.id});
      }
    }
  }

  // Destroy cover/wall at target if splash
  if (w.splash && grid[target.y][target.x] === 2) {
    grid[target.y][target.x] = 3;
  }

  // Heat
  attacker.heat += w.heat;
  if (attacker.heat >= attacker.heatCap) {
    attacker.overheated = true;
  }

  // Animation
  animations.push({
    type: 'beam',
    x1: attacker.x, y1: attacker.y,
    x2: target.x, y2: target.y,
    color: w.color,
    timer: 20,
    results
  });

  return results;
}

// Destroy wall/cover when shot hits terrain
function destroyTerrain(x, y) {
  if (x >= 0 && x < GRID_COLS && y >= 0 && y < GRID_ROWS) {
    if (grid[y][x] === 1 || grid[y][x] === 2) {
      grid[y][x] = 3;
      animations.push({type:'explode', x, y, timer:15, color:'#fa0'});
    }
  }
}

// ============================================================
// AI LOGIC
// ============================================================
function aiChooseLoadout() {
  // Pick good combos
  let combos = [
    {weapon:'cannon', armor:'heavy'},
    {weapon:'laser', armor:'medium'},
    {weapon:'missile', armor:'medium'},
    {weapon:'mg', armor:'light'},
    {weapon:'cannon', armor:'medium'},
    {weapon:'laser', armor:'light'},
    {weapon:'missile', armor:'heavy'}
  ];
  let picks = [];
  let used = new Set();
  // Try to pick diverse loadouts
  let shuffled = combos.sort(() => Math.random()-0.5);
  for (let c of shuffled) {
    let key = c.weapon+c.armor;
    if (!used.has(key) && picks.length < 2) {
      picks.push({...c});
      used.add(key);
    }
  }
  while (picks.length < 2) picks.push({weapon:'laser', armor:'medium'});
  return picks;
}

function aiTakeTurn(mech) {
  aiThinking = true;
  setTimeout(() => {
    if (!mech.alive || mech.overheated) {
      aiThinking = false;
      advanceTurn();
      return;
    }

    // Tactical positioning: evaluate each reachable cell
    let reachable = getReachable(mech);
    reachable.push({x:mech.x, y:mech.y}); // can stay put

    let bestScore = -Infinity;
    let bestPos = {x:mech.x, y:mech.y};
    let bestTarget = null;
    let w = WEAPONS[mech.weapon];

    for (let pos of reachable) {
      let posScore = 0;

      // Check what targets we can hit from this position
      let tempX = mech.x, tempY = mech.y;
      mech.x = pos.x; mech.y = pos.y;

      let targets = getTargets(mech);
      let bestTgtScore = 0;
      let bestTgt = null;

      for (let t of targets) {
        let d = dist(pos.x, pos.y, t.x, t.y);
        let tScore = w.dmg * w.accuracy * (w.shots||1);
        // Prefer low-HP targets (finish them off)
        if (t.hp <= w.dmg * (w.shots||1)) tScore += 40;
        // Prefer closer targets
        tScore += (w.range - d) * 2;
        // Cover penalty for target
        if (grid[t.y][t.x] === 2) tScore *= 0.6;
        if (tScore > bestTgtScore) { bestTgtScore = tScore; bestTgt = t; }
      }
      posScore += bestTgtScore;

      // Defensive scoring
      let inCover = grid[pos.y][pos.x] === 2;
      if (inCover) posScore += 15;

      // Stay away from enemies if low HP
      for (let em of mechs) {
        if (!em.alive || em.owner === mech.owner) continue;
        let ed = dist(pos.x, pos.y, em.x, em.y);
        if (mech.hp < mech.maxHp * 0.3) {
          posScore += ed * 3; // flee
        } else {
          // Get into range but not too close
          if (ed <= w.range) posScore += 8;
          if (ed <= 1) posScore -= 5;
        }
      }

      // Heat awareness: don't attack if it would overheat and there's no great target
      if (mech.heat + w.heat >= mech.heatCap && bestTgtScore < 25) {
        // Skip attack value
        bestTgt = null;
        bestTgtScore = 0;
      }

      if (bestTgt) posScore += 10; // bonus for having a target

      mech.x = tempX; mech.y = tempY;

      if (posScore > bestScore) {
        bestScore = posScore;
        bestPos = pos;
        bestTarget = bestTgt;
      }
    }

    // Execute move
    if (bestPos.x !== mech.x || bestPos.y !== mech.y) {
      mech.x = bestPos.x;
      mech.y = bestPos.y;
    }
    mech.hasMoved = true;

    // Execute attack
    setTimeout(() => {
      if (bestTarget && bestTarget.alive) {
        let results = resolveAttack(mech, bestTarget);
        let totalDmg = results.reduce((s,r) => s + r.dmg, 0);
        let msg = `AI ${WEAPONS[mech.weapon].name} → Mech ${bestTarget.id}: `;
        msg += results.some(r=>r.hit) ? `${totalDmg} dmg` : 'MISS';
        combatLog.unshift(msg);
        if (combatLog.length > 6) combatLog.pop();
      }
      mech.hasAttacked = true;

      setTimeout(() => {
        aiThinking = false;
        checkWinCondition();
        if (gameState === 'combat') advanceTurn();
      }, 400);
    }, 500);
  }, 600);
}

// ============================================================
// TURN MANAGEMENT
// ============================================================
function startCombat() {
  gameState = 'combat';
  overlay.style.display = 'none';
  turnNumber = 1;

  generateGrid();

  let aiLoadout = aiChooseLoadout();

  mechs = [
    createMech(1, 'player', 0, 0, playerLoadout[0].weapon, playerLoadout[0].armor),
    createMech(2, 'player', 1, 1, playerLoadout[1].weapon, playerLoadout[1].armor),
    createMech(3, 'ai', GRID_COLS-1, GRID_ROWS-1, aiLoadout[0].weapon, aiLoadout[0].armor),
    createMech(4, 'ai', GRID_COLS-2, GRID_ROWS-2, aiLoadout[1].weapon, aiLoadout[1].armor),
  ];

  // Clear spawn cells
  for (let m of mechs) { grid[m.y][m.x] = 0; }

  currentMechIdx = 0;
  startMechTurn();
  updateHUD();
  setStatus('Your turn! Select a mech to move.');
}

function startMechTurn() {
  let mech = mechs[currentMechIdx];
  if (!mech) return;

  // Cool down
  if (mech.overheated) {
    mech.heat = Math.max(0, mech.heat - mech.coolRate * 2);
    if (mech.heat <= mech.heatCap * 0.3) mech.overheated = false;
    else {
      // Skip turn
      combatLog.unshift(`Mech ${mech.id} cooling down (${mech.heat}/${mech.heatCap})`);
      if (combatLog.length > 6) combatLog.pop();
      advanceTurn();
      return;
    }
  } else {
    mech.heat = Math.max(0, mech.heat - mech.coolRate);
  }

  if (!mech.alive) {
    advanceTurn();
    return;
  }

  mech.hasMoved = false;
  mech.hasAttacked = false;
  phase = 'move';
  selectedCell = null;
  validMoves = getReachable(mech);
  validTargets = [];

  if (mech.owner === 'ai') {
    setStatus('AI is thinking...');
    aiTakeTurn(mech);
  } else {
    setStatus(`Mech ${mech.id}: Click a blue cell to move, or click mech to skip move.`);
  }
}

function advanceTurn() {
  currentMechIdx++;
  if (currentMechIdx >= mechs.length) {
    currentMechIdx = 0;
    turnNumber++;
    // Degrade some random cover each round
    if (Math.random() < 0.15) {
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (grid[r][c] === 2 && Math.random() < 0.1) grid[r][c] = 3;
        }
      }
    }
  }
  updateHUD();
  startMechTurn();
}

function checkWinCondition() {
  let playerAlive = mechs.filter(m => m.owner === 'player' && m.alive).length;
  let aiAlive = mechs.filter(m => m.owner === 'ai' && m.alive).length;

  if (aiAlive === 0) {
    gameState = 'gameover';
    score += 100; // victory bonus
    updateHUD();
    showGameOver(true);
  } else if (playerAlive === 0) {
    gameState = 'gameover';
    updateHUD();
    showGameOver(false);
  }
}

function showGameOver(won) {
  overlay.style.display = 'flex';
  overlay.innerHTML = `
    <h1>${won ? 'VICTORY!' : 'DEFEATED'}</h1>
    <h2>Score: ${score}</h2>
    <p>${won ? 'All enemy mechs destroyed! Superior tactics prevail.' : 'Your mechs have been destroyed. Regroup and try again.'}</p>
    <p style="font-size:11px;color:#889;">Turns: ${turnNumber} | Damage dealt: ${score}</p>
    <button onclick="startGame()">REDEPLOY</button>
  `;
}

// ============================================================
// INPUT HANDLING
// ============================================================
function getCellFromMouse(e) {
  let rect = canvas.getBoundingClientRect();
  let scaleX = canvas.width / rect.width;
  let scaleY = canvas.height / rect.height;
  let mx = (e.clientX - rect.left) * scaleX;
  let my = (e.clientY - rect.top) * scaleY;
  let c = Math.floor((mx - GRID_OX) / CELL);
  let r = Math.floor((my - GRID_OY) / CELL);
  if (c >= 0 && c < GRID_COLS && r >= 0 && r < GRID_ROWS) return {c, r, mx, my};
  return {c:-1, r:-1, mx, my};
}

canvas.addEventListener('click', function(e) {
  if (gameState === 'loadout') {
    handleLoadoutClick(e);
    return;
  }
  if (gameState !== 'combat' || aiThinking) return;

  let {c, r} = getCellFromMouse(e);
  if (c < 0) return;

  let mech = mechs[currentMechIdx];
  if (!mech || mech.owner !== 'player' || !mech.alive) return;

  if (phase === 'move') {
    // Click on own mech to skip move
    if (c === mech.x && r === mech.y) {
      mech.hasMoved = true;
      phase = 'attack';
      validMoves = [];
      validTargets = getTargets(mech);
      if (validTargets.length === 0) {
        setStatus(`Mech ${mech.id}: No targets in range. Turn ends.`);
        setTimeout(() => { checkWinCondition(); if (gameState==='combat') advanceTurn(); }, 400);
      } else {
        setStatus(`Mech ${mech.id}: Click an enemy to attack, or click own mech to skip.`);
      }
      return;
    }
    // Check if valid move
    let valid = validMoves.find(m => m.x === c && m.y === r);
    if (valid) {
      mech.x = c;
      mech.y = r;
      mech.hasMoved = true;
      phase = 'attack';
      validMoves = [];
      validTargets = getTargets(mech);
      if (validTargets.length === 0) {
        setStatus(`Mech ${mech.id}: No targets in range. Turn ends.`);
        setTimeout(() => { checkWinCondition(); if (gameState==='combat') advanceTurn(); }, 400);
      } else {
        setStatus(`Mech ${mech.id}: Click an enemy to attack, or click own mech to skip.`);
      }
    }
  } else if (phase === 'attack') {
    // Skip attack
    if (c === mech.x && r === mech.y) {
      mech.hasAttacked = true;
      validTargets = [];
      setTimeout(() => { checkWinCondition(); if (gameState==='combat') advanceTurn(); }, 200);
      return;
    }
    // Attack target
    let target = validTargets.find(t => t.x === c && t.y === r);
    if (target) {
      let results = resolveAttack(mech, target);
      let totalDmg = results.reduce((s,r) => s + r.dmg, 0);
      let msg = `Mech ${mech.id} ${WEAPONS[mech.weapon].name} → Mech ${target.id}: `;
      msg += results.some(r=>r.hit) ? `${totalDmg} dmg` : 'MISS';
      combatLog.unshift(msg);
      if (combatLog.length > 6) combatLog.pop();
      setStatus(msg);
      mech.hasAttacked = true;
      validTargets = [];
      updateHUD();
      setTimeout(() => { checkWinCondition(); if (gameState==='combat') advanceTurn(); }, 600);
    }
  }
});

canvas.addEventListener('mousemove', function(e) {
  if (gameState === 'loadout') {
    handleLoadoutHover(e);
  }
});

// ============================================================
// LOADOUT PHASE
// ============================================================
// Layout positions for loadout UI
let loadoutButtons = [];

function buildLoadoutButtons() {
  loadoutButtons = [];
  let x0 = 50, y0 = 100;

  // Slot tabs
  loadoutButtons.push({id:'slot0', x:180, y:40, w:100, h:30, label:'Mech 1', type:'tab'});
  loadoutButtons.push({id:'slot1', x:320, y:40, w:100, h:30, label:'Mech 2', type:'tab'});

  // Weapons
  let wy = y0 + 30;
  WEAPON_KEYS.forEach((k, i) => {
    let w = WEAPONS[k];
    loadoutButtons.push({
      id:'w_'+k, x:x0, y:wy + i*52, w:240, h:44,
      label:`${w.name}`, sub:`DMG:${w.dmg} RNG:${w.range} HEAT:${w.heat}${w.shots?' x'+w.shots:''}`,
      type:'weapon', key:k, color:w.color
    });
  });

  // Armors
  let ay = y0 + 30;
  ARMOR_KEYS.forEach((k, i) => {
    let a = ARMORS[k];
    loadoutButtons.push({
      id:'a_'+k, x:320, y:ay + i*52, w:240, h:44,
      label:`${a.name}`, sub:`HP:${a.hp} MOV:${a.move} COOL:${a.coolRate}`,
      type:'armor', key:k, color:a.color
    });
  });

  // Deploy button
  loadoutButtons.push({id:'deploy', x:200, y:410, w:200, h:44, label:'DEPLOY!', type:'deploy'});
}

function handleLoadoutClick(e) {
  let {mx, my} = getCellFromMouse(e);
  // Use raw pixel coords
  let rect = canvas.getBoundingClientRect();
  let scaleX = canvas.width / rect.width;
  let scaleY = canvas.height / rect.height;
  let px = (e.clientX - rect.left) * scaleX;
  let py = (e.clientY - rect.top) * scaleY;

  for (let btn of loadoutButtons) {
    if (px >= btn.x && px <= btn.x+btn.w && py >= btn.y && py <= btn.y+btn.h) {
      if (btn.type === 'tab') {
        loadoutSlot = btn.id === 'slot0' ? 0 : 1;
      } else if (btn.type === 'weapon') {
        playerLoadout[loadoutSlot].weapon = btn.key;
      } else if (btn.type === 'armor') {
        playerLoadout[loadoutSlot].armor = btn.key;
      } else if (btn.type === 'deploy') {
        startCombat();
      }
      return;
    }
  }
}

function handleLoadoutHover(e) {
  let rect = canvas.getBoundingClientRect();
  let scaleX = canvas.width / rect.width;
  let scaleY = canvas.height / rect.height;
  let px = (e.clientX - rect.left) * scaleX;
  let py = (e.clientY - rect.top) * scaleY;
  loadoutHover = null;
  for (let btn of loadoutButtons) {
    if (px >= btn.x && px <= btn.x+btn.w && py >= btn.y && py <= btn.y+btn.h) {
      loadoutHover = btn.id;
      break;
    }
  }
}

function drawLoadout() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, 600, 500);

  ctx.fillStyle = '#8af';
  ctx.font = 'bold 22px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('MECH LOADOUT', 300, 30);

  ctx.font = '12px Courier New';
  ctx.fillStyle = '#889';
  ctx.fillText('Choose weapon and armor for each mech', 300, 90);

  // Labels
  ctx.textAlign = 'center';
  ctx.font = 'bold 14px Courier New';
  ctx.fillStyle = '#8af';
  ctx.fillText('WEAPONS', 170, 120);
  ctx.fillText('ARMOR', 440, 120);

  for (let btn of loadoutButtons) {
    let selected = false;
    if (btn.type === 'weapon') selected = playerLoadout[loadoutSlot].weapon === btn.key;
    if (btn.type === 'armor') selected = playerLoadout[loadoutSlot].armor === btn.key;
    if (btn.type === 'tab') selected = (btn.id === 'slot'+loadoutSlot);

    let hover = loadoutHover === btn.id;
    let borderColor = selected ? '#8af' : (hover ? '#8af88' : '#445');
    let bgColor = selected ? 'rgba(136,170,255,0.15)' : (hover ? 'rgba(136,170,255,0.07)' : 'rgba(30,30,50,0.8)');

    ctx.fillStyle = bgColor;
    ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = selected ? 2 : 1;
    ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);

    if (selected && btn.type !== 'tab' && btn.type !== 'deploy') {
      ctx.shadowColor = '#8af';
      ctx.shadowBlur = 10;
      ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
      ctx.shadowBlur = 0;
    }

    ctx.textAlign = 'left';
    if (btn.type === 'deploy' || btn.type === 'tab') {
      ctx.textAlign = 'center';
      ctx.font = 'bold 16px Courier New';
      ctx.fillStyle = selected ? '#8af' : '#ccc';
      ctx.fillText(btn.label, btn.x + btn.w/2, btn.y + btn.h/2 + 5);
    } else {
      // Colored dot
      ctx.fillStyle = btn.color || '#8af';
      ctx.beginPath();
      ctx.arc(btn.x + 16, btn.y + 15, 5, 0, Math.PI*2);
      ctx.fill();

      ctx.font = 'bold 14px Courier New';
      ctx.fillStyle = '#eee';
      ctx.fillText(btn.label, btn.x + 28, btn.y + 18);

      ctx.font = '11px Courier New';
      ctx.fillStyle = '#889';
      ctx.fillText(btn.sub, btn.x + 28, btn.y + 35);
    }
  }

  // Show current loadout summary
  ctx.textAlign = 'center';
  ctx.font = '12px Courier New';
  ctx.fillStyle = '#8af';
  let ly = 380;
  for (let i = 0; i < 2; i++) {
    let lo = playerLoadout[i];
    let w = WEAPONS[lo.weapon], a = ARMORS[lo.armor];
    ctx.fillStyle = i === loadoutSlot ? '#8af' : '#667';
    ctx.fillText(`Mech ${i+1}: ${w.name} + ${a.name} (HP:${a.hp} DMG:${w.dmg} RNG:${w.range})`, 300, ly + i*18);
  }
}

// ============================================================
// RENDERING — COMBAT
// ============================================================
function drawGrid() {
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      let x = GRID_OX + c * CELL;
      let y = GRID_OY + r * CELL;

      // Base cell
      ctx.fillStyle = (r+c)%2 === 0 ? '#181830' : '#1e1e3a';
      ctx.fillRect(x, y, CELL, CELL);

      // Terrain
      if (grid[r][c] === 1) {
        // Wall
        ctx.fillStyle = '#556';
        ctx.fillRect(x+2, y+2, CELL-4, CELL-4);
        ctx.strokeStyle = '#778';
        ctx.lineWidth = 1;
        // Brick pattern
        for (let by = 0; by < 3; by++) {
          let bx0 = x+3 + (by%2)*8;
          ctx.strokeRect(bx0, y+3+by*13, 16, 12);
          ctx.strokeRect(bx0+16, y+3+by*13, 16, 12);
        }
      } else if (grid[r][c] === 2) {
        // Cover
        ctx.fillStyle = '#2a3a2a';
        ctx.fillRect(x+4, y+4, CELL-8, CELL-8);
        ctx.strokeStyle = '#4a6a4a';
        ctx.lineWidth = 1;
        ctx.strokeRect(x+4, y+4, CELL-8, CELL-8);
        ctx.fillStyle = '#4a6a4a';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('CVR', x+CELL/2, y+CELL/2+3);
      } else if (grid[r][c] === 3) {
        // Destroyed
        ctx.fillStyle = '#1a1410';
        ctx.fillRect(x+2, y+2, CELL-4, CELL-4);
        ctx.fillStyle = '#332a20';
        ctx.fillRect(x+8, y+12, 10, 8);
        ctx.fillRect(x+22, y+20, 12, 6);
      }

      // Grid lines
      ctx.strokeStyle = '#2a2a4a';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(x, y, CELL, CELL);
    }
  }
}

function drawHighlights() {
  // Valid moves
  for (let m of validMoves) {
    let x = GRID_OX + m.x * CELL;
    let y = GRID_OY + m.y * CELL;
    ctx.fillStyle = 'rgba(136,170,255,0.18)';
    ctx.fillRect(x+1, y+1, CELL-2, CELL-2);
    ctx.strokeStyle = 'rgba(136,170,255,0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
  }

  // Valid targets
  for (let t of validTargets) {
    let x = GRID_OX + t.x * CELL;
    let y = GRID_OY + t.y * CELL;
    ctx.fillStyle = 'rgba(255,68,68,0.2)';
    ctx.fillRect(x+1, y+1, CELL-2, CELL-2);
    ctx.strokeStyle = '#f44';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
    // Crosshair
    ctx.beginPath();
    ctx.moveTo(x+CELL/2-8, y+CELL/2);
    ctx.lineTo(x+CELL/2+8, y+CELL/2);
    ctx.moveTo(x+CELL/2, y+CELL/2-8);
    ctx.lineTo(x+CELL/2, y+CELL/2+8);
    ctx.strokeStyle = '#f44';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Current mech highlight
  if (gameState === 'combat' && currentMechIdx < mechs.length) {
    let cm = mechs[currentMechIdx];
    if (cm && cm.alive) {
      let x = GRID_OX + cm.x * CELL;
      let y = GRID_OY + cm.y * CELL;
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 8;
      ctx.strokeRect(x+1, y+1, CELL-2, CELL-2);
      ctx.shadowBlur = 0;
    }
  }
}

function drawMechs() {
  for (let m of mechs) {
    if (!m.alive) continue;
    let x = GRID_OX + m.x * CELL + CELL/2;
    let y = GRID_OY + m.y * CELL + CELL/2;
    let aColor = ARMORS[m.armor].color;
    let isPlayer = m.owner === 'player';

    // Body
    ctx.save();

    // Shadow/glow
    if (m.overheated) {
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 12;
    } else {
      ctx.shadowColor = isPlayer ? '#8af' : '#f66';
      ctx.shadowBlur = 6;
    }

    // Mech body (hexagonal shape)
    ctx.beginPath();
    let s = 16;
    for (let i = 0; i < 6; i++) {
      let angle = Math.PI/6 + i * Math.PI/3;
      let px = x + Math.cos(angle) * s;
      let py = y + Math.sin(angle) * s;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = isPlayer ? '#2244aa' : '#882244';
    ctx.fill();
    ctx.strokeStyle = aColor;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Weapon indicator
    let wColor = WEAPONS[m.weapon].color;
    ctx.fillStyle = wColor;
    ctx.beginPath();
    ctx.arc(x, y-3, 4, 0, Math.PI*2);
    ctx.fill();

    // Mech ID
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(m.id, x, y+5);

    // Owner indicator
    ctx.fillStyle = isPlayer ? '#8af' : '#f88';
    ctx.font = '8px Courier New';
    ctx.fillText(isPlayer ? 'PLR' : 'AI', x, y + 14);

    ctx.restore();

    // HP bar
    let barW = 32, barH = 4;
    let bx = x - barW/2, by = GRID_OY + m.y * CELL - 2;
    ctx.fillStyle = '#333';
    ctx.fillRect(bx, by, barW, barH);
    let hpPct = m.hp / m.maxHp;
    ctx.fillStyle = hpPct > 0.6 ? '#4f4' : (hpPct > 0.3 ? '#fa0' : '#f44');
    ctx.fillRect(bx, by, barW * hpPct, barH);

    // Heat bar
    let hby = GRID_OY + m.y * CELL + CELL + 1;
    ctx.fillStyle = '#222';
    ctx.fillRect(bx, hby, barW, 3);
    let heatPct = m.heat / m.heatCap;
    ctx.fillStyle = m.overheated ? '#f44' : (heatPct > 0.7 ? '#fa0' : '#44a');
    ctx.fillRect(bx, hby, barW * heatPct, 3);
  }
}

function drawAnimations() {
  for (let i = animations.length-1; i >= 0; i--) {
    let a = animations[i];
    a.timer--;
    if (a.timer <= 0) { animations.splice(i, 1); continue; }

    if (a.type === 'beam') {
      let x1 = GRID_OX + a.x1*CELL + CELL/2;
      let y1 = GRID_OY + a.y1*CELL + CELL/2;
      let x2 = GRID_OX + a.x2*CELL + CELL/2;
      let y2 = GRID_OY + a.y2*CELL + CELL/2;

      let alpha = a.timer / 20;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = a.color;
      ctx.lineWidth = 3;
      ctx.shadowColor = a.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.restore();

      // Impact flash
      if (a.timer > 14) {
        ctx.save();
        ctx.globalAlpha = (a.timer-14)/6;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x2, y2, 12, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // Damage numbers
      if (a.timer > 8 && a.timer < 16) {
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        for (let r of a.results) {
          if (r.hit) {
            ctx.fillStyle = '#ff4';
            ctx.fillText('-'+r.dmg, x2 + (Math.random()-0.5)*10, y2 - 20 + (16-a.timer)*2);
          } else {
            ctx.fillStyle = '#888';
            ctx.fillText('MISS', x2, y2 - 20);
          }
        }
      }
    }

    if (a.type === 'explode') {
      let x = GRID_OX + a.x*CELL + CELL/2;
      let y = GRID_OY + a.y*CELL + CELL/2;
      let alpha = a.timer / 15;
      let radius = (15 - a.timer) * 2 + 5;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = a.color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }
}

function drawCombatInfo() {
  // Right side info panel area (using space below grid if needed)
  let infoX = GRID_OX + GRID_COLS * CELL + 10;
  let infoY = GRID_OY;
  let panelW = 600 - infoX - 5;

  if (panelW < 80) return; // not enough space

  ctx.fillStyle = 'rgba(26,26,46,0.9)';
  ctx.fillRect(infoX-4, infoY-4, panelW+8, GRID_ROWS*CELL+8);

  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'left';

  let ly = infoY + 10;
  for (let m of mechs) {
    let isPlayer = m.owner === 'player';
    ctx.fillStyle = m.alive ? (isPlayer ? '#8af' : '#f88') : '#444';
    let prefix = isPlayer ? 'P' : 'A';
    ctx.fillText(`${prefix}${m.id} ${WEAPONS[m.weapon].name.substr(0,4)}`, infoX, ly);
    ly += 12;
    ctx.fillStyle = m.alive ? '#aaa' : '#444';
    ctx.fillText(`HP:${m.hp}/${m.maxHp}`, infoX, ly);
    ly += 12;
    let heatStr = m.overheated ? 'OVRHEAT' : `H:${m.heat}/${m.heatCap}`;
    ctx.fillStyle = m.overheated ? '#f44' : '#889';
    ctx.fillText(heatStr, infoX, ly);
    ly += 16;
  }

  // Combat log
  ly += 4;
  ctx.fillStyle = '#667';
  ctx.font = '9px Courier New';
  ctx.fillText('-- LOG --', infoX, ly);
  ly += 12;
  for (let log of combatLog) {
    ctx.fillStyle = '#778';
    // Wrap long text
    let txt = log.length > 16 ? log.substr(0,16) : log;
    ctx.fillText(txt, infoX, ly);
    ly += 11;
    if (log.length > 16) {
      ctx.fillText(log.substr(16), infoX, ly);
      ly += 11;
    }
    if (ly > infoY + GRID_ROWS*CELL - 5) break;
  }
}

// ============================================================
// MAIN DRAW
// ============================================================
function draw() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, 600, 500);

  if (gameState === 'loadout') {
    drawLoadout();
  } else if (gameState === 'combat' || gameState === 'gameover') {
    drawGrid();
    drawHighlights();
    drawMechs();
    drawAnimations();
    drawCombatInfo();
  }

  requestAnimationFrame(draw);
}

// ============================================================
// GAME START
// ============================================================
function startGame() {
  score = 0;
  turnNumber = 0;
  mechs = [];
  animations = [];
  combatLog = [];
  currentMechIdx = 0;
  loadoutSlot = 0;
  playerLoadout = [{weapon:'laser',armor:'medium'},{weapon:'missile',armor:'medium'}];
  validMoves = [];
  validTargets = [];
  aiThinking = false;

  gameState = 'loadout';
  overlay.style.display = 'none';
  buildLoadoutButtons();
  updateHUD();
  setStatus('Choose weapons and armor for your 2 mechs, then click DEPLOY!');
}

// Boot
buildLoadoutButtons();
updateHUD();
draw();
</script>
<script src="../recorder.js"></script>
</body>
</html>

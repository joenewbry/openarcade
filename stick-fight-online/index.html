<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stick Fight Online</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #ff4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 255, 68, 0.5); }
    h1 { color: #ff4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 255, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ff4; }
    canvas {
      border: 2px solid #ff4;
      box-shadow: 0 0 20px rgba(255, 255, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ff4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255, 255, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
    .controls { width: 600px; margin-top: 12px; color: #777; font-size: 0.8rem; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>STICK FIGHT ONLINE</h1>
  </div>
  <div class="score-bar">
    <div>YOU: <span id="p1Score">0</span></div>
    <div>Round: <span id="roundNum">1</span></div>
    <div>Kills: <span id="killCount">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">STICK FIGHT ONLINE</h2>
      <p id="overlayText">Click to Start</p>
      <p style="font-size:0.8rem;color:#888;margin-top:8px;">Arrows: Move/Jump | Z: Attack | X: Pickup/Throw | C: Special</p>
    </div>
  </div>
  <div class="controls">
    Arrows: Move/Jump &nbsp;|&nbsp; Z: Attack &nbsp;|&nbsp; X: Pickup/Throw &nbsp;|&nbsp; C: Special &nbsp;|&nbsp; First to 5 wins!
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    let gameState = 'waiting';
    let score = 0;

    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const p1ScoreEl = document.getElementById('p1Score');
    const roundNumEl = document.getElementById('roundNum');
    const killCountEl = document.getElementById('killCount');

    // Input
    const keys = {};
    const keysJust = {};
    document.addEventListener('keydown', e => {
      if (!keys[e.key]) keysJust[e.key] = true;
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','z','x','c'].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // Constants
    const GRAVITY = 0.45;
    const JUMP_FORCE = -9;
    const MOVE_SPEED = 2.8;
    const PLAYER_W = 12, PLAYER_H = 30;
    const LAVA_RISE_SPEED = 0.15;
    const CRUMBLE_TIME = 120; // frames standing before crumble
    const WIN_SCORE = 5;
    const COLORS = ['#4af','#f44','#4f4','#f8f'];
    const WEAPON_TYPES = ['sword','gun','grenade','laser'];

    // Game state vars
    let players = [];
    let platforms = [];
    let projectiles = [];
    let particles = [];
    let weaponPickups = [];
    let lavaY = H + 50;
    let roundNum = 0;
    let totalKills = 0;
    let roundTimer = 0;
    let roundOver = false;
    let roundOverTimer = 0;
    let matchOver = false;

    // Platform class
    class Platform {
      constructor(x, y, w, h, type) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.type = type || 'normal'; // normal, crumble
        this.hp = 1;
        this.crumbleTimer = 0;
        this.crumbling = false;
        this.shakeX = 0;
        this.dead = false;
        this.originalY = y;
      }
      update() {
        if (this.crumbling) {
          this.crumbleTimer++;
          this.shakeX = (Math.random() - 0.5) * 3;
          if (this.crumbleTimer > CRUMBLE_TIME) {
            this.dead = true;
            for (let i = 0; i < 8; i++) {
              particles.push(new Particle(this.x + Math.random() * this.w, this.y, (Math.random()-0.5)*3, -Math.random()*2, '#886', 20));
            }
          }
        }
      }
      draw() {
        if (this.dead) return;
        let alpha = this.crumbling ? Math.max(0.3, 1 - this.crumbleTimer / CRUMBLE_TIME) : 1;
        ctx.globalAlpha = alpha;
        let dx = this.crumbling ? this.shakeX : 0;
        if (this.type === 'crumble') {
          ctx.fillStyle = '#665533';
          ctx.fillRect(this.x + dx, this.y, this.w, this.h);
          ctx.strokeStyle = '#aa8844';
          ctx.lineWidth = 1;
          ctx.strokeRect(this.x + dx, this.y, this.w, this.h);
          // crack lines
          if (this.crumbling) {
            ctx.strokeStyle = '#332211';
            ctx.beginPath();
            ctx.moveTo(this.x + dx + this.w * 0.3, this.y);
            ctx.lineTo(this.x + dx + this.w * 0.5, this.y + this.h);
            ctx.moveTo(this.x + dx + this.w * 0.7, this.y);
            ctx.lineTo(this.x + dx + this.w * 0.4, this.y + this.h);
            ctx.stroke();
          }
        } else {
          ctx.fillStyle = '#444466';
          ctx.fillRect(this.x + dx, this.y, this.w, this.h);
          ctx.strokeStyle = '#6666aa';
          ctx.lineWidth = 1;
          ctx.strokeRect(this.x + dx, this.y, this.w, this.h);
        }
        ctx.globalAlpha = 1;
      }
    }

    // Particle class
    class Particle {
      constructor(x, y, vx, vy, color, life) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.life = life; this.maxLife = life;
        this.size = 2 + Math.random() * 3;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;
        this.life--;
      }
      draw() {
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.globalAlpha = 1;
      }
    }

    // Projectile class
    class Projectile {
      constructor(x, y, vx, vy, type, owner) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.type = type; this.owner = owner;
        this.life = type === 'laser' ? 15 : (type === 'grenade' ? 90 : 60);
        this.bounces = 0;
        this.radius = type === 'grenade' ? 4 : 2;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.type === 'grenade') {
          this.vy += GRAVITY * 0.6;
          // Bounce off platforms
          for (let p of platforms) {
            if (p.dead) continue;
            if (this.x > p.x && this.x < p.x + p.w && this.y + this.radius > p.y && this.y - this.radius < p.y + p.h) {
              this.vy = -Math.abs(this.vy) * 0.6;
              this.y = p.y - this.radius;
              this.bounces++;
            }
          }
        }
        if (this.type === 'laser') {
          // Laser moves fast and straight
        }
        this.life--;
        if (this.x < -20 || this.x > W + 20 || this.y > H + 20) this.life = 0;
      }
      draw() {
        if (this.type === 'bullet') {
          ctx.fillStyle = '#ff0';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 6;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (this.type === 'grenade') {
          ctx.fillStyle = '#0a0';
          ctx.beginPath();
          ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#0f0';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (this.type === 'laser') {
          ctx.strokeStyle = '#f0f';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#f0f';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(this.x - this.vx * 3, this.y - this.vy * 3);
          ctx.lineTo(this.x, this.y);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
      }
      explode() {
        if (this.type === 'grenade') {
          for (let i = 0; i < 20; i++) {
            let a = Math.random() * Math.PI * 2;
            let s = 2 + Math.random() * 4;
            particles.push(new Particle(this.x, this.y, Math.cos(a)*s, Math.sin(a)*s, '#f80', 25));
          }
          // damage all players in radius
          let blastR = 60;
          for (let p of players) {
            if (p.dead) continue;
            let dx = (p.x + PLAYER_W/2) - this.x;
            let dy = (p.y + PLAYER_H/2) - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < blastR) {
              let dmg = Math.floor(40 * (1 - dist/blastR));
              p.takeDamage(dmg, this.owner, dx > 0 ? 1 : -1);
            }
          }
          // destroy crumble platforms nearby
          for (let pl of platforms) {
            if (pl.dead) continue;
            let cx = pl.x + pl.w/2, cy = pl.y + pl.h/2;
            let dist = Math.sqrt((cx-this.x)**2 + (cy-this.y)**2);
            if (dist < blastR && pl.type === 'crumble') {
              pl.dead = true;
              for (let i = 0; i < 6; i++) {
                particles.push(new Particle(cx, cy, (Math.random()-0.5)*4, -Math.random()*3, '#886', 20));
              }
            }
          }
        }
      }
    }

    // Weapon pickup
    class WeaponPickup {
      constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.vy = 0;
        this.grounded = false;
        this.timer = 0;
        this.bobOffset = Math.random() * Math.PI * 2;
      }
      update() {
        this.timer++;
        if (!this.grounded) {
          this.vy += GRAVITY;
          this.y += this.vy;
          for (let p of platforms) {
            if (p.dead) continue;
            if (this.x > p.x - 6 && this.x < p.x + p.w + 6 && this.y + 6 > p.y && this.y < p.y + p.h) {
              this.y = p.y - 6;
              this.vy = 0;
              this.grounded = true;
            }
          }
          if (this.y > H) this.grounded = true; // fell off
        }
      }
      draw() {
        if (this.y > H) return;
        let by = Math.sin(this.timer * 0.05 + this.bobOffset) * 2;
        let colors = { sword: '#aaf', gun: '#ff4', grenade: '#0f0', laser: '#f0f' };
        ctx.fillStyle = colors[this.type] || '#fff';
        ctx.shadowColor = colors[this.type] || '#fff';
        ctx.shadowBlur = 8;
        if (this.type === 'sword') {
          ctx.fillRect(this.x - 1, this.y - 10 + by, 3, 14);
          ctx.fillStyle = '#664';
          ctx.fillRect(this.x - 3, this.y + 2 + by, 7, 3);
        } else if (this.type === 'gun') {
          ctx.fillRect(this.x - 6, this.y - 2 + by, 12, 4);
          ctx.fillRect(this.x - 2, this.y + 2 + by, 4, 5);
        } else if (this.type === 'grenade') {
          ctx.beginPath();
          ctx.arc(this.x, this.y + by, 5, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.type === 'laser') {
          ctx.fillRect(this.x - 7, this.y - 2 + by, 14, 4);
          ctx.fillStyle = '#a0a';
          ctx.fillRect(this.x + 5, this.y - 3 + by, 3, 6);
        }
        ctx.shadowBlur = 0;
      }
    }

    // Fighter class
    class Fighter {
      constructor(x, y, idx, isAI) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.idx = idx;
        this.isAI = isAI;
        this.color = COLORS[idx];
        this.hp = 100;
        this.dead = false;
        this.facing = idx === 0 ? 1 : -1;
        this.grounded = false;
        this.weapon = null; // {type, ammo}
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.hitTimer = 0;
        this.specialCooldown = 0;
        this.animFrame = 0;
        this.walkCycle = 0;
        this.deathTimer = 0;
        this.score = 0;
        this.jumpCount = 0;
        this.maxJumps = 2;
        this.onPlatform = null;
        // AI state
        this.aiTarget = null;
        this.aiAction = 'idle';
        this.aiTimer = 0;
        this.aiJumpTimer = 0;
        this.aiAttackTimer = 0;
        this.aiPickupTarget = null;
      }

      reset(x, y) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.hp = 100;
        this.dead = false;
        this.weapon = null;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.hitTimer = 0;
        this.specialCooldown = 0;
        this.deathTimer = 0;
        this.jumpCount = 0;
        this.onPlatform = null;
        this.grounded = false;
      }

      takeDamage(dmg, attacker, dir) {
        if (this.dead) return;
        this.hp -= dmg;
        this.hitTimer = 10;
        this.vx = dir * 5;
        this.vy = -3;
        // Hit particles
        for (let i = 0; i < 6; i++) {
          particles.push(new Particle(
            this.x + PLAYER_W/2, this.y + PLAYER_H/3,
            (Math.random()-0.5)*5 + dir*2, (Math.random()-0.5)*4,
            this.color, 15
          ));
        }
        if (this.hp <= 0) {
          this.die(attacker);
        }
      }

      die(killer) {
        this.dead = true;
        this.deathTimer = 60;
        // Death particles
        for (let i = 0; i < 15; i++) {
          particles.push(new Particle(
            this.x + PLAYER_W/2, this.y + PLAYER_H/2,
            (Math.random()-0.5)*6, (Math.random()-0.5)*6 - 2,
            this.color, 30
          ));
        }
        if (killer !== undefined && killer !== this.idx) {
          let k = players[killer];
          if (k) {
            k.score++;
            if (killer === 0) {
              totalKills++;
              killCountEl.textContent = totalKills;
            }
          }
        }
        // Drop weapon
        if (this.weapon) {
          weaponPickups.push(new WeaponPickup(this.x + PLAYER_W/2, this.y, this.weapon.type));
          this.weapon = null;
        }
      }

      pickup() {
        if (this.weapon) {
          // Throw weapon as projectile
          this.throwWeapon();
          return;
        }
        let best = null, bestD = 30;
        for (let i = 0; i < weaponPickups.length; i++) {
          let wp = weaponPickups[i];
          let dx = (this.x + PLAYER_W/2) - wp.x;
          let dy = (this.y + PLAYER_H/2) - wp.y;
          let d = Math.sqrt(dx*dx + dy*dy);
          if (d < bestD) { bestD = d; best = i; }
        }
        if (best !== null) {
          let wp = weaponPickups[best];
          let ammo = { sword: 999, gun: 6, grenade: 3, laser: 4 };
          this.weapon = { type: wp.type, ammo: ammo[wp.type] };
          weaponPickups.splice(best, 1);
        }
      }

      throwWeapon() {
        if (!this.weapon) return;
        let speed = 8;
        projectiles.push(new Projectile(
          this.x + PLAYER_W/2 + this.facing * 10, this.y + PLAYER_H/3,
          this.facing * speed, -1,
          this.weapon.type === 'grenade' ? 'grenade' : 'bullet', this.idx
        ));
        this.weapon = null;
      }

      attack() {
        if (this.attackCooldown > 0) return;
        this.attackTimer = 12;

        if (!this.weapon) {
          // Punch
          this.attackCooldown = 18;
          let punchX = this.x + PLAYER_W/2 + this.facing * 20;
          let punchY = this.y + PLAYER_H/3;
          for (let p of players) {
            if (p.idx === this.idx || p.dead) continue;
            let dx = (p.x + PLAYER_W/2) - punchX;
            let dy = (p.y + PLAYER_H/2) - punchY;
            if (Math.abs(dx) < 18 && Math.abs(dy) < 22) {
              p.takeDamage(12, this.idx, this.facing);
            }
          }
          // Punch particles
          particles.push(new Particle(punchX, punchY, this.facing*2, 0, '#ff4', 8));
        } else if (this.weapon.type === 'sword') {
          this.attackCooldown = 14;
          let range = 30;
          let sx = this.x + PLAYER_W/2 + this.facing * range/2;
          let sy = this.y + PLAYER_H/3;
          for (let p of players) {
            if (p.idx === this.idx || p.dead) continue;
            let dx = (p.x + PLAYER_W/2) - sx;
            let dy = (p.y + PLAYER_H/2) - sy;
            if (Math.abs(dx) < range && Math.abs(dy) < 24) {
              p.takeDamage(22, this.idx, this.facing);
            }
          }
          // Slash particles
          for (let i = 0; i < 4; i++) {
            particles.push(new Particle(sx + Math.random()*10*this.facing, sy + (Math.random()-0.5)*20, this.facing*3, (Math.random()-0.5)*2, '#aaf', 10));
          }
        } else if (this.weapon.type === 'gun') {
          this.attackCooldown = 12;
          this.weapon.ammo--;
          projectiles.push(new Projectile(
            this.x + PLAYER_W/2 + this.facing * 12, this.y + PLAYER_H/3,
            this.facing * 10, 0, 'bullet', this.idx
          ));
          if (this.weapon.ammo <= 0) this.weapon = null;
        } else if (this.weapon.type === 'grenade') {
          this.attackCooldown = 30;
          this.weapon.ammo--;
          projectiles.push(new Projectile(
            this.x + PLAYER_W/2 + this.facing * 10, this.y,
            this.facing * 5, -4, 'grenade', this.idx
          ));
          if (this.weapon.ammo <= 0) this.weapon = null;
        } else if (this.weapon.type === 'laser') {
          this.attackCooldown = 20;
          this.weapon.ammo--;
          projectiles.push(new Projectile(
            this.x + PLAYER_W/2 + this.facing * 12, this.y + PLAYER_H/3,
            this.facing * 14, 0, 'laser', this.idx
          ));
          if (this.weapon.ammo <= 0) this.weapon = null;
        }
      }

      special() {
        if (this.specialCooldown > 0) return;
        this.specialCooldown = 60;
        // Dash attack
        this.vx = this.facing * 12;
        this.vy = -2;
        this.attackTimer = 15;
        // Hit everything in dash path
        let sx = this.x + PLAYER_W/2;
        let sy = this.y + PLAYER_H/2;
        for (let p of players) {
          if (p.idx === this.idx || p.dead) continue;
          let dx = (p.x + PLAYER_W/2) - sx;
          let dy = (p.y + PLAYER_H/2) - sy;
          if (Math.abs(dy) < 24 && dx * this.facing > 0 && Math.abs(dx) < 50) {
            p.takeDamage(18, this.idx, this.facing);
          }
        }
        for (let i = 0; i < 8; i++) {
          particles.push(new Particle(sx, sy, -this.facing*(1+Math.random()*2), (Math.random()-0.5)*3, '#ff4', 12));
        }
      }

      updateAI() {
        this.aiTimer++;

        // Find closest alive enemy
        let closest = null, closestD = Infinity;
        for (let p of players) {
          if (p.idx === this.idx || p.dead) continue;
          let d = Math.abs(p.x - this.x) + Math.abs(p.y - this.y);
          if (d < closestD) { closestD = d; closest = p; }
        }
        this.aiTarget = closest;

        // Look for weapon pickups if unarmed
        if (!this.weapon && weaponPickups.length > 0) {
          let bestPick = null, bestPickD = Infinity;
          for (let wp of weaponPickups) {
            if (wp.y > H) continue;
            let d = Math.abs(wp.x - this.x) + Math.abs(wp.y - this.y);
            if (d < bestPickD) { bestPickD = d; bestPick = wp; }
          }
          if (bestPick && bestPickD < 150) {
            this.aiPickupTarget = bestPick;
            // Move toward pickup
            let dx = bestPick.x - (this.x + PLAYER_W/2);
            if (Math.abs(dx) > 8) {
              this.vx = dx > 0 ? MOVE_SPEED : -MOVE_SPEED;
              this.facing = dx > 0 ? 1 : -1;
            }
            // Jump to reach pickup if it's above
            if (bestPick.y < this.y - 20 && this.grounded && this.aiJumpTimer <= 0) {
              this.vy = JUMP_FORCE;
              this.grounded = false;
              this.jumpCount = 1;
              this.aiJumpTimer = 20;
            }
            // Try to pick up
            if (Math.abs(dx) < 25 && Math.abs(bestPick.y - this.y) < 30) {
              this.pickup();
              this.aiPickupTarget = null;
            }
            this.aiJumpTimer--;
            return;
          }
        }

        if (!closest) return;

        let dx = closest.x - this.x;
        let dy = closest.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        this.facing = dx > 0 ? 1 : -1;

        // Avoid lava
        if (this.y + PLAYER_H > lavaY - 40) {
          // Need to get higher
          if (this.grounded && this.aiJumpTimer <= 0) {
            this.vy = JUMP_FORCE;
            this.grounded = false;
            this.jumpCount = 1;
            this.aiJumpTimer = 15;
          } else if (!this.grounded && this.jumpCount < this.maxJumps && this.aiJumpTimer <= 0) {
            this.vy = JUMP_FORCE;
            this.jumpCount++;
            this.aiJumpTimer = 15;
          }
          // Move toward center
          let cx = W/2 - this.x;
          this.vx = cx > 0 ? MOVE_SPEED : -MOVE_SPEED;
          this.aiJumpTimer--;
          return;
        }

        // Navigate platforms - look for nearest safe platform
        let onSafe = false;
        for (let pl of platforms) {
          if (pl.dead) continue;
          if (this.x + PLAYER_W > pl.x && this.x < pl.x + pl.w &&
              Math.abs((this.y + PLAYER_H) - pl.y) < 5) {
            onSafe = true;
            // If on crumbling platform, jump off
            if (pl.crumbling && pl.crumbleTimer > CRUMBLE_TIME * 0.6) {
              if (this.aiJumpTimer <= 0) {
                this.vy = JUMP_FORCE;
                this.grounded = false;
                this.jumpCount = 1;
                this.aiJumpTimer = 15;
                this.vx = (Math.random() > 0.5 ? 1 : -1) * MOVE_SPEED;
              }
            }
            break;
          }
        }

        // Combat behavior
        if (dist < 35 && !this.weapon) {
          // Close range - punch
          if (this.aiAttackTimer <= 0) {
            this.attack();
            this.aiAttackTimer = 15 + Math.random() * 10;
          }
          // Sometimes dodge back
          if (Math.random() < 0.02) {
            this.vx = -this.facing * MOVE_SPEED;
          }
        } else if (dist < 50 && this.weapon && this.weapon.type === 'sword') {
          // Sword range
          if (this.aiAttackTimer <= 0) {
            this.attack();
            this.aiAttackTimer = 12 + Math.random() * 8;
          }
        } else if (this.weapon && (this.weapon.type === 'gun' || this.weapon.type === 'laser') && dist < 250 && Math.abs(dy) < 40) {
          // Ranged attack
          if (this.aiAttackTimer <= 0) {
            this.attack();
            this.aiAttackTimer = 15 + Math.random() * 15;
          }
        } else if (this.weapon && this.weapon.type === 'grenade' && dist < 200 && dist > 60) {
          if (this.aiAttackTimer <= 0) {
            this.attack();
            this.aiAttackTimer = 30 + Math.random() * 20;
          }
        } else {
          // Move toward target
          if (Math.abs(dx) > 25) {
            this.vx = dx > 0 ? MOVE_SPEED : -MOVE_SPEED;
          }
        }

        // Jump to reach target or over gaps
        if (dy < -30 && this.grounded && this.aiJumpTimer <= 0) {
          this.vy = JUMP_FORCE;
          this.grounded = false;
          this.jumpCount = 1;
          this.aiJumpTimer = 25;
        }

        // Random jump during combat
        if (dist < 60 && Math.random() < 0.03 && this.grounded && this.aiJumpTimer <= 0) {
          this.vy = JUMP_FORCE;
          this.grounded = false;
          this.jumpCount = 1;
          this.aiJumpTimer = 20;
        }

        // Use special occasionally
        if (dist < 80 && dist > 30 && this.specialCooldown <= 0 && Math.random() < 0.01) {
          this.special();
        }

        // Double jump if falling toward lava
        if (!this.grounded && this.vy > 0 && this.y + PLAYER_H > lavaY - 60 && this.jumpCount < this.maxJumps && this.aiJumpTimer <= 0) {
          this.vy = JUMP_FORCE;
          this.jumpCount++;
          this.aiJumpTimer = 15;
        }

        this.aiJumpTimer--;
        this.aiAttackTimer--;
      }

      update() {
        if (this.dead) {
          this.deathTimer--;
          return;
        }

        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.specialCooldown > 0) this.specialCooldown--;
        if (this.hitTimer > 0) this.hitTimer--;
        if (this.attackTimer > 0) this.attackTimer--;

        if (this.isAI) {
          this.updateAI();
        } else {
          // Player input
          if (keys['ArrowLeft']) {
            this.vx = -MOVE_SPEED;
            this.facing = -1;
          } else if (keys['ArrowRight']) {
            this.vx = MOVE_SPEED;
            this.facing = 1;
          }
          if (keysJust['ArrowUp'] && this.jumpCount < this.maxJumps) {
            this.vy = JUMP_FORCE;
            this.grounded = false;
            this.jumpCount++;
          }
          if (keysJust['z']) this.attack();
          if (keysJust['x']) this.pickup();
          if (keysJust['c']) this.special();
        }

        // Physics
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.85;

        // Platform collisions
        this.grounded = false;
        this.onPlatform = null;
        for (let p of platforms) {
          if (p.dead) continue;
          // Only top collision (can jump through from below)
          if (this.vy >= 0 &&
              this.x + PLAYER_W > p.x && this.x < p.x + p.w &&
              this.y + PLAYER_H > p.y && this.y + PLAYER_H - this.vy <= p.y + 4) {
            this.y = p.y - PLAYER_H;
            this.vy = 0;
            this.grounded = true;
            this.jumpCount = 0;
            this.onPlatform = p;
            // Trigger crumble
            if (p.type === 'crumble' && !p.crumbling) {
              p.crumbling = true;
            }
          }
        }

        // Wall bounds
        if (this.x < 0) { this.x = 0; this.vx = 0; }
        if (this.x + PLAYER_W > W) { this.x = W - PLAYER_W; this.vx = 0; }

        // Lava death
        if (this.y + PLAYER_H > lavaY) {
          this.hp = 0;
          // Find nearest alive enemy to credit the kill (or self)
          let killer = this.idx;
          let minD = Infinity;
          for (let p of players) {
            if (p.idx === this.idx || p.dead) continue;
            let d = Math.abs(p.x - this.x);
            if (d < minD) { minD = d; killer = p.idx; }
          }
          this.die(killer);
        }

        // Fall death
        if (this.y > H + 50) {
          if (!this.dead) {
            let killer = this.idx;
            let minD = Infinity;
            for (let p of players) {
              if (p.idx === this.idx || p.dead) continue;
              let d = Math.abs(p.x - this.x);
              if (d < minD) { minD = d; killer = p.idx; }
            }
            this.die(killer);
          }
        }

        // Walk cycle
        if (this.grounded && Math.abs(this.vx) > 0.5) {
          this.walkCycle += 0.2;
        } else {
          this.walkCycle = 0;
        }
      }

      draw() {
        if (this.dead) return;
        let cx = this.x + PLAYER_W/2;
        let cy = this.y;

        // Flash on hit
        let col = this.hitTimer > 0 && this.hitTimer % 3 === 0 ? '#fff' : this.color;

        ctx.strokeStyle = col;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';

        // Head
        ctx.beginPath();
        ctx.arc(cx, cy + 5, 5, 0, Math.PI * 2);
        ctx.stroke();

        // Body
        ctx.beginPath();
        ctx.moveTo(cx, cy + 10);
        ctx.lineTo(cx, cy + 22);
        ctx.stroke();

        // Legs - animate walking
        let legSwing = Math.sin(this.walkCycle) * 6;
        let legSwingB = Math.sin(this.walkCycle + Math.PI) * 6;
        if (!this.grounded) { legSwing = -4; legSwingB = 4; }
        ctx.beginPath();
        ctx.moveTo(cx, cy + 22);
        ctx.lineTo(cx + legSwing, cy + PLAYER_H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx, cy + 22);
        ctx.lineTo(cx + legSwingB, cy + PLAYER_H);
        ctx.stroke();

        // Arms
        let armY = cy + 13;
        if (this.attackTimer > 0) {
          // Attack animation - arm extended
          ctx.beginPath();
          ctx.moveTo(cx, armY);
          ctx.lineTo(cx + this.facing * 16, armY - 2);
          ctx.stroke();
          // Other arm back
          ctx.beginPath();
          ctx.moveTo(cx, armY);
          ctx.lineTo(cx - this.facing * 6, armY + 4);
          ctx.stroke();

          // Draw weapon attack
          if (this.weapon) {
            if (this.weapon.type === 'sword') {
              ctx.strokeStyle = '#aaf';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(cx + this.facing * 16, armY - 2);
              ctx.lineTo(cx + this.facing * 30, armY - 8);
              ctx.stroke();
              // Slash arc
              ctx.strokeStyle = 'rgba(170,170,255,0.4)';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(cx + this.facing * 16, armY, 14, -Math.PI*0.6, Math.PI*0.3);
              ctx.stroke();
            }
          } else {
            // Punch effect
            ctx.fillStyle = '#ff4';
            ctx.beginPath();
            ctx.arc(cx + this.facing * 18, armY - 2, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        } else {
          // Normal arms
          let armSwing = Math.sin(this.walkCycle) * 4;
          ctx.beginPath();
          ctx.moveTo(cx, armY);
          ctx.lineTo(cx + this.facing * 6 + armSwing, armY + 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, armY);
          ctx.lineTo(cx - this.facing * 3 - armSwing, armY + 6);
          ctx.stroke();

          // Draw held weapon
          if (this.weapon) {
            this.drawWeapon(cx, armY);
          }
        }

        // HP bar
        let hpW = 24;
        let hpX = cx - hpW/2;
        let hpY = cy - 10;
        ctx.fillStyle = '#300';
        ctx.fillRect(hpX, hpY, hpW, 3);
        let hpFrac = Math.max(0, this.hp / 100);
        ctx.fillStyle = hpFrac > 0.5 ? '#0f0' : hpFrac > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(hpX, hpY, hpW * hpFrac, 3);

        // Player label
        ctx.fillStyle = col;
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(this.isAI ? 'CPU'+(this.idx) : 'P1', cx, cy - 13);

        ctx.lineWidth = 1;
        ctx.lineCap = 'butt';
      }

      drawWeapon(cx, armY) {
        ctx.lineWidth = 2;
        if (this.weapon.type === 'sword') {
          ctx.strokeStyle = '#aaf';
          ctx.beginPath();
          ctx.moveTo(cx + this.facing * 6, armY + 4);
          ctx.lineTo(cx + this.facing * 18, armY - 6);
          ctx.stroke();
        } else if (this.weapon.type === 'gun') {
          ctx.fillStyle = '#ff4';
          ctx.fillRect(cx + this.facing * 4, armY + 1, this.facing * 12, 3);
        } else if (this.weapon.type === 'grenade') {
          ctx.fillStyle = '#0f0';
          ctx.beginPath();
          ctx.arc(cx + this.facing * 8, armY + 4, 3, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.weapon.type === 'laser') {
          ctx.fillStyle = '#f0f';
          ctx.fillRect(cx + this.facing * 4, armY + 1, this.facing * 14, 3);
          ctx.fillStyle = '#a0a';
          ctx.fillRect(cx + this.facing * 16, armY, this.facing * 3, 5);
        }
      }
    }

    // Level generation
    function generatePlatforms() {
      platforms = [];
      // Floor (thick, solid, crumble type so it eventually falls)
      platforms.push(new Platform(0, H - 20, W, 30, 'normal'));

      // Platform layout - varied
      let layouts = [
        // Layout 0: Symmetrical tiers
        [
          [80, 310, 120, 10, 'crumble'],
          [400, 310, 120, 10, 'crumble'],
          [220, 270, 160, 10, 'normal'],
          [50, 220, 100, 10, 'crumble'],
          [450, 220, 100, 10, 'crumble'],
          [180, 170, 80, 10, 'normal'],
          [340, 170, 80, 10, 'normal'],
          [250, 120, 100, 10, 'crumble'],
        ],
        // Layout 1: Staircase
        [
          [30, 320, 100, 10, 'normal'],
          [160, 280, 100, 10, 'crumble'],
          [290, 240, 100, 10, 'normal'],
          [420, 200, 100, 10, 'crumble'],
          [290, 160, 100, 10, 'crumble'],
          [160, 120, 100, 10, 'normal'],
          [30, 170, 80, 10, 'crumble'],
          [500, 280, 80, 10, 'normal'],
        ],
        // Layout 2: Islands
        [
          [100, 300, 80, 10, 'crumble'],
          [260, 300, 80, 10, 'crumble'],
          [420, 300, 80, 10, 'crumble'],
          [50, 220, 70, 10, 'normal'],
          [200, 200, 90, 10, 'crumble'],
          [350, 220, 70, 10, 'normal'],
          [500, 200, 70, 10, 'crumble'],
          [270, 140, 60, 10, 'normal'],
          [130, 140, 60, 10, 'crumble'],
          [410, 140, 60, 10, 'crumble'],
        ],
      ];

      let layout = layouts[Math.floor(Math.random() * layouts.length)];
      for (let p of layout) {
        platforms.push(new Platform(p[0], p[1], p[2], p[3], p[4]));
      }
    }

    function spawnWeapons() {
      weaponPickups = [];
      let count = 3 + Math.floor(Math.random() * 3);
      for (let i = 0; i < count; i++) {
        let type = WEAPON_TYPES[Math.floor(Math.random() * WEAPON_TYPES.length)];
        let x = 50 + Math.random() * (W - 100);
        let y = 50 + Math.random() * 100;
        weaponPickups.push(new WeaponPickup(x, y, type));
      }
    }

    function spawnWeaponPeriodic() {
      if (Math.random() < 0.005 && weaponPickups.length < 5) {
        let type = WEAPON_TYPES[Math.floor(Math.random() * WEAPON_TYPES.length)];
        let x = 50 + Math.random() * (W - 100);
        weaponPickups.push(new WeaponPickup(x, 20, type));
      }
    }

    function initRound() {
      roundNum++;
      roundNumEl.textContent = roundNum;
      roundTimer = 0;
      roundOver = false;
      roundOverTimer = 0;
      lavaY = H + 50;
      projectiles = [];
      particles = [];

      generatePlatforms();
      spawnWeapons();

      // Spawn positions
      let spawns = [
        [80, H - 60],
        [W - 100, H - 60],
        [200, H - 60],
        [W - 220, H - 60],
      ];

      if (players.length === 0) {
        // First round - create players
        players = [];
        players.push(new Fighter(spawns[0][0], spawns[0][1], 0, false));
        for (let i = 1; i < 4; i++) {
          players.push(new Fighter(spawns[i][0], spawns[i][1], i, true));
        }
      } else {
        for (let i = 0; i < players.length; i++) {
          players[i].reset(spawns[i][0], spawns[i][1]);
        }
      }
    }

    function startMatch() {
      gameState = 'playing';
      overlay.style.display = 'none';
      score = 0;
      totalKills = 0;
      roundNum = 0;
      matchOver = false;
      killCountEl.textContent = '0';
      players = [];
      for (let i = 0; i < 4; i++) {
        if (i === 0) players.push(new Fighter(0, 0, 0, false));
        else players.push(new Fighter(0, 0, i, true));
        players[i].score = 0;
      }
      p1ScoreEl.textContent = '0';
      initRound();
    }

    function checkRoundEnd() {
      let alive = players.filter(p => !p.dead);
      if (alive.length <= 1) {
        if (!roundOver) {
          roundOver = true;
          roundOverTimer = 90; // pause before next round
          if (alive.length === 1) {
            alive[0].score++;
            if (alive[0].idx === 0) {
              totalKills++;
              killCountEl.textContent = totalKills;
            }
          }
        }
      }
    }

    function checkMatchEnd() {
      for (let p of players) {
        if (p.score >= WIN_SCORE) {
          matchOver = true;
          gameState = 'over';
          score = players[0].score;
          p1ScoreEl.textContent = score;

          let winner = p.idx === 0 ? 'YOU WIN!' : 'CPU' + p.idx + ' WINS!';
          overlayTitle.textContent = winner;
          overlayText.textContent = 'Score: ' + players[0].score + ' | Kills: ' + totalKills + ' | Click to play again';
          overlay.style.display = 'flex';
          return true;
        }
      }
      return false;
    }

    function update() {
      if (gameState !== 'playing') return;

      roundTimer++;

      // Lava rises after 8 seconds
      if (roundTimer > 480) {
        lavaY -= LAVA_RISE_SPEED;
        // Accelerate over time
        if (roundTimer > 900) lavaY -= 0.1;
        if (roundTimer > 1200) lavaY -= 0.15;
      }

      // Update platforms
      for (let p of platforms) p.update();

      // Spawn weapons periodically
      spawnWeaponPeriodic();

      // Update weapon pickups
      for (let wp of weaponPickups) wp.update();
      weaponPickups = weaponPickups.filter(wp => wp.y < H + 10);

      // Update players
      for (let p of players) p.update();

      // Update projectiles
      for (let pr of projectiles) {
        pr.update();
        if (pr.life <= 0) {
          pr.explode();
          continue;
        }
        // Check hit against players
        for (let p of players) {
          if (p.idx === pr.owner || p.dead) continue;
          let dx = (p.x + PLAYER_W/2) - pr.x;
          let dy = (p.y + PLAYER_H/2) - pr.y;
          let hitR = pr.type === 'grenade' ? 8 : 12;
          if (Math.abs(dx) < hitR && Math.abs(dy) < hitR + 5) {
            if (pr.type === 'bullet') {
              p.takeDamage(18, pr.owner, dx < 0 ? -1 : 1);
              pr.life = 0;
            } else if (pr.type === 'laser') {
              p.takeDamage(25, pr.owner, dx < 0 ? -1 : 1);
              pr.life = 0;
            } else if (pr.type === 'grenade') {
              // Grenade only on timer expiry
            }
          }
        }
        // Check grenade timer
        if (pr.type === 'grenade' && pr.life <= 1) {
          pr.explode();
        }
      }
      projectiles = projectiles.filter(pr => pr.life > 0);

      // Update particles
      for (let p of particles) p.update();
      particles = particles.filter(p => p.life > 0);

      // Clear just-pressed keys
      for (let k in keysJust) keysJust[k] = false;

      // Check round end
      checkRoundEnd();

      if (roundOver) {
        roundOverTimer--;
        if (roundOverTimer <= 0) {
          // Check match end
          if (!checkMatchEnd()) {
            initRound();
          }
        }
      }

      // Update score display
      p1ScoreEl.textContent = players[0].score;
    }

    function drawLava() {
      if (lavaY >= H + 50) return;
      // Lava gradient
      let grad = ctx.createLinearGradient(0, lavaY, 0, H);
      grad.addColorStop(0, '#f80');
      grad.addColorStop(0.3, '#f40');
      grad.addColorStop(1, '#800');
      ctx.fillStyle = grad;
      ctx.fillRect(0, lavaY, W, H - lavaY + 10);

      // Lava surface glow
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      for (let x = 0; x < W; x += 4) {
        let wavY = lavaY + Math.sin((x + roundTimer * 2) * 0.03) * 3;
        if (x === 0) ctx.moveTo(x, wavY);
        else ctx.lineTo(x, wavY);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Lava bubbles
      if (Math.random() < 0.1) {
        let bx = Math.random() * W;
        particles.push(new Particle(bx, lavaY - 2, (Math.random()-0.5)*0.5, -1 - Math.random(), '#ff0', 15));
      }
    }

    function drawBackground() {
      // Dark gradient bg
      let grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#0a0a1e');
      grad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Grid lines for depth
      ctx.strokeStyle = 'rgba(255,255,68,0.03)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 30) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 30) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }
    }

    function drawHUD() {
      // Player scores at top
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      for (let i = 0; i < players.length; i++) {
        let p = players[i];
        let x = 10 + i * 150;
        ctx.fillStyle = p.dead ? '#555' : p.color;
        let label = i === 0 ? 'P1' : 'CPU' + i;
        let wepStr = p.weapon ? ' [' + p.weapon.type[0].toUpperCase() + ':' + p.weapon.ammo + ']' : '';
        ctx.fillText(label + ': ' + p.score + '/' + WIN_SCORE + wepStr, x, 14);
      }

      // Lava warning
      if (lavaY < H && lavaY > H - 100) {
        // Warning text
      } else if (roundTimer > 400 && roundTimer < 480 && roundTimer % 30 < 15) {
        ctx.fillStyle = '#f80';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('!! LAVA RISING SOON !!', W/2, 30);
      }

      // Round over text
      if (roundOver) {
        ctx.fillStyle = '#ff4';
        ctx.font = '20px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ff4';
        ctx.shadowBlur = 15;
        let alive = players.filter(p => !p.dead);
        let txt = alive.length === 1 ?
          (alive[0].idx === 0 ? 'YOU WIN THE ROUND!' : 'CPU' + alive[0].idx + ' WINS!') :
          'DRAW!';
        ctx.fillText(txt, W/2, H/2 - 20);
        ctx.shadowBlur = 0;
        ctx.font = '12px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Next round starting...', W/2, H/2 + 5);
      }

      // Special cooldown indicator for player
      if (!players[0].dead && players[0].specialCooldown > 0) {
        ctx.fillStyle = '#444';
        ctx.fillRect(10, H - 12, 50, 6);
        let frac = 1 - players[0].specialCooldown / 60;
        ctx.fillStyle = frac >= 1 ? '#ff4' : '#884';
        ctx.fillRect(10, H - 12, 50 * frac, 6);
        ctx.fillStyle = '#888';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText('DASH', 12, H - 5);
      } else if (!players[0].dead) {
        ctx.fillStyle = '#ff4';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText('[C] DASH READY', 10, H - 5);
      }
    }

    function draw() {
      drawBackground();

      // Draw platforms
      for (let p of platforms) p.draw();

      // Draw weapon pickups
      for (let wp of weaponPickups) wp.draw();

      // Draw projectiles
      for (let pr of projectiles) pr.draw();

      // Draw particles
      for (let p of particles) p.draw();

      // Draw lava
      drawLava();

      // Draw players
      for (let p of players) p.draw();

      // Draw HUD
      drawHUD();

      // Waiting state
      if (gameState === 'waiting') {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
        ctx.fillRect(0, 0, W, H);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') startMatch();
    });
    document.addEventListener('click', () => {
      if (gameState === 'waiting') startMatch();
    });

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

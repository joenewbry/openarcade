<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kaboom!</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f06; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 0, 102, 0.4); }
    h1 { color: #f06; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 0, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f06; }
    canvas {
      border: 2px solid #f06;
      box-shadow: 0 0 20px rgba(255, 0, 102, 0.2);
      display: block;
      cursor: none;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f06;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>KABOOM!</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Wave: <span id="wave">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">KABOOM!</h2>
      <p id="overlayText">Move mouse or arrow keys -- Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const waveEl = document.getElementById('wave');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Bomber constants
    const BOMBER_W = 40;
    const BOMBER_H = 36;
    const BOMBER_Y = 30;

    // Bucket constants
    const BUCKET_W = 70;
    const BUCKET_H = 18;
    const BUCKET_GAP = 4;
    const BUCKET_BOTTOM_Y = H - 40;

    // Bomb constants
    const BOMB_R = 8;

    // Game state
    let bomberX, bomberDir, bomberSpeed;
    let bucketX, buckets;
    let bombs, explosions;
    let wave, bombsInWave, bombsDropped, bombsCaught;
    let dropTimer, dropInterval;
    let waveCompleteTimer;
    let keys = {};
    const KEYBOARD_SPEED = 6;

    // Wave configuration
    function getWaveConfig(w) {
      const speed = Math.min(2 + w * 0.6, 8);
      const interval = Math.max(60 - w * 5, 12);
      const count = 10 + w * 5;
      return { speed, interval, count };
    }

    function init() {
      score = 0;
      wave = 1;
      buckets = 3;
      bomberX = W / 2;
      bomberDir = 1;
      bucketX = W / 2;
      bombs = [];
      explosions = [];
      dropTimer = 0;
      bombsDropped = 0;
      bombsCaught = 0;
      waveCompleteTimer = 0;

      const cfg = getWaveConfig(wave);
      bomberSpeed = cfg.speed;
      dropInterval = cfg.interval;
      bombsInWave = cfg.count;

      scoreEl.textContent = '0';
      waveEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'KABOOM!';
      overlayText.textContent = 'Move mouse or arrow keys \u2014 Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function startWave(w) {
      wave = w;
      waveEl.textContent = wave;
      const cfg = getWaveConfig(wave);
      bomberSpeed = cfg.speed;
      dropInterval = cfg.interval;
      bombsInWave = cfg.count;
      bombsDropped = 0;
      bombsCaught = 0;
      dropTimer = 0;
      bombs = [];
    }

    function update() {
      // Keyboard movement
      if (keys['ArrowLeft']) bucketX -= KEYBOARD_SPEED;
      if (keys['ArrowRight']) bucketX += KEYBOARD_SPEED;
      bucketX = Math.max(BUCKET_W / 2, Math.min(W - BUCKET_W / 2, bucketX));

      // Wave complete animation pause
      if (waveCompleteTimer > 0) {
        waveCompleteTimer--;
        if (waveCompleteTimer === 0) {
          startWave(wave + 1);
        }
        // Update explosions during pause
        updateExplosions();
        return;
      }

      // Move bomber
      bomberX += bomberDir * bomberSpeed;
      if (bomberX > W - BOMBER_W / 2) {
        bomberX = W - BOMBER_W / 2;
        bomberDir = -1;
      }
      if (bomberX < BOMBER_W / 2) {
        bomberX = BOMBER_W / 2;
        bomberDir = 1;
      }

      // Drop bombs
      if (bombsDropped < bombsInWave) {
        dropTimer++;
        if (dropTimer >= dropInterval) {
          dropTimer = 0;
          bombs.push({
            x: bomberX,
            y: BOMBER_Y + BOMBER_H,
            vy: 2 + wave * 0.3,
            fusePhase: Math.random() * Math.PI * 2
          });
          bombsDropped++;
        }
      }

      // Update bombs
      for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        b.y += b.vy;
        b.fusePhase += 0.15;

        // Check catch with buckets (from bottom bucket up)
        let caught = false;
        for (let j = 0; j < buckets; j++) {
          const bucketY = BUCKET_BOTTOM_Y - j * (BUCKET_H + BUCKET_GAP);
          const bLeft = bucketX - BUCKET_W / 2;
          const bRight = bucketX + BUCKET_W / 2;

          if (b.y + BOMB_R >= bucketY && b.y + BOMB_R <= bucketY + BUCKET_H + b.vy &&
              b.x >= bLeft + 4 && b.x <= bRight - 4) {
            // Caught!
            caught = true;
            bombs.splice(i, 1);
            bombsCaught++;

            // Score: more points in higher waves
            const points = wave * 10;
            score += points;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }

            // Small catch sparkle
            explosions.push({
              x: b.x,
              y: bucketY,
              radius: 0,
              maxRadius: 12,
              alpha: 0.8,
              color: '#fff'
            });
            break;
          }
        }

        if (caught) continue;

        // Check if bomb hit the ground
        if (b.y + BOMB_R >= H - 10) {
          bombs.splice(i, 1);

          // Explosion
          explosions.push({
            x: b.x,
            y: H - 20,
            radius: 0,
            maxRadius: 40,
            alpha: 1.0,
            color: '#f06'
          });

          // Lose a bucket
          buckets--;
          if (buckets <= 0) {
            gameOver();
            return;
          }
        }
      }

      // Check wave complete
      if (bombsDropped >= bombsInWave && bombs.length === 0 && waveCompleteTimer === 0) {
        // Wave bonus
        const bonus = wave * 100;
        score += bonus;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }

        // Restore one bucket (max 3)
        if (buckets < 3) buckets++;

        waveCompleteTimer = 90; // 1.5 second pause
      }

      updateExplosions();
    }

    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.radius += 2;
        e.alpha -= 0.03;
        if (e.alpha <= 0 || e.radius >= e.maxRadius) {
          explosions.splice(i, 1);
        }
      }
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press SPACE to restart`;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Ground line
      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, H - 10, W, 2);

      // Draw bomber
      drawBomber(bomberX, BOMBER_Y);

      // Draw bombs
      bombs.forEach(b => drawBomb(b));

      // Draw buckets
      drawBuckets();

      // Draw explosions
      explosions.forEach(e => {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = e.color;
        ctx.globalAlpha = e.alpha;
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      });

      // Wave complete text
      if (waveCompleteTimer > 0) {
        const pulse = 0.6 + Math.sin(waveCompleteTimer * 0.15) * 0.4;
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.font = 'bold 28px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#f06';
        ctx.shadowColor = '#f06';
        ctx.shadowBlur = 20;
        ctx.fillText(`WAVE ${wave} COMPLETE!`, W / 2, H / 2 - 20);
        ctx.font = '18px "Courier New", monospace';
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;
        ctx.fillText(`+${wave * 100} BONUS`, W / 2, H / 2 + 15);
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // Lives / buckets indicator on canvas
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#888';
      ctx.fillText('Buckets:', 10, H - 18);
      for (let i = 0; i < buckets; i++) {
        ctx.fillStyle = '#f06';
        ctx.shadowColor = '#f06';
        ctx.shadowBlur = 4;
        ctx.fillRect(85 + i * 20, H - 26, 14, 10);
      }
      ctx.shadowBlur = 0;
    }

    function drawBomber(x, y) {
      ctx.save();

      // Body - a menacing character
      ctx.fillStyle = '#e0e0e0';
      ctx.shadowColor = '#f06';
      ctx.shadowBlur = 8;

      // Hat
      ctx.fillStyle = '#333';
      ctx.fillRect(x - 18, y - 8, 36, 6);
      ctx.fillRect(x - 12, y - 18, 24, 12);

      // Face
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(x - 14, y, 28, 18);

      // Eyes - shift based on direction
      const eyeOffset = bomberDir * 2;
      ctx.fillStyle = '#f06';
      ctx.shadowColor = '#f06';
      ctx.shadowBlur = 6;
      ctx.fillRect(x - 8 + eyeOffset, y + 4, 5, 5);
      ctx.fillRect(x + 3 + eyeOffset, y + 4, 5, 5);

      // Grin
      ctx.fillStyle = '#f06';
      ctx.fillRect(x - 8, y + 12, 16, 3);

      // Arms (reaching down toward bombs)
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(x - 18, y + 6, 5, 14);
      ctx.fillRect(x + 13, y + 6, 5, 14);

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBomb(b) {
      ctx.save();

      // Bomb body
      ctx.fillStyle = '#333';
      ctx.shadowColor = '#f06';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(b.x, b.y, BOMB_R, 0, Math.PI * 2);
      ctx.fill();

      // Highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.beginPath();
      ctx.arc(b.x - 2, b.y - 2, BOMB_R * 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Fuse
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b.x + 3, b.y - BOMB_R + 1);
      ctx.quadraticCurveTo(b.x + 8, b.y - BOMB_R - 6, b.x + 5, b.y - BOMB_R - 10);
      ctx.stroke();

      // Fuse spark/glow
      const sparkBrightness = 0.5 + Math.sin(b.fusePhase) * 0.5;
      ctx.fillStyle = `rgba(255, ${Math.floor(100 + sparkBrightness * 155)}, 0, ${sparkBrightness})`;
      ctx.shadowColor = '#fa0';
      ctx.shadowBlur = 12 * sparkBrightness;
      ctx.beginPath();
      ctx.arc(b.x + 5, b.y - BOMB_R - 10, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBuckets() {
      const bucketColors = ['#f06', '#d05', '#b04'];

      for (let i = 0; i < buckets; i++) {
        const by = BUCKET_BOTTOM_Y - i * (BUCKET_H + BUCKET_GAP);
        const color = bucketColors[i] || '#f06';
        const bLeft = bucketX - BUCKET_W / 2;

        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowColor = '#f06';
        ctx.shadowBlur = 8;

        // Bucket shape - slightly curved trapezoid
        ctx.beginPath();
        ctx.moveTo(bLeft + 4, by);
        ctx.lineTo(bLeft + BUCKET_W - 4, by);
        ctx.lineTo(bLeft + BUCKET_W - 1, by + BUCKET_H);
        ctx.lineTo(bLeft + 1, by + BUCKET_H);
        ctx.closePath();
        ctx.fill();

        // Bucket rim highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.fillRect(bLeft + 5, by, BUCKET_W - 10, 3);

        // Bucket inner shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(bLeft + 6, by + 4, BUCKET_W - 12, BUCKET_H - 6);

        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Mouse handler
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      bucketX = Math.max(BUCKET_W / 2, Math.min(W - BUCKET_W / 2, x));
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') {
          init();
        }
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Expose game data for ML training
    window.gameData = {};

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

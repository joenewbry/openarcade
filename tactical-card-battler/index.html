<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tactical Card Battler</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #cc44ff; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 68, 255, 0.4); }
    h1 { color: #cc44ff; font-size: 1.6rem; text-shadow: 0 0 15px rgba(204, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #cc44ff; }
    canvas {
      border: 2px solid #cc44ff;
      box-shadow: 0 0 20px rgba(204, 68, 255, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #cc44ff;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(204, 68, 255, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TACTICAL CARD BATTLER</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="playerHP">30</span> HP | Mana: <span id="playerMana">0</span></div>
    <div>Score: <span id="score">0</span></div>
    <div>AI: <span id="aiHP">30</span> HP | Mana: <span id="aiMana">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">TACTICAL CARD BATTLER</h2>
      <p id="overlayText">Click anywhere to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const playerHPEl = document.getElementById('playerHP');
    const playerManaEl = document.getElementById('playerMana');
    const aiHPEl = document.getElementById('aiHP');
    const aiManaEl = document.getElementById('aiMana');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ---- COLORS ----
    const C_BG = '#1a1a2e';
    const C_PURPLE = '#cc44ff';
    const C_PURPLEGLOW = 'rgba(204,68,255,0.3)';
    const C_BLUE = '#4488ff';
    const C_BLUEGLOW = 'rgba(68,136,255,0.3)';
    const C_RED = '#ff4466';
    const C_REDGLOW = 'rgba(255,68,102,0.3)';
    const C_GREEN = '#44ff88';
    const C_GOLD = '#ffcc44';
    const C_LANE = '#16213e';
    const C_LANEBORDER = '#2a2a4e';
    const C_CARD = '#22224a';
    const C_CARDBORDER = '#44447a';
    const C_CARDHI = '#33336a';

    // ---- CARD POOL (20 cards) ----
    // type: 'minion' or 'spell'
    // minion: { cost, atk, hp, name, desc }
    // spell: { cost, name, desc, effect }
    const CARD_POOL = [
      // MINIONS (14)
      { type:'minion', cost:1, atk:1, hp:2, name:'Imp',       desc:'1/2' },
      { type:'minion', cost:1, atk:2, hp:1, name:'Wisp',      desc:'2/1' },
      { type:'minion', cost:2, atk:2, hp:3, name:'Grunt',     desc:'2/3' },
      { type:'minion', cost:2, atk:3, hp:2, name:'Rogue',     desc:'3/2' },
      { type:'minion', cost:3, atk:3, hp:4, name:'Knight',    desc:'3/4' },
      { type:'minion', cost:3, atk:4, hp:3, name:'Assassin',  desc:'4/3' },
      { type:'minion', cost:4, atk:4, hp:5, name:'Golem',     desc:'4/5' },
      { type:'minion', cost:4, atk:5, hp:4, name:'Berserker', desc:'5/4' },
      { type:'minion', cost:5, atk:5, hp:6, name:'Drake',     desc:'5/6' },
      { type:'minion', cost:5, atk:6, hp:5, name:'Champion',  desc:'6/5' },
      { type:'minion', cost:6, atk:7, hp:7, name:'Giant',     desc:'7/7' },
      { type:'minion', cost:7, atk:8, hp:8, name:'Dragon',    desc:'8/8' },
      { type:'minion', cost:2, atk:1, hp:4, name:'Shieldsman',desc:'1/4' },
      { type:'minion', cost:3, atk:2, hp:5, name:'Guardian',  desc:'2/5' },
      // SPELLS (6)
      { type:'spell', cost:1, name:'Zap',        desc:'Deal 2 dmg', effect:'damage', value:2 },
      { type:'spell', cost:2, name:'Fireball',   desc:'Deal 4 dmg', effect:'damage', value:4 },
      { type:'spell', cost:3, name:'Lightning',  desc:'Deal 6 dmg', effect:'damage', value:6 },
      { type:'spell', cost:1, name:'Heal',       desc:'Heal hero 3', effect:'heal', value:3 },
      { type:'spell', cost:2, name:'Greater Heal',desc:'Heal hero 6',effect:'heal', value:6 },
      { type:'spell', cost:2, name:'War Cry',    desc:'All +2 atk', effect:'buff_atk', value:2 },
    ];

    function makeCard(template) {
      const c = { ...template };
      c.id = Math.random();
      if (c.type === 'minion') { c.curHp = c.hp; c.canAttack = false; }
      return c;
    }

    function buildDeck() {
      const deck = [];
      // 15 cards from pool, weighted random
      for (let i = 0; i < 15; i++) {
        deck.push(makeCard(CARD_POOL[Math.floor(Math.random() * CARD_POOL.length)]));
      }
      // shuffle
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    // ---- GAME STATE ----
    let player, ai, turnNumber, currentTurn, selectedCard, dragging, dragX, dragY;
    let selectedAttacker, animQueue, turnPhase, endTurnBtn;
    let combatLog, logTimer;

    // Layout constants
    const LANE_X = [120, 300, 480]; // center x of 3 lanes
    const LANE_W = 140;
    const LANE_TOP = 50;    // AI lane top
    const LANE_MID = 190;   // divider
    const LANE_BOT = 330;   // below player lane
    const PLAYER_LANE_Y = 250; // where player minions sit
    const AI_LANE_Y = 120;    // where AI minions sit
    const HAND_Y = 410;
    const HAND_H = 80;
    const CARD_W = 65;
    const CARD_H = 75;
    const HERO_SIZE = 40;
    const END_BTN = { x: 530, y: 365, w: 60, h: 28 };

    function init() {
      player = {
        hp: 30, maxHp: 30, mana: 0, maxMana: 0,
        deck: buildDeck(), hand: [], lanes: [null, null, null]
      };
      ai = {
        hp: 30, maxHp: 30, mana: 0, maxMana: 0,
        deck: buildDeck(), hand: [], lanes: [null, null, null]
      };
      turnNumber = 0;
      currentTurn = 'player';
      selectedCard = null;
      dragging = false;
      dragX = 0; dragY = 0;
      selectedAttacker = null;
      animQueue = [];
      turnPhase = 'idle'; // idle, animating, ai_thinking
      combatLog = '';
      logTimer = 0;
      score = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TACTICAL CARD BATTLER';
      overlayText.textContent = 'Click anywhere to start';
      updateHUD();
      draw();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startTurn('player');
    }

    function startTurn(who) {
      currentTurn = who;
      const p = who === 'player' ? player : ai;
      turnNumber++;
      // gain mana
      p.maxMana = Math.min(10, p.maxMana + 1);
      p.mana = p.maxMana;
      // draw card
      if (p.deck.length > 0 && p.hand.length < 7) {
        p.hand.push(p.deck.pop());
      }
      // minions can attack
      for (let i = 0; i < 3; i++) {
        if (p.lanes[i]) p.lanes[i].canAttack = true;
      }
      selectedCard = null;
      selectedAttacker = null;
      if (who === 'ai') {
        turnPhase = 'ai_thinking';
        setTimeout(() => aiTurn(), 600);
      } else {
        turnPhase = 'idle';
      }
      updateHUD();
      draw();
    }

    function endTurn() {
      if (currentTurn !== 'player' || turnPhase !== 'idle') return;
      // combat phase: player minions attack
      doCombat('player');
    }

    function doCombat(who) {
      const attacker = who === 'player' ? player : ai;
      const defender = who === 'player' ? ai : player;
      turnPhase = 'animating';
      let delay = 0;
      for (let i = 0; i < 3; i++) {
        const m = attacker.lanes[i];
        if (!m) continue;
        delay += 400;
        setTimeout(() => {
          if (!attacker.lanes[i]) return; // might have died
          const opp = defender.lanes[i];
          if (opp) {
            // attack opposing minion
            opp.curHp -= m.atk;
            m.curHp -= opp.atk;
            showLog(m.name + ' fights ' + opp.name);
            if (who === 'player') score += m.atk;
            if (opp.curHp <= 0) { defender.lanes[i] = null; showLog(opp.name + ' dies!'); }
            if (m.curHp <= 0) { attacker.lanes[i] = null; showLog(m.name + ' dies!'); }
          } else {
            // attack hero
            defender.hp -= m.atk;
            if (who === 'player') score += m.atk;
            showLog(m.name + ' hits hero for ' + m.atk + '!');
          }
          updateHUD();
          draw();
          checkGameOver();
        }, delay);
      }
      setTimeout(() => {
        if (gameState !== 'playing') return;
        turnPhase = 'idle';
        if (who === 'player') {
          startTurn('ai');
        } else {
          startTurn('player');
        }
      }, delay + 500);
    }

    function showLog(msg) {
      combatLog = msg;
      logTimer = 90;
    }

    function checkGameOver() {
      if (player.hp <= 0 || ai.hp <= 0) {
        gameState = 'over';
        overlay.style.display = 'flex';
        if (ai.hp <= 0) {
          overlayTitle.textContent = 'VICTORY!';
          overlayText.textContent = 'Score: ' + score + ' | Click to play again';
        } else {
          overlayTitle.textContent = 'DEFEAT';
          overlayText.textContent = 'Score: ' + score + ' | Click to play again';
        }
      }
    }

    function playCard(who, cardIdx, laneIdx) {
      const p = who === 'player' ? player : ai;
      const card = p.hand[cardIdx];
      if (!card || card.cost > p.mana) return false;
      if (card.type === 'minion') {
        if (laneIdx < 0 || laneIdx > 2 || p.lanes[laneIdx] !== null) return false;
        p.mana -= card.cost;
        p.hand.splice(cardIdx, 1);
        const minion = { ...card, curHp: card.hp, canAttack: false };
        p.lanes[laneIdx] = minion;
        showLog((who === 'player' ? 'You' : 'AI') + ' plays ' + card.name + ' to lane ' + (laneIdx+1));
      } else if (card.type === 'spell') {
        p.mana -= card.cost;
        p.hand.splice(cardIdx, 1);
        applySpell(who, card, laneIdx);
      }
      updateHUD();
      draw();
      return true;
    }

    function applySpell(who, card, targetLane) {
      const p = who === 'player' ? player : ai;
      const opp = who === 'player' ? ai : player;
      if (card.effect === 'damage') {
        // damage target: opponent lane minion if exists, else hero
        if (targetLane >= 0 && targetLane <= 2 && opp.lanes[targetLane]) {
          opp.lanes[targetLane].curHp -= card.value;
          if (who === 'player') score += card.value;
          showLog(card.name + ' hits ' + opp.lanes[targetLane].name + ' for ' + card.value + '!');
          if (opp.lanes[targetLane].curHp <= 0) {
            showLog(opp.lanes[targetLane].name + ' dies!');
            opp.lanes[targetLane] = null;
          }
        } else {
          opp.hp -= card.value;
          if (who === 'player') score += card.value;
          showLog(card.name + ' hits hero for ' + card.value + '!');
        }
      } else if (card.effect === 'heal') {
        p.hp = Math.min(p.maxHp, p.hp + card.value);
        showLog(card.name + ' heals for ' + card.value);
      } else if (card.effect === 'buff_atk') {
        for (let i = 0; i < 3; i++) {
          if (p.lanes[i]) {
            p.lanes[i].atk += card.value;
            showLog(p.lanes[i].name + ' gains +' + card.value + ' atk!');
          }
        }
      }
      checkGameOver();
    }

    // ---- AI LOGIC ----
    function aiTurn() {
      if (gameState !== 'playing') return;
      // AI plays cards with simple board evaluation heuristic
      let played = true;
      while (played) {
        played = false;
        // Evaluate best card to play
        let bestScore = -1, bestCardIdx = -1, bestLane = -1;
        for (let ci = 0; ci < ai.hand.length; ci++) {
          const card = ai.hand[ci];
          if (card.cost > ai.mana) continue;
          if (card.type === 'minion') {
            for (let li = 0; li < 3; li++) {
              if (ai.lanes[li] !== null) continue;
              let s = evaluateMinion(card, li);
              if (s > bestScore) { bestScore = s; bestCardIdx = ci; bestLane = li; }
            }
          } else if (card.type === 'spell') {
            let r = evaluateSpell(card);
            if (r.score > bestScore) { bestScore = r.score; bestCardIdx = ci; bestLane = r.lane; }
          }
        }
        if (bestCardIdx >= 0 && bestScore > 0) {
          playCard('ai', bestCardIdx, bestLane);
          played = true;
        }
      }
      // after playing, do combat
      setTimeout(() => {
        if (gameState !== 'playing') return;
        doCombat('ai');
      }, 600);
    }

    function evaluateMinion(card, lane) {
      let s = card.atk + card.hp; // base value from stats
      const oppMinion = player.lanes[lane];
      if (oppMinion) {
        // can we trade favorably?
        if (card.atk >= oppMinion.curHp) s += 5; // can kill it
        if (card.hp > oppMinion.atk) s += 3; // survives trade
      } else {
        // empty lane = face damage potential
        s += card.atk * 1.5;
      }
      // prefer cheaper cards first (mana efficiency)
      s += (10 - card.cost) * 0.5;
      return s;
    }

    function evaluateSpell(card) {
      let bestScore = 0, bestLane = -1;
      if (card.effect === 'damage') {
        // prefer killing minions, else face
        for (let i = 0; i < 3; i++) {
          const m = player.lanes[i];
          if (m) {
            let s = card.value;
            if (card.value >= m.curHp) s += m.atk + m.curHp + 5; // kill value
            else s += card.value; // chip damage
            if (s > bestScore) { bestScore = s; bestLane = i; }
          }
        }
        // face damage
        let faceScore = card.value * 1.2;
        if (player.hp <= card.value) faceScore += 50; // lethal!
        if (faceScore > bestScore) { bestScore = faceScore; bestLane = -1; }
      } else if (card.effect === 'heal') {
        if (ai.hp < 20) bestScore = card.value * 1.5;
        else bestScore = card.value * 0.5;
        bestLane = -1;
      } else if (card.effect === 'buff_atk') {
        let minionCount = ai.lanes.filter(m => m).length;
        bestScore = minionCount * card.value * 2;
        bestLane = -1;
      }
      return { score: bestScore, lane: bestLane };
    }

    // ---- HUD ----
    function updateHUD() {
      scoreEl.textContent = score;
      playerHPEl.textContent = Math.max(0, player.hp);
      playerManaEl.textContent = player.mana + '/' + player.maxMana;
      aiHPEl.textContent = Math.max(0, ai.hp);
      aiManaEl.textContent = ai.mana + '/' + ai.maxMana;
    }

    // ---- DRAWING ----
    function draw() {
      ctx.fillStyle = C_BG;
      ctx.fillRect(0, 0, W, H);

      drawLanes();
      drawHeroes();
      drawMinions();
      drawHand();
      drawEndTurnButton();
      drawCombatLog();
      drawTurnIndicator();
      if (dragging && selectedCard !== null) drawDragCard();
      drawSpellTarget();
    }

    function drawLanes() {
      for (let i = 0; i < 3; i++) {
        const x = LANE_X[i] - LANE_W/2;
        // AI side
        ctx.fillStyle = C_LANE;
        ctx.strokeStyle = C_LANEBORDER;
        ctx.lineWidth = 1;
        ctx.fillRect(x, LANE_TOP, LANE_W, LANE_MID - LANE_TOP - 5);
        ctx.strokeRect(x, LANE_TOP, LANE_W, LANE_MID - LANE_TOP - 5);
        // Player side
        ctx.fillRect(x, LANE_MID + 5, LANE_W, LANE_BOT - LANE_MID - 5);
        ctx.strokeRect(x, LANE_MID + 5, LANE_W, LANE_BOT - LANE_MID - 5);
        // Lane label
        ctx.fillStyle = '#555';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Lane ' + (i+1), LANE_X[i], LANE_MID + 1);
      }
    }

    function drawHeroes() {
      // AI hero (top center)
      const ahx = 35, ahy = 25;
      ctx.fillStyle = ai.hp > 10 ? C_RED : '#aa2233';
      ctx.shadowColor = C_REDGLOW;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(ahx, ahy, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(ai.hp, ahx, ahy);
      ctx.fillStyle = '#aaa';
      ctx.font = '9px Courier New';
      ctx.fillText('AI', ahx, ahy - 28);

      // Player hero (bottom left)
      const phx = 35, phy = LANE_BOT + 10;
      ctx.fillStyle = player.hp > 10 ? C_BLUE : '#2244aa';
      ctx.shadowColor = C_BLUEGLOW;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(phx, phy, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(player.hp, phx, phy);
      ctx.fillStyle = '#aaa';
      ctx.font = '9px Courier New';
      ctx.fillText('YOU', phx, phy - 28);
    }

    function drawMinion(m, x, y, owner) {
      const isSelected = selectedAttacker && selectedAttacker.lane !== undefined &&
        ((owner === 'player' && player.lanes[selectedAttacker.lane] === m) ||
         (owner === 'ai' && ai.lanes[selectedAttacker.lane] === m));
      const w = 60, h = 55;
      // card body
      ctx.fillStyle = owner === 'player' ? '#1a2a5a' : '#4a1a2a';
      ctx.strokeStyle = isSelected ? C_GOLD : (owner === 'player' ? '#3366cc' : '#cc3344');
      ctx.lineWidth = isSelected ? 2 : 1;
      if (m.canAttack && owner === 'player' && currentTurn === 'player') {
        ctx.shadowColor = C_GOLD;
        ctx.shadowBlur = 6;
      }
      roundRect(x - w/2, y - h/2, w, h, 4);
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      // name
      ctx.fillStyle = '#ddd';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(m.name, x, y - h/2 + 4);

      // atk / hp
      ctx.font = 'bold 14px Courier New';
      // atk (bottom left)
      ctx.fillStyle = C_GOLD;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText(m.atk, x - w/2 + 5, y + h/2 - 3);
      // hp (bottom right)
      ctx.fillStyle = m.curHp < m.hp ? C_RED : C_GREEN;
      ctx.textAlign = 'right';
      ctx.fillText(m.curHp, x + w/2 - 5, y + h/2 - 3);

      // small sword and heart icons
      ctx.fillStyle = '#888';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('ATK', x - w/2 + 3, y + h/2 - 16);
      ctx.textAlign = 'right';
      ctx.fillText('HP', x + w/2 - 3, y + h/2 - 16);
    }

    function drawMinions() {
      for (let i = 0; i < 3; i++) {
        if (ai.lanes[i]) drawMinion(ai.lanes[i], LANE_X[i], AI_LANE_Y, 'ai');
        if (player.lanes[i]) drawMinion(player.lanes[i], LANE_X[i], PLAYER_LANE_Y, 'player');
      }
    }

    function drawHand() {
      const hand = player.hand;
      const n = hand.length;
      if (n === 0) return;
      const totalW = n * (CARD_W + 4);
      const startX = (W - totalW) / 2;
      for (let i = 0; i < n; i++) {
        if (dragging && selectedCard === i) continue; // skip dragged card
        const card = hand[i];
        const x = startX + i * (CARD_W + 4);
        const y = HAND_Y;
        drawCardInHand(card, x, y, card.cost <= player.mana && currentTurn === 'player');
      }
    }

    function drawCardInHand(card, x, y, playable) {
      ctx.fillStyle = playable ? C_CARD : '#181830';
      ctx.strokeStyle = playable ? C_PURPLE : '#333';
      ctx.lineWidth = playable ? 1.5 : 1;
      if (playable) {
        ctx.shadowColor = C_PURPLEGLOW;
        ctx.shadowBlur = 6;
      }
      roundRect(x, y, CARD_W, CARD_H, 4);
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      // mana cost (top left circle)
      ctx.fillStyle = '#3344aa';
      ctx.beginPath();
      ctx.arc(x + 10, y + 10, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(card.cost, x + 10, y + 10);

      // name
      ctx.fillStyle = playable ? '#ddd' : '#777';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const displayName = card.name.length > 9 ? card.name.substring(0,8)+'..' : card.name;
      ctx.fillText(displayName, x + CARD_W/2, y + 22);

      if (card.type === 'minion') {
        // atk/hp
        ctx.font = 'bold 11px Courier New';
        ctx.fillStyle = C_GOLD;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText(card.atk, x + 5, y + CARD_H - 4);
        ctx.fillStyle = C_GREEN;
        ctx.textAlign = 'right';
        ctx.fillText(card.hp, x + CARD_W - 5, y + CARD_H - 4);
        // type indicator
        ctx.fillStyle = '#666';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('MINION', x + CARD_W/2, y + 36);
      } else {
        ctx.fillStyle = C_PURPLE;
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('SPELL', x + CARD_W/2, y + 36);
        ctx.fillStyle = '#aaa';
        ctx.font = '7px Courier New';
        ctx.fillText(card.desc, x + CARD_W/2, y + 48);
      }
    }

    function drawDragCard() {
      const card = player.hand[selectedCard];
      if (!card) return;
      const x = dragX - CARD_W/2;
      const y = dragY - CARD_H/2;
      ctx.globalAlpha = 0.85;
      drawCardInHand(card, x, y, true);
      ctx.globalAlpha = 1;

      // highlight target lanes
      if (card.type === 'minion') {
        for (let i = 0; i < 3; i++) {
          if (player.lanes[i] === null) {
            const lx = LANE_X[i] - LANE_W/2;
            ctx.strokeStyle = C_GREEN;
            ctx.lineWidth = 2;
            ctx.setLineDash([4,4]);
            ctx.strokeRect(lx + 2, LANE_MID + 7, LANE_W - 4, LANE_BOT - LANE_MID - 9);
            ctx.setLineDash([]);
          }
        }
      } else if (card.effect === 'damage') {
        // highlight enemy lanes/hero
        for (let i = 0; i < 3; i++) {
          const lx = LANE_X[i] - LANE_W/2;
          ctx.strokeStyle = C_RED;
          ctx.lineWidth = 2;
          ctx.setLineDash([4,4]);
          ctx.strokeRect(lx + 2, LANE_TOP + 2, LANE_W - 4, LANE_MID - LANE_TOP - 9);
          ctx.setLineDash([]);
        }
      }
    }

    function drawSpellTarget() {
      // placeholder for spell targeting visualization
    }

    function drawEndTurnButton() {
      const b = END_BTN;
      const active = currentTurn === 'player' && turnPhase === 'idle';
      ctx.fillStyle = active ? '#2a1a4a' : '#1a1a2a';
      ctx.strokeStyle = active ? C_PURPLE : '#444';
      ctx.lineWidth = active ? 2 : 1;
      if (active) {
        ctx.shadowColor = C_PURPLEGLOW;
        ctx.shadowBlur = 6;
      }
      roundRect(b.x, b.y, b.w, b.h, 4);
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = active ? '#ddd' : '#666';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('END', b.x + b.w/2, b.y + b.h/2 - 5);
      ctx.fillText('TURN', b.x + b.w/2, b.y + b.h/2 + 5);
    }

    function drawCombatLog() {
      if (logTimer > 0) {
        logTimer--;
        ctx.fillStyle = 'rgba(204,68,255,' + Math.min(1, logTimer / 30) + ')';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(combatLog, W/2, LANE_MID - 12);
      }
    }

    function drawTurnIndicator() {
      ctx.fillStyle = currentTurn === 'player' ? C_BLUE : C_RED;
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      const t = currentTurn === 'player' ? 'YOUR TURN' : 'AI TURN';
      ctx.fillText(t, W - 10, 5);

      // Mana crystals for player
      const mx = 530, my = 395;
      ctx.fillStyle = '#555';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('MANA', mx + 30, my + 5);
      for (let i = 0; i < player.maxMana; i++) {
        const cx = mx + (i % 5) * 12;
        const cy = my + 18 + Math.floor(i / 5) * 12;
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fillStyle = i < player.mana ? '#6644ff' : '#2a2a4e';
        ctx.fill();
        ctx.strokeStyle = '#8866ff';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    }

    function roundRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    // ---- INPUT ----
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = W / rect.width, sy = H / rect.height;
      const mx = (e.clientX - rect.left) * sx;
      const my = (e.clientY - rect.top) * sy;
      mouseX = mx; mouseY = my;

      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (currentTurn !== 'player' || turnPhase !== 'idle') return;

      // Check end turn button
      if (mx >= END_BTN.x && mx <= END_BTN.x + END_BTN.w &&
          my >= END_BTN.y && my <= END_BTN.y + END_BTN.h) {
        endTurn();
        return;
      }

      // Check clicking on player minion for attack (not used in this version, combat is auto)
      // Instead, check if clicking a card in hand to drag
      const hand = player.hand;
      const n = hand.length;
      if (n > 0) {
        const totalW = n * (CARD_W + 4);
        const startX = (W - totalW) / 2;
        for (let i = n - 1; i >= 0; i--) {
          const cx = startX + i * (CARD_W + 4);
          if (mx >= cx && mx <= cx + CARD_W && my >= HAND_Y && my <= HAND_Y + CARD_H) {
            const card = hand[i];
            if (card.cost <= player.mana) {
              selectedCard = i;
              dragging = true;
              dragX = mx; dragY = my;
              draw();
            }
            return;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = W / rect.width, sy = H / rect.height;
      mouseX = (e.clientX - rect.left) * sx;
      mouseY = (e.clientY - rect.top) * sy;
      if (dragging) {
        dragX = mouseX;
        dragY = mouseY;
        draw();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!dragging || selectedCard === null) return;
      const rect = canvas.getBoundingClientRect();
      const sx = W / rect.width, sy = H / rect.height;
      const mx = (e.clientX - rect.left) * sx;
      const my = (e.clientY - rect.top) * sy;

      const card = player.hand[selectedCard];
      if (card) {
        if (card.type === 'minion') {
          // determine which lane
          for (let i = 0; i < 3; i++) {
            const lx = LANE_X[i] - LANE_W/2;
            if (mx >= lx && mx <= lx + LANE_W && my >= LANE_MID + 5 && my <= LANE_BOT) {
              if (player.lanes[i] === null) {
                playCard('player', selectedCard, i);
                break;
              }
            }
          }
        } else if (card.type === 'spell') {
          if (card.effect === 'damage') {
            // check if dropped on an enemy lane
            let targetLane = -1;
            for (let i = 0; i < 3; i++) {
              const lx = LANE_X[i] - LANE_W/2;
              if (mx >= lx && mx <= lx + LANE_W && my >= LANE_TOP && my < LANE_MID) {
                targetLane = i;
                break;
              }
            }
            playCard('player', selectedCard, targetLane);
          } else if (card.effect === 'heal' || card.effect === 'buff_atk') {
            // play anywhere on board
            if (my < HAND_Y) {
              playCard('player', selectedCard, -1);
            }
          }
        }
      }

      dragging = false;
      selectedCard = null;
      draw();
    });

    // Click handler for overlay
    overlay.addEventListener('click', (e) => {
      if (gameState === 'waiting') { startGame(); }
      else if (gameState === 'over') { init(); }
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    // ---- GAME LOOP ----
    function gameLoop() {
      if (gameState === 'playing') {
        if (logTimer > 0) draw();
        updateGameData();
      }
      requestAnimationFrame(gameLoop);
    }

    // ---- Expose game data for recorder ----
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState,
        score,
        turnNumber,
        currentTurn,
        playerHP: player ? player.hp : 0,
        aiHP: ai ? ai.hp : 0,
        playerMana: player ? player.mana : 0,
        playerHand: player ? player.hand.length : 0,
        aiHand: ai ? ai.hand.length : 0,
        lanes: {
          player: player ? player.lanes.map(m => m ? { name: m.name, atk: m.atk, hp: m.curHp } : null) : [],
          ai: ai ? ai.lanes.map(m => m ? { name: m.name, atk: m.atk, hp: m.curHp } : null) : []
        }
      };
    }

    // ---- Initialize ----
    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

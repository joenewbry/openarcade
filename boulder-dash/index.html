<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boulder Dash</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #8cf; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 204, 255, 0.4); }
    h1 { color: #8cf; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 204, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8cf; }
    canvas {
      border: 2px solid #8cf;
      box-shadow: 0 0 20px rgba(136, 204, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8cf;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BOULDER DASH</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">BOULDER DASH</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Tile types
    const EMPTY = 0;
    const DIRT = 1;
    const WALL = 2;
    const BOULDER = 3;
    const DIAMOND = 4;
    const PLAYER = 5;
    const EXIT = 6;
    const ENEMY = 7;
    const STEEL = 8;  // Indestructible border

    // Grid dimensions
    const COLS = 25;
    const ROWS = 20;
    const TILE_W = W / COLS;  // 20
    const TILE_H = H / ROWS;  // 20

    let score, best = 0, gameState;
    let grid, player, enemies, diamonds, diamondsNeeded, diamondsCollected;
    let exitOpen, exitPos, level, timeLeft, tickTimer, tickInterval;
    let fallingMap; // tracks which boulders/diamonds are falling
    let animFrame;
    let lastGravityTick;
    let deathAnim, deathTimer;
    let levelCompleteAnim, levelCompleteTimer;

    // Level definitions
    const levels = [
      { diamonds: 6, time: 120, enemies: 1, boulderDensity: 0.12, diamondDensity: 0.06 },
      { diamonds: 10, time: 110, enemies: 2, boulderDensity: 0.14, diamondDensity: 0.06 },
      { diamonds: 14, time: 100, enemies: 3, boulderDensity: 0.16, diamondDensity: 0.06 },
      { diamonds: 18, time: 90, enemies: 3, boulderDensity: 0.18, diamondDensity: 0.07 },
      { diamonds: 22, time: 85, enemies: 4, boulderDensity: 0.20, diamondDensity: 0.07 },
      { diamonds: 26, time: 80, enemies: 4, boulderDensity: 0.22, diamondDensity: 0.08 },
      { diamonds: 30, time: 75, enemies: 5, boulderDensity: 0.24, diamondDensity: 0.08 },
    ];

    function getLevelDef(lvl) {
      if (lvl < levels.length) return levels[lvl];
      // Infinite scaling past defined levels
      const last = levels[levels.length - 1];
      const extra = lvl - levels.length + 1;
      return {
        diamonds: last.diamonds + extra * 4,
        time: Math.max(60, last.time - extra * 5),
        enemies: Math.min(8, last.enemies + Math.floor(extra / 2)),
        boulderDensity: Math.min(0.30, last.boulderDensity + extra * 0.02),
        diamondDensity: Math.min(0.12, last.diamondDensity + extra * 0.01),
      };
    }

    function generateCave(lvl) {
      const def = getLevelDef(lvl);
      grid = [];
      fallingMap = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        fallingMap[r] = [];
        for (let c = 0; c < COLS; c++) {
          fallingMap[r][c] = false;
          // Steel border
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
            grid[r][c] = STEEL;
          } else {
            grid[r][c] = DIRT;
          }
        }
      }

      // Place some wall structures (clusters)
      const wallClusters = 3 + lvl;
      for (let i = 0; i < wallClusters; i++) {
        const cr = 2 + Math.floor(Math.random() * (ROWS - 4));
        const cc = 2 + Math.floor(Math.random() * (COLS - 4));
        const size = 2 + Math.floor(Math.random() * 3);
        const horizontal = Math.random() > 0.5;
        for (let j = 0; j < size; j++) {
          const rr = horizontal ? cr : cr + j;
          const rc = horizontal ? cc + j : cc;
          if (rr > 0 && rr < ROWS - 1 && rc > 0 && rc < COLS - 1) {
            grid[rr][rc] = WALL;
          }
        }
      }

      // Scatter boulders
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (grid[r][c] === DIRT && Math.random() < def.boulderDensity) {
            grid[r][c] = BOULDER;
          }
        }
      }

      // Scatter diamonds (ensure enough)
      let placed = 0;
      const totalDiamondsNeeded = def.diamonds + 4; // a few extra
      while (placed < totalDiamondsNeeded) {
        for (let r = 1; r < ROWS - 1 && placed < totalDiamondsNeeded; r++) {
          for (let c = 1; c < COLS - 1 && placed < totalDiamondsNeeded; c++) {
            if (grid[r][c] === DIRT && Math.random() < def.diamondDensity) {
              grid[r][c] = DIAMOND;
              placed++;
            }
          }
        }
      }

      // Place player in top-left area (clear a small space)
      const pr = 2;
      const pc = 2;
      grid[pr][pc] = PLAYER;
      grid[pr - 1][pc] = EMPTY;
      grid[pr][pc - 1] = EMPTY;
      grid[pr][pc + 1] = grid[pr][pc + 1] === STEEL ? STEEL : EMPTY;
      grid[pr + 1][pc] = grid[pr + 1][pc] === STEEL ? STEEL : DIRT;
      player = { r: pr, c: pc };

      // Place exit in bottom-right area
      const er = ROWS - 3;
      const ec = COLS - 3;
      grid[er][ec] = EXIT;
      exitPos = { r: er, c: ec };

      // Place enemies
      enemies = [];
      for (let i = 0; i < def.enemies; i++) {
        let attempts = 0;
        while (attempts < 200) {
          const er2 = 3 + Math.floor(Math.random() * (ROWS - 6));
          const ec2 = 5 + Math.floor(Math.random() * (COLS - 8));
          // Don't place near player or exit
          if (Math.abs(er2 - pr) + Math.abs(ec2 - pc) > 6 &&
              Math.abs(er2 - er) + Math.abs(ec2 - ec) > 4 &&
              grid[er2][ec2] === DIRT) {
            grid[er2][ec2] = ENEMY;
            enemies.push({ r: er2, c: ec2, dir: Math.floor(Math.random() * 4), alive: true });
            break;
          }
          attempts++;
        }
      }

      diamondsNeeded = def.diamonds;
      diamondsCollected = 0;
      timeLeft = def.time;
      exitOpen = false;
    }

    function init() {
      score = 0;
      level = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BOULDER DASH';
      overlayText.innerHTML = 'Arrow keys to move &amp; dig<br>Press SPACE to start';
      deathAnim = false;
      levelCompleteAnim = false;
      generateCave(0);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastGravityTick = 0;
      tickInterval = 150; // ms between gravity/enemy ticks
      deathAnim = false;
      levelCompleteAnim = false;
      // Start timer
      if (tickTimer) clearInterval(tickTimer);
      tickTimer = setInterval(() => {
        if (gameState === 'playing' && !deathAnim && !levelCompleteAnim) {
          timeLeft--;
          if (timeLeft <= 0) {
            die();
          }
        }
      }, 1000);
      loop(performance.now());
    }

    function gameOver() {
      gameState = 'over';
      if (tickTimer) clearInterval(tickTimer);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.innerHTML = `Score: ${score} | Level: ${level + 1}<br>Press any key to restart`;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function die() {
      // Play death animation
      deathAnim = true;
      deathTimer = 30; // frames
    }

    function nextLevel() {
      levelCompleteAnim = true;
      levelCompleteTimer = 40;
      // Time bonus
      const timeBonus = timeLeft * 10;
      score += timeBonus;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      animFrame = requestAnimationFrame(loop);

      if (deathAnim) {
        deathTimer--;
        draw();
        if (deathTimer <= 0) {
          deathAnim = false;
          gameOver();
        }
        return;
      }

      if (levelCompleteAnim) {
        levelCompleteTimer--;
        draw();
        if (levelCompleteTimer <= 0) {
          levelCompleteAnim = false;
          level++;
          generateCave(level);
        }
        return;
      }

      // Gravity and enemy movement on a tick
      if (timestamp - lastGravityTick >= tickInterval) {
        lastGravityTick = timestamp;
        applyGravity();
        moveEnemies();
      }

      draw();
    }

    function applyGravity() {
      // Process from bottom to top so things fall correctly
      // Reset falling state for next tick
      const newFalling = [];
      for (let r = 0; r < ROWS; r++) {
        newFalling[r] = [];
        for (let c = 0; c < COLS; c++) {
          newFalling[r][c] = false;
        }
      }

      for (let r = ROWS - 2; r >= 1; r--) {
        for (let c = 1; c < COLS - 1; c++) {
          const tile = grid[r][c];
          if (tile !== BOULDER && tile !== DIAMOND) continue;

          const below = grid[r + 1][c];
          const wasFalling = fallingMap[r][c];

          // Fall straight down if empty below
          if (below === EMPTY) {
            grid[r + 1][c] = tile;
            grid[r][c] = EMPTY;
            newFalling[r + 1][c] = true;
            continue;
          }

          // Kill player if falling onto them
          if (below === PLAYER && wasFalling) {
            grid[r + 1][c] = tile;
            grid[r][c] = EMPTY;
            die();
            return;
          }

          // Kill enemy if falling onto them
          if (below === ENEMY && wasFalling) {
            grid[r + 1][c] = tile;
            grid[r][c] = EMPTY;
            // Remove enemy
            for (let i = enemies.length - 1; i >= 0; i--) {
              if (enemies[i].r === r + 1 && enemies[i].c === c) {
                enemies[i].alive = false;
                enemies.splice(i, 1);
                // Bonus for crushing enemy
                score += 200;
                scoreEl.textContent = score;
                if (score > best) {
                  best = score;
                  bestEl.textContent = best;
                }
                break;
              }
            }
            newFalling[r + 1][c] = true;
            continue;
          }

          // Slide off rounded objects (boulders and diamonds)
          if (below === BOULDER || below === DIAMOND || below === WALL) {
            // Try sliding left
            if (c > 1 && grid[r][c - 1] === EMPTY && grid[r + 1][c - 1] === EMPTY) {
              grid[r][c - 1] = tile;
              grid[r][c] = EMPTY;
              newFalling[r][c - 1] = true;
              continue;
            }
            // Try sliding right
            if (c < COLS - 2 && grid[r][c + 1] === EMPTY && grid[r + 1][c + 1] === EMPTY) {
              grid[r][c + 1] = tile;
              grid[r][c] = EMPTY;
              newFalling[r][c + 1] = true;
              continue;
            }
          }

          // Not falling this tick
          newFalling[r][c] = false;
        }
      }
      fallingMap = newFalling;
    }

    function moveEnemies() {
      // Directions: 0=up, 1=right, 2=down, 3=left
      const dr = [-1, 0, 1, 0];
      const dc = [0, 1, 0, -1];

      for (const enemy of enemies) {
        if (!enemy.alive) continue;

        // Wall-following AI: try to turn left first, then straight, then right, then reverse
        const leftDir = (enemy.dir + 3) % 4;
        const rightDir = (enemy.dir + 1) % 4;
        const reverseDir = (enemy.dir + 2) % 4;

        const tryDirs = [leftDir, enemy.dir, rightDir, reverseDir];
        let moved = false;

        for (const d of tryDirs) {
          const nr = enemy.r + dr[d];
          const nc = enemy.c + dc[d];
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
            const target = grid[nr][nc];
            if (target === EMPTY) {
              grid[enemy.r][enemy.c] = EMPTY;
              enemy.r = nr;
              enemy.c = nc;
              grid[nr][nc] = ENEMY;
              enemy.dir = d;
              moved = true;
              break;
            }
            if (target === PLAYER) {
              die();
              return;
            }
          }
        }

        if (!moved) {
          // Stuck, try random direction next tick
          enemy.dir = Math.floor(Math.random() * 4);
        }
      }
    }

    function tryMove(dr, dc) {
      if (gameState !== 'playing' || deathAnim || levelCompleteAnim) return;

      const nr = player.r + dr;
      const nc = player.c + dc;

      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) return;

      const target = grid[nr][nc];

      // Can't move into walls or steel
      if (target === WALL || target === STEEL) return;

      // Can't move into falling boulders from the side
      // (but can push stationary boulders horizontally)

      // Push boulder horizontally
      if (target === BOULDER && dr === 0) {
        const behindR = nr;
        const behindC = nc + dc;
        if (behindC >= 0 && behindC < COLS && grid[behindR][behindC] === EMPTY && !fallingMap[nr][nc]) {
          grid[behindR][behindC] = BOULDER;
          fallingMap[behindR][behindC] = false;
          // Move player
          grid[player.r][player.c] = EMPTY;
          player.r = nr;
          player.c = nc;
          grid[nr][nc] = PLAYER;
          return;
        }
        return; // Can't push
      }

      if (target === BOULDER && dr !== 0) return; // Can't push vertically

      // Collect diamond
      if (target === DIAMOND) {
        diamondsCollected++;
        score += 100;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        if (diamondsCollected >= diamondsNeeded && !exitOpen) {
          exitOpen = true;
        }
      }

      // Reach exit
      if (target === EXIT) {
        if (exitOpen) {
          nextLevel();
          return;
        }
        return; // Exit not open yet
      }

      // Enemy collision
      if (target === ENEMY) {
        die();
        return;
      }

      // Move into empty, dirt, or diamond space
      if (target === EMPTY || target === DIRT || target === DIAMOND) {
        grid[player.r][player.c] = EMPTY;
        player.r = nr;
        player.c = nc;
        grid[nr][nc] = PLAYER;
      }
    }

    function draw() {
      ctx.fillStyle = '#0a0a14';
      ctx.fillRect(0, 0, W, H);

      const sparklePhase = (Date.now() % 1000) / 1000;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = c * TILE_W;
          const y = r * TILE_H;
          const tile = grid[r][c];

          switch (tile) {
            case DIRT:
              // Brown dirt with slight texture
              ctx.fillStyle = '#6b4423';
              ctx.fillRect(x, y, TILE_W, TILE_H);
              ctx.fillStyle = '#8b6433';
              ctx.fillRect(x + 2, y + 2, TILE_W - 4, TILE_H - 4);
              // Texture dots
              ctx.fillStyle = '#5a3a1a';
              if ((r + c) % 3 === 0) ctx.fillRect(x + 4, y + 4, 2, 2);
              if ((r + c) % 3 === 1) ctx.fillRect(x + 12, y + 10, 2, 2);
              break;

            case WALL:
              // Gray stone wall
              ctx.fillStyle = '#444';
              ctx.fillRect(x, y, TILE_W, TILE_H);
              ctx.fillStyle = '#555';
              ctx.fillRect(x + 1, y + 1, TILE_W - 2, TILE_H - 2);
              ctx.fillStyle = '#3a3a3a';
              ctx.fillRect(x + 3, y + 3, TILE_W - 6, 1);
              ctx.fillRect(x + 3, y + TILE_H - 4, TILE_W - 6, 1);
              break;

            case STEEL:
              // Dark indestructible border
              ctx.fillStyle = '#333';
              ctx.fillRect(x, y, TILE_W, TILE_H);
              ctx.fillStyle = '#2a2a2a';
              ctx.fillRect(x + 1, y + 1, TILE_W - 2, TILE_H - 2);
              // Cross hatch
              ctx.strokeStyle = '#3a3a3a';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + TILE_W, y + TILE_H);
              ctx.moveTo(x + TILE_W, y);
              ctx.lineTo(x, y + TILE_H);
              ctx.stroke();
              break;

            case BOULDER:
              // Gray circle boulder
              ctx.fillStyle = '#888';
              ctx.shadowColor = '#666';
              ctx.shadowBlur = 3;
              ctx.beginPath();
              ctx.arc(x + TILE_W / 2, y + TILE_H / 2, TILE_W / 2 - 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
              // Highlight
              ctx.fillStyle = '#aaa';
              ctx.beginPath();
              ctx.arc(x + TILE_W / 2 - 2, y + TILE_H / 2 - 3, 3, 0, Math.PI * 2);
              ctx.fill();
              break;

            case DIAMOND:
              // Bright cyan/white sparkle diamond
              drawDiamond(x, y, sparklePhase);
              break;

            case PLAYER:
              if (deathAnim) {
                // Death flash
                const flash = deathTimer % 4 < 2;
                ctx.fillStyle = flash ? '#f44' : '#fff';
                ctx.shadowColor = '#f44';
                ctx.shadowBlur = 15;
                ctx.fillRect(x + 2, y + 2, TILE_W - 4, TILE_H - 4);
                ctx.shadowBlur = 0;
              } else {
                drawPlayer(x, y);
              }
              break;

            case EXIT:
              drawExit(x, y);
              break;

            case ENEMY:
              drawEnemy(x, y);
              break;

            // EMPTY: do nothing (black background)
          }
        }
      }

      // HUD overlay on canvas
      drawHUD();

      // Update ML pipeline data
      updateGameData();
    }

    function drawDiamond(x, y, phase) {
      const cx = x + TILE_W / 2;
      const cy = y + TILE_H / 2;
      const size = TILE_W / 2 - 2;
      const glow = 0.5 + 0.5 * Math.sin(phase * Math.PI * 2 + x * 0.3);

      ctx.shadowColor = '#8cf';
      ctx.shadowBlur = 6 + glow * 8;

      // Diamond shape (rotated square)
      ctx.fillStyle = `rgba(136, 204, 255, ${0.7 + glow * 0.3})`;
      ctx.beginPath();
      ctx.moveTo(cx, cy - size);
      ctx.lineTo(cx + size, cy);
      ctx.lineTo(cx, cy + size);
      ctx.lineTo(cx - size, cy);
      ctx.closePath();
      ctx.fill();

      // Inner bright spot
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx - 1, cy - 2, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawPlayer(x, y) {
      const cx = x + TILE_W / 2;
      const cy = y + TILE_H / 2;

      ctx.shadowColor = '#8cf';
      ctx.shadowBlur = 10;

      // Body
      ctx.fillStyle = '#8cf';
      ctx.fillRect(x + 4, y + 6, TILE_W - 8, TILE_H - 8);

      // Head
      ctx.fillStyle = '#adf';
      ctx.beginPath();
      ctx.arc(cx, y + 5, 4, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(cx - 3, y + 3, 2, 2);
      ctx.fillRect(cx + 1, y + 3, 2, 2);

      ctx.shadowBlur = 0;
    }

    function drawExit(x, y) {
      if (exitOpen) {
        // Glowing open exit
        const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
        ctx.fillStyle = `rgba(100, 255, 100, ${0.4 + pulse * 0.6})`;
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 12 + pulse * 8;
        ctx.fillRect(x + 2, y + 2, TILE_W - 4, TILE_H - 4);
        ctx.shadowBlur = 0;

        // Door frame
        ctx.strokeStyle = '#4f4';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 3, y + 3, TILE_W - 6, TILE_H - 6);

        // Arrow or "E" indicator
        ctx.fillStyle = '#fff';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('E', x + TILE_W / 2, y + TILE_H / 2);
      } else {
        // Locked exit - dark steel door
        ctx.fillStyle = '#2a2a3e';
        ctx.fillRect(x + 2, y + 2, TILE_W - 4, TILE_H - 4);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 3, y + 3, TILE_W - 6, TILE_H - 6);
      }
    }

    function drawEnemy(x, y) {
      const cx = x + TILE_W / 2;
      const cy = y + TILE_H / 2;
      const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.008);

      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 8;

      // Butterfly/firefly enemy shape
      ctx.fillStyle = `rgba(255, 68, 68, ${pulse})`;
      // Body
      ctx.beginPath();
      ctx.arc(cx, cy, TILE_W / 2 - 3, 0, Math.PI * 2);
      ctx.fill();

      // Wings (triangles)
      ctx.fillStyle = `rgba(255, 120, 80, ${pulse})`;
      ctx.beginPath();
      ctx.moveTo(cx - 2, cy);
      ctx.lineTo(cx - TILE_W / 2 + 1, cy - 4);
      ctx.lineTo(cx - TILE_W / 2 + 1, cy + 4);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(cx + 2, cy);
      ctx.lineTo(cx + TILE_W / 2 - 1, cy - 4);
      ctx.lineTo(cx + TILE_W / 2 - 1, cy + 4);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(cx - 3, cy - 2, 2, 2);
      ctx.fillRect(cx + 1, cy - 2, 2, 2);

      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Semi-transparent bar at top
      ctx.fillStyle = 'rgba(10, 10, 20, 0.7)';
      ctx.fillRect(0, 0, W, 18);

      ctx.font = '11px Courier New';
      ctx.textBaseline = 'top';

      // Level
      ctx.fillStyle = '#8cf';
      ctx.textAlign = 'left';
      ctx.fillText(`LVL ${level + 1}`, 4, 3);

      // Diamonds
      const dColor = exitOpen ? '#4f4' : '#8cf';
      ctx.fillStyle = dColor;
      ctx.textAlign = 'center';
      ctx.fillText(`\u2666 ${diamondsCollected}/${diamondsNeeded}`, W / 2, 3);

      // Timer
      const tColor = timeLeft <= 15 ? '#f44' : '#8cf';
      ctx.fillStyle = tColor;
      ctx.textAlign = 'right';
      ctx.fillText(`TIME ${timeLeft}`, W - 4, 3);

      // If exit is open, flash message
      if (exitOpen && !levelCompleteAnim) {
        const flash = Math.sin(Date.now() * 0.006) > 0;
        if (flash) {
          ctx.fillStyle = 'rgba(10, 10, 20, 0.6)';
          ctx.fillRect(W / 2 - 60, H - 22, 120, 18);
          ctx.fillStyle = '#4f4';
          ctx.font = '12px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText('EXIT OPEN!', W / 2, H - 6);
        }
      }

      // Level complete flash
      if (levelCompleteAnim) {
        ctx.fillStyle = 'rgba(10, 10, 20, 0.7)';
        ctx.fillRect(0, H / 2 - 20, W, 40);
        ctx.fillStyle = '#4f4';
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 15;
        ctx.font = '20px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`LEVEL ${level + 1} COMPLETE!`, W / 2, H / 2);
        ctx.shadowBlur = 0;
      }
    }

    // Keyboard handling
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowUp': tryMove(-1, 0); break;
          case 'ArrowDown': tryMove(1, 0); break;
          case 'ArrowLeft': tryMove(0, -1); break;
          case 'ArrowRight': tryMove(0, 1); break;
        }
      }
    });

    // Expose game data for potential ML pipelines
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        playerR: player ? player.r : 0,
        playerC: player ? player.c : 0,
        diamondsCollected,
        diamondsNeeded,
        exitOpen,
        timeLeft,
        level,
        enemyCount: enemies ? enemies.length : 0,
      };
    }

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

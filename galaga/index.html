<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaga</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f48; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255,68,136,0.5); }
    h1 { color: #f48; font-size: 2rem; text-shadow: 0 0 15px rgba(255,68,136,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f48; }
    canvas {
      border: 2px solid #f48;
      box-shadow: 0 0 20px rgba(255,68,136,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f48;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>GALAGA</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">GALAGA</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const PLAYER_W = 32, PLAYER_H = 28, PLAYER_SPEED = 5;
    const BULLET_W = 3, BULLET_H = 12, BULLET_SPEED = 8;
    const MAX_PLAYER_BULLETS = 2;

    const ENEMY_W = 28, ENEMY_H = 24;
    const FORM_COLS = 10, FORM_ROWS = 5;
    const FORM_PAD_X = 6, FORM_PAD_Y = 6;
    const FORM_TOP = 60;

    // Enemy types: bee, butterfly, boss
    const ENEMY_TYPES = {
      bee:       { hp: 1, points: 50,  divePts: 100, color: '#4ff', glow: '#0cc' },
      butterfly: { hp: 1, points: 80,  divePts: 160, color: '#ff4', glow: '#cc0' },
      boss:      { hp: 2, points: 150, divePts: 400, color: '#f48', glow: '#c24' }
    };

    // Stars
    const STARS = [];
    for (let i = 0; i < 80; i++) {
      STARS.push({
        x: Math.random() * W,
        y: Math.random() * H,
        speed: 0.2 + Math.random() * 0.8,
        brightness: 0.3 + Math.random() * 0.7,
        size: Math.random() > 0.8 ? 2 : 1
      });
    }

    // --- Game state ---
    let score, best = 0, gameState;
    let lives, level, player, playerBullets, enemies, enemyBullets, particles;
    let keys, tick, spawnPhase, spawnQueue, spawnTimer;
    let tractorBeam, capturedShip;

    // Formation grid positions (computed once per level)
    function formationX(col) {
      const totalW = FORM_COLS * (ENEMY_W + FORM_PAD_X) - FORM_PAD_X;
      const startX = (W - totalW) / 2;
      return startX + col * (ENEMY_W + FORM_PAD_X);
    }
    function formationY(row) {
      return FORM_TOP + row * (ENEMY_H + FORM_PAD_Y);
    }

    // --- Bezier dive paths ---
    function bezier(t, p0, p1, p2, p3) {
      const u = 1 - t;
      return u*u*u*p0 + 3*u*u*t*p1 + 3*u*t*t*p2 + t*t*t*p3;
    }

    function makeDivePath(startX, startY, targetX, targetY) {
      // Generate a swooping bezier curve
      const midY = H * 0.55;
      const swingDir = Math.random() > 0.5 ? 1 : -1;
      const swingAmount = 80 + Math.random() * 120;
      return {
        p0x: startX, p0y: startY,
        p1x: startX + swingDir * swingAmount, p1y: midY - 60,
        p2x: targetX - swingDir * swingAmount * 0.5, p2y: midY + 100,
        p3x: targetX, p3y: targetY
      };
    }

    function makeLoopPath(startX, startY) {
      // Swooping loop that goes down toward the player then back up
      const playerCX = player.x + PLAYER_W / 2;
      const loopDir = startX > W / 2 ? -1 : 1;
      return {
        p0x: startX, p0y: startY,
        p1x: startX + loopDir * 100, p1y: H * 0.4,
        p2x: playerCX + loopDir * 60, p2y: H * 0.85,
        p3x: startX, p3y: startY
      };
    }

    function makeEntryPath(entryX, entryY, destX, destY) {
      // Enemies fly in from top/sides with a curve
      const midX = (entryX + destX) / 2 + (Math.random() - 0.5) * 200;
      return {
        p0x: entryX, p0y: entryY,
        p1x: midX, p1y: entryY + 80,
        p2x: midX, p2y: destY - 40,
        p3x: destX, p3y: destY
      };
    }

    function makeEnemy(type, row, col) {
      return {
        type,
        row, col,
        hp: ENEMY_TYPES[type].hp,
        // Position
        x: formationX(col), y: formationY(row),
        formX: formationX(col), formY: formationY(row),
        // State: 'entering', 'formation', 'diving', 'returning', 'dead'
        state: 'entering',
        // Path following
        path: null, pathT: 0, pathSpeed: 0,
        // Dive cooldown
        diveCooldown: 120 + Math.random() * 300,
        // Alive
        alive: true,
        // Hit flash
        hitFlash: 0,
        // For tractor beam boss
        hasTractorBeam: false,
        tractorTimer: 0
      };
    }

    function init() {
      score = 0;
      lives = 3;
      level = 0;
      tick = 0;
      keys = {};
      player = { x: W / 2 - PLAYER_W / 2, y: H - 60 };
      playerBullets = [];
      enemies = [];
      enemyBullets = [];
      particles = [];
      tractorBeam = null;
      capturedShip = null;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GALAGA';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      nextLevel();
      loop();
    }

    function nextLevel() {
      level++;
      spawnPhase = 0;
      spawnQueue = [];
      spawnTimer = 0;

      // Build formation for this level
      // Row 0: bosses, Row 1: butterflies, Rows 2-4: bees
      // Progressive: more enemies each level, fill more of the grid
      const bossCount = Math.min(4 + Math.floor(level / 3), FORM_COLS);
      const butterflyCount = Math.min(6 + Math.floor(level / 2), FORM_COLS);
      const beeRows = Math.min(2 + Math.floor(level / 4), 3);

      // Queue spawn groups with entry paths
      const groups = [];

      // Bosses enter from top-right
      const bossStartCol = Math.floor((FORM_COLS - bossCount) / 2);
      const bossGroup = [];
      for (let c = 0; c < bossCount; c++) {
        const e = makeEnemy('boss', 0, bossStartCol + c);
        e.path = makeEntryPath(W + 20, -20, e.formX + ENEMY_W / 2, e.formY + ENEMY_H / 2);
        e.pathSpeed = 0.012 + level * 0.001;
        bossGroup.push(e);
      }
      groups.push(bossGroup);

      // Butterflies enter from top-left
      const bfStartCol = Math.floor((FORM_COLS - butterflyCount) / 2);
      const bfGroup = [];
      for (let c = 0; c < butterflyCount; c++) {
        const e = makeEnemy('butterfly', 1, bfStartCol + c);
        e.path = makeEntryPath(-20, -20, e.formX + ENEMY_W / 2, e.formY + ENEMY_H / 2);
        e.pathSpeed = 0.014 + level * 0.001;
        bfGroup.push(e);
      }
      groups.push(bfGroup);

      // Bees enter from alternating sides
      for (let r = 0; r < beeRows; r++) {
        const beeCount = Math.min(8 + Math.floor(level / 3), FORM_COLS);
        const beeStartCol = Math.floor((FORM_COLS - beeCount) / 2);
        const beeGroup = [];
        const side = r % 2 === 0 ? 1 : -1;
        for (let c = 0; c < beeCount; c++) {
          const e = makeEnemy('bee', 2 + r, beeStartCol + c);
          e.path = makeEntryPath(
            side > 0 ? W + 20 : -20,
            -30 - c * 5,
            e.formX + ENEMY_W / 2, e.formY + ENEMY_H / 2
          );
          e.pathSpeed = 0.016 + level * 0.001;
          beeGroup.push(e);
        }
        groups.push(beeGroup);
      }

      spawnQueue = groups;
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
        return;
      }
      // Brief invincibility handled by respawn flash
      player.x = W / 2 - PLAYER_W / 2;
      player.invincible = 45;
    }

    // --- Update ---
    function update() {
      tick++;

      // Spawn enemies from queue
      if (spawnQueue.length > 0) {
        spawnTimer++;
        if (spawnTimer >= 30) {
          spawnTimer = 0;
          const group = spawnQueue.shift();
          group.forEach((e, i) => {
            e.pathT = -i * 0.04; // Stagger entry
            enemies.push(e);
          });
        }
      }

      // Player movement
      if (keys['ArrowLeft'] || keys['a']) player.x -= PLAYER_SPEED;
      if (keys['ArrowRight'] || keys['d']) player.x += PLAYER_SPEED;
      player.x = Math.max(0, Math.min(W - PLAYER_W, player.x));
      if (player.invincible > 0) player.invincible--;

      // Player bullets
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        playerBullets[i].y -= BULLET_SPEED;
        if (playerBullets[i].y < -BULLET_H) {
          playerBullets.splice(i, 1);
        }
      }

      // Update stars
      STARS.forEach(s => {
        s.y += s.speed;
        if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
      });

      // Formation sway
      const formSwayX = Math.sin(tick * 0.015) * (20 + level * 2);
      const formSwayY = Math.sin(tick * 0.01) * 5;

      // Update enemies
      const liveEnemies = enemies.filter(e => e.alive);
      const divingCount = enemies.filter(e => e.alive && (e.state === 'diving' || e.state === 'returning')).length;
      const maxDivers = Math.min(2 + Math.floor(level / 2), 6);
      const diveChance = 0.003 + level * 0.001;

      for (const e of enemies) {
        if (!e.alive) continue;
        if (e.hitFlash > 0) e.hitFlash--;

        if (e.state === 'entering') {
          if (e.pathT < 0) { e.pathT += 0.02; continue; }
          e.pathT += e.pathSpeed;
          if (e.pathT >= 1) {
            e.state = 'formation';
            e.x = e.formX;
            e.y = e.formY;
            e.path = null;
          } else {
            const p = e.path;
            e.x = bezier(e.pathT, p.p0x, p.p1x, p.p2x, p.p3x) - ENEMY_W / 2;
            e.y = bezier(e.pathT, p.p0y, p.p1y, p.p2y, p.p3y) - ENEMY_H / 2;
          }
        } else if (e.state === 'formation') {
          // Sway with formation
          e.x = e.formX + formSwayX;
          e.y = e.formY + formSwayY;

          // Chance to dive
          e.diveCooldown--;
          if (e.diveCooldown <= 0 && divingCount < maxDivers && Math.random() < diveChance) {
            e.state = 'diving';
            e.path = makeLoopPath(e.x + ENEMY_W / 2, e.y + ENEMY_H / 2);
            e.pathT = 0;
            e.pathSpeed = 0.008 + level * 0.002;

            // Boss tractor beam chance
            if (e.type === 'boss' && !capturedShip && Math.random() < 0.25) {
              e.hasTractorBeam = true;
            }
          }
        } else if (e.state === 'diving') {
          e.pathT += e.pathSpeed;

          // Tractor beam logic
          if (e.hasTractorBeam && e.pathT > 0.3 && e.pathT < 0.6 && !tractorBeam) {
            // Stop and deploy tractor beam
            const bx = bezier(0.45, e.path.p0x, e.path.p1x, e.path.p2x, e.path.p3x) - ENEMY_W / 2;
            const by = bezier(0.45, e.path.p0y, e.path.p1y, e.path.p2y, e.path.p3y) - ENEMY_H / 2;
            e.x = bx; e.y = by;
            tractorBeam = { boss: e, timer: 120, x: bx + ENEMY_W / 2, y: by + ENEMY_H };
            e.tractorTimer = 120;
            continue;
          }

          if (e.tractorTimer > 0) {
            e.tractorTimer--;
            if (e.tractorTimer <= 0) {
              e.hasTractorBeam = false;
              tractorBeam = null;
              e.pathT = 0.6; // Resume dive
            }
            continue;
          }

          if (e.pathT >= 1) {
            e.state = 'formation';
            e.x = e.formX + formSwayX;
            e.y = e.formY + formSwayY;
            e.path = null;
            e.diveCooldown = 180 + Math.random() * 200;
            e.hasTractorBeam = false;
          } else {
            const p = e.path;
            e.x = bezier(e.pathT, p.p0x, p.p1x, p.p2x, p.p3x) - ENEMY_W / 2;
            e.y = bezier(e.pathT, p.p0y, p.p1y, p.p2y, p.p3y) - ENEMY_H / 2;
          }

          // Shoot while diving
          if (Math.random() < 0.02 + level * 0.003) {
            const dx = (player.x + PLAYER_W / 2) - (e.x + ENEMY_W / 2);
            const dy = (player.y) - (e.y + ENEMY_H);
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const spd = 3 + level * 0.3;
            enemyBullets.push({
              x: e.x + ENEMY_W / 2,
              y: e.y + ENEMY_H,
              vx: (dx / dist) * spd,
              vy: (dy / dist) * spd
            });
          }
        }
      }

      // Tractor beam capture check
      if (tractorBeam) {
        tractorBeam.timer--;
        if (tractorBeam.timer <= 0) {
          tractorBeam.boss.hasTractorBeam = false;
          tractorBeam.boss.tractorTimer = 0;
          tractorBeam = null;
        } else if (!player.invincible) {
          // Check if player is under the beam
          const beamX = tractorBeam.x;
          const playerCX = player.x + PLAYER_W / 2;
          if (Math.abs(playerCX - beamX) < 30 &&
              player.y > tractorBeam.y && player.y < tractorBeam.y + 200) {
            // Captured!
            capturedShip = {
              x: player.x, y: player.y,
              targetX: tractorBeam.boss.x,
              targetY: tractorBeam.boss.y - PLAYER_H - 4,
              boss: tractorBeam.boss,
              attached: false
            };
            tractorBeam.boss.hasTractorBeam = false;
            tractorBeam.boss.tractorTimer = 0;
            tractorBeam = null;
            spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#f48');
            loseLife();
          }
        }
      }

      // Captured ship follows its boss
      if (capturedShip && capturedShip.boss.alive) {
        if (!capturedShip.attached) {
          // Float up to boss
          capturedShip.y -= 2;
          capturedShip.x += (capturedShip.targetX - capturedShip.x) * 0.05;
          if (capturedShip.y <= capturedShip.targetY + 10) {
            capturedShip.attached = true;
          }
        } else {
          capturedShip.x = capturedShip.boss.x;
          capturedShip.y = capturedShip.boss.y - PLAYER_H - 4;
        }
      }

      // If the boss holding captured ship dies, release it as a life bonus
      if (capturedShip && !capturedShip.boss.alive) {
        // Ship rescued! Player gets dual ship (extra life)
        lives++;
        livesEl.textContent = lives;
        spawnExplosion(capturedShip.x + PLAYER_W / 2, capturedShip.y + PLAYER_H / 2, '#4f4');
        score += 1000;
        scoreEl.textContent = score;
        capturedShip = null;
      }

      // Formation enemies shoot occasionally
      const formEnemies = enemies.filter(e => e.alive && e.state === 'formation');
      if (formEnemies.length > 0 && Math.random() < 0.01 + level * 0.004) {
        // Bottom-row enemies preferred
        const bottomRow = {};
        formEnemies.forEach(e => {
          if (!bottomRow[e.col] || e.row > bottomRow[e.col].row) {
            bottomRow[e.col] = e;
          }
        });
        const shooters = Object.values(bottomRow);
        const shooter = shooters[Math.floor(Math.random() * shooters.length)];
        const spd = 2.5 + level * 0.2;
        enemyBullets.push({
          x: shooter.x + ENEMY_W / 2,
          y: shooter.y + ENEMY_H,
          vx: (Math.random() - 0.5) * 1.2,
          vy: spd
        });
      }

      // Enemy bullets update
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        enemyBullets[i].x += enemyBullets[i].vx;
        enemyBullets[i].y += enemyBullets[i].vy;
        if (enemyBullets[i].y > H + 10 || enemyBullets[i].x < -10 || enemyBullets[i].x > W + 10) {
          enemyBullets.splice(i, 1);
          continue;
        }
        // Hit player
        if (!player.invincible &&
            enemyBullets[i].x >= player.x && enemyBullets[i].x <= player.x + PLAYER_W &&
            enemyBullets[i].y >= player.y && enemyBullets[i].y <= player.y + PLAYER_H) {
          enemyBullets.splice(i, 1);
          spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#f48');
          loseLife();
          continue;
        }
      }

      // Player bullet vs enemy collision
      for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
        const b = playerBullets[bi];
        let hit = false;
        for (const e of enemies) {
          if (!e.alive) continue;
          if (b.x >= e.x && b.x <= e.x + ENEMY_W &&
              b.y >= e.y && b.y <= e.y + ENEMY_H) {
            e.hp--;
            e.hitFlash = 6;
            playerBullets.splice(bi, 1);
            if (e.hp <= 0) {
              e.alive = false;
              const t = ENEMY_TYPES[e.type];
              const pts = (e.state === 'diving' || e.state === 'returning') ? t.divePts : t.points;
              score += pts;
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }
              spawnExplosion(e.x + ENEMY_W / 2, e.y + ENEMY_H / 2, t.color);
            } else {
              spawnSpark(e.x + ENEMY_W / 2, e.y + ENEMY_H / 2);
            }
            hit = true;
            break;
          }
        }
      }

      // Diving enemy collides with player
      if (!player.invincible) {
        for (const e of enemies) {
          if (!e.alive || e.state === 'formation' || e.state === 'entering') continue;
          if (e.x < player.x + PLAYER_W && e.x + ENEMY_W > player.x &&
              e.y < player.y + PLAYER_H && e.y + ENEMY_H > player.y) {
            e.alive = false;
            spawnExplosion(e.x + ENEMY_W / 2, e.y + ENEMY_H / 2, ENEMY_TYPES[e.type].color);
            spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#f48');
            loseLife();
            break;
          }
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.03;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Check if all enemies dead -> next level
      if (enemies.length > 0 && spawnQueue.length === 0 && enemies.every(e => !e.alive)) {
        nextLevel();
      }
    }

    function spawnExplosion(x, y, color) {
      // 8-petal star burst at cardinal + diagonal angles
      for (let i = 0; i < 8; i++) {
        const ang = (Math.PI * 2 / 8) * i;
        const spd = 2.5 + Math.random() * 2;
        const len = 5 + Math.random() * 4;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 22 + Math.random() * 10,
          color,
          star: true,
          len
        });
      }
      // Random scatter sparks
      for (let i = 0; i < 8; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 12 + Math.random() * 10,
          color,
          star: false
        });
      }
    }

    function spawnSpark(x, y) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 8 + Math.random() * 5,
          color: '#fff'
        });
      }
    }

    function shoot() {
      if (playerBullets.length < MAX_PLAYER_BULLETS) {
        playerBullets.push({
          x: player.x + PLAYER_W / 2 - BULLET_W / 2,
          y: player.y - BULLET_H
        });
      }
    }

    // --- Drawing ---
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Stars
      STARS.forEach(s => {
        const twinkle = (Math.sin(tick * 0.03 + s.x * 0.1) + 1) * 0.5;
        const alpha = s.brightness * (0.5 + twinkle * 0.5);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      });

      // Level indicator
      ctx.fillStyle = '#333';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`Stage ${level}`, W - 10, 20);
      ctx.textAlign = 'left';

      // Enemies
      for (const e of enemies) {
        if (!e.alive) continue;
        drawEnemy(e);
      }

      // Captured ship
      if (capturedShip && capturedShip.boss.alive) {
        drawPlayerShip(capturedShip.x, capturedShip.y, '#888', '#555', true);
      }

      // Tractor beam
      if (tractorBeam) {
        drawTractorBeam(tractorBeam);
      }

      // Player
      if (gameState === 'playing' || gameState === 'waiting') {
        if (!player.invincible || Math.floor(tick / 3) % 2 === 0) {
          drawPlayerShip(player.x, player.y, '#f48', '#c24', false);
        }
      }

      // Player bullets
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#f48';
      ctx.shadowBlur = 8;
      playerBullets.forEach(b => {
        ctx.fillRect(b.x, b.y, BULLET_W, BULLET_H);
      });
      ctx.shadowBlur = 0;

      // Enemy bullets
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      enemyBullets.forEach(b => {
        ctx.fillStyle = '#f66';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Particles
      particles.forEach(p => {
        const alpha = Math.min(1, p.life / 15);
        ctx.globalAlpha = alpha;
        if (p.star) {
          ctx.strokeStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 6;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x + p.vx * (p.len / 2.5), p.y + p.vy * (p.len / 2.5));
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 4;
          ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        }
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Lives indicator
      for (let i = 0; i < lives - 1; i++) {
        drawMiniShip(10 + i * 22, H - 20);
      }

      // CRT Scanlines overlay
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#000';
      for (let sy = 0; sy < H; sy += 2) {
        ctx.fillRect(0, sy, W, 1);
      }
      ctx.globalAlpha = 1;
    }

    function drawPlayerShip(x, y, color, glow, captured) {
      ctx.fillStyle = color;
      ctx.shadowColor = glow;
      ctx.shadowBlur = captured ? 4 : 12;
      // Main body
      ctx.beginPath();
      ctx.moveTo(x + PLAYER_W / 2, y);
      ctx.lineTo(x + PLAYER_W, y + PLAYER_H);
      ctx.lineTo(x + PLAYER_W - 6, y + PLAYER_H - 4);
      ctx.lineTo(x + PLAYER_W / 2, y + 10);
      ctx.lineTo(x + 6, y + PLAYER_H - 4);
      ctx.lineTo(x, y + PLAYER_H);
      ctx.closePath();
      ctx.fill();
      // Cockpit
      ctx.fillStyle = captured ? '#555' : '#fff';
      ctx.beginPath();
      ctx.arc(x + PLAYER_W / 2, y + 10, 3, 0, Math.PI * 2);
      ctx.fill();
      // Wing accents
      if (!captured) {
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.3;
        ctx.fillRect(x + 3, y + PLAYER_H - 6, 8, 2);
        ctx.fillRect(x + PLAYER_W - 11, y + PLAYER_H - 6, 8, 2);
        ctx.globalAlpha = 1;
      }
      ctx.shadowBlur = 0;
    }

    function drawMiniShip(x, y) {
      ctx.fillStyle = '#f48';
      ctx.beginPath();
      ctx.moveTo(x + 6, y);
      ctx.lineTo(x + 12, y + 10);
      ctx.lineTo(x, y + 10);
      ctx.closePath();
      ctx.fill();
    }

    function drawEnemy(e) {
      const t = ENEMY_TYPES[e.type];
      const cx = e.x + ENEMY_W / 2;
      const cy = e.y + ENEMY_H / 2;

      if (e.hitFlash > 0) {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
      } else {
        ctx.fillStyle = t.color;
        ctx.shadowColor = t.glow;
      }
      ctx.shadowBlur = 8;

      if (e.type === 'bee') {
        // Small compact shape
        ctx.beginPath();
        ctx.moveTo(cx, e.y + 2);
        ctx.lineTo(e.x + ENEMY_W - 4, cy);
        ctx.lineTo(cx + 4, e.y + ENEMY_H - 2);
        ctx.lineTo(cx - 4, e.y + ENEMY_H - 2);
        ctx.lineTo(e.x + 4, cy);
        ctx.closePath();
        ctx.fill();
        // Wings (animated)
        const wingFlap = Math.sin(tick * 0.2 + e.col) * 4;
        ctx.fillStyle = e.hitFlash > 0 ? '#fff' : 'rgba(0,255,255,0.4)';
        ctx.beginPath();
        ctx.moveTo(e.x + 4, cy);
        ctx.lineTo(e.x - 2, cy - 6 + wingFlap);
        ctx.lineTo(e.x + 8, cy - 2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(e.x + ENEMY_W - 4, cy);
        ctx.lineTo(e.x + ENEMY_W + 2, cy - 6 - wingFlap);
        ctx.lineTo(e.x + ENEMY_W - 8, cy - 2);
        ctx.closePath();
        ctx.fill();
      } else if (e.type === 'butterfly') {
        // Wider butterfly shape
        ctx.beginPath();
        ctx.moveTo(cx, e.y + 2);
        ctx.lineTo(e.x + ENEMY_W - 2, e.y + 6);
        ctx.lineTo(e.x + ENEMY_W, cy + 2);
        ctx.lineTo(cx + 6, e.y + ENEMY_H - 2);
        ctx.lineTo(cx, e.y + ENEMY_H);
        ctx.lineTo(cx - 6, e.y + ENEMY_H - 2);
        ctx.lineTo(e.x, cy + 2);
        ctx.lineTo(e.x + 2, e.y + 6);
        ctx.closePath();
        ctx.fill();
        // Wing detail
        const wingAng = Math.sin(tick * 0.15 + e.col * 0.5) * 3;
        ctx.fillStyle = e.hitFlash > 0 ? '#fff' : 'rgba(255,255,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(e.x + 5, cy - 2, 6, 4 + wingAng, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(e.x + ENEMY_W - 5, cy - 2, 6, 4 - wingAng, 0.3, 0, Math.PI * 2);
        ctx.fill();
      } else if (e.type === 'boss') {
        // Larger, more imposing
        ctx.beginPath();
        ctx.moveTo(cx, e.y);
        ctx.lineTo(e.x + ENEMY_W, e.y + 8);
        ctx.lineTo(e.x + ENEMY_W + 2, cy + 4);
        ctx.lineTo(e.x + ENEMY_W - 4, e.y + ENEMY_H);
        ctx.lineTo(e.x + 4, e.y + ENEMY_H);
        ctx.lineTo(e.x - 2, cy + 4);
        ctx.lineTo(e.x, e.y + 8);
        ctx.closePath();
        ctx.fill();
        // Boss crown/horns
        ctx.fillStyle = e.hitFlash > 0 ? '#fff' : '#f48';
        ctx.beginPath();
        ctx.moveTo(cx - 8, e.y + 4);
        ctx.lineTo(cx - 12, e.y - 4);
        ctx.lineTo(cx - 4, e.y + 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(cx + 8, e.y + 4);
        ctx.lineTo(cx + 12, e.y - 4);
        ctx.lineTo(cx + 4, e.y + 2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = e.hitFlash > 0 ? '#f48' : '#fff';
        ctx.beginPath();
        ctx.arc(cx - 6, cy, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(cx + 6, cy, 3, 0, Math.PI * 2);
        ctx.fill();
        // HP indicator for damaged boss
        if (e.hp < ENEMY_TYPES.boss.hp) {
          ctx.fillStyle = '#f00';
          ctx.globalAlpha = 0.6;
          ctx.fillRect(e.x + 4, e.y + ENEMY_H + 2, ENEMY_W - 8, 2);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(e.x + 4, e.y + ENEMY_H + 2, (ENEMY_W - 8) * (e.hp / ENEMY_TYPES.boss.hp), 2);
          ctx.globalAlpha = 1;
        }
      }

      ctx.shadowBlur = 0;
    }

    function drawTractorBeam(tb) {
      const beamW = 50;
      const beamH = player.y - tb.y;
      ctx.save();
      // Pulsing beam
      const pulse = Math.sin(tick * 0.15) * 0.2 + 0.5;
      const grad = ctx.createLinearGradient(tb.x, tb.y, tb.x, tb.y + beamH);
      grad.addColorStop(0, `rgba(255,68,136,${pulse})`);
      grad.addColorStop(0.5, `rgba(255,68,136,${pulse * 0.6})`);
      grad.addColorStop(1, `rgba(255,68,136,${pulse * 0.2})`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(tb.x - 8, tb.y);
      ctx.lineTo(tb.x + 8, tb.y);
      ctx.lineTo(tb.x + beamW / 2, tb.y + beamH);
      ctx.lineTo(tb.x - beamW / 2, tb.y + beamH);
      ctx.closePath();
      ctx.fill();
      // Beam edge lines
      ctx.strokeStyle = `rgba(255,68,136,${pulse * 0.8})`;
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(tb.x - 8, tb.y);
      ctx.lineTo(tb.x - beamW / 2, tb.y + beamH);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tb.x + 8, tb.y);
      ctx.lineTo(tb.x + beamW / 2, tb.y + beamH);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // --- Game loop ---
    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') { start(); }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') { init(); }
        return;
      }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === ' ') shoot();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

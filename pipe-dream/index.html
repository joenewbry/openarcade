<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pipe Dream</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }
    .back { color: #4dc; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 221, 204, 0.5); }
    h1 { color: #4dc; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 221, 204, 0.4); }
    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .side-panel { width: 130px; }
    .panel-box {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: center;
    }
    .panel-box label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }
    .panel-box .value {
      font-size: 1.4rem;
      color: #4dc;
    }
    #queueCanvas { display: block; margin: 0 auto; }
    canvas#game {
      border: 2px solid #4dc;
      box-shadow: 0 0 20px rgba(68, 221, 204, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4dc;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PIPE DREAM</h1>
  </div>
  <div class="game-area">
    <div class="side-panel">
      <div class="panel-box">
        <label>NEXT</label>
        <canvas id="queueCanvas" width="110" height="280"></canvas>
      </div>
      <div class="panel-box">
        <label>SCORE</label>
        <div class="value" id="score">0</div>
      </div>
      <div class="panel-box">
        <label>BEST</label>
        <div class="value" id="best">0</div>
      </div>
      <div class="panel-box">
        <label>TIMER</label>
        <div class="value" id="timer">--</div>
      </div>
    </div>
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="350" height="500"></canvas>
      <div class="overlay" id="overlay" style="width:350px;height:500px;">
        <h2 id="overlayTitle">PIPE DREAM</h2>
        <p id="overlayText">Press SPACE or click to start</p>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const queueCanvas = document.getElementById('queueCanvas');
    const qctx = queueCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const COLS = 7;
    const ROWS = 10;
    const CELL = 50;
    const W = canvas.width;
    const H = canvas.height;

    // Pipe types: connections [top, right, bottom, left]
    const PIPE_TYPES = [
      { name: 'vert',  conn: [1,0,1,0] },
      { name: 'horiz', conn: [0,1,0,1] },
      { name: 'tr',    conn: [1,1,0,0] },
      { name: 'rb',    conn: [0,1,1,0] },
      { name: 'bl',    conn: [0,0,1,1] },
      { name: 'lt',    conn: [1,0,0,1] },
      { name: 'cross', conn: [1,1,1,1] },
    ];

    const WATER_COLOR = '#0af';
    const WATER_GLOW = '#08f';
    const SOURCE_COLOR = '#f80';
    const CURSOR_COLOR = '#ff0';

    // Opposite directions: 0=top->2=bottom, 1=right->3=left
    const OPP = [2, 3, 0, 1];
    // Direction offsets [dr, dc]: top, right, bottom, left
    const DR = [-1, 0, 1, 0];
    const DC = [0, 1, 0, -1];

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // Game state
    let grid;            // ROWS x COLS: null or { typeIdx, filled:[t,r,b,l], crossUsed:0|1|2 }
    let queue;           // pipe type indices
    let cursorR, cursorC;
    let sourceR, sourceC, sourceDir;
    let flowHead;        // { r, c, fromDir } next cell water will enter
    let flowStarted;
    let flowCountdown;   // seconds remaining
    let flowSpeed;       // ms per pipe segment (decreases)
    let pipesUsed;       // number of pipes water has passed through
    let animProgress;    // 0..1 for current flow animation
    let animFromDir, animExitDir, animR, animC; // current animation targets
    let animating;       // true while animating a flow step

    let countdownId;     // setTimeout for countdown
    let animFrameId;     // requestAnimationFrame id

    const COUNTDOWN_SEC = 15;
    const SPEED_START = 1200;
    const SPEED_MIN = 350;
    const SPEED_STEP = 35;
    const QUEUE_LEN = 5;

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PIPE DREAM';
      overlayText.textContent = 'Press SPACE or click to start';
      timerEl.textContent = '--';

      grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      queue = [];
      for (let i = 0; i < QUEUE_LEN; i++) queue.push(randPipe());

      cursorR = Math.floor(ROWS / 2);
      cursorC = Math.floor(COLS / 2);

      // Random source on left or right edge
      sourceR = 1 + Math.floor(Math.random() * (ROWS - 2));
      const onLeft = Math.random() < 0.5;
      sourceC = onLeft ? 0 : COLS - 1;
      sourceDir = onLeft ? 1 : 3; // exits toward center

      flowHead = null;
      flowStarted = false;
      flowCountdown = COUNTDOWN_SEC;
      flowSpeed = SPEED_START;
      pipesUsed = 0;
      animProgress = 0;
      animating = false;

      clearTimeout(countdownId);
      cancelAnimationFrame(animFrameId);

      draw();
      drawQueue();
    }

    function randPipe() {
      // weights: straights common, bends common, cross rare
      const w = [3, 3, 2, 2, 2, 2, 1];
      const total = w.reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      for (let i = 0; i < w.length; i++) {
        r -= w[i];
        if (r <= 0) return i;
      }
      return 0;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      flowCountdown = COUNTDOWN_SEC;
      timerEl.textContent = flowCountdown;
      countdownTick();
      renderLoop();
    }

    function countdownTick() {
      if (gameState !== 'playing') return;
      timerEl.textContent = flowCountdown;
      if (flowCountdown <= 0) {
        beginFlow();
        return;
      }
      flowCountdown--;
      countdownId = setTimeout(countdownTick, 1000);
    }

    function beginFlow() {
      flowStarted = true;
      timerEl.textContent = 'FLOW';

      // Mark source in grid
      grid[sourceR][sourceC] = { typeIdx: -1, filled: [0,0,0,0], crossUsed: 0 };
      grid[sourceR][sourceC].filled[sourceDir] = 1;

      // First cell water enters
      flowHead = {
        r: sourceR + DR[sourceDir],
        c: sourceC + DC[sourceDir],
        fromDir: OPP[sourceDir]
      };

      advanceFlow();
    }

    function advanceFlow() {
      if (gameState !== 'playing') return;

      const { r, c, fromDir } = flowHead;

      // Off grid?
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) { endGame(); return; }

      const cell = grid[r][c];
      if (!cell || cell.typeIdx < 0) { endGame(); return; }

      const pipe = PIPE_TYPES[cell.typeIdx];

      // Pipe must connect on the entry side
      if (!pipe.conn[fromDir]) { endGame(); return; }

      // Find exit direction
      let exitDir;
      if (pipe.name === 'cross') {
        // Cross: water goes straight through
        exitDir = OPP[fromDir];
        // Check if this channel already used
        if (cell.filled[fromDir] && cell.filled[exitDir]) { endGame(); return; }
      } else {
        exitDir = -1;
        for (let d = 0; d < 4; d++) {
          if (d !== fromDir && pipe.conn[d]) { exitDir = d; break; }
        }
        if (exitDir < 0) { endGame(); return; }
        // Already filled?
        if (cell.filled[fromDir] && cell.filled[exitDir]) { endGame(); return; }
      }

      // Start animation for this pipe segment
      animR = r;
      animC = c;
      animFromDir = fromDir;
      animExitDir = exitDir;
      animProgress = 0;
      animating = true;

      const startTime = performance.now();
      const duration = flowSpeed;

      function step() {
        if (gameState !== 'playing') return;
        const now = performance.now();
        animProgress = Math.min(1, (now - startTime) / duration);

        if (animProgress < 1) {
          requestAnimationFrame(step);
        } else {
          // Animation done: mark filled
          animating = false;
          cell.filled[fromDir] = 1;
          cell.filled[exitDir] = 1;

          // Score
          pipesUsed++;
          let pts = 10;
          if (pipe.name === 'cross') {
            cell.crossUsed++;
            if (cell.crossUsed >= 2) pts += 50; // bonus for second channel
          }
          score += pts;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }

          // Speed up
          flowSpeed = Math.max(SPEED_MIN, SPEED_START - pipesUsed * SPEED_STEP);

          // Next cell
          flowHead = {
            r: r + DR[exitDir],
            c: c + DC[exitDir],
            fromDir: OPP[exitDir]
          };

          // Small delay then advance
          setTimeout(advanceFlow, 0);
        }
      }

      requestAnimationFrame(step);
    }

    function endGame() {
      gameState = 'over';
      animating = false;
      clearTimeout(countdownId);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = 'Pipes: ' + pipesUsed + ' | Score: ' + score + ' -- Press SPACE to restart';
    }

    function placePipe(r, c) {
      if (gameState !== 'playing') return;
      if (r === sourceR && c === sourceC) return;

      const cell = grid[r][c];

      // Can't replace a pipe that has water in it
      if (cell && (cell.filled[0] || cell.filled[1] || cell.filled[2] || cell.filled[3])) return;

      // Replacing an unfilled pipe costs countdown time
      if (cell && cell.typeIdx >= 0) {
        flowCountdown = Math.max(0, flowCountdown - 2);
        timerEl.textContent = flowStarted ? 'FLOW' : flowCountdown;
      }

      const typeIdx = queue.shift();
      queue.push(randPipe());

      grid[r][c] = {
        typeIdx: typeIdx,
        filled: [0, 0, 0, 0],
        crossUsed: 0
      };

      drawQueue();
    }

    // Main render loop
    function renderLoop() {
      if (gameState !== 'playing' && gameState !== 'over') return;
      draw();
      if (gameState === 'playing') {
        animFrameId = requestAnimationFrame(renderLoop);
      }
    }

    // ---- DRAWING ----

    function drawPipeShape(context, x, y, size, typeIdx) {
      const cx = x + size / 2;
      const cy = y + size / 2;
      const pw = size * 0.32; // pipe width
      const hw = pw / 2;
      const conn = PIPE_TYPES[typeIdx].conn;

      // Pipe walls: dark interior with border
      context.fillStyle = '#1e2d4d';
      context.strokeStyle = '#3a5a8a';
      context.lineWidth = 1.5;

      // Draw each arm from center to edge
      for (let d = 0; d < 4; d++) {
        if (!conn[d]) continue;
        context.save();
        context.translate(cx, cy);
        context.rotate(d * Math.PI / 2);
        context.fillRect(-hw, -size / 2, pw, size / 2 + hw);
        context.restore();
      }

      // Draw outlines (arms)
      for (let d = 0; d < 4; d++) {
        if (!conn[d]) continue;
        context.save();
        context.translate(cx, cy);
        context.rotate(d * Math.PI / 2);
        // left wall
        context.beginPath();
        context.moveTo(-hw, 0);
        context.lineTo(-hw, -size / 2);
        context.stroke();
        // right wall
        context.beginPath();
        context.moveTo(hw, 0);
        context.lineTo(hw, -size / 2);
        context.stroke();
        context.restore();
      }

      // Draw rounded end caps where arms DON'T connect
      for (let d = 0; d < 4; d++) {
        if (conn[d]) continue;
        // Draw a cap closing off this direction
        const nd = (d + 3) % 4; // check adjacent
        const pd = (d + 1) % 4;
        // Only draw cap wall segments between connected arms
      }

      // Draw connecting arcs for bends
      if (typeIdx >= 2 && typeIdx <= 5) {
        // It's a bend piece - draw rounded inner corner
        const connDirs = [];
        for (let d = 0; d < 4; d++) if (conn[d]) connDirs.push(d);
        if (connDirs.length === 2) {
          // Draw inner corner arc
          context.save();
          context.translate(cx, cy);
          // The two connected directions
          const d1 = connDirs[0], d2 = connDirs[1];
          context.restore();
        }
      }
    }

    function drawWater(context, x, y, size, filled, animInfo) {
      const cx = x + size / 2;
      const cy = y + size / 2;
      const pw = size * 0.32;
      const ww = pw * 0.55; // water width (inside pipe)
      const hw = ww / 2;

      context.fillStyle = WATER_COLOR;
      context.shadowColor = WATER_GLOW;
      context.shadowBlur = 6;

      // Draw filled water segments
      if (filled) {
        for (let d = 0; d < 4; d++) {
          if (!filled[d]) continue;
          context.save();
          context.translate(cx, cy);
          context.rotate(d * Math.PI / 2);
          context.fillRect(-hw, -size / 2, ww, size / 2);
          context.restore();
        }
        // Center blob if any filled
        if (filled.some(f => f)) {
          context.fillRect(cx - hw, cy - hw, ww, ww);
        }
      }

      // Animated water for current flow step
      if (animInfo) {
        const { fromDir, exitDir, progress } = animInfo;
        const p = progress;

        if (p <= 0.5) {
          // Water entering: from edge toward center
          const t = p * 2;
          context.save();
          context.translate(cx, cy);
          context.rotate(fromDir * Math.PI / 2);
          context.fillRect(-hw, -size / 2, ww, t * size / 2);
          context.restore();
        } else {
          // Entry side fully filled
          context.save();
          context.translate(cx, cy);
          context.rotate(fromDir * Math.PI / 2);
          context.fillRect(-hw, -size / 2, ww, size / 2);
          context.restore();

          // Center
          context.fillRect(cx - hw, cy - hw, ww, ww);

          // Water exiting: center toward edge
          const t = (p - 0.5) * 2;
          context.save();
          context.translate(cx, cy);
          context.rotate(exitDir * Math.PI / 2);
          // Draw from center outward (negative y in rotated space)
          context.fillRect(-hw, 0, ww, -(t * size / 2));
          context.restore();
        }
      }

      context.shadowBlur = 0;
    }

    function drawSourceCell(context, x, y, size) {
      const cx = x + size / 2;
      const cy = y + size / 2;

      // Source background
      context.fillStyle = '#2a1a0e';
      context.shadowColor = SOURCE_COLOR;
      context.shadowBlur = 12;
      context.fillRect(x + 3, y + 3, size - 6, size - 6);
      context.shadowBlur = 0;

      // Border
      context.strokeStyle = SOURCE_COLOR;
      context.lineWidth = 2;
      context.strokeRect(x + 3, y + 3, size - 6, size - 6);

      // "S" label
      context.fillStyle = SOURCE_COLOR;
      context.shadowColor = SOURCE_COLOR;
      context.shadowBlur = 8;
      context.font = 'bold ' + Math.floor(size * 0.4) + 'px Courier New';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText('S', cx, cy);
      context.shadowBlur = 0;

      // Arrow showing exit direction
      const arrX = cx + DC[sourceDir] * size * 0.3;
      const arrY = cy + DR[sourceDir] * size * 0.3;
      context.strokeStyle = SOURCE_COLOR;
      context.lineWidth = 2;
      context.beginPath();
      context.moveTo(cx + DC[sourceDir] * size * 0.1, cy + DR[sourceDir] * size * 0.1);
      context.lineTo(arrX, arrY);
      context.stroke();

      // Arrowhead
      const aLen = 5;
      const angle = Math.atan2(DR[sourceDir], DC[sourceDir]);
      context.beginPath();
      context.moveTo(arrX, arrY);
      context.lineTo(arrX - aLen * Math.cos(angle - 0.5), arrY - aLen * Math.sin(angle - 0.5));
      context.moveTo(arrX, arrY);
      context.lineTo(arrX - aLen * Math.cos(angle + 0.5), arrY - aLen * Math.sin(angle + 0.5));
      context.stroke();

      // Draw water spout if flow started
      if (flowStarted) {
        const ww = size * 0.32 * 0.55;
        context.fillStyle = WATER_COLOR;
        context.shadowColor = WATER_GLOW;
        context.shadowBlur = 8;
        context.save();
        context.translate(cx, cy);
        context.rotate(sourceDir * Math.PI / 2);
        context.fillRect(-ww / 2, 0, ww, -(size * 0.45));
        context.restore();
        context.shadowBlur = 0;
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * CELL, 0);
        ctx.lineTo(c * CELL, ROWS * CELL);
        ctx.stroke();
      }
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * CELL);
        ctx.lineTo(COLS * CELL, r * CELL);
        ctx.stroke();
      }

      // Draw all cells
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = grid[r][c];
          if (!cell) continue;

          const px = c * CELL;
          const py = r * CELL;

          // Source cell
          if (cell.typeIdx === -1) {
            drawSourceCell(ctx, px, py, CELL);
            continue;
          }

          // Draw pipe structure
          drawPipeShape(ctx, px, py, CELL, cell.typeIdx);

          // Draw static water fills
          let anim = null;
          if (animating && animR === r && animC === c) {
            anim = { fromDir: animFromDir, exitDir: animExitDir, progress: animProgress };
          }
          drawWater(ctx, px, py, CELL, cell.filled, anim);
        }
      }

      // Draw source if not yet in grid (before flow starts)
      if (!grid[sourceR][sourceC]) {
        drawSourceCell(ctx, sourceC * CELL, sourceR * CELL, CELL);
      }

      // Cursor highlight
      if (gameState === 'playing') {
        const pulse = Math.sin(performance.now() / 200) * 0.3 + 0.7;
        ctx.strokeStyle = CURSOR_COLOR;
        ctx.lineWidth = 2.5;
        ctx.shadowColor = CURSOR_COLOR;
        ctx.shadowBlur = 8 * pulse;
        ctx.globalAlpha = pulse;
        ctx.strokeRect(cursorC * CELL + 2, cursorR * CELL + 2, CELL - 4, CELL - 4);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;

        // Next piece preview ghost on cursor (if cell empty)
        if (queue.length > 0 && !grid[cursorR][cursorC] && !(cursorR === sourceR && cursorC === sourceC)) {
          ctx.globalAlpha = 0.25;
          drawPipeShape(ctx, cursorC * CELL, cursorR * CELL, CELL, queue[0]);
          ctx.globalAlpha = 1;
        }
      }

      // Status text at bottom of canvas
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (gameState === 'playing' && !flowStarted) {
        ctx.fillStyle = '#4dc';
        ctx.shadowColor = '#4dc';
        ctx.shadowBlur = 12;
        ctx.font = 'bold 15px Courier New';
        ctx.fillText('Water in ' + (flowCountdown + 1) + 's - place pipes!', W / 2, H - 12);
        ctx.shadowBlur = 0;
      } else if (gameState === 'playing' && flowStarted) {
        ctx.fillStyle = WATER_COLOR;
        ctx.shadowColor = WATER_GLOW;
        ctx.shadowBlur = 10;
        ctx.font = 'bold 14px Courier New';
        ctx.fillText('Pipes filled: ' + pipesUsed, W / 2, H - 12);
        ctx.shadowBlur = 0;
      }
    }

    function drawQueue() {
      const qw = queueCanvas.width;
      const qh = queueCanvas.height;
      qctx.fillStyle = '#16213e';
      qctx.fillRect(0, 0, qw, qh);

      const prevSize = 50;
      const gap = 6;

      for (let i = 0; i < queue.length; i++) {
        const px = (qw - prevSize) / 2;
        const py = i * (prevSize + gap) + gap;

        // Highlight first piece
        if (i === 0) {
          qctx.strokeStyle = '#4dc';
          qctx.lineWidth = 2;
          qctx.shadowColor = '#4dc';
          qctx.shadowBlur = 8;
          qctx.strokeRect(px - 3, py - 3, prevSize + 6, prevSize + 6);
          qctx.shadowBlur = 0;
        }

        drawPipeShape(qctx, px, py, prevSize, queue[i]);
      }
    }

    // ---- INPUT ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') start();
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowUp':    cursorR = Math.max(0, cursorR - 1); break;
          case 'ArrowDown':  cursorR = Math.min(ROWS - 1, cursorR + 1); break;
          case 'ArrowLeft':  cursorC = Math.max(0, cursorC - 1); break;
          case 'ArrowRight': cursorC = Math.min(COLS - 1, cursorC + 1); break;
          case ' ':          placePipe(cursorR, cursorC); break;
        }
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      const cx = (e.clientX - rect.left) * sx;
      const cy = (e.clientY - rect.top) * sy;
      const c = Math.floor(cx / CELL);
      const r = Math.floor(cy / CELL);

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing' && r >= 0 && r < ROWS && c >= 0 && c < COLS) {
        cursorR = r;
        cursorC = c;
        placePipe(r, c);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const sx = canvas.width / rect.width;
      const sy = canvas.height / rect.height;
      const cx = (e.clientX - rect.left) * sx;
      const cy = (e.clientY - rect.top) * sy;
      const c = Math.floor(cx / CELL);
      const r = Math.floor(cy / CELL);
      if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
        cursorR = r;
        cursorC = c;
      }
    });

    // Expose for debugging / ML
    window.gameData = {
      get grid() { return grid; },
      get queue() { return queue; },
      get flowHead() { return flowHead; },
      get pipesUsed() { return pipesUsed; }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Base Builder Blitz</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 10px;
      width: 600px;
    }
    .back { color: #e94; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238,153,68,0.4); }
    h1 { color: #e94; font-size: 1.4rem; text-shadow: 0 0 15px rgba(238,153,68,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
    }
    .score-bar span { color: #e94; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.75rem;
      color: #aaa;
    }
    .info-bar .you { color: #4af; }
    .info-bar .ai { color: #f66; }
    canvas {
      border: 2px solid #e94;
      box-shadow: 0 0 20px rgba(238,153,68,0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e94;
      text-align: center;
      pointer-events: none;
      background: rgba(26,26,46,0.88);
    }
    .overlay h2 { font-size: 1.6rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(238,153,68,0.5); }
    .overlay p { font-size: 0.85rem; color: #ccc; margin: 4px 0; }
    .overlay .keys { color: #e94; font-size: 0.8rem; margin-top: 12px; }
    .controls {
      width: 600px;
      margin-top: 8px;
      font-size: 0.7rem;
      color: #888;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BASE BUILDER BLITZ</h1>
  </div>
  <div class="score-bar">
    <div style="color:#4af">You: <span id="pRes">150</span>G | Base: <span id="pHP">100</span>HP</div>
    <div>Score: <span id="score" style="color:#e94">0</span> | <span id="timer" style="color:#e94">5:00</span></div>
    <div style="color:#f66">AI: <span id="aRes">150</span>G | Base: <span id="aHP">100</span>HP</div>
  </div>
  <div class="info-bar">
    <div>Wrk:<span class="you" id="pWork">2</span> Sol:<span class="you" id="pSol">0</span> Arc:<span class="you" id="pArc">0</span> Kni:<span class="you" id="pKni">0</span></div>
    <div>Wrk:<span class="ai" id="aWork">2</span> Sol:<span class="ai" id="aSol">0</span> Arc:<span class="ai" id="aArc">0</span> Kni:<span class="ai" id="aKni">0</span></div>
  </div>
  <div style="position:relative;display:inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BASE BUILDER BLITZ</h2>
      <p id="overlayText">Build, gather, attack - destroy the enemy base!</p>
      <div class="keys" id="overlayKeys">
        <p>Click to place buildings | 1-4: Select building type</p>
        <p>Q: Train Soldier | R: Train Archer | F: Train Knight</p>
        <p>WASD: Scroll camera | ESC: Cancel placement</p>
        <p style="margin-top:8px;color:#fff;">Click anywhere to start</p>
      </div>
    </div>
  </div>
  <div class="controls">
    [1] Barracks 80G | [2] Tower 60G | [3] Wall 30G | [4] Mine 50G || [Q] Soldier 40G | [R] Archer 50G | [F] Knight 80G || WASD: Camera
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;

    // UI elements
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const pResEl = document.getElementById('pRes');
    const pHPEl = document.getElementById('pHP');
    const aResEl = document.getElementById('aRes');
    const aHPEl = document.getElementById('aHP');
    const pWorkEl = document.getElementById('pWork');
    const pSolEl = document.getElementById('pSol');
    const pArcEl = document.getElementById('pArc');
    const pKniEl = document.getElementById('pKni');
    const aWorkEl = document.getElementById('aWork');
    const aSolEl = document.getElementById('aSol');
    const aArcEl = document.getElementById('aArc');
    const aKniEl = document.getElementById('aKni');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlayKeys = document.getElementById('overlayKeys');

    let gameState = 'waiting';
    let score = 0;

    // --- CONSTANTS ---
    const TILE = 20;
    const MAP_W = 60;
    const MAP_H = 20;
    const WORLD_W = MAP_W * TILE;
    const WORLD_H = MAP_H * TILE;
    const ROUND_TIME = 300;
    const GATHER_RATE = 1.2;
    const BASE_INCOME = 0.6;

    // Building definitions
    const BLDG = {
      base:     { w: 3, h: 3, hp: 100, cost: 0,  name: 'HQ' },
      barracks: { w: 2, h: 2, hp: 60,  cost: 80, name: 'Barracks' },
      tower:    { w: 1, h: 2, hp: 40,  cost: 60, name: 'Tower', range: 85, dmg: 7, fireRate: 1.2 },
      wall:     { w: 1, h: 1, hp: 100, cost: 30, name: 'Wall' },
      mine:     { w: 2, h: 1, hp: 30,  cost: 50, name: 'Mine' }
    };

    // Unit definitions
    const UDEF = {
      worker:  { hp: 20, spd: 35, atk: 3,  range: 14, atkSpd: 1.0, cost: 0,  r: 4 },
      soldier: { hp: 45, spd: 42, atk: 9,  range: 14, atkSpd: 0.8, cost: 40, r: 5 },
      archer:  { hp: 28, spd: 36, atk: 7,  range: 85, atkSpd: 1.2, cost: 50, r: 4 },
      knight:  { hp: 80, spd: 32, atk: 15, range: 16, atkSpd: 1.0, cost: 80, r: 6 }
    };

    // Player colors
    const P_COL = ['#4af', '#f66'];
    const P_GLOW = ['rgba(68,170,255,0.3)', 'rgba(255,102,102,0.3)'];
    const P_BG = ['rgba(68,170,255,0.04)', 'rgba(255,102,102,0.04)'];

    // --- STATE ---
    let camera = { x: 0, y: 0 };
    let keys = {};
    let mouse = { x: 0, y: 0 };
    let selectedBldg = null;
    let timeLeft = ROUND_TIME;
    let players, units, buildings, resources, particles;
    let grid; // MAP_W x MAP_H occupancy

    // === GRID ===
    function initGrid() {
      grid = Array.from({ length: MAP_W }, () => new Uint8Array(MAP_H));
    }
    function setGrid(tx, ty, tw, th, val) {
      for (let x = tx; x < tx + tw; x++)
        for (let y = ty; y < ty + th; y++)
          if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) grid[x][y] = val;
    }
    function gridFree(tx, ty, tw, th) {
      for (let x = tx; x < tx + tw; x++)
        for (let y = ty; y < ty + th; y++) {
          if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return false;
          if (grid[x][y]) return false;
        }
      return true;
    }

    // === FACTORIES ===
    function mkPlayer(id) {
      return { id, res: 150, score: 0, bBuilt: 0, uKilled: 0, resGathered: 0 };
    }

    function mkBuilding(type, tx, ty, owner) {
      const d = BLDG[type];
      setGrid(tx, ty, d.w, d.h, 1);
      return {
        type, tx, ty, owner,
        x: tx * TILE + d.w * TILE / 2,
        y: ty * TILE + d.h * TILE / 2,
        w: d.w * TILE, h: d.h * TILE,
        hp: d.hp, maxHp: d.hp,
        fireCd: 0, queue: [], trainT: 0
      };
    }

    function mkUnit(type, x, y, owner) {
      const d = UDEF[type];
      return {
        type, x, y, owner,
        hp: d.hp, maxHp: d.hp, spd: d.spd,
        atk: d.atk, range: d.range, atkSpd: d.atkSpd,
        r: d.r, atkCd: 0, target: null,
        gatherNode: null, carrying: 0,
        state: type === 'worker' ? 'gather' : 'attack'
      };
    }

    function mkResource(x, y, amt) {
      return { x, y, amount: amt, maxAmt: amt, r: 10 };
    }

    // === INIT ===
    function init() {
      gameState = 'waiting';
      score = 0;
      timeLeft = ROUND_TIME;
      camera = { x: 0, y: 0 };
      selectedBldg = null;
      units = []; buildings = []; resources = []; particles = [];
      aiBuildPhase = 0; aiTimer = 0; aiAttackCd = 0;
      initGrid();
      players = [mkPlayer(0), mkPlayer(1)];

      // Resource nodes
      const nodes = [
        [8,5],[7,14],[10,10],
        [25,4],[28,10],[25,16],[30,7],[32,13],
        [50,5],[51,14],[48,10]
      ];
      for (const [nx, ny] of nodes) {
        resources.push(mkResource(nx * TILE, ny * TILE, 250 + Math.random() * 200));
      }

      // Bases
      buildings.push(mkBuilding('base', 2, 8, 0));
      buildings.push(mkBuilding('base', 55, 8, 1));

      // Starting workers
      for (let i = 0; i < 2; i++) {
        units.push(mkUnit('worker', 5 * TILE + i * 15, 10 * TILE, 0));
        units.push(mkUnit('worker', 54 * TILE - i * 15, 10 * TILE, 1));
      }

      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BASE BUILDER BLITZ';
      overlayText.textContent = 'Build, gather, attack - destroy the enemy base!';
      overlayKeys.style.display = 'block';
      updateUI();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    function endGame(reason) {
      gameState = 'over';
      const p = players[0];
      score = Math.floor(p.bBuilt * 50 + p.uKilled * 30 + p.resGathered * 0.5);
      if (reason === 'win') score += 500;

      overlay.style.display = 'flex';
      overlayKeys.style.display = 'none';

      const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
      const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);

      if (reason === 'win') {
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = 'You destroyed the enemy base! Score: ' + score;
      } else if (reason === 'lose') {
        overlayTitle.textContent = 'DEFEATED';
        overlayText.textContent = 'Your base was destroyed. Score: ' + score;
      } else {
        const pHP = pBase ? pBase.hp : 0;
        const aHP = aBase ? aBase.hp : 0;
        if (pHP > aHP) {
          overlayTitle.textContent = 'VICTORY!';
          overlayText.textContent = 'You win on HP! (' + Math.ceil(pHP) + ' vs ' + Math.ceil(aHP) + ') Score: ' + (score + 200);
          score += 200;
        } else if (aHP > pHP) {
          overlayTitle.textContent = 'DEFEATED';
          overlayText.textContent = 'AI wins on HP. (' + Math.ceil(pHP) + ' vs ' + Math.ceil(aHP) + ') Score: ' + score;
        } else {
          overlayTitle.textContent = 'DRAW!';
          overlayText.textContent = 'Bases tied. Score: ' + score;
        }
      }
      scoreEl.textContent = score;
    }

    // === INPUT ===
    document.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      if (k === '1') selectedBldg = selectedBldg === 'barracks' ? null : 'barracks';
      if (k === '2') selectedBldg = selectedBldg === 'tower' ? null : 'tower';
      if (k === '3') selectedBldg = selectedBldg === 'wall' ? null : 'wall';
      if (k === '4') selectedBldg = selectedBldg === 'mine' ? null : 'mine';
      if (k === 'escape') selectedBldg = null;

      if (k === 'q') trainUnit('soldier', 0);
      if (k === 'r') trainUnit('archer', 0);
      if (k === 'f') trainUnit('knight', 0);
    });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', e => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      // Minimap click
      const mmX = W - 135, mmY = H - 58, mmW = 125, mmH = 42;
      if (mouse.x >= mmX && mouse.x <= mmX + mmW && mouse.y >= mmY && mouse.y <= mmY + mmH) {
        camera.x = Math.max(0, Math.min(WORLD_W - W, ((mouse.x - mmX) / mmW) * WORLD_W - W / 2));
        return;
      }

      // Build menu click
      if (mouse.y > H - 34) {
        const menuTypes = ['barracks', 'tower', 'wall', 'mine'];
        for (let i = 0; i < 4; i++) {
          if (mouse.x >= 10 + i * 70 && mouse.x < 10 + i * 70 + 65) {
            selectedBldg = selectedBldg === menuTypes[i] ? null : menuTypes[i];
            return;
          }
        }
        // Unit train buttons
        const unitTypes = ['soldier', 'archer', 'knight'];
        for (let i = 0; i < 3; i++) {
          if (mouse.x >= 305 + i * 55 && mouse.x < 305 + i * 55 + 50) {
            trainUnit(unitTypes[i], 0);
            return;
          }
        }
        return;
      }

      // Place building
      if (selectedBldg) {
        placeBuilding(selectedBldg, 0, mouse.x + camera.x, mouse.y + camera.y);
      }
    });

    canvas.addEventListener('contextmenu', e => { e.preventDefault(); selectedBldg = null; });

    // === PLACE BUILDING ===
    function placeBuilding(type, owner, wx, wy) {
      const d = BLDG[type];
      const p = players[owner];
      if (p.res < d.cost) return false;
      const tx = Math.floor(wx / TILE);
      const ty = Math.floor(wy / TILE);

      // Territory check: left half for player 0, right half for player 1
      const halfX = MAP_W / 2;
      if (owner === 0 && tx + d.w > halfX) return false;
      if (owner === 1 && tx < halfX) return false;

      if (!gridFree(tx, ty, d.w, d.h)) return false;

      p.res -= d.cost;
      buildings.push(mkBuilding(type, tx, ty, owner));
      p.bBuilt++;

      for (let i = 0; i < 8; i++) {
        particles.push({
          x: tx * TILE + d.w * TILE / 2,
          y: ty * TILE + d.h * TILE / 2,
          vx: (Math.random() - 0.5) * 60,
          vy: (Math.random() - 0.5) * 60,
          life: 0.5, color: '#e94'
        });
      }
      return true;
    }

    // === TRAIN UNIT ===
    function trainUnit(type, owner) {
      const d = UDEF[type];
      const p = players[owner];
      if (p.res < d.cost) return false;
      const barr = buildings.filter(b => b.type === 'barracks' && b.owner === owner && b.hp > 0);
      if (barr.length === 0) return false;
      barr.sort((a, b) => a.queue.length - b.queue.length);
      const bar = barr[0];
      if (bar.queue.length >= 3) return false;
      p.res -= d.cost;
      bar.queue.push(type);
      if (bar.queue.length === 1) bar.trainT = trainTime(type);
      return true;
    }

    function trainTime(t) {
      return { soldier: 3, archer: 4, knight: 5, worker: 4 }[t] || 3;
    }

    // === HELPERS ===
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    function moveToward(u, tx, ty, dt) {
      const dx = tx - u.x, dy = ty - u.y;
      const d = Math.hypot(dx, dy);
      if (d < 2) return;
      u.x += (dx / d) * u.spd * dt;
      u.y += (dy / d) * u.spd * dt;
      u.x = Math.max(u.r, Math.min(WORLD_W - u.r, u.x));
      u.y = Math.max(u.r, Math.min(WORLD_H - u.r, u.y));
    }

    function spawnDeath(x, y, owner) {
      const c = P_COL[owner];
      for (let i = 0; i < 6; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 80,
          vy: (Math.random() - 0.5) * 80,
          life: 0.6, color: c
        });
      }
    }

    // === UPDATE ===
    let lastTime = 0;

    function update(dt) {
      if (gameState !== 'playing') return;

      // Timer
      timeLeft -= dt;
      if (timeLeft <= 0) { timeLeft = 0; endGame('timeout'); return; }

      // Camera
      const cs = 250 * dt;
      if (keys['a']) camera.x -= cs;
      if (keys['d']) camera.x += cs;
      if (keys['w']) camera.y -= cs;
      if (keys['s']) camera.y += cs;
      camera.x = Math.max(0, Math.min(WORLD_W - W, camera.x));
      camera.y = Math.max(0, Math.min(WORLD_H - H, camera.y));

      // Passive + mine income
      for (const p of players) p.res += BASE_INCOME * dt;
      for (const b of buildings) {
        if (b.type === 'mine' && b.hp > 0) {
          players[b.owner].res += 1.8 * dt;
          players[b.owner].resGathered += 1.8 * dt;
        }
      }

      // Buildings: training + towers
      for (const b of buildings) {
        if (b.hp <= 0) continue;

        // Training
        if (b.type === 'barracks' && b.queue.length > 0) {
          b.trainT -= dt;
          if (b.trainT <= 0) {
            const utype = b.queue.shift();
            const sx = b.x + (b.owner === 0 ? b.w / 2 + 8 : -b.w / 2 - 8);
            const sy = b.y + (Math.random() - 0.5) * 20;
            units.push(mkUnit(utype, sx, sy, b.owner));
            if (b.queue.length > 0) b.trainT = trainTime(b.queue[0]);
          }
        }

        // Towers
        if (b.type === 'tower') {
          b.fireCd -= dt;
          if (b.fireCd <= 0) {
            let best = null, bestD = BLDG.tower.range;
            for (const u of units) {
              if (u.owner !== b.owner && u.hp > 0) {
                const d = dist(b, u);
                if (d < bestD) { best = u; bestD = d; }
              }
            }
            if (best) {
              best.hp -= BLDG.tower.dmg;
              b.fireCd = BLDG.tower.fireRate;
              particles.push({
                x: b.x, y: b.y - 8,
                vx: (best.x - b.x) * 3, vy: (best.y - b.y + 8) * 3,
                life: 0.25, color: P_COL[b.owner]
              });
              if (best.hp <= 0) {
                players[b.owner].uKilled++;
                spawnDeath(best.x, best.y, best.owner);
              }
            }
          }
        }
      }

      // Remove dead buildings
      for (let i = buildings.length - 1; i >= 0; i--) {
        const b = buildings[i];
        if (b.hp <= 0) {
          if (b.type === 'base') {
            endGame(b.owner === 0 ? 'lose' : 'win');
            return;
          }
          const d = BLDG[b.type];
          setGrid(b.tx, b.ty, d.w, d.h, 0);
          spawnDeath(b.x, b.y, b.owner);
          buildings.splice(i, 1);
        }
      }

      // Update units
      for (const u of units) {
        if (u.hp <= 0) continue;
        u.atkCd -= dt;
        if (u.state === 'gather') updateWorker(u, dt);
        else updateCombat(u, dt);
      }

      // Remove dead units
      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) {
          const dead = units[i];
          players[1 - dead.owner].uKilled++;
          spawnDeath(dead.x, dead.y, dead.owner);
          units.splice(i, 1);
        }
      }

      // Remove depleted resources
      resources = resources.filter(r => r.amount > 0);

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // AI
      updateAI(dt);
      updateUI();
    }

    // === WORKER ===
    function updateWorker(u, dt) {
      if (!u.gatherNode || u.gatherNode.amount <= 0) {
        let best = null, bestD = Infinity;
        for (const r of resources) {
          if (r.amount <= 0) continue;
          const d = dist(u, r);
          // Workers prefer nodes on their side
          const sidePenalty = (u.owner === 0 && r.x > WORLD_W * 0.6) ? 200 :
                              (u.owner === 1 && r.x < WORLD_W * 0.4) ? 200 : 0;
          if (d + sidePenalty < bestD) { best = r; bestD = d + sidePenalty; }
        }
        u.gatherNode = best;
        u.carrying = 0;
      }

      if (u.carrying >= 10) {
        // Return to base or mine
        const dropOff = buildings.find(b =>
          (b.type === 'base' || b.type === 'mine') && b.owner === u.owner && b.hp > 0
        );
        if (!dropOff) { u.state = 'attack'; return; }
        if (dist(u, dropOff) < 28) {
          players[u.owner].res += u.carrying;
          players[u.owner].resGathered += u.carrying;
          u.carrying = 0;
        } else {
          moveToward(u, dropOff.x, dropOff.y, dt);
        }
      } else if (u.gatherNode) {
        if (dist(u, u.gatherNode) < 16) {
          const g = GATHER_RATE * dt;
          const actual = Math.min(g, u.gatherNode.amount);
          u.gatherNode.amount -= actual;
          u.carrying += actual;
        } else {
          moveToward(u, u.gatherNode.x, u.gatherNode.y, dt);
        }
      }
    }

    // === COMBAT ===
    function updateCombat(u, dt) {
      let target = null, targetD = Infinity;

      // Prefer nearby enemy units first
      for (const e of units) {
        if (e.owner === u.owner || e.hp <= 0) continue;
        const d = dist(u, e);
        if (d < 250 && d < targetD) { target = e; targetD = d; }
      }

      // Then enemy buildings
      if (!target) {
        for (const b of buildings) {
          if (b.owner === u.owner || b.hp <= 0) continue;
          const d = dist(u, b);
          if (d < targetD) { target = b; targetD = d; }
        }
      }

      if (!target) return;

      if (targetD <= u.range) {
        if (u.atkCd <= 0) {
          target.hp -= u.atk;
          u.atkCd = u.atkSpd;
          particles.push({
            x: u.x, y: u.y,
            vx: (target.x - u.x) * 2, vy: (target.y - u.y) * 2,
            life: 0.15, color: P_COL[u.owner]
          });
        }
      } else {
        moveToward(u, target.x, target.y, dt);
      }
    }

    // === AI ===
    let aiTimer = 0, aiBuildPhase = 0, aiAttackCd = 0;

    function updateAI(dt) {
      aiTimer += dt;
      if (aiTimer < 0.8) return;
      aiTimer = 0;

      const ai = players[1];
      const cnt = (type) => buildings.filter(b => b.type === type && b.owner === 1 && b.hp > 0).length;
      const nBarracks = cnt('barracks');
      const nTower = cnt('tower');
      const nMine = cnt('mine');
      const nWall = cnt('wall');
      const combatUnits = units.filter(u => u.owner === 1 && u.type !== 'worker' && u.hp > 0);
      const enemyNear = units.filter(u => u.owner === 0 && u.type !== 'worker' && u.hp > 0 && u.x > WORLD_W * 0.55);
      const underAttack = enemyNear.length > 0;

      // === BUILD ORDER ===
      // Phase 0: Mine
      if (aiBuildPhase === 0) {
        if (nMine === 0 && ai.res >= BLDG.mine.cost) {
          if (tryAIBuild('mine', [[50,12],[48,14]])) aiBuildPhase = 1;
        } else if (nMine > 0) aiBuildPhase = 1;
      }
      // Phase 1: First barracks
      if (aiBuildPhase === 1) {
        if (nBarracks === 0 && ai.res >= BLDG.barracks.cost) {
          if (tryAIBuild('barracks', [[52,5],[53,12]])) aiBuildPhase = 2;
        } else if (nBarracks > 0) aiBuildPhase = 2;
      }
      // Phase 2: Tower
      if (aiBuildPhase === 2) {
        if (nTower === 0 && ai.res >= BLDG.tower.cost) {
          if (tryAIBuild('tower', [[50,9],[49,7],[49,12]])) aiBuildPhase = 3;
        } else if (nTower > 0) aiBuildPhase = 3;
      }
      // Phase 3: Second barracks
      if (aiBuildPhase === 3) {
        if (nBarracks < 2 && ai.res >= BLDG.barracks.cost) {
          if (tryAIBuild('barracks', [[52,13],[50,5],[54,5]])) aiBuildPhase = 4;
        } else if (nBarracks >= 2) aiBuildPhase = 4;
      }
      // Phase 4+: Expand
      if (aiBuildPhase >= 4) {
        if (nTower < 3 && ai.res >= BLDG.tower.cost + 30) {
          tryAIBuild('tower', [[48,6],[48,13],[46,9],[47,4],[47,15]]);
        }
        if (nWall < 6 && ai.res >= BLDG.wall.cost + 60) {
          tryAIBuild('wall', [[47,8],[47,9],[47,10],[47,11],[47,12],[47,7]]);
        }
        if (nMine < 2 && ai.res >= BLDG.mine.cost + 50) {
          tryAIBuild('mine', [[48,16],[52,16],[50,3]]);
        }
        if (nBarracks < 3 && ai.res >= BLDG.barracks.cost + 40 && timeLeft < 200) {
          tryAIBuild('barracks', [[50,15],[54,4],[50,2]]);
        }
      }

      // === TRAIN ===
      if (nBarracks > 0) {
        if (underAttack && ai.res >= UDEF.knight.cost) {
          trainUnit('knight', 1);
        } else if (ai.res >= UDEF.soldier.cost) {
          const r = Math.random();
          if (r < 0.35) trainUnit('soldier', 1);
          else if (r < 0.65 && ai.res >= UDEF.archer.cost) trainUnit('archer', 1);
          else if (ai.res >= UDEF.knight.cost) trainUnit('knight', 1);
          else trainUnit('soldier', 1);
        }
      }

      // === ATTACK WAVES ===
      aiAttackCd += 0.8;
      if (aiAttackCd > 15 && combatUnits.length >= 3) {
        aiAttackCd = 0;
        // Rally all idle combat units toward enemy side
        for (const u of combatUnits) {
          if (u.x > WORLD_W * 0.45) {
            u.x -= 10; // Nudge forward
          }
        }
      }
    }

    function tryAIBuild(type, spots) {
      const d = BLDG[type];
      for (const [tx, ty] of spots) {
        if (tx >= MAP_W / 2 && gridFree(tx, ty, d.w, d.h)) {
          const ai = players[1];
          if (ai.res >= d.cost) {
            ai.res -= d.cost;
            buildings.push(mkBuilding(type, tx, ty, 1));
            ai.bBuilt++;
            return true;
          }
        }
      }
      return false;
    }

    // === UI UPDATE ===
    function updateUI() {
      const p = players[0], a = players[1];
      pResEl.textContent = Math.floor(p.res);
      aResEl.textContent = Math.floor(a.res);

      const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
      const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);
      pHPEl.textContent = pBase ? Math.ceil(pBase.hp) : 0;
      aHPEl.textContent = aBase ? Math.ceil(aBase.hp) : 0;

      score = Math.floor(p.bBuilt * 50 + p.uKilled * 30 + p.resGathered * 0.5);
      scoreEl.textContent = score;

      const m = Math.floor(timeLeft / 60);
      const s = Math.floor(timeLeft % 60);
      timerEl.textContent = m + ':' + String(s).padStart(2, '0');

      const uc = (owner, type) => units.filter(u => u.owner === owner && u.type === type && u.hp > 0).length;
      pWorkEl.textContent = uc(0, 'worker');
      pSolEl.textContent = uc(0, 'soldier');
      pArcEl.textContent = uc(0, 'archer');
      pKniEl.textContent = uc(0, 'knight');
      aWorkEl.textContent = uc(1, 'worker');
      aSolEl.textContent = uc(1, 'soldier');
      aArcEl.textContent = uc(1, 'archer');
      aKniEl.textContent = uc(1, 'knight');
    }

    // === RENDER ===
    function render() {
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(-camera.x, -camera.y);

      // Grid
      ctx.strokeStyle = '#151530';
      ctx.lineWidth = 0.5;
      const startTX = Math.floor(camera.x / TILE);
      const endTX = Math.ceil((camera.x + W) / TILE);
      const startTY = Math.floor(camera.y / TILE);
      const endTY = Math.ceil((camera.y + H) / TILE);
      for (let x = startTX; x <= endTX; x++) {
        ctx.beginPath();
        ctx.moveTo(x * TILE, camera.y);
        ctx.lineTo(x * TILE, camera.y + H);
        ctx.stroke();
      }
      for (let y = startTY; y <= endTY; y++) {
        ctx.beginPath();
        ctx.moveTo(camera.x, y * TILE);
        ctx.lineTo(camera.x + W, y * TILE);
        ctx.stroke();
      }

      // Center divider
      ctx.strokeStyle = 'rgba(238,153,68,0.15)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(WORLD_W / 2, 0);
      ctx.lineTo(WORLD_W / 2, WORLD_H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Territory BG
      ctx.fillStyle = P_BG[0];
      ctx.fillRect(0, 0, WORLD_W / 2, WORLD_H);
      ctx.fillStyle = P_BG[1];
      ctx.fillRect(WORLD_W / 2, 0, WORLD_W / 2, WORLD_H);

      // Resources
      for (const r of resources) {
        const pct = r.amount / r.maxAmt;
        ctx.fillStyle = 'rgba(255,255,68,' + (0.08 + pct * 0.15) + ')';
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r + 4 + pct * 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'hsl(50,' + (40 + pct * 60) + '%,' + (30 + pct * 40) + '%)';
        ctx.beginPath();
        ctx.arc(r.x, r.y, 3 + r.r * pct, 0, Math.PI * 2);
        ctx.fill();
        // Crystal shape on top
        ctx.fillStyle = '#ff4';
        ctx.save();
        ctx.translate(r.x, r.y);
        ctx.beginPath();
        ctx.moveTo(0, -4 * pct - 2);
        ctx.lineTo(3, 0);
        ctx.lineTo(0, 4 * pct + 2);
        ctx.lineTo(-3, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Amount label
        ctx.fillStyle = '#cc4';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(Math.floor(r.amount), r.x, r.y - r.r - 4);
      }

      // Buildings
      for (const b of buildings) {
        if (b.hp <= 0) continue;
        const isP = b.owner === 0;
        const col = isP ? '#4af' : '#f66';
        const hpPct = b.hp / b.maxHp;

        // Glow
        ctx.shadowColor = col;
        ctx.shadowBlur = 6;
        ctx.fillStyle = col;
        ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);
        ctx.shadowBlur = 0;

        // Inner darker
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(b.x - b.w / 2 + 2, b.y - b.h / 2 + 2, b.w - 4, b.h - 4);

        // Border
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.strokeRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icons = { base: 'HQ', barracks: 'BK', tower: 'TW', wall: 'W', mine: '$' };
        ctx.fillText(icons[b.type], b.x, b.y);

        // HP bar
        if (hpPct < 1) {
          ctx.fillStyle = '#200';
          ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2 - 5, b.w, 3);
          ctx.fillStyle = hpPct > 0.5 ? '#0c0' : hpPct > 0.25 ? '#cc0' : '#c00';
          ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2 - 5, b.w * hpPct, 3);
        }

        // Train queue indicator
        if (b.type === 'barracks' && b.queue.length > 0) {
          const pct = 1 - b.trainT / trainTime(b.queue[0]);
          ctx.fillStyle = '#0c0';
          ctx.fillRect(b.x - b.w / 2, b.y + b.h / 2 + 1, b.w * pct, 2);
          ctx.fillStyle = '#ccc';
          ctx.font = '7px Courier New';
          ctx.fillText('[' + b.queue.length + ']', b.x, b.y + b.h / 2 + 9);
        }

        // Tower range
        if (b.type === 'tower') {
          ctx.strokeStyle = P_GLOW[b.owner];
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(b.x, b.y, BLDG.tower.range, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Units
      for (const u of units) {
        if (u.hp <= 0) continue;
        const isP = u.owner === 0;
        let col;
        switch (u.type) {
          case 'worker':  col = isP ? '#8cf' : '#fc8'; break;
          case 'soldier': col = isP ? '#4af' : '#f66'; break;
          case 'archer':  col = isP ? '#4f8' : '#f84'; break;
          case 'knight':  col = isP ? '#88f' : '#f44'; break;
        }

        ctx.shadowColor = col;
        ctx.shadowBlur = 3;
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(u.x, u.y, u.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Type letter
        ctx.fillStyle = '#000';
        ctx.font = 'bold 7px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText({ worker: 'w', soldier: 'S', archer: 'A', knight: 'K' }[u.type], u.x, u.y);

        // HP bar
        const hp = u.hp / u.maxHp;
        if (hp < 1) {
          ctx.fillStyle = '#200';
          ctx.fillRect(u.x - u.r, u.y - u.r - 4, u.r * 2, 2);
          ctx.fillStyle = hp > 0.5 ? '#0c0' : '#c00';
          ctx.fillRect(u.x - u.r, u.y - u.r - 4, u.r * 2 * hp, 2);
        }

        // Worker carry indicator
        if (u.type === 'worker' && u.carrying > 0) {
          ctx.fillStyle = '#ff4';
          ctx.font = '6px Courier New';
          ctx.textBaseline = 'bottom';
          ctx.fillText(Math.floor(u.carrying), u.x, u.y - u.r - 5);
        }
      }

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, Math.min(1, p.life * 2));
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // === HUD (screen space) ===

      // Placement ghost
      if (selectedBldg && gameState === 'playing') {
        const d = BLDG[selectedBldg];
        const wx = mouse.x + camera.x;
        const wy = mouse.y + camera.y;
        const tx = Math.floor(wx / TILE);
        const ty = Math.floor(wy / TILE);
        const ok = gridFree(tx, ty, d.w, d.h) && tx + d.w <= MAP_W / 2 && players[0].res >= d.cost;

        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = ok ? '#0f0' : '#f00';
        ctx.fillRect(tx * TILE, ty * TILE, d.w * TILE, d.h * TILE);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Bottom menu bar
      ctx.fillStyle = 'rgba(10,10,30,0.88)';
      ctx.fillRect(0, H - 34, W, 34);
      ctx.strokeStyle = '#e94';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, H - 34);
      ctx.lineTo(W, H - 34);
      ctx.stroke();

      // Building buttons
      const bMenu = [
        { key: '1', type: 'barracks', label: 'Barracks', cost: 80 },
        { key: '2', type: 'tower', label: 'Tower', cost: 60 },
        { key: '3', type: 'wall', label: 'Wall', cost: 30 },
        { key: '4', type: 'mine', label: 'Mine', cost: 50 }
      ];
      for (let i = 0; i < bMenu.length; i++) {
        const mi = bMenu[i];
        const bx = 10 + i * 70;
        const sel = selectedBldg === mi.type;
        const aff = players[0].res >= mi.cost;

        ctx.fillStyle = sel ? 'rgba(238,153,68,0.25)' : 'rgba(25,25,50,0.9)';
        ctx.fillRect(bx, H - 30, 64, 26);
        ctx.strokeStyle = sel ? '#e94' : (aff ? '#555' : '#333');
        ctx.lineWidth = sel ? 2 : 1;
        ctx.strokeRect(bx, H - 30, 64, 26);

        ctx.fillStyle = aff ? '#e94' : '#555';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('[' + mi.key + ']' + mi.label, bx + 2, H - 28);
        ctx.fillStyle = aff ? '#ff4' : '#444';
        ctx.fillText(mi.cost + 'G', bx + 2, H - 18);
      }

      // Unit train buttons
      const uMenu = [
        { key: 'Q', label: 'Soldier', cost: 40 },
        { key: 'R', label: 'Archer', cost: 50 },
        { key: 'F', label: 'Knight', cost: 80 }
      ];
      const hasBarr = buildings.some(b => b.type === 'barracks' && b.owner === 0 && b.hp > 0);
      for (let i = 0; i < uMenu.length; i++) {
        const mi = uMenu[i];
        const ux = 305 + i * 55;
        const aff = players[0].res >= mi.cost && hasBarr;

        ctx.fillStyle = 'rgba(25,25,50,0.9)';
        ctx.fillRect(ux, H - 30, 50, 26);
        ctx.strokeStyle = aff ? '#4af' : '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(ux, H - 30, 50, 26);

        ctx.fillStyle = aff ? '#4af' : '#444';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('[' + mi.key + ']' + mi.label.substring(0, 3), ux + 2, H - 28);
        ctx.fillStyle = aff ? '#ff4' : '#444';
        ctx.fillText(mi.cost + 'G', ux + 2, H - 18);
      }

      // Minimap
      renderMinimap();

      // Selected building label
      if (selectedBldg && gameState === 'playing') {
        ctx.fillStyle = 'rgba(10,10,30,0.8)';
        ctx.fillRect(0, 0, W, 18);
        ctx.fillStyle = '#e94';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Placing: ' + BLDG[selectedBldg].name + ' (' + BLDG[selectedBldg].cost + 'G) | Right-click/ESC to cancel', 8, 4);
      }
    }

    function renderMinimap() {
      const mx = W - 135, my = H - 80, mw = 125, mh = 42;
      ctx.fillStyle = 'rgba(10,10,30,0.92)';
      ctx.fillRect(mx - 2, my - 2, mw + 4, mh + 4);
      ctx.strokeStyle = '#e94';
      ctx.lineWidth = 1;
      ctx.strokeRect(mx - 2, my - 2, mw + 4, mh + 4);

      // Label
      ctx.fillStyle = '#e94';
      ctx.font = '7px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('MAP', mx, my - 11);

      const sx = mw / WORLD_W;
      const sy = mh / WORLD_H;

      // Territory
      ctx.fillStyle = 'rgba(68,170,255,0.08)';
      ctx.fillRect(mx, my, mw / 2, mh);
      ctx.fillStyle = 'rgba(255,102,102,0.08)';
      ctx.fillRect(mx + mw / 2, my, mw / 2, mh);

      // Resources
      for (const r of resources) {
        ctx.fillStyle = '#ff4';
        ctx.fillRect(mx + r.x * sx - 1, my + r.y * sy - 1, 2, 2);
      }

      // Buildings
      for (const b of buildings) {
        if (b.hp <= 0) continue;
        ctx.fillStyle = P_COL[b.owner];
        ctx.fillRect(
          mx + (b.x - b.w / 2) * sx,
          my + (b.y - b.h / 2) * sy,
          Math.max(2, b.w * sx),
          Math.max(2, b.h * sy)
        );
      }

      // Units (dots)
      for (const u of units) {
        if (u.hp <= 0) continue;
        ctx.fillStyle = u.owner === 0 ? '#8cf' : '#fc8';
        ctx.fillRect(mx + u.x * sx, my + u.y * sy, 1, 1);
      }

      // Viewport
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(mx + camera.x * sx, my + camera.y * sy, W * sx, H * sy);
    }

    // === GAME LOOP ===
    function gameLoop(ts) {
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;
      update(dt);
      render();
      updateGameData();
      requestAnimationFrame(gameLoop);
    }

    // === Expose for recorder ===
    window.gameData = {};
    function updateGameData() {
      const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
      const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);
      window.gameData = {
        gameState, score,
        timeLeft: Math.floor(timeLeft),
        playerRes: Math.floor(players[0] ? players[0].res : 0),
        aiRes: Math.floor(players[1] ? players[1].res : 0),
        playerBaseHP: pBase ? Math.ceil(pBase.hp) : 0,
        aiBaseHP: aBase ? Math.ceil(aBase.hp) : 0,
        playerUnits: units.filter(u => u.owner === 0 && u.hp > 0).length,
        aiUnits: units.filter(u => u.owner === 1 && u.hp > 0).length,
        playerBuildings: buildings.filter(b => b.owner === 0 && b.hp > 0).length,
        aiBuildings: buildings.filter(b => b.owner === 1 && b.hp > 0).length
      };
    }

    // === Init + Start ===
    init();
    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

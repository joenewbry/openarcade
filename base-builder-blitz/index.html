<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Base Builder Blitz</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 10px;
      width: 600px;
    }
    .back { color: #e94; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238,153,68,0.4); }
    h1 { color: #e94; font-size: 1.4rem; text-shadow: 0 0 15px rgba(238,153,68,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
    }
    .score-bar span { color: #e94; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.75rem;
      color: #aaa;
    }
    .info-bar .you { color: #4af; }
    .info-bar .ai { color: #f66; }
    canvas {
      border: 2px solid #e94;
      box-shadow: 0 0 20px rgba(238,153,68,0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e94;
      text-align: center;
      pointer-events: none;
      background: rgba(26,26,46,0.88);
    }
    .overlay h2 { font-size: 1.6rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(238,153,68,0.5); }
    .overlay p { font-size: 0.85rem; color: #ccc; margin: 4px 0; }
    .overlay .keys { color: #e94; font-size: 0.8rem; margin-top: 12px; }
    .controls {
      width: 600px;
      margin-top: 8px;
      font-size: 0.7rem;
      color: #888;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BASE BUILDER BLITZ</h1>
  </div>
  <div class="score-bar">
    <div class="you">You: <span id="pRes">100</span>G | Base: <span id="pHP">100</span>HP</div>
    <div>Score: <span id="score" style="color:#e94">0</span> | <span id="timer" style="color:#e94">5:00</span></div>
    <div class="ai">AI: <span id="aRes">100</span>G | Base: <span id="aHP">100</span>HP</div>
  </div>
  <div class="info-bar">
    <div>Workers:<span class="you" id="pWork">2</span> Sol:<span class="you" id="pSol">0</span> Arc:<span class="you" id="pArc">0</span> Kni:<span class="you" id="pKni">0</span></div>
    <div>Workers:<span class="ai" id="aWork">2</span> Sol:<span class="ai" id="aSol">0</span> Arc:<span class="ai" id="aArc">0</span> Kni:<span class="ai" id="aKni">0</span></div>
  </div>
  <div style="position:relative;display:inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BASE BUILDER BLITZ</h2>
      <p id="overlayText">Build, gather, attack - destroy the enemy base!</p>
      <div class="keys">
        <p>Click to place buildings | 1-4: Select building</p>
        <p>Q/W/E: Train Soldier/Archer/Knight</p>
        <p>WASD: Scroll camera</p>
        <p style="margin-top:8px;color:#fff;">Click anywhere to start</p>
      </div>
    </div>
  </div>
  <div class="controls">
    [1] Barracks 80G | [2] Tower 60G | [3] Wall 30G | [4] Mine 50G | [Q] Soldier 40G | [W] Archer 50G | [E] Knight 80G | WASD Camera
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;

    // UI elements
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const pResEl = document.getElementById('pRes');
    const pHPEl = document.getElementById('pHP');
    const aResEl = document.getElementById('aRes');
    const aHPEl = document.getElementById('aHP');
    const pWorkEl = document.getElementById('pWork');
    const pSolEl = document.getElementById('pSol');
    const pArcEl = document.getElementById('pArc');
    const pKniEl = document.getElementById('pKni');
    const aWorkEl = document.getElementById('aWork');
    const aSolEl = document.getElementById('aSol');
    const aArcEl = document.getElementById('aArc');
    const aKniEl = document.getElementById('aKni');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    // --- CONSTANTS ---
    const TILE = 20;
    const MAP_W = 60; // tiles
    const MAP_H = 20; // tiles
    const WORLD_W = MAP_W * TILE; // 1200
    const WORLD_H = MAP_H * TILE; // 400
    const ROUND_TIME = 300; // 5 minutes in seconds
    const GATHER_RATE = 0.8; // resources per second per worker at a node
    const BASE_INCOME = 0.5; // passive income per second

    // Building types
    const BLDG = {
      base:     { w:3, h:3, hp:100, cost:0,  color:'#4af', aColor:'#f66', name:'Base' },
      barracks: { w:2, h:2, hp:60,  cost:80, color:'#48f', aColor:'#f84', name:'Barracks' },
      tower:    { w:1, h:2, hp:40,  cost:60, color:'#88f', aColor:'#fa4', name:'Tower', range:80, dmg:8, fireRate:1.5 },
      wall:     { w:1, h:1, hp:80,  cost:30, color:'#aaf', aColor:'#fca', name:'Wall' },
      mine:     { w:2, h:1, hp:30,  cost:50, color:'#ff4', aColor:'#ff4', name:'Mine' }
    };

    // Unit types
    const UNIT = {
      worker:  { hp:20, spd:30, atk:2,  range:15,  atkSpd:1.0, cost:0,  r:4, name:'Worker' },
      soldier: { hp:40, spd:40, atk:8,  range:15,  atkSpd:0.8, cost:40, r:5, name:'Soldier' },
      archer:  { hp:25, spd:35, atk:6,  range:80,  atkSpd:1.2, cost:50, r:4, name:'Archer' },
      knight:  { hp:70, spd:30, atk:14, range:18,  atkSpd:1.0, cost:80, r:6, name:'Knight' }
    };

    // --- GAME STATE ---
    let camera = { x: 0, y: 0 };
    let keys = {};
    let mouse = { x: 0, y: 0, down: false };
    let selectedBldg = null; // 'barracks','tower','wall','mine'
    let timeLeft = ROUND_TIME;
    let players = [];
    let units = [];
    let buildings = [];
    let resources = []; // resource nodes on map
    let particles = [];
    let gridOccupied = []; // MAP_W x MAP_H boolean

    function initGrid() {
      gridOccupied = [];
      for (let x = 0; x < MAP_W; x++) {
        gridOccupied[x] = [];
        for (let y = 0; y < MAP_H; y++) {
          gridOccupied[x][y] = false;
        }
      }
    }

    function occupyGrid(tx, ty, tw, th) {
      for (let x = tx; x < tx + tw; x++)
        for (let y = ty; y < ty + th; y++)
          if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H)
            gridOccupied[x][y] = true;
    }

    function isGridFree(tx, ty, tw, th) {
      for (let x = tx; x < tx + tw; x++)
        for (let y = ty; y < ty + th; y++) {
          if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return false;
          if (gridOccupied[x][y]) return false;
        }
      return true;
    }

    function freeGrid(tx, ty, tw, th) {
      for (let x = tx; x < tx + tw; x++)
        for (let y = ty; y < ty + th; y++)
          if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H)
            gridOccupied[x][y] = false;
    }

    // --- PLAYER ---
    function makePlayer(id, side) {
      return {
        id, side,
        res: 150,
        score: 0,
        buildingsBuilt: 0,
        unitsKilled: 0,
        resGathered: 0
      };
    }

    // --- BUILDING ---
    function makeBuilding(type, tx, ty, owner) {
      const def = BLDG[type];
      const b = {
        type, tx, ty,
        x: tx * TILE + (def.w * TILE) / 2,
        y: ty * TILE + (def.h * TILE) / 2,
        w: def.w * TILE,
        h: def.h * TILE,
        hp: def.hp,
        maxHp: def.hp,
        owner,
        fireCooldown: 0,
        trainQueue: [],
        trainTimer: 0
      };
      occupyGrid(tx, ty, def.w, def.h);
      return b;
    }

    // --- UNIT ---
    function makeUnit(type, x, y, owner) {
      const def = UNIT[type];
      return {
        type, x, y, owner,
        hp: def.hp,
        maxHp: def.hp,
        spd: def.spd,
        atk: def.atk,
        range: def.range,
        atkSpd: def.atkSpd,
        r: def.r,
        atkCooldown: 0,
        target: null,
        gatherTarget: null,
        carrying: 0,
        state: type === 'worker' ? 'gather' : 'attack' // workers gather, combat units attack
      };
    }

    // --- RESOURCE NODE ---
    function makeResource(x, y, amount) {
      return { x, y, amount, maxAmount: amount, r: 10 };
    }

    // --- INIT ---
    function init() {
      gameState = 'waiting';
      score = 0;
      timeLeft = ROUND_TIME;
      camera = { x: 0, y: 0 };
      selectedBldg = null;
      units = [];
      buildings = [];
      resources = [];
      particles = [];
      initGrid();

      // Players
      players = [makePlayer(0, 'left'), makePlayer(1, 'right')];

      // Resource nodes - scattered across the map, more in the middle
      const nodePositions = [
        // Left side resources (close to player)
        { x: 8, y: 5 }, { x: 7, y: 14 }, { x: 10, y: 10 },
        // Center resources (contested)
        { x: 25, y: 4 }, { x: 28, y: 10 }, { x: 25, y: 16 },
        { x: 30, y: 7 }, { x: 32, y: 13 },
        // Right side resources (close to AI)
        { x: 50, y: 5 }, { x: 51, y: 14 }, { x: 48, y: 10 }
      ];
      for (const np of nodePositions) {
        resources.push(makeResource(np.x * TILE, np.y * TILE, 300 + Math.random() * 200));
      }

      // Player base (left side)
      const pBase = makeBuilding('base', 2, 8, 0);
      buildings.push(pBase);

      // AI base (right side)
      const aBase = makeBuilding('base', 55, 8, 1);
      buildings.push(aBase);

      // Starting workers for player
      for (let i = 0; i < 2; i++) {
        units.push(makeUnit('worker', 5 * TILE + i * 15, 10 * TILE, 0));
      }
      // Starting workers for AI
      for (let i = 0; i < 2; i++) {
        units.push(makeUnit('worker', 54 * TILE + i * 15, 10 * TILE, 1));
      }

      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BASE BUILDER BLITZ';
      overlayText.textContent = 'Build, gather, attack - destroy the enemy base!';
      document.querySelector('.overlay .keys').style.display = 'block';
      updateUI();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      camera.x = 0; // Player starts viewing left side
    }

    function endGame(reason) {
      gameState = 'over';
      // Calculate score
      const p = players[0];
      score = Math.floor(p.buildingsBuilt * 50 + p.unitsKilled * 30 + p.resGathered * 0.5);
      if (reason === 'win') score += 500;

      overlay.style.display = 'flex';
      const keysDiv = document.querySelector('.overlay .keys');
      if (keysDiv) keysDiv.style.display = 'none';
      if (reason === 'win') {
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = `You destroyed the enemy base! Score: ${score}`;
      } else if (reason === 'lose') {
        overlayTitle.textContent = 'DEFEATED';
        overlayText.textContent = `Your base was destroyed. Score: ${score}`;
      } else {
        overlayTitle.textContent = 'TIME UP!';
        // Compare remaining base HP
        const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
        const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);
        const pHP = pBase ? pBase.hp : 0;
        const aHP = aBase ? aBase.hp : 0;
        if (pHP > aHP) {
          overlayText.textContent = `You win on HP! (${pHP} vs ${aHP}) Score: ${score}`;
          score += 200;
        } else if (aHP > pHP) {
          overlayText.textContent = `AI wins on HP. (${pHP} vs ${aHP}) Score: ${score}`;
        } else {
          overlayText.textContent = `Draw! Score: ${score}`;
        }
      }
      scoreEl.textContent = score;
    }

    // --- INPUT ---
    document.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      // Building selection
      if (e.key === '1') selectedBldg = 'barracks';
      if (e.key === '2') selectedBldg = 'tower';
      if (e.key === '3') selectedBldg = 'wall';
      if (e.key === '4') selectedBldg = 'mine';
      if (e.key === 'Escape') selectedBldg = null;

      // Train units
      if (e.key === 'q' || e.key === 'Q') trainUnit('soldier', 0);
      if (e.key === 'w' && !e.ctrlKey) { /* handled by camera */ }
      if (e.key === 'e' || e.key === 'E') trainUnit('knight', 0);

      // Prevent scrolling
      if (['w','a','s','d','q','e','1','2','3','4'].includes(e.key.toLowerCase())) {
        // Allow w for camera too
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
      // W key released = train archer (on keyup to not conflict with camera)
    });

    // Separate W handler: train archer on press
    document.addEventListener('keypress', e => {
      if (gameState !== 'playing') return;
      if ((e.key === 'w' || e.key === 'W') && !e.ctrlKey) {
        trainUnit('archer', 0);
      }
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', e => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      const worldX = mouse.x + camera.x;
      const worldY = mouse.y + camera.y;

      // Check if clicking on minimap
      const mmX = W - 130, mmY = H - 55, mmW = 120, mmH = 40;
      if (mouse.x >= mmX && mouse.x <= mmX + mmW && mouse.y >= mmY && mouse.y <= mmY + mmH) {
        const ratio = WORLD_W / mmW;
        camera.x = Math.max(0, Math.min(WORLD_W - W, (mouse.x - mmX) * ratio - W / 2));
        return;
      }

      // Check if clicking build menu at bottom
      if (mouse.y > H - 32) {
        const menuItems = ['barracks','tower','wall','mine'];
        const menuX = 10;
        for (let i = 0; i < menuItems.length; i++) {
          if (mouse.x >= menuX + i * 70 && mouse.x < menuX + i * 70 + 65) {
            selectedBldg = (selectedBldg === menuItems[i]) ? null : menuItems[i];
            return;
          }
        }
        return;
      }

      if (selectedBldg) {
        placeBuildingPlayer(selectedBldg, worldX, worldY);
      }
    });

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      selectedBldg = null;
    });

    // --- PLACE BUILDING ---
    function placeBuildingPlayer(type, wx, wy) {
      const def = BLDG[type];
      const p = players[0];
      if (p.res < def.cost) return;

      const tx = Math.floor(wx / TILE);
      const ty = Math.floor(wy / TILE);

      // Must be on player's side (left half + a bit)
      if (tx > MAP_W / 2 - 2) return;
      if (!isGridFree(tx, ty, def.w, def.h)) return;

      p.res -= def.cost;
      const b = makeBuilding(type, tx, ty, 0);
      buildings.push(b);
      p.buildingsBuilt++;

      // Spawn particles
      for (let i = 0; i < 8; i++) {
        particles.push({
          x: b.x, y: b.y,
          vx: (Math.random() - 0.5) * 60,
          vy: (Math.random() - 0.5) * 60,
          life: 0.5,
          color: '#e94'
        });
      }
    }

    function placeBuildingAI(type, tx, ty) {
      const def = BLDG[type];
      const p = players[1];
      if (p.res < def.cost) return false;
      if (!isGridFree(tx, ty, def.w, def.h)) return false;

      p.res -= def.cost;
      const b = makeBuilding(type, tx, ty, 1);
      buildings.push(b);
      p.buildingsBuilt++;
      return true;
    }

    // --- TRAIN UNIT ---
    function trainUnit(type, owner) {
      const def = UNIT[type];
      const p = players[owner];
      if (p.res < def.cost) return;

      // Find a barracks
      const barracks = buildings.filter(b => b.type === 'barracks' && b.owner === owner && b.hp > 0);
      if (barracks.length === 0) return;

      // Use the barracks with shortest queue
      barracks.sort((a, b) => a.trainQueue.length - b.trainQueue.length);
      const bar = barracks[0];
      if (bar.trainQueue.length >= 3) return; // max queue

      p.res -= def.cost;
      bar.trainQueue.push(type);
      if (bar.trainQueue.length === 1) bar.trainTimer = getTrainTime(type);
    }

    function getTrainTime(type) {
      if (type === 'soldier') return 3;
      if (type === 'archer') return 4;
      if (type === 'knight') return 6;
      if (type === 'worker') return 4;
      return 3;
    }

    // --- DISTANCE ---
    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    // --- UPDATE ---
    let lastTime = 0;
    function update(dt) {
      if (gameState !== 'playing') return;

      // Timer
      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame('timeout');
        return;
      }

      // Camera movement
      const camSpd = 200 * dt;
      if (keys['a']) camera.x -= camSpd;
      if (keys['d']) camera.x += camSpd;
      camera.x = Math.max(0, Math.min(WORLD_W - W, camera.x));
      camera.y = 0; // Fixed Y

      // Passive income
      for (const p of players) {
        p.res += BASE_INCOME * dt;
      }

      // Mine income
      for (const b of buildings) {
        if (b.type === 'mine' && b.hp > 0) {
          players[b.owner].res += 1.5 * dt;
          players[b.owner].resGathered += 1.5 * dt;
        }
      }

      // Update buildings (training + towers)
      for (const b of buildings) {
        if (b.hp <= 0) continue;

        // Training
        if (b.type === 'barracks' && b.trainQueue.length > 0) {
          b.trainTimer -= dt;
          if (b.trainTimer <= 0) {
            const unitType = b.trainQueue.shift();
            const spawnX = b.x + (b.owner === 0 ? b.w / 2 + 10 : -b.w / 2 - 10);
            const spawnY = b.y + (Math.random() - 0.5) * 20;
            units.push(makeUnit(unitType, spawnX, spawnY, b.owner));
            if (b.trainQueue.length > 0) {
              b.trainTimer = getTrainTime(b.trainQueue[0]);
            }
          }
        }

        // Tower firing
        if (b.type === 'tower') {
          b.fireCooldown -= dt;
          if (b.fireCooldown <= 0) {
            // Find nearest enemy unit or building
            let closest = null, closestDist = BLDG.tower.range;
            for (const u of units) {
              if (u.owner !== b.owner && u.hp > 0) {
                const d = dist(b, u);
                if (d < closestDist) { closest = u; closestDist = d; }
              }
            }
            if (closest) {
              closest.hp -= BLDG.tower.dmg;
              b.fireCooldown = BLDG.tower.fireRate;
              // Projectile particle
              particles.push({
                x: b.x, y: b.y - 10,
                vx: (closest.x - b.x) * 3,
                vy: (closest.y - b.y + 10) * 3,
                life: 0.3,
                color: b.owner === 0 ? '#4af' : '#f66'
              });
              if (closest.hp <= 0) {
                players[b.owner].unitsKilled++;
                spawnDeathParticles(closest.x, closest.y, closest.owner);
              }
            }
          }
        }
      }

      // Remove dead buildings
      for (let i = buildings.length - 1; i >= 0; i--) {
        const b = buildings[i];
        if (b.hp <= 0) {
          // Check for base destruction
          if (b.type === 'base') {
            if (b.owner === 0) endGame('lose');
            else endGame('win');
            return;
          }
          const def = BLDG[b.type];
          freeGrid(b.tx, b.ty, def.w, def.h);
          spawnDeathParticles(b.x, b.y, b.owner);
          buildings.splice(i, 1);
        }
      }

      // Update units
      for (const u of units) {
        if (u.hp <= 0) continue;
        u.atkCooldown -= dt;

        if (u.state === 'gather') {
          updateWorker(u, dt);
        } else {
          updateCombatUnit(u, dt);
        }
      }

      // Remove dead units
      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) {
          const dead = units[i];
          const killer = dead.owner === 0 ? 1 : 0;
          players[killer].unitsKilled++;
          spawnDeathParticles(dead.x, dead.y, dead.owner);
          units.splice(i, 1);
        }
      }

      // Remove depleted resources
      resources = resources.filter(r => r.amount > 0);

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // AI logic
      updateAI(dt);

      updateUI();
    }

    // --- WORKER LOGIC ---
    function updateWorker(u, dt) {
      // Find nearest resource node
      if (!u.gatherTarget || u.gatherTarget.amount <= 0) {
        let best = null, bestDist = Infinity;
        for (const r of resources) {
          if (r.amount <= 0) continue;
          const d = dist(u, r);
          if (d < bestDist) { best = r; bestDist = d; }
        }
        u.gatherTarget = best;
        u.carrying = 0;
      }

      if (u.carrying >= 10) {
        // Return to base
        const base = buildings.find(b => b.type === 'base' && b.owner === u.owner && b.hp > 0);
        if (!base) { u.state = 'attack'; return; }
        const d = dist(u, base);
        if (d < 30) {
          players[u.owner].res += u.carrying;
          players[u.owner].resGathered += u.carrying;
          u.carrying = 0;
        } else {
          moveToward(u, base.x, base.y, dt);
        }
      } else if (u.gatherTarget) {
        const d = dist(u, u.gatherTarget);
        if (d < 18) {
          // Gather
          const gatherAmt = GATHER_RATE * dt;
          const actual = Math.min(gatherAmt, u.gatherTarget.amount);
          u.gatherTarget.amount -= actual;
          u.carrying += actual;
        } else {
          moveToward(u, u.gatherTarget.x, u.gatherTarget.y, dt);
        }
      }
    }

    // --- COMBAT UNIT LOGIC ---
    function updateCombatUnit(u, dt) {
      // Find target: nearest enemy unit or building
      let target = null, targetDist = Infinity;

      // Prefer nearby enemy units
      for (const e of units) {
        if (e.owner === u.owner || e.hp <= 0) continue;
        const d = dist(u, e);
        if (d < targetDist) { target = e; targetDist = d; }
      }

      // If no units nearby, target buildings
      if (!target || targetDist > 200) {
        for (const b of buildings) {
          if (b.owner === u.owner || b.hp <= 0) continue;
          const d = dist(u, b);
          if (d < targetDist) { target = b; targetDist = d; }
        }
      }

      if (!target) return;

      if (targetDist <= u.range) {
        // Attack
        if (u.atkCooldown <= 0) {
          target.hp -= u.atk;
          u.atkCooldown = u.atkSpd;
          // Attack particle
          particles.push({
            x: u.x, y: u.y,
            vx: (target.x - u.x) * 2,
            vy: (target.y - u.y) * 2,
            life: 0.2,
            color: u.owner === 0 ? '#4af' : '#f66'
          });
        }
      } else {
        moveToward(u, target.x, target.y, dt);
      }
    }

    function moveToward(u, tx, ty, dt) {
      const dx = tx - u.x;
      const dy = ty - u.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 1) return;
      u.x += (dx / d) * u.spd * dt;
      u.y += (dy / d) * u.spd * dt;
      // Clamp to world
      u.x = Math.max(0, Math.min(WORLD_W, u.x));
      u.y = Math.max(0, Math.min(WORLD_H, u.y));
    }

    function spawnDeathParticles(x, y, owner) {
      const col = owner === 0 ? '#4af' : '#f66';
      for (let i = 0; i < 6; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 80,
          vy: (Math.random() - 0.5) * 80,
          life: 0.6,
          color: col
        });
      }
    }

    // --- AI LOGIC ---
    let aiTimer = 0;
    let aiBuildPhase = 0; // tracks build order progress
    let aiAttackWave = 0;

    function updateAI(dt) {
      aiTimer += dt;
      if (aiTimer < 1.0) return; // AI thinks every second
      aiTimer = 0;

      const ai = players[1];
      const aiBarracks = buildings.filter(b => b.type === 'barracks' && b.owner === 1 && b.hp > 0);
      const aiTowers = buildings.filter(b => b.type === 'tower' && b.owner === 1 && b.hp > 0);
      const aiMines = buildings.filter(b => b.type === 'mine' && b.owner === 1 && b.hp > 0);
      const aiWalls = buildings.filter(b => b.type === 'wall' && b.owner === 1 && b.hp > 0);
      const aiCombatUnits = units.filter(u => u.owner === 1 && u.type !== 'worker' && u.hp > 0);
      const aiWorkers = units.filter(u => u.owner === 1 && u.type === 'worker' && u.hp > 0);

      // Detect enemy threat
      const enemyNearBase = units.filter(u => u.owner === 0 && u.hp > 0 && u.x > MAP_W * TILE * 0.6);
      const underAttack = enemyNearBase.length > 0;

      // === BUILD ORDER ===
      // Phase 0: Mine first for economy
      if (aiBuildPhase === 0 && aiMines.length === 0 && ai.res >= BLDG.mine.cost) {
        if (placeBuildingAI('mine', 50, 12)) aiBuildPhase = 1;
      }
      // Phase 1: First barracks
      if (aiBuildPhase <= 1 && aiBarracks.length === 0 && ai.res >= BLDG.barracks.cost) {
        if (placeBuildingAI('barracks', 52, 5)) aiBuildPhase = 2;
      }
      // Phase 2: Defense tower
      if (aiBuildPhase <= 2 && aiTowers.length === 0 && ai.res >= BLDG.tower.cost) {
        if (placeBuildingAI('tower', 50, 9)) aiBuildPhase = 3;
      }
      // Phase 3: Second barracks
      if (aiBuildPhase <= 3 && aiBarracks.length < 2 && ai.res >= BLDG.barracks.cost) {
        if (placeBuildingAI('barracks', 52, 13)) aiBuildPhase = 4;
      }
      // Phase 4: More towers + walls
      if (aiBuildPhase >= 4) {
        if (aiTowers.length < 3 && ai.res >= BLDG.tower.cost + 40) {
          const towerSpots = [{x:48,y:6},{x:48,y:13},{x:46,y:9}];
          for (const s of towerSpots) {
            if (isGridFree(s.x, s.y, 1, 2)) {
              placeBuildingAI('tower', s.x, s.y);
              break;
            }
          }
        }
        if (aiWalls.length < 5 && ai.res >= BLDG.wall.cost + 80) {
          const wallSpots = [{x:47,y:8},{x:47,y:9},{x:47,y:10},{x:47,y:11},{x:47,y:12}];
          for (const s of wallSpots) {
            if (isGridFree(s.x, s.y, 1, 1)) {
              placeBuildingAI('wall', s.x, s.y);
              break;
            }
          }
        }
        // Extra mine
        if (aiMines.length < 2 && ai.res >= BLDG.mine.cost + 60) {
          const mineSpots = [{x:48,y:15},{x:52,y:15}];
          for (const s of mineSpots) {
            if (isGridFree(s.x, s.y, 2, 1)) {
              placeBuildingAI('mine', s.x, s.y);
              break;
            }
          }
        }
        // Third barracks late game
        if (aiBarracks.length < 3 && ai.res >= BLDG.barracks.cost + 60 && timeLeft < 180) {
          const spots = [{x:50,y:15},{x:54,y:5}];
          for (const s of spots) {
            if (isGridFree(s.x, s.y, 2, 2)) {
              placeBuildingAI('barracks', s.x, s.y);
              break;
            }
          }
        }
      }

      // === TRAIN UNITS ===
      if (aiBarracks.length > 0) {
        // Reactive: if under attack, train knights
        if (underAttack && ai.res >= UNIT.knight.cost) {
          trainUnit('knight', 1);
        }
        // Normal production mix
        else if (ai.res >= UNIT.soldier.cost) {
          const roll = Math.random();
          if (roll < 0.4 && ai.res >= UNIT.soldier.cost) trainUnit('soldier', 1);
          else if (roll < 0.7 && ai.res >= UNIT.archer.cost) trainUnit('archer', 1);
          else if (ai.res >= UNIT.knight.cost) trainUnit('knight', 1);
          else if (ai.res >= UNIT.soldier.cost) trainUnit('soldier', 1);
        }
      }

      // === SEND ATTACK WAVES ===
      // When we have enough combat units, send them toward enemy
      // (units auto-attack, but we can "rally" idle ones toward enemy base)
      if (aiCombatUnits.length >= 4 + aiAttackWave * 2) {
        aiAttackWave++;
        // All combat units push toward enemy base
        for (const u of aiCombatUnits) {
          if (u.x > MAP_W * TILE * 0.4) {
            // Give them a nudge toward enemy base area
            u.x -= 5;
          }
        }
      }
    }

    // --- UPDATE UI ---
    function updateUI() {
      const p = players[0], a = players[1];
      pResEl.textContent = Math.floor(p.res);
      aResEl.textContent = Math.floor(a.res);

      const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
      const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);
      pHPEl.textContent = pBase ? Math.ceil(pBase.hp) : 0;
      aHPEl.textContent = aBase ? Math.ceil(aBase.hp) : 0;

      score = Math.floor(p.buildingsBuilt * 50 + p.unitsKilled * 30 + p.resGathered * 0.5);
      scoreEl.textContent = score;

      const mins = Math.floor(timeLeft / 60);
      const secs = Math.floor(timeLeft % 60);
      timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

      // Unit counts
      const pw = units.filter(u => u.owner === 0 && u.type === 'worker' && u.hp > 0).length;
      const ps = units.filter(u => u.owner === 0 && u.type === 'soldier' && u.hp > 0).length;
      const pa = units.filter(u => u.owner === 0 && u.type === 'archer' && u.hp > 0).length;
      const pk = units.filter(u => u.owner === 0 && u.type === 'knight' && u.hp > 0).length;
      pWorkEl.textContent = pw;
      pSolEl.textContent = ps;
      pArcEl.textContent = pa;
      pKniEl.textContent = pk;

      const aw = units.filter(u => u.owner === 1 && u.type === 'worker' && u.hp > 0).length;
      const as = units.filter(u => u.owner === 1 && u.type === 'soldier' && u.hp > 0).length;
      const aa = units.filter(u => u.owner === 1 && u.type === 'archer' && u.hp > 0).length;
      const ak = units.filter(u => u.owner === 1 && u.type === 'knight' && u.hp > 0).length;
      aWorkEl.textContent = aw;
      aSolEl.textContent = as;
      aArcEl.textContent = aa;
      aKniEl.textContent = ak;
    }

    // --- RENDER ---
    function render() {
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(-camera.x, -camera.y);

      // Grid lines
      ctx.strokeStyle = '#151530';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= WORLD_W; x += TILE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, WORLD_H);
        ctx.stroke();
      }
      for (let y = 0; y <= WORLD_H; y += TILE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(WORLD_W, y);
        ctx.stroke();
      }

      // Center divider
      ctx.strokeStyle = 'rgba(238,153,68,0.15)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(WORLD_W / 2, 0);
      ctx.lineTo(WORLD_W / 2, WORLD_H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Territory shading
      ctx.fillStyle = 'rgba(68,170,255,0.03)';
      ctx.fillRect(0, 0, WORLD_W / 2, WORLD_H);
      ctx.fillStyle = 'rgba(255,102,102,0.03)';
      ctx.fillRect(WORLD_W / 2, 0, WORLD_W / 2, WORLD_H);

      // Resource nodes
      for (const r of resources) {
        const pct = r.amount / r.maxAmount;
        const glow = 4 + pct * 6;
        ctx.fillStyle = `rgba(255,255,68,${0.1 + pct * 0.2})`;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r + glow, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgb(${180 + pct * 75},${180 + pct * 75},${40})`;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r * pct + 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ff4';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(Math.floor(r.amount), r.x, r.y - r.r - 3);
      }

      // Buildings
      for (const b of buildings) {
        const def = BLDG[b.type];
        const col = b.owner === 0 ? def.color : def.aColor;
        const hpPct = b.hp / b.maxHp;

        // Building shadow/glow
        ctx.shadowColor = col;
        ctx.shadowBlur = 8;

        // Main body
        ctx.fillStyle = col;
        ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2, b.w, b.h);

        // Darker inner
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(b.x - b.w / 2 + 2, b.y - b.h / 2 + 2, b.w - 4, b.h - 4);

        // Type icon / letter
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icons = { base: 'HQ', barracks: 'BK', tower: 'TW', wall: 'W', mine: 'M$' };
        ctx.fillText(icons[b.type], b.x, b.y);

        // HP bar
        if (hpPct < 1) {
          ctx.fillStyle = '#300';
          ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2 - 5, b.w, 3);
          ctx.fillStyle = hpPct > 0.5 ? '#0f0' : hpPct > 0.25 ? '#ff0' : '#f00';
          ctx.fillRect(b.x - b.w / 2, b.y - b.h / 2 - 5, b.w * hpPct, 3);
        }

        // Training indicator
        if (b.type === 'barracks' && b.trainQueue.length > 0) {
          ctx.fillStyle = '#fff';
          ctx.font = '7px Courier New';
          ctx.fillText(`[${b.trainQueue.length}]`, b.x, b.y + b.h / 2 + 7);
          // Progress bar
          const trainDef = getTrainTime(b.trainQueue[0]);
          const pct = 1 - (b.trainTimer / trainDef);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(b.x - b.w / 2, b.y + b.h / 2 + 1, b.w * pct, 2);
        }

        // Tower range indicator
        if (b.type === 'tower') {
          ctx.strokeStyle = `rgba(${b.owner === 0 ? '68,170,255' : '255,102,102'},0.15)`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(b.x, b.y, BLDG.tower.range, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Units
      for (const u of units) {
        if (u.hp <= 0) continue;
        const isPlayer = u.owner === 0;
        let col;
        switch (u.type) {
          case 'worker': col = isPlayer ? '#8cf' : '#fc8'; break;
          case 'soldier': col = isPlayer ? '#4af' : '#f66'; break;
          case 'archer': col = isPlayer ? '#4f8' : '#f84'; break;
          case 'knight': col = isPlayer ? '#88f' : '#f44'; break;
        }

        // Glow
        ctx.shadowColor = col;
        ctx.shadowBlur = 4;

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(u.x, u.y, u.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Unit type letter
        ctx.fillStyle = '#000';
        ctx.font = 'bold 7px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const letters = { worker: 'w', soldier: 'S', archer: 'A', knight: 'K' };
        ctx.fillText(letters[u.type], u.x, u.y);

        // HP bar for damaged units
        const hpPct = u.hp / u.maxHp;
        if (hpPct < 1) {
          ctx.fillStyle = '#300';
          ctx.fillRect(u.x - u.r, u.y - u.r - 4, u.r * 2, 2);
          ctx.fillStyle = hpPct > 0.5 ? '#0f0' : '#f00';
          ctx.fillRect(u.x - u.r, u.y - u.r - 4, u.r * 2 * hpPct, 2);
        }

        // Carrying indicator for workers
        if (u.type === 'worker' && u.carrying > 0) {
          ctx.fillStyle = '#ff4';
          ctx.font = '6px Courier New';
          ctx.fillText(Math.floor(u.carrying), u.x, u.y - u.r - 6);
        }
      }

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life * 2);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // --- HUD OVERLAY (screen space) ---

      // Building placement preview
      if (selectedBldg && gameState === 'playing') {
        const def = BLDG[selectedBldg];
        const worldX = mouse.x + camera.x;
        const worldY = mouse.y + camera.y;
        const tx = Math.floor(worldX / TILE);
        const ty = Math.floor(worldY / TILE);
        const canPlace = isGridFree(tx, ty, def.w, def.h) && tx <= MAP_W / 2 - 2 && players[0].res >= def.cost;

        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = canPlace ? '#0f0' : '#f00';
        ctx.fillRect(tx * TILE, ty * TILE, def.w * TILE, def.h * TILE);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Build menu bar at bottom
      ctx.fillStyle = 'rgba(10,10,30,0.85)';
      ctx.fillRect(0, H - 32, W, 32);
      ctx.strokeStyle = '#e94';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, H - 32);
      ctx.lineTo(W, H - 32);
      ctx.stroke();

      const menuItems = [
        { key: '1', type: 'barracks', name: 'Barracks', cost: 80 },
        { key: '2', type: 'tower', name: 'Tower', cost: 60 },
        { key: '3', type: 'wall', name: 'Wall', cost: 30 },
        { key: '4', type: 'mine', name: 'Mine', cost: 50 }
      ];
      const menuX = 10;
      for (let i = 0; i < menuItems.length; i++) {
        const mi = menuItems[i];
        const x = menuX + i * 70;
        const selected = selectedBldg === mi.type;
        const canAfford = players[0].res >= mi.cost;

        ctx.fillStyle = selected ? 'rgba(238,153,68,0.3)' : 'rgba(30,30,60,0.8)';
        ctx.fillRect(x, H - 28, 62, 24);
        ctx.strokeStyle = selected ? '#e94' : (canAfford ? '#666' : '#333');
        ctx.lineWidth = selected ? 2 : 1;
        ctx.strokeRect(x, H - 28, 62, 24);

        ctx.fillStyle = canAfford ? '#e94' : '#666';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`[${mi.key}]${mi.name}`, x + 3, H - 19);
        ctx.fillStyle = canAfford ? '#ff4' : '#555';
        ctx.fillText(`${mi.cost}G`, x + 3, H - 10);
      }

      // Unit train shortcuts
      const unitItems = [
        { key: 'Q', name: 'Sol', cost: 40 },
        { key: 'W', name: 'Arc', cost: 50 },
        { key: 'E', name: 'Kni', cost: 80 }
      ];
      const ux = 300;
      for (let i = 0; i < unitItems.length; i++) {
        const ui = unitItems[i];
        const x = ux + i * 55;
        const canAfford = players[0].res >= ui.cost;
        const hasBarracks = buildings.some(b => b.type === 'barracks' && b.owner === 0 && b.hp > 0);

        ctx.fillStyle = 'rgba(30,30,60,0.8)';
        ctx.fillRect(x, H - 28, 50, 24);
        ctx.strokeStyle = (canAfford && hasBarracks) ? '#4af' : '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, H - 28, 50, 24);

        ctx.fillStyle = (canAfford && hasBarracks) ? '#4af' : '#555';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`[${ui.key}]${ui.name}`, x + 3, H - 19);
        ctx.fillStyle = (canAfford && hasBarracks) ? '#ff4' : '#555';
        ctx.fillText(`${ui.cost}G`, x + 3, H - 10);
      }

      // Minimap
      const mmX = W - 135, mmY = H - 58, mmW = 125, mmH = 42;
      ctx.fillStyle = 'rgba(10,10,30,0.9)';
      ctx.fillRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);
      ctx.strokeStyle = '#e94';
      ctx.lineWidth = 1;
      ctx.strokeRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);

      const scaleX = mmW / WORLD_W;
      const scaleY = mmH / WORLD_H;

      // Minimap territory
      ctx.fillStyle = 'rgba(68,170,255,0.1)';
      ctx.fillRect(mmX, mmY, mmW / 2, mmH);
      ctx.fillStyle = 'rgba(255,102,102,0.1)';
      ctx.fillRect(mmX + mmW / 2, mmY, mmW / 2, mmH);

      // Minimap resources
      for (const r of resources) {
        ctx.fillStyle = '#ff4';
        ctx.fillRect(mmX + r.x * scaleX - 1, mmY + r.y * scaleY - 1, 2, 2);
      }

      // Minimap buildings
      for (const b of buildings) {
        if (b.hp <= 0) continue;
        ctx.fillStyle = b.owner === 0 ? '#4af' : '#f66';
        const bw = Math.max(2, b.w * scaleX);
        const bh = Math.max(2, b.h * scaleY);
        ctx.fillRect(mmX + (b.x - b.w / 2) * scaleX, mmY + (b.y - b.h / 2) * scaleY, bw, bh);
      }

      // Minimap units
      for (const u of units) {
        if (u.hp <= 0) continue;
        ctx.fillStyle = u.owner === 0 ? '#8cf' : '#fc8';
        ctx.fillRect(mmX + u.x * scaleX, mmY + u.y * scaleY, 1, 1);
      }

      // Minimap viewport
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(
        mmX + camera.x * scaleX,
        mmY + camera.y * scaleY,
        W * scaleX,
        H * scaleY
      );

      // Selected building label
      if (selectedBldg) {
        ctx.fillStyle = '#e94';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`Placing: ${BLDG[selectedBldg].name} (Right-click/ESC to cancel)`, 10, 15);
      }
    }

    // --- GAME LOOP ---
    function gameLoop(ts) {
      const dt = Math.min(0.05, (ts - lastTime) / 1000);
      lastTime = ts;

      update(dt);
      render();
      updateGameData();

      requestAnimationFrame(gameLoop);
    }

    // --- Expose game data for recorder ---
    window.gameData = {};
    function updateGameData() {
      const pBase = buildings.find(b => b.type === 'base' && b.owner === 0);
      const aBase = buildings.find(b => b.type === 'base' && b.owner === 1);
      window.gameData = {
        gameState,
        score,
        timeLeft: Math.floor(timeLeft),
        playerRes: Math.floor(players[0] ? players[0].res : 0),
        aiRes: Math.floor(players[1] ? players[1].res : 0),
        playerBaseHP: pBase ? Math.ceil(pBase.hp) : 0,
        aiBaseHP: aBase ? Math.ceil(aBase.hp) : 0,
        playerUnits: units.filter(u => u.owner === 0 && u.hp > 0).length,
        aiUnits: units.filter(u => u.owner === 1 && u.hp > 0).length,
        playerBuildings: buildings.filter(b => b.owner === 0 && b.hp > 0).length,
        aiBuildings: buildings.filter(b => b.owner === 1 && b.hp > 0).length
      };
    }

    // --- Initialize ---
    init();
    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

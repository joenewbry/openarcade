<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Settlers Online</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
      width: 600px;
    }
    .back { color: #e84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 136, 68, 0.4); }
    h1 { color: #e84; font-size: 1.8rem; text-shadow: 0 0 15px rgba(238, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 1rem;
    }
    .score-bar .player-vp { color: #4af; }
    .score-bar .turn-info { color: #e84; }
    canvas#game {
      border: 2px solid #e84;
      box-shadow: 0 0 20px rgba(238, 136, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
      z-index: 10;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(238,136,68,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .big { font-size: 1.4rem; color: #e84; margin-top: 10px; }
    .controls {
      width: 600px;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #888;
    }
    .controls span { color: #e84; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&#9664; back</a>
    <h1>Settlers Online</h1>
  </div>
  <div class="score-bar">
    <span class="player-vp">VP: 0</span>
    <span class="turn-info">Setup Phase</span>
  </div>
  <canvas id="game" width="600" height="550"></canvas>
  <div class="controls">
    <span>Click to build &amp; trade</span>
    <span>First to 10 VP wins</span>
  </div>

  <script>
  // ====== GLOBALS ======
  let gameState = 'title';
  let score = 0;

  const C = document.getElementById('game');
  const ctx = C.getContext('2d');
  const W = 600, H = 550;
  const vpSpan = document.querySelector('.player-vp');
  const turnSpan = document.querySelector('.turn-info');

  // ====== CONSTANTS ======
  const TERRAINS = ['forest','hills','mountain','field','pasture','desert'];
  const RES_NAMES = ['wood','brick','ore','grain','sheep'];
  const RES_COLORS = {wood:'#2d5a1e',brick:'#a63c1e',ore:'#666',grain:'#d4a017',sheep:'#8fbf4a'};
  const TERRAIN_RES = {forest:'wood',hills:'brick',mountain:'ore',field:'grain',pasture:'sheep',desert:null};
  const TERRAIN_COLORS = {forest:'#1b6e1b',hills:'#b85c38',mountain:'#7a7a7a',field:'#d4a817',pasture:'#6db84a',desert:'#d2b48c'};
  const PLAYER_COLORS = ['#4af','#e55','#4c4','#fa4'];
  const PLAYER_NAMES = ['You','Red AI','Green AI','Gold AI'];
  const BUILD_COSTS = {
    road: {wood:1,brick:1},
    settlement: {wood:1,brick:1,grain:1,sheep:1},
    city: {ore:3,grain:2}
  };

  // ====== BOARD LAYOUT ======
  const HEX_ROWS = [3,4,5,4,3];
  const HEX_SIZE = 38;
  const BOARD_CX = 210, BOARD_CY = 220;

  let tiles = [];
  let vertices = [];
  let edges = [];
  let players = [];
  let currentPlayer = 0;
  let diceRoll = [0,0];
  let turnPhase = 'roll';
  let setupPhase = 0;
  let setupStep = 'settlement';
  let setupPlayerIdx = 0;
  let robberTile = -1;
  let longestRoadPlayer = -1;
  let longestRoadLen = 0;
  let selectedAction = null;
  let tradeOpen = false;
  let tradeOffer = {give:'',want:''};
  let hoverVertex = -1;
  let hoverEdge = -1;
  let messageLog = [];
  let animFrame = 0;
  let lastDice = [1,1];
  let lastSetupVertex = -1; // track last placed settlement for road placement

  // ====== HEX MATH ======
  function hexCorner(cx, cy, size, i) {
    const angle = Math.PI / 180 * (60 * i - 30);
    return { x: cx + size * Math.cos(angle), y: cy + size * Math.sin(angle) };
  }

  function hexCenter(row, col) {
    const rowCount = HEX_ROWS.length;
    const h = HEX_SIZE * Math.sqrt(3);
    const y = BOARD_CY + (row - 2) * h;
    const cols = HEX_ROWS[row];
    const w = HEX_SIZE * 2;
    const totalW = (cols - 1) * w * 0.75;
    const x = BOARD_CX - totalW / 2 + col * w * 0.75;
    return { x, y };
  }

  // ====== BOARD GENERATION ======
  function generateBoard() {
    tiles = [];
    let terrains = [];
    for (let i = 0; i < 4; i++) terrains.push('forest');
    for (let i = 0; i < 3; i++) terrains.push('hills');
    for (let i = 0; i < 3; i++) terrains.push('mountain');
    for (let i = 0; i < 4; i++) terrains.push('field');
    for (let i = 0; i < 4; i++) terrains.push('pasture');
    terrains.push('desert');
    shuffle(terrains);

    let numbers = [2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12];
    shuffle(numbers);

    let tIdx = 0, nIdx = 0;
    for (let r = 0; r < HEX_ROWS.length; r++) {
      for (let c = 0; c < HEX_ROWS[r]; c++) {
        const pos = hexCenter(r, c);
        const terrain = terrains[tIdx];
        let num = 0;
        if (terrain !== 'desert') {
          num = numbers[nIdx++];
        } else {
          robberTile = tIdx;
        }
        tiles.push({
          row: r, col: c, x: pos.x, y: pos.y,
          terrain, number: num, hasRobber: terrain === 'desert'
        });
        tIdx++;
      }
    }
    generateVerticesAndEdges();
  }

  function generateVerticesAndEdges() {
    vertices = [];
    edges = [];
    const vMap = new Map();

    function vKey(x, y) {
      return Math.round(x * 10) + ',' + Math.round(y * 10);
    }

    for (let t = 0; t < tiles.length; t++) {
      const tile = tiles[t];
      tile.vertexIds = [];
      for (let i = 0; i < 6; i++) {
        const corner = hexCorner(tile.x, tile.y, HEX_SIZE, i);
        const key = vKey(corner.x, corner.y);
        if (!vMap.has(key)) {
          vMap.set(key, vertices.length);
          vertices.push({
            x: corner.x, y: corner.y,
            building: null,
            adjacentTiles: [],
            adjacentVertices: [],
            adjacentEdges: []
          });
        }
        const vi = vMap.get(key);
        tile.vertexIds.push(vi);
        if (!vertices[vi].adjacentTiles.includes(t)) {
          vertices[vi].adjacentTiles.push(t);
        }
      }
    }

    const eMap = new Map();
    function eKey(a, b) { return Math.min(a, b) + '-' + Math.max(a, b); }

    for (let t = 0; t < tiles.length; t++) {
      const vids = tiles[t].vertexIds;
      for (let i = 0; i < 6; i++) {
        const a = vids[i], b = vids[(i + 1) % 6];
        const key = eKey(a, b);
        if (!eMap.has(key)) {
          eMap.set(key, edges.length);
          edges.push({ v1: a, v2: b, road: null });
        }
        const ei = eMap.get(key);
        if (!vertices[a].adjacentEdges.includes(ei)) vertices[a].adjacentEdges.push(ei);
        if (!vertices[b].adjacentEdges.includes(ei)) vertices[b].adjacentEdges.push(ei);
        if (!vertices[a].adjacentVertices.includes(b)) vertices[a].adjacentVertices.push(b);
        if (!vertices[b].adjacentVertices.includes(a)) vertices[b].adjacentVertices.push(a);
      }
    }
  }

  // ====== PLAYER ======
  function createPlayer(idx) {
    return {
      index: idx,
      resources: { wood: 0, brick: 0, ore: 0, grain: 0, sheep: 0 },
      roads: 0, settlements: 0, cities: 0, vp: 0,
      hasLongestRoad: false, knightsPlayed: 0, hasLargestArmy: false
    };
  }

  // ====== UTILITY ======
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function canAfford(player, cost) {
    for (const r in cost) {
      if ((player.resources[r] || 0) < cost[r]) return false;
    }
    return true;
  }

  function payCost(player, cost) {
    for (const r in cost) player.resources[r] -= cost[r];
  }

  function totalResources(player) {
    let t = 0;
    for (const r of RES_NAMES) t += player.resources[r];
    return t;
  }

  function addMsg(msg) {
    messageLog.unshift(msg);
    if (messageLog.length > 6) messageLog.pop();
  }

  // ====== SETUP PHASE ======
  function initGame() {
    generateBoard();
    players = [];
    for (let i = 0; i < 4; i++) players.push(createPlayer(i));
    currentPlayer = 0;
    setupPhase = 1;
    setupStep = 'settlement';
    setupPlayerIdx = 0;
    gameState = 'playing';
    turnPhase = 'setup';
    selectedAction = null;
    tradeOpen = false;
    longestRoadPlayer = -1;
    longestRoadLen = 0;
    lastSetupVertex = -1;
    messageLog = [];
    lastDice = [1, 1];
    addMsg('Setup: Place your 1st settlement');
    turnSpan.textContent = 'Setup - Place Settlement';
    draw();
  }

  function getSetupOrder() {
    if (setupPhase === 1) return [0, 1, 2, 3];
    if (setupPhase === 2) return [3, 2, 1, 0];
    return [];
  }

  function advanceSetup() {
    if (setupStep === 'settlement') {
      setupStep = 'road';
      if (getSetupOrder()[setupPlayerIdx] === 0) {
        turnSpan.textContent = 'Setup - Place Road';
        addMsg('Now place a road next to it');
      }
      draw();
      return;
    }
    // After road placement, move to next player
    setupStep = 'settlement';
    setupPlayerIdx++;
    if (setupPlayerIdx >= 4) {
      if (setupPhase === 1) {
        setupPhase = 2;
        setupPlayerIdx = 0;
      } else {
        // Setup complete - distribute resources for second settlements
        for (let p = 0; p < 4; p++) {
          let count = 0;
          for (const v of vertices) {
            if (v.building && v.building.player === p && v.building.type === 'settlement') {
              count++;
              if (count === 2) {
                for (const ti of v.adjacentTiles) {
                  const res = TERRAIN_RES[tiles[ti].terrain];
                  if (res) players[p].resources[res]++;
                }
              }
            }
          }
        }
        setupPhase = 0;
        currentPlayer = 0;
        turnPhase = 'roll';
        turnSpan.textContent = 'Your Turn - Click Dice';
        addMsg('Game started! Click dice to roll');
        updateVP();
        draw();
        return;
      }
    }
    // Get the updated order after possible phase change
    const order = getSetupOrder();
    currentPlayer = order[setupPlayerIdx];
    if (currentPlayer !== 0) {
      turnSpan.textContent = PLAYER_NAMES[currentPlayer] + ' placing...';
      draw();
      setTimeout(() => aiSetup(currentPlayer), 500);
    } else {
      const which = setupPhase === 1 ? '1st' : '2nd';
      turnSpan.textContent = 'Setup - Place ' + which + ' Settlement';
      addMsg('Place your ' + which + ' settlement');
      draw();
    }
  }

  // ====== VALID PLACEMENTS ======
  function getValidSettlementVertices(playerIdx, isSetup) {
    const valid = [];
    for (let vi = 0; vi < vertices.length; vi++) {
      if (vertices[vi].building) continue;
      // Must be adjacent to at least one tile
      if (vertices[vi].adjacentTiles.length === 0) continue;
      // Distance rule
      let tooClose = false;
      for (const adj of vertices[vi].adjacentVertices) {
        if (vertices[adj].building) { tooClose = true; break; }
      }
      if (tooClose) continue;
      if (isSetup) {
        valid.push(vi);
      } else {
        // Must connect to player's road
        let connected = false;
        for (const ei of vertices[vi].adjacentEdges) {
          if (edges[ei].road === playerIdx) { connected = true; break; }
        }
        if (connected) valid.push(vi);
      }
    }
    return valid;
  }

  function getValidRoadEdges(playerIdx, fromVertex) {
    const valid = [];
    for (let ei = 0; ei < edges.length; ei++) {
      if (edges[ei].road !== null) continue;
      const e = edges[ei];
      if (fromVertex !== undefined) {
        if (e.v1 === fromVertex || e.v2 === fromVertex) valid.push(ei);
        continue;
      }
      // Must connect to player's building or road
      let connected = false;
      for (const vi of [e.v1, e.v2]) {
        if (vertices[vi].building && vertices[vi].building.player === playerIdx) {
          connected = true; break;
        }
        for (const adjE of vertices[vi].adjacentEdges) {
          if (adjE !== ei && edges[adjE].road === playerIdx) {
            if (!vertices[vi].building || vertices[vi].building.player === playerIdx) {
              connected = true; break;
            }
          }
        }
        if (connected) break;
      }
      if (connected) valid.push(ei);
    }
    return valid;
  }

  function getValidCityVertices(playerIdx) {
    const valid = [];
    for (let vi = 0; vi < vertices.length; vi++) {
      if (vertices[vi].building && vertices[vi].building.player === playerIdx && vertices[vi].building.type === 'settlement') {
        valid.push(vi);
      }
    }
    return valid;
  }

  // ====== BUILDING ======
  function placeSettlement(vi, playerIdx, isSetup) {
    vertices[vi].building = { player: playerIdx, type: 'settlement' };
    players[playerIdx].settlements++;
    if (!isSetup) payCost(players[playerIdx], BUILD_COSTS.settlement);
    lastSetupVertex = vi;
    updateVP();
  }

  function placeRoad(ei, playerIdx, isSetup) {
    edges[ei].road = playerIdx;
    players[playerIdx].roads++;
    if (!isSetup) payCost(players[playerIdx], BUILD_COSTS.road);
    updateLongestRoad();
  }

  function placeCity(vi, playerIdx) {
    vertices[vi].building = { player: playerIdx, type: 'city' };
    players[playerIdx].settlements--;
    players[playerIdx].cities++;
    payCost(players[playerIdx], BUILD_COSTS.city);
    updateVP();
  }

  // ====== LONGEST ROAD ======
  function calcLongestRoad(playerIdx) {
    let best = 0;
    const playerEdges = [];
    for (let ei = 0; ei < edges.length; ei++) {
      if (edges[ei].road === playerIdx) playerEdges.push(ei);
    }
    function dfs(vertex, visited) {
      let maxLen = 0;
      for (const ei of vertices[vertex].adjacentEdges) {
        if (edges[ei].road !== playerIdx || visited.has(ei)) continue;
        const nextV = edges[ei].v1 === vertex ? edges[ei].v2 : edges[ei].v1;
        if (vertices[nextV].building && vertices[nextV].building.player !== playerIdx) continue;
        visited.add(ei);
        const len = 1 + dfs(nextV, visited);
        if (len > maxLen) maxLen = len;
        visited.delete(ei);
      }
      return maxLen;
    }
    for (const ei of playerEdges) {
      for (const startV of [edges[ei].v1, edges[ei].v2]) {
        const visited = new Set([ei]);
        const otherV = edges[ei].v1 === startV ? edges[ei].v2 : startV;
        const len = 1 + dfs(otherV, visited);
        if (len > best) best = len;
      }
    }
    return best;
  }

  function updateLongestRoad() {
    let bestPlayer = -1, bestLen = 0;
    for (let p = 0; p < 4; p++) {
      const len = calcLongestRoad(p);
      if (len >= 5 && len > bestLen) { bestLen = len; bestPlayer = p; }
    }
    for (let p = 0; p < 4; p++) players[p].hasLongestRoad = false;
    if (bestPlayer >= 0) {
      players[bestPlayer].hasLongestRoad = true;
      if (longestRoadPlayer !== bestPlayer) {
        longestRoadPlayer = bestPlayer;
        longestRoadLen = bestLen;
        addMsg(PLAYER_NAMES[bestPlayer] + ': Longest Road (' + bestLen + ')');
      }
    }
    updateVP();
  }

  // ====== VP ======
  function updateVP() {
    for (let p = 0; p < 4; p++) {
      let vp = players[p].settlements + players[p].cities * 2;
      if (players[p].hasLongestRoad) vp += 2;
      if (players[p].hasLargestArmy) vp += 2;
      players[p].vp = vp;
    }
    score = players[0].vp;
    vpSpan.textContent = 'VP: ' + score + ' / 10';
  }

  function checkWin() {
    for (let p = 0; p < 4; p++) {
      if (players[p].vp >= 10) {
        gameState = 'over';
        addMsg(PLAYER_NAMES[p] + ' wins with ' + players[p].vp + ' VP!');
        draw();
        return true;
      }
    }
    return false;
  }

  // ====== DICE & RESOURCES ======
  function rollDice() {
    const d1 = Math.floor(Math.random() * 6) + 1;
    const d2 = Math.floor(Math.random() * 6) + 1;
    diceRoll = [d1, d2];
    lastDice = [d1, d2];
    const total = d1 + d2;
    addMsg('Rolled ' + total + (total === 7 ? ' - Robber!' : ''));

    if (total === 7) {
      for (let p = 0; p < 4; p++) {
        const t = totalResources(players[p]);
        if (t > 7) {
          const discard = Math.floor(t / 2);
          for (let d = 0; d < discard; d++) {
            const owned = RES_NAMES.filter(r => players[p].resources[r] > 0);
            if (owned.length > 0) {
              const r = owned[Math.floor(Math.random() * owned.length)];
              players[p].resources[r]--;
            }
          }
          if (p === 0) addMsg('Discarded ' + discard + ' cards');
        }
      }
      let newRobber;
      do { newRobber = Math.floor(Math.random() * tiles.length); } while (newRobber === robberTile);
      tiles[robberTile].hasRobber = false;
      robberTile = newRobber;
      tiles[robberTile].hasRobber = true;
    } else {
      for (let t = 0; t < tiles.length; t++) {
        if (tiles[t].number === total && !tiles[t].hasRobber) {
          const res = TERRAIN_RES[tiles[t].terrain];
          if (!res) continue;
          for (const vi of tiles[t].vertexIds) {
            if (vertices[vi].building) {
              const b = vertices[vi].building;
              const amount = b.type === 'city' ? 2 : 1;
              players[b.player].resources[res] += amount;
            }
          }
        }
      }
    }
    turnPhase = 'build';
  }

  // ====== TRADING ======
  function bankTrade(playerIdx, give, want) {
    if (players[playerIdx].resources[give] >= 4) {
      players[playerIdx].resources[give] -= 4;
      players[playerIdx].resources[want] += 1;
      if (playerIdx === 0) addMsg('Traded 4 ' + give + ' -> 1 ' + want);
      return true;
    }
    return false;
  }

  // ====== AI ======
  function aiSetup(playerIdx) {
    if (gameState !== 'playing') return;
    if (setupStep === 'settlement') {
      const valid = getValidSettlementVertices(playerIdx, true);
      if (valid.length === 0) { advanceSetup(); return; }
      let best = -1, bestScore = -Infinity;
      for (const vi of valid) {
        let s = 0;
        const resSet = new Set();
        for (const ti of vertices[vi].adjacentTiles) {
          const res = TERRAIN_RES[tiles[ti].terrain];
          if (res) {
            resSet.add(res);
            const n = tiles[ti].number;
            s += 6 - Math.abs(7 - n);
          }
        }
        s += resSet.size * 3;
        s += Math.random() * 2;
        if (s > bestScore) { bestScore = s; best = vi; }
      }
      placeSettlement(best, playerIdx, true);
      lastSetupVertex = best;
      draw();
      setTimeout(() => { advanceSetup(); }, 350);
    } else if (setupStep === 'road') {
      const valid = getValidRoadEdges(playerIdx, lastSetupVertex);
      if (valid.length > 0) {
        const ei = valid[Math.floor(Math.random() * valid.length)];
        placeRoad(ei, playerIdx, true);
      }
      draw();
      setTimeout(() => { advanceSetup(); }, 350);
    }
  }

  function aiTurn(playerIdx) {
    if (gameState !== 'playing') return;
    turnPhase = 'roll';
    draw();

    setTimeout(() => {
      rollDice();
      draw();
      if (checkWin()) return;

      setTimeout(() => {
        aiBuilding(playerIdx);
      }, 500);
    }, 600);
  }

  function aiBuilding(playerIdx) {
    if (gameState !== 'playing') return;
    const p = players[playerIdx];
    let actions = [];

    // AI strategy: try trades, then build in priority order
    aiSmartTrade(playerIdx);

    // Try city first (best VP per action)
    if (canAfford(p, BUILD_COSTS.city)) {
      const valid = getValidCityVertices(playerIdx);
      if (valid.length > 0) {
        let best = valid[0], bestVal = -1;
        for (const vi of valid) {
          let val = 0;
          for (const ti of vertices[vi].adjacentTiles) {
            val += 6 - Math.abs(7 - tiles[ti].number);
          }
          if (val > bestVal) { bestVal = val; best = vi; }
        }
        placeCity(best, playerIdx);
        actions.push('city');
      }
    }

    // Try settlement
    if (canAfford(p, BUILD_COSTS.settlement)) {
      const valid = getValidSettlementVertices(playerIdx, false);
      if (valid.length > 0) {
        let best = valid[0], bestVal = -1;
        for (const vi of valid) {
          let val = 0;
          const resSet = new Set();
          for (const ti of vertices[vi].adjacentTiles) {
            const res = TERRAIN_RES[tiles[ti].terrain];
            if (res) { resSet.add(res); val += 6 - Math.abs(7 - tiles[ti].number); }
          }
          val += resSet.size * 2;
          // Bonus for blocking player 0
          for (const adj of vertices[vi].adjacentVertices) {
            if (vertices[adj].building && vertices[adj].building.player === 0) val += 2;
          }
          if (val > bestVal) { bestVal = val; best = vi; }
        }
        placeSettlement(best, playerIdx, false);
        actions.push('settlement');
      }
    }

    // Build 1-2 roads
    for (let attempt = 0; attempt < 2; attempt++) {
      if (canAfford(p, BUILD_COSTS.road) && p.roads < 15) {
        const valid = getValidRoadEdges(playerIdx);
        if (valid.length > 0) {
          let best = valid[Math.floor(Math.random() * valid.length)];
          let bestVal = -1;
          for (const ei of valid) {
            const e = edges[ei];
            let val = Math.random() * 2;
            for (const vi of [e.v1, e.v2]) {
              if (!vertices[vi].building) {
                let tooClose = false;
                for (const adj of vertices[vi].adjacentVertices) {
                  if (vertices[adj].building) tooClose = true;
                }
                if (!tooClose) {
                  for (const ti of vertices[vi].adjacentTiles) {
                    val += (6 - Math.abs(7 - tiles[ti].number)) * 0.5;
                  }
                }
              }
            }
            if (val > bestVal) { bestVal = val; best = ei; }
          }
          placeRoad(best, playerIdx, false);
          actions.push('road');
        }
      }
    }

    if (actions.length > 0) {
      addMsg(PLAYER_NAMES[playerIdx] + ': ' + actions.join(', '));
    }

    draw();
    if (checkWin()) return;
    nextPlayer();
  }

  function aiSmartTrade(playerIdx) {
    const p = players[playerIdx];
    // Determine what to build
    const wantsToBuild = [];
    if (getValidCityVertices(playerIdx).length > 0) wantsToBuild.push(BUILD_COSTS.city);
    if (getValidSettlementVertices(playerIdx, false).length > 0) wantsToBuild.push(BUILD_COSTS.settlement);
    wantsToBuild.push(BUILD_COSTS.road);

    for (const cost of wantsToBuild) {
      const needs = [];
      for (const r in cost) {
        const deficit = cost[r] - p.resources[r];
        if (deficit > 0) needs.push(r);
      }
      if (needs.length === 0) continue;

      // Try bank trade
      for (const r of RES_NAMES) {
        if (p.resources[r] >= 5 && needs.length > 0 && r !== needs[0]) {
          bankTrade(playerIdx, r, needs[0]);
          return;
        }
      }
      for (const r of RES_NAMES) {
        if (p.resources[r] >= 4 && needs.length > 0 && r !== needs[0]) {
          bankTrade(playerIdx, r, needs[0]);
          return;
        }
      }
    }
  }

  function nextPlayer() {
    currentPlayer = (currentPlayer + 1) % 4;
    turnPhase = 'roll';
    selectedAction = null;
    tradeOpen = false;
    if (gameState !== 'playing') return;

    if (currentPlayer === 0) {
      turnSpan.textContent = 'Your Turn - Click Dice';
      addMsg('Your turn!');
    } else {
      turnSpan.textContent = PLAYER_NAMES[currentPlayer] + "'s Turn";
      setTimeout(() => aiTurn(currentPlayer), 500);
    }
    draw();
  }

  // ====== RENDERING ======
  function draw() {
    animFrame++;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, W, H);

    if (gameState === 'title') { drawTitle(); return; }

    drawBoard();
    drawRoads();
    drawHighlights();
    drawBuildings();
    drawUI();

    if (gameState === 'over') drawGameOver();
  }

  function drawTitle() {
    // Ocean background
    ctx.fillStyle = '#0d2137';
    ctx.fillRect(0, 0, W, H);

    // Decorative hexes
    const pulse = 0.3 + 0.15 * Math.sin(animFrame * 0.03);
    const colors = ['#1b6e1b','#b85c38','#7a7a7a','#d4a817','#6db84a','#d2b48c'];
    for (let i = 0; i < 7; i++) {
      const angle = (i / 7) * Math.PI * 2 + animFrame * 0.005;
      const r = 100;
      const hx = W/2 + r * Math.cos(angle);
      const hy = 250 + r * Math.sin(angle) * 0.6;
      ctx.globalAlpha = 0.35;
      drawHex(hx, hy, 28, colors[i % 6], 'rgba(238,136,68,0.3)');
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 38px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#e84';
    ctx.shadowBlur = 20;
    ctx.fillText('Settlers', W/2, 100);
    ctx.fillText('Online', W/2, 140);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#aaa';
    ctx.font = '14px Courier New';
    ctx.fillText('Trade, Build, Settle the Island', W/2, 190);
    ctx.fillText('You vs 3 AI Opponents', W/2, 212);

    // Rules summary
    ctx.font = '11px Courier New';
    ctx.fillStyle = '#777';
    const rules = [
      'Roll dice -> Collect resources',
      'Build roads, settlements, cities',
      'Trade 4:1 with the bank',
      'Longest Road = +2 VP',
      'First to 10 Victory Points wins!'
    ];
    for (let i = 0; i < rules.length; i++) {
      ctx.fillText(rules[i], W/2, 340 + i * 18);
    }

    // Start button
    const btnY = 460;
    ctx.fillStyle = 'rgba(238,136,68,' + (0.15 + pulse * 0.15) + ')';
    ctx.fillRect(W/2 - 90, btnY - 16, 180, 36);
    ctx.strokeStyle = '#e84';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#e84';
    ctx.shadowBlur = 10 * pulse;
    ctx.strokeRect(W/2 - 90, btnY - 16, 180, 36);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#e84';
    ctx.font = 'bold 16px Courier New';
    ctx.fillText('Click to Start', W/2, btnY + 2);
  }

  function drawHex(cx, cy, size, fillColor, strokeColor) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(cx, cy, size, i);
      if (i === 0) ctx.moveTo(corner.x, corner.y);
      else ctx.lineTo(corner.x, corner.y);
    }
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor || '#2a2a4e';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawBoard() {
    // Draw ocean
    ctx.fillStyle = '#0d2137';
    ctx.beginPath();
    ctx.arc(BOARD_CX, BOARD_CY, HEX_SIZE * 4.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(238,136,68,0.15)';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Draw tiles
    for (let t = 0; t < tiles.length; t++) {
      const tile = tiles[t];
      let color = TERRAIN_COLORS[tile.terrain];
      if (tile.hasRobber) color = '#444';
      drawHex(tile.x, tile.y, HEX_SIZE - 2, color, '#1a1a2e');

      // Number token
      if (tile.number > 0 && !tile.hasRobber) {
        ctx.fillStyle = '#f5f0dc';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, 13, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#c00' : '#333';
        ctx.fillText('' + tile.number, tile.x, tile.y - 1);

        // Probability dots
        const dots = 6 - Math.abs(7 - tile.number);
        ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#c00' : '#888';
        for (let d = 0; d < dots; d++) {
          ctx.beginPath();
          ctx.arc(tile.x - (dots - 1) * 2.5 + d * 5, tile.y + 9, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Robber
      if (tile.hasRobber && tile.terrain !== 'desert') {
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y - 4, 9, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(tile.x - 6, tile.y + 5, 12, 8);
        ctx.fillStyle = '#e84';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('R', tile.x, tile.y - 3);
      } else if (tile.terrain === 'desert') {
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('DESERT', tile.x, tile.y);
      }

      // Terrain icon letter
      if (!tile.hasRobber && tile.terrain !== 'desert') {
        ctx.font = '8px Courier New';
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(tile.terrain.substring(0, 3).toUpperCase(), tile.x, tile.y + 20);
      }
    }
  }

  function drawRoads() {
    for (let ei = 0; ei < edges.length; ei++) {
      const e = edges[ei];
      if (e.road === null) continue;
      const v1 = vertices[e.v1], v2 = vertices[e.v2];
      // Road shadow
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(v1.x + 1, v1.y + 1);
      ctx.lineTo(v2.x + 1, v2.y + 1);
      ctx.stroke();
      // Road
      ctx.strokeStyle = PLAYER_COLORS[e.road];
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(v1.x, v1.y);
      ctx.lineTo(v2.x, v2.y);
      ctx.stroke();
    }
  }

  function drawHighlights() {
    if (currentPlayer !== 0 || gameState !== 'playing') return;

    // Setup highlights
    if (turnPhase === 'setup') {
      const order = getSetupOrder();
      if (order[setupPlayerIdx] !== 0) return;

      if (setupStep === 'settlement') {
        const valid = getValidSettlementVertices(0, true);
        for (const vi of valid) {
          const isHover = vi === hoverVertex;
          ctx.fillStyle = isHover ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.2)';
          ctx.beginPath();
          ctx.arc(vertices[vi].x, vertices[vi].y, isHover ? 8 : 5, 0, Math.PI * 2);
          ctx.fill();
          if (isHover) {
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      } else if (setupStep === 'road') {
        const valid = getValidRoadEdges(0, lastSetupVertex);
        for (const ei of valid) {
          const e = edges[ei];
          const v1 = vertices[e.v1], v2 = vertices[e.v2];
          const isHover = ei === hoverEdge;
          ctx.strokeStyle = isHover ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.2)';
          ctx.lineWidth = isHover ? 6 : 4;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(v1.x, v1.y);
          ctx.lineTo(v2.x, v2.y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      return;
    }

    // Build phase highlights
    if (turnPhase === 'build' && selectedAction === 'settlement') {
      const valid = getValidSettlementVertices(0, false);
      for (const vi of valid) {
        const isHover = vi === hoverVertex;
        ctx.fillStyle = isHover ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.2)';
        ctx.beginPath();
        ctx.arc(vertices[vi].x, vertices[vi].y, isHover ? 8 : 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    if (turnPhase === 'build' && selectedAction === 'city') {
      const valid = getValidCityVertices(0);
      for (const vi of valid) {
        const isHover = vi === hoverVertex;
        ctx.fillStyle = isHover ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.2)';
        ctx.beginPath();
        ctx.arc(vertices[vi].x, vertices[vi].y, isHover ? 9 : 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    if (turnPhase === 'build' && selectedAction === 'road') {
      const valid = getValidRoadEdges(0);
      for (const ei of valid) {
        const e = edges[ei];
        const v1 = vertices[e.v1], v2 = vertices[e.v2];
        const isHover = ei === hoverEdge;
        ctx.strokeStyle = isHover ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.2)';
        ctx.lineWidth = isHover ? 6 : 4;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  function drawBuildings() {
    for (let vi = 0; vi < vertices.length; vi++) {
      const v = vertices[vi];
      if (!v.building) continue;
      const color = PLAYER_COLORS[v.building.player];
      if (v.building.type === 'settlement') {
        // House shape
        ctx.fillStyle = color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(v.x, v.y - 9);
        ctx.lineTo(v.x + 7, v.y - 3);
        ctx.lineTo(v.x + 7, v.y + 5);
        ctx.lineTo(v.x - 7, v.y + 5);
        ctx.lineTo(v.x - 7, v.y - 3);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else {
        // City - larger
        ctx.fillStyle = color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(v.x - 4, v.y - 12);
        ctx.lineTo(v.x + 3, v.y - 6);
        ctx.lineTo(v.x + 9, v.y - 6);
        ctx.lineTo(v.x + 9, v.y + 6);
        ctx.lineTo(v.x - 9, v.y + 6);
        ctx.lineTo(v.x - 9, v.y - 3);
        ctx.lineTo(v.x - 4, v.y - 3);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Window
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(v.x - 2, v.y - 1, 4, 4);
      }
    }
  }

  function drawUI() {
    const PX = 430;  // panel x
    const PW = 162;  // panel width

    ctx.textBaseline = 'middle';

    // === DICE PANEL ===
    drawPanel(PX, 8, PW, 55, 'DICE');
    const dy = 36;
    drawDie(PX + 40, dy, lastDice[0]);
    drawDie(PX + 100, dy, lastDice[1]);

    if (currentPlayer === 0 && turnPhase === 'roll') {
      ctx.fillStyle = '#e84';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('[ CLICK TO ROLL ]', PX + PW/2, 60);
    } else if (lastDice[0] + lastDice[1] > 1) {
      ctx.fillStyle = '#777';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText('Total: ' + (lastDice[0]+lastDice[1]), PX + PW/2, 60);
    }

    // === RESOURCES PANEL ===
    drawPanel(PX, 68, PW, 82, 'RESOURCES');
    const resIcons = [
      {name:'wood', icon:'\u25B2', color:'#3a7a2a'},
      {name:'brick', icon:'\u25A0', color:'#b85c38'},
      {name:'ore', icon:'\u25C6', color:'#999'},
      {name:'grain', icon:'\u2042', color:'#d4a017'},
      {name:'sheep', icon:'\u223F', color:'#6db84a'}
    ];
    const res = players.length > 0 ? players[0].resources : {};
    for (let i = 0; i < 5; i++) {
      const ry = 88 + i * 12;
      ctx.fillStyle = resIcons[i].color;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(resIcons[i].icon, PX + 8, ry);
      ctx.fillStyle = '#bbb';
      ctx.fillText(resIcons[i].name, PX + 22, ry);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'right';
      ctx.fillText('' + (res[resIcons[i].name] || 0), PX + PW - 8, ry);
    }

    // === BUILD PANEL ===
    drawPanel(PX, 156, PW, 118, 'BUILD');
    const buildOpts = [
      {key:'road', label:'Road', cost:'W+B', costs: BUILD_COSTS.road},
      {key:'settlement', label:'Settlement', cost:'W+B+G+S', costs: BUILD_COSTS.settlement},
      {key:'city', label:'City', cost:'3O+2G', costs: BUILD_COSTS.city},
    ];
    for (let i = 0; i < 3; i++) {
      const by = 176 + i * 26;
      const opt = buildOpts[i];
      const canBuild = currentPlayer === 0 && turnPhase === 'build' && canAfford(players[0], opt.costs);
      const active = selectedAction === opt.key;

      ctx.fillStyle = active ? 'rgba(238,136,68,0.25)' : 'rgba(255,255,255,0.04)';
      ctx.fillRect(PX + 4, by - 2, PW - 8, 22);
      if (active) {
        ctx.strokeStyle = '#e84';
        ctx.lineWidth = 1;
        ctx.strokeRect(PX + 4, by - 2, PW - 8, 22);
      }
      ctx.fillStyle = canBuild ? '#ddd' : '#555';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(opt.label, PX + 10, by + 4);
      ctx.fillStyle = canBuild ? '#999' : '#444';
      ctx.font = '8px Courier New';
      ctx.fillText(opt.cost, PX + 10, by + 15);
    }

    // End turn button
    const endY = 256;
    const canEnd = currentPlayer === 0 && turnPhase === 'build';
    ctx.fillStyle = canEnd ? 'rgba(238,136,68,0.15)' : 'rgba(255,255,255,0.03)';
    ctx.fillRect(PX + 4, endY, PW - 8, 18);
    ctx.strokeStyle = canEnd ? '#e84' : '#333';
    ctx.lineWidth = 1;
    ctx.strokeRect(PX + 4, endY, PW - 8, 18);
    ctx.fillStyle = canEnd ? '#e84' : '#555';
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('END TURN', PX + PW/2, endY + 9);

    // === TRADE PANEL ===
    drawPanel(PX, 280, PW, 78, 'TRADE 4:1');
    if (tradeOpen && currentPlayer === 0 && turnPhase === 'build') {
      ctx.fillStyle = '#aaa';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('Give: ' + (tradeOffer.give || '???'), PX + 6, 300);
      ctx.fillText('Want: ' + (tradeOffer.want || '???'), PX + 6, 313);

      // Resource buttons - give row
      for (let i = 0; i < 5; i++) {
        const bx = PX + 6 + i * 31;
        const hasEnough = players[0].resources[RES_NAMES[i]] >= 4;
        ctx.fillStyle = tradeOffer.give === RES_NAMES[i] ? '#e84' : (hasEnough ? '#2a2a4e' : '#1a1a2e');
        ctx.fillRect(bx, 322, 28, 13);
        ctx.strokeStyle = hasEnough ? '#e84' : '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, 322, 28, 13);
        ctx.fillStyle = hasEnough ? '#fff' : '#555';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(RES_NAMES[i].substring(0,3).toUpperCase(), bx + 14, 329);
        // Want row
        ctx.fillStyle = tradeOffer.want === RES_NAMES[i] ? '#4af' : '#2a2a4e';
        ctx.fillRect(bx, 337, 28, 13);
        ctx.strokeStyle = '#4af';
        ctx.strokeRect(bx, 337, 28, 13);
        ctx.fillStyle = '#fff';
        ctx.fillText(RES_NAMES[i].substring(0,3).toUpperCase(), bx + 14, 344);
      }
    } else {
      const canTrade = currentPlayer === 0 && turnPhase === 'build';
      ctx.fillStyle = canTrade ? '#aaa' : '#555';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('Click to open trade', PX + 8, 304);
      ctx.fillStyle = '#666';
      ctx.fillText('Give 4 of one resource', PX + 8, 318);
      ctx.fillText('Get 1 of another', PX + 8, 332);
    }

    // === VP TRACKER ===
    drawPanel(PX, 364, PW, 90, 'VICTORY POINTS');
    for (let p = 0; p < 4; p++) {
      if (!players[p]) continue;
      const py = 386 + p * 18;
      // Color bar
      ctx.fillStyle = PLAYER_COLORS[p];
      ctx.fillRect(PX + 8, py - 5, 6, 10);
      // Name and VP
      ctx.fillStyle = p === currentPlayer ? '#fff' : '#aaa';
      ctx.font = p === currentPlayer ? 'bold 10px Courier New' : '10px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const name = (p === 0 ? 'You' : PLAYER_NAMES[p]);
      ctx.fillText(name, PX + 18, py);
      // VP bar
      const barW = Math.min(players[p].vp / 10, 1) * 50;
      ctx.fillStyle = 'rgba(238,136,68,0.2)';
      ctx.fillRect(PX + 80, py - 4, 50, 8);
      ctx.fillStyle = PLAYER_COLORS[p];
      ctx.fillRect(PX + 80, py - 4, barW, 8);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'right';
      ctx.fillText(players[p].vp + '', PX + PW - 6, py);
      // Badges
      let badges = '';
      if (players[p].hasLongestRoad) badges += 'LR ';
      if (players[p].hasLargestArmy) badges += 'LA';
      if (badges) {
        ctx.fillStyle = '#e84';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(badges, PX + 78, py);
      }
    }

    // === MESSAGE LOG ===
    drawPanel(PX, 460, PW, 84, 'LOG');
    ctx.font = '8px Courier New';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < Math.min(messageLog.length, 6); i++) {
      ctx.fillStyle = i === 0 ? '#e84' : (i === 1 ? '#999' : '#555');
      let msg = messageLog[i];
      if (msg.length > 26) msg = msg.substring(0, 25) + '..';
      ctx.fillText(msg, PX + 6, 480 + i * 10);
    }

    // === BOARD STATUS BAR ===
    if (turnPhase === 'setup') {
      const order = getSetupOrder();
      const cp = order[setupPlayerIdx];
      ctx.fillStyle = 'rgba(26,26,46,0.9)';
      ctx.fillRect(20, H - 32, 395, 26);
      ctx.strokeStyle = PLAYER_COLORS[cp];
      ctx.lineWidth = 1;
      ctx.strokeRect(20, H - 32, 395, 26);
      ctx.fillStyle = PLAYER_COLORS[cp];
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const round = setupPhase === 1 ? '1' : '2';
      ctx.fillText(PLAYER_NAMES[cp] + ' - Place ' + setupStep + ' (Round ' + round + ')', 217, H - 19);
    }
  }

  function drawPanel(x, y, w, h, title) {
    ctx.fillStyle = '#12152a';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = 'rgba(238,136,68,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
    if (title) {
      ctx.fillStyle = '#e84';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(title, x + 6, y + 10);
    }
  }

  function drawDie(cx, cy, value) {
    const r = 15;
    ctx.fillStyle = '#f5f0dc';
    ctx.beginPath();
    ctx.roundRect(cx - r, cy - r, r * 2, r * 2, 3);
    ctx.fill();
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.fillStyle = '#222';
    const dotR = 2.5;
    const positions = {
      1: [[0,0]],
      2: [[-5,-5],[5,5]],
      3: [[-5,-5],[0,0],[5,5]],
      4: [[-5,-5],[5,-5],[-5,5],[5,5]],
      5: [[-5,-5],[5,-5],[0,0],[-5,5],[5,5]],
      6: [[-5,-5],[5,-5],[-5,0],[5,0],[-5,5],[5,5]]
    };
    const dots = positions[value] || positions[1];
    for (const [dx, dy] of dots) {
      ctx.beginPath();
      ctx.arc(cx + dx, cy + dy, dotR, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawGameOver() {
    ctx.fillStyle = 'rgba(26,26,46,0.88)';
    ctx.fillRect(0, 0, W, H);

    let winner = 0;
    for (let p = 0; p < 4; p++) {
      if (players[p].vp >= 10) winner = p;
    }

    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#e84';
    ctx.shadowBlur = 25;
    ctx.fillStyle = '#e84';
    ctx.font = 'bold 36px Courier New';
    if (winner === 0) {
      ctx.fillText('VICTORY!', W/2, H/2 - 60);
    } else {
      ctx.fillText(PLAYER_NAMES[winner] + ' Wins', W/2, H/2 - 60);
    }
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#aaa';
    ctx.font = '14px Courier New';
    ctx.fillText(players[winner].vp + ' Victory Points', W/2, H/2 - 25);

    for (let p = 0; p < 4; p++) {
      ctx.fillStyle = PLAYER_COLORS[p];
      ctx.font = '13px Courier New';
      const tag = p === winner ? ' << WINNER' : '';
      ctx.fillText(PLAYER_NAMES[p] + ': ' + players[p].vp + ' VP' + tag, W/2, H/2 + 20 + p * 24);
    }

    ctx.fillStyle = '#e84';
    ctx.font = '14px Courier New';
    const pulse = 0.5 + 0.5 * Math.sin(animFrame * 0.05);
    ctx.globalAlpha = 0.5 + pulse * 0.5;
    ctx.fillText('Click to play again', W/2, H/2 + 130);
    ctx.globalAlpha = 1;
  }

  // ====== INPUT ======
  C.addEventListener('mousemove', function(e) {
    const rect = C.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (W / rect.width);
    const my = (e.clientY - rect.top) * (H / rect.height);

    hoverVertex = -1;
    hoverEdge = -1;

    // Find closest vertex
    let minDist = 18;
    for (let vi = 0; vi < vertices.length; vi++) {
      const dx = vertices[vi].x - mx, dy = vertices[vi].y - my;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < minDist) { minDist = d; hoverVertex = vi; }
    }

    // Find closest edge midpoint
    let minEdgeDist = 12;
    for (let ei = 0; ei < edges.length; ei++) {
      const e = edges[ei];
      const v1 = vertices[e.v1], v2 = vertices[e.v2];
      const cx = (v1.x + v2.x) / 2, cy = (v1.y + v2.y) / 2;
      const dx = cx - mx, dy = cy - my;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < minEdgeDist) { minEdgeDist = d; hoverEdge = ei; }
    }

    if (gameState === 'playing') draw();
  });

  C.addEventListener('click', function(e) {
    const rect = C.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (W / rect.width);
    const my = (e.clientY - rect.top) * (H / rect.height);

    if (gameState === 'title') {
      initGame();
      return;
    }

    if (gameState === 'over') {
      gameState = 'title';
      draw();
      return;
    }

    // === SETUP CLICKS ===
    if (turnPhase === 'setup') {
      const order = getSetupOrder();
      if (order[setupPlayerIdx] !== 0) return;

      if (setupStep === 'settlement') {
        const valid = getValidSettlementVertices(0, true);
        if (hoverVertex >= 0 && valid.includes(hoverVertex)) {
          placeSettlement(hoverVertex, 0, true);
          addMsg('Settlement placed!');
          advanceSetup();
          return;
        }
      } else if (setupStep === 'road') {
        const valid = getValidRoadEdges(0, lastSetupVertex);
        if (hoverEdge >= 0 && valid.includes(hoverEdge)) {
          placeRoad(hoverEdge, 0, true);
          addMsg('Road placed!');
          advanceSetup();
          return;
        }
      }
      return;
    }

    if (currentPlayer !== 0) return;

    const PX = 430;
    const PW = 162;

    // === DICE CLICK ===
    if (turnPhase === 'roll') {
      if (mx >= PX && mx <= PX + PW && my >= 8 && my <= 63) {
        rollDice();
        turnSpan.textContent = 'Your Turn - Build / Trade';
        draw();
        return;
      }
    }

    // === BUILD MENU CLICKS ===
    if (turnPhase === 'build') {
      const buildOpts = ['road', 'settlement', 'city'];
      for (let i = 0; i < 3; i++) {
        const by = 176 + i * 26;
        if (mx >= PX + 4 && mx <= PX + PW - 4 && my >= by - 2 && my <= by + 20) {
          if (canAfford(players[0], BUILD_COSTS[buildOpts[i]])) {
            selectedAction = selectedAction === buildOpts[i] ? null : buildOpts[i];
            tradeOpen = false;
          }
          draw();
          return;
        }
      }

      // End turn
      const endY = 256;
      if (mx >= PX + 4 && mx <= PX + PW - 4 && my >= endY && my <= endY + 18) {
        selectedAction = null;
        nextPlayer();
        return;
      }

      // Trade panel
      const tradeY = 280;
      if (mx >= PX && mx <= PX + PW && my >= tradeY && my <= tradeY + 78) {
        if (!tradeOpen) {
          tradeOpen = true;
          tradeOffer = { give: '', want: '' };
          selectedAction = null;
          draw();
          return;
        }
        // Resource button clicks
        for (let i = 0; i < 5; i++) {
          const bx = PX + 6 + i * 31;
          if (mx >= bx && mx <= bx + 28 && my >= 322 && my <= 335) {
            if (players[0].resources[RES_NAMES[i]] >= 4) {
              tradeOffer.give = RES_NAMES[i];
              tryExecuteTrade();
            }
            draw();
            return;
          }
          if (mx >= bx && mx <= bx + 28 && my >= 337 && my <= 350) {
            tradeOffer.want = RES_NAMES[i];
            tryExecuteTrade();
            draw();
            return;
          }
        }
        return;
      }

      // === BOARD CLICKS ===
      if (selectedAction === 'road' && hoverEdge >= 0) {
        const valid = getValidRoadEdges(0);
        if (valid.includes(hoverEdge)) {
          placeRoad(hoverEdge, 0, false);
          addMsg('Road built!');
          if (!canAfford(players[0], BUILD_COSTS.road)) selectedAction = null;
          draw();
          return;
        }
      }
      if (selectedAction === 'settlement' && hoverVertex >= 0) {
        const valid = getValidSettlementVertices(0, false);
        if (valid.includes(hoverVertex)) {
          placeSettlement(hoverVertex, 0, false);
          addMsg('Settlement built!');
          selectedAction = null;
          draw();
          return;
        }
      }
      if (selectedAction === 'city' && hoverVertex >= 0) {
        const valid = getValidCityVertices(0);
        if (valid.includes(hoverVertex)) {
          placeCity(hoverVertex, 0);
          addMsg('City upgraded!');
          selectedAction = null;
          draw();
          return;
        }
      }
    }
  });

  function tryExecuteTrade() {
    if (tradeOffer.give && tradeOffer.want && tradeOffer.give !== tradeOffer.want) {
      if (bankTrade(0, tradeOffer.give, tradeOffer.want)) {
        tradeOffer = { give: '', want: '' };
        draw();
      }
    }
  }

  // ====== ANIMATION LOOP ======
  let lastTime = 0;
  function gameLoop(time) {
    if (gameState === 'title' || gameState === 'over') draw();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);

  // Initial draw
  draw();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

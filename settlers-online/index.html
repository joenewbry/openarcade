<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Settlers Online</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
      width: 600px;
    }
    .back { color: #e84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 136, 68, 0.4); }
    h1 { color: #e84; font-size: 1.8rem; text-shadow: 0 0 15px rgba(238, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 1rem;
    }
    .score-bar .player-vp { color: #4af; }
    .score-bar .turn-info { color: #e84; }
    canvas#game {
      border: 2px solid #e84;
      box-shadow: 0 0 20px rgba(238, 136, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
      z-index: 10;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(238,136,68,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .big { font-size: 1.4rem; color: #e84; margin-top: 10px; }
    .controls {
      width: 600px;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #888;
    }
    .controls span { color: #e84; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&#9664; back</a>
    <h1>Settlers Online</h1>
  </div>
  <div class="score-bar">
    <span class="player-vp">VP: 0</span>
    <span class="turn-info">Setup Phase</span>
  </div>
  <canvas id="game" width="600" height="550"></canvas>
  <div class="controls">
    <span>Click to build &amp; trade</span>
    <span>First to 10 VP wins</span>
  </div>

  <script>
  // ====== GLOBALS ======
  let gameState = 'title';
  let score = 0;

  const C = document.getElementById('game');
  const ctx = C.getContext('2d');
  const W = 600, H = 550;
  const overlay = document.querySelector('.overlay');
  const vpSpan = document.querySelector('.player-vp');
  const turnSpan = document.querySelector('.turn-info');

  // ====== CONSTANTS ======
  const TERRAINS = ['forest','hills','mountain','field','pasture','desert'];
  const RES_NAMES = ['wood','brick','ore','grain','sheep'];
  const RES_COLORS = {wood:'#2d5a1e',brick:'#a63c1e',ore:'#666',grain:'#d4a017',sheep:'#8fbf4a'};
  const TERRAIN_RES = {forest:'wood',hills:'brick',mountain:'ore',field:'grain',pasture:'sheep',desert:null};
  const TERRAIN_COLORS = {forest:'#1b6e1b',hills:'#b85c38',mountain:'#7a7a7a',field:'#d4a817',pasture:'#6db84a',desert:'#d2b48c'};
  const PLAYER_COLORS = ['#4af','#e44','#4c4','#fa4'];
  const PLAYER_NAMES = ['You','Red AI','Green AI','Yellow AI'];
  const BUILD_COSTS = {
    road: {wood:1,brick:1},
    settlement: {wood:1,brick:1,grain:1,sheep:1},
    city: {ore:3,grain:2}
  };

  // ====== BOARD LAYOUT ======
  // Standard Catan: 19 hex tiles in rows of 3,4,5,4,3
  const HEX_ROWS = [3,4,5,4,3];
  const HEX_SIZE = 36;
  const BOARD_CX = 220, BOARD_CY = 210;

  let tiles = [];
  let vertices = [];  // intersection points
  let edges = [];     // roads between vertices
  let players = [];
  let currentPlayer = 0;
  let diceRoll = [0,0];
  let turnPhase = 'roll'; // roll, build, done
  let setupPhase = 0; // 0=not setup, 1=first round, 2=second round
  let setupStep = 'settlement'; // settlement or road
  let setupPlayerIdx = 0;
  let robberTile = -1;
  let longestRoadPlayer = -1;
  let longestRoadLen = 0;
  let devCards = [];
  let selectedAction = null; // 'road','settlement','city','trade'
  let tradeOpen = false;
  let tradeOffer = {give:'',want:''};
  let hoverVertex = -1;
  let hoverEdge = -1;
  let messageLog = [];
  let messageTimer = 0;
  let animFrame = 0;
  let diceAnim = 0;
  let lastDice = [1,1];

  // ====== HEX MATH ======
  function hexCorner(cx, cy, size, i) {
    const angle = Math.PI / 180 * (60 * i - 30);
    return { x: cx + size * Math.cos(angle), y: cy + size * Math.sin(angle) };
  }

  function hexCenter(row, col) {
    const rowOffset = [0, 0, 0, 0, 0];
    const totalRows = HEX_ROWS.length;
    let y = BOARD_CY - (totalRows - 1) * HEX_SIZE * 0.866;
    for (let r = 0; r < row; r++) y += HEX_SIZE * 1.732;
    const cols = HEX_ROWS[row];
    const maxCols = 5;
    const xStart = BOARD_CX - (cols - 1) * HEX_SIZE * 0.866;
    let x = xStart + col * HEX_SIZE * 1.732;
    return { x, y };
  }

  // ====== BOARD GENERATION ======
  function generateBoard() {
    tiles = [];
    // Terrain distribution: 4 forest, 3 hills, 3 mountain, 4 field, 4 pasture, 1 desert
    let terrains = [];
    for (let i = 0; i < 4; i++) terrains.push('forest');
    for (let i = 0; i < 3; i++) terrains.push('hills');
    for (let i = 0; i < 3; i++) terrains.push('mountain');
    for (let i = 0; i < 4; i++) terrains.push('field');
    for (let i = 0; i < 4; i++) terrains.push('pasture');
    terrains.push('desert');
    shuffle(terrains);

    // Number tokens (standard distribution)
    let numbers = [2,3,3,4,4,5,5,6,6,8,8,9,9,10,10,11,11,12];
    shuffle(numbers);

    let tIdx = 0;
    let nIdx = 0;
    for (let r = 0; r < HEX_ROWS.length; r++) {
      for (let c = 0; c < HEX_ROWS[r]; c++) {
        const pos = hexCenter(r, c);
        const terrain = terrains[tIdx];
        let num = 0;
        if (terrain !== 'desert') {
          num = numbers[nIdx++];
        } else {
          robberTile = tIdx;
        }
        tiles.push({
          row: r, col: c, x: pos.x, y: pos.y,
          terrain, number: num, hasRobber: terrain === 'desert'
        });
        tIdx++;
      }
    }

    // Generate vertices (hex corners / intersections)
    generateVerticesAndEdges();
  }

  function generateVerticesAndEdges() {
    vertices = [];
    edges = [];
    const vMap = new Map(); // key -> vertex index

    function vKey(x, y) {
      return Math.round(x * 10) + ',' + Math.round(y * 10);
    }

    // For each tile, compute 6 corners
    for (let t = 0; t < tiles.length; t++) {
      const tile = tiles[t];
      tile.vertexIds = [];
      for (let i = 0; i < 6; i++) {
        const corner = hexCorner(tile.x, tile.y, HEX_SIZE, i);
        const key = vKey(corner.x, corner.y);
        if (!vMap.has(key)) {
          vMap.set(key, vertices.length);
          vertices.push({
            x: corner.x, y: corner.y,
            building: null, // {player, type:'settlement'|'city'}
            adjacentTiles: [],
            adjacentVertices: [],
            adjacentEdges: []
          });
        }
        const vi = vMap.get(key);
        tile.vertexIds.push(vi);
        if (!vertices[vi].adjacentTiles.includes(t)) {
          vertices[vi].adjacentTiles.push(t);
        }
      }
    }

    // Build edges from tile vertex pairs
    const eMap = new Map();
    function eKey(a, b) {
      return Math.min(a, b) + '-' + Math.max(a, b);
    }

    for (let t = 0; t < tiles.length; t++) {
      const vids = tiles[t].vertexIds;
      for (let i = 0; i < 6; i++) {
        const a = vids[i], b = vids[(i + 1) % 6];
        const key = eKey(a, b);
        if (!eMap.has(key)) {
          eMap.set(key, edges.length);
          edges.push({
            v1: a, v2: b,
            road: null // player index or null
          });
        }
        const ei = eMap.get(key);
        if (!vertices[a].adjacentEdges.includes(ei)) vertices[a].adjacentEdges.push(ei);
        if (!vertices[b].adjacentEdges.includes(ei)) vertices[b].adjacentEdges.push(ei);
        if (!vertices[a].adjacentVertices.includes(b)) vertices[a].adjacentVertices.push(b);
        if (!vertices[b].adjacentVertices.includes(a)) vertices[b].adjacentVertices.push(a);
      }
    }
  }

  // ====== PLAYER ======
  function createPlayer(idx) {
    return {
      index: idx,
      resources: { wood: 0, brick: 0, ore: 0, grain: 0, sheep: 0 },
      roads: 0,
      settlements: 0,
      cities: 0,
      vp: 0,
      hasLongestRoad: false,
      knightsPlayed: 0,
      hasLargestArmy: false
    };
  }

  // ====== UTILITY ======
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function canAfford(player, cost) {
    for (const r in cost) {
      if ((player.resources[r] || 0) < cost[r]) return false;
    }
    return true;
  }

  function payCost(player, cost) {
    for (const r in cost) {
      player.resources[r] -= cost[r];
    }
  }

  function totalResources(player) {
    let t = 0;
    for (const r of RES_NAMES) t += player.resources[r];
    return t;
  }

  function addMsg(msg) {
    messageLog.unshift(msg);
    if (messageLog.length > 5) messageLog.pop();
    messageTimer = 180;
  }

  // ====== SETUP PHASE ======
  function initGame() {
    generateBoard();
    players = [];
    for (let i = 0; i < 4; i++) players.push(createPlayer(i));
    currentPlayer = 0;
    setupPhase = 1;
    setupStep = 'settlement';
    setupPlayerIdx = 0;
    gameState = 'playing';
    turnPhase = 'setup';
    selectedAction = null;
    tradeOpen = false;
    longestRoadPlayer = -1;
    longestRoadLen = 0;
    messageLog = [];
    addMsg('Setup: Place your first settlement');
    draw();
  }

  function getSetupOrder() {
    // Round 1: 0,1,2,3  Round 2: 3,2,1,0
    if (setupPhase === 1) return [0, 1, 2, 3];
    if (setupPhase === 2) return [3, 2, 1, 0];
    return [];
  }

  function advanceSetup() {
    const order = getSetupOrder();
    if (setupStep === 'settlement') {
      setupStep = 'road';
      return;
    }
    // After road placement
    setupStep = 'settlement';
    setupPlayerIdx++;
    if (setupPlayerIdx >= 4) {
      if (setupPhase === 1) {
        setupPhase = 2;
        setupPlayerIdx = 0;
        // Second round resources
      } else {
        // Setup complete, give resources for second settlements
        for (let p = 0; p < 4; p++) {
          // Find second settlement and give resources from adjacent tiles
          let settlementCount = 0;
          for (const v of vertices) {
            if (v.building && v.building.player === p && v.building.type === 'settlement') {
              settlementCount++;
              if (settlementCount === 2) {
                for (const ti of v.adjacentTiles) {
                  const res = TERRAIN_RES[tiles[ti].terrain];
                  if (res) players[p].resources[res]++;
                }
              }
            }
          }
        }
        setupPhase = 0;
        currentPlayer = 0;
        turnPhase = 'roll';
        addMsg('Game started! Click dice to roll');
        updateVP();
        draw();
        return;
      }
    }
    currentPlayer = order[setupPlayerIdx];
    if (currentPlayer !== 0) {
      // AI setup
      setTimeout(() => aiSetup(currentPlayer), 400);
    } else {
      addMsg('Place your ' + (setupPhase === 1 ? 'first' : 'second') + ' settlement');
    }
    draw();
  }

  // ====== VALID PLACEMENTS ======
  function getValidSettlementVertices(playerIdx, isSetup) {
    const valid = [];
    for (let vi = 0; vi < vertices.length; vi++) {
      if (vertices[vi].building) continue;
      // Distance rule: no adjacent buildings
      let tooClose = false;
      for (const adj of vertices[vi].adjacentVertices) {
        if (vertices[adj].building) { tooClose = true; break; }
      }
      if (tooClose) continue;
      if (isSetup) {
        valid.push(vi);
      } else {
        // Must be connected to player's road network
        let connected = false;
        for (const ei of vertices[vi].adjacentEdges) {
          if (edges[ei].road === playerIdx) { connected = true; break; }
        }
        if (connected) valid.push(vi);
      }
    }
    return valid;
  }

  function getValidRoadEdges(playerIdx, fromVertex) {
    const valid = [];
    for (let ei = 0; ei < edges.length; ei++) {
      if (edges[ei].road !== null) continue;
      const e = edges[ei];
      if (fromVertex !== undefined) {
        if (e.v1 === fromVertex || e.v2 === fromVertex) valid.push(ei);
        continue;
      }
      // Must connect to player's building or road
      let connected = false;
      for (const vi of [e.v1, e.v2]) {
        if (vertices[vi].building && vertices[vi].building.player === playerIdx) {
          connected = true; break;
        }
        for (const adjE of vertices[vi].adjacentEdges) {
          if (adjE !== ei && edges[adjE].road === playerIdx) {
            // Check that vertex isn't blocked by another player's building
            if (!vertices[vi].building || vertices[vi].building.player === playerIdx) {
              connected = true; break;
            }
          }
        }
        if (connected) break;
      }
      if (connected) valid.push(ei);
    }
    return valid;
  }

  function getValidCityVertices(playerIdx) {
    const valid = [];
    for (let vi = 0; vi < vertices.length; vi++) {
      if (vertices[vi].building && vertices[vi].building.player === playerIdx && vertices[vi].building.type === 'settlement') {
        valid.push(vi);
      }
    }
    return valid;
  }

  // ====== BUILDING ======
  function placeSettlement(vi, playerIdx, isSetup) {
    vertices[vi].building = { player: playerIdx, type: 'settlement' };
    players[playerIdx].settlements++;
    if (!isSetup) payCost(players[playerIdx], BUILD_COSTS.settlement);
    updateVP();
  }

  function placeRoad(ei, playerIdx, isSetup) {
    edges[ei].road = playerIdx;
    players[playerIdx].roads++;
    if (!isSetup) payCost(players[playerIdx], BUILD_COSTS.road);
    updateLongestRoad();
  }

  function placeCity(vi, playerIdx) {
    vertices[vi].building = { player: playerIdx, type: 'city' };
    players[playerIdx].settlements--;
    players[playerIdx].cities++;
    payCost(players[playerIdx], BUILD_COSTS.city);
    updateVP();
  }

  // ====== LONGEST ROAD ======
  function calcLongestRoad(playerIdx) {
    // DFS from each road endpoint
    let best = 0;
    const playerEdges = [];
    for (let ei = 0; ei < edges.length; ei++) {
      if (edges[ei].road === playerIdx) playerEdges.push(ei);
    }

    function dfs(vertex, visited) {
      let maxLen = 0;
      for (const ei of vertices[vertex].adjacentEdges) {
        if (edges[ei].road !== playerIdx) continue;
        if (visited.has(ei)) continue;
        // Check if blocked by opponent building
        const nextV = edges[ei].v1 === vertex ? edges[ei].v2 : edges[ei].v1;
        if (vertices[nextV].building && vertices[nextV].building.player !== playerIdx) continue;
        visited.add(ei);
        const len = 1 + dfs(nextV, visited);
        if (len > maxLen) maxLen = len;
        visited.delete(ei);
      }
      return maxLen;
    }

    for (const ei of playerEdges) {
      for (const startV of [edges[ei].v1, edges[ei].v2]) {
        const visited = new Set([ei]);
        const len = 1 + dfs(edges[ei].v1 === startV ? edges[ei].v2 : startV, visited);
        if (len > best) best = len;
      }
    }
    return best;
  }

  function updateLongestRoad() {
    let bestPlayer = -1, bestLen = 0;
    for (let p = 0; p < 4; p++) {
      const len = calcLongestRoad(p);
      if (len >= 5 && len > bestLen) {
        bestLen = len;
        bestPlayer = p;
      }
    }
    for (let p = 0; p < 4; p++) players[p].hasLongestRoad = false;
    if (bestPlayer >= 0) {
      players[bestPlayer].hasLongestRoad = true;
      if (longestRoadPlayer !== bestPlayer) {
        longestRoadPlayer = bestPlayer;
        longestRoadLen = bestLen;
        addMsg(PLAYER_NAMES[bestPlayer] + ' has Longest Road (' + bestLen + ')');
      }
    }
    updateVP();
  }

  // ====== VP ======
  function updateVP() {
    for (let p = 0; p < 4; p++) {
      let vp = players[p].settlements + players[p].cities * 2;
      if (players[p].hasLongestRoad) vp += 2;
      if (players[p].hasLargestArmy) vp += 2;
      players[p].vp = vp;
    }
    score = players[0].vp;
    vpSpan.textContent = 'VP: ' + score + ' / 10';
    checkWin();
  }

  function checkWin() {
    for (let p = 0; p < 4; p++) {
      if (players[p].vp >= 10) {
        gameState = 'over';
        if (p === 0) {
          addMsg('You win with ' + players[p].vp + ' VP!');
        } else {
          addMsg(PLAYER_NAMES[p] + ' wins with ' + players[p].vp + ' VP!');
        }
        draw();
        return true;
      }
    }
    return false;
  }

  // ====== DICE & RESOURCES ======
  function rollDice() {
    const d1 = Math.floor(Math.random() * 6) + 1;
    const d2 = Math.floor(Math.random() * 6) + 1;
    diceRoll = [d1, d2];
    lastDice = [d1, d2];
    const total = d1 + d2;
    addMsg(PLAYER_NAMES[currentPlayer] + ' rolled ' + total);

    if (total === 7) {
      // Discard half for players with 8+ resources
      for (let p = 0; p < 4; p++) {
        const t = totalResources(players[p]);
        if (t > 7) {
          const discard = Math.floor(t / 2);
          for (let d = 0; d < discard; d++) {
            // Discard random resource
            const owned = RES_NAMES.filter(r => players[p].resources[r] > 0);
            if (owned.length > 0) {
              const r = owned[Math.floor(Math.random() * owned.length)];
              players[p].resources[r]--;
            }
          }
          if (p === 0) addMsg('You discarded ' + discard + ' cards');
        }
      }
      // Move robber handled by AI or skip for simplicity
      // Move robber to random non-desert tile
      let newRobber;
      do {
        newRobber = Math.floor(Math.random() * tiles.length);
      } while (newRobber === robberTile);
      tiles[robberTile].hasRobber = false;
      robberTile = newRobber;
      tiles[robberTile].hasRobber = true;
      addMsg('Robber moved!');
    } else {
      // Produce resources
      for (let t = 0; t < tiles.length; t++) {
        if (tiles[t].number === total && !tiles[t].hasRobber) {
          const res = TERRAIN_RES[tiles[t].terrain];
          if (!res) continue;
          for (const vi of tiles[t].vertexIds) {
            if (vertices[vi].building) {
              const b = vertices[vi].building;
              const amount = b.type === 'city' ? 2 : 1;
              players[b.player].resources[res] += amount;
            }
          }
        }
      }
    }
    turnPhase = 'build';
  }

  // ====== TRADING ======
  function bankTrade(playerIdx, give, want) {
    // 4:1 trade
    if (players[playerIdx].resources[give] >= 4) {
      players[playerIdx].resources[give] -= 4;
      players[playerIdx].resources[want] += 1;
      if (playerIdx === 0) addMsg('Traded 4 ' + give + ' for 1 ' + want);
      return true;
    }
    return false;
  }

  function aiTradeWithPlayer(aiIdx, give, want, amount) {
    // AI offers trade to human
    if (players[aiIdx].resources[give] >= amount && players[0].resources[want] >= amount) {
      // Auto-accept fair trades for simplicity (AI gives what player might need)
      return { from: aiIdx, give, want, amount };
    }
    return null;
  }

  // ====== AI ======
  function aiSetup(playerIdx) {
    if (setupStep === 'settlement') {
      const valid = getValidSettlementVertices(playerIdx, true);
      if (valid.length === 0) { advanceSetup(); return; }
      // Score vertices by resource diversity and number quality
      let best = -1, bestScore = -Infinity;
      for (const vi of valid) {
        let s = 0;
        const resSet = new Set();
        for (const ti of vertices[vi].adjacentTiles) {
          const res = TERRAIN_RES[tiles[ti].terrain];
          if (res) {
            resSet.add(res);
            // Higher probability numbers score higher
            const n = tiles[ti].number;
            s += 6 - Math.abs(7 - n); // 6,8=5pts, 5,9=4pts, etc.
          }
        }
        s += resSet.size * 3; // Diversity bonus
        s += Math.random() * 2; // Slight randomness
        if (s > bestScore) { bestScore = s; best = vi; }
      }
      placeSettlement(best, playerIdx, true);
      setupStep = 'road';
      draw();
      setTimeout(() => aiSetup(playerIdx), 300);
    } else {
      // Place road adjacent to last settlement
      let lastSettlement = -1;
      for (let vi = 0; vi < vertices.length; vi++) {
        if (vertices[vi].building && vertices[vi].building.player === playerIdx) {
          lastSettlement = vi;
        }
      }
      const valid = getValidRoadEdges(playerIdx, lastSettlement);
      if (valid.length > 0) {
        const ei = valid[Math.floor(Math.random() * valid.length)];
        placeRoad(ei, playerIdx, true);
      }
      advanceSetup();
    }
  }

  function aiTurn(playerIdx) {
    if (gameState !== 'playing') return;
    turnPhase = 'roll';
    addMsg(PLAYER_NAMES[playerIdx] + "'s turn");
    draw();

    setTimeout(() => {
      rollDice();
      draw();
      if (checkWin()) return;

      setTimeout(() => {
        aiBuilding(playerIdx);
      }, 400);
    }, 500);
  }

  function aiBuilding(playerIdx) {
    if (gameState !== 'playing') return;
    const p = players[playerIdx];
    let built = false;

    // Strategy: prioritize cities, then settlements, then roads
    // Try to trade for missing resources first
    aiSmartTrade(playerIdx);

    // Try to build city
    if (canAfford(p, BUILD_COSTS.city)) {
      const valid = getValidCityVertices(playerIdx);
      if (valid.length > 0) {
        // Pick city on best production spot
        let best = valid[0], bestVal = -1;
        for (const vi of valid) {
          let val = 0;
          for (const ti of vertices[vi].adjacentTiles) {
            const n = tiles[ti].number;
            val += 6 - Math.abs(7 - n);
          }
          if (val > bestVal) { bestVal = val; best = vi; }
        }
        placeCity(best, playerIdx);
        addMsg(PLAYER_NAMES[playerIdx] + ' built a city');
        built = true;
      }
    }

    // Try to build settlement
    if (canAfford(p, BUILD_COSTS.settlement)) {
      const valid = getValidSettlementVertices(playerIdx, false);
      if (valid.length > 0) {
        let best = valid[0], bestVal = -1;
        for (const vi of valid) {
          let val = 0;
          const resSet = new Set();
          for (const ti of vertices[vi].adjacentTiles) {
            const res = TERRAIN_RES[tiles[ti].terrain];
            if (res) {
              resSet.add(res);
              val += 6 - Math.abs(7 - tiles[ti].number);
            }
          }
          val += resSet.size * 2;
          // Bonus for blocking player 0
          for (const adj of vertices[vi].adjacentVertices) {
            if (vertices[adj].building && vertices[adj].building.player === 0) val += 3;
          }
          if (val > bestVal) { bestVal = val; best = vi; }
        }
        placeSettlement(best, playerIdx, false);
        addMsg(PLAYER_NAMES[playerIdx] + ' built a settlement');
        built = true;
      }
    }

    // Try to build roads (toward good spots)
    if (canAfford(p, BUILD_COSTS.road) && p.roads < 13) {
      const valid = getValidRoadEdges(playerIdx);
      if (valid.length > 0) {
        // Prefer roads toward valid settlement spots
        let best = valid[Math.floor(Math.random() * valid.length)];
        let bestVal = -1;
        for (const ei of valid) {
          const e = edges[ei];
          let val = Math.random() * 2;
          // Check if either endpoint is near a good settlement spot
          for (const vi of [e.v1, e.v2]) {
            if (!vertices[vi].building) {
              let tooClose = false;
              for (const adj of vertices[vi].adjacentVertices) {
                if (vertices[adj].building) tooClose = true;
              }
              if (!tooClose) {
                for (const ti of vertices[vi].adjacentTiles) {
                  val += (6 - Math.abs(7 - tiles[ti].number)) * 0.5;
                }
              }
            }
          }
          if (val > bestVal) { bestVal = val; best = ei; }
        }
        placeRoad(best, playerIdx, false);
        built = true;
      }
    }

    draw();
    if (checkWin()) return;
    nextPlayer();
  }

  function aiSmartTrade(playerIdx) {
    const p = players[playerIdx];
    // Check what AI needs
    const needs = [];
    if (canAlmostAfford(p, BUILD_COSTS.city)) {
      for (const r in BUILD_COSTS.city) {
        if (p.resources[r] < BUILD_COSTS.city[r]) needs.push(r);
      }
    }
    if (canAlmostAfford(p, BUILD_COSTS.settlement)) {
      for (const r in BUILD_COSTS.settlement) {
        if (p.resources[r] < BUILD_COSTS.settlement[r]) needs.push(r);
      }
    }

    // Try bank trade if have 4+ of something
    for (const r of RES_NAMES) {
      if (p.resources[r] >= 4 && needs.length > 0) {
        const want = needs[0];
        if (want !== r) {
          bankTrade(playerIdx, r, want);
          addMsg(PLAYER_NAMES[playerIdx] + ' bank traded');
          return;
        }
      }
    }
  }

  function canAlmostAfford(player, cost) {
    let missing = 0;
    for (const r in cost) {
      if (player.resources[r] < cost[r]) missing += cost[r] - player.resources[r];
    }
    return missing <= 2;
  }

  function nextPlayer() {
    currentPlayer = (currentPlayer + 1) % 4;
    turnPhase = 'roll';
    selectedAction = null;
    tradeOpen = false;
    if (gameState !== 'playing') return;

    if (currentPlayer === 0) {
      turnSpan.textContent = 'Your Turn - Roll Dice';
      addMsg('Your turn! Click dice to roll');
    } else {
      turnSpan.textContent = PLAYER_NAMES[currentPlayer] + "'s Turn";
      setTimeout(() => aiTurn(currentPlayer), 600);
    }
    draw();
  }

  // ====== RENDERING ======
  function draw() {
    animFrame++;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, W, H);

    if (gameState === 'title') {
      drawTitle();
      return;
    }

    drawBoard();
    drawBuildings();
    drawRoads();
    drawUI();

    if (gameState === 'over') {
      drawGameOver();
    }
  }

  function drawTitle() {
    ctx.fillStyle = '#e84';
    ctx.font = 'bold 36px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('Settlers Online', W / 2, 160);

    ctx.font = '16px Courier New';
    ctx.fillStyle = '#aaa';
    ctx.fillText('Trade, Build, Settle', W / 2, 200);
    ctx.fillText('2-4 Players (You vs 3 AI)', W / 2, 225);

    // Draw mini hex
    for (let i = 0; i < 6; i++) {
      const a1 = Math.PI / 180 * (60 * i - 30);
      const a2 = Math.PI / 180 * (60 * ((i+1)%6) - 30);
      ctx.strokeStyle = '#e84';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W/2 + 40*Math.cos(a1), 290 + 40*Math.sin(a1));
      ctx.lineTo(W/2 + 40*Math.cos(a2), 290 + 40*Math.sin(a2));
      ctx.stroke();
    }

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 20px Courier New';
    ctx.fillText('Click to Start', W / 2, 380);

    // Glow animation
    const glow = 0.3 + 0.2 * Math.sin(animFrame * 0.05);
    ctx.shadowColor = '#e84';
    ctx.shadowBlur = 20 * glow;
    ctx.strokeStyle = '#e84';
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2 - 100, 360, 200, 35);
    ctx.shadowBlur = 0;
  }

  function drawHex(cx, cy, size, fillColor, strokeColor) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const corner = hexCorner(cx, cy, size, i);
      if (i === 0) ctx.moveTo(corner.x, corner.y);
      else ctx.lineTo(corner.x, corner.y);
    }
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor || '#333';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  function drawBoard() {
    // Draw sea background
    ctx.fillStyle = '#1a3a5c';
    ctx.beginPath();
    ctx.arc(BOARD_CX, BOARD_CY, HEX_SIZE * 4.5, 0, Math.PI * 2);
    ctx.fill();

    // Draw tiles
    for (let t = 0; t < tiles.length; t++) {
      const tile = tiles[t];
      let color = TERRAIN_COLORS[tile.terrain];
      if (tile.hasRobber) {
        color = '#444';
      }
      drawHex(tile.x, tile.y, HEX_SIZE - 1, color, '#2a2a4e');

      // Draw number token
      if (tile.number > 0 && !tile.hasRobber) {
        ctx.fillStyle = '#f5f0dc';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#c00' : '#333';
        ctx.fillText(tile.number, tile.x, tile.y);

        // Probability dots
        const dots = 6 - Math.abs(7 - tile.number);
        ctx.fillStyle = (tile.number === 6 || tile.number === 8) ? '#c00' : '#666';
        for (let d = 0; d < dots; d++) {
          ctx.fillRect(tile.x - dots * 2.5 + d * 5, tile.y + 10, 2, 2);
        }
      }

      // Robber
      if (tile.hasRobber) {
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(tile.x, tile.y - 5, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(tile.x - 5, tile.y + 3, 10, 8);
        ctx.fillStyle = '#e84';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('R', tile.x, tile.y - 3);
      }

      // Terrain letter
      if (!tile.hasRobber) {
        ctx.font = '7px Courier New';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.textAlign = 'center';
        const label = tile.terrain.substring(0,3).toUpperCase();
        ctx.fillText(label, tile.x, tile.y + 22);
      }
    }
  }

  function drawRoads() {
    for (let ei = 0; ei < edges.length; ei++) {
      const e = edges[ei];
      if (e.road === null) continue;
      const v1 = vertices[e.v1], v2 = vertices[e.v2];
      ctx.strokeStyle = PLAYER_COLORS[e.road];
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(v1.x, v1.y);
      ctx.lineTo(v2.x, v2.y);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // Draw hover road
    if (hoverEdge >= 0 && selectedAction === 'road' && currentPlayer === 0) {
      const e = edges[hoverEdge];
      const v1 = vertices[e.v1], v2 = vertices[e.v2];
      ctx.strokeStyle = 'rgba(68,170,255,0.5)';
      ctx.lineWidth = 4;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(v1.x, v1.y);
      ctx.lineTo(v2.x, v2.y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.lineWidth = 1;
    }
  }

  function drawBuildings() {
    for (let vi = 0; vi < vertices.length; vi++) {
      const v = vertices[vi];
      if (!v.building) continue;
      const color = PLAYER_COLORS[v.building.player];
      if (v.building.type === 'settlement') {
        // Small house
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(v.x, v.y - 8);
        ctx.lineTo(v.x + 6, v.y - 2);
        ctx.lineTo(v.x + 6, v.y + 5);
        ctx.lineTo(v.x - 6, v.y + 5);
        ctx.lineTo(v.x - 6, v.y - 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        // City - larger building
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(v.x - 3, v.y - 10);
        ctx.lineTo(v.x + 4, v.y - 5);
        ctx.lineTo(v.x + 8, v.y - 5);
        ctx.lineTo(v.x + 8, v.y + 6);
        ctx.lineTo(v.x - 8, v.y + 6);
        ctx.lineTo(v.x - 8, v.y - 2);
        ctx.lineTo(v.x - 3, v.y - 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // Draw valid placement indicators
    if (currentPlayer === 0 && gameState === 'playing') {
      if ((selectedAction === 'settlement' || (turnPhase === 'setup' && setupStep === 'settlement')) && getSetupOrder()[setupPlayerIdx] === 0 || selectedAction === 'settlement') {
        const isSetup = turnPhase === 'setup';
        if (isSetup || selectedAction === 'settlement') {
          const valid = getValidSettlementVertices(0, isSetup);
          for (const vi of valid) {
            ctx.fillStyle = vi === hoverVertex ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.25)';
            ctx.beginPath();
            ctx.arc(vertices[vi].x, vertices[vi].y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      if (selectedAction === 'city') {
        const valid = getValidCityVertices(0);
        for (const vi of valid) {
          ctx.fillStyle = vi === hoverVertex ? 'rgba(68,170,255,0.7)' : 'rgba(68,170,255,0.25)';
          ctx.beginPath();
          ctx.arc(vertices[vi].x, vertices[vi].y, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      if (turnPhase === 'setup' && setupStep === 'road' && getSetupOrder()[setupPlayerIdx] === 0) {
        // Find last settlement placed by player
        let lastS = -1;
        for (let vi = 0; vi < vertices.length; vi++) {
          if (vertices[vi].building && vertices[vi].building.player === 0) lastS = vi;
        }
        const valid = getValidRoadEdges(0, lastS);
        for (const ei of valid) {
          const e = edges[ei];
          const v1 = vertices[e.v1], v2 = vertices[e.v2];
          ctx.strokeStyle = ei === hoverEdge ? 'rgba(68,170,255,0.6)' : 'rgba(68,170,255,0.2)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(v1.x, v1.y);
          ctx.lineTo(v2.x, v2.y);
          ctx.stroke();
          ctx.lineWidth = 1;
        }
      }
    }
  }

  function drawUI() {
    const panelX = 430;
    const panelW = 160;

    // === DICE ===
    const diceY = 12;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, diceY, panelW, 52);
    ctx.strokeStyle = '#e84';
    ctx.lineWidth = 1;
    ctx.strokeRect(panelX, diceY, panelW, 52);

    // Draw dice
    const d1x = panelX + 35, d2x = panelX + 95, dy = diceY + 26;
    drawDie(d1x, dy, lastDice[0]);
    drawDie(d2x, dy, lastDice[1]);

    if (currentPlayer === 0 && turnPhase === 'roll') {
      ctx.fillStyle = '#e84';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('CLICK TO ROLL', panelX + panelW/2, diceY + 48);
    } else if (lastDice[0] > 0) {
      ctx.fillStyle = '#888';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Rolled: ' + (lastDice[0]+lastDice[1]), panelX + panelW/2, diceY + 48);
    }

    // === RESOURCES ===
    const resY = 70;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, resY, panelW, 90);
    ctx.strokeStyle = '#e84';
    ctx.strokeRect(panelX, resY, panelW, 90);

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('RESOURCES', panelX + 8, resY + 14);

    const res = players[0].resources;
    const resIcons = [
      {name:'wood', icon:'W', color:'#3a7a2a'},
      {name:'brick', icon:'B', color:'#b85c38'},
      {name:'ore', icon:'O', color:'#888'},
      {name:'grain', icon:'G', color:'#d4a017'},
      {name:'sheep', icon:'S', color:'#6db84a'}
    ];
    for (let i = 0; i < 5; i++) {
      const ry = resY + 22 + i * 13;
      ctx.fillStyle = resIcons[i].color;
      ctx.fillRect(panelX + 8, ry - 6, 8, 8);
      ctx.fillStyle = '#ccc';
      ctx.font = '10px Courier New';
      ctx.fillText(resIcons[i].name.padEnd(6) + ': ' + res[resIcons[i].name], panelX + 20, ry);
    }

    // === BUILD MENU ===
    const buildY = 166;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, buildY, panelW, 120);
    ctx.strokeStyle = '#e84';
    ctx.strokeRect(panelX, buildY, panelW, 120);

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('BUILD', panelX + 8, buildY + 14);

    const buildOpts = [
      {key:'road', label:'Road', cost:'W+B', canBuild: currentPlayer===0 && turnPhase==='build' && canAfford(players[0], BUILD_COSTS.road)},
      {key:'settlement', label:'Settlement', cost:'W+B+G+S', canBuild: currentPlayer===0 && turnPhase==='build' && canAfford(players[0], BUILD_COSTS.settlement)},
      {key:'city', label:'City', cost:'3O+2G', canBuild: currentPlayer===0 && turnPhase==='build' && canAfford(players[0], BUILD_COSTS.city)},
    ];

    for (let i = 0; i < buildOpts.length; i++) {
      const by = buildY + 24 + i * 28;
      const opt = buildOpts[i];
      const active = selectedAction === opt.key;
      ctx.fillStyle = active ? 'rgba(238,136,68,0.3)' : 'rgba(255,255,255,0.05)';
      ctx.fillRect(panelX + 4, by - 4, panelW - 8, 24);
      if (active) {
        ctx.strokeStyle = '#e84';
        ctx.strokeRect(panelX + 4, by - 4, panelW - 8, 24);
      }
      ctx.fillStyle = opt.canBuild ? '#fff' : '#555';
      ctx.font = '10px Courier New';
      ctx.fillText(opt.label, panelX + 10, by + 6);
      ctx.fillStyle = opt.canBuild ? '#aaa' : '#444';
      ctx.font = '8px Courier New';
      ctx.fillText(opt.cost, panelX + 10, by + 16);
    }

    // End turn button
    const endY = buildY + 98;
    const canEnd = currentPlayer === 0 && turnPhase === 'build';
    ctx.fillStyle = canEnd ? 'rgba(238,136,68,0.2)' : 'rgba(255,255,255,0.03)';
    ctx.fillRect(panelX + 4, endY - 4, panelW - 8, 18);
    ctx.strokeStyle = canEnd ? '#e84' : '#333';
    ctx.strokeRect(panelX + 4, endY - 4, panelW - 8, 18);
    ctx.fillStyle = canEnd ? '#e84' : '#555';
    ctx.font = 'bold 10px Courier New';
    ctx.fillText('END TURN', panelX + 40, endY + 8);

    // === TRADE ===
    const tradeY = 292;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, tradeY, panelW, 78);
    ctx.strokeStyle = '#e84';
    ctx.strokeRect(panelX, tradeY, panelW, 78);

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('TRADE (4:1 Bank)', panelX + 8, tradeY + 14);

    if (tradeOpen && currentPlayer === 0 && turnPhase === 'build') {
      // Trade give/want selection
      ctx.fillStyle = '#aaa';
      ctx.font = '9px Courier New';
      ctx.fillText('Give: ' + (tradeOffer.give || '?'), panelX + 8, tradeY + 30);
      ctx.fillText('Want: ' + (tradeOffer.want || '?'), panelX + 8, tradeY + 43);

      // Resource buttons
      for (let i = 0; i < 5; i++) {
        const bx = panelX + 8 + i * 29;
        // Give row
        const hasEnough = players[0].resources[RES_NAMES[i]] >= 4;
        ctx.fillStyle = tradeOffer.give === RES_NAMES[i] ? '#e84' : (hasEnough ? '#555' : '#333');
        ctx.fillRect(bx, tradeY + 48, 26, 12);
        ctx.fillStyle = hasEnough ? '#fff' : '#666';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(RES_NAMES[i].substring(0,2).toUpperCase(), bx + 13, tradeY + 57);
        // Want row
        ctx.fillStyle = tradeOffer.want === RES_NAMES[i] ? '#4af' : '#555';
        ctx.fillRect(bx, tradeY + 62, 26, 12);
        ctx.fillStyle = '#fff';
        ctx.fillText(RES_NAMES[i].substring(0,2).toUpperCase(), bx + 13, tradeY + 71);
      }
      ctx.textAlign = 'left';
    } else {
      const canTrade = currentPlayer === 0 && turnPhase === 'build';
      ctx.fillStyle = canTrade ? '#aaa' : '#555';
      ctx.font = '9px Courier New';
      ctx.fillText('Click to open trade', panelX + 8, tradeY + 35);
      ctx.fillText('Need 4 of same resource', panelX + 8, tradeY + 50);
    }

    // === VP TRACKER ===
    const vpY = 376;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, vpY, panelW, 100);
    ctx.strokeStyle = '#e84';
    ctx.strokeRect(panelX, vpY, panelW, 100);

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('VICTORY POINTS', panelX + 8, vpY + 14);

    for (let p = 0; p < 4; p++) {
      const py = vpY + 24 + p * 18;
      ctx.fillStyle = PLAYER_COLORS[p];
      ctx.fillRect(panelX + 8, py - 5, 8, 8);
      ctx.fillStyle = '#ccc';
      ctx.font = '10px Courier New';
      const name = (p === 0 ? 'You' : 'AI ' + p).padEnd(5);
      let extras = '';
      if (players[p].hasLongestRoad) extras += ' LR';
      if (players[p].hasLargestArmy) extras += ' LA';
      ctx.fillText(name + players[p].vp + ' VP' + extras, panelX + 20, py);
    }

    // === MESSAGES ===
    const msgY = 482;
    ctx.fillStyle = '#16213e';
    ctx.fillRect(panelX, msgY, panelW, 62);
    ctx.strokeStyle = '#333';
    ctx.strokeRect(panelX, msgY, panelW, 62);

    ctx.font = '8px Courier New';
    ctx.textAlign = 'left';
    for (let i = 0; i < Math.min(messageLog.length, 5); i++) {
      ctx.fillStyle = i === 0 ? '#e84' : '#666';
      const msg = messageLog[i].length > 24 ? messageLog[i].substring(0, 23) + '.' : messageLog[i];
      ctx.fillText(msg, panelX + 4, msgY + 12 + i * 11);
    }

    // === STATUS BAR at bottom of board ===
    if (turnPhase === 'setup') {
      const order = getSetupOrder();
      const cp = order[setupPlayerIdx];
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, H - 35, 425, 35);
      ctx.fillStyle = PLAYER_COLORS[cp];
      ctx.font = '12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(PLAYER_NAMES[cp] + ': Place ' + setupStep, 215, H - 15);
    }
  }

  function drawDie(cx, cy, value) {
    ctx.fillStyle = '#f5f0dc';
    ctx.beginPath();
    const r = 14;
    ctx.roundRect(cx - r, cy - r, r*2, r*2, 3);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.fillStyle = '#222';
    const dotR = 2.5;
    const positions = {
      1: [[0,0]],
      2: [[-5,-5],[5,5]],
      3: [[-5,-5],[0,0],[5,5]],
      4: [[-5,-5],[5,-5],[-5,5],[5,5]],
      5: [[-5,-5],[5,-5],[0,0],[-5,5],[5,5]],
      6: [[-5,-5],[5,-5],[-5,0],[5,0],[-5,5],[5,5]]
    };
    const dots = positions[value] || positions[1];
    for (const [dx, dy] of dots) {
      ctx.beginPath();
      ctx.arc(cx + dx, cy + dy, dotR, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawGameOver() {
    ctx.fillStyle = 'rgba(26,26,46,0.85)';
    ctx.fillRect(0, 0, W, H);

    let winner = 0;
    for (let p = 0; p < 4; p++) {
      if (players[p].vp >= 10) winner = p;
    }

    ctx.fillStyle = '#e84';
    ctx.font = 'bold 32px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#e84';
    ctx.shadowBlur = 20;
    if (winner === 0) {
      ctx.fillText('YOU WIN!', W / 2, H / 2 - 40);
    } else {
      ctx.fillText(PLAYER_NAMES[winner] + ' Wins!', W / 2, H / 2 - 40);
    }
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#aaa';
    ctx.font = '16px Courier New';
    ctx.fillText('Score: ' + players[winner].vp + ' Victory Points', W / 2, H / 2 + 10);

    for (let p = 0; p < 4; p++) {
      ctx.fillStyle = PLAYER_COLORS[p];
      ctx.font = '14px Courier New';
      ctx.fillText(PLAYER_NAMES[p] + ': ' + players[p].vp + ' VP', W / 2, H / 2 + 50 + p * 22);
    }

    ctx.fillStyle = '#e84';
    ctx.font = '14px Courier New';
    ctx.fillText('Click to play again', W / 2, H / 2 + 150);
  }

  // ====== INPUT ======
  C.addEventListener('mousemove', function(e) {
    const rect = C.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (W / rect.width);
    const my = (e.clientY - rect.top) * (H / rect.height);

    hoverVertex = -1;
    hoverEdge = -1;

    // Find closest vertex
    let minDist = 15;
    for (let vi = 0; vi < vertices.length; vi++) {
      const dx = vertices[vi].x - mx, dy = vertices[vi].y - my;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < minDist) { minDist = d; hoverVertex = vi; }
    }

    // Find closest edge
    let minEdgeDist = 10;
    for (let ei = 0; ei < edges.length; ei++) {
      const e = edges[ei];
      const v1 = vertices[e.v1], v2 = vertices[e.v2];
      const cx = (v1.x + v2.x) / 2, cy = (v1.y + v2.y) / 2;
      const dx = cx - mx, dy = cy - my;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < minEdgeDist) { minEdgeDist = d; hoverEdge = ei; }
    }

    draw();
  });

  C.addEventListener('click', function(e) {
    const rect = C.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (W / rect.width);
    const my = (e.clientY - rect.top) * (H / rect.height);

    if (gameState === 'title') {
      initGame();
      return;
    }

    if (gameState === 'over') {
      gameState = 'title';
      draw();
      return;
    }

    // === SETUP PHASE CLICKS ===
    if (turnPhase === 'setup' && getSetupOrder()[setupPlayerIdx] === 0) {
      if (setupStep === 'settlement') {
        const valid = getValidSettlementVertices(0, true);
        if (hoverVertex >= 0 && valid.includes(hoverVertex)) {
          placeSettlement(hoverVertex, 0, true);
          addMsg('Settlement placed!');
          advanceSetup();
          draw();
          return;
        }
      } else if (setupStep === 'road') {
        let lastS = -1;
        for (let vi = 0; vi < vertices.length; vi++) {
          if (vertices[vi].building && vertices[vi].building.player === 0) lastS = vi;
        }
        const valid = getValidRoadEdges(0, lastS);
        if (hoverEdge >= 0 && valid.includes(hoverEdge)) {
          placeRoad(hoverEdge, 0, true);
          addMsg('Road placed!');
          advanceSetup();
          draw();
          return;
        }
      }
      return;
    }

    if (currentPlayer !== 0) return;

    const panelX = 430;
    const panelW = 160;

    // === DICE CLICK ===
    if (turnPhase === 'roll') {
      if (mx >= panelX && mx <= panelX + panelW && my >= 12 && my <= 64) {
        rollDice();
        turnSpan.textContent = 'Your Turn - Build/Trade';
        draw();
        return;
      }
    }

    // === BUILD MENU CLICKS ===
    if (turnPhase === 'build') {
      const buildY = 166;
      const buildOpts = ['road', 'settlement', 'city'];
      for (let i = 0; i < 3; i++) {
        const by = buildY + 24 + i * 28;
        if (mx >= panelX + 4 && mx <= panelX + panelW - 4 && my >= by - 4 && my <= by + 20) {
          if (canAfford(players[0], BUILD_COSTS[buildOpts[i]])) {
            selectedAction = selectedAction === buildOpts[i] ? null : buildOpts[i];
            tradeOpen = false;
            draw();
            return;
          }
        }
      }

      // End turn button
      const endY = buildY + 98;
      if (mx >= panelX + 4 && mx <= panelX + panelW - 4 && my >= endY - 4 && my <= endY + 14) {
        selectedAction = null;
        nextPlayer();
        return;
      }

      // Trade panel
      const tradeY = 292;
      if (mx >= panelX && mx <= panelX + panelW && my >= tradeY && my <= tradeY + 78) {
        if (!tradeOpen) {
          tradeOpen = true;
          tradeOffer = { give: '', want: '' };
          selectedAction = null;
          draw();
          return;
        }
        // Resource button clicks
        for (let i = 0; i < 5; i++) {
          const bx = panelX + 8 + i * 29;
          // Give row
          if (mx >= bx && mx <= bx + 26 && my >= tradeY + 48 && my <= tradeY + 60) {
            if (players[0].resources[RES_NAMES[i]] >= 4) {
              tradeOffer.give = RES_NAMES[i];
              tryExecuteTrade();
            }
            draw();
            return;
          }
          // Want row
          if (mx >= bx && mx <= bx + 26 && my >= tradeY + 62 && my <= tradeY + 74) {
            tradeOffer.want = RES_NAMES[i];
            tryExecuteTrade();
            draw();
            return;
          }
        }
        return;
      }

      // === BOARD CLICKS (building) ===
      if (selectedAction === 'road' && hoverEdge >= 0) {
        const valid = getValidRoadEdges(0);
        if (valid.includes(hoverEdge)) {
          placeRoad(hoverEdge, 0, false);
          addMsg('Road built!');
          selectedAction = null;
          draw();
          return;
        }
      }
      if (selectedAction === 'settlement' && hoverVertex >= 0) {
        const valid = getValidSettlementVertices(0, false);
        if (valid.includes(hoverVertex)) {
          placeSettlement(hoverVertex, 0, false);
          addMsg('Settlement built!');
          selectedAction = null;
          draw();
          return;
        }
      }
      if (selectedAction === 'city' && hoverVertex >= 0) {
        const valid = getValidCityVertices(0);
        if (valid.includes(hoverVertex)) {
          placeCity(hoverVertex, 0);
          addMsg('City built!');
          selectedAction = null;
          draw();
          return;
        }
      }
    }
  });

  function tryExecuteTrade() {
    if (tradeOffer.give && tradeOffer.want && tradeOffer.give !== tradeOffer.want) {
      if (bankTrade(0, tradeOffer.give, tradeOffer.want)) {
        tradeOffer = { give: '', want: '' };
      }
    }
  }

  // ====== ANIMATION LOOP ======
  function gameLoop() {
    if (gameState === 'title') {
      draw();
    }
    requestAnimationFrame(gameLoop);
  }

  // ====== START ======
  gameState = 'title';
  draw();
  gameLoop();

  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

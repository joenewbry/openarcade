<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bike Trials MP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f4a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 170, 0.4); }
    h1 { color: #f4a; font-size: 1.8rem; text-shadow: 0 0 15px rgba(255, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f4a; }
    canvas {
      border: 2px solid #f4a;
      box-shadow: 0 0 20px rgba(255, 68, 170, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f4a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BIKE TRIALS MP</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BIKE TRIALS MP</h2>
      <p id="overlayText">Arrow Keys: UP=Gas DOWN=Brake LEFT/RIGHT=Lean<br>Race the ghost to the finish!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const THEME = '#f4a';
    const THEME_RGB = '255, 68, 170';
    const THEME_DIM = '#a24';
    const THEME_GLOW = 'rgba(255, 68, 170, 0.5)';

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('bikeTrialsBest') || '0');
    bestEl.textContent = bestScore;

    // Physics constants
    const GRAVITY = 0.45;
    const WHEEL_RADIUS = 12;
    const WHEELBASE = 40;
    const MAX_SPEED = 7;
    const THROTTLE_FORCE = 0.18;
    const BRAKE_FORCE = 0.12;
    const LEAN_TORQUE = 0.004;
    const ANGULAR_DAMPING = 0.92;
    const BOUNCE = 0.3;
    const FRICTION = 0.985;
    const MAX_LEAN = Math.PI * 0.55;

    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space',' '].includes(e.key)) e.preventDefault();
      keys[e.key] = true;

      if (gameState === 'waiting') {
        startGame();
      } else if (gameState === 'over') {
        if (e.key === ' ' || e.key === 'Enter') {
          if (finished) {
            nextLevel();
          } else {
            initGame();
            startGame();
          }
        }
      }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // Track generation
    let terrain = [];
    let checkpoints = [];
    let trackLength = 0;
    let currentLevel = 1;

    function generateTerrain(level) {
      terrain = [];
      checkpoints = [];
      const segW = 30;
      const numSegs = 300 + level * 80;
      trackLength = numSegs * segW;
      let x = -200;
      let y = 280;
      let lastFeature = 0;

      // Start flat
      for (let i = 0; i < 10; i++) {
        terrain.push({ x: x, y: y });
        x += segW;
      }

      for (let i = 10; i < numSegs; i++) {
        const progress = i / numSegs;
        const difficulty = 0.3 + progress * 0.7 + (level - 1) * 0.15;
        const featureChance = Math.random();
        const distSinceLast = i - lastFeature;

        if (distSinceLast > 5 && featureChance < 0.15 * difficulty) {
          // Hill
          const hillH = 30 + Math.random() * 50 * difficulty;
          const hillW = 4 + Math.floor(Math.random() * 4);
          for (let j = 0; j < hillW && i < numSegs; j++) {
            const t = j / (hillW - 1);
            const hf = Math.sin(t * Math.PI);
            terrain.push({ x: x, y: y - hillH * hf });
            x += segW;
            i++;
          }
          lastFeature = i;
        } else if (distSinceLast > 8 && featureChance < 0.28 * difficulty) {
          // Gap / canyon
          const gapW = 2 + Math.floor(Math.random() * 2 * difficulty);
          // Ramp up
          terrain.push({ x: x, y: y - 15 });
          x += segW; i++;
          if (i < numSegs) {
            terrain.push({ x: x, y: y - 30 });
            x += segW; i++;
          }
          // Gap - deep pit
          for (let j = 0; j < gapW && i < numSegs; j++) {
            terrain.push({ x: x, y: y + 80 });
            x += segW; i++;
          }
          // Landing ramp
          if (i < numSegs) {
            terrain.push({ x: x, y: y - 15 });
            x += segW; i++;
          }
          if (i < numSegs) {
            terrain.push({ x: x, y: y });
            x += segW; i++;
          }
          lastFeature = i;
        } else if (distSinceLast > 6 && featureChance < 0.4 * difficulty) {
          // Steep incline
          const dir = Math.random() < 0.5 ? -1 : 1;
          const steps = 3 + Math.floor(Math.random() * 3);
          for (let j = 0; j < steps && i < numSegs; j++) {
            y += dir * (8 + Math.random() * 12 * difficulty);
            y = Math.max(100, Math.min(340, y));
            terrain.push({ x: x, y: y });
            x += segW;
            i++;
          }
          lastFeature = i;
        } else if (distSinceLast > 10 && featureChance < 0.5 * difficulty) {
          // Bumpy section
          const bumps = 4 + Math.floor(Math.random() * 4);
          for (let j = 0; j < bumps && i < numSegs; j++) {
            const bumpH = 10 + Math.random() * 20 * difficulty;
            terrain.push({ x: x, y: y - bumpH * (j % 2 === 0 ? 1 : 0) });
            x += segW;
            i++;
          }
          lastFeature = i;
        } else {
          // Gentle undulation
          y += (Math.random() - 0.5) * 8;
          y = Math.max(100, Math.min(340, y));
          terrain.push({ x: x, y: y });
          x += segW;
        }
      }

      // Finish flat
      for (let i = 0; i < 10; i++) {
        terrain.push({ x: x, y: y });
        x += segW;
      }

      // Checkpoints every ~quarter
      const cpCount = 3;
      for (let i = 1; i <= cpCount; i++) {
        const idx = Math.floor((terrain.length * i) / (cpCount + 1));
        if (idx < terrain.length) {
          checkpoints.push({
            x: terrain[idx].x,
            y: terrain[idx].y - 60,
            reached: false,
            index: idx
          });
        }
      }
      // Finish line
      const lastIdx = terrain.length - 5;
      checkpoints.push({
        x: terrain[lastIdx].x,
        y: terrain[lastIdx].y - 60,
        reached: false,
        isFinish: true,
        index: lastIdx
      });
    }

    function getTerrainY(worldX) {
      for (let i = 0; i < terrain.length - 1; i++) {
        if (worldX >= terrain[i].x && worldX < terrain[i + 1].x) {
          const t = (worldX - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
          return terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
        }
      }
      if (terrain.length > 0) {
        if (worldX < terrain[0].x) return terrain[0].y;
        return terrain[terrain.length - 1].y;
      }
      return 280;
    }

    function getTerrainAngle(worldX) {
      for (let i = 0; i < terrain.length - 1; i++) {
        if (worldX >= terrain[i].x && worldX < terrain[i + 1].x) {
          const dx = terrain[i + 1].x - terrain[i].x;
          const dy = terrain[i + 1].y - terrain[i].y;
          return Math.atan2(dy, dx);
        }
      }
      return 0;
    }

    // Bike class
    class Bike {
      constructor(isGhost) {
        this.isGhost = isGhost;
        this.reset();
      }

      reset() {
        this.x = 50;
        this.y = 200;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.angularVel = 0;
        this.speed = 0;
        this.crashed = false;
        this.onGround = false;
        this.distance = 0;
      }

      update(throttle, brake, leanDir) {
        if (this.crashed) return;

        // Lean control
        this.angularVel += leanDir * LEAN_TORQUE;
        this.angularVel *= ANGULAR_DAMPING;
        this.angle += this.angularVel;

        // Gravity
        this.vy += GRAVITY;

        // Wheel positions in world space
        const cosA = Math.cos(this.angle);
        const sinA = Math.sin(this.angle);
        const halfWB = WHEELBASE / 2;

        const rearWX = this.x - cosA * halfWB;
        const rearWY = this.y - sinA * halfWB;
        const frontWX = this.x + cosA * halfWB;
        const frontWY = this.y + sinA * halfWB;

        const groundRear = getTerrainY(rearWX);
        const groundFront = getTerrainY(frontWX);

        let rearOnGround = false;
        let frontOnGround = false;

        // Rear wheel collision
        if (rearWY + WHEEL_RADIUS > groundRear) {
          rearOnGround = true;
          const penetration = (rearWY + WHEEL_RADIUS) - groundRear;
          this.y -= penetration * 0.7;
          this.vy *= -BOUNCE;
          if (Math.abs(this.vy) < 1) this.vy = 0;
          const targetAngle = getTerrainAngle(this.x);
          this.angle += (targetAngle - this.angle) * 0.08;
        }

        // Front wheel collision
        if (frontWY + WHEEL_RADIUS > groundFront) {
          frontOnGround = true;
          const penetration = (frontWY + WHEEL_RADIUS) - groundFront;
          this.y -= penetration * 0.7;
          this.vy *= -BOUNCE;
          if (Math.abs(this.vy) < 1) this.vy = 0;
          const targetAngle = getTerrainAngle(this.x);
          this.angle += (targetAngle - this.angle) * 0.08;
        }

        this.onGround = rearOnGround || frontOnGround;

        // Throttle / Brake
        if (this.onGround) {
          if (throttle) {
            const terrAngle = getTerrainAngle(this.x);
            this.vx += Math.cos(terrAngle) * THROTTLE_FORCE;
            this.vy += Math.sin(terrAngle) * THROTTLE_FORCE;
          }
          if (brake) {
            this.vx *= (1 - BRAKE_FORCE);
          }
          this.vx *= FRICTION;
        }

        // Apply velocity
        this.x += this.vx;
        this.y += this.vy;

        // Speed cap
        this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (this.speed > MAX_SPEED) {
          const ratio = MAX_SPEED / this.speed;
          this.vx *= ratio;
          this.vy *= ratio;
          this.speed = MAX_SPEED;
        }

        // Track distance
        this.distance = Math.max(this.distance, this.x - 50);

        // Crash detection - bike flipped too far
        if (Math.abs(this.angle) > MAX_LEAN) {
          this.crashed = true;
        }

        // Fell into pit
        if (this.y > 500) {
          this.crashed = true;
        }

        // Head collision with ground
        const headX = this.x - sinA * 28;
        const headY = this.y - cosA * 28;
        const headGround = getTerrainY(headX);
        if (headY > headGround - 3 && this.onGround) {
          this.crashed = true;
        }

        // Keep angle in range
        if (this.angle > Math.PI) this.angle -= Math.PI * 2;
        if (this.angle < -Math.PI) this.angle += Math.PI * 2;
      }

      draw(camX, camY, alpha) {
        ctx.save();
        const screenX = this.x - camX;
        const screenY = this.y - camY;
        ctx.translate(screenX, screenY);
        ctx.rotate(this.angle);
        ctx.globalAlpha = alpha;

        const color = this.isGhost ? 'rgba(255, 68, 170, 0.35)' : THEME;
        const bodyColor = this.isGhost ? 'rgba(255, 68, 170, 0.25)' : '#d38';
        const riderColor = this.isGhost ? 'rgba(200, 200, 200, 0.25)' : '#ccc';

        // Glow
        if (!this.isGhost) {
          ctx.shadowColor = THEME_GLOW;
          ctx.shadowBlur = 12;
        }

        const halfWB = WHEELBASE / 2;
        const wheelRot = (this.x * 0.15);

        // Rear wheel
        ctx.beginPath();
        ctx.arc(-halfWB, 0, WHEEL_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.stroke();
        for (let s = 0; s < 4; s++) {
          const sa = wheelRot + s * Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(-halfWB, 0);
          ctx.lineTo(-halfWB + Math.cos(sa) * WHEEL_RADIUS * 0.8, Math.sin(sa) * WHEEL_RADIUS * 0.8);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Front wheel
        ctx.beginPath();
        ctx.arc(halfWB, 0, WHEEL_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.stroke();
        for (let s = 0; s < 4; s++) {
          const sa = wheelRot + s * Math.PI / 2;
          ctx.beginPath();
          ctx.moveTo(halfWB, 0);
          ctx.lineTo(halfWB + Math.cos(sa) * WHEEL_RADIUS * 0.8, Math.sin(sa) * WHEEL_RADIUS * 0.8);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Frame
        ctx.beginPath();
        ctx.moveTo(-halfWB, 0);
        ctx.lineTo(-8, -10);
        ctx.lineTo(5, -12);
        ctx.lineTo(halfWB - 2, -4);
        ctx.lineTo(halfWB, 0);
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Seat + tank
        ctx.beginPath();
        ctx.moveTo(-12, -10);
        ctx.lineTo(-6, -18);
        ctx.lineTo(8, -20);
        ctx.lineTo(14, -14);
        ctx.fillStyle = bodyColor;
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Front forks
        ctx.beginPath();
        ctx.moveTo(10, -12);
        ctx.lineTo(halfWB, 0);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Rear swing arm
        ctx.beginPath();
        ctx.moveTo(-6, -4);
        ctx.lineTo(-halfWB, 0);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Exhaust
        ctx.beginPath();
        ctx.moveTo(-4, -4);
        ctx.lineTo(-halfWB + 4, 6);
        ctx.lineTo(-halfWB - 2, 6);
        ctx.strokeStyle = this.isGhost ? 'rgba(150,100,50,0.2)' : '#a64';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Handlebars
        ctx.beginPath();
        ctx.moveTo(10, -20);
        ctx.lineTo(16, -24);
        ctx.moveTo(10, -20);
        ctx.lineTo(6, -24);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Rider
        ctx.shadowBlur = 0;

        // Body
        ctx.beginPath();
        ctx.moveTo(-2, -18);
        ctx.lineTo(2, -32);
        ctx.strokeStyle = riderColor;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.arc(2, -37, 5, 0, Math.PI * 2);
        ctx.fillStyle = this.isGhost ? 'rgba(200,200,200,0.2)' : '#eee';
        ctx.fill();
        // Helmet
        ctx.beginPath();
        ctx.arc(2, -37, 5.5, -Math.PI, 0);
        ctx.strokeStyle = this.isGhost ? 'rgba(255,68,170,0.2)' : THEME;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Arms
        ctx.beginPath();
        ctx.moveTo(2, -28);
        ctx.lineTo(10, -20);
        ctx.strokeStyle = riderColor;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.moveTo(-2, -18);
        ctx.lineTo(-6, -8);
        ctx.lineTo(-2, -2);
        ctx.strokeStyle = riderColor;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }

    // Ghost AI
    let ghostData = [];
    let ghostFrame = 0;

    function generateGhostRun() {
      const ghost = new Bike(true);
      ghost.reset();
      const recording = [];
      const maxFrames = 12000;

      for (let f = 0; f < maxFrames; f++) {
        const terrAngle = getTerrainAngle(ghost.x + 30);
        const aheadY = getTerrainY(ghost.x + 60);
        const currentY = getTerrainY(ghost.x);

        let throttle = true;
        let brake = false;
        let lean = 0;

        // Lean into slopes
        if (terrAngle > 0.15) lean = 0.5;
        else if (terrAngle < -0.15) lean = -0.3;

        // Brake on steep descents
        if (terrAngle > 0.5 && ghost.speed > 4) {
          brake = true;
          throttle = false;
        }

        // Approaching gap - lean forward and full throttle
        if (aheadY - currentY > 30) {
          lean = 0.4;
          throttle = true;
          brake = false;
        }

        // In air - stabilize
        if (!ghost.onGround) {
          if (ghost.angle > 0.2) lean = -0.6;
          else if (ghost.angle < -0.2) lean = 0.6;
          else lean = 0;
        }

        // Correct excessive lean
        if (ghost.angle > 0.6) lean = -0.8;
        if (ghost.angle < -0.6) lean = 0.8;

        ghost.update(throttle, brake, lean);

        recording.push({
          x: ghost.x,
          y: ghost.y,
          angle: ghost.angle,
          speed: ghost.speed,
          crashed: ghost.crashed
        });

        if (ghost.crashed || ghost.x > terrain[terrain.length - 1].x - 100) break;
      }

      return recording;
    }

    // Game objects
    let player, ghostBike;
    let cameraX, cameraY;
    let timer, startTime;
    let checkpointBonus;
    let finished;
    let particles;
    let crashTimer;

    function initGame() {
      gameState = 'waiting';
      score = 0;
      scoreEl.textContent = '0';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BIKE TRIALS MP';
      overlayText.innerHTML = `Level ${currentLevel}<br>Arrow Keys: UP=Gas DOWN=Brake LEFT/RIGHT=Lean<br>Race the ghost to the finish!`;

      generateTerrain(currentLevel);
      player = new Bike(false);
      ghostBike = new Bike(true);
      ghostData = generateGhostRun();
      ghostFrame = 0;
      cameraX = 0;
      cameraY = 0;
      timer = 0;
      startTime = 0;
      checkpointBonus = 0;
      finished = false;
      particles = [];
      crashTimer = 0;

      for (const cp of checkpoints) cp.reached = false;
    }

    function startGame() {
      if (gameState !== 'waiting') return;
      gameState = 'playing';
      startTime = performance.now();
      overlay.style.display = 'none';
    }

    function endGame(didFinish) {
      gameState = 'over';
      finished = didFinish;

      const timePenalty = Math.floor(timer * 2);
      const distScore = Math.floor(player.distance);
      score = Math.max(0, distScore + checkpointBonus - timePenalty);
      scoreEl.textContent = score;

      if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = bestScore;
        localStorage.setItem('bikeTrialsBest', bestScore.toString());
      }

      overlay.style.display = 'flex';
      if (didFinish) {
        overlayTitle.textContent = 'LEVEL COMPLETE!';
        overlayText.innerHTML = `Distance: ${distScore}m + Checkpoints: ${checkpointBonus} - Time: ${timePenalty}<br>Score: ${score}<br><br>Press SPACE or ENTER for next level`;
      } else {
        overlayTitle.textContent = 'CRASHED!';
        overlayText.innerHTML = `Distance: ${distScore}m | Score: ${score}<br><br>Press SPACE or ENTER to retry`;
      }
    }

    function nextLevel() {
      currentLevel++;
      generateTerrain(currentLevel);
      player = new Bike(false);
      ghostBike = new Bike(true);
      ghostData = generateGhostRun();
      ghostFrame = 0;
      cameraX = 0;
      cameraY = 0;
      timer = 0;
      startTime = performance.now();
      checkpointBonus = 0;
      finished = false;
      particles = [];
      crashTimer = 0;
      score = 0;
      scoreEl.textContent = '0';
      for (const cp of checkpoints) cp.reached = false;
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    // Particles
    function spawnParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 1) * 4,
          life: 30 + Math.random() * 30,
          maxLife: 60,
          color: color || THEME,
          size: 1.5 + Math.random() * 2.5
        });
      }
    }

    // Main update
    function update() {
      if (gameState === 'crashed') {
        // Animate crash for a bit then show overlay
        crashTimer++;
        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.08;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }
        if (crashTimer > 50) {
          endGame(false);
        }
        return;
      }

      if (gameState !== 'playing') return;

      timer = (performance.now() - startTime) / 1000;

      // Player input
      const throttle = keys['ArrowUp'] || false;
      const brake = keys['ArrowDown'] || false;
      let lean = 0;
      if (keys['ArrowRight']) lean = 1;
      if (keys['ArrowLeft']) lean = -1;

      player.update(throttle, brake, lean);

      // Dirt particles from rear wheel
      if (player.onGround && throttle && Math.random() < 0.4) {
        const cosA = Math.cos(player.angle);
        const sinA = Math.sin(player.angle);
        spawnParticles(
          player.x - cosA * WHEELBASE / 2,
          player.y - sinA * WHEELBASE / 2 + WHEEL_RADIUS,
          1, '#864'
        );
      }

      // Ghost playback
      if (ghostFrame < ghostData.length) {
        const gd = ghostData[ghostFrame];
        ghostBike.x = gd.x;
        ghostBike.y = gd.y;
        ghostBike.angle = gd.angle;
        ghostBike.speed = gd.speed;
        ghostBike.crashed = gd.crashed;
        ghostFrame++;
      }

      // Checkpoints
      for (const cp of checkpoints) {
        if (!cp.reached && Math.abs(player.x - cp.x) < 30) {
          cp.reached = true;
          checkpointBonus += cp.isFinish ? 500 : 200;
          spawnParticles(cp.x, cp.y, 20, cp.isFinish ? '#ff0' : THEME);

          if (cp.isFinish) {
            endGame(true);
            return;
          }
        }
      }

      // Update score display
      const distScore = Math.floor(player.distance);
      const timePenalty = Math.floor(timer * 2);
      score = Math.max(0, distScore + checkpointBonus - timePenalty);
      scoreEl.textContent = score;

      // Camera follow
      const targetCamX = player.x - W * 0.3;
      const targetCamY = player.y - H * 0.55;
      cameraX += (targetCamX - cameraX) * 0.08;
      cameraY += (targetCamY - cameraY) * 0.06;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.08;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Crash
      if (player.crashed) {
        spawnParticles(player.x, player.y, 15, '#f44');
        gameState = 'crashed';
        crashTimer = 0;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
      skyGrad.addColorStop(0, '#0a0a1a');
      skyGrad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, H);

      // Stars (parallax)
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 50) % 800) - (cameraX * 0.05) % 800;
        const sy = ((i * 97 + 30) % 250);
        const ss = (i % 3 === 0) ? 1.5 : 1;
        ctx.fillRect(sx < 0 ? sx + 800 : sx, sy, ss, ss);
      }

      // Mountains (parallax)
      ctx.beginPath();
      ctx.moveTo(0, H);
      for (let mx = -50; mx < W + 100; mx += 80) {
        const worldMX = mx + cameraX * 0.15;
        const mh = 80 + Math.sin(worldMX * 0.005) * 40 + Math.cos(worldMX * 0.012) * 25;
        ctx.lineTo(mx, H - 80 - mh);
      }
      ctx.lineTo(W, H);
      ctx.closePath();
      ctx.fillStyle = '#12122a';
      ctx.fill();

      // Terrain
      if (terrain.length > 1) {
        const startX = cameraX - 50;
        const endX = cameraX + W + 50;

        // Terrain fill
        ctx.beginPath();
        let started = false;
        let firstScreenX = 0;

        for (let i = 0; i < terrain.length; i++) {
          const sx = terrain[i].x - cameraX;
          const sy = terrain[i].y - cameraY;

          if (terrain[i].x >= startX - 60 && terrain[i].x <= endX + 60) {
            if (!started) {
              firstScreenX = sx;
              ctx.moveTo(sx, sy);
              started = true;
            } else {
              ctx.lineTo(sx, sy);
            }
          }
        }

        if (started) {
          const lastVisibleX = Math.min(terrain[terrain.length - 1].x - cameraX, W + 100);
          ctx.lineTo(lastVisibleX, H + 100);
          ctx.lineTo(firstScreenX, H + 100);
          ctx.closePath();

          const tGrad = ctx.createLinearGradient(0, 0, 0, H);
          tGrad.addColorStop(0, '#2a2a3e');
          tGrad.addColorStop(1, '#1a1a2e');
          ctx.fillStyle = tGrad;
          ctx.fill();

          // Terrain edge with neon glow
          ctx.shadowColor = THEME_GLOW;
          ctx.shadowBlur = 8;

          ctx.beginPath();
          started = false;
          for (let i = 0; i < terrain.length; i++) {
            const sx = terrain[i].x - cameraX;
            const sy = terrain[i].y - cameraY;
            if (terrain[i].x >= startX - 60 && terrain[i].x <= endX + 60) {
              if (!started) { ctx.moveTo(sx, sy); started = true; }
              else ctx.lineTo(sx, sy);
            }
          }
          ctx.strokeStyle = THEME_DIM;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Grass tufts
        ctx.strokeStyle = 'rgba(100, 200, 100, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < terrain.length - 1; i += 3) {
          if (terrain[i].x >= startX - 30 && terrain[i].x <= endX + 30) {
            const sx = terrain[i].x - cameraX;
            const sy = terrain[i].y - cameraY;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx - 3, sy - 6);
            ctx.moveTo(sx + 2, sy);
            ctx.lineTo(sx + 5, sy - 5);
            ctx.stroke();
          }
        }
      }

      // Checkpoints
      for (const cp of checkpoints) {
        const sx = cp.x - cameraX;
        const sy = cp.y - cameraY;

        if (sx > -50 && sx < W + 50) {
          const groundY = getTerrainY(cp.x) - cameraY;

          // Pole
          ctx.beginPath();
          ctx.moveTo(sx, groundY);
          ctx.lineTo(sx, sy - 20);
          ctx.strokeStyle = cp.reached ? 'rgba(100,200,100,0.6)' : 'rgba(255,68,170,0.5)';
          ctx.lineWidth = 2;
          ctx.stroke();

          if (cp.isFinish) {
            // Checkered flag
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = cp.reached ? 0 : 10;
            const flagW = 24;
            const flagH = 16;
            for (let fy = 0; fy < 4; fy++) {
              for (let fx = 0; fx < 6; fx++) {
                ctx.fillStyle = (fx + fy) % 2 === 0 ? '#fff' : '#222';
                ctx.fillRect(sx + fx * (flagW / 6), sy - 20 + fy * (flagH / 4), flagW / 6, flagH / 4);
              }
            }
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ff0';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('FINISH', sx + 12, sy - 24);
          } else {
            // Checkpoint flag
            ctx.shadowColor = cp.reached ? '#0f0' : THEME_GLOW;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(sx, sy - 20);
            ctx.lineTo(sx + 14, sy - 12);
            ctx.lineTo(sx, sy - 4);
            ctx.closePath();
            ctx.fillStyle = cp.reached ? 'rgba(100,200,100,0.7)' : 'rgba(255,68,170,0.7)';
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
      }

      // Particles
      for (const p of particles) {
        const sx = p.x - cameraX;
        const sy = p.y - cameraY;
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.fillRect(sx - p.size / 2, sy - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;

      // Ghost bike
      if (ghostFrame > 0 && !ghostBike.crashed) {
        ghostBike.draw(cameraX, cameraY, 0.35);
      }

      // Player bike
      if (!player.crashed || gameState === 'crashed') {
        player.draw(cameraX, cameraY, 1);

        // Crash explosion
        if (player.crashed) {
          ctx.save();
          const psx = player.x - cameraX;
          const psy = player.y - cameraY;
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 20;
          ctx.strokeStyle = '#f44';
          ctx.lineWidth = 2;
          const t = performance.now() * 0.01;
          for (let r = 0; r < 6; r++) {
            const a = t + r * Math.PI / 3;
            const len = 10 + Math.random() * 20;
            ctx.beginPath();
            ctx.moveTo(psx + Math.cos(a) * 8, psy + Math.sin(a) * 8);
            ctx.lineTo(psx + Math.cos(a) * len, psy + Math.sin(a) * len);
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
          ctx.restore();
        }
      }

      // HUD
      drawHUD();
    }

    function drawHUD() {
      const pad = 10;

      // Speed gauge
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(pad, H - 55, 120, 45);
      ctx.strokeStyle = 'rgba(255,68,170,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(pad, H - 55, 120, 45);

      ctx.fillStyle = THEME;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('SPEED', pad + 5, H - 40);

      const speedPct = Math.min(1, player.speed / MAX_SPEED);
      ctx.fillStyle = '#333';
      ctx.fillRect(pad + 5, H - 34, 100, 8);
      const speedColor = speedPct > 0.8 ? '#f44' : speedPct > 0.5 ? '#fa4' : THEME;
      ctx.shadowColor = speedColor;
      ctx.shadowBlur = 6;
      ctx.fillStyle = speedColor;
      ctx.fillRect(pad + 5, H - 34, 100 * speedPct, 8);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#aaa';
      ctx.fillText(`${Math.floor(player.speed * 20)} km/h`, pad + 5, H - 16);

      // Distance
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(pad + 130, H - 55, 110, 45);
      ctx.strokeStyle = 'rgba(255,68,170,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(pad + 130, H - 55, 110, 45);

      ctx.fillStyle = THEME;
      ctx.font = '10px Courier New';
      ctx.fillText('DIST', pad + 135, H - 40);
      ctx.fillStyle = '#ddd';
      ctx.font = '14px Courier New';
      ctx.fillText(`${Math.floor(player.distance)}m`, pad + 135, H - 18);

      // Timer
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(W - 130, H - 55, 120, 45);
      ctx.strokeStyle = 'rgba(255,68,170,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 130, H - 55, 120, 45);

      ctx.fillStyle = THEME;
      ctx.font = '10px Courier New';
      ctx.fillText('TIME', W - 125, H - 40);
      ctx.fillStyle = '#ddd';
      ctx.font = '14px Courier New';
      const mins = Math.floor(timer / 60);
      const secs = Math.floor(timer % 60);
      const ms = Math.floor((timer * 100) % 100);
      ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, W - 125, H - 18);

      // Lean angle indicator
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(W - 130, H - 108, 120, 45);
      ctx.strokeStyle = 'rgba(255,68,170,0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(W - 130, H - 108, 120, 45);

      ctx.fillStyle = THEME;
      ctx.font = '10px Courier New';
      ctx.fillText('LEAN', W - 125, H - 93);

      // Lean gauge arc
      const leanCenterX = W - 70;
      const leanCenterY = H - 76;
      ctx.save();
      ctx.translate(leanCenterX, leanCenterY);
      ctx.beginPath();
      ctx.arc(0, 0, 14, -Math.PI, 0);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Needle
      const needleAngle = -Math.PI / 2 + player.angle * 1.5;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(needleAngle) * 12, Math.sin(needleAngle) * 12);
      const leanWarning = Math.abs(player.angle) > MAX_LEAN * 0.7;
      ctx.strokeStyle = leanWarning ? '#f44' : THEME;
      ctx.shadowColor = leanWarning ? '#f44' : THEME_GLOW;
      ctx.shadowBlur = 6;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();

      ctx.fillStyle = '#aaa';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`${Math.floor(player.angle * 180 / Math.PI)}deg`, W - 55, H - 68);

      // Level indicator
      ctx.fillStyle = THEME;
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`LVL ${currentLevel}`, W - 15, 25);
      ctx.textAlign = 'left';

      // Ghost label
      if (ghostFrame > 0 && ghostFrame <= ghostData.length && !ghostBike.crashed) {
        const gsx = ghostBike.x - cameraX;
        const gsy = ghostBike.y - cameraY;
        if (gsx > -20 && gsx < W + 20 && gsy > 0 && gsy < H) {
          ctx.fillStyle = 'rgba(255,68,170,0.4)';
          ctx.font = '9px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('GHOST', gsx, gsy - 50);
          ctx.textAlign = 'left';
        }
      }

      // Progress bar at top
      if (checkpoints.length > 0 && terrain.length > 1) {
        const barY = 6;
        const barH = 4;
        const barW = W - 20;
        const barX = 10;

        ctx.fillStyle = '#222';
        ctx.fillRect(barX, barY, barW, barH);

        const totalDist = terrain[terrain.length - 1].x - terrain[0].x;
        const playerProg = Math.max(0, Math.min(1, (player.x - terrain[0].x) / totalDist));
        ctx.fillStyle = THEME;
        ctx.shadowColor = THEME_GLOW;
        ctx.shadowBlur = 4;
        ctx.fillRect(barX, barY, barW * playerProg, barH);
        ctx.shadowBlur = 0;

        // Ghost progress marker
        const ghostProg = Math.max(0, Math.min(1, (ghostBike.x - terrain[0].x) / totalDist));
        ctx.fillStyle = 'rgba(255,68,170,0.4)';
        ctx.fillRect(barX + barW * ghostProg - 2, barY - 1, 4, barH + 2);

        // Checkpoint markers
        for (const cp of checkpoints) {
          const cpProg = Math.max(0, Math.min(1, (cp.x - terrain[0].x) / totalDist));
          ctx.fillStyle = cp.reached ? '#0f0' : (cp.isFinish ? '#ff0' : '#888');
          ctx.fillRect(barX + barW * cpProg - 1, barY - 2, 2, barH + 4);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    initGame();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pinball</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 350px;
    }
    .back { color: #fc6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 204, 102, 0.5); }
    h1 { color: #fc6; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 204, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 350px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fc6; }
    canvas {
      border: 2px solid #fc6;
      box-shadow: 0 0 20px rgba(255, 204, 102, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fc6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PINBALL</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Balls: <span id="balls">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="350" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:350px;height:600px;">
      <h2 id="overlayTitle">PINBALL</h2>
      <p id="overlayText">Hold SPACE to launch</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const ballsEl = document.getElementById('balls');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Physics constants
    const GRAVITY = 0.15;
    const FRICTION = 0.999;
    const BALL_RADIUS = 6;
    const FLIPPER_LENGTH = 50;
    const FLIPPER_WIDTH = 8;
    const FLIPPER_PIVOT_Y = H - 55;
    const FLIPPER_REST_ANGLE = 0.4;   // radians from horizontal (resting, angled down)
    const FLIPPER_UP_ANGLE = -0.6;    // radians (flipped up)
    const FLIPPER_SPEED = 0.25;       // angular speed

    // Table geometry
    const TABLE_LEFT = 15;
    const TABLE_RIGHT = W - 15;
    const TABLE_TOP = 15;
    const LAUNCHER_X = TABLE_RIGHT - 18;
    const LAUNCHER_WIDTH = 20;
    const LAUNCHER_WALL_X = TABLE_RIGHT - LAUNCHER_WIDTH - 8;

    // Flipper pivots
    const LEFT_FLIPPER_X = 85;
    const RIGHT_FLIPPER_X = W - 85;

    // Game state variables
    let balls, ballObj, launching, launchPower, launchHeld;
    let leftFlipperAngle, rightFlipperAngle;
    let leftFlipperTarget, rightFlipperTarget;
    let bumpers, dropTargets, dropTargetSets, rollovers, spinner;
    let slingshots;
    let multiplier, multiball, multiballBalls;
    let nudgeCount, tiltWarning, tilted, tiltCooldown;
    let flashTimers, bonusText;
    let keys = {};

    // Bumper definitions
    function createBumpers() {
      return [
        { x: W / 2, y: 150, r: 22, points: 100, hitTimer: 0, color: '#f44' },
        { x: W / 2 - 60, y: 200, r: 20, points: 100, hitTimer: 0, color: '#4f4' },
        { x: W / 2 + 60, y: 200, r: 20, points: 100, hitTimer: 0, color: '#48f' },
        { x: W / 2 - 30, y: 270, r: 18, points: 150, hitTimer: 0, color: '#f0f' },
        { x: W / 2 + 30, y: 270, r: 18, points: 150, hitTimer: 0, color: '#fc6' },
      ];
    }

    // Drop targets
    function createDropTargets() {
      const set1 = [
        { x: 50, y: 160, w: 6, h: 20, hit: false, points: 200 },
        { x: 50, y: 185, w: 6, h: 20, hit: false, points: 200 },
        { x: 50, y: 210, w: 6, h: 20, hit: false, points: 200 },
      ];
      const set2 = [
        { x: W - 56, y: 160, w: 6, h: 20, hit: false, points: 200 },
        { x: W - 56, y: 185, w: 6, h: 20, hit: false, points: 200 },
        { x: W - 56, y: 210, w: 6, h: 20, hit: false, points: 200 },
      ];
      return [set1, set2];
    }

    // Rollover lanes
    function createRollovers() {
      return [
        { x: 100, y: 80, w: 20, hit: false, points: 50 },
        { x: 155, y: 80, w: 20, hit: false, points: 50 },
        { x: 210, y: 80, w: 20, hit: false, points: 50 },
      ];
    }

    // Spinner
    function createSpinner() {
      return { x: W / 2, y: 110, w: 30, angle: 0, spinSpeed: 0, points: 10 };
    }

    // Slingshots (triangular kickers above flippers)
    function createSlingshots() {
      return [
        { // Left slingshot
          x1: TABLE_LEFT + 15, y1: FLIPPER_PIVOT_Y - 80,
          x2: TABLE_LEFT + 15, y2: FLIPPER_PIVOT_Y - 10,
          x3: LEFT_FLIPPER_X - 10, y3: FLIPPER_PIVOT_Y - 10,
          hitTimer: 0, points: 10
        },
        { // Right slingshot
          x1: TABLE_RIGHT - LAUNCHER_WIDTH - 23, y1: FLIPPER_PIVOT_Y - 80,
          x2: TABLE_RIGHT - LAUNCHER_WIDTH - 23, y2: FLIPPER_PIVOT_Y - 10,
          x3: RIGHT_FLIPPER_X + 10, y3: FLIPPER_PIVOT_Y - 10,
          hitTimer: 0, points: 10
        }
      ];
    }

    function createBall(x, y, vx, vy) {
      return { x: x, y: y, vx: vx || 0, vy: vy || 0, active: true };
    }

    function init() {
      score = 0;
      balls = 3;
      scoreEl.textContent = '0';
      ballsEl.textContent = balls;
      multiplier = 1;
      multiball = false;
      multiballBalls = [];
      nudgeCount = 0;
      tiltWarning = false;
      tilted = false;
      tiltCooldown = 0;
      flashTimers = {};
      bonusText = [];
      launching = true;
      launchPower = 0;
      launchHeld = false;
      leftFlipperAngle = FLIPPER_REST_ANGLE;
      rightFlipperAngle = FLIPPER_REST_ANGLE;
      leftFlipperTarget = FLIPPER_REST_ANGLE;
      rightFlipperTarget = FLIPPER_REST_ANGLE;
      bumpers = createBumpers();
      dropTargetSets = createDropTargets();
      dropTargets = dropTargetSets.flat();
      rollovers = createRollovers();
      spinner = createSpinner();
      slingshots = createSlingshots();
      ballObj = createBall(LAUNCHER_X, H - 60, 0, 0);
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PINBALL';
      overlayText.textContent = 'Hold SPACE to launch';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      launching = true;
      launchPower = 0;
      launchHeld = false;
      ballObj = createBall(LAUNCHER_X, H - 60, 0, 0);
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function loseBall() {
      balls--;
      ballsEl.textContent = balls;
      if (balls <= 0) {
        gameOver();
        return;
      }
      // Reset for next ball
      launching = true;
      launchPower = 0;
      launchHeld = false;
      tilted = false;
      tiltWarning = false;
      nudgeCount = 0;
      multiplier = 1;
      multiball = false;
      multiballBalls = [];
      ballObj = createBall(LAUNCHER_X, H - 60, 0, 0);
    }

    function addScore(pts) {
      const gained = pts * multiplier;
      score += gained;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      return gained;
    }

    function addBonusText(x, y, text) {
      bonusText.push({ x, y, text, timer: 60, oy: 0 });
    }

    // --- Physics helpers ---

    function reflectBallOffCircle(ball, cx, cy, cr, bounceFactor) {
      const dx = ball.x - cx;
      const dy = ball.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return;
      const nx = dx / dist;
      const ny = dy / dist;
      // Push ball out
      ball.x = cx + nx * (cr + BALL_RADIUS + 1);
      ball.y = cy + ny * (cr + BALL_RADIUS + 1);
      // Reflect velocity
      const dot = ball.vx * nx + ball.vy * ny;
      ball.vx -= 2 * dot * nx;
      ball.vy -= 2 * dot * ny;
      // Apply bounce force
      const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      const minSpeed = bounceFactor;
      if (speed < minSpeed) {
        ball.vx = nx * minSpeed;
        ball.vy = ny * minSpeed;
      } else {
        ball.vx *= 1.05;
        ball.vy *= 1.05;
      }
    }

    function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
      const d1 = (px - x2) * (y1 - y2) - (x1 - x2) * (py - y2);
      const d2 = (px - x3) * (y2 - y3) - (x2 - x3) * (py - y3);
      const d3 = (px - x1) * (y3 - y1) - (x3 - x1) * (py - y1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }

    function closestPointOnSegment(px, py, ax, ay, bx, by) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      let t = (apx * abx + apy * aby) / (abx * abx + aby * aby);
      t = Math.max(0, Math.min(1, t));
      return { x: ax + t * abx, y: ay + t * aby };
    }

    function reflectBallOffSegment(ball, ax, ay, bx, by, bounceFactor) {
      const cp = closestPointOnSegment(ball.x, ball.y, ax, ay, bx, by);
      const dx = ball.x - cp.x;
      const dy = ball.y - cp.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return false;
      if (dist > BALL_RADIUS + 2) return false;
      const nx = dx / dist;
      const ny = dy / dist;
      ball.x = cp.x + nx * (BALL_RADIUS + 2);
      ball.y = cp.y + ny * (BALL_RADIUS + 2);
      const dot = ball.vx * nx + ball.vy * ny;
      if (dot > 0) return false; // moving away
      ball.vx -= 2 * dot * nx;
      ball.vy -= 2 * dot * ny;
      const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      if (speed < bounceFactor) {
        ball.vx += nx * bounceFactor * 0.5;
        ball.vy += ny * bounceFactor * 0.5;
      }
      return true;
    }

    // Flipper collision
    function getFlipperEndpoints(pivotX, pivotY, angle, side) {
      const dir = side === 'left' ? 1 : -1;
      const endX = pivotX + Math.cos(angle * dir) * FLIPPER_LENGTH * dir;
      const endY = pivotY - Math.sin(angle * dir) * FLIPPER_LENGTH;
      return { px: pivotX, py: pivotY, ex: endX, ey: endY };
    }

    function handleFlipperCollision(ball, pivotX, pivotY, angle, prevAngle, side) {
      const fp = getFlipperEndpoints(pivotX, pivotY, angle, side);
      const cp = closestPointOnSegment(ball.x, ball.y, fp.px, fp.py, fp.ex, fp.ey);
      const dx = ball.x - cp.x;
      const dy = ball.y - cp.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < BALL_RADIUS + FLIPPER_WIDTH / 2 + 1) {
        const nx = dist > 0 ? dx / dist : 0;
        const ny = dist > 0 ? dy / dist : -1;
        // Push out
        ball.x = cp.x + nx * (BALL_RADIUS + FLIPPER_WIDTH / 2 + 2);
        ball.y = cp.y + ny * (BALL_RADIUS + FLIPPER_WIDTH / 2 + 2);
        // Reflect
        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * dot * nx;
        ball.vy -= 2 * dot * ny;
        // Flipper hit boost -- if flipper is moving up, add force
        const angularVel = angle - prevAngle;
        if (Math.abs(angularVel) > 0.02) {
          // Distance from pivot to contact
          const contactDist = Math.sqrt((cp.x - pivotX) ** 2 + (cp.y - pivotY) ** 2);
          const boost = angularVel * contactDist * 0.15;
          ball.vy -= Math.abs(boost) * 3;
          ball.vx += (side === 'left' ? 1 : -1) * Math.abs(boost) * 1.5;
        }
        // Minimum upward speed on flipper hit
        if (ball.vy > -2) ball.vy = -2;
        return true;
      }
      return false;
    }

    // --- Update ---

    function updateBallPhysics(ball) {
      if (!ball.active) return;
      if (tilted) {
        // Tilted: ball just falls
        ball.vy += GRAVITY;
        ball.x += ball.vx;
        ball.y += ball.vy;
        if (ball.y > H + 20) ball.active = false;
        return;
      }

      // Gravity
      ball.vy += GRAVITY;

      // Friction
      ball.vx *= FRICTION;
      ball.vy *= FRICTION;

      // Move
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall collisions
      // Left wall
      if (ball.x - BALL_RADIUS < TABLE_LEFT) {
        ball.x = TABLE_LEFT + BALL_RADIUS;
        ball.vx = Math.abs(ball.vx) * 0.8;
      }
      // Right wall (with launcher channel gap)
      if (ball.y < FLIPPER_PIVOT_Y - 100) {
        // Top area - full right wall
        if (ball.x + BALL_RADIUS > TABLE_RIGHT) {
          ball.x = TABLE_RIGHT - BALL_RADIUS;
          ball.vx = -Math.abs(ball.vx) * 0.8;
        }
      } else {
        // Bottom area - wall stops at launcher channel
        if (ball.x < LAUNCHER_WALL_X && ball.x + BALL_RADIUS > LAUNCHER_WALL_X) {
          // Only bounce off launcher wall if ball is in play area (not in launcher)
          if (!launching) {
            ball.x = LAUNCHER_WALL_X - BALL_RADIUS;
            ball.vx = -Math.abs(ball.vx) * 0.8;
          }
        }
        if (ball.x + BALL_RADIUS > TABLE_RIGHT) {
          ball.x = TABLE_RIGHT - BALL_RADIUS;
          ball.vx = -Math.abs(ball.vx) * 0.8;
        }
      }
      // Top wall (curved)
      if (ball.y - BALL_RADIUS < TABLE_TOP) {
        ball.y = TABLE_TOP + BALL_RADIUS;
        ball.vy = Math.abs(ball.vy) * 0.8;
      }

      // Launcher wall -- vertical barrier between playfield and launch lane
      if (ball.y > FLIPPER_PIVOT_Y - 100 && ball.y < FLIPPER_PIVOT_Y) {
        // Ball in play area bumping into launcher wall from the left
        if (ball.x + BALL_RADIUS > LAUNCHER_WALL_X && ball.x < LAUNCHER_WALL_X) {
          ball.x = LAUNCHER_WALL_X - BALL_RADIUS;
          ball.vx = -Math.abs(ball.vx) * 0.6;
        }
      }

      // Top curve guide rails -- guide the ball from launcher into the playfield
      const curveCenter = { x: TABLE_RIGHT - 40, y: TABLE_TOP + 40 };
      const curveDist = Math.sqrt((ball.x - curveCenter.x) ** 2 + (ball.y - curveCenter.y) ** 2);
      if (curveDist > 45 && ball.x > W / 2 + 50 && ball.y < TABLE_TOP + 80) {
        reflectBallOffCircle(ball, curveCenter.x, curveCenter.y, 45, 1);
      }

      // Bumper collisions
      for (const bumper of bumpers) {
        const dx = ball.x - bumper.x;
        const dy = ball.y - bumper.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < bumper.r + BALL_RADIUS) {
          reflectBallOffCircle(ball, bumper.x, bumper.y, bumper.r, 4);
          bumper.hitTimer = 15;
          const pts = addScore(bumper.points);
          addBonusText(bumper.x, bumper.y - bumper.r - 10, `+${pts}`);
        }
      }

      // Drop target collisions
      for (const dt of dropTargets) {
        if (dt.hit) continue;
        if (ball.x + BALL_RADIUS > dt.x && ball.x - BALL_RADIUS < dt.x + dt.w &&
            ball.y + BALL_RADIUS > dt.y && ball.y - BALL_RADIUS < dt.y + dt.h) {
          dt.hit = true;
          // Bounce ball away from target
          if (dt.x < W / 2) {
            ball.vx = Math.abs(ball.vx) + 2;
          } else {
            ball.vx = -Math.abs(ball.vx) - 2;
          }
          const pts = addScore(dt.points);
          addBonusText(dt.x, dt.y - 10, `+${pts}`);

          // Check if a full set is cleared
          for (const set of dropTargetSets) {
            if (set.every(t => t.hit)) {
              addScore(2000);
              multiplier = Math.min(multiplier + 1, 5);
              addBonusText(set[1].x, set[1].y - 30, `${multiplier}x MULTI!`);
              // Reset the set after a delay
              setTimeout(() => {
                set.forEach(t => t.hit = false);
              }, 3000);
            }
          }
        }
      }

      // Rollover lanes
      for (const ro of rollovers) {
        if (ball.x > ro.x && ball.x < ro.x + ro.w && ball.y > ro.y - 5 && ball.y < ro.y + 10) {
          if (!ro.hit) {
            ro.hit = true;
            addScore(ro.points);
            addBonusText(ro.x + ro.w / 2, ro.y - 15, `+${ro.points * multiplier}`);
            // Check if all rollovers lit
            if (rollovers.every(r => r.hit)) {
              addScore(1000);
              addBonusText(W / 2, ro.y - 30, 'ALL LANES BONUS!');
              // Activate multiball
              if (!multiball) {
                multiball = true;
                multiballBalls.push(createBall(ball.x - 15, ball.y, -2, -3));
                multiballBalls.push(createBall(ball.x + 15, ball.y, 2, -3));
                addBonusText(W / 2, H / 2, 'MULTIBALL!');
              }
              setTimeout(() => rollovers.forEach(r => r.hit = false), 5000);
            }
          }
        } else if (ball.y < ro.y - 15 || ball.y > ro.y + 20) {
          // Reset rollover when ball leaves area
        }
      }

      // Spinner
      const sdx = ball.x - spinner.x;
      const sdy = ball.y - spinner.y;
      if (Math.abs(sdx) < spinner.w / 2 + BALL_RADIUS && Math.abs(sdy) < 8 + BALL_RADIUS) {
        spinner.spinSpeed = Math.abs(ball.vy) * 0.5 + Math.abs(ball.vx) * 0.3;
        addScore(spinner.points);
        ball.vy *= 0.7; // Slow ball slightly through spinner
      }

      // Slingshot collisions
      for (const sl of slingshots) {
        // Check distance to each edge of the triangle
        const hit1 = reflectBallOffSegment(ball, sl.x1, sl.y1, sl.x2, sl.y2, 5);
        const hit2 = reflectBallOffSegment(ball, sl.x2, sl.y2, sl.x3, sl.y3, 5);
        const hit3 = reflectBallOffSegment(ball, sl.x3, sl.y3, sl.x1, sl.y1, 5);
        if (hit1 || hit2 || hit3) {
          sl.hitTimer = 10;
          addScore(sl.points);
        }
      }

      // Flipper collisions
      handleFlipperCollision(ball, LEFT_FLIPPER_X, FLIPPER_PIVOT_Y, leftFlipperAngle, leftFlipperAngle, 'left');
      handleFlipperCollision(ball, RIGHT_FLIPPER_X, FLIPPER_PIVOT_Y, rightFlipperAngle, rightFlipperAngle, 'right');

      // Out-slants (angled walls above flippers leading to drain)
      // Left out-slant
      reflectBallOffSegment(ball, TABLE_LEFT, FLIPPER_PIVOT_Y - 80, LEFT_FLIPPER_X - 20, FLIPPER_PIVOT_Y, 1);
      // Right out-slant
      reflectBallOffSegment(ball, LAUNCHER_WALL_X, FLIPPER_PIVOT_Y - 80, RIGHT_FLIPPER_X + 20, FLIPPER_PIVOT_Y, 1);

      // Drain detection
      if (ball.y > H + 10) {
        ball.active = false;
      }
    }

    function update() {
      if (tilted) {
        tiltCooldown--;
        if (tiltCooldown <= 0) {
          tilted = false;
        }
      }

      // Launcher
      if (launching) {
        if (launchHeld) {
          launchPower = Math.min(launchPower + 0.8, 100);
        }
        ballObj.x = LAUNCHER_X;
        ballObj.y = H - 60 + (launchPower * 0.15);
        ballObj.vx = 0;
        ballObj.vy = 0;
        return;
      }

      // Store previous flipper angles for velocity calc
      const prevLeftAngle = leftFlipperAngle;
      const prevRightAngle = rightFlipperAngle;

      // Animate flippers
      const flipSpeed = FLIPPER_SPEED;
      if (leftFlipperAngle < leftFlipperTarget) {
        leftFlipperAngle = Math.min(leftFlipperAngle + flipSpeed, leftFlipperTarget);
      } else {
        leftFlipperAngle = Math.max(leftFlipperAngle - flipSpeed, leftFlipperTarget);
      }
      if (rightFlipperAngle < rightFlipperTarget) {
        rightFlipperAngle = Math.min(rightFlipperAngle + flipSpeed, rightFlipperTarget);
      } else {
        rightFlipperAngle = Math.max(rightFlipperAngle - flipSpeed, rightFlipperTarget);
      }

      // Update main ball
      updateBallPhysics(ballObj);

      // Re-do flipper collision with proper prev angle
      handleFlipperCollision(ballObj, LEFT_FLIPPER_X, FLIPPER_PIVOT_Y, leftFlipperAngle, prevLeftAngle, 'left');
      handleFlipperCollision(ballObj, RIGHT_FLIPPER_X, FLIPPER_PIVOT_Y, rightFlipperAngle, prevRightAngle, 'right');

      // Multiball balls
      for (const mb of multiballBalls) {
        if (!mb.active) continue;
        updateBallPhysics(mb);
        handleFlipperCollision(mb, LEFT_FLIPPER_X, FLIPPER_PIVOT_Y, leftFlipperAngle, prevLeftAngle, 'left');
        handleFlipperCollision(mb, RIGHT_FLIPPER_X, FLIPPER_PIVOT_Y, rightFlipperAngle, prevRightAngle, 'right');
      }

      // Remove inactive multiball balls
      multiballBalls = multiballBalls.filter(b => b.active);
      if (multiballBalls.length === 0 && multiball) {
        multiball = false;
      }

      // Spinner decay
      if (spinner.spinSpeed > 0) {
        spinner.angle += spinner.spinSpeed;
        spinner.spinSpeed *= 0.97;
        if (spinner.spinSpeed < 0.1) spinner.spinSpeed = 0;
      }

      // Bumper hit timers
      for (const b of bumpers) {
        if (b.hitTimer > 0) b.hitTimer--;
      }
      for (const s of slingshots) {
        if (s.hitTimer > 0) s.hitTimer--;
      }

      // Bonus text
      for (let i = bonusText.length - 1; i >= 0; i--) {
        bonusText[i].timer--;
        bonusText[i].oy -= 0.8;
        if (bonusText[i].timer <= 0) bonusText.splice(i, 1);
      }

      // Check main ball drain
      if (!ballObj.active) {
        if (multiballBalls.length > 0) {
          // Promote a multiball ball to main
          ballObj = multiballBalls.shift();
        } else {
          loseBall();
        }
      }

      // Nudge cooldown
      if (tiltWarning) {
        tiltCooldown--;
        if (tiltCooldown <= 0) {
          tiltWarning = false;
          nudgeCount = Math.max(0, nudgeCount - 1);
        }
      }
    }

    // --- Draw ---

    function drawBall(ball) {
      if (!ball.active) return;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#eee';
      ctx.shadowColor = '#fc6';
      ctx.shadowBlur = 15;
      ctx.fill();
      ctx.shadowBlur = 0;
      // Highlight
      ctx.beginPath();
      ctx.arc(ball.x - 2, ball.y - 2, BALL_RADIUS * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fill();
    }

    function drawFlipper(pivotX, pivotY, angle, side) {
      const fp = getFlipperEndpoints(pivotX, pivotY, angle, side);
      ctx.save();
      ctx.strokeStyle = '#fc6';
      ctx.lineWidth = FLIPPER_WIDTH;
      ctx.lineCap = 'round';
      ctx.shadowColor = '#fc6';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(fp.px, fp.py);
      ctx.lineTo(fp.ex, fp.ey);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Table border glow
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 2;
      ctx.strokeRect(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT - TABLE_LEFT, H - TABLE_TOP);

      // Launcher lane
      ctx.fillStyle = '#16213e';
      ctx.fillRect(LAUNCHER_WALL_X, FLIPPER_PIVOT_Y - 100, LAUNCHER_WIDTH + 8, H - FLIPPER_PIVOT_Y + 100);
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(LAUNCHER_WALL_X, FLIPPER_PIVOT_Y - 100);
      ctx.lineTo(LAUNCHER_WALL_X, H);
      ctx.stroke();

      // Launch power indicator
      if (launching && launchPower > 0) {
        const barH = (launchPower / 100) * 80;
        ctx.fillStyle = `hsl(${40 - launchPower * 0.4}, 100%, 50%)`;
        ctx.shadowColor = '#fc6';
        ctx.shadowBlur = 8;
        ctx.fillRect(LAUNCHER_X - 5, H - 30 - barH, 10, barH);
        ctx.shadowBlur = 0;
      }

      // Slingshots
      for (const sl of slingshots) {
        ctx.beginPath();
        ctx.moveTo(sl.x1, sl.y1);
        ctx.lineTo(sl.x2, sl.y2);
        ctx.lineTo(sl.x3, sl.y3);
        ctx.closePath();
        ctx.strokeStyle = sl.hitTimer > 0 ? '#fff' : '#fc6';
        ctx.lineWidth = 2;
        ctx.shadowColor = sl.hitTimer > 0 ? '#fff' : '#fc6';
        ctx.shadowBlur = sl.hitTimer > 0 ? 15 : 5;
        ctx.stroke();
        ctx.fillStyle = sl.hitTimer > 0 ? 'rgba(255, 204, 102, 0.3)' : 'rgba(255, 204, 102, 0.08)';
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Out-slants
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(TABLE_LEFT, FLIPPER_PIVOT_Y - 80);
      ctx.lineTo(LEFT_FLIPPER_X - 20, FLIPPER_PIVOT_Y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(LAUNCHER_WALL_X, FLIPPER_PIVOT_Y - 80);
      ctx.lineTo(RIGHT_FLIPPER_X + 20, FLIPPER_PIVOT_Y);
      ctx.stroke();

      // Bumpers
      for (const b of bumpers) {
        const glowing = b.hitTimer > 0;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fillStyle = glowing ? '#fff' : b.color;
        ctx.shadowColor = glowing ? '#fff' : b.color;
        ctx.shadowBlur = glowing ? 25 : 12;
        ctx.fill();
        ctx.shadowBlur = 0;
        // Inner ring
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = glowing ? b.color : '#1a1a2e';
        ctx.fill();
        // Center dot
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = glowing ? '#fff' : b.color;
        ctx.fill();
      }

      // Drop targets
      for (const dt of dropTargets) {
        if (dt.hit) {
          ctx.fillStyle = 'rgba(255, 204, 102, 0.15)';
        } else {
          ctx.fillStyle = '#fc6';
          ctx.shadowColor = '#fc6';
          ctx.shadowBlur = 8;
        }
        ctx.fillRect(dt.x, dt.y, dt.w, dt.h);
        ctx.shadowBlur = 0;
      }

      // Rollover lanes
      for (const ro of rollovers) {
        ctx.fillStyle = ro.hit ? '#fc6' : '#0f3460';
        ctx.shadowColor = ro.hit ? '#fc6' : 'transparent';
        ctx.shadowBlur = ro.hit ? 10 : 0;
        ctx.fillRect(ro.x, ro.y, ro.w, 3);
        // Arrow indicator
        ctx.beginPath();
        ctx.moveTo(ro.x + ro.w / 2, ro.y + 8);
        ctx.lineTo(ro.x + ro.w / 2 - 5, ro.y + 15);
        ctx.lineTo(ro.x + ro.w / 2 + 5, ro.y + 15);
        ctx.closePath();
        ctx.fillStyle = ro.hit ? '#fc6' : '#0f3460';
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Spinner
      ctx.save();
      ctx.translate(spinner.x, spinner.y);
      ctx.rotate(spinner.angle);
      ctx.strokeStyle = spinner.spinSpeed > 1 ? '#fc6' : '#888';
      ctx.shadowColor = spinner.spinSpeed > 1 ? '#fc6' : 'transparent';
      ctx.shadowBlur = spinner.spinSpeed > 1 ? 10 : 0;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-spinner.w / 2, 0);
      ctx.lineTo(spinner.w / 2, 0);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();

      // Flippers
      if (!tilted) {
        drawFlipper(LEFT_FLIPPER_X, FLIPPER_PIVOT_Y, leftFlipperAngle, 'left');
        drawFlipper(RIGHT_FLIPPER_X, FLIPPER_PIVOT_Y, rightFlipperAngle, 'right');
      } else {
        // Tilted flippers -- draw in dim color
        ctx.globalAlpha = 0.3;
        drawFlipper(LEFT_FLIPPER_X, FLIPPER_PIVOT_Y, FLIPPER_REST_ANGLE, 'left');
        drawFlipper(RIGHT_FLIPPER_X, FLIPPER_PIVOT_Y, FLIPPER_REST_ANGLE, 'right');
        ctx.globalAlpha = 1;
      }

      // Drain area (gap between flippers)
      ctx.fillStyle = '#0a0a18';
      ctx.fillRect(LEFT_FLIPPER_X - 10, FLIPPER_PIVOT_Y + 15, RIGHT_FLIPPER_X - LEFT_FLIPPER_X + 20, 8);

      // Draw balls
      drawBall(ballObj);
      for (const mb of multiballBalls) {
        drawBall(mb);
      }

      // Multiplier display
      if (multiplier > 1) {
        ctx.fillStyle = '#fc6';
        ctx.shadowColor = '#fc6';
        ctx.shadowBlur = 8;
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`${multiplier}x MULTIPLIER`, W / 2, H - 15);
        ctx.shadowBlur = 0;
      }

      // Multiball indicator
      if (multiball) {
        ctx.fillStyle = '#f0f';
        ctx.shadowColor = '#f0f';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('MULTIBALL', W / 2, 38);
        ctx.shadowBlur = 0;
      }

      // Tilt warning
      if (tiltWarning && !tilted) {
        ctx.fillStyle = '#f44';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('WARNING', W / 2, H / 2);
      }
      if (tilted) {
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 15;
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('TILT', W / 2, H / 2);
        ctx.shadowBlur = 0;
      }

      // Bonus text
      for (const bt of bonusText) {
        const alpha = Math.min(1, bt.timer / 20);
        ctx.fillStyle = `rgba(255, 204, 102, ${alpha})`;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(bt.text, bt.x, bt.y + bt.oy);
      }

      // Ball count indicator (small dots at bottom-left)
      for (let i = 0; i < balls - 1; i++) {
        ctx.beginPath();
        ctx.arc(TABLE_LEFT + 15 + i * 15, H - 10, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fc6';
        ctx.shadowColor = '#fc6';
        ctx.shadowBlur = 5;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // --- Game loop ---

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Input ---

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        // If space is pressed, start holding the launcher
        if (e.key === ' ') {
          launchHeld = true;
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;

        // Flippers
        if (e.key === 'ArrowLeft') {
          leftFlipperTarget = -FLIPPER_UP_ANGLE;
        }
        if (e.key === 'ArrowRight') {
          rightFlipperTarget = -FLIPPER_UP_ANGLE;
        }

        // Launch
        if (e.key === ' ' && launching) {
          launchHeld = true;
        }

        // Nudge
        if (e.key === 'ArrowUp') {
          if (!tilted) {
            nudgeCount++;
            if (nudgeCount >= 4) {
              tilted = true;
              tiltCooldown = 180; // 3 seconds at 60fps
              leftFlipperTarget = FLIPPER_REST_ANGLE;
              rightFlipperTarget = FLIPPER_REST_ANGLE;
            } else if (nudgeCount >= 2) {
              tiltWarning = true;
              tiltCooldown = 120;
            }
            // Apply nudge force to ball
            ballObj.vy -= 1.5;
            ballObj.vx += (Math.random() - 0.5) * 2;
            for (const mb of multiballBalls) {
              mb.vy -= 1;
              mb.vx += (Math.random() - 0.5) * 2;
            }
          }
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;

      if (gameState === 'playing') {
        // Flippers release
        if (e.key === 'ArrowLeft') {
          leftFlipperTarget = FLIPPER_REST_ANGLE;
        }
        if (e.key === 'ArrowRight') {
          rightFlipperTarget = FLIPPER_REST_ANGLE;
        }

        // Launch release
        if (e.key === ' ' && launching && launchHeld) {
          launchHeld = false;
          launching = false;
          const power = launchPower / 100;
          ballObj.vy = -(3 + power * 10);
          ballObj.vx = -0.5; // slight leftward to enter playfield
          launchPower = 0;
        }
      }
    });

    // Expose game data for ML
    window.gameData = {};
    setInterval(() => {
      if (gameState === 'playing') {
        window.gameData = {
          ballX: ballObj.x,
          ballY: ballObj.y,
          ballVX: ballObj.vx,
          ballVY: ballObj.vy,
          leftFlipper: leftFlipperAngle,
          rightFlipper: rightFlipperAngle,
          launching: launching,
          launchPower: launchPower,
          multiplier: multiplier,
          multiball: multiball,
          tilted: tilted,
          balls: balls,
          score: score
        };
      }
    }, 100);

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

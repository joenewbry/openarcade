<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OutRun</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #f4e; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 238, 0.4); }
    h1 { color: #f4e; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 68, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f4e; }
    canvas {
      border: 2px solid #f4e;
      box-shadow: 0 0 20px rgba(255, 68, 238, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f4e;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>OUTRUN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">OUTRUN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Road constants
    const ROAD_W = 2000;         // half-width of road in world units
    const SEG_LENGTH = 200;      // length of each road segment in world units
    const DRAW_DIST = 150;       // how many segments to draw
    const CAM_HEIGHT = 1000;     // camera height
    const CAM_DEPTH = 1 / Math.tan((80 / 2) * Math.PI / 180); // field of view
    const TOTAL_SEGMENTS = 6000; // total road length before looping

    // Checkpoint every N segments
    const CHECKPOINT_INTERVAL = 600;
    const TIME_PER_CHECKPOINT = 15; // seconds added

    // Player
    const MAX_SPEED = SEG_LENGTH * 60; // ~60 segments/second at max
    const ACCEL = MAX_SPEED / 120;     // ~2 seconds to reach max
    const BRAKE = -MAX_SPEED / 60;
    const DECEL = -MAX_SPEED / 300;    // natural deceleration
    const OFF_ROAD_DECEL = -MAX_SPEED / 30;
    const OFF_ROAD_LIMIT = MAX_SPEED / 4;
    const CENTRIFUGAL = 0.3;

    // Sprites / traffic
    const TRAFFIC_DENSITY = 0.03; // chance per segment of having a car
    const TRAFFIC_COLORS = ['#f44', '#4f4', '#44f', '#ff0', '#0ff', '#fa0', '#f4e', '#fff'];

    // State
    let segments = [];
    let playerX;       // -1 to 1, lateral position
    let speed;
    let position;      // z position along road
    let timeLeft;
    let lastTime;
    let keys = {};
    let trafficCars = [];
    let nextCheckpoint;
    let checkpointFlash;
    let frameCount;

    // Scenery types
    const SCENERY_PALM = 0;
    const SCENERY_BUSH = 1;
    const SCENERY_SIGN = 2;
    const SCENERY_ROCK = 3;

    function buildRoad() {
      segments = [];
      for (let i = 0; i < TOTAL_SEGMENTS; i++) {
        const seg = {
          index: i,
          p1: { world: { z: i * SEG_LENGTH }, camera: {}, screen: {} },
          p2: { world: { z: (i + 1) * SEG_LENGTH }, camera: {}, screen: {} },
          curve: 0,
          hill: 0,
          color: {},
          sceneryLeft: null,
          sceneryRight: null,
          trafficCar: null
        };

        // Add curves: gentle S-bends
        if (i > 50 && i < 250) seg.curve = 2;
        else if (i > 300 && i < 500) seg.curve = -3;
        else if (i > 600 && i < 800) seg.curve = 4;
        else if (i > 900 && i < 1050) seg.curve = -2;
        else if (i > 1100 && i < 1400) seg.curve = 3;
        else if (i > 1500 && i < 1700) seg.curve = -4;
        else if (i > 1800 && i < 1950) seg.curve = 2.5;
        else if (i > 2100 && i < 2400) seg.curve = -3.5;
        else if (i > 2500 && i < 2700) seg.curve = 5;
        else if (i > 2800 && i < 3000) seg.curve = -2;
        else if (i > 3200 && i < 3500) seg.curve = 3;
        else if (i > 3600 && i < 3800) seg.curve = -4;
        else if (i > 4000 && i < 4300) seg.curve = 2;
        else if (i > 4500 && i < 4700) seg.curve = -3;
        else if (i > 4900 && i < 5200) seg.curve = 4.5;
        else if (i > 5400 && i < 5600) seg.curve = -5;
        else if (i > 5700 && i < 5900) seg.curve = 3;

        // Hills
        if (i > 100 && i < 180) seg.hill = Math.sin((i - 100) / 80 * Math.PI) * 40;
        else if (i > 350 && i < 450) seg.hill = Math.sin((i - 350) / 100 * Math.PI) * 60;
        else if (i > 700 && i < 780) seg.hill = Math.sin((i - 700) / 80 * Math.PI) * 30;
        else if (i > 1000 && i < 1100) seg.hill = Math.sin((i - 1000) / 100 * Math.PI) * -50;
        else if (i > 1300 && i < 1380) seg.hill = Math.sin((i - 1300) / 80 * Math.PI) * 45;
        else if (i > 1600 && i < 1700) seg.hill = Math.sin((i - 1600) / 100 * Math.PI) * -40;
        else if (i > 2000 && i < 2100) seg.hill = Math.sin((i - 2000) / 100 * Math.PI) * 55;
        else if (i > 2300 && i < 2380) seg.hill = Math.sin((i - 2300) / 80 * Math.PI) * -35;
        else if (i > 2600 && i < 2700) seg.hill = Math.sin((i - 2600) / 100 * Math.PI) * 50;
        else if (i > 3100 && i < 3200) seg.hill = Math.sin((i - 3100) / 100 * Math.PI) * -60;
        else if (i > 3500 && i < 3600) seg.hill = Math.sin((i - 3500) / 100 * Math.PI) * 40;
        else if (i > 4100 && i < 4200) seg.hill = Math.sin((i - 4100) / 100 * Math.PI) * -45;
        else if (i > 4600 && i < 4700) seg.hill = Math.sin((i - 4600) / 100 * Math.PI) * 55;
        else if (i > 5100 && i < 5200) seg.hill = Math.sin((i - 5100) / 100 * Math.PI) * -50;

        // Segment colors (alternating for road stripe effect)
        const dark = (Math.floor(i / 3) % 2 === 0);
        seg.color = {
          road: dark ? '#555' : '#666',
          grass: dark ? '#1a4a1a' : '#1e5e1e',
          rumble: dark ? '#c22' : '#fff',
          lane: dark ? '#fff' : null
        };

        // Checkpoint segments are special color
        if (i % CHECKPOINT_INTERVAL === 0 && i > 0) {
          seg.color.road = '#f4e';
          seg.color.rumble = '#f4e';
        }

        // Scenery
        if (Math.random() < 0.06 && i > 10) {
          const type = Math.random() < 0.5 ? SCENERY_PALM :
                       Math.random() < 0.5 ? SCENERY_BUSH :
                       Math.random() < 0.5 ? SCENERY_SIGN : SCENERY_ROCK;
          const offset = 1.2 + Math.random() * 2.0;
          if (Math.random() < 0.5) {
            seg.sceneryLeft = { type, offset };
          } else {
            seg.sceneryRight = { type, offset };
          }
        }

        segments.push(seg);
      }

      // Pre-compute y positions from hills
      let curY = 0;
      for (let i = 0; i < segments.length; i++) {
        curY += segments[i].hill;
        segments[i].p1.world.y = curY;
      }
      // Set p2.y
      for (let i = 0; i < segments.length - 1; i++) {
        segments[i].p2.world.y = segments[i + 1].p1.world.y;
      }
      segments[segments.length - 1].p2.world.y = segments[segments.length - 1].p1.world.y;
    }

    function spawnTraffic() {
      trafficCars = [];
      for (let i = 30; i < TOTAL_SEGMENTS; i++) {
        if (Math.random() < TRAFFIC_DENSITY) {
          trafficCars.push({
            z: i * SEG_LENGTH + Math.random() * SEG_LENGTH,
            x: -0.7 + Math.random() * 1.4,  // lateral position
            speed: MAX_SPEED * (0.2 + Math.random() * 0.35),
            color: TRAFFIC_COLORS[Math.floor(Math.random() * TRAFFIC_COLORS.length)],
            w: 300  // width in world units
          });
        }
      }
    }

    function init() {
      buildRoad();
      spawnTraffic();
      playerX = 0;
      speed = 0;
      position = 0;
      score = 0;
      timeLeft = 30;
      lastTime = 0;
      frameCount = 0;
      nextCheckpoint = CHECKPOINT_INTERVAL;
      checkpointFlash = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'OUTRUN';
      overlayText.textContent = 'Press SPACE to start';
      keys = {};
      drawFrame();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function findSegment(z) {
      const idx = Math.floor(z / SEG_LENGTH) % TOTAL_SEGMENTS;
      return segments[idx < 0 ? idx + TOTAL_SEGMENTS : idx];
    }

    function project(p, camX, camY, camZ) {
      p.camera.x = (p.world.x || 0) - camX;
      p.camera.y = (p.world.y || 0) - camY;
      p.camera.z = (p.world.z || 0) - camZ;
      if (p.camera.z <= 0) p.camera.z = 1;
      p.screen.scale = CAM_DEPTH / p.camera.z;
      p.screen.x = Math.round(W / 2 + p.screen.scale * p.camera.x * W / 2);
      p.screen.y = Math.round(H / 2 - p.screen.scale * p.camera.y * H / 2);
      p.screen.w = Math.round(p.screen.scale * ROAD_W * W / 2);
    }

    function loop(now) {
      if (gameState !== 'playing') return;

      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      update(dt);
      drawFrame();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      frameCount++;

      // Timer
      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        gameOver();
        return;
      }

      // Current segment for player
      const playerSeg = findSegment(position);
      const speedPct = speed / MAX_SPEED;

      // Acceleration / braking
      if (keys['ArrowUp'] || keys['w']) {
        speed += ACCEL * dt * 60;
      } else if (keys['ArrowDown'] || keys['s']) {
        speed += BRAKE * dt * 60;
      } else {
        speed += DECEL * dt * 60;
      }

      // Steering
      if (keys['ArrowLeft'] || keys['a']) {
        playerX -= 0.04 * speedPct * dt * 60;
      }
      if (keys['ArrowRight'] || keys['d']) {
        playerX += 0.04 * speedPct * dt * 60;
      }

      // Centrifugal force from curves
      playerX -= (playerSeg.curve * speedPct * CENTRIFUGAL * dt);

      // Off-road detection
      if (Math.abs(playerX) > 1.0) {
        // Slow down off road
        if (speed > OFF_ROAD_LIMIT) {
          speed += OFF_ROAD_DECEL * dt * 60;
        }
        // Bump player back slightly
        playerX = Math.max(-2.0, Math.min(2.0, playerX));
      }

      // Clamp speed
      speed = Math.max(0, Math.min(MAX_SPEED, speed));

      // Move forward
      position += speed * dt;

      // Check for traffic collision
      for (let i = 0; i < trafficCars.length; i++) {
        const car = trafficCars[i];
        const carDist = car.z - position;
        if (carDist > 0 && carDist < SEG_LENGTH * 0.8) {
          const playerW = 0.25;
          if (Math.abs(playerX - car.x) < (playerW + 0.2)) {
            // Collision - reduce speed dramatically
            speed = Math.max(0, speed - MAX_SPEED * 0.6);
            // Bounce player away
            if (playerX > car.x) playerX += 0.3;
            else playerX -= 0.3;
            position = car.z - SEG_LENGTH * 0.8;
          }
        }
      }

      // Move traffic
      for (let i = 0; i < trafficCars.length; i++) {
        trafficCars[i].z += trafficCars[i].speed * dt;
        if (trafficCars[i].z > TOTAL_SEGMENTS * SEG_LENGTH) {
          trafficCars[i].z -= TOTAL_SEGMENTS * SEG_LENGTH;
        }
      }

      // Score
      score = Math.floor(position / SEG_LENGTH);
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Checkpoint
      const currentSeg = Math.floor(position / SEG_LENGTH);
      if (currentSeg >= nextCheckpoint) {
        timeLeft += TIME_PER_CHECKPOINT;
        nextCheckpoint += CHECKPOINT_INTERVAL;
        checkpointFlash = 2.0;
      }
      if (checkpointFlash > 0) checkpointFlash -= dt;
    }

    function drawFrame() {
      // Sky gradient - retro sunset
      const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.55);
      skyGrad.addColorStop(0, '#0a0020');
      skyGrad.addColorStop(0.3, '#1a0040');
      skyGrad.addColorStop(0.55, '#4a0060');
      skyGrad.addColorStop(0.75, '#a02050');
      skyGrad.addColorStop(0.9, '#f06030');
      skyGrad.addColorStop(1, '#ff8040');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, H);

      // Sun
      const sunY = H * 0.38;
      const sunR = 40;
      ctx.fillStyle = '#ff4060';
      ctx.shadowColor = '#ff4060';
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(W / 2, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Sun stripes (horizontal lines through sun for retro look)
      ctx.fillStyle = '#0a0020';
      for (let i = 0; i < 6; i++) {
        const stripeY = sunY - sunR + 10 + i * 14;
        const stripeH = 2 + i * 0.8;
        // Only draw within the sun circle
        const dy = stripeY - sunY;
        if (Math.abs(dy) < sunR) {
          const halfW = Math.sqrt(sunR * sunR - dy * dy);
          ctx.fillRect(W / 2 - halfW, stripeY, halfW * 2, stripeH);
        }
      }

      // Stars in upper sky
      if (frameCount === undefined || frameCount === 0) {
        // Stars are seeded, not random per frame
      }

      const baseSegIdx = Math.floor(position / SEG_LENGTH);
      const camZ = position - (position % SEG_LENGTH);

      // Compute cumulative curve for camera X offset
      let camX = playerX * ROAD_W;
      let camY = CAM_HEIGHT;

      // Get the y of the segment the player is on
      const pSeg = findSegment(position);
      camY += pSeg.p1.world.y;

      let maxY = H; // clip below this line

      // Collect segments to draw
      const drawSegs = [];

      let curCurveX = 0;
      for (let n = 0; n < DRAW_DIST; n++) {
        const idx = (baseSegIdx + n) % TOTAL_SEGMENTS;
        const seg = segments[idx];

        // Adjust z for wrapping
        const loopOffset = (baseSegIdx + n >= TOTAL_SEGMENTS) ? TOTAL_SEGMENTS * SEG_LENGTH : 0;

        seg.p1.world.z = (idx) * SEG_LENGTH + loopOffset;
        seg.p2.world.z = (idx + 1) * SEG_LENGTH + loopOffset;

        // Apply curve as cumulative x offset
        seg.p1.world.x = curCurveX;
        curCurveX += seg.curve;
        seg.p2.world.x = curCurveX;

        project(seg.p1, camX + seg.p1.world.x, camY, position);
        project(seg.p2, camX + seg.p2.world.x, camY, position);

        // Skip segments behind camera or above screen
        if (seg.p1.camera.z <= 0 || seg.p2.screen.y >= maxY) continue;

        drawSegs.push({ seg, idx });
      }

      // Draw segments back to front
      for (let i = drawSegs.length - 1; i >= 0; i--) {
        const { seg, idx } = drawSegs[i];

        const p1 = seg.p1.screen;
        const p2 = seg.p2.screen;

        // Clip
        if (p1.y > H && p2.y > H) continue;

        const y1 = Math.max(0, Math.min(H, p2.y));
        const y2 = Math.max(0, Math.min(H, p1.y));
        if (y1 >= y2) continue;

        // Grass
        ctx.fillStyle = seg.color.grass;
        ctx.fillRect(0, y1, W, y2 - y1);

        // Road
        drawQuad(ctx, seg.color.road,
          p1.x - p1.w, p1.y, p1.w * 2,
          p2.x - p2.w, p2.y, p2.w * 2);

        // Rumble strips
        const rw1 = p1.w * 0.08;
        const rw2 = p2.w * 0.08;
        drawQuad(ctx, seg.color.rumble,
          p1.x - p1.w - rw1, p1.y, rw1,
          p2.x - p2.w - rw2, p2.y, rw2);
        drawQuad(ctx, seg.color.rumble,
          p1.x + p1.w, p1.y, rw1,
          p2.x + p2.w, p2.y, rw2);

        // Lane markings
        if (seg.color.lane) {
          const laneW1 = p1.w * 0.015;
          const laneW2 = p2.w * 0.015;
          for (let lane = -1; lane <= 1; lane += 2) {
            const lx1 = p1.x + p1.w * lane * 0.33;
            const lx2 = p2.x + p2.w * lane * 0.33;
            drawQuad(ctx, seg.color.lane,
              lx1 - laneW1, p1.y, laneW1 * 2,
              lx2 - laneW2, p2.y, laneW2 * 2);
          }
        }

        // Scenery
        if (seg.sceneryLeft) {
          drawScenery(seg.sceneryLeft, -1, p1, p2, seg);
        }
        if (seg.sceneryRight) {
          drawScenery(seg.sceneryRight, 1, p1, p2, seg);
        }

        // Traffic cars on this segment
        for (let t = 0; t < trafficCars.length; t++) {
          const car = trafficCars[t];
          const carSegIdx = Math.floor(car.z / SEG_LENGTH) % TOTAL_SEGMENTS;
          if (carSegIdx === idx) {
            drawTrafficCar(car, seg);
          }
        }
      }

      // Player car
      drawPlayerCar();

      // HUD
      drawHUD();

      // Checkpoint flash
      if (checkpointFlash > 0) {
        const alpha = Math.min(1, checkpointFlash) * 0.6;
        ctx.fillStyle = `rgba(255, 68, 238, ${alpha * 0.15})`;
        ctx.fillRect(0, 0, W, H);
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(255, 68, 238, ${alpha})`;
        ctx.shadowColor = '#f4e';
        ctx.shadowBlur = 20;
        ctx.fillText('CHECKPOINT! +' + TIME_PER_CHECKPOINT + 's', W / 2, H / 2 - 40);
        ctx.shadowBlur = 0;
      }
    }

    function drawQuad(ctx, color, x1, y1, w1, x2, y2, w2) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x1 + w1, y1);
      ctx.lineTo(x2 + w2, y2);
      ctx.lineTo(x2, y2);
      ctx.closePath();
      ctx.fill();
    }

    function drawScenery(item, side, p1, p2, seg) {
      // Interpolate position
      const scale = p1.scale || (seg.p1.screen.scale);
      if (!scale || scale < 0.001) return;

      const x = side > 0
        ? p1.x + p1.w * item.offset
        : p1.x - p1.w * item.offset;
      const y = p1.y;

      const size = scale * 4000;
      if (size < 2) return;

      switch (item.type) {
        case SCENERY_PALM:
          // Trunk
          ctx.fillStyle = '#5a3a1a';
          ctx.fillRect(x - size * 0.03, y - size * 0.5, size * 0.06, size * 0.5);
          // Leaves
          ctx.fillStyle = '#1a6a1a';
          ctx.shadowColor = '#2a8a2a';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(x, y - size * 0.5, size * 0.15, 0, Math.PI * 2);
          ctx.fill();
          // Extra leaf clusters
          ctx.beginPath();
          ctx.arc(x - size * 0.1, y - size * 0.45, size * 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + size * 0.1, y - size * 0.45, size * 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          break;

        case SCENERY_BUSH:
          ctx.fillStyle = '#1a5a2a';
          ctx.shadowColor = '#2a7a3a';
          ctx.shadowBlur = 3;
          ctx.beginPath();
          ctx.arc(x, y - size * 0.06, size * 0.08, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          break;

        case SCENERY_SIGN:
          // Post
          ctx.fillStyle = '#888';
          ctx.fillRect(x - size * 0.01, y - size * 0.3, size * 0.02, size * 0.3);
          // Sign face
          ctx.fillStyle = '#224';
          ctx.fillRect(x - size * 0.08, y - size * 0.32, size * 0.16, size * 0.1);
          ctx.fillStyle = '#f4e';
          ctx.shadowColor = '#f4e';
          ctx.shadowBlur = 4;
          ctx.fillRect(x - size * 0.06, y - size * 0.3, size * 0.12, size * 0.06);
          ctx.shadowBlur = 0;
          break;

        case SCENERY_ROCK:
          ctx.fillStyle = '#444';
          ctx.beginPath();
          ctx.arc(x, y - size * 0.03, size * 0.05, 0, Math.PI * 2);
          ctx.fill();
          break;
      }
    }

    function drawTrafficCar(car, seg) {
      const p1 = seg.p1.screen;
      const p2 = seg.p2.screen;

      // Interpolate within segment
      const segStart = Math.floor(car.z / SEG_LENGTH) * SEG_LENGTH;
      const frac = (car.z - segStart) / SEG_LENGTH;

      const cx = p1.x + (p2.x - p1.x) * frac + (p1.w + (p2.w - p1.w) * frac) * car.x;
      const cy = p1.y + (p2.y - p1.y) * frac;
      const scale = p1.scale || seg.p1.screen.scale;
      if (!scale || scale < 0.001) return;

      const cw = scale * car.w;
      const ch = cw * 0.6;

      if (cw < 1) return;

      // Car body
      ctx.fillStyle = car.color;
      ctx.shadowColor = car.color;
      ctx.shadowBlur = 6;
      ctx.fillRect(cx - cw / 2, cy - ch, cw, ch);

      // Roof (darker)
      ctx.fillStyle = shadeColor(car.color, -40);
      ctx.fillRect(cx - cw * 0.35, cy - ch * 1.3, cw * 0.7, ch * 0.4);

      // Windshield
      ctx.fillStyle = '#aae';
      ctx.fillRect(cx - cw * 0.3, cy - ch * 1.25, cw * 0.6, ch * 0.3);

      ctx.shadowBlur = 0;
    }

    function shadeColor(hex, amt) {
      let r = parseInt(hex.slice(1, 2), 16) * 17;
      let g = parseInt(hex.slice(2, 3), 16) * 17;
      let b = parseInt(hex.slice(3, 4), 16) * 17;
      r = Math.max(0, Math.min(255, r + amt));
      g = Math.max(0, Math.min(255, g + amt));
      b = Math.max(0, Math.min(255, b + amt));
      return `rgb(${r},${g},${b})`;
    }

    function drawPlayerCar() {
      const carW = 50;
      const carH = 30;
      const cx = W / 2;
      const cy = H - 50;

      // Steering visual tilt
      const steerOffset = (keys['ArrowLeft'] || keys['a'] ? -3 : 0) +
                           (keys['ArrowRight'] || keys['d'] ? 3 : 0);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(cx - carW / 2 + 3, cy - 2, carW, 8);

      // Car body
      ctx.fillStyle = '#f4e';
      ctx.shadowColor = '#f4e';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(cx - carW / 2 + steerOffset, cy);
      ctx.lineTo(cx + carW / 2 + steerOffset, cy);
      ctx.lineTo(cx + carW / 2 - 3, cy - carH);
      ctx.lineTo(cx - carW / 2 + 3, cy - carH);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Roof
      ctx.fillStyle = '#c3b';
      ctx.fillRect(cx - carW * 0.3, cy - carH - 12, carW * 0.6, 14);

      // Windshield
      ctx.fillStyle = '#99ccff';
      ctx.fillRect(cx - carW * 0.25, cy - carH - 10, carW * 0.5, 10);

      // Rear lights
      ctx.fillStyle = '#f00';
      ctx.shadowColor = '#f00';
      ctx.shadowBlur = 8;
      ctx.fillRect(cx - carW / 2 + steerOffset + 2, cy - 5, 6, 4);
      ctx.fillRect(cx + carW / 2 + steerOffset - 8, cy - 5, 6, 4);
      ctx.shadowBlur = 0;

      // Wheels
      ctx.fillStyle = '#222';
      ctx.fillRect(cx - carW / 2 - 3 + steerOffset, cy - 6, 6, 8);
      ctx.fillRect(cx + carW / 2 - 3 + steerOffset, cy - 6, 6, 8);
      ctx.fillRect(cx - carW / 2 - 1, cy - carH + 2, 6, 8);
      ctx.fillRect(cx + carW / 2 - 5, cy - carH + 2, 6, 8);
    }

    function drawHUD() {
      // Speed gauge background
      const gaugeX = 10;
      const gaugeY = H - 35;
      const gaugeW = 120;
      const gaugeH = 14;
      const speedPct = speed / MAX_SPEED;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(gaugeX - 2, gaugeY - 18, gaugeW + 4, gaugeH + 24);

      ctx.font = '10px Courier New';
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left';
      ctx.fillText('SPEED', gaugeX, gaugeY - 6);

      // Speed bar
      ctx.fillStyle = '#333';
      ctx.fillRect(gaugeX, gaugeY, gaugeW, gaugeH);

      const speedColor = speedPct < 0.5 ? '#4f4' : speedPct < 0.8 ? '#ff0' : '#f44';
      ctx.fillStyle = speedColor;
      ctx.shadowColor = speedColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(gaugeX, gaugeY, gaugeW * speedPct, gaugeH);
      ctx.shadowBlur = 0;

      // Speed text (km/h)
      const kmh = Math.floor(speedPct * 280);
      ctx.font = 'bold 11px Courier New';
      ctx.fillStyle = '#fff';
      ctx.fillText(kmh + ' km/h', gaugeX + gaugeW + 5, gaugeY + 12);

      // Timer
      ctx.font = 'bold 22px Courier New';
      ctx.textAlign = 'center';
      const timeColor = timeLeft <= 5 ? '#f44' : timeLeft <= 10 ? '#ff0' : '#fff';
      ctx.fillStyle = timeColor;
      ctx.shadowColor = timeColor;
      ctx.shadowBlur = timeLeft <= 5 ? 12 : 0;
      ctx.fillText('TIME: ' + Math.ceil(timeLeft), W / 2, 28);
      ctx.shadowBlur = 0;

      // Timer flash when low
      if (timeLeft <= 5 && Math.floor(timeLeft * 4) % 2 === 0) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.08)';
        ctx.fillRect(0, 0, W, H);
      }

      // Next checkpoint distance
      const distToCheckpoint = nextCheckpoint - Math.floor(position / SEG_LENGTH);
      ctx.font = '11px Courier New';
      ctx.textAlign = 'right';
      ctx.fillStyle = '#f4e';
      ctx.fillText('NEXT CP: ' + distToCheckpoint + 'm', W - 10, 20);

      // Controls hint (only when slow/stopped)
      if (speed < MAX_SPEED * 0.05 && gameState === 'playing') {
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(255, 68, 238, 0.5)';
        ctx.fillText('UP=Gas  DOWN=Brake  LEFT/RIGHT=Steer', W / 2, H - 8);
      }
    }

    // Keyboard handling
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

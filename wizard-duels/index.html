<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wizard Duels</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #a4f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 68, 255, 0.5); }
    h1 { color: #a4f; font-size: 1.6rem; text-shadow: 0 0 15px rgba(170, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a4f; }
    canvas {
      border: 2px solid #a4f;
      box-shadow: 0 0 20px rgba(170, 68, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a4f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .controls-info {
      width: 600px;
      margin-top: 12px;
      font-size: 0.8rem;
      color: #667;
      text-align: center;
    }
    .controls-info span { color: #a4f; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WIZARD DUELS</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="score">0</span> dmg</div>
    <div>Round <span id="roundNum">1</span>/3</div>
    <div>AI: <span id="aiScore">0</span> dmg</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">WIZARD DUELS</h2>
      <p id="overlayText">Press any key to start</p>
    </div>
  </div>
  <div class="controls-info">
    <span>[1]</span> Fire &bull; <span>[2]</span> Ice &bull; <span>[3]</span> Lightning &bull; <span>[4]</span> Heal &bull; <span>[S]</span> Shield &bull; <span>[Space]</span> Meditate
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const roundNumEl = document.getElementById('roundNum');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Prevent default for game keys
    document.addEventListener('keydown', function(e) {
      if (['1','2','3','4','s','S',' '].includes(e.key)) e.preventDefault();
    });

    // ─── Global game state ───
    let gameState = 'menu';
    let score = 0;

    // ─── Constants ───
    const MAX_HP = 100;
    const MAX_MANA = 100;
    const MANA_REGEN = 0.15;
    const MEDITATE_REGEN = 0.8;
    const SHIELD_DURATION = 40;
    const SHIELD_COOLDOWN = 90;
    const BLIND_DURATION = 120;

    const SPELLS = {
      fire:      { name: 'Fire',      mana: 15, damage: 18, speed: 6,   color: '#f72', trail: '#fa3', size: 6 },
      ice:       { name: 'Ice',       mana: 20, damage: 15, speed: 3.5, color: '#4df', trail: '#8ef', size: 8, slow: true, slowDur: 120 },
      lightning: { name: 'Lightning', mana: 40, damage: 35, speed: 12,  color: '#ff0', trail: '#ff8', size: 4 },
      heal:      { name: 'Heal',      mana: 30, damage: 0,  speed: 0,   color: '#4f8', trail: '#8fa', size: 0 }
    };

    const COMBO_STEAM     = { name: 'Steam',     damage: 10, color: '#ccc', trail: '#eee', size: 12, speed: 5, blind: true };
    const COMBO_EXPLOSION = { name: 'Explosion',  damage: 45, color: '#f80', trail: '#fc0', size: 14, speed: 7, explosive: true };

    // ─── Wizard factory ───
    function createWizard(x, facing, isAI) {
      return {
        x: x, y: 260, facing: facing, isAI: isAI,
        hp: MAX_HP, mana: MAX_MANA,
        shieldUp: false, shieldTimer: 0, shieldCooldown: 0,
        meditating: false,
        blinded: 0, slowed: 0,
        castAnim: 0, castSpellType: null,
        lastSpell: null, comboTimer: 0,
        hitAnim: 0, healAnim: 0,
        roundWins: 0, totalDamage: 0
      };
    }

    let player, ai;
    let projectiles = [];
    let particles = [];
    let floatingTexts = [];
    let currentRound = 1;
    let roundTimer = 0;
    let aiDecisionTimer = 0;
    let savedPlayerWins = 0;
    let savedAiWins = 0;

    // ─── Init ───
    function initRound() {
      player = createWizard(80, 1, false);
      ai = createWizard(520, -1, true);
      player.roundWins = savedPlayerWins;
      ai.roundWins = savedAiWins;
      player.totalDamage = score;
      projectiles = [];
      particles = [];
      floatingTexts = [];
      roundTimer = 0;
      aiDecisionTimer = 0;
    }

    function initGame() {
      score = 0;
      currentRound = 1;
      savedPlayerWins = 0;
      savedAiWins = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      roundNumEl.textContent = '1';
      initRound();
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    // ─── Input ───
    const keys = {};
    document.addEventListener('keydown', function(e) {
      keys[e.key] = true;

      if (gameState === 'menu' || gameState === 'gameOver') {
        initGame();
        return;
      }
      if (gameState === 'roundEnd') {
        nextRound();
        return;
      }
      if (gameState !== 'playing') return;

      if (e.key === '1') castSpell(player, ai, 'fire');
      if (e.key === '2') castSpell(player, ai, 'ice');
      if (e.key === '3') castSpell(player, ai, 'lightning');
      if (e.key === '4') castSpell(player, ai, 'heal');
      if (e.key === 's' || e.key === 'S') activateShield(player);
    });

    document.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });

    // ─── Spell casting ───
    function castSpell(caster, target, type) {
      var spell = SPELLS[type];
      if (caster.mana < spell.mana) return;
      if (caster.shieldUp) return;

      caster.mana -= spell.mana;
      caster.meditating = false;
      caster.castAnim = 20;
      caster.castSpellType = type;

      if (type === 'heal') {
        var healAmt = 25;
        caster.hp = Math.min(MAX_HP, caster.hp + healAmt);
        caster.healAnim = 30;
        addFloatingText(caster.x, caster.y - 40, '+' + healAmt, '#4f8');
        spawnParticles(caster.x, caster.y - 20, '#4f8', 12);
        caster.lastSpell = null;
        caster.comboTimer = 0;
        return;
      }

      // Check for combo
      var comboSpell = null;
      if (caster.comboTimer > 0 && caster.lastSpell) {
        var pair = [caster.lastSpell, type].sort().join('+');
        if (pair === 'fire+ice') comboSpell = COMBO_STEAM;
        if (pair === 'fire+lightning') comboSpell = COMBO_EXPLOSION;
      }

      if (comboSpell) {
        projectiles.push(createProjectile(caster, target, comboSpell, true));
        addFloatingText(caster.x, caster.y - 60, comboSpell.name + '!', comboSpell.color);
        spawnParticles(caster.x + caster.facing * 20, caster.y - 20, comboSpell.color, 20);
        caster.lastSpell = null;
        caster.comboTimer = 0;
      } else {
        projectiles.push(createProjectile(caster, target, spell, false));
        spawnParticles(caster.x + caster.facing * 20, caster.y - 20, spell.color, 8);
        caster.lastSpell = type;
        caster.comboTimer = 90;
      }
    }

    function createProjectile(caster, target, spell, isCombo) {
      return {
        x: caster.x + caster.facing * 30,
        y: caster.y - 20,
        vx: spell.speed * caster.facing,
        vy: (Math.random() - 0.5) * 0.5,
        spell: spell,
        isCombo: isCombo,
        owner: caster,
        target: target,
        size: spell.size,
        life: 200,
        trail: []
      };
    }

    function activateShield(wizard) {
      if (wizard.shieldCooldown > 0) return;
      if (wizard.mana < 5) return;
      wizard.shieldUp = true;
      wizard.shieldTimer = SHIELD_DURATION;
      wizard.shieldCooldown = SHIELD_COOLDOWN;
      wizard.meditating = false;
      wizard.mana -= 5;
    }

    // ─── AI Logic ───
    function updateAI() {
      aiDecisionTimer--;
      if (aiDecisionTimer > 0) return;

      aiDecisionTimer = ai.blinded > 0 ? (55 + Math.random() * 40) : (22 + Math.random() * 28);

      // Check incoming projectiles
      var incoming = projectiles.filter(function(p) { return p.target === ai; });
      var nearest = null;
      var nearestDist = Infinity;
      for (var i = 0; i < incoming.length; i++) {
        var d = Math.abs(incoming[i].x - ai.x);
        if (d < nearestDist) {
          nearestDist = d;
          nearest = incoming[i];
        }
      }

      // Shield timing
      if (nearest && nearestDist < 140 && !ai.shieldUp && ai.shieldCooldown <= 0) {
        var shieldChance = nearest.isCombo ? 0.85 : 0.7;
        if (Math.random() < shieldChance) {
          activateShield(ai);
          aiDecisionTimer = 15;
          return;
        }
      }

      // Meditate when low mana and safe
      if (ai.mana < 20 && (!nearest || nearestDist > 300)) {
        ai.meditating = true;
        aiDecisionTimer = 35 + Math.random() * 20;
        return;
      }

      // Stop meditating on threat
      if (ai.meditating && nearest && nearestDist < 250) {
        ai.meditating = false;
      }

      // Heal if low HP
      if (ai.hp < 40 && ai.mana >= SPELLS.heal.mana && Math.random() < 0.6) {
        castSpell(ai, player, 'heal');
        aiDecisionTimer = 30;
        return;
      }

      // Blinded: sometimes do nothing
      if (ai.blinded > 0 && Math.random() < 0.4) {
        aiDecisionTimer = 20;
        return;
      }

      // Combo strategy
      if (ai.comboTimer > 0 && ai.lastSpell === 'fire') {
        if (ai.mana >= SPELLS.ice.mana && Math.random() < 0.6) { castSpell(ai, player, 'ice'); return; }
        if (ai.mana >= SPELLS.lightning.mana && Math.random() < 0.5) { castSpell(ai, player, 'lightning'); return; }
      }
      if (ai.comboTimer > 0 && ai.lastSpell === 'ice' && ai.mana >= SPELLS.fire.mana && Math.random() < 0.5) {
        castSpell(ai, player, 'fire'); return;
      }
      if (ai.comboTimer > 0 && ai.lastSpell === 'lightning' && ai.mana >= SPELLS.fire.mana && Math.random() < 0.5) {
        castSpell(ai, player, 'fire'); return;
      }

      // General offense
      var r = Math.random();
      if (ai.mana >= SPELLS.lightning.mana && r < 0.15 && ai.mana > 60) {
        castSpell(ai, player, 'lightning');
      } else if (ai.mana >= SPELLS.ice.mana && r < 0.45) {
        castSpell(ai, player, 'ice');
      } else if (ai.mana >= SPELLS.fire.mana) {
        castSpell(ai, player, 'fire');
      } else {
        ai.meditating = true;
        aiDecisionTimer = 30;
      }
    }

    // ─── Particles ───
    function spawnParticles(x, y, color, count) {
      for (var i = 0; i < count; i++) {
        particles.push({
          x: x, y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4 - 1,
          color: color,
          life: 20 + Math.random() * 20,
          maxLife: 40,
          size: 2 + Math.random() * 3
        });
      }
    }

    function spawnExplosion(x, y, color, count) {
      for (var i = 0; i < count; i++) {
        var angle = Math.random() * Math.PI * 2;
        var speed = 1 + Math.random() * 5;
        particles.push({
          x: x, y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          color: color,
          life: 30 + Math.random() * 30,
          maxLife: 60,
          size: 2 + Math.random() * 4
        });
      }
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x: x, y: y, text: text, color: color, life: 60 });
    }

    // ─── Update ───
    function update() {
      if (gameState !== 'playing') return;
      roundTimer++;

      // Mana regen
      var wizards = [player, ai];
      for (var wi = 0; wi < 2; wi++) {
        var w = wizards[wi];
        if (w.meditating) {
          w.mana = Math.min(MAX_MANA, w.mana + MEDITATE_REGEN);
        } else {
          w.mana = Math.min(MAX_MANA, w.mana + MANA_REGEN);
        }
      }

      // Player meditation
      player.meditating = keys[' '] && !player.shieldUp;

      // Timers
      for (var wi = 0; wi < 2; wi++) {
        var w = wizards[wi];
        if (w.shieldTimer > 0) {
          w.shieldTimer--;
          if (w.shieldTimer <= 0) w.shieldUp = false;
        }
        if (w.shieldCooldown > 0) w.shieldCooldown--;
        if (w.castAnim > 0) w.castAnim--;
        if (w.hitAnim > 0) w.hitAnim--;
        if (w.healAnim > 0) w.healAnim--;
        if (w.blinded > 0) w.blinded--;
        if (w.slowed > 0) w.slowed--;
        if (w.comboTimer > 0) w.comboTimer--;
      }

      // AI
      updateAI();

      // Projectiles
      for (var i = projectiles.length - 1; i >= 0; i--) {
        var p = projectiles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        p.trail.push({ x: p.x, y: p.y, life: 15 });
        if (p.trail.length > 20) p.trail.shift();

        // Trail particles
        if (Math.random() < 0.4) {
          particles.push({
            x: p.x + (Math.random() - 0.5) * 4,
            y: p.y + (Math.random() - 0.5) * 4,
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            color: p.spell.trail,
            life: 8 + Math.random() * 8,
            maxLife: 16,
            size: 1.5 + Math.random() * 2
          });
        }

        // Collision
        var target = p.target;
        var dx = p.x - target.x;
        var dy = p.y - (target.y - 20);

        if (Math.abs(dx) < 25 && Math.abs(dy) < 40) {
          if (target.shieldUp) {
            spawnExplosion(target.x + target.facing * -20, target.y - 20, '#fff', 15);
            addFloatingText(target.x, target.y - 50, 'Blocked!', '#fff');
            projectiles.splice(i, 1);
            continue;
          }

          var dmg = p.spell.damage;
          target.hp = Math.max(0, target.hp - dmg);
          target.hitAnim = 15;
          p.owner.totalDamage += dmg;

          if (p.owner === player) {
            score += dmg;
            scoreEl.textContent = score;
          } else {
            aiScoreEl.textContent = ai.totalDamage;
          }

          addFloatingText(target.x, target.y - 50, '-' + dmg, p.spell.color);

          if (p.spell.blind) {
            target.blinded = BLIND_DURATION;
            addFloatingText(target.x, target.y - 70, 'Blinded!', '#ccc');
          }
          if (p.spell.slow) {
            target.slowed = p.spell.slowDur || 120;
          }

          if (p.spell.explosive) {
            spawnExplosion(p.x, p.y, '#f80', 40);
            spawnExplosion(p.x, p.y, '#ff0', 20);
          } else {
            spawnExplosion(p.x, p.y, p.spell.color, 20);
          }

          projectiles.splice(i, 1);
          continue;
        }

        if (p.x < -20 || p.x > W + 20 || p.life <= 0) {
          projectiles.splice(i, 1);
        }
      }

      // Update particles
      for (var i = particles.length - 1; i >= 0; i--) {
        var p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.03;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Floating texts
      for (var i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].y -= 0.8;
        floatingTexts[i].life--;
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
      }

      // Round end check
      if (player.hp <= 0 || ai.hp <= 0) {
        endRound();
      }
    }

    function endRound() {
      var playerWon = ai.hp <= 0;
      if (playerWon) player.roundWins++;
      else ai.roundWins++;

      savedPlayerWins = player.roundWins;
      savedAiWins = ai.roundWins;

      if (currentRound >= 3 || player.roundWins >= 2 || ai.roundWins >= 2) {
        gameState = 'gameOver';
        var won = player.roundWins > ai.roundWins;
        overlayTitle.textContent = won ? 'VICTORY!' : 'DEFEATED';
        overlayText.textContent = 'Score: ' + score + ' | Rounds: ' + player.roundWins + '-' + ai.roundWins + ' | Press any key';
        overlay.style.display = 'flex';
      } else {
        gameState = 'roundEnd';
        overlayTitle.textContent = playerWon ? 'Round Won!' : 'Round Lost!';
        overlayText.textContent = 'Round ' + currentRound + '/3 | ' + player.roundWins + '-' + ai.roundWins + ' | Press any key';
        overlay.style.display = 'flex';
      }
    }

    function nextRound() {
      currentRound++;
      roundNumEl.textContent = currentRound;
      initRound();
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    // ─── Drawing ───
    function drawWizard(w, label) {
      var cx = w.x;
      var cy = w.y;
      var f = w.facing;
      var flash = w.hitAnim > 0 && w.hitAnim % 4 < 2;

      ctx.save();
      ctx.translate(cx, cy);

      // Robe
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(-16, 40);
      ctx.lineTo(16, 40);
      ctx.lineTo(12, 0);
      ctx.closePath();
      ctx.fillStyle = flash ? '#fff' : (w.isAI ? '#833' : '#338');
      ctx.fill();
      ctx.strokeStyle = flash ? '#fff' : (w.isAI ? '#f44' : '#48f');
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Robe detail - belt
      ctx.strokeStyle = flash ? '#fff' : (w.isAI ? '#a33' : '#33a');
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-13, 15);
      ctx.lineTo(13, 15);
      ctx.stroke();

      // Hat
      ctx.beginPath();
      ctx.moveTo(-14, -5);
      ctx.lineTo(f * 5, -50);
      ctx.lineTo(14, -5);
      ctx.closePath();
      ctx.fillStyle = flash ? '#fff' : (w.isAI ? '#622' : '#226');
      ctx.fill();
      ctx.strokeStyle = flash ? '#fff' : (w.isAI ? '#f44' : '#48f');
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Hat star
      ctx.fillStyle = flash ? '#fff' : '#ff0';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('\u2605', f * 2, -22);

      // Brim
      ctx.beginPath();
      ctx.ellipse(0, -5, 18, 5, 0, 0, Math.PI * 2);
      ctx.fillStyle = flash ? '#fff' : (w.isAI ? '#833' : '#338');
      ctx.fill();
      ctx.strokeStyle = flash ? '#fff' : (w.isAI ? '#f44' : '#48f');
      ctx.stroke();

      // Face
      ctx.fillStyle = '#dba';
      ctx.fillRect(-6, -16, 12, 10);

      // Eyes
      if (w.blinded > 0) {
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(-4, -13); ctx.lineTo(-1, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-1, -13); ctx.lineTo(-4, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(2, -13); ctx.lineTo(5, -10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, -13); ctx.lineTo(2, -10); ctx.stroke();
      } else {
        ctx.fillStyle = '#fff';
        ctx.fillRect(f > 0 ? -4 : -2, -14, 3, 3);
        ctx.fillRect(f > 0 ? 2 : 0, -14, 3, 3);
        ctx.fillStyle = '#111';
        ctx.fillRect(f > 0 ? -3 : -1, -13, 1.5, 1.5);
        ctx.fillRect(f > 0 ? 3 : 1, -13, 1.5, 1.5);
      }

      // Staff arm + staff
      var armAngle = w.castAnim > 0 ? -0.6 : 0.15;
      ctx.save();
      ctx.translate(f * 10, 5);
      ctx.rotate(armAngle * f);
      ctx.strokeStyle = flash ? '#fff' : '#dba';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(f * 15, -10);
      ctx.stroke();
      ctx.strokeStyle = '#864';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(f * 12, 15);
      ctx.lineTo(f * 18, -25);
      ctx.stroke();
      // Staff orb
      var orbColor = '#a4f';
      if (w.castAnim > 0 && w.castSpellType && SPELLS[w.castSpellType]) {
        orbColor = SPELLS[w.castSpellType].color;
      }
      ctx.beginPath();
      ctx.arc(f * 18, -27, 5, 0, Math.PI * 2);
      ctx.fillStyle = orbColor;
      ctx.shadowColor = orbColor;
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();

      // Shield bubble
      if (w.shieldUp) {
        var sa = 0.3 + 0.2 * Math.sin(roundTimer * 0.2);
        ctx.beginPath();
        ctx.ellipse(f * -5, -5, 30, 48, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(170, 68, 255, ' + (sa + 0.3) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'rgba(170, 68, 255, ' + sa + ')';
        ctx.fill();
        // Shield rune
        ctx.fillStyle = 'rgba(255, 255, 255, ' + (sa + 0.1) + ')';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('\u2726', f * -5, 0);
      }

      // Meditation aura
      if (w.meditating) {
        for (var mi = 0; mi < 4; mi++) {
          var ma = roundTimer * 0.05 + mi * (Math.PI * 2 / 4);
          var mrx = Math.cos(ma) * 22;
          var mry = Math.sin(ma) * 35;
          ctx.beginPath();
          ctx.arc(mrx, mry - 5, 3, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(100, 180, 255, ' + (0.3 + 0.2 * Math.sin(roundTimer * 0.1 + mi)) + ')';
          ctx.fill();
        }
        // Mana stream visual
        ctx.strokeStyle = 'rgba(100, 180, 255, 0.15)';
        ctx.lineWidth = 1;
        for (var mi = 0; mi < 6; mi++) {
          var my = -40 + mi * 15;
          var mx = Math.sin(roundTimer * 0.08 + mi) * 15;
          ctx.beginPath();
          ctx.moveTo(mx - 5, my);
          ctx.lineTo(mx + 5, my);
          ctx.stroke();
        }
      }

      // Heal aura
      if (w.healAnim > 0) {
        var ha = w.healAnim / 30;
        ctx.beginPath();
        ctx.ellipse(0, 0, 25 * (1 + (1 - ha) * 0.5), 40 * (1 + (1 - ha) * 0.5), 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(68, 255, 136, ' + (ha * 0.3) + ')';
        ctx.fill();
        ctx.strokeStyle = 'rgba(68, 255, 136, ' + (ha * 0.5) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Blind cloud
      if (w.blinded > 0) {
        var ba = Math.min(1, w.blinded / 30);
        ctx.fillStyle = 'rgba(200, 200, 200, ' + (ba * 0.25) + ')';
        ctx.beginPath();
        ctx.ellipse(0, -15, 22, 30, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, ' + (ba * 0.6) + ')';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('BLIND', 0, -38);
      }

      ctx.restore();

      // HP bar
      var barW = 54;
      var barH = 7;
      var barX = cx - barW / 2;
      var barY = cy - 65;
      ctx.fillStyle = '#222';
      ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
      var hpPct = w.hp / MAX_HP;
      var hpColor = hpPct > 0.5 ? '#4f4' : hpPct > 0.25 ? '#fa0' : '#f44';
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpColor;
      ctx.fillRect(barX, barY, barW * hpPct, barH);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barW, barH);
      // HP number
      ctx.fillStyle = '#fff';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(Math.ceil(w.hp), cx, barY + 6);

      // Mana bar
      var mBarY = barY + barH + 2;
      var mBarH = 5;
      ctx.fillStyle = '#222';
      ctx.fillRect(barX - 1, mBarY - 1, barW + 2, mBarH + 2);
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, mBarY, barW, mBarH);
      ctx.fillStyle = '#48f';
      ctx.fillRect(barX, mBarY, barW * (w.mana / MAX_MANA), mBarH);
      ctx.strokeStyle = '#555';
      ctx.strokeRect(barX, mBarY, barW, mBarH);

      // Label
      ctx.fillStyle = '#888';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy + 55);
    }

    function drawBackground() {
      // Sky gradient
      var grd = ctx.createLinearGradient(0, 0, 0, H);
      grd.addColorStop(0, '#050515');
      grd.addColorStop(0.5, '#12122e');
      grd.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      // Stars
      ctx.fillStyle = '#fff';
      for (var i = 0; i < 50; i++) {
        var sx = (i * 137.5 + 23) % W;
        var sy = (i * 73.1 + 11) % (H * 0.55);
        var ss = 0.5 + (i % 3) * 0.5;
        var twinkle = 0.3 + 0.7 * Math.abs(Math.sin(roundTimer * 0.015 + i * 0.7));
        ctx.globalAlpha = twinkle * 0.6;
        ctx.fillRect(sx, sy, ss, ss);
      }
      ctx.globalAlpha = 1;

      // Moon
      ctx.beginPath();
      ctx.arc(480, 50, 22, 0, Math.PI * 2);
      ctx.fillStyle = '#dde';
      ctx.globalAlpha = 0.15;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(480, 50, 18, 0, Math.PI * 2);
      ctx.fillStyle = '#eef';
      ctx.globalAlpha = 0.08;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Ground
      var groundGrd = ctx.createLinearGradient(0, 295, 0, H);
      groundGrd.addColorStop(0, '#2a2a4e');
      groundGrd.addColorStop(1, '#1e1e3a');
      ctx.fillStyle = groundGrd;
      ctx.fillRect(0, 300, W, 100);

      // Ground line
      ctx.strokeStyle = '#3a3a5e';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 300);
      ctx.lineTo(W, 300);
      ctx.stroke();

      // Arena center line
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 8]);
      ctx.beginPath();
      ctx.moveTo(W / 2, 80);
      ctx.lineTo(W / 2, 300);
      ctx.stroke();
      ctx.setLineDash([]);

      // Arena circle
      ctx.beginPath();
      ctx.ellipse(W / 2, 300, 260, 12, 0, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Runes on ground
      var runeAlpha = 0.04 + 0.025 * Math.sin(roundTimer * 0.025);
      ctx.fillStyle = 'rgba(170, 68, 255, ' + runeAlpha + ')';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      var runes = ['\u2721', '\u2726', '\u2605', '\u2736', '\u2727'];
      for (var ri = 0; ri < 5; ri++) {
        ctx.fillText(runes[ri], 80 + ri * 110, 320 + (ri % 2) * 15);
      }

      // Ambient magic particles floating up from ground
      ctx.globalAlpha = 0.15;
      for (var ap = 0; ap < 8; ap++) {
        var apx = (ap * 83 + roundTimer * 0.3) % W;
        var apy = 300 - ((roundTimer * 0.5 + ap * 37) % 80);
        ctx.beginPath();
        ctx.arc(apx, apy, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = '#a4f';
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawProjectiles() {
      for (var pi = 0; pi < projectiles.length; pi++) {
        var p = projectiles[pi];

        // Trail
        for (var ti = 0; ti < p.trail.length; ti++) {
          var t = p.trail[ti];
          t.life--;
          var alpha = t.life / 15;
          if (alpha <= 0) continue;
          ctx.beginPath();
          ctx.arc(t.x, t.y, p.size * 0.6 * alpha, 0, Math.PI * 2);
          ctx.fillStyle = p.spell.trail;
          ctx.globalAlpha = alpha * 0.4;
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        p.trail = p.trail.filter(function(t) { return t.life > 0; });

        // Outer glow
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = p.spell.color;
        ctx.globalAlpha = 0.15;
        ctx.fill();
        ctx.globalAlpha = 1;

        // Main body
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.spell.color;
        ctx.shadowColor = p.spell.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;

        // Core
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.8;
        ctx.fill();
        ctx.globalAlpha = 1;

        // Lightning zigzag
        if (p.spell.name === 'Lightning' || p.spell.name === 'Explosion') {
          ctx.strokeStyle = p.spell.color;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          for (var j = 0; j < 5; j++) {
            ctx.lineTo(
              p.x - p.vx * (j + 1) * 2.5 + (Math.random() - 0.5) * 14,
              p.y + (Math.random() - 0.5) * 14
            );
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // Ice crystals
        if (p.spell.name === 'Ice' || p.spell.name === 'Steam') {
          ctx.strokeStyle = p.spell.color;
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.4;
          for (var ic = 0; ic < 3; ic++) {
            var ia = roundTimer * 0.1 + ic * 2;
            var irx = Math.cos(ia) * (p.size + 3);
            var iry = Math.sin(ia) * (p.size + 3);
            ctx.beginPath();
            ctx.moveTo(p.x + irx, p.y + iry);
            ctx.lineTo(p.x + irx * 0.5, p.y + iry * 0.5);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }
      }
    }

    function drawParticles() {
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var alpha = p.life / (p.maxLife || 40);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawFloatingTexts() {
      for (var i = 0; i < floatingTexts.length; i++) {
        var ft = floatingTexts[i];
        var alpha = ft.life / 60;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = ft.color;
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = ft.color;
        ctx.shadowBlur = 6;
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      // Round win indicators
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#48f';
      ctx.fillText('Wins:', 12, 18);
      for (var i = 0; i < 2; i++) {
        ctx.beginPath();
        ctx.arc(62 + i * 18, 15, 6, 0, Math.PI * 2);
        ctx.fillStyle = i < player.roundWins ? '#48f' : '#222';
        ctx.fill();
        ctx.strokeStyle = '#48f';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      ctx.textAlign = 'right';
      ctx.fillStyle = '#f44';
      ctx.fillText('Wins:', W - 50, 18);
      for (var i = 0; i < 2; i++) {
        ctx.beginPath();
        ctx.arc(W - 35 + i * 18, 15, 6, 0, Math.PI * 2);
        ctx.fillStyle = i < ai.roundWins ? '#f44' : '#222';
        ctx.fill();
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Spell bar at bottom
      var spellY = H - 28;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      var spellList = ['fire', 'ice', 'lightning', 'heal'];
      var spellKeys = ['1', '2', '3', '4'];

      // Spell bar background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillRect(30, spellY - 14, 440, 30);
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.2)';
      ctx.lineWidth = 1;
      ctx.strokeRect(30, spellY - 14, 440, 30);

      for (var si = 0; si < 4; si++) {
        var sp = SPELLS[spellList[si]];
        var sx = 80 + si * 100;
        var canCast = player.mana >= sp.mana && !player.shieldUp;
        ctx.fillStyle = canCast ? sp.color : '#444';
        ctx.globalAlpha = canCast ? 1 : 0.4;
        ctx.fillText('[' + spellKeys[si] + '] ' + sp.name, sx, spellY);
        ctx.fillStyle = canCast ? '#888' : '#333';
        ctx.fillText(sp.mana + 'mp', sx, spellY + 11);
        ctx.globalAlpha = 1;
      }

      // Shield indicator
      var canShield = player.shieldCooldown <= 0 && player.mana >= 5;
      ctx.fillStyle = canShield ? '#a4f' : '#444';
      ctx.globalAlpha = canShield ? 1 : 0.4;
      ctx.fillText('[S] Shield', 510, spellY);
      if (player.shieldCooldown > 0) {
        ctx.fillStyle = '#555';
        ctx.fillText((player.shieldCooldown / 60).toFixed(1) + 's', 510, spellY + 11);
      }
      ctx.globalAlpha = 1;

      // Meditation indicator
      if (player.meditating) {
        ctx.fillStyle = '#8cf';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        var medAlpha = 0.5 + 0.3 * Math.sin(roundTimer * 0.1);
        ctx.globalAlpha = medAlpha;
        ctx.fillText('\u2726 Meditating... \u2726', W / 2, 45);
        ctx.globalAlpha = 1;
      }

      // Combo hint
      if (player.comboTimer > 0 && player.lastSpell) {
        var hint = '';
        if (player.lastSpell === 'fire') hint = '\u26A1 Combo: +[2]Ice=Steam  +[3]Lightning=Explosion';
        else if (player.lastSpell === 'ice') hint = '\u26A1 Combo: +[1]Fire=Steam';
        else if (player.lastSpell === 'lightning') hint = '\u26A1 Combo: +[1]Fire=Explosion';
        if (hint) {
          ctx.fillStyle = '#a4f';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.globalAlpha = Math.min(1, player.comboTimer / 45);
          ctx.fillText(hint, W / 2, 60);
          ctx.globalAlpha = 1;
        }
      }
    }

    function draw() {
      drawBackground();
      drawProjectiles();
      drawParticles();
      if (player) drawWizard(player, 'YOU');
      if (ai) drawWizard(ai, 'AI');
      drawFloatingTexts();
      if (gameState === 'playing') drawHUD();
    }

    // ─── Main loop ───
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ─── Start ───
    initRound();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

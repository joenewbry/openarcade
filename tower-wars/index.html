<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower Wars</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #2d8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(34, 221, 136, 0.5); }
    h1 { color: #2d8; font-size: 1.6rem; text-shadow: 0 0 15px rgba(34, 221, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #2d8; }
    canvas {
      border: 2px solid #2d8;
      box-shadow: 0 0 20px rgba(34, 221, 136, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #2d8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(34,221,136,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; white-space: pre-line; }
    .controls {
      display: flex;
      gap: 6px;
      margin-top: 10px;
      width: 600px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .controls button {
      background: #1a1a2e;
      color: #2d8;
      border: 1px solid #2d8;
      padding: 4px 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
    }
    .controls button:hover { background: #2d8; color: #1a1a2e; }
    .controls button.active { background: #2d8; color: #1a1a2e; box-shadow: 0 0 10px rgba(34,221,136,0.4); }
    .controls button:disabled { opacity: 0.4; cursor: default; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TOWER WARS</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span> | Lives: <span id="pLives">20</span> | Gold: <span id="pGold">50</span></div>
    <div>Best: <span id="best">0</span></div>
    <div>AI: <span id="aiKills">0</span> | Lives: <span id="aLives">20</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">TOWER WARS</h2>
      <p id="overlayText">Build towers. Send creeps. Destroy your opponent.
Click to Start</p>
    </div>
  </div>
  <div class="controls" id="controls">
    <button id="btnArrow" onclick="selectTower(0)">Arrow [10g]</button>
    <button id="btnCannon" onclick="selectTower(1)">Cannon [20g]</button>
    <button id="btnIce" onclick="selectTower(2)">Ice [15g]</button>
    <button id="btnLightning" onclick="selectTower(3)">Zap [25g]</button>
    <button id="btnSell" onclick="selectTower(-1)">Sell</button>
    <span style="color:#444;margin:0 4px;">|</span>
    <button id="btnCreep1" onclick="sendCreep(0)">Scout [8g]</button>
    <button id="btnCreep2" onclick="sendCreep(1)">Soldier [14g]</button>
    <button id="btnCreep3" onclick="sendCreep(2)">Tank [22g]</button>
    <button id="btnCreep4" onclick="sendCreep(3)">Speed [18g]</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const pLivesEl = document.getElementById('pLives');
    const aLivesEl = document.getElementById('aLives');
    const pGoldEl = document.getElementById('pGold');
    const aiKillsEl = document.getElementById('aiKills');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('towerWarsBest')) || 0;
    bestEl.textContent = bestScore;

    // Grid constants
    const COLS = 13, ROWS = 16;
    const CELL = 20;
    const GRID_W = COLS * CELL; // 260
    const GRID_H = ROWS * CELL; // 320
    const PAD_TOP = 40;
    const P_OX = 10, P_OY = PAD_TOP;
    const A_OX = W - GRID_W - 10, A_OY = PAD_TOP;
    const MID_X = W / 2;

    // Entry/exit positions (grid coords)
    const ENTRY_COL = 0, ENTRY_ROW = 1;
    const EXIT_COL = COLS - 1, EXIT_ROW = ROWS - 2;

    // Tower definitions
    const TOWER_DEFS = [
      { name: 'Arrow', cost: 10, range: 3, damage: 8, rate: 500, color: '#4f4', splash: 0, slow: 0, chain: 0, sell: 5 },
      { name: 'Cannon', cost: 20, range: 2.5, damage: 25, rate: 1200, color: '#f84', splash: 1.2, slow: 0, chain: 0, sell: 10 },
      { name: 'Ice', cost: 15, range: 2.8, damage: 4, rate: 600, color: '#8ef', splash: 0, slow: 0.5, chain: 0, sell: 7 },
      { name: 'Zap', cost: 25, range: 3.5, damage: 12, rate: 800, color: '#ff0', splash: 0, slow: 0, chain: 3, sell: 12 }
    ];

    // Creep definitions
    const CREEP_DEFS = [
      { name: 'Scout', cost: 8, hp: 30, speed: 1.8, reward: 5, color: '#f66', size: 4 },
      { name: 'Soldier', cost: 14, hp: 80, speed: 1.0, reward: 8, color: '#fa0', size: 5 },
      { name: 'Tank', cost: 22, hp: 200, speed: 0.6, reward: 14, color: '#f0f', size: 7 },
      { name: 'Speed', cost: 18, hp: 50, speed: 2.5, reward: 10, color: '#0ff', size: 4 }
    ];

    let selectedTower = 0;
    let playerGold = 50, aiGold = 50;
    let playerLives = 20, aiLives = 20;
    let playerKills = 0, aiKills = 0;
    let gameTime = 0;

    // Grid: 0 = empty, 1+ = tower index+1
    let playerGrid, aiGrid;
    let playerTowers, aiTowers;
    let playerCreeps, aiCreeps; // creeps on player's field (sent by AI), creeps on AI's field (sent by player)
    let projectiles;
    let particles;
    let hoverCell = null;
    let aiTimer = 0;
    let aiActionTimer = 0;
    let goldTimer = 0;
    let waveTimer = 0;

    function initGame() {
      playerGrid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      aiGrid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      playerTowers = [];
      aiTowers = [];
      playerCreeps = []; // creeps walking on PLAYER's field (sent by AI, attacking player)
      aiCreeps = [];     // creeps walking on AI's field (sent by player, attacking AI)
      projectiles = [];
      particles = [];
      playerGold = 50; aiGold = 50;
      playerLives = 20; aiLives = 20;
      playerKills = 0; aiKills = 0;
      gameTime = 0;
      aiTimer = 0;
      aiActionTimer = 0;
      goldTimer = 0;
      waveTimer = 0;
      score = 0;
      selectedTower = 0;
      updateUI();
    }

    function updateUI() {
      scoreEl.textContent = score;
      pLivesEl.textContent = playerLives;
      aLivesEl.textContent = aiLives;
      pGoldEl.textContent = playerGold;
      aiKillsEl.textContent = aiKills;
    }

    // Pathfinding (BFS)
    function findPath(grid) {
      const start = { r: ENTRY_ROW, c: ENTRY_COL };
      const end = { r: EXIT_ROW, c: EXIT_COL };
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const parent = Array.from({length: ROWS}, () => Array(COLS).fill(null));
      const queue = [start];
      visited[start.r][start.c] = true;
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      while (queue.length > 0) {
        const cur = queue.shift();
        if (cur.r === end.r && cur.c === end.c) {
          // reconstruct
          const path = [];
          let n = cur;
          while (n) {
            path.unshift({ r: n.r, c: n.c });
            n = parent[n.r][n.c];
          }
          return path;
        }
        for (const [dr, dc] of dirs) {
          const nr = cur.r + dr, nc = cur.c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc] && grid[nr][nc] === 0) {
            visited[nr][nc] = true;
            parent[nr][nc] = cur;
            queue.push({ r: nr, c: nc });
          }
        }
      }
      return null; // no path
    }

    function gridToWorld(ox, oy, r, c) {
      return { x: ox + c * CELL + CELL / 2, y: oy + r * CELL + CELL / 2 };
    }

    function placeTower(grid, towers, r, c, type, isAI) {
      const def = TOWER_DEFS[type];
      grid[r][c] = type + 1;
      const ox = isAI ? A_OX : P_OX;
      const oy = isAI ? A_OY : P_OY;
      const pos = gridToWorld(ox, oy, r, c);
      towers.push({
        r, c, type, x: pos.x, y: pos.y,
        lastFire: 0, ...def
      });
    }

    function removeTower(grid, towers, r, c) {
      grid[r][c] = 0;
      const idx = towers.findIndex(t => t.r === r && t.c === c);
      if (idx >= 0) {
        const t = towers[idx];
        towers.splice(idx, 1);
        return t.sell;
      }
      return 0;
    }

    function selectTower(type) {
      selectedTower = type;
      document.querySelectorAll('.controls button').forEach((b, i) => {
        if (i < 5) b.classList.toggle('active', i === type || (type === -1 && i === 4));
      });
    }
    selectTower(0);

    function sendCreep(type) {
      if (gameState !== 'playing') return;
      const def = CREEP_DEFS[type];
      if (playerGold < def.cost) return;
      playerGold -= def.cost;
      spawnCreep(aiGrid, aiCreeps, type, true);
      updateUI();
    }

    function spawnCreep(grid, creeps, type, isOnAIField) {
      const path = findPath(grid);
      if (!path) return;
      const def = CREEP_DEFS[type];
      const ox = isOnAIField ? A_OX : P_OX;
      const oy = isOnAIField ? A_OY : P_OY;
      const startPos = gridToWorld(ox, oy, path[0].r, path[0].c);
      creeps.push({
        type,
        x: startPos.x, y: startPos.y,
        hp: def.hp, maxHp: def.hp,
        speed: def.speed,
        color: def.color,
        size: def.size,
        reward: def.reward,
        path: path,
        pathIdx: 0,
        slowTimer: 0,
        slowFactor: 1,
        ox, oy
      });
    }

    // Canvas click handler
    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        return;
      }
      if (gameState === 'over') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      // Check if click is on player's grid
      const gc = Math.floor((mx - P_OX) / CELL);
      const gr = Math.floor((my - P_OY) / CELL);
      if (gc >= 0 && gc < COLS && gr >= 0 && gr < ROWS) {
        if (selectedTower === -1) {
          // Sell
          if (playerGrid[gr][gc] > 0) {
            const gold = removeTower(playerGrid, playerTowers, gr, gc);
            playerGold += gold;
            updateUI();
          }
        } else if (selectedTower >= 0 && selectedTower < TOWER_DEFS.length) {
          const def = TOWER_DEFS[selectedTower];
          if (playerGold < def.cost) return;
          if (playerGrid[gr][gc] !== 0) return;
          // Don't allow blocking entry/exit
          if (gr === ENTRY_ROW && gc === ENTRY_COL) return;
          if (gr === EXIT_ROW && gc === EXIT_COL) return;
          // Test if path still exists
          playerGrid[gr][gc] = selectedTower + 1;
          const testPath = findPath(playerGrid);
          if (!testPath) {
            playerGrid[gr][gc] = 0;
            return; // would block path
          }
          playerGrid[gr][gc] = 0;
          playerGold -= def.cost;
          placeTower(playerGrid, playerTowers, gr, gc, selectedTower, false);
          // Update paths for existing creeps on player field
          updateCreepPaths(playerGrid, playerCreeps, false);
          updateUI();
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);
      const gc = Math.floor((mx - P_OX) / CELL);
      const gr = Math.floor((my - P_OY) / CELL);
      if (gc >= 0 && gc < COLS && gr >= 0 && gr < ROWS) {
        hoverCell = { r: gr, c: gc };
      } else {
        hoverCell = null;
      }
    });

    function updateCreepPaths(grid, creeps, isOnAIField) {
      const path = findPath(grid);
      if (!path) return;
      const ox = isOnAIField ? A_OX : P_OX;
      const oy = isOnAIField ? A_OY : P_OY;
      for (const creep of creeps) {
        // Find closest path node to current position
        let bestIdx = 0, bestDist = Infinity;
        for (let i = 0; i < path.length; i++) {
          const wp = gridToWorld(ox, oy, path[i].r, path[i].c);
          const d = Math.hypot(creep.x - wp.x, creep.y - wp.y);
          if (d < bestDist) { bestDist = d; bestIdx = i; }
        }
        creep.path = path;
        creep.pathIdx = bestIdx;
      }
    }

    // AI Logic
    function aiUpdate(dt) {
      aiTimer += dt;
      aiActionTimer += dt;

      // AI passive gold same as player
      // AI builds towers periodically
      if (aiActionTimer > 2000) {
        aiActionTimer = 0;
        aiDecide();
      }
    }

    function aiDecide() {
      // Strategy: alternate between building towers and sending creeps
      const rand = Math.random();

      if (rand < 0.55 && aiGold >= 10) {
        // Build a tower
        aiBuildTower();
      } else if (aiGold >= 8) {
        // Send creeps to player
        aiSendCreep();
      }
    }

    function aiBuildTower() {
      // Find good positions near the path
      const path = findPath(aiGrid);
      if (!path) return;
      const pathSet = new Set(path.map(p => p.r + ',' + p.c));

      // Collect candidate cells adjacent to path
      const candidates = [];
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      for (const p of path) {
        for (const [dr, dc] of dirs) {
          const nr = p.r + dr, nc = p.c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && aiGrid[nr][nc] === 0 &&
              !pathSet.has(nr + ',' + nc) &&
              !(nr === ENTRY_ROW && nc === ENTRY_COL) &&
              !(nr === EXIT_ROW && nc === EXIT_COL)) {
            candidates.push({ r: nr, c: nc });
          }
        }
      }
      if (candidates.length === 0) return;

      // Pick affordable tower type
      const affordable = TOWER_DEFS.map((d, i) => ({ ...d, idx: i })).filter(d => d.cost <= aiGold);
      if (affordable.length === 0) return;
      const towerType = affordable[Math.floor(Math.random() * affordable.length)].idx;
      const def = TOWER_DEFS[towerType];

      // Try random candidate
      for (let attempts = 0; attempts < 10; attempts++) {
        const cand = candidates[Math.floor(Math.random() * candidates.length)];
        aiGrid[cand.r][cand.c] = towerType + 1;
        const testPath = findPath(aiGrid);
        if (testPath) {
          aiGrid[cand.r][cand.c] = 0;
          aiGold -= def.cost;
          placeTower(aiGrid, aiTowers, cand.r, cand.c, towerType, true);
          updateCreepPaths(aiGrid, aiCreeps, true);
          return;
        }
        aiGrid[cand.r][cand.c] = 0;
      }
    }

    function aiSendCreep() {
      const affordable = CREEP_DEFS.map((d, i) => ({ ...d, idx: i })).filter(d => d.cost <= aiGold);
      if (affordable.length === 0) return;
      // Prefer variety
      const pick = affordable[Math.floor(Math.random() * affordable.length)];
      aiGold -= pick.cost;
      spawnCreep(playerGrid, playerCreeps, pick.idx, false);
    }

    // Game update
    function update(dt) {
      if (gameState !== 'playing') return;
      gameTime += dt;

      // Passive gold income
      goldTimer += dt;
      if (goldTimer >= 2000) {
        goldTimer -= 2000;
        playerGold += 3;
        aiGold += 3;
      }

      // Auto wave timer - send a free scout periodically for both sides
      waveTimer += dt;
      if (waveTimer >= 8000) {
        waveTimer -= 8000;
        // Both sides get a free scout wave
        spawnCreep(aiGrid, aiCreeps, 0, true);
        spawnCreep(playerGrid, playerCreeps, 0, false);
      }

      aiUpdate(dt);

      // Update creeps on player's field
      updateCreeps(playerCreeps, playerTowers, false, dt);
      // Update creeps on AI's field  
      updateCreeps(aiCreeps, aiTowers, true, dt);

      // Update projectiles
      updateProjectiles(dt);

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt / 16;
        p.y += p.vy * dt / 16;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      updateUI();

      // Check win/lose
      if (playerLives <= 0) {
        endGame(false);
      } else if (aiLives <= 0) {
        endGame(true);
      }
    }

    function updateCreeps(creeps, towers, isOnAIField, dt) {
      const ox = isOnAIField ? A_OX : P_OX;
      const oy = isOnAIField ? A_OY : P_OY;

      for (let i = creeps.length - 1; i >= 0; i--) {
        const c = creeps[i];

        // Slow effect
        if (c.slowTimer > 0) {
          c.slowTimer -= dt;
          if (c.slowTimer <= 0) c.slowFactor = 1;
        }

        // Move along path
        if (c.pathIdx < c.path.length - 1) {
          const target = gridToWorld(ox, oy, c.path[c.pathIdx + 1].r, c.path[c.pathIdx + 1].c);
          const dx = target.x - c.x;
          const dy = target.y - c.y;
          const dist = Math.hypot(dx, dy);
          const speed = c.speed * c.slowFactor * CELL * dt / 500;
          if (dist <= speed) {
            c.x = target.x;
            c.y = target.y;
            c.pathIdx++;
          } else {
            c.x += (dx / dist) * speed;
            c.y += (dy / dist) * speed;
          }
        }

        // Reached exit
        if (c.pathIdx >= c.path.length - 1) {
          creeps.splice(i, 1);
          if (isOnAIField) {
            aiLives--;
            score += 5;
          } else {
            playerLives--;
            aiKills++;
          }
          continue;
        }

        // Dead
        if (c.hp <= 0) {
          // Reward gold
          if (isOnAIField) {
            // Player's creeps dying on AI field - AI gets gold
            aiGold += c.reward;
          } else {
            // AI's creeps dying on player field - player gets gold and score
            playerGold += c.reward;
            playerKills++;
            score += 2;
          }
          // Death particles
          for (let j = 0; j < 6; j++) {
            particles.push({
              x: c.x, y: c.y,
              vx: (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 3,
              color: c.color, life: 400, size: 2
            });
          }
          creeps.splice(i, 1);
        }
      }

      // Tower firing
      const now = gameTime;
      for (const t of towers) {
        if (now - t.lastFire < t.rate) continue;
        const rangePx = t.range * CELL;
        let target = null;
        let bestProgress = -1;
        for (const c of creeps) {
          const d = Math.hypot(c.x - t.x, c.y - t.y);
          if (d <= rangePx && c.pathIdx > bestProgress) {
            bestProgress = c.pathIdx;
            target = c;
          }
        }
        if (target) {
          t.lastFire = now;
          fireProjectile(t, target, creeps);
        }
      }
    }

    function fireProjectile(tower, target, creeps) {
      projectiles.push({
        x: tower.x, y: tower.y,
        tx: target.x, ty: target.y,
        target,
        tower,
        creeps,
        speed: 5,
        color: tower.color
      });
    }

    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        const dx = p.target.x - p.x;
        const dy = p.target.y - p.y;
        const dist = Math.hypot(dx, dy);
        const speed = p.speed * dt / 2;
        if (dist <= speed || p.target.hp <= 0) {
          // Hit
          if (p.target.hp > 0) {
            applyDamage(p.tower, p.target, p.creeps);
          }
          projectiles.splice(i, 1);
        } else {
          p.x += (dx / dist) * speed;
          p.y += (dy / dist) * speed;
        }
      }
    }

    function applyDamage(tower, target, creeps) {
      target.hp -= tower.damage;

      // Splash damage
      if (tower.splash > 0) {
        const splashPx = tower.splash * CELL;
        for (const c of creeps) {
          if (c !== target) {
            const d = Math.hypot(c.x - target.x, c.y - target.y);
            if (d <= splashPx) {
              c.hp -= tower.damage * 0.5;
              // splash particle
              particles.push({ x: c.x, y: c.y, vx: 0, vy: -1, color: '#f84', life: 300, size: 3 });
            }
          }
        }
        // Explosion particle
        for (let i = 0; i < 8; i++) {
          const a = (i / 8) * Math.PI * 2;
          particles.push({
            x: target.x, y: target.y,
            vx: Math.cos(a) * 2, vy: Math.sin(a) * 2,
            color: '#f84', life: 300, size: 2
          });
        }
      }

      // Slow
      if (tower.slow > 0) {
        target.slowFactor = 1 - tower.slow;
        target.slowTimer = 1500;
        particles.push({ x: target.x, y: target.y, vx: 0, vy: -1, color: '#8ef', life: 400, size: 4 });
      }

      // Chain lightning
      if (tower.chain > 0) {
        let chainTarget = target;
        let chained = new Set([target]);
        for (let c = 0; c < tower.chain; c++) {
          let nearest = null, nearDist = CELL * 3;
          for (const cr of creeps) {
            if (chained.has(cr) || cr.hp <= 0) continue;
            const d = Math.hypot(cr.x - chainTarget.x, cr.y - chainTarget.y);
            if (d < nearDist) { nearDist = d; nearest = cr; }
          }
          if (nearest) {
            nearest.hp -= tower.damage * 0.6;
            chained.add(nearest);
            // Lightning arc particle
            particles.push({
              x: (chainTarget.x + nearest.x) / 2,
              y: (chainTarget.y + nearest.y) / 2,
              vx: 0, vy: 0, color: '#ff0', life: 200, size: 2
            });
            chainTarget = nearest;
          } else break;
        }
      }
    }

    function endGame(won) {
      gameState = 'over';
      score += Math.floor(gameTime / 1000);
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('towerWarsBest', bestScore);
        bestEl.textContent = bestScore;
      }
      scoreEl.textContent = score;
      overlayTitle.textContent = won ? 'VICTORY!' : 'DEFEATED';
      overlayText.textContent = `Score: ${score}\nKills: ${playerKills} | Survived: ${Math.floor(gameTime/1000)}s\nClick to play again`;
      overlay.style.display = 'flex';
    }

    // Drawing
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Title labels
      ctx.fillStyle = '#2d8';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('YOUR BASE', P_OX + GRID_W / 2, P_OY - 8);
      ctx.fillStyle = '#f66';
      ctx.fillText('AI BASE', A_OX + GRID_W / 2, A_OY - 8);

      // Middle info
      ctx.fillStyle = '#555';
      ctx.font = '10px Courier New';
      ctx.fillText('TOWER WARS', MID_X, PAD_TOP + 20);
      ctx.fillStyle = '#2d8';
      ctx.font = '11px Courier New';
      ctx.fillText(`${Math.floor(gameTime/1000)}s`, MID_X, PAD_TOP + 40);
      ctx.fillStyle = '#888';
      ctx.font = '9px Courier New';
      ctx.fillText(`AI Gold: ${aiGold}`, MID_X, PAD_TOP + 58);

      drawGrid(P_OX, P_OY, playerGrid, playerTowers, playerCreeps, false);
      drawGrid(A_OX, A_OY, aiGrid, aiTowers, aiCreeps, true);

      // Draw projectiles
      for (const p of projectiles) {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Draw particles
      for (const p of particles) {
        const alpha = Math.max(0, p.life / 400);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;

      // Draw hover preview on player grid
      if (hoverCell && gameState === 'playing' && selectedTower >= 0 && selectedTower < TOWER_DEFS.length) {
        const { r, c } = hoverCell;
        if (playerGrid[r][c] === 0 && !(r === ENTRY_ROW && c === ENTRY_COL) && !(r === EXIT_ROW && c === EXIT_COL)) {
          const px = P_OX + c * CELL;
          const py = P_OY + r * CELL;
          ctx.fillStyle = 'rgba(34, 221, 136, 0.2)';
          ctx.fillRect(px, py, CELL, CELL);
          ctx.strokeStyle = '#2d8';
          ctx.lineWidth = 1;
          ctx.strokeRect(px + 0.5, py + 0.5, CELL - 1, CELL - 1);
          // Range circle
          const def = TOWER_DEFS[selectedTower];
          ctx.strokeStyle = 'rgba(34, 221, 136, 0.2)';
          ctx.beginPath();
          ctx.arc(px + CELL / 2, py + CELL / 2, def.range * CELL, 0, Math.PI * 2);
          ctx.stroke();
        }
      } else if (hoverCell && gameState === 'playing' && selectedTower === -1) {
        const { r, c } = hoverCell;
        if (playerGrid[r][c] > 0) {
          const px = P_OX + c * CELL;
          const py = P_OY + r * CELL;
          ctx.fillStyle = 'rgba(255, 80, 80, 0.2)';
          ctx.fillRect(px, py, CELL, CELL);
          ctx.strokeStyle = '#f55';
          ctx.lineWidth = 1;
          ctx.strokeRect(px + 0.5, py + 0.5, CELL - 1, CELL - 1);
        }
      }
    }

    function drawGrid(ox, oy, grid, towers, creeps, isAI) {
      // Grid background
      ctx.fillStyle = '#12122a';
      ctx.fillRect(ox, oy, GRID_W, GRID_H);

      // Grid lines
      ctx.strokeStyle = '#222244';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(ox, oy + r * CELL);
        ctx.lineTo(ox + GRID_W, oy + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(ox + c * CELL, oy);
        ctx.lineTo(ox + c * CELL, oy + GRID_H);
        ctx.stroke();
      }

      // Entry / Exit markers
      ctx.fillStyle = '#0a0';
      ctx.shadowColor = '#0f0';
      ctx.shadowBlur = 8;
      const entryX = ox + ENTRY_COL * CELL, entryY = oy + ENTRY_ROW * CELL;
      ctx.fillRect(entryX + 2, entryY + 2, CELL - 4, CELL - 4);
      ctx.fillStyle = '#a00';
      ctx.shadowColor = '#f00';
      const exitX = ox + EXIT_COL * CELL, exitY = oy + EXIT_ROW * CELL;
      ctx.fillRect(exitX + 2, exitY + 2, CELL - 4, CELL - 4);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('IN', entryX + CELL / 2, entryY + CELL / 2 + 3);
      ctx.fillText('OUT', exitX + CELL / 2, exitY + CELL / 2 + 3);

      // Draw path hint
      if (gameState === 'playing') {
        const path = findPath(grid);
        if (path && path.length > 1) {
          ctx.strokeStyle = 'rgba(34, 221, 136, 0.08)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          const s = gridToWorld(ox, oy, path[0].r, path[0].c);
          ctx.moveTo(s.x, s.y);
          for (let i = 1; i < path.length; i++) {
            const p = gridToWorld(ox, oy, path[i].r, path[i].c);
            ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        }
      }

      // Draw towers
      for (const t of towers) {
        const tx = ox + t.c * CELL;
        const ty = oy + t.r * CELL;
        ctx.fillStyle = t.color;
        ctx.shadowColor = t.color;
        ctx.shadowBlur = 4;
        // Tower body
        ctx.fillRect(tx + 3, ty + 3, CELL - 6, CELL - 6);
        ctx.shadowBlur = 0;
        // Tower type indicator
        ctx.fillStyle = '#000';
        ctx.font = 'bold 8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(t.name[0], tx + CELL / 2, ty + CELL / 2 + 3);
      }

      // Draw creeps
      for (const c of creeps) {
        // Health bar
        const barW = c.size * 2 + 4;
        const hpRatio = Math.max(0, c.hp / c.maxHp);
        ctx.fillStyle = '#300';
        ctx.fillRect(c.x - barW / 2, c.y - c.size - 5, barW, 3);
        ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : hpRatio > 0.25 ? '#ff0' : '#f00';
        ctx.fillRect(c.x - barW / 2, c.y - c.size - 5, barW * hpRatio, 3);

        // Body
        ctx.fillStyle = c.color;
        ctx.shadowColor = c.color;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Slow indicator
        if (c.slowTimer > 0) {
          ctx.strokeStyle = '#8ef';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.size + 2, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    // Game loop
    let lastTime = 0;
    function gameLoop(ts) {
      const dt = lastTime ? Math.min(ts - lastTime, 50) : 16;
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Defender</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 512px;
    }
    .back { color: #4f8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 255, 136, 0.5); }
    h1 { color: #4f8; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 255, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 512px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4f8; }
    canvas {
      border: 2px solid #4f8;
      box-shadow: 0 0 20px rgba(68, 255, 136, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4f8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DEFENDER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span> | Bombs: <span id="bombs">3</span> | Wave: <span id="wave">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="512" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:512px;height:400px;">
      <h2 id="overlayTitle">DEFENDER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const bombsEl = document.getElementById('bombs');
    const waveEl = document.getElementById('wave');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // World constants
    const WORLD_W = 4096;
    const GROUND_Y = H - 50; // ground level on screen
    const RADAR_H = 30;      // minimap height at top
    const RADAR_Y = 4;       // minimap y position
    const PLAY_TOP = RADAR_Y + RADAR_H + 4; // gameplay area starts below radar

    // Player constants
    const SHIP_W = 28;
    const SHIP_H = 12;
    const PLAYER_SPEED = 4;
    const PLAYER_MAX_SPEED = 6;
    const PLAYER_ACCEL = 0.3;
    const BULLET_SPEED = 10;
    const BULLET_LIFE = 40; // frames before bullet expires
    const FIRE_COOLDOWN = 6;
    const INVINCIBLE_TIME = 90; // frames of invincibility after respawn

    // Colors
    const THEME = '#4f8';
    const THEME_RGBA = 'rgba(68, 255, 136, ';

    let score, best = 0, gameState;
    let player, bullets, enemies, humans, particles, mines, stars;
    let cameraX, keys, wave, lives, smartBombs;
    let tick, fireCooldown, invincibleTimer;
    let animFrame;

    // Terrain (mountain peaks for the landscape)
    let terrain = [];

    function generateTerrain() {
      terrain = [];
      const segments = 128;
      const segW = WORLD_W / segments;
      for (let i = 0; i <= segments; i++) {
        const baseH = 20 + Math.sin(i * 0.15) * 12 + Math.sin(i * 0.07) * 8 + Math.sin(i * 0.31) * 6;
        terrain.push({ x: i * segW, h: baseH });
      }
    }

    function generateStars() {
      stars = [];
      for (let i = 0; i < 80; i++) {
        stars.push({
          x: Math.random() * WORLD_W,
          y: PLAY_TOP + Math.random() * (GROUND_Y - PLAY_TOP - 60),
          brightness: 0.3 + Math.random() * 0.7,
          size: Math.random() > 0.8 ? 2 : 1
        });
      }
    }

    function wrapX(x) {
      return ((x % WORLD_W) + WORLD_W) % WORLD_W;
    }

    function worldToScreen(wx) {
      let dx = wx - cameraX;
      // Handle wrapping: find shortest distance
      if (dx > WORLD_W / 2) dx -= WORLD_W;
      if (dx < -WORLD_W / 2) dx += WORLD_W;
      return dx + W / 2;
    }

    function isOnScreen(wx, margin) {
      const sx = worldToScreen(wx);
      return sx > -margin && sx < W + margin;
    }

    function worldDist(a, b) {
      let d = a - b;
      if (d > WORLD_W / 2) d -= WORLD_W;
      if (d < -WORLD_W / 2) d += WORLD_W;
      return d;
    }

    // Spawn humans on the ground
    function spawnHumans() {
      humans = [];
      const count = 8 + wave;
      for (let i = 0; i < count; i++) {
        humans.push({
          x: Math.random() * WORLD_W,
          y: GROUND_Y,
          alive: true,
          falling: false,
          carried: false,
          carriedBy: null,
          vy: 0,
          rescued: false
        });
      }
    }

    // Spawn enemies for the current wave
    function spawnEnemies() {
      enemies = [];
      const landerCount = 4 + wave * 2;
      const bomberCount = Math.max(0, Math.floor(wave * 1.2) - 1);
      const baiterCount = Math.max(0, wave - 3);

      for (let i = 0; i < landerCount; i++) {
        spawnLander();
      }
      for (let i = 0; i < bomberCount; i++) {
        spawnBomber();
      }
      for (let i = 0; i < baiterCount; i++) {
        spawnBaiter();
      }
    }

    function spawnLander() {
      const x = wrapX(cameraX + W / 2 + 200 + Math.random() * (WORLD_W - W - 400));
      enemies.push({
        type: 'lander',
        x: x,
        y: PLAY_TOP + 20 + Math.random() * 80,
        vx: (Math.random() - 0.5) * 1.5,
        vy: 0,
        alive: true,
        state: 'roaming', // roaming, descending, ascending, mutant
        target: null,
        hp: 1,
        color: '#f44',
        points: 150,
        shootTimer: 60 + Math.floor(Math.random() * 120),
        phaseOffset: Math.random() * Math.PI * 2
      });
    }

    function spawnBomber() {
      const x = wrapX(cameraX + W / 2 + 200 + Math.random() * (WORLD_W - W - 400));
      enemies.push({
        type: 'bomber',
        x: x,
        y: PLAY_TOP + 30 + Math.random() * 100,
        vx: (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random()),
        vy: Math.sin(Math.random() * Math.PI * 2) * 0.5,
        alive: true,
        state: 'moving',
        hp: 1,
        color: '#f80',
        points: 250,
        mineTimer: 80 + Math.floor(Math.random() * 100),
        phaseOffset: Math.random() * Math.PI * 2
      });
    }

    function spawnBaiter() {
      const x = wrapX(cameraX + W / 2 + 300 + Math.random() * (WORLD_W - W - 600));
      enemies.push({
        type: 'baiter',
        x: x,
        y: PLAY_TOP + 20 + Math.random() * 60,
        vx: 0,
        vy: 0,
        alive: true,
        state: 'chasing',
        hp: 2,
        color: '#ff0',
        points: 200,
        shootTimer: 40 + Math.floor(Math.random() * 60),
        phaseOffset: Math.random() * Math.PI * 2
      });
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      lives = 3;
      smartBombs = 3;
      wave = 1;
      livesEl.textContent = lives;
      bombsEl.textContent = smartBombs;
      waveEl.textContent = wave;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DEFENDER';
      overlayText.textContent = 'Arrows:Move  Space:Fire  Shift:Bomb  Z:Hyperspace';
      keys = {};
      tick = 0;
      fireCooldown = 0;
      invincibleTimer = 0;
      cameraX = 0;
      player = { x: WORLD_W / 2, y: H / 2, vx: 0, vy: 0, dir: 1 }; // dir: 1=right, -1=left
      bullets = [];
      enemies = [];
      humans = [];
      particles = [];
      mines = [];
      generateTerrain();
      generateStars();
      spawnHumans();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      invincibleTimer = INVINCIBLE_TIME;
      spawnEnemies();
      cancelAnimationFrame(animFrame);
      loop();
    }

    function loop() {
      if (gameState !== 'playing') return;
      tick++;
      update();
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function update() {
      // Decrease cooldowns
      if (fireCooldown > 0) fireCooldown--;
      if (invincibleTimer > 0) invincibleTimer--;

      // Player movement
      if (keys['ArrowLeft']) {
        player.dir = -1;
        player.vx -= PLAYER_ACCEL;
      }
      if (keys['ArrowRight']) {
        player.dir = 1;
        player.vx += PLAYER_ACCEL;
      }
      if (keys['ArrowUp']) {
        player.vy -= PLAYER_ACCEL;
      }
      if (keys['ArrowDown']) {
        player.vy += PLAYER_ACCEL;
      }

      // Friction
      if (!keys['ArrowLeft'] && !keys['ArrowRight']) player.vx *= 0.92;
      if (!keys['ArrowUp'] && !keys['ArrowDown']) player.vy *= 0.92;

      // Speed limits
      player.vx = Math.max(-PLAYER_MAX_SPEED, Math.min(PLAYER_MAX_SPEED, player.vx));
      player.vy = Math.max(-PLAYER_SPEED, Math.min(PLAYER_SPEED, player.vy));

      player.x = wrapX(player.x + player.vx);
      player.y += player.vy;

      // Clamp player Y to playable area
      player.y = Math.max(PLAY_TOP + 10, Math.min(GROUND_Y - SHIP_H, player.y));

      // Camera follows player with offset based on direction
      const targetCamX = wrapX(player.x + player.dir * 80);
      let camDiff = worldDist(targetCamX, cameraX);
      cameraX = wrapX(cameraX + camDiff * 0.08);

      // Continuous fire if space held
      if (keys[' '] && fireCooldown <= 0) {
        fireBullet();
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x = wrapX(b.x + b.vx);
        b.y += b.vy;
        b.life--;
        if (b.life <= 0 || b.y < PLAY_TOP || b.y > GROUND_Y + 10) {
          bullets.splice(i, 1);
        }
      }

      // Update enemies
      updateEnemies();

      // Update mines
      for (let i = mines.length - 1; i >= 0; i--) {
        const m = mines[i];
        m.life--;
        if (m.life <= 0) {
          mines.splice(i, 1);
          continue;
        }
        // Check collision with player
        if (invincibleTimer <= 0) {
          const dx = Math.abs(worldDist(m.x, player.x));
          const dy = Math.abs(m.y - player.y);
          if (dx < 10 && dy < 10) {
            mines.splice(i, 1);
            playerHit();
            return;
          }
        }
      }

      // Update humans
      updateHumans();

      // Bullet vs enemy collisions
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (!e.alive) continue;
          const dx = Math.abs(worldDist(b.x, e.x));
          const dy = Math.abs(b.y - e.y);
          const hitW = e.type === 'baiter' ? 14 : 12;
          const hitH = e.type === 'baiter' ? 8 : 10;
          if (dx < hitW && dy < hitH) {
            e.hp--;
            bullets.splice(i, 1);
            if (e.hp <= 0) {
              killEnemy(e);
            } else {
              spawnParticles(e.x, e.y, '#fff', 3);
            }
            break;
          }
        }
      }

      // Bullet vs mine collisions
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        for (let j = mines.length - 1; j >= 0; j--) {
          const m = mines[j];
          const dx = Math.abs(worldDist(b.x, m.x));
          const dy = Math.abs(b.y - m.y);
          if (dx < 8 && dy < 8) {
            mines.splice(j, 1);
            bullets.splice(i, 1);
            spawnParticles(m.x, m.y, '#f80', 5);
            score += 25;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            break;
          }
        }
      }

      // Enemy vs player collisions
      if (invincibleTimer <= 0) {
        for (const e of enemies) {
          if (!e.alive) continue;
          const dx = Math.abs(worldDist(e.x, player.x));
          const dy = Math.abs(e.y - player.y);
          if (dx < 18 && dy < 12) {
            killEnemy(e);
            playerHit();
            return;
          }
        }
      }

      // Enemy projectile vs player (lander/baiter shots)
      // (Enemy bullets stored as enemies of type 'shot')
      // Handled in the enemy loop

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vy += 0.02; // slight gravity on particles
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Check wave complete
      const liveEnemies = enemies.filter(e => e.alive && e.type !== 'shot');
      if (liveEnemies.length === 0) {
        nextWave();
      }

      // Baiter spawn timer: if wave is taking too long, add baiters
      if (tick % 600 === 0 && tick > 300) {
        spawnBaiter();
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerDir: player.dir,
        cameraX: cameraX,
        enemyCount: enemies.filter(e => e.alive).length,
        humanCount: humans.filter(h => h.alive).length,
        wave: wave,
        lives: lives,
        smartBombs: smartBombs
      };
    }

    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.alive) { enemies.splice(i, 1); continue; }

        if (e.type === 'shot') {
          e.x = wrapX(e.x + e.vx);
          e.y += e.vy;
          e.life--;
          if (e.life <= 0 || e.y < PLAY_TOP || e.y > GROUND_Y + 20) {
            enemies.splice(i, 1);
            continue;
          }
          // Hit player
          if (invincibleTimer <= 0) {
            const dx = Math.abs(worldDist(e.x, player.x));
            const dy = Math.abs(e.y - player.y);
            if (dx < 12 && dy < 8) {
              enemies.splice(i, 1);
              playerHit();
              return;
            }
          }
          continue;
        }

        if (e.type === 'lander') {
          updateLander(e);
        } else if (e.type === 'bomber') {
          updateBomber(e);
        } else if (e.type === 'baiter') {
          updateBaiter(e);
        } else if (e.type === 'mutant') {
          updateMutant(e);
        }

        // Shooting
        if (e.shootTimer !== undefined) {
          e.shootTimer--;
          if (e.shootTimer <= 0 && e.type !== 'bomber') {
            enemyShoot(e);
            e.shootTimer = 40 + Math.floor(Math.random() * 80);
          }
        }
      }
    }

    function updateLander(e) {
      if (e.state === 'roaming') {
        // Float around, looking for humans
        e.x = wrapX(e.x + e.vx);
        e.y += Math.sin(tick * 0.03 + e.phaseOffset) * 0.5;
        e.y = Math.max(PLAY_TOP + 10, Math.min(GROUND_Y - 40, e.y));

        // Occasionally change direction
        if (Math.random() < 0.005) e.vx = (Math.random() - 0.5) * 2;

        // Look for a human to abduct
        if (Math.random() < 0.008) {
          const aliveHumans = humans.filter(h => h.alive && !h.carried);
          if (aliveHumans.length > 0) {
            e.target = aliveHumans[Math.floor(Math.random() * aliveHumans.length)];
            e.state = 'descending';
          }
        }
      } else if (e.state === 'descending') {
        // Move toward target human
        if (!e.target || !e.target.alive || e.target.carried) {
          e.state = 'roaming';
          e.target = null;
          return;
        }
        const dx = worldDist(e.target.x, e.x);
        e.x = wrapX(e.x + Math.sign(dx) * 1.5);
        e.y += 1; // descend

        // Close enough to grab?
        if (Math.abs(dx) < 10 && Math.abs(e.y - GROUND_Y) < 15) {
          e.target.carried = true;
          e.target.carriedBy = e;
          e.state = 'ascending';
        }

        // Don't go below ground
        if (e.y > GROUND_Y - 5) e.y = GROUND_Y - 5;
      } else if (e.state === 'ascending') {
        // Carry human upward
        e.x = wrapX(e.x + e.vx * 0.5);
        e.y -= 0.8;

        // Update carried human position
        if (e.target && e.target.alive) {
          e.target.x = e.x;
          e.target.y = e.y + 14;
        }

        // If reached top, human dies and lander becomes mutant
        if (e.y < PLAY_TOP + 5) {
          if (e.target && e.target.alive) {
            e.target.alive = false;
            spawnParticles(e.target.x, e.target.y, '#f4f', 8);
          }
          // Become mutant
          e.type = 'mutant';
          e.state = 'chasing';
          e.color = '#f4f';
          e.points = 150;
          e.hp = 1;
          e.vx = 0;
          e.vy = 0;
          e.target = null;
        }
      }
    }

    function updateMutant(e) {
      // Aggressively chase the player
      const dx = worldDist(player.x, e.x);
      const dy = player.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const speed = 2.5 + wave * 0.2;
      e.vx += (dx / dist) * 0.15;
      e.vy += (dy / dist) * 0.15;
      e.vx = Math.max(-speed, Math.min(speed, e.vx));
      e.vy = Math.max(-speed, Math.min(speed, e.vy));
      e.x = wrapX(e.x + e.vx);
      e.y += e.vy;
      e.y = Math.max(PLAY_TOP + 5, Math.min(GROUND_Y - 5, e.y));

      // Shoot frequently
      if (!e.shootTimer) e.shootTimer = 30;
    }

    function updateBomber(e) {
      // Move in a steady path, dropping mines
      e.x = wrapX(e.x + e.vx);
      e.y += Math.sin(tick * 0.02 + e.phaseOffset) * 0.3;
      e.y = Math.max(PLAY_TOP + 20, Math.min(GROUND_Y - 60, e.y));

      e.mineTimer--;
      if (e.mineTimer <= 0) {
        // Drop a mine
        mines.push({
          x: e.x,
          y: e.y + 8,
          life: 300 + Math.floor(Math.random() * 200)
        });
        e.mineTimer = 60 + Math.floor(Math.random() * 80);
      }
    }

    function updateBaiter(e) {
      // Fast aggressive chaser
      const dx = worldDist(player.x, e.x);
      const dy = player.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const speed = 3 + wave * 0.3;
      e.vx += (dx / dist) * 0.2;
      e.vy += (dy / dist) * 0.2;
      const mag = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
      if (mag > speed) {
        e.vx = (e.vx / mag) * speed;
        e.vy = (e.vy / mag) * speed;
      }
      e.x = wrapX(e.x + e.vx);
      e.y += e.vy;
      e.y = Math.max(PLAY_TOP + 5, Math.min(GROUND_Y - 5, e.y));
    }

    function enemyShoot(e) {
      const dx = worldDist(player.x, e.x);
      const dy = player.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const speed = 3;
      enemies.push({
        type: 'shot',
        x: e.x,
        y: e.y,
        vx: (dx / dist) * speed + (Math.random() - 0.5) * 0.5,
        vy: (dy / dist) * speed + (Math.random() - 0.5) * 0.5,
        alive: true,
        hp: 1,
        life: 80,
        color: '#f88'
      });
    }

    function updateHumans() {
      for (const h of humans) {
        if (!h.alive) continue;

        if (h.falling) {
          h.vy += 0.15; // gravity
          h.y += h.vy;

          // Check if player catches them
          const dx = Math.abs(worldDist(h.x, player.x));
          const dy = Math.abs(h.y - player.y);
          if (dx < 20 && dy < 16) {
            // Caught! carry them down
            h.falling = false;
            h.rescued = true;
            h.vy = 0;
            score += 500;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            spawnParticles(h.x, h.y, '#4f8', 8);
          }

          // Hit the ground
          if (h.y >= GROUND_Y) {
            h.y = GROUND_Y;
            h.falling = false;
            h.rescued = false;
            h.vy = 0;
          }

          // Fell off the top (shouldn't happen but safety)
          if (h.y < 0) {
            h.alive = false;
          }
        } else if (h.rescued) {
          // Being carried by player to ground
          h.x = player.x;
          h.y = player.y + 14;
          if (h.y >= GROUND_Y - 2) {
            h.y = GROUND_Y;
            h.rescued = false;
            score += 500;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            spawnParticles(h.x, h.y, '#4f8', 6);
          }
        } else if (h.carried) {
          // Position updated by the lander
        }
      }
    }

    function killEnemy(e) {
      e.alive = false;
      score += e.points;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
      spawnParticles(e.x, e.y, e.color, 10);

      // If carrying a human, release them
      if (e.target && e.target.alive && e.target.carried) {
        e.target.carried = false;
        e.target.carriedBy = null;
        e.target.falling = true;
        e.target.vy = 0;
      }
    }

    function fireBullet() {
      fireCooldown = FIRE_COOLDOWN;
      bullets.push({
        x: wrapX(player.x + player.dir * 18),
        y: player.y,
        vx: BULLET_SPEED * player.dir,
        vy: 0,
        life: BULLET_LIFE
      });
    }

    function smartBomb() {
      if (smartBombs <= 0) return;
      smartBombs--;
      bombsEl.textContent = smartBombs;

      // Destroy all enemies on screen
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.alive) continue;
        if (isOnScreen(e.x, 50)) {
          killEnemy(e);
        }
      }
      // Destroy all mines on screen
      for (let i = mines.length - 1; i >= 0; i--) {
        if (isOnScreen(mines[i].x, 50)) {
          spawnParticles(mines[i].x, mines[i].y, '#f80', 4);
          mines.splice(i, 1);
        }
      }
      // Flash effect
      particles.push({
        x: player.x, y: player.y,
        vx: 0, vy: 0,
        life: 15,
        color: '#fff',
        isFlash: true
      });
    }

    function hyperspace() {
      // Random teleport - risky!
      player.x = Math.random() * WORLD_W;
      player.y = PLAY_TOP + 30 + Math.random() * (GROUND_Y - PLAY_TOP - 80);
      player.vx = 0;
      player.vy = 0;
      invincibleTimer = 30;

      // 15% chance of death on hyperspace
      if (Math.random() < 0.15) {
        spawnParticles(player.x, player.y, THEME, 20);
        playerHit();
      }
    }

    function playerHit() {
      lives--;
      livesEl.textContent = lives;
      spawnParticles(player.x, player.y, THEME, 15);

      if (lives <= 0) {
        gameOver();
        return;
      }

      // Respawn
      invincibleTimer = INVINCIBLE_TIME;
      player.vx = 0;
      player.vy = 0;
      player.y = H / 2;
    }

    function nextWave() {
      wave++;
      waveEl.textContent = wave;
      smartBombs = Math.min(smartBombs + 1, 6);
      bombsEl.textContent = smartBombs;

      // Award bonus for surviving humans
      const aliveHumans = humans.filter(h => h.alive);
      score += aliveHumans.length * 100;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }

      spawnEnemies();

      // Add new humans if too few remain
      const neededHumans = 8 + wave;
      while (humans.filter(h => h.alive).length < Math.min(neededHumans, 15)) {
        humans.push({
          x: Math.random() * WORLD_W,
          y: GROUND_Y,
          alive: true,
          falling: false,
          carried: false,
          carriedBy: null,
          vy: 0,
          rescued: false
        });
      }
    }

    function gameOver() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Wave: ${wave} â€” Press any key to restart`;
    }

    function spawnParticles(wx, wy, color, count) {
      for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x: wx, y: wy,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.random() * 15,
          color: color
        });
      }
    }

    // Drawing
    function draw() {
      // Clear
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      // Draw stars
      drawStars();

      // Draw terrain/ground
      drawTerrain();

      // Draw humans
      drawHumans();

      // Draw mines
      drawMines();

      // Draw enemies
      drawEnemies();

      // Draw bullets
      drawBullets();

      // Draw player
      drawPlayer();

      // Draw particles
      drawParticles();

      // Draw smart bomb flash
      const flash = particles.find(p => p.isFlash);
      if (flash) {
        const alpha = flash.life / 15;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
        ctx.fillRect(0, 0, W, H);
      }

      // Draw radar/minimap
      drawRadar();

      // Draw HUD info on canvas
      drawHUD();
    }

    function drawStars() {
      for (const s of stars) {
        const sx = worldToScreen(s.x);
        // Parallax: stars move at half speed
        const psx = ((sx - W/2) * 0.5) + W/2;
        if (psx > -2 && psx < W + 2) {
          const twinkle = (Math.sin(tick * 0.05 + s.x) + 1) * 0.5;
          const alpha = s.brightness * (0.5 + twinkle * 0.5);
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.fillRect(psx, s.y, s.size, s.size);
        }
      }
    }

    function drawTerrain() {
      ctx.fillStyle = '#0a2818';
      ctx.strokeStyle = '#1a5a30';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, H);

      for (let sx = -10; sx <= W + 10; sx += 4) {
        const wx = wrapX(cameraX - W/2 + sx);
        const segW = WORLD_W / (terrain.length - 1);
        const idx = wx / segW;
        const i0 = Math.floor(idx) % terrain.length;
        const i1 = (i0 + 1) % terrain.length;
        const t = idx - Math.floor(idx);
        const h = terrain[i0].h * (1 - t) + terrain[i1].h * t;
        ctx.lineTo(sx, H - h);
      }

      ctx.lineTo(W + 10, H);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Ground line glow
      ctx.strokeStyle = '#2a8a4a';
      ctx.shadowColor = '#4f8';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      for (let sx = -10; sx <= W + 10; sx += 4) {
        const wx = wrapX(cameraX - W/2 + sx);
        const segW = WORLD_W / (terrain.length - 1);
        const idx = wx / segW;
        const i0 = Math.floor(idx) % terrain.length;
        const i1 = (i0 + 1) % terrain.length;
        const t = idx - Math.floor(idx);
        const h = terrain[i0].h * (1 - t) + terrain[i1].h * t;
        if (sx === -10) ctx.moveTo(sx, H - h);
        else ctx.lineTo(sx, H - h);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawHumans() {
      for (const h of humans) {
        if (!h.alive) continue;
        const sx = worldToScreen(h.x);
        if (sx < -20 || sx > W + 20) continue;

        ctx.fillStyle = '#4af';
        ctx.shadowColor = '#4af';
        ctx.shadowBlur = 4;
        // Simple stick figure
        // Head
        ctx.beginPath();
        ctx.arc(sx, h.y - 10, 3, 0, Math.PI * 2);
        ctx.fill();
        // Body
        ctx.strokeStyle = '#4af';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sx, h.y - 7);
        ctx.lineTo(sx, h.y - 1);
        ctx.stroke();
        // Legs
        ctx.beginPath();
        ctx.moveTo(sx, h.y - 1);
        ctx.lineTo(sx - 3, h.y + 3);
        ctx.moveTo(sx, h.y - 1);
        ctx.lineTo(sx + 3, h.y + 3);
        ctx.stroke();
        // Arms
        ctx.beginPath();
        ctx.moveTo(sx - 4, h.y - 5);
        ctx.lineTo(sx + 4, h.y - 5);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    function drawMines() {
      for (const m of mines) {
        const sx = worldToScreen(m.x);
        if (sx < -10 || sx > W + 10) continue;
        const pulse = Math.sin(tick * 0.15) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(255, 136, 0, ${pulse})`;
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 6;
        // Small diamond shape
        ctx.beginPath();
        ctx.moveTo(sx, m.y - 5);
        ctx.lineTo(sx + 5, m.y);
        ctx.lineTo(sx, m.y + 5);
        ctx.lineTo(sx - 5, m.y);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawEnemies() {
      for (const e of enemies) {
        if (!e.alive) continue;
        const sx = worldToScreen(e.x);
        if (sx < -30 || sx > W + 30) continue;

        if (e.type === 'shot') {
          // Enemy bullet
          ctx.fillStyle = '#f88';
          ctx.shadowColor = '#f88';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(sx, e.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          continue;
        }

        ctx.shadowColor = e.color;
        ctx.shadowBlur = 8;

        if (e.type === 'lander') {
          drawLander(sx, e);
        } else if (e.type === 'bomber') {
          drawBomberShape(sx, e);
        } else if (e.type === 'baiter') {
          drawBaiterShape(sx, e);
        } else if (e.type === 'mutant') {
          drawMutantShape(sx, e);
        }
        ctx.shadowBlur = 0;
      }
    }

    function drawLander(sx, e) {
      ctx.fillStyle = e.color;
      // UFO shape
      ctx.beginPath();
      ctx.ellipse(sx, e.y, 12, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // Dome
      ctx.fillStyle = '#faa';
      ctx.beginPath();
      ctx.ellipse(sx, e.y - 4, 6, 5, 0, Math.PI, 0);
      ctx.fill();
      // Beam if descending
      if (e.state === 'descending' || e.state === 'ascending') {
        ctx.strokeStyle = `rgba(255, 68, 68, ${0.3 + Math.sin(tick * 0.1) * 0.2})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sx, e.y + 6);
        ctx.lineTo(sx, GROUND_Y);
        ctx.stroke();
      }
    }

    function drawBomberShape(sx, e) {
      ctx.fillStyle = e.color;
      // Angular ship shape
      ctx.beginPath();
      ctx.moveTo(sx - 10, e.y);
      ctx.lineTo(sx, e.y - 8);
      ctx.lineTo(sx + 10, e.y);
      ctx.lineTo(sx, e.y + 8);
      ctx.closePath();
      ctx.fill();
      // Center dot
      ctx.fillStyle = '#ff0';
      ctx.beginPath();
      ctx.arc(sx, e.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBaiterShape(sx, e) {
      ctx.fillStyle = e.color;
      // Sleek fast shape
      const wobble = Math.sin(tick * 0.2 + e.phaseOffset) * 2;
      ctx.beginPath();
      ctx.moveTo(sx - 14, e.y + wobble);
      ctx.lineTo(sx + 14, e.y - 2);
      ctx.lineTo(sx + 14, e.y + 2);
      ctx.lineTo(sx - 14, e.y + 4 + wobble);
      ctx.closePath();
      ctx.fill();
      // Glow trail
      ctx.strokeStyle = `rgba(255, 255, 0, 0.4)`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx - 14, e.y + 2 + wobble);
      ctx.lineTo(sx - 22, e.y + 2 + wobble);
      ctx.stroke();
    }

    function drawMutantShape(sx, e) {
      ctx.fillStyle = e.color;
      // Erratic mutant shape - rotates
      const rot = tick * 0.1;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI * 2 / 6) * i + rot;
        const r = 8 + Math.sin(ang * 3 + tick * 0.05) * 3;
        const px = sx + Math.cos(ang) * r;
        const py = e.y + Math.sin(ang) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      for (const b of bullets) {
        const sx = worldToScreen(b.x);
        if (sx < -5 || sx > W + 5) continue;
        ctx.fillRect(sx - 6, b.y - 1, 12, 2);
      }
      ctx.shadowBlur = 0;
    }

    function drawPlayer() {
      if (invincibleTimer > 0 && Math.floor(tick / 3) % 2 === 0) return; // blink

      const sx = worldToScreen(player.x);
      const dir = player.dir;

      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 12;

      // Ship body
      ctx.beginPath();
      ctx.moveTo(sx + dir * 16, player.y);           // nose
      ctx.lineTo(sx - dir * 12, player.y - 7);       // top tail
      ctx.lineTo(sx - dir * 8, player.y);             // tail notch
      ctx.lineTo(sx - dir * 12, player.y + 7);       // bottom tail
      ctx.closePath();
      ctx.fill();

      // Engine glow
      if (Math.abs(player.vx) > 1) {
        const glowAlpha = Math.min(1, Math.abs(player.vx) / PLAYER_MAX_SPEED);
        ctx.fillStyle = `rgba(68, 255, 136, ${glowAlpha * 0.6})`;
        ctx.beginPath();
        ctx.moveTo(sx - dir * 12, player.y - 4);
        ctx.lineTo(sx - dir * (16 + Math.random() * 6), player.y);
        ctx.lineTo(sx - dir * 12, player.y + 4);
        ctx.closePath();
        ctx.fill();
      }

      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      for (const p of particles) {
        if (p.isFlash) continue;
        const sx = worldToScreen(p.x);
        if (sx < -10 || sx > W + 10) continue;
        const alpha = Math.min(1, p.life / 15);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(sx - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;
    }

    function drawRadar() {
      // Background
      ctx.fillStyle = 'rgba(10, 10, 30, 0.9)';
      ctx.fillRect(0, RADAR_Y, W, RADAR_H);

      // Border
      ctx.strokeStyle = '#1a4a2a';
      ctx.lineWidth = 1;
      ctx.strokeRect(0, RADAR_Y, W, RADAR_H);

      const radarScale = W / WORLD_W;

      // Viewport indicator
      const viewLeft = (cameraX - W/2);
      const viewSx = wrapX(viewLeft) * radarScale;
      const viewW = W * radarScale;
      ctx.strokeStyle = `rgba(68, 255, 136, 0.3)`;
      ctx.lineWidth = 1;
      ctx.strokeRect(viewSx, RADAR_Y, viewW, RADAR_H);

      // Terrain on radar (simplified)
      ctx.fillStyle = '#1a3a22';
      ctx.beginPath();
      ctx.moveTo(0, RADAR_Y + RADAR_H);
      for (let i = 0; i < terrain.length; i++) {
        const rx = (terrain[i].x * radarScale);
        const rh = terrain[i].h * (RADAR_H / (H * 1.5));
        ctx.lineTo(rx, RADAR_Y + RADAR_H - rh);
      }
      ctx.lineTo(W, RADAR_Y + RADAR_H);
      ctx.closePath();
      ctx.fill();

      // Humans on radar
      for (const h of humans) {
        if (!h.alive) continue;
        const rx = wrapX(h.x) * radarScale;
        ctx.fillStyle = '#4af';
        ctx.fillRect(rx - 1, RADAR_Y + RADAR_H - 4, 2, 3);
      }

      // Enemies on radar
      for (const e of enemies) {
        if (!e.alive || e.type === 'shot') continue;
        const rx = wrapX(e.x) * radarScale;
        const ry = RADAR_Y + ((e.y - PLAY_TOP) / (GROUND_Y - PLAY_TOP)) * RADAR_H;
        ctx.fillStyle = e.color;
        ctx.fillRect(rx - 1, Math.max(RADAR_Y, ry) - 1, 2, 2);
      }

      // Mines on radar
      for (const m of mines) {
        const rx = wrapX(m.x) * radarScale;
        ctx.fillStyle = '#f80';
        ctx.fillRect(rx, RADAR_Y + RADAR_H - 8, 1, 1);
      }

      // Player on radar
      const prx = wrapX(player.x) * radarScale;
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      ctx.fillRect(prx - 2, RADAR_Y + ((player.y - PLAY_TOP) / (GROUND_Y - PLAY_TOP)) * RADAR_H - 1, 4, 2);
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Lives indicators (small ships)
      const hudY = PLAY_TOP + 4;
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      for (let i = 0; i < lives - 1; i++) {
        const lx = 10 + i * 20;
        ctx.beginPath();
        ctx.moveTo(lx + 10, hudY + 4);
        ctx.lineTo(lx, hudY);
        ctx.lineTo(lx + 3, hudY + 4);
        ctx.lineTo(lx, hudY + 8);
        ctx.closePath();
        ctx.fill();
      }

      // Smart bomb indicators
      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 4;
      for (let i = 0; i < smartBombs; i++) {
        const bx = W - 20 - i * 16;
        ctx.beginPath();
        ctx.arc(bx, hudY + 4, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Wave number
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`WAVE ${wave}`, W / 2, hudY + 8);
      ctx.textAlign = 'left';
    }

    // Input handlers
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'z', 'Z'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === 'Shift') {
          smartBomb();
        }
        if (e.key === 'z' || e.key === 'Z') {
          hyperspace();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

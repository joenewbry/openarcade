<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DX-Ball</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 540px;
    }
    .back { color: #fa6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 170, 102, 0.5); }
    h1 { color: #fa6; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 170, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 540px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fa6; }
    canvas {
      border: 2px solid #fa6;
      box-shadow: 0 0 20px rgba(255, 170, 102, 0.2);
      display: block;
      cursor: none;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fa6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .overlay .sub { font-size: 0.85rem; color: #666; margin-top: 6px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DX-BALL</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="540" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:540px;height:560px;">
      <h2 id="overlayTitle">DX-BALL</h2>
      <p id="overlayText">Press SPACE or click to start</p>
      <p class="sub">Mouse or Arrow Keys to move paddle</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ---------- CONSTANTS ----------
    const PADDLE_BASE_W = 80;
    const PADDLE_MIN_W = 40;
    const PADDLE_MAX_W = 160;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 36;
    const PADDLE_KEY_SPEED = 7;

    const BALL_R = 5;
    const BASE_BALL_SPEED = 4.0;
    const MAX_BALL_SPEED = 8.0;

    const BRICK_COLS = 12;
    const BRICK_W = (W - 20) / BRICK_COLS;
    const BRICK_H = 18;
    const BRICK_TOP = 50;
    const BRICK_PAD = 2;

    const POWERUP_W = 28;
    const POWERUP_H = 14;
    const POWERUP_SPEED = 2.5;
    const POWERUP_DROP_CHANCE = 0.22;

    // Brick types
    const BRICK_NORMAL = 1;
    const BRICK_DOUBLE = 2;
    const BRICK_TRIPLE = 3;
    const BRICK_EXPLOSIVE = 4;

    // Power-up types (positive = good, negative = bad)
    const PU_EXPAND = 'expand';
    const PU_SHRINK = 'shrink';
    const PU_MULTI = 'multi';
    const PU_FIREBALL = 'fireball';
    const PU_CATCH = 'catch';
    const PU_EXTRA_LIFE = 'life';
    const PU_SPEED_UP = 'speedup';

    const GOOD_POWERUPS = [PU_EXPAND, PU_MULTI, PU_FIREBALL, PU_CATCH, PU_EXTRA_LIFE];
    const BAD_POWERUPS = [PU_SHRINK, PU_SPEED_UP];

    const POWERUP_LABELS = {
      [PU_EXPAND]: 'WIDE',
      [PU_SHRINK]: 'THIN',
      [PU_MULTI]: 'x3',
      [PU_FIREBALL]: 'FIRE',
      [PU_CATCH]: 'GRAB',
      [PU_EXTRA_LIFE]: '+1',
      [PU_SPEED_UP]: 'FAST',
    };

    // Brick colors per hits remaining
    const BRICK_COLORS = {
      1: '#fa6',
      2: '#4cf',
      3: '#f4a',
      4: '#f44',
    };

    // Neon row palette for visual variety
    const ROW_HUES = ['#f44', '#fa6', '#ff4', '#4f4', '#4cf', '#48f', '#a4f', '#f4a', '#fa6', '#4f4'];

    // ---------- STATE ----------
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let lives, level;
    let paddleX, paddleW;
    let balls, bricks, powerups;
    let keys = {};
    let mouseX = W / 2;
    let useMouseControl = false;
    let fireball = false;
    let fireballTimer = 0;
    let catching = false;
    let catchTimer = 0;
    let caughtBall = null;
    let combo = 0;
    let comboMultiplier = 1;
    let particles = [];
    let shakeTimer = 0;
    let levelTransition = 0;
    let brickRows = 6;

    // ---------- LEVEL PATTERNS ----------
    function generateLevel(lvl) {
      bricks = [];
      const rows = Math.min(6 + Math.floor(lvl / 2), 10);
      brickRows = rows;
      const pattern = (lvl - 1) % 8;

      for (let r = 0; r < rows; r++) {
        bricks[r] = [];
        for (let c = 0; c < BRICK_COLS; c++) {
          let type = BRICK_NORMAL;
          let alive = true;

          switch (pattern) {
            case 0: // Full grid, some doubles
              type = (r + c) % 5 === 0 ? BRICK_DOUBLE : BRICK_NORMAL;
              break;
            case 1: // Checkerboard
              alive = (r + c) % 2 === 0;
              type = r < 2 ? BRICK_DOUBLE : BRICK_NORMAL;
              break;
            case 2: // Diamond
              {
                const centerC = BRICK_COLS / 2 - 0.5;
                const centerR = rows / 2 - 0.5;
                const dist = Math.abs(c - centerC) / (BRICK_COLS / 2) + Math.abs(r - centerR) / (rows / 2);
                alive = dist < 1.0;
                type = dist < 0.4 ? BRICK_TRIPLE : (dist < 0.7 ? BRICK_DOUBLE : BRICK_NORMAL);
              }
              break;
            case 3: // Stripes with explosives
              alive = c % 3 !== 2;
              type = r % 3 === 0 ? BRICK_EXPLOSIVE : (r % 3 === 1 ? BRICK_DOUBLE : BRICK_NORMAL);
              break;
            case 4: // Pyramid
              {
                const half = Math.floor(rows / 2);
                const rowWidth = r < half ? (r + 1) * 2 : (rows - r) * 2;
                const startC = Math.floor((BRICK_COLS - rowWidth) / 2);
                alive = c >= startC && c < startC + rowWidth;
                type = r < 2 ? BRICK_TRIPLE : (r < 4 ? BRICK_DOUBLE : BRICK_NORMAL);
              }
              break;
            case 5: // Fortress with explosive core
              {
                const isEdge = r === 0 || r === rows - 1 || c === 0 || c === BRICK_COLS - 1;
                const isInner = r >= 2 && r <= rows - 3 && c >= 3 && c <= BRICK_COLS - 4;
                type = isEdge ? BRICK_TRIPLE : (isInner ? BRICK_EXPLOSIVE : BRICK_DOUBLE);
              }
              break;
            case 6: // Zigzag
              {
                const offset = r % 2 === 0 ? 0 : 3;
                alive = (c + offset) % 6 < 4;
                type = c % 4 === 0 ? BRICK_EXPLOSIVE : (r < 3 ? BRICK_DOUBLE : BRICK_NORMAL);
              }
              break;
            case 7: // Invader shape
              {
                const invader = [
                  [0,0,1,0,0,0,0,0,0,1,0,0],
                  [0,0,0,1,0,0,0,0,1,0,0,0],
                  [0,0,1,1,1,1,1,1,1,1,0,0],
                  [0,1,1,0,1,1,1,1,0,1,1,0],
                  [1,1,1,1,1,1,1,1,1,1,1,1],
                  [1,0,1,1,1,1,1,1,1,1,0,1],
                  [1,0,1,0,0,0,0,0,0,1,0,1],
                  [0,0,0,1,1,0,0,1,1,0,0,0],
                ];
                alive = r < invader.length && invader[r] && invader[r][c] === 1;
                type = r < 3 ? BRICK_DOUBLE : (r === 4 ? BRICK_TRIPLE : BRICK_NORMAL);
              }
              break;
          }

          // Scale difficulty with level
          if (lvl > 3 && type === BRICK_NORMAL && Math.random() < 0.1 * Math.min(lvl, 8)) {
            type = BRICK_DOUBLE;
          }
          if (lvl > 5 && type === BRICK_DOUBLE && Math.random() < 0.08) {
            type = BRICK_EXPLOSIVE;
          }

          bricks[r][c] = { alive, type, hits: alive ? type : 0 };
        }
      }
    }

    function brickColor(brick, row) {
      if (brick.type === BRICK_EXPLOSIVE) return '#f44';
      if (brick.hits === 3) return '#f4a';
      if (brick.hits === 2) return '#4cf';
      // Use row hue for single-hit bricks
      return ROW_HUES[row % ROW_HUES.length];
    }

    // ---------- INIT ----------
    function init() {
      score = 0;
      lives = 3;
      level = 1;
      paddleW = PADDLE_BASE_W;
      paddleX = W / 2 - paddleW / 2;
      balls = [];
      powerups = [];
      particles = [];
      fireball = false;
      fireballTimer = 0;
      catching = false;
      catchTimer = 0;
      caughtBall = null;
      combo = 0;
      comboMultiplier = 1;
      shakeTimer = 0;
      levelTransition = 0;

      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';

      generateLevel(1);
      resetBall();

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DX-BALL';
      overlayText.textContent = 'Press SPACE or click to start';
      draw();
    }

    function resetBall() {
      balls = [];
      caughtBall = null;
      const speed = Math.min(BASE_BALL_SPEED + (level - 1) * 0.3, MAX_BALL_SPEED);
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
      balls.push({
        x: W / 2,
        y: PADDLE_Y - BALL_R - 2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        fireball: fireball,
      });
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
    }

    // ---------- PARTICLES ----------
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 20 + Math.random() * 20,
          maxLife: 40,
          color,
          size: 2 + Math.random() * 3,
        });
      }
    }

    function spawnExplosion(x, y) {
      spawnParticles(x, y, '#f44', 20);
      spawnParticles(x, y, '#fa6', 15);
      spawnParticles(x, y, '#ff4', 10);
      shakeTimer = 8;
    }

    // ---------- POWERUP LOGIC ----------
    function dropPowerup(x, y) {
      if (Math.random() > POWERUP_DROP_CHANCE) return;
      const isGood = Math.random() < 0.65;
      const pool = isGood ? GOOD_POWERUPS : BAD_POWERUPS;
      const type = pool[Math.floor(Math.random() * pool.length)];
      powerups.push({ x: x - POWERUP_W / 2, y, type, isGood });
    }

    function applyPowerup(pu) {
      switch (pu.type) {
        case PU_EXPAND:
          paddleW = Math.min(paddleW + 30, PADDLE_MAX_W);
          paddleX = Math.max(0, Math.min(W - paddleW, paddleX));
          break;
        case PU_SHRINK:
          paddleW = Math.max(paddleW - 20, PADDLE_MIN_W);
          break;
        case PU_MULTI:
          {
            const newBalls = [];
            balls.forEach(b => {
              for (let i = 0; i < 2; i++) {
                const angle = Math.atan2(b.vy, b.vx) + (i === 0 ? -0.4 : 0.4);
                const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                newBalls.push({
                  x: b.x,
                  y: b.y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  fireball: b.fireball,
                });
              }
            });
            balls = balls.concat(newBalls);
            // Cap at 12 balls to avoid performance issues
            if (balls.length > 12) balls = balls.slice(0, 12);
          }
          break;
        case PU_FIREBALL:
          fireball = true;
          fireballTimer = 600; // 10 seconds at 60fps
          balls.forEach(b => b.fireball = true);
          break;
        case PU_CATCH:
          catching = true;
          catchTimer = 480; // 8 seconds
          break;
        case PU_EXTRA_LIFE:
          lives++;
          livesEl.textContent = lives;
          break;
        case PU_SPEED_UP:
          balls.forEach(b => {
            const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            const newSpeed = Math.min(speed * 1.4, MAX_BALL_SPEED);
            const ratio = newSpeed / speed;
            b.vx *= ratio;
            b.vy *= ratio;
          });
          break;
      }
    }

    // ---------- BRICK COLLISION ----------
    function destroyBrick(r, c, fromExplosion) {
      if (r < 0 || r >= bricks.length || c < 0 || c >= BRICK_COLS) return;
      const brick = bricks[r][c];
      if (!brick.alive) return;

      brick.hits--;
      if (brick.hits <= 0) {
        brick.alive = false;
        const bx = 10 + c * BRICK_W + BRICK_W / 2;
        const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;

        // Score with combo multiplier
        const basePoints = brick.type === BRICK_EXPLOSIVE ? 50 : (brick.type * 10 + 5);
        score += Math.floor(basePoints * comboMultiplier);
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }

        spawnParticles(bx, by, brickColor(brick, r), 8);
        dropPowerup(bx, by);

        // Explosive chain reaction
        if (brick.type === BRICK_EXPLOSIVE && !fromExplosion) {
          spawnExplosion(bx, by);
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              destroyBrick(r + dr, c + dc, true);
            }
          }
        }
      } else {
        // Brick damaged but not destroyed
        const bx = 10 + c * BRICK_W + BRICK_W / 2;
        const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;
        spawnParticles(bx, by, '#fff', 3);
      }
    }

    // ---------- UPDATE ----------
    function update() {
      // Level transition animation
      if (levelTransition > 0) {
        levelTransition--;
        if (levelTransition === 0) {
          generateLevel(level);
          resetBall();
          fireball = false;
          fireballTimer = 0;
          catching = false;
          catchTimer = 0;
          caughtBall = null;
          paddleW = PADDLE_BASE_W;
          paddleX = Math.max(0, Math.min(W - paddleW, paddleX));
        }
        return;
      }

      // Screen shake decay
      if (shakeTimer > 0) shakeTimer--;

      // Timers for powerups
      if (fireballTimer > 0) {
        fireballTimer--;
        if (fireballTimer <= 0) {
          fireball = false;
          balls.forEach(b => b.fireball = false);
        }
      }
      if (catchTimer > 0) {
        catchTimer--;
        if (catchTimer <= 0) {
          catching = false;
          if (caughtBall) {
            caughtBall = null;
          }
        }
      }

      // Move paddle (keyboard)
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        paddleX -= PADDLE_KEY_SPEED;
        useMouseControl = false;
      }
      if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        paddleX += PADDLE_KEY_SPEED;
        useMouseControl = false;
      }

      // Mouse control
      if (useMouseControl) {
        paddleX = mouseX - paddleW / 2;
      }

      paddleX = Math.max(0, Math.min(W - paddleW, paddleX));

      // Move caught ball with paddle
      if (caughtBall) {
        caughtBall.x = paddleX + paddleW / 2;
        caughtBall.y = PADDLE_Y - BALL_R - 1;
      }

      // Update powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        powerups[i].y += POWERUP_SPEED;
        const pu = powerups[i];

        // Catch with paddle
        if (pu.y + POWERUP_H >= PADDLE_Y && pu.y <= PADDLE_Y + PADDLE_H &&
            pu.x + POWERUP_W >= paddleX && pu.x <= paddleX + paddleW) {
          applyPowerup(pu);
          spawnParticles(pu.x + POWERUP_W / 2, pu.y, pu.isGood ? '#4f4' : '#f44', 6);
          powerups.splice(i, 1);
          continue;
        }

        // Off screen
        if (pu.y > H) {
          powerups.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05; // gravity
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Update balls
      for (let bi = balls.length - 1; bi >= 0; bi--) {
        const ball = balls[bi];
        if (ball === caughtBall) continue; // Held ball doesn't move

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall collisions
        if (ball.x - BALL_R <= 0) {
          ball.x = BALL_R;
          ball.vx = Math.abs(ball.vx);
        }
        if (ball.x + BALL_R >= W) {
          ball.x = W - BALL_R;
          ball.vx = -Math.abs(ball.vx);
        }
        if (ball.y - BALL_R <= 0) {
          ball.y = BALL_R;
          ball.vy = Math.abs(ball.vy);
        }

        // Paddle collision
        if (ball.vy > 0 && ball.y + BALL_R >= PADDLE_Y && ball.y + BALL_R <= PADDLE_Y + PADDLE_H + 6 &&
            ball.x >= paddleX - 2 && ball.x <= paddleX + paddleW + 2) {

          // Reset combo multiplier on paddle touch
          combo = 0;
          comboMultiplier = 1;

          if (catching && !caughtBall) {
            // Catch the ball
            caughtBall = ball;
            ball.x = paddleX + paddleW / 2;
            ball.y = PADDLE_Y - BALL_R - 1;
            ball.vx = 0;
            ball.vy = 0;
            continue;
          }

          ball.y = PADDLE_Y - BALL_R;
          const hit = (ball.x - paddleX) / paddleW; // 0 to 1
          const angle = -Math.PI * (0.15 + 0.7 * (1 - hit));
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          ball.vx = Math.cos(angle) * speed;
          ball.vy = Math.sin(angle) * speed;
          continue;
        }

        // Ball falls below
        if (ball.y - BALL_R > H) {
          balls.splice(bi, 1);
          if (ball === caughtBall) caughtBall = null;

          if (balls.length === 0) {
            lives--;
            livesEl.textContent = lives;
            combo = 0;
            comboMultiplier = 1;
            fireball = false;
            fireballTimer = 0;
            catching = false;
            catchTimer = 0;
            caughtBall = null;
            paddleW = PADDLE_BASE_W;

            if (lives <= 0) {
              gameOver();
              return;
            }
            resetBall();
          }
          continue;
        }

        // Brick collisions
        for (let r = 0; r < bricks.length; r++) {
          for (let c = 0; c < BRICK_COLS; c++) {
            if (!bricks[r][c].alive) continue;

            const bx = 10 + c * BRICK_W + BRICK_PAD;
            const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
            const bw = BRICK_W - BRICK_PAD * 2;
            const bh = BRICK_H - BRICK_PAD * 2;

            if (ball.x + BALL_R > bx && ball.x - BALL_R < bx + bw &&
                ball.y + BALL_R > by && ball.y - BALL_R < by + bh) {

              // Combo tracking
              combo++;
              comboMultiplier = 1 + Math.floor(combo / 3) * 0.5;

              destroyBrick(r, c, false);

              if (!ball.fireball) {
                // Bounce
                const overlapLeft = (ball.x + BALL_R) - bx;
                const overlapRight = (bx + bw) - (ball.x - BALL_R);
                const overlapTop = (ball.y + BALL_R) - by;
                const overlapBottom = (by + bh) - (ball.y - BALL_R);
                const minX = Math.min(overlapLeft, overlapRight);
                const minY = Math.min(overlapTop, overlapBottom);

                if (minX < minY) {
                  ball.vx = -ball.vx;
                } else {
                  ball.vy = -ball.vy;
                }
              }
              // Fireball passes through without bouncing

              if (!ball.fireball) break; // Only one brick per frame for normal ball
            }
          }
          if (!ball.fireball) {
            // Check if we already bounced
            // (simplified: only check the first hit)
          }
        }

        // Prevent ball from going too horizontal (minimum vertical speed)
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (Math.abs(ball.vy) < speed * 0.15 && speed > 0) {
          ball.vy = (ball.vy >= 0 ? 1 : -1) * speed * 0.15;
          const newHSpeed = Math.sqrt(speed * speed - ball.vy * ball.vy);
          ball.vx = (ball.vx >= 0 ? 1 : -1) * newHSpeed;
        }
      }

      // Check level clear
      let allClear = true;
      for (let r = 0; r < bricks.length; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (bricks[r][c].alive) { allClear = false; break; }
        }
        if (!allClear) break;
      }
      if (allClear) {
        level++;
        levelEl.textContent = level;
        levelTransition = 60; // 1 second pause between levels
        powerups = [];
        combo = 0;
        comboMultiplier = 1;
      }
    }

    // ---------- DRAW ----------
    function draw() {
      ctx.save();

      // Screen shake
      if (shakeTimer > 0) {
        const intensity = shakeTimer * 0.8;
        ctx.translate(
          (Math.random() - 0.5) * intensity,
          (Math.random() - 0.5) * intensity
        );
      }

      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(-5, -5, W + 10, H + 10);

      // Subtle grid
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 30) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 30) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Level transition text
      if (levelTransition > 0) {
        ctx.fillStyle = '#fa6';
        ctx.shadowColor = '#fa6';
        ctx.shadowBlur = 20;
        ctx.font = 'bold 28px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`LEVEL ${level}`, W / 2, H / 2 - 10);
        ctx.shadowBlur = 0;
        ctx.font = '16px "Courier New", monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Get ready!', W / 2, H / 2 + 20);
        ctx.textAlign = 'left';
        ctx.restore();
        return;
      }

      // Bricks
      for (let r = 0; r < bricks.length; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const brick = bricks[r][c];
          if (!brick.alive) continue;

          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;
          const color = brickColor(brick, r);

          ctx.fillStyle = color;
          ctx.shadowColor = color;
          ctx.shadowBlur = 6;
          ctx.fillRect(bx, by, bw, bh);
          ctx.shadowBlur = 0;

          // Brick type indicators
          if (brick.type === BRICK_EXPLOSIVE) {
            // Draw explosion icon (star)
            ctx.fillStyle = '#ff4';
            ctx.font = '10px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('*', bx + bw / 2, by + bh / 2 + 4);
            ctx.textAlign = 'left';
          } else if (brick.hits > 1) {
            // Draw hit count
            ctx.fillStyle = '#1a1a2e';
            ctx.font = 'bold 10px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(brick.hits, bx + bw / 2, by + bh / 2 + 4);
            ctx.textAlign = 'left';
          }
        }
      }

      // Powerups
      powerups.forEach(pu => {
        const color = pu.isGood ? '#4f4' : '#f44';
        const bgColor = pu.isGood ? 'rgba(0, 255, 0, 0.15)' : 'rgba(255, 0, 0, 0.15)';
        ctx.fillStyle = bgColor;
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        ctx.fillRect(pu.x, pu.y, POWERUP_W, POWERUP_H);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.strokeRect(pu.x, pu.y, POWERUP_W, POWERUP_H);
        ctx.shadowBlur = 0;

        ctx.fillStyle = color;
        ctx.font = 'bold 9px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(POWERUP_LABELS[pu.type], pu.x + POWERUP_W / 2, pu.y + POWERUP_H / 2 + 3);
        ctx.textAlign = 'left';
      });

      // Paddle
      {
        const paddleColor = catching ? '#4cf' : (fireball ? '#f44' : '#fa6');
        ctx.fillStyle = paddleColor;
        ctx.shadowColor = paddleColor;
        ctx.shadowBlur = 14;
        // Rounded paddle
        const pr = 6;
        ctx.beginPath();
        ctx.moveTo(paddleX + pr, PADDLE_Y);
        ctx.lineTo(paddleX + paddleW - pr, PADDLE_Y);
        ctx.quadraticCurveTo(paddleX + paddleW, PADDLE_Y, paddleX + paddleW, PADDLE_Y + pr);
        ctx.lineTo(paddleX + paddleW, PADDLE_Y + PADDLE_H - pr);
        ctx.quadraticCurveTo(paddleX + paddleW, PADDLE_Y + PADDLE_H, paddleX + paddleW - pr, PADDLE_Y + PADDLE_H);
        ctx.lineTo(paddleX + pr, PADDLE_Y + PADDLE_H);
        ctx.quadraticCurveTo(paddleX, PADDLE_Y + PADDLE_H, paddleX, PADDLE_Y + PADDLE_H - pr);
        ctx.lineTo(paddleX, PADDLE_Y + pr);
        ctx.quadraticCurveTo(paddleX, PADDLE_Y, paddleX + pr, PADDLE_Y);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Balls
      balls.forEach(ball => {
        const ballColor = ball.fireball ? '#f44' : '#fff';
        const glowColor = ball.fireball ? '#f44' : '#fa6';
        ctx.fillStyle = ballColor;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = ball.fireball ? 20 : 12;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Fireball trail
        if (ball.fireball && ball !== caughtBall) {
          ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
          ctx.beginPath();
          ctx.arc(ball.x - ball.vx * 0.5, ball.y - ball.vy * 0.5, BALL_R * 0.8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255, 68, 68, 0.15)';
          ctx.beginPath();
          ctx.arc(ball.x - ball.vx, ball.y - ball.vy, BALL_R * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Particles
      particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Combo display
      if (comboMultiplier > 1) {
        ctx.fillStyle = '#fa6';
        ctx.shadowColor = '#fa6';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 16px "Courier New", monospace';
        ctx.textAlign = 'right';
        ctx.fillText(`x${comboMultiplier.toFixed(1)}`, W - 10, H - 10);
        ctx.textAlign = 'left';
        ctx.shadowBlur = 0;
      }

      // Lives indicator
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#fa6';
        ctx.shadowColor = '#fa6';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(15 + i * 16, H - 12, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Active powerup timers
      let timerY = H - 28;
      if (fireball && fireballTimer > 0) {
        const pct = fireballTimer / 600;
        ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
        ctx.fillRect(10, timerY, 80 * pct, 6);
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 1;
        ctx.strokeRect(10, timerY, 80, 6);
        ctx.fillStyle = '#f44';
        ctx.font = '8px "Courier New", monospace';
        ctx.fillText('FIRE', 95, timerY + 6);
        timerY -= 12;
      }
      if (catching && catchTimer > 0) {
        const pct = catchTimer / 480;
        ctx.fillStyle = 'rgba(68, 204, 255, 0.3)';
        ctx.fillRect(10, timerY, 80 * pct, 6);
        ctx.strokeStyle = '#4cf';
        ctx.lineWidth = 1;
        ctx.strokeRect(10, timerY, 80, 6);
        ctx.fillStyle = '#4cf';
        ctx.font = '8px "Courier New", monospace';
        ctx.fillText('GRAB', 95, timerY + 6);
      }

      ctx.restore();
    }

    // ---------- GAME LOOP ----------
    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      updateGameData();
      requestAnimationFrame(loop);
    }

    // ---------- INPUT ----------
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        // Release caught ball
        if (e.key === ' ' && caughtBall) {
          const speed = Math.min(BASE_BALL_SPEED + (level - 1) * 0.3, MAX_BALL_SPEED);
          const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.4;
          caughtBall.vx = Math.cos(angle) * speed;
          caughtBall.vy = Math.sin(angle) * speed;
          caughtBall = null;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Mouse controls
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      useMouseControl = true;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing' && caughtBall) {
        const speed = Math.min(BASE_BALL_SPEED + (level - 1) * 0.3, MAX_BALL_SPEED);
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.4;
        caughtBall.vx = Math.cos(angle) * speed;
        caughtBall.vy = Math.sin(angle) * speed;
        caughtBall = null;
      }
    });

    // Prevent right-click context menu on canvas
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ---------- RICH STATE FOR ML ----------
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        paddleX,
        paddleW,
        balls: balls.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy, fireball: b.fireball })),
        powerups: powerups.map(p => ({ x: p.x, y: p.y, type: p.type, isGood: p.isGood })),
        lives,
        level,
        combo,
        comboMultiplier,
        fireball,
        catching,
        bricksRemaining: bricks.flat().filter(b => b.alive).length,
      };
    }

    // ---------- START ----------
    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

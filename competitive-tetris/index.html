<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Competitive Tetris</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f4f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 255, 0.5); }
    h1 { color: #f4f; font-size: 1.5rem; text-shadow: 0 0 15px rgba(255, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f4f; }
    canvas {
      border: 2px solid #f4f;
      box-shadow: 0 0 20px rgba(255, 68, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f4f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 68, 255, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>COMPETITIVE TETRIS</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span> lines</div>
    <div>AI: <span id="aiScore">0</span> lines</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">COMPETITIVE TETRIS</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    // Board constants
    const COLS = 10, ROWS = 20;
    const CELL = 22;
    const BOARD_W = COLS * CELL; // 220
    const BOARD_H = ROWS * CELL; // 440
    const BOARD_Y = 30;
    const P1_X = 15;
    const P2_X = W - BOARD_W - 15;
    const PREVIEW_SIZE = 4;
    const PREVIEW_CELL = 16;

    // Piece definitions: each rotation is a list of [row, col] offsets
    const PIECES = {
      I: { color: '#00f0f0', shape: [[0,0],[0,1],[0,2],[0,3]] },
      O: { color: '#f0f000', shape: [[0,0],[0,1],[1,0],[1,1]] },
      T: { color: '#a000f0', shape: [[0,1],[1,0],[1,1],[1,2]] },
      S: { color: '#00f000', shape: [[0,1],[0,2],[1,0],[1,1]] },
      Z: { color: '#f00000', shape: [[0,0],[0,1],[1,1],[1,2]] },
      J: { color: '#0000f0', shape: [[0,0],[1,0],[1,1],[1,2]] },
      L: { color: '#f0a000', shape: [[0,2],[1,0],[1,1],[1,2]] }
    };
    const PIECE_NAMES = ['I','O','T','S','Z','J','L'];

    function rotateShape(shape) {
      // 90 degrees clockwise
      const maxR = Math.max(...shape.map(s => s[0]));
      return shape.map(([r, c]) => [c, maxR - r]);
    }

    function getRotations(name) {
      let s = PIECES[name].shape.map(p => [...p]);
      const rots = [s];
      for (let i = 0; i < 3; i++) {
        s = rotateShape(s);
        // Normalize to 0,0 origin
        const minR = Math.min(...s.map(p => p[0]));
        const minC = Math.min(...s.map(p => p[1]));
        s = s.map(([r, c]) => [r - minR, c - minC]);
        rots.push(s);
      }
      return rots;
    }

    // Pre-compute all rotations
    const ALL_ROTATIONS = {};
    PIECE_NAMES.forEach(n => { ALL_ROTATIONS[n] = getRotations(n); });

    // Player board state
    function createPlayer() {
      return {
        board: Array.from({length: ROWS}, () => Array(COLS).fill(null)),
        piece: null,
        pieceType: null,
        rotation: 0,
        pieceRow: 0,
        pieceCol: 0,
        nextType: null,
        lines: 0,
        dropTimer: 0,
        dropInterval: 800,
        pendingGarbage: 0,
        alive: true,
        bag: [],
        lockDelay: 0,
        lockDelayMax: 500
      };
    }

    let p1, p2;
    let lastTime = 0;
    let aiMoveTimer = 0;
    let aiTargetCol = -1;
    let aiTargetRot = 0;
    let aiMoveInterval = 80;
    let aiDropping = false;
    let speedTimer = 0;

    function nextFromBag(player) {
      if (player.bag.length === 0) {
        player.bag = [...PIECE_NAMES];
        // Fisher-Yates shuffle
        for (let i = player.bag.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [player.bag[i], player.bag[j]] = [player.bag[j], player.bag[i]];
        }
      }
      return player.bag.pop();
    }

    function spawnPiece(player) {
      // Apply pending garbage first
      if (player.pendingGarbage > 0) {
        addGarbage(player, player.pendingGarbage);
        player.pendingGarbage = 0;
      }

      const type = player.nextType || nextFromBag(player);
      player.nextType = nextFromBag(player);
      player.pieceType = type;
      player.rotation = 0;
      player.piece = ALL_ROTATIONS[type][0];
      player.pieceCol = Math.floor((COLS - getShapeWidth(player.piece)) / 2);
      player.pieceRow = 0;
      player.lockDelay = 0;

      // Check if spawn position is blocked
      if (!isValid(player.board, player.piece, player.pieceRow, player.pieceCol)) {
        player.alive = false;
      }
    }

    function getShapeWidth(shape) {
      return Math.max(...shape.map(p => p[1])) + 1;
    }

    function isValid(board, shape, row, col) {
      for (const [r, c] of shape) {
        const br = row + r;
        const bc = col + c;
        if (bc < 0 || bc >= COLS || br >= ROWS) return false;
        if (br >= 0 && board[br][bc]) return false;
      }
      return true;
    }

    function lockPiece(player) {
      for (const [r, c] of player.piece) {
        const br = player.pieceRow + r;
        const bc = player.pieceCol + c;
        if (br >= 0 && br < ROWS && bc >= 0 && bc < COLS) {
          player.board[br][bc] = PIECES[player.pieceType].color;
        }
      }
      // Clear lines
      const cleared = clearLines(player);
      player.lines += cleared;

      // Send garbage to opponent
      if (cleared >= 2) {
        const opponent = player === p1 ? p2 : p1;
        let garbage = 0;
        if (cleared === 2) garbage = 1;
        else if (cleared === 3) garbage = 2;
        else if (cleared >= 4) garbage = 4;
        opponent.pendingGarbage += garbage;
      }

      spawnPiece(player);
    }

    function clearLines(player) {
      let cleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (player.board[r].every(c => c !== null)) {
          player.board.splice(r, 1);
          player.board.unshift(Array(COLS).fill(null));
          cleared++;
          r++; // recheck this row
        }
      }
      return cleared;
    }

    function addGarbage(player, count) {
      for (let i = 0; i < count; i++) {
        const gap = Math.floor(Math.random() * COLS);
        const row = Array(COLS).fill('#888888');
        row[gap] = null;
        player.board.shift(); // remove top row
        player.board.push(row); // add garbage at bottom
      }
    }

    function getGhostRow(player) {
      let r = player.pieceRow;
      while (isValid(player.board, player.piece, r + 1, player.pieceCol)) r++;
      return r;
    }

    function movePlayer(player, dx) {
      if (!player.alive || !player.piece) return;
      if (isValid(player.board, player.piece, player.pieceRow, player.pieceCol + dx)) {
        player.pieceCol += dx;
        // Reset lock delay if piece can still move down
        if (player.lockDelay > 0) player.lockDelay = 0;
      }
    }

    function rotatePlayer(player, dir) {
      if (!player.alive || !player.piece) return;
      const newRot = (player.rotation + dir + 4) % 4;
      const newShape = ALL_ROTATIONS[player.pieceType][newRot];
      // Try basic rotation
      if (isValid(player.board, newShape, player.pieceRow, player.pieceCol)) {
        player.piece = newShape;
        player.rotation = newRot;
        if (player.lockDelay > 0) player.lockDelay = 0;
        return;
      }
      // Wall kicks: try offsets
      const kicks = [[-1,0],[1,0],[-2,0],[2,0],[0,-1],[0,1]];
      for (const [dc, dr] of kicks) {
        if (isValid(player.board, newShape, player.pieceRow + dr, player.pieceCol + dc)) {
          player.piece = newShape;
          player.rotation = newRot;
          player.pieceCol += dc;
          player.pieceRow += dr;
          if (player.lockDelay > 0) player.lockDelay = 0;
          return;
        }
      }
    }

    function softDrop(player) {
      if (!player.alive || !player.piece) return;
      if (isValid(player.board, player.piece, player.pieceRow + 1, player.pieceCol)) {
        player.pieceRow++;
      }
    }

    function hardDrop(player) {
      if (!player.alive || !player.piece) return;
      while (isValid(player.board, player.piece, player.pieceRow + 1, player.pieceCol)) {
        player.pieceRow++;
      }
      lockPiece(player);
    }

    // --- AI Logic ---
    function aiEvaluate(board) {
      let holes = 0;
      let totalHeight = 0;
      let maxHeight = 0;
      let bumpiness = 0;
      const colHeights = [];

      for (let c = 0; c < COLS; c++) {
        let h = 0;
        for (let r = 0; r < ROWS; r++) {
          if (board[r][c]) { h = ROWS - r; break; }
        }
        colHeights.push(h);
        totalHeight += h;
        if (h > maxHeight) maxHeight = h;
      }

      // Count holes (empty cells below a filled cell)
      for (let c = 0; c < COLS; c++) {
        let blocked = false;
        for (let r = 0; r < ROWS; r++) {
          if (board[r][c]) blocked = true;
          else if (blocked) holes++;
        }
      }

      // Bumpiness (sum of height differences between adjacent columns)
      for (let c = 0; c < COLS - 1; c++) {
        bumpiness += Math.abs(colHeights[c] - colHeights[c + 1]);
      }

      // Count complete lines
      let completeLines = 0;
      for (let r = 0; r < ROWS; r++) {
        if (board[r].every(cell => cell !== null)) completeLines++;
      }

      // Weighted score (lower is better)
      return -holes * 35 - totalHeight * 2 - bumpiness * 5 + completeLines * 80 - maxHeight * 3;
    }

    function aiFindBestMove(player) {
      let bestScore = -Infinity;
      let bestCol = player.pieceCol;
      let bestRot = 0;

      for (let rot = 0; rot < 4; rot++) {
        const shape = ALL_ROTATIONS[player.pieceType][rot];
        const shapeWidth = Math.max(...shape.map(p => p[1])) + 1;
        const minCol = -Math.min(...shape.map(p => p[1]));
        const maxCol = COLS - shapeWidth - Math.min(...shape.map(p => p[1]));

        for (let col = minCol; col <= maxCol; col++) {
          // Check if piece can exist at top
          if (!isValid(player.board, shape, 0, col)) continue;

          // Drop piece
          let row = 0;
          while (isValid(player.board, shape, row + 1, col)) row++;

          // Clone board and place piece
          const testBoard = player.board.map(r => [...r]);
          for (const [r, c] of shape) {
            const br = row + r;
            const bc = col + c;
            if (br >= 0 && br < ROWS && bc >= 0 && bc < COLS) {
              testBoard[br][bc] = '#fff';
            }
          }

          const sc = aiEvaluate(testBoard);
          if (sc > bestScore) {
            bestScore = sc;
            bestCol = col;
            bestRot = rot;
          }
        }
      }

      return { col: bestCol, rot: bestRot };
    }

    function updateAI(dt) {
      if (!p2.alive || !p2.piece) return;

      // Decide target if we haven't yet
      if (aiTargetCol === -1) {
        const move = aiFindBestMove(p2);
        aiTargetCol = move.col;
        aiTargetRot = move.rot;
        aiDropping = false;
      }

      aiMoveTimer += dt;
      if (aiMoveTimer < aiMoveInterval) return;
      aiMoveTimer = 0;

      // First handle rotation
      if (p2.rotation !== aiTargetRot) {
        rotatePlayer(p2, 1);
        return;
      }

      // Then move horizontally
      if (p2.pieceCol < aiTargetCol) {
        movePlayer(p2, 1);
        return;
      } else if (p2.pieceCol > aiTargetCol) {
        movePlayer(p2, -1);
        return;
      }

      // In position - hard drop
      if (!aiDropping) {
        aiDropping = true;
        hardDrop(p2);
        aiTargetCol = -1;
      }
    }

    // --- Input ---
    document.addEventListener('keydown', e => {
      if (gameState !== 'playing') return;
      if (!p1.alive) return;

      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          movePlayer(p1, -1);
          break;
        case 'ArrowRight':
          e.preventDefault();
          movePlayer(p1, 1);
          break;
        case 'ArrowUp':
          e.preventDefault();
          rotatePlayer(p1, 1);
          break;
        case 'ArrowDown':
          e.preventDefault();
          softDrop(p1);
          break;
        case ' ':
          e.preventDefault();
          hardDrop(p1);
          break;
      }
    });

    // --- Gravity ---
    function updateGravity(player, dt) {
      if (!player.alive || !player.piece) return;
      player.dropTimer += dt;

      if (player.dropTimer >= player.dropInterval) {
        player.dropTimer = 0;
        if (isValid(player.board, player.piece, player.pieceRow + 1, player.pieceCol)) {
          player.pieceRow++;
          player.lockDelay = 0;
        } else {
          // Piece can't move down - start/continue lock delay
          player.lockDelay += player.dropInterval;
          if (player.lockDelay >= player.lockDelayMax) {
            lockPiece(player);
          }
        }
      }
    }

    // --- Drawing ---
    function drawBoard(player, ox, oy, label) {
      // Background
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(ox, oy, BOARD_W, BOARD_H);

      // Grid lines
      ctx.strokeStyle = '#1a1a3e';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(ox, oy + r * CELL);
        ctx.lineTo(ox + BOARD_W, oy + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(ox + c * CELL, oy);
        ctx.lineTo(ox + c * CELL, oy + BOARD_H);
        ctx.stroke();
      }

      // Placed blocks
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (player.board[r][c]) {
            drawBlock(ox + c * CELL, oy + r * CELL, player.board[r][c]);
          }
        }
      }

      // Ghost piece
      if (player.piece && player.alive) {
        const ghostRow = getGhostRow(player);
        for (const [r, c] of player.piece) {
          const br = ghostRow + r;
          const bc = player.pieceCol + c;
          if (br >= 0 && br < ROWS) {
            ctx.fillStyle = 'rgba(255, 68, 255, 0.15)';
            ctx.fillRect(ox + bc * CELL + 1, oy + br * CELL + 1, CELL - 2, CELL - 2);
            ctx.strokeStyle = 'rgba(255, 68, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.strokeRect(ox + bc * CELL + 1, oy + br * CELL + 1, CELL - 2, CELL - 2);
          }
        }
      }

      // Active piece
      if (player.piece && player.alive) {
        const color = PIECES[player.pieceType].color;
        for (const [r, c] of player.piece) {
          const br = player.pieceRow + r;
          const bc = player.pieceCol + c;
          if (br >= 0 && br < ROWS) {
            drawBlock(ox + bc * CELL, oy + br * CELL, color);
          }
        }
      }

      // Board border
      ctx.strokeStyle = player.alive ? '#f4f' : '#555';
      ctx.lineWidth = 2;
      ctx.strokeRect(ox, oy, BOARD_W, BOARD_H);

      // Pending garbage indicator
      if (player.pendingGarbage > 0) {
        ctx.fillStyle = '#f44';
        const barH = Math.min(player.pendingGarbage * CELL, BOARD_H);
        ctx.fillRect(ox - 6, oy + BOARD_H - barH, 4, barH);
      }

      // Label
      ctx.fillStyle = player.alive ? '#f4f' : '#555';
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(label, ox + BOARD_W / 2, oy - 6);

      // Next piece preview
      const previewX = player === p1 ? ox + BOARD_W + 8 : ox - PREVIEW_SIZE * PREVIEW_CELL - 8;
      const previewY = oy;
      ctx.fillStyle = '#111';
      ctx.fillRect(previewX, previewY, PREVIEW_SIZE * PREVIEW_CELL, PREVIEW_SIZE * PREVIEW_CELL);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(previewX, previewY, PREVIEW_SIZE * PREVIEW_CELL, PREVIEW_SIZE * PREVIEW_CELL);

      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('NEXT', previewX + PREVIEW_SIZE * PREVIEW_CELL / 2, previewY - 3);

      if (player.nextType) {
        const nextShape = ALL_ROTATIONS[player.nextType][0];
        const nextColor = PIECES[player.nextType].color;
        const sw = Math.max(...nextShape.map(p => p[1])) + 1;
        const sh = Math.max(...nextShape.map(p => p[0])) + 1;
        const offX = Math.floor((PREVIEW_SIZE - sw) / 2);
        const offY = Math.floor((PREVIEW_SIZE - sh) / 2);
        for (const [r, c] of nextShape) {
          const px = previewX + (offX + c) * PREVIEW_CELL;
          const py = previewY + (offY + r) * PREVIEW_CELL;
          ctx.fillStyle = nextColor;
          ctx.fillRect(px + 1, py + 1, PREVIEW_CELL - 2, PREVIEW_CELL - 2);
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(px + 1, py + 1, PREVIEW_CELL - 2, 3);
        }
      }
    }

    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.fillRect(x + 1, y + 1, CELL - 2, 4);
      ctx.fillRect(x + 1, y + 1, 4, CELL - 2);
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(x + CELL - 4, y + 1, 3, CELL - 2);
      ctx.fillRect(x + 1, y + CELL - 4, CELL - 2, 3);
    }

    function drawCenterInfo() {
      const cx = W / 2;
      // VS text
      ctx.fillStyle = '#f4f';
      ctx.font = 'bold 20px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = '#f4f';
      ctx.shadowBlur = 15;
      ctx.fillText('VS', cx, BOARD_Y + 40);
      ctx.shadowBlur = 0;

      // Speed level
      const level = Math.floor(speedTimer / 30000) + 1;
      ctx.fillStyle = '#888';
      ctx.font = '11px Courier New';
      ctx.fillText('SPEED ' + level, cx, BOARD_Y + 65);

      // Garbage indicators
      if (p1.pendingGarbage > 0) {
        ctx.fillStyle = '#f44';
        ctx.font = '12px Courier New';
        ctx.fillText('+' + p1.pendingGarbage + ' >>>', cx, BOARD_Y + 100);
      }
      if (p2.pendingGarbage > 0) {
        ctx.fillStyle = '#f44';
        ctx.font = '12px Courier New';
        ctx.fillText('<<< +' + p2.pendingGarbage, cx, BOARD_Y + 120);
      }

      // Controls reminder
      ctx.fillStyle = '#444';
      ctx.font = '9px Courier New';
      ctx.fillText('\u2190\u2192 Move', cx, BOARD_Y + BOARD_H - 60);
      ctx.fillText('\u2191 Rotate', cx, BOARD_Y + BOARD_H - 46);
      ctx.fillText('\u2193 Soft Drop', cx, BOARD_Y + BOARD_H - 32);
      ctx.fillText('SPACE Hard Drop', cx, BOARD_Y + BOARD_H - 18);
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'playing' || gameState === 'over') {
        drawBoard(p1, P1_X, BOARD_Y, 'YOU (' + p1.lines + ')');
        drawBoard(p2, P2_X, BOARD_Y, 'AI (' + p2.lines + ')');
        drawCenterInfo();
      }
    }

    // --- Game Loop ---
    function update(dt) {
      if (gameState !== 'playing') return;

      // Speed increase over time
      speedTimer += dt;
      const speedLevel = Math.floor(speedTimer / 30000);
      const baseInterval = Math.max(150, 800 - speedLevel * 80);
      p1.dropInterval = baseInterval;
      p2.dropInterval = baseInterval;

      // Update gravity
      updateGravity(p1, dt);
      updateGravity(p2, dt);

      // Update AI
      updateAI(dt);

      // Update scores
      score = p1.lines;
      scoreEl.textContent = p1.lines;
      aiScoreEl.textContent = p2.lines;

      // Check game over
      if (!p1.alive || !p2.alive) {
        gameState = 'over';
        score = p1.lines;
        if (!p1.alive && !p2.alive) {
          overlayTitle.textContent = 'DRAW!';
          overlayText.textContent = 'Both topped out! Lines: ' + p1.lines + ' vs ' + p2.lines + ' | Click to Retry';
        } else if (!p1.alive) {
          overlayTitle.textContent = 'AI WINS!';
          overlayText.textContent = 'You topped out! Lines: ' + p1.lines + ' vs ' + p2.lines + ' | Click to Retry';
        } else {
          overlayTitle.textContent = 'YOU WIN!';
          overlayText.textContent = 'AI topped out! Lines: ' + p1.lines + ' vs ' + p2.lines + ' | Click to Retry';
        }
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
      }
    }

    function gameLoop(time) {
      const dt = lastTime ? Math.min(time - lastTime, 100) : 16;
      lastTime = time;

      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    function init() {
      p1 = createPlayer();
      p2 = createPlayer();
      speedTimer = 0;
      aiMoveTimer = 0;
      aiTargetCol = -1;
      aiTargetRot = 0;
      aiDropping = false;

      spawnPiece(p1);
      spawnPiece(p2);

      score = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
    }

    // Click handler
    overlay.style.pointerEvents = 'auto';
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        lastTime = 0;
      }
    });

    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

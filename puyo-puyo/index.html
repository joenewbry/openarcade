<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puyo Puyo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 380px;
    }
    .back { color: #c8f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 136, 255, 0.5); }
    h1 { color: #c8f; font-size: 2rem; text-shadow: 0 0 15px rgba(204, 136, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 380px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #c8f; }
    canvas {
      border: 2px solid #c8f;
      box-shadow: 0 0 20px rgba(204, 136, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c8f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .side-panel { width: 120px; }
    .panel-box {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: center;
    }
    .panel-box label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }
    .panel-box .value {
      font-size: 1.4rem;
      color: #c8f;
    }
    #nextCanvas {
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PUYO PUYO</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="game-area">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="240" height="480"></canvas>
      <div class="overlay" id="overlay" style="width:240px;height:480px;">
        <h2 id="overlayTitle">PUYO PUYO</h2>
        <p id="overlayText">Press SPACE to start</p>
      </div>
    </div>
    <div class="side-panel">
      <div class="panel-box">
        <label>NEXT</label>
        <canvas id="nextCanvas" width="80" height="80"></canvas>
      </div>
      <div class="panel-box">
        <label>CHAIN</label>
        <div class="value" id="chain">0</div>
      </div>
      <div class="panel-box">
        <label>SCORE</label>
        <div class="value" id="scorePanel">0</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nctx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const scorePanelEl = document.getElementById('scorePanel');
    const chainEl = document.getElementById('chain');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const COLS = 6;
    const ROWS = 12;
    const CELL = 40;
    const W = canvas.width;
    const H = canvas.height;

    // Puyo colors - 4 distinct neon colors
    const COLORS = ['#f44', '#4f4', '#44f', '#ff4'];

    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let board; // ROWS x COLS grid, null or color index
    let currentPair; // { pivot: {color}, child: {color}, rotation: 0-3 }
    let pairX, pairY; // position of pivot puyo (grid coords, can be fractional for animation)
    let nextPair;
    let dropTimer;
    let dropInterval;
    let maxChain;
    let animState; // null, 'popping', 'falling', 'chainCheck'
    let animTimer;
    let popSet; // Set of cells being popped
    let popPhase; // animation phase counter
    let chainCount; // current chain counter
    let pairsDropped; // count of pairs placed, for difficulty scaling
    let keys = {};
    let softDropping = false;
    const SOFT_DROP_INTERVAL = 40;

    function init() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      score = 0;
      maxChain = 0;
      chainCount = 0;
      pairsDropped = 0;
      scoreEl.textContent = '0';
      scorePanelEl.textContent = '0';
      chainEl.textContent = '0';
      dropInterval = 800;
      animState = null;
      popSet = null;
      popPhase = 0;
      clearTimeout(dropTimer);
      clearTimeout(animTimer);
      nextPair = randomPair();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PUYO PUYO';
      overlayText.textContent = 'Press SPACE to start';
      draw();
      drawNext();
    }

    function randomPair() {
      return {
        pivot: Math.floor(Math.random() * COLORS.length),
        child: Math.floor(Math.random() * COLORS.length)
      };
    }

    function spawnPair() {
      currentPair = {
        pivot: nextPair.pivot,
        child: nextPair.child,
        rotation: 0 // 0=child above, 1=child right, 2=child below, 3=child left
      };
      nextPair = randomPair();
      pairX = 2; // column 3 (0-indexed)
      pairY = 0;
      pairsDropped++;
      drawNext();

      // Progressive difficulty: speed up every 10 pairs placed
      dropInterval = Math.max(150, 800 - Math.floor(pairsDropped / 10) * 50);

      // Check if spawn position is blocked
      if (board[0][2] !== null) {
        gameOver();
        return false;
      }
      return true;
    }

    // Get child position relative to pivot based on rotation
    function getChildOffset(rotation) {
      switch (rotation) {
        case 0: return { dx: 0, dy: -1 }; // above
        case 1: return { dx: 1, dy: 0 };  // right
        case 2: return { dx: 0, dy: 1 };  // below
        case 3: return { dx: -1, dy: 0 }; // left
      }
    }

    function getChildPos() {
      const off = getChildOffset(currentPair.rotation);
      return { x: pairX + off.dx, y: pairY + off.dy };
    }

    function canPlace(px, py, rotation) {
      const off = getChildOffset(rotation);
      const cx = px + off.dx;
      const cy = py + off.dy;
      // Pivot must be valid (on grid or above)
      if (px < 0 || px >= COLS || py >= ROWS) return false;
      if (py >= 0 && board[py][px] !== null) return false;
      // Child must be valid
      if (cx < 0 || cx >= COLS || cy >= ROWS) return false;
      if (cy >= 0 && board[cy][cx] !== null) return false;
      return true;
    }

    function movePair(dx) {
      if (!currentPair || animState) return;
      const newX = pairX + dx;
      if (canPlace(newX, pairY, currentPair.rotation)) {
        pairX = newX;
      }
    }

    function rotatePair(dir) {
      if (!currentPair || animState) return;
      // dir: 1 = clockwise, -1 = counter-clockwise
      let newRot = (currentPair.rotation + dir + 4) % 4;

      // Try direct rotation
      if (canPlace(pairX, pairY, newRot)) {
        currentPair.rotation = newRot;
        return;
      }

      // Wall kick: try shifting pivot
      const kicks = [
        { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
        { dx: 0, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
      ];
      for (const kick of kicks) {
        if (canPlace(pairX + kick.dx, pairY + kick.dy, newRot)) {
          pairX += kick.dx;
          pairY += kick.dy;
          currentPair.rotation = newRot;
          return;
        }
      }
    }

    function dropPair() {
      if (!currentPair || animState) return false;
      const newY = pairY + 1;
      if (canPlace(pairX, newY, currentPair.rotation)) {
        pairY = newY;
        return true;
      }
      return false;
    }

    function lockPair() {
      if (!currentPair) return;
      const child = getChildPos();

      // Place pivot
      if (pairY >= 0 && pairY < ROWS) {
        board[pairY][pairX] = currentPair.pivot;
      }
      // Place child
      if (child.y >= 0 && child.y < ROWS) {
        board[child.y][child.x] = currentPair.child;
      }

      currentPair = null;

      // Apply gravity then check for pops
      chainCount = 0;
      applyGravity();
    }

    function applyGravity() {
      let fell = false;
      for (let c = 0; c < COLS; c++) {
        // Start from bottom, move puyos down to fill gaps
        let writeRow = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r][c] !== null) {
            if (writeRow !== r) {
              board[writeRow][c] = board[r][c];
              board[r][c] = null;
              fell = true;
            }
            writeRow--;
          }
        }
      }

      // After gravity, check for pops
      animState = 'chainCheck';
      animTimer = setTimeout(() => {
        checkPops();
      }, fell ? 150 : 50);
    }

    function checkPops() {
      // Find all connected groups of 4+ same color
      const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
      const groups = [];

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] !== null && !visited[r][c]) {
            // BFS to find connected group
            const color = board[r][c];
            const group = [];
            const queue = [{ r, c }];
            visited[r][c] = true;

            while (queue.length > 0) {
              const cell = queue.shift();
              group.push(cell);

              const neighbors = [
                { r: cell.r - 1, c: cell.c },
                { r: cell.r + 1, c: cell.c },
                { r: cell.r, c: cell.c - 1 },
                { r: cell.r, c: cell.c + 1 }
              ];

              for (const n of neighbors) {
                if (n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS &&
                    !visited[n.r][n.c] && board[n.r][n.c] === color) {
                  visited[n.r][n.c] = true;
                  queue.push(n);
                }
              }
            }

            if (group.length >= 4) {
              groups.push({ color, cells: group });
            }
          }
        }
      }

      if (groups.length > 0) {
        // Pop these groups
        chainCount++;
        if (chainCount > maxChain) {
          maxChain = chainCount;
          chainEl.textContent = maxChain;
        }

        popSet = new Set();
        let totalPopped = 0;
        let groupBonus = 0;
        let colorBonus = 0;
        const colorsPopped = new Set();

        for (const group of groups) {
          for (const cell of group.cells) {
            popSet.add(cell.r * COLS + cell.c);
            totalPopped++;
          }
          colorsPopped.add(group.color);
          // Group size bonus: 0 for 4, 2 for 5, 3 for 6, etc.
          if (group.cells.length > 4) {
            groupBonus += group.cells.length - 3;
          }
        }

        // Color bonus
        const colorBonusTable = [0, 0, 3, 6, 12];
        colorBonus = colorBonusTable[Math.min(colorsPopped.size, 4)];

        // Chain power table
        const chainPower = [0, 0, 8, 16, 32, 64, 96, 128, 160, 192, 224, 256];
        const cp = chainCount < chainPower.length ? chainPower[chainCount] : 256 + (chainCount - 11) * 32;

        // Score formula: (10 * puyosCleared) * max(1, chainPower + colorBonus + groupBonus)
        const multiplier = Math.max(1, cp + colorBonus + groupBonus);
        const points = 10 * totalPopped * multiplier;
        score += points;
        scoreEl.textContent = score;
        scorePanelEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }

        // Animate pop
        animState = 'popping';
        popPhase = 0;
        animatePop();
      } else {
        // No more pops - spawn next pair
        animState = null;
        popSet = null;
        if (!spawnPair()) return;
        draw();
        scheduleDrop();
      }
    }

    function animatePop() {
      popPhase++;
      draw();

      if (popPhase <= 16) {
        animTimer = setTimeout(animatePop, 35);
      } else {
        // Remove popped puyos
        for (const key of popSet) {
          const r = Math.floor(key / COLS);
          const c = key % COLS;
          board[r][c] = null;
        }
        popSet = null;
        animState = 'falling';
        draw();

        // Apply gravity again
        animTimer = setTimeout(() => {
          applyGravity();
        }, 100);
      }
    }

    function scheduleDrop() {
      clearTimeout(dropTimer);
      if (gameState !== 'playing') return;
      dropTimer = setTimeout(tick, softDropping ? SOFT_DROP_INTERVAL : dropInterval);
    }

    function tick() {
      clearTimeout(dropTimer);
      if (gameState !== 'playing' || animState) return;

      if (!dropPair()) {
        lockPair();
      } else {
        if (softDropping) {
          score += 1;
          scoreEl.textContent = score;
          scorePanelEl.textContent = score;
        }
        draw();
        scheduleDrop();
      }
    }

    function hardDrop() {
      if (!currentPair || animState) return;
      let dropped = 0;
      while (dropPair()) {
        dropped++;
      }
      score += dropped * 2;
      scoreEl.textContent = score;
      scorePanelEl.textContent = score;
      lockPair();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      if (!spawnPair()) return;
      draw();
      scheduleDrop();
    }

    function gameOver() {
      gameState = 'over';
      clearTimeout(dropTimer);
      clearTimeout(animTimer);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    // Drawing functions
    function drawPuyo(context, cx, cy, radius, colorIdx, alpha) {
      if (colorIdx === null || colorIdx === undefined) return;
      const color = COLORS[colorIdx];

      context.save();
      context.globalAlpha = alpha !== undefined ? alpha : 1;

      // Main body
      context.beginPath();
      context.arc(cx, cy, radius, 0, Math.PI * 2);
      context.fillStyle = color;
      context.shadowColor = color;
      context.shadowBlur = 10;
      context.fill();
      context.shadowBlur = 0;

      // Inner highlight (top-left)
      context.beginPath();
      context.arc(cx - radius * 0.25, cy - radius * 0.25, radius * 0.45, 0, Math.PI * 2);
      context.fillStyle = 'rgba(255, 255, 255, 0.25)';
      context.fill();

      // Small specular highlight
      context.beginPath();
      context.arc(cx - radius * 0.3, cy - radius * 0.35, radius * 0.15, 0, Math.PI * 2);
      context.fillStyle = 'rgba(255, 255, 255, 0.5)';
      context.fill();

      // Eyes
      const eyeOffX = radius * 0.22;
      const eyeY = cy - radius * 0.05;
      const eyeR = radius * 0.12;
      // Left eye
      context.beginPath();
      context.arc(cx - eyeOffX, eyeY, eyeR, 0, Math.PI * 2);
      context.fillStyle = '#fff';
      context.fill();
      context.beginPath();
      context.arc(cx - eyeOffX, eyeY, eyeR * 0.5, 0, Math.PI * 2);
      context.fillStyle = '#111';
      context.fill();
      // Right eye
      context.beginPath();
      context.arc(cx + eyeOffX, eyeY, eyeR, 0, Math.PI * 2);
      context.fillStyle = '#fff';
      context.fill();
      context.beginPath();
      context.arc(cx + eyeOffX, eyeY, eyeR * 0.5, 0, Math.PI * 2);
      context.fillStyle = '#111';
      context.fill();

      context.restore();
    }

    function drawBoardPuyo(r, c, colorIdx, alpha) {
      const cx = c * CELL + CELL / 2;
      const cy = r * CELL + CELL / 2;
      drawPuyo(ctx, cx, cy, CELL * 0.42, colorIdx, alpha);
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Draw "X" marker on the kill column (col 2, row 0)
      ctx.save();
      ctx.strokeStyle = 'rgba(204, 136, 255, 0.3)';
      ctx.lineWidth = 2;
      const xc = 2 * CELL;
      ctx.beginPath();
      ctx.moveTo(xc + 4, 4);
      ctx.lineTo(xc + CELL - 4, CELL - 4);
      ctx.moveTo(xc + CELL - 4, 4);
      ctx.lineTo(xc + 4, CELL - 4);
      ctx.stroke();
      ctx.restore();

      // Board puyos
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] !== null) {
            // Check if this cell is being popped
            if (popSet && popSet.has(r * COLS + c)) {
              // Pop animation
              const pulse = Math.sin(popPhase * 0.6) * 0.5 + 0.5;
              const shrink = Math.max(0, 1 - popPhase / 16);
              const cx = c * CELL + CELL / 2;
              const cy = r * CELL + CELL / 2;
              drawPuyo(ctx, cx, cy, CELL * 0.42 * shrink, board[r][c], pulse);

              // Sparkle effect
              if (popPhase < 12) {
                ctx.save();
                const sparkCount = 4;
                for (let s = 0; s < sparkCount; s++) {
                  const angle = (popPhase * 0.3) + (s * Math.PI * 2 / sparkCount);
                  const dist = popPhase * 2;
                  const sx = cx + Math.cos(angle) * dist;
                  const sy = cy + Math.sin(angle) * dist;
                  ctx.fillStyle = COLORS[board[r][c]];
                  ctx.shadowColor = COLORS[board[r][c]];
                  ctx.shadowBlur = 8;
                  ctx.globalAlpha = 1 - popPhase / 12;
                  ctx.fillRect(sx - 2, sy - 2, 4, 4);
                }
                ctx.shadowBlur = 0;
                ctx.restore();
              }
            } else {
              drawBoardPuyo(r, c, board[r][c]);
            }
          }
        }
      }

      // Current falling pair
      if (currentPair && !animState) {
        const child = getChildPos();

        // Ghost (drop preview)
        let ghostY = pairY;
        while (canPlace(pairX, ghostY + 1, currentPair.rotation)) {
          ghostY++;
        }
        if (ghostY !== pairY) {
          const ghostChild = getChildOffset(currentPair.rotation);
          // Ghost pivot
          if (ghostY >= 0 && ghostY < ROWS) {
            drawBoardPuyo(ghostY, pairX, currentPair.pivot, 0.2);
          }
          // Ghost child
          const gcr = ghostY + ghostChild.dy;
          const gcc = pairX + ghostChild.dx;
          if (gcr >= 0 && gcr < ROWS) {
            drawBoardPuyo(gcr, gcc, currentPair.child, 0.2);
          }
        }

        // Draw actual pair
        if (pairY >= 0 && pairY < ROWS) {
          drawBoardPuyo(pairY, pairX, currentPair.pivot);
        }
        if (child.y >= 0 && child.y < ROWS) {
          drawBoardPuyo(child.y, child.x, currentPair.child);
        }
      }

      // Chain text display
      if (animState === 'popping' && chainCount >= 2) {
        ctx.save();
        const scale = 1 + Math.sin(popPhase * 0.5) * 0.1;
        ctx.translate(W / 2, H / 2);
        ctx.scale(scale, scale);
        ctx.font = 'bold 36px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#c8f';
        ctx.shadowColor = '#c8f';
        ctx.shadowBlur = 20;
        ctx.fillText(chainCount + ' CHAIN!', 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawNext() {
      nctx.fillStyle = '#16213e';
      nctx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

      if (!nextPair) return;

      const ncx = nextCanvas.width / 2;
      const size = 16;

      // Child above pivot
      drawPuyo(nctx, ncx, 20, size, nextPair.child);
      drawPuyo(nctx, ncx, 56, size, nextPair.pivot);
    }

    document.addEventListener('keydown', (e) => {
      const gameKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'Z'];
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing' && !animState) {
        switch (e.key) {
          case 'ArrowLeft':
            movePair(-1);
            draw();
            break;
          case 'ArrowRight':
            movePair(1);
            draw();
            break;
          case 'ArrowDown':
            if (!softDropping) {
              softDropping = true;
              clearTimeout(dropTimer);
              tick();
            }
            break;
          case 'ArrowUp':
            rotatePair(1); // clockwise
            draw();
            break;
          case 'z':
          case 'Z':
            rotatePair(-1); // counter-clockwise
            draw();
            break;
          case ' ':
            hardDrop();
            break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
      if (e.key === 'ArrowDown' && softDropping) {
        softDropping = false;
        clearTimeout(dropTimer);
        scheduleDrop();
      }
    });

    // Expose game data for ML
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        board: board ? board.map(row => row.slice()) : [],
        pairX, pairY,
        currentPair,
        nextPair,
        chainCount,
        maxChain,
        score,
        gameState
      };
    }

    // Periodically update game data
    setInterval(updateGameData, 200);

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nidhogg-like</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #fc0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(252, 204, 0, 0.5); }
    h1 { color: #fc0; font-size: 1.6rem; text-shadow: 0 0 15px rgba(252, 204, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fc0; }
    canvas {
      border: 2px solid #fc0;
      box-shadow: 0 0 20px rgba(252, 204, 0, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fc0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(252, 204, 0, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
    .controls { width: 600px; margin-top: 12px; color: #777; font-size: 0.8rem; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>NIDHOGG-LIKE</h1>
  </div>
  <div class="score-bar">
    <div>P1 Kills: <span id="p1Score">0</span></div>
    <div>Screen: <span id="screenPos">0</span></div>
    <div>AI Kills: <span id="p2Score">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="300"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:300px;">
      <h2 id="overlayTitle">NIDHOGG-LIKE</h2>
      <p id="overlayText">Click to Start</p>
      <p style="font-size:0.8rem;color:#888;margin-top:8px;">Arrows: Move/Jump | Z/X/C: Attack High/Mid/Low | S: Block | D: Throw</p>
    </div>
  </div>
  <div class="controls">
    Arrows: Move/Jump &nbsp;|&nbsp; Z: High &nbsp;|&nbsp; X: Mid &nbsp;|&nbsp; C: Low &nbsp;|&nbsp; S: Block &nbsp;|&nbsp; D: Throw Sword
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 300;
    const GROUND = 235;
    const GRAVITY = 0.55;
    const SCREEN_W = 600;
    const TOTAL_SCREENS = 9;
    const WORLD_LEFT = -4 * SCREEN_W;
    const WORLD_RIGHT = 4 * SCREEN_W + SCREEN_W;

    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const screenPosEl = document.getElementById('screenPos');

    let gameState;
    let score;

    // Input
    const keys = {};
    const keyJustPressed = {};
    document.addEventListener('keydown', e => {
      if (!keys[e.code]) keyJustPressed[e.code] = true;
      keys[e.code] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyZ','KeyX','KeyC','KeyS','KeyD'].includes(e.code)) {
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    // Constants
    const STANCE_HIGH = 0, STANCE_MID = 1, STANCE_LOW = 2;
    const SWORD_RANGE = 48;
    const FIST_RANGE = 22;
    const SWORD_THROW_SPEED = 11;

    // Dropped swords on the ground
    let droppedSwords = [];

    class Fighter {
      constructor(x, facing, isAI) {
        this.x = x;
        this.y = GROUND;
        this.vx = 0;
        this.vy = 0;
        this.facing = facing;
        this.isAI = isAI;
        this.hasSword = true;
        this.stance = STANCE_MID;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackStance = STANCE_MID;
        this.attackHitRegistered = false;
        this.blocking = false;
        this.dead = false;
        this.deathTimer = 0;
        this.onGround = true;
        this.runSpeed = 3.2;
        this.color = isAI ? '#f55' : '#fc0';
        this.throwCooldown = 0;
        this.thrownSword = null;
        this.stunTimer = 0;
        this.advancing = false;
        this.advanceTimer = 0;
        this.goalDir = isAI ? -1 : 1; // P1 goes right, AI goes left
        // AI fields
        this.aiTimer = 0;
        this.aiDecision = null;
      }

      reset(x, facing) {
        this.x = x;
        this.y = GROUND;
        this.vx = 0;
        this.vy = 0;
        this.facing = facing;
        this.hasSword = true;
        this.stance = STANCE_MID;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackHitRegistered = false;
        this.blocking = false;
        this.dead = false;
        this.deathTimer = 0;
        this.onGround = true;
        this.thrownSword = null;
        this.throwCooldown = 0;
        this.stunTimer = 0;
        this.advancing = false;
        this.advanceTimer = 0;
        this.aiTimer = 0;
        this.aiDecision = null;
      }

      get weaponRange() { return this.hasSword ? SWORD_RANGE : FIST_RANGE; }

      attack(stance) {
        if (this.attacking || this.stunTimer > 0 || this.dead) return;
        this.attacking = true;
        this.attackTimer = 14;
        this.attackStance = stance;
        this.attackHitRegistered = false;
        this.blocking = false;
      }

      throwSword(opponent) {
        if (!this.hasSword || this.attacking || this.throwCooldown > 0 || this.stunTimer > 0 || this.dead) return;
        this.hasSword = false;
        this.throwCooldown = 40;
        this.thrownSword = {
          x: this.x + this.facing * 18,
          y: this.y - 22,
          vx: this.facing * SWORD_THROW_SPEED,
          vy: -0.5,
          active: true,
          stance: this.stance
        };
      }

      update() {
        if (this.dead) {
          this.deathTimer++;
          this.vy += GRAVITY;
          this.x += this.vx;
          this.y += this.vy;
          return;
        }

        if (this.stunTimer > 0) {
          this.stunTimer--;
          this.vx *= 0.85;
        }

        if (this.attackTimer > 0) {
          this.attackTimer--;
          if (this.attackTimer === 0) this.attacking = false;
        }

        if (this.throwCooldown > 0) this.throwCooldown--;

        // Physics
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;

        if (this.y >= GROUND) {
          this.y = GROUND;
          this.vy = 0;
          this.onGround = true;
        } else {
          this.onGround = false;
        }

        // World bounds
        this.x = Math.max(WORLD_LEFT + 20, Math.min(WORLD_RIGHT - 20, this.x));

        // Ground friction
        if (this.onGround && this.stunTimer <= 0 && !this.advancing) {
          this.vx *= 0.75;
        }

        // Thrown sword update
        if (this.thrownSword && this.thrownSword.active) {
          this.thrownSword.x += this.thrownSword.vx;
          this.thrownSword.y += this.thrownSword.vy;
          this.thrownSword.vy += 0.03;
          // Despawn far away
          if (Math.abs(this.thrownSword.x - this.x) > 900) {
            // Drop sword on ground
            droppedSwords.push({ x: this.thrownSword.x, y: GROUND - 5 });
            this.thrownSword.active = false;
          }
          // Hit ground
          if (this.thrownSword.y > GROUND) {
            droppedSwords.push({ x: this.thrownSword.x, y: GROUND - 5 });
            this.thrownSword.active = false;
          }
        }
      }
    }

    // Game state
    let p1, p2, cameraX, kills1, kills2, roundTimer, respawnTimer;
    let winner, particles, enGardeTimer, flashTimer;

    function init() {
      gameState = 'waiting';
      score = 0;
      kills1 = 0;
      kills2 = 0;
      p1 = new Fighter(0, 1, false);
      p2 = new Fighter(200, -1, true);
      cameraX = 0;
      roundTimer = 0;
      respawnTimer = 0;
      winner = null;
      particles = [];
      droppedSwords = [];
      enGardeTimer = 0;
      flashTimer = 0;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'NIDHOGG-LIKE';
      overlayText.textContent = 'Click to Start';
      updateUI();
    }

    function startMatch() {
      gameState = 'playing';
      kills1 = 0;
      kills2 = 0;
      p1.reset(-80, 1);
      p2.reset(80, -1);
      cameraX = 0;
      roundTimer = 0;
      respawnTimer = 0;
      winner = null;
      particles = [];
      droppedSwords = [];
      enGardeTimer = 80;
      flashTimer = 0;
      overlay.style.display = 'none';
      updateUI();
    }

    function updateUI() {
      p1ScoreEl.textContent = kills1;
      p2ScoreEl.textContent = kills2;
      let leaderX = p1.dead ? p2.x : (p2.dead ? p1.x : (p1.x + p2.x) / 2);
      screenPosEl.textContent = Math.round(leaderX / SCREEN_W);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 10,
          vy: -Math.random() * 7 - 2,
          life: 20 + Math.random() * 25,
          color,
          size: 1.5 + Math.random() * 3
        });
      }
    }

    // --- Combat ---
    function checkHit(attacker, defender) {
      if (!attacker.attacking || defender.dead || attacker.dead) return false;
      if (attacker.attackHitRegistered) return false;
      // Active frames: frames 7-10 of a 14-frame attack
      if (attacker.attackTimer < 4 || attacker.attackTimer > 8) return false;

      let dx = defender.x - attacker.x;
      let dist = Math.abs(dx);
      let inFront = (dx * attacker.facing) > 0;

      if (!inFront || dist > attacker.weaponRange + 12) return false;

      // Height check
      let dy = Math.abs(defender.y - attacker.y);
      if (dy > 35) return false;

      // Block check
      if (defender.blocking && !defender.attacking) {
        if (defender.stance === attacker.attackStance) {
          // Successful block - parry!
          attacker.stunTimer = 18;
          attacker.vx = -attacker.facing * 4;
          attacker.attackHitRegistered = true;
          spawnParticles(
            (attacker.x + defender.x) / 2,
            attacker.y - 22,
            '#fff', 6
          );
          return false;
        }
      }

      // Sword clash check
      if (defender.attacking && !defender.attackHitRegistered &&
          defender.attackTimer >= 4 && defender.attackTimer <= 8 &&
          defender.attackStance === attacker.attackStance) {
        attacker.stunTimer = 14;
        defender.stunTimer = 14;
        attacker.vx = -attacker.facing * 5;
        defender.vx = -defender.facing * 5;
        attacker.attackHitRegistered = true;
        defender.attackHitRegistered = true;
        spawnParticles((attacker.x + defender.x) / 2, attacker.y - 22, '#fff', 10);
        // Chance to disarm on clash
        if (Math.random() < 0.2) {
          let victim = Math.random() < 0.5 ? attacker : defender;
          if (victim.hasSword) {
            victim.hasSword = false;
            droppedSwords.push({
              x: (attacker.x + defender.x) / 2,
              y: GROUND - 5
            });
          }
        }
        return false;
      }

      attacker.attackHitRegistered = true;
      return true;
    }

    function checkThrownSwordHit(sword, target) {
      if (!sword || !sword.active || target.dead) return false;
      let dx = Math.abs(sword.x - target.x);
      let dy = Math.abs(sword.y - (target.y - 22));
      if (dx < 16 && dy < 22) {
        if (target.blocking) {
          // Catch/deflect the sword
          sword.active = false;
          if (!target.hasSword) {
            target.hasSword = true;
          }
          spawnParticles(sword.x, sword.y, '#fff', 6);
          return false;
        }
        return true;
      }
      return false;
    }

    function killFighter(victim, killer) {
      victim.dead = true;
      victim.deathTimer = 0;
      victim.vy = -9;
      victim.vx = (victim.x < killer.x ? -4 : 4);

      if (killer === p1) {
        kills1++;
        score = kills1;
      } else {
        kills2++;
      }

      spawnParticles(victim.x, victim.y - 20, victim.color, 18);
      spawnParticles(victim.x, victim.y - 20, '#c00', 12);

      // Drop victim's sword if they had one
      if (victim.hasSword) {
        droppedSwords.push({ x: victim.x, y: GROUND - 5 });
      }

      // Killer advances toward their goal side
      killer.advancing = true;
      killer.advanceTimer = 70;
      killer.facing = killer.goalDir;

      flashTimer = 15;
      respawnTimer = 100;
      updateUI();
    }

    function respawn() {
      let alive = p1.dead ? p2 : p1;
      let dead = p1.dead ? p1 : p2;

      // Respawn in front of the advancing killer (blocking their path)
      let spawnX = alive.x + alive.goalDir * 280;
      spawnX = Math.max(WORLD_LEFT + 50, Math.min(WORLD_RIGHT - 50, spawnX));

      dead.reset(spawnX, dead === p1 ? 1 : -1);
      dead.facing = dead.x < alive.x ? 1 : -1;
      alive.advancing = false;
      alive.advanceTimer = 0;
      enGardeTimer = 50;
    }

    // --- AI ---
    function updateAI(ai, player) {
      if (ai.dead || ai.stunTimer > 0) return;

      let dx = player.x - ai.x;
      let dist = Math.abs(dx);

      // Always face player
      ai.facing = dx > 0 ? 1 : -1;

      // React to incoming thrown sword
      if (player.thrownSword && player.thrownSword.active) {
        let sw = player.thrownSword;
        let sDist = Math.abs(sw.x - ai.x);
        let approaching = (sw.vx > 0 && sw.x < ai.x) || (sw.vx < 0 && sw.x > ai.x);
        if (sDist < 180 && approaching) {
          ai.blocking = true;
          ai.stance = sw.stance;
          // Sometimes jump over it
          if (Math.random() < 0.2 && ai.onGround && sDist < 100) {
            ai.vy = -11;
            ai.blocking = false;
          }
          return;
        }
      }

      // React to player attacks
      if (player.attacking && player.attackTimer >= 4 && dist < 90) {
        if (Math.random() < 0.65) {
          ai.blocking = true;
          ai.stance = player.attackStance;
          ai.aiTimer = 8;
          return;
        } else if (Math.random() < 0.3 && ai.onGround) {
          ai.vy = -11;
          ai.vx = -ai.facing * 2;
          return;
        }
      }

      ai.aiTimer--;
      if (ai.aiTimer > 0) {
        // Maintain current action
        if (ai.blocking) ai.vx *= 0.4;
        return;
      }

      // New decision
      ai.aiTimer = 6 + Math.floor(Math.random() * 10);
      ai.blocking = false;

      if (ai.advancing) {
        // Just run toward goal
        ai.vx = ai.goalDir * ai.runSpeed * 1.2;
        return;
      }

      // Pick up dropped sword if nearby and unarmed
      if (!ai.hasSword) {
        let closest = null;
        let closestDist = Infinity;
        for (let s of droppedSwords) {
          let d = Math.abs(s.x - ai.x);
          if (d < closestDist) { closestDist = d; closest = s; }
        }
        if (closest && closestDist < 40) {
          ai.hasSword = true;
          droppedSwords.splice(droppedSwords.indexOf(closest), 1);
        } else if (closest && closestDist < 200) {
          // Move toward sword
          ai.vx = (closest.x > ai.x ? 1 : -1) * ai.runSpeed;
          return;
        }
      }

      if (dist < 55) {
        // Close range combat
        let r = Math.random();
        if (r < 0.12 && ai.hasSword) {
          ai.throwSword(player);
        } else if (r < 0.65) {
          // Attack at stance player isn't blocking
          let stances = [STANCE_HIGH, STANCE_MID, STANCE_LOW];
          if (player.blocking) {
            stances = stances.filter(s => s !== player.stance);
          }
          // Mix it up
          let chosen = stances[Math.floor(Math.random() * stances.length)];
          ai.stance = chosen;
          ai.attack(chosen);
        } else if (r < 0.85) {
          // Block
          ai.blocking = true;
          ai.stance = [STANCE_HIGH, STANCE_MID, STANCE_LOW][Math.floor(Math.random() * 3)];
          ai.aiTimer = 10 + Math.floor(Math.random() * 8);
        } else {
          // Back off
          ai.vx = -ai.facing * ai.runSpeed;
        }
      } else if (dist < 130) {
        // Approach range
        let r = Math.random();
        if (r < 0.5) {
          ai.vx = ai.facing * ai.runSpeed * 0.7;
        } else if (r < 0.65 && ai.hasSword) {
          ai.throwSword(player);
        } else if (r < 0.8) {
          ai.blocking = true;
          ai.stance = [STANCE_HIGH, STANCE_MID, STANCE_LOW][Math.floor(Math.random() * 3)];
          ai.vx = ai.facing * ai.runSpeed * 0.4;
        } else {
          // Lunge: run in and attack
          ai.vx = ai.facing * ai.runSpeed * 1.3;
          let s = [STANCE_HIGH, STANCE_MID, STANCE_LOW][Math.floor(Math.random() * 3)];
          ai.stance = s;
          ai.attack(s);
        }
      } else {
        // Far away - close distance
        ai.blocking = false;
        ai.vx = ai.facing * ai.runSpeed * 1.1;
        if (Math.random() < 0.08 && ai.onGround) {
          ai.vy = -11;
        }
      }

      // Move toward player if not attacking/blocking
      if (!ai.blocking && !ai.attacking && dist > 55) {
        ai.vx += ai.facing * 0.2;
        ai.vx = Math.max(-ai.runSpeed, Math.min(ai.runSpeed, ai.vx));
      }

      if (ai.blocking) {
        ai.vx *= 0.4;
      }
    }

    // --- Player Input ---
    function updatePlayer(p, opponent) {
      if (p.dead || p.stunTimer > 0) return;

      if (p.advancing) {
        p.vx = p.goalDir * p.runSpeed * 1.2;
        p.advanceTimer--;
        if (p.advanceTimer <= 0) p.advancing = false;
        return;
      }

      // Movement
      let moveX = 0;
      if (keys['ArrowLeft']) moveX -= 1;
      if (keys['ArrowRight']) moveX += 1;

      if (!p.blocking && !p.attacking) {
        p.vx = moveX * p.runSpeed;
        if (moveX !== 0) p.facing = moveX;
      } else if (p.blocking) {
        p.vx = moveX * p.runSpeed * 0.3;
      }

      // Jump
      if ((keys['ArrowUp'] || keyJustPressed['ArrowUp']) && p.onGround && !p.attacking) {
        p.vy = -11;
      }

      // Blocking
      p.blocking = false;
      if (keys['KeyS']) {
        p.blocking = true;
      }

      // Set stance with up/down while blocking
      if (p.blocking) {
        if (keys['ArrowUp']) p.stance = STANCE_HIGH;
        else if (keys['ArrowDown']) p.stance = STANCE_LOW;
        // else keep current stance (defaults mid if not changed)
      }

      // Attacks
      if (keyJustPressed['KeyZ']) {
        p.stance = STANCE_HIGH;
        p.attack(STANCE_HIGH);
      }
      if (keyJustPressed['KeyX']) {
        p.stance = STANCE_MID;
        p.attack(STANCE_MID);
      }
      if (keyJustPressed['KeyC']) {
        p.stance = STANCE_LOW;
        p.attack(STANCE_LOW);
      }

      // Throw
      if (keyJustPressed['KeyD']) {
        p.throwSword(opponent);
      }

      // Pick up dropped sword
      if (!p.hasSword) {
        for (let i = droppedSwords.length - 1; i >= 0; i--) {
          if (Math.abs(droppedSwords[i].x - p.x) < 30) {
            p.hasSword = true;
            droppedSwords.splice(i, 1);
            break;
          }
        }
      }
    }

    function checkWinCondition() {
      if (p1.x >= WORLD_RIGHT - 50 && !p1.dead) {
        winner = 'P1';
        return true;
      }
      if (p2.x <= WORLD_LEFT + 50 && !p2.dead) {
        winner = 'AI';
        return true;
      }
      return false;
    }

    // ===== RENDERING =====

    function drawBackground(camX) {
      ctx.fillStyle = '#0a0a1e';
      ctx.fillRect(0, 0, W, H);

      // Far background - subtle vertical lines
      ctx.strokeStyle = 'rgba(252, 204, 0, 0.03)';
      ctx.lineWidth = 1;
      for (let px = WORLD_LEFT; px < WORLD_RIGHT; px += 80) {
        let sx = px - camX * 0.3 + W / 2;
        if (sx > -5 && sx < W + 5) {
          ctx.beginPath();
          ctx.moveTo(sx, 0);
          ctx.lineTo(sx, GROUND + 20);
          ctx.stroke();
        }
      }

      // Ground fill
      ctx.fillStyle = '#151530';
      ctx.fillRect(0, GROUND + 18, W, H - GROUND);

      // Ground surface
      let grad = ctx.createLinearGradient(0, GROUND + 12, 0, GROUND + 22);
      grad.addColorStop(0, 'rgba(252,204,0,0.3)');
      grad.addColorStop(1, 'rgba(252,204,0,0.0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, GROUND + 12, W, 10);

      ctx.strokeStyle = '#fc0';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(0, GROUND + 16);
      ctx.lineTo(W, GROUND + 16);
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Screen dividers
      for (let s = -4; s <= 4; s++) {
        let sx = s * SCREEN_W - camX + W / 2;
        if (sx > -10 && sx < W + 10) {
          ctx.strokeStyle = 'rgba(252, 204, 0, 0.1)';
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 10]);
          ctx.beginPath();
          ctx.moveTo(sx, 30);
          ctx.lineTo(sx, GROUND + 16);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // Pillars for decoration
      for (let px = WORLD_LEFT + 100; px < WORLD_RIGHT; px += 300) {
        let sx = px - camX + W / 2;
        if (sx > -20 && sx < W + 20) {
          ctx.fillStyle = 'rgba(252, 204, 0, 0.04)';
          ctx.fillRect(sx - 4, GROUND - 40, 8, 56);
          ctx.fillRect(sx - 10, GROUND - 42, 20, 4);
          ctx.fillRect(sx - 8, GROUND + 14, 16, 4);
        }
      }

      // Win zones
      let leftZX = WORLD_LEFT - camX + W / 2;
      let rightZX = WORLD_RIGHT - 50 - camX + W / 2;

      // AI win zone (left)
      if (leftZX > -80 && leftZX < W + 80) {
        ctx.fillStyle = 'rgba(255, 85, 85, 0.12)';
        ctx.fillRect(leftZX, 0, 60, GROUND + 16);
        ctx.strokeStyle = '#f55';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4;
        ctx.strokeRect(leftZX, 0, 60, GROUND + 16);
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#f55';
        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('AI GOAL', leftZX + 30, 20);
      }

      // P1 win zone (right)
      if (rightZX > -80 && rightZX < W + 80) {
        ctx.fillStyle = 'rgba(252, 204, 0, 0.12)';
        ctx.fillRect(rightZX, 0, 50, GROUND + 16);
        ctx.strokeStyle = '#fc0';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4;
        ctx.strokeRect(rightZX, 0, 50, GROUND + 16);
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#fc0';
        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('P1 GOAL', rightZX + 25, 20);
      }

      // Direction arrows
      ctx.font = 'bold 13px Courier New';
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#fc0';
      ctx.textAlign = 'left';
      ctx.fillText('P1 \u2192', 8, 15);
      ctx.fillStyle = '#f55';
      ctx.textAlign = 'right';
      ctx.fillText('\u2190 AI', W - 8, 15);
      ctx.globalAlpha = 1;
    }

    function drawDroppedSwords(camX) {
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 2;
      for (let s of droppedSwords) {
        let sx = s.x - camX + W / 2;
        if (sx > -20 && sx < W + 20) {
          ctx.beginPath();
          ctx.moveTo(sx - 10, s.y + 12);
          ctx.lineTo(sx + 10, s.y + 12);
          ctx.stroke();
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(sx - 1, s.y + 9);
          ctx.lineTo(sx - 1, s.y + 15);
          ctx.stroke();
          ctx.strokeStyle = '#aaa';
          ctx.lineWidth = 2;
        }
      }
    }

    function drawFighter(f, camX) {
      let sx = f.x - camX + W / 2;
      let sy = f.y;
      if (sx < -60 || sx > W + 60) return;

      ctx.save();

      if (f.dead) {
        ctx.globalAlpha = Math.max(0, 1 - f.deathTimer / 50);
        // Rotate on death
        ctx.translate(sx, sy - 20);
        ctx.rotate(f.deathTimer * 0.1 * (f.vx > 0 ? 1 : -1));
        ctx.translate(-sx, -(sy - 20));
      }

      let dir = f.facing;
      let color = f.color;

      if (f.stunTimer > 0 && Math.floor(f.stunTimer / 2) % 2 === 0) color = '#fff';
      if (f.blocking) color = f.isAI ? '#c44' : '#da0';

      ctx.strokeStyle = color;
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';

      let headY = sy - 38;
      let neckY = sy - 32;
      let hipY = sy - 8;
      let armY = sy - 24;

      // Head
      ctx.beginPath();
      ctx.arc(sx, headY, 5, 0, Math.PI * 2);
      ctx.stroke();

      // Torso
      ctx.beginPath();
      ctx.moveTo(sx, neckY);
      ctx.lineTo(sx, hipY);
      ctx.stroke();

      // Legs - animated
      let legA = 0;
      if (Math.abs(f.vx) > 0.8 && f.onGround && !f.dead) {
        legA = Math.sin(Date.now() / 80) * 8;
      }
      ctx.beginPath();
      ctx.moveTo(sx, hipY);
      ctx.lineTo(sx + legA, sy + 14);
      ctx.moveTo(sx, hipY);
      ctx.lineTo(sx - legA, sy + 14);
      ctx.stroke();

      // Arms and weapon
      let weaponStance = f.attacking ? f.attackStance : f.stance;
      let swordTipY;
      if (weaponStance === STANCE_HIGH) swordTipY = armY - 16;
      else if (weaponStance === STANCE_MID) swordTipY = armY - 2;
      else swordTipY = armY + 10;

      // Back arm
      ctx.beginPath();
      ctx.moveTo(sx, armY);
      ctx.lineTo(sx - dir * 7, armY + 6);
      ctx.stroke();

      // Front arm + weapon
      let ext = 10;
      if (f.attacking && f.attackTimer >= 4 && f.attackTimer <= 8) {
        ext = 26; // Full lunge
      } else if (f.attacking) {
        ext = 16; // Wind-up / recovery
      }
      if (f.blocking) ext = 8;

      // Arm
      ctx.beginPath();
      ctx.moveTo(sx, armY);
      ctx.lineTo(sx + dir * ext, swordTipY);
      ctx.stroke();

      // Weapon
      if (f.hasSword) {
        let sLen = 28;
        let isActive = f.attacking && f.attackTimer >= 4 && f.attackTimer <= 8;
        ctx.strokeStyle = isActive ? '#fff' : color;
        ctx.lineWidth = isActive ? 3.5 : 2;

        if (isActive) {
          ctx.shadowColor = color;
          ctx.shadowBlur = 12;
        }

        ctx.beginPath();
        ctx.moveTo(sx + dir * ext, swordTipY);
        ctx.lineTo(sx + dir * (ext + sLen), swordTipY);
        ctx.stroke();

        ctx.shadowBlur = 0;

        // Guard
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(sx + dir * ext, swordTipY - 4);
        ctx.lineTo(sx + dir * ext, swordTipY + 4);
        ctx.stroke();
      } else {
        // Fist
        let isActive = f.attacking && f.attackTimer >= 4 && f.attackTimer <= 8;
        if (isActive) {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = color;
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(sx + dir * (ext + 6), swordTipY, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(sx + dir * (ext + 4), swordTipY, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Block shield visual
      if (f.blocking) {
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(sx + dir * 10, swordTipY - 14);
        ctx.lineTo(sx + dir * 10, swordTipY + 14);
        ctx.stroke();
        ctx.setLineDash([]);

        // Stance label
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        let sName = ['H', 'M', 'L'][f.stance];
        ctx.fillText(sName, sx + dir * 10, swordTipY - 17);
      }

      // Label
      ctx.fillStyle = color;
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.fillText(f.isAI ? 'AI' : 'P1', sx, headY - 10);
      ctx.shadowBlur = 0;

      // Disarmed indicator
      if (!f.hasSword && !f.dead) {
        ctx.fillStyle = '#888';
        ctx.font = '7px Courier New';
        ctx.fillText('UNARMED', sx, sy + 26);
      }

      ctx.restore();
    }

    function drawThrownSword(sword, camX, color) {
      if (!sword || !sword.active) return;
      let sx = sword.x - camX + W / 2;
      let sy = sword.y;
      if (sx < -30 || sx > W + 30) return;

      let dir = sword.vx > 0 ? 1 : -1;
      let rot = Date.now() / 60;

      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(rot * dir);
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(-14, 0);
      ctx.lineTo(14, 0);
      ctx.stroke();
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-2, -3);
      ctx.lineTo(-2, 3);
      ctx.stroke();
      ctx.restore();
    }

    function drawParticles(camX) {
      for (let p of particles) {
        let sx = p.x - camX + W / 2;
        if (sx < -10 || sx > W + 10) continue;
        ctx.globalAlpha = Math.min(1, p.life / 25);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(sx, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawProgressBar() {
      let barY = H - 18;
      let barW = W - 60;
      let barH = 6;
      let barX = 30;

      // Background
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(barX, barY, barW, barH);

      // Center tick
      ctx.fillStyle = '#555';
      ctx.fillRect(barX + barW / 2 - 1, barY - 3, 2, barH + 6);

      // Goal zones
      ctx.fillStyle = 'rgba(252,204,0,0.2)';
      ctx.fillRect(barX + barW - 10, barY, 10, barH);
      ctx.fillStyle = 'rgba(255,85,85,0.2)';
      ctx.fillRect(barX, barY, 10, barH);

      // Fighter positions
      let norm1 = (p1.x - WORLD_LEFT) / (WORLD_RIGHT - WORLD_LEFT);
      norm1 = Math.max(0, Math.min(1, norm1));
      ctx.fillStyle = '#fc0';
      ctx.shadowColor = '#fc0';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.arc(barX + norm1 * barW, barY + barH / 2, 4, 0, Math.PI * 2);
      ctx.fill();

      let norm2 = (p2.x - WORLD_LEFT) / (WORLD_RIGHT - WORLD_LEFT);
      norm2 = Math.max(0, Math.min(1, norm2));
      ctx.fillStyle = '#f55';
      ctx.shadowColor = '#f55';
      ctx.beginPath();
      ctx.arc(barX + norm2 * barW, barY + barH / 2, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Labels
      ctx.font = '7px Courier New';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#fc0';
      ctx.fillText('P1\u2192', barX, barY - 4);
      ctx.textAlign = 'right';
      ctx.fillStyle = '#f55';
      ctx.fillText('\u2190AI', barX + barW, barY - 4);
    }

    function drawEnGarde() {
      if (enGardeTimer > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, enGardeTimer / 30);
        ctx.fillStyle = '#fc0';
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fc0';
        ctx.shadowBlur = 25;
        ctx.fillText('EN GARDE!', W / 2, H / 2 - 30);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawKillFlash() {
      if (flashTimer > 0) {
        ctx.save();
        ctx.globalAlpha = flashTimer / 15 * 0.3;
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    }

    // ===== MAIN LOOP =====
    function update() {
      if (gameState !== 'playing') return;

      roundTimer++;
      if (enGardeTimer > 0) enGardeTimer--;
      if (flashTimer > 0) flashTimer--;

      // During en garde, fighters don't move
      if (enGardeTimer > 20) {
        for (let k in keyJustPressed) keyJustPressed[k] = false;
        return;
      }

      // Player input
      updatePlayer(p1, p2);

      // AI
      if (!p2.advancing) {
        updateAI(p2, p1);
      }

      // Advancing
      if (p1.advancing) {
        p1.vx = p1.goalDir * p1.runSpeed * 1.3;
        p1.advanceTimer--;
        if (p1.advanceTimer <= 0) p1.advancing = false;
      }
      if (p2.advancing) {
        p2.vx = p2.goalDir * p2.runSpeed * 1.3;
        p2.advanceTimer--;
        if (p2.advanceTimer <= 0) p2.advancing = false;
      }

      p1.update();
      p2.update();

      // Combat
      if (!p1.dead && !p2.dead) {
        if (checkHit(p1, p2)) killFighter(p2, p1);
        if (checkHit(p2, p1)) killFighter(p1, p2);

        if (checkThrownSwordHit(p1.thrownSword, p2)) {
          p1.thrownSword.active = false;
          killFighter(p2, p1);
        }
        if (checkThrownSwordHit(p2.thrownSword, p1)) {
          p2.thrownSword.active = false;
          killFighter(p1, p2);
        }

        // Push apart
        let dx = p2.x - p1.x;
        let dist = Math.abs(dx);
        if (dist < 18) {
          let push = (18 - dist) / 2;
          let d = dx > 0 ? 1 : -1;
          p1.x -= d * push;
          p2.x += d * push;
        }
      }

      // AI picks up dropped swords
      if (!p2.dead && !p2.hasSword) {
        for (let i = droppedSwords.length - 1; i >= 0; i--) {
          if (Math.abs(droppedSwords[i].x - p2.x) < 30) {
            p2.hasSword = true;
            droppedSwords.splice(i, 1);
            break;
          }
        }
      }

      // Respawn
      if ((p1.dead || p2.dead) && respawnTimer > 0) {
        respawnTimer--;
        if (respawnTimer <= 0) respawn();
      }

      // Camera
      let targetCamX;
      if (p1.dead) targetCamX = p2.x;
      else if (p2.dead) targetCamX = p1.x;
      else targetCamX = (p1.x + p2.x) / 2;
      cameraX += (targetCamX - cameraX) * 0.06;

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.vx *= 0.98;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Win check
      if (checkWinCondition()) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = winner === 'P1' ? 'VICTORY!' : 'DEFEAT!';
        overlayText.textContent = 'P1: ' + kills1 + ' kills | AI: ' + kills2 + ' kills \u2014 Click to play again';
      }

      for (let k in keyJustPressed) keyJustPressed[k] = false;
      updateUI();
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      drawBackground(cameraX);
      drawDroppedSwords(cameraX);

      drawFighter(p1, cameraX);
      drawFighter(p2, cameraX);

      drawThrownSword(p1.thrownSword, cameraX, '#fc0');
      drawThrownSword(p2.thrownSword, cameraX, '#f55');

      drawParticles(cameraX);
      drawProgressBar();
      drawEnGarde();
      drawKillFlash();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') startMatch();
    });
    document.addEventListener('click', () => {
      if (gameState === 'waiting') startMatch();
    });

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #88f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 136, 255, 0.5); }
    h1 { color: #88f; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 136, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #88f; }
    canvas {
      border: 2px solid #88f;
      box-shadow: 0 0 20px rgba(136, 136, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #88f;
      text-align: center;
      pointer-events: none;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PONG</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="playerScore">0</span></div>
    <div id="matchPoint" style="color:#f44;display:none;">MATCH POINT</div>
    <div>CPU: <span id="cpuScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:400px;">
      <h2 id="overlayTitle">PONG</h2>
      <p id="overlayText">Press UP/DOWN or SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerScoreEl = document.getElementById('playerScore');
    const cpuScoreEl = document.getElementById('cpuScore');
    const matchPointEl = document.getElementById('matchPoint');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const W = canvas.width;
    const H = canvas.height;

    const PADDLE_W = 10;
    const PADDLE_H = 60;
    const PADDLE_MARGIN = 20;
    const PADDLE_SPEED = 5;
    const BALL_SIZE = 8;
    const BASE_BALL_SPEED = 4;
    const WIN_SCORE = 11;
    const AI_SPEED = 3.5;
    const AI_REACTION = 0.08;

    let playerY, cpuY, ballX, ballY, ballVX, ballVY;
    let playerScore, cpuScore, gameState, rallyCount;
    let keys = {};
    let aiTarget;

    function init() {
      playerY = H / 2 - PADDLE_H / 2;
      cpuY = H / 2 - PADDLE_H / 2;
      playerScore = 0;
      cpuScore = 0;
      rallyCount = 0;
      playerScoreEl.textContent = '0';
      cpuScoreEl.textContent = '0';
      matchPointEl.style.display = 'none';
      resetBall(1);
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PONG';
      overlayText.textContent = 'Press UP/DOWN or SPACE to start';
      draw();
    }

    function resetBall(dir) {
      ballX = W / 2;
      ballY = H / 2;
      const angle = (Math.random() - 0.5) * Math.PI / 3;
      const speed = BASE_BALL_SPEED;
      ballVX = Math.cos(angle) * speed * dir;
      ballVY = Math.sin(angle) * speed;
      rallyCount = 0;
      aiTarget = H / 2;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Player movement
      if (keys['ArrowUp']) playerY -= PADDLE_SPEED;
      if (keys['ArrowDown']) playerY += PADDLE_SPEED;
      playerY = Math.max(0, Math.min(H - PADDLE_H, playerY));

      // AI movement
      if (ballVX > 0) {
        // Ball heading toward AI - predict where it will arrive
        const timeToReach = (W - PADDLE_MARGIN - PADDLE_W - ballX) / ballVX;
        aiTarget = ballY + ballVY * timeToReach;
        // Wrap prediction within bounds
        while (aiTarget < 0 || aiTarget > H) {
          if (aiTarget < 0) aiTarget = -aiTarget;
          if (aiTarget > H) aiTarget = 2 * H - aiTarget;
        }
      } else {
        aiTarget = H / 2;
      }

      const cpuCenter = cpuY + PADDLE_H / 2;
      const diff = aiTarget - cpuCenter;
      const aiMoveSpeed = AI_SPEED + Math.min(rallyCount * 0.1, 2);
      if (Math.abs(diff) > 4) {
        cpuY += Math.sign(diff) * Math.min(aiMoveSpeed, Math.abs(diff) * AI_REACTION + 2);
      }
      cpuY = Math.max(0, Math.min(H - PADDLE_H, cpuY));

      // Ball movement
      ballX += ballVX;
      ballY += ballVY;

      // Top/bottom bounce
      if (ballY - BALL_SIZE / 2 <= 0) { ballY = BALL_SIZE / 2; ballVY = Math.abs(ballVY); }
      if (ballY + BALL_SIZE / 2 >= H) { ballY = H - BALL_SIZE / 2; ballVY = -Math.abs(ballVY); }

      // Player paddle collision (left)
      const pPaddleX = PADDLE_MARGIN;
      if (ballVX < 0 &&
          ballX - BALL_SIZE / 2 <= pPaddleX + PADDLE_W &&
          ballX - BALL_SIZE / 2 >= pPaddleX &&
          ballY >= playerY && ballY <= playerY + PADDLE_H) {
        ballX = pPaddleX + PADDLE_W + BALL_SIZE / 2;
        const hit = (ballY - playerY) / PADDLE_H;
        const angle = (hit - 0.5) * Math.PI / 3;
        const speed = Math.sqrt(ballVX * ballVX + ballVY * ballVY) + 0.15;
        ballVX = Math.cos(angle) * speed;
        ballVY = Math.sin(angle) * speed;
        rallyCount++;
      }

      // CPU paddle collision (right)
      const cPaddleX = W - PADDLE_MARGIN - PADDLE_W;
      if (ballVX > 0 &&
          ballX + BALL_SIZE / 2 >= cPaddleX &&
          ballX + BALL_SIZE / 2 <= cPaddleX + PADDLE_W &&
          ballY >= cpuY && ballY <= cpuY + PADDLE_H) {
        ballX = cPaddleX - BALL_SIZE / 2;
        const hit = (ballY - cpuY) / PADDLE_H;
        const angle = Math.PI - (hit - 0.5) * Math.PI / 3;
        const speed = Math.sqrt(ballVX * ballVX + ballVY * ballVY) + 0.15;
        ballVX = Math.cos(angle) * speed;
        ballVY = Math.sin(angle) * speed;
        rallyCount++;
      }

      // Scoring
      if (ballX < 0) {
        cpuScore++;
        cpuScoreEl.textContent = cpuScore;
        checkWin(-1);
      }
      if (ballX > W) {
        playerScore++;
        playerScoreEl.textContent = playerScore;
        checkWin(1);
      }

      // Match point indicator
      if (playerScore >= WIN_SCORE - 1 || cpuScore >= WIN_SCORE - 1) {
        matchPointEl.style.display = 'block';
      } else {
        matchPointEl.style.display = 'none';
      }
    }

    function checkWin(lastScorer) {
      if (playerScore >= WIN_SCORE) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = `${playerScore} - ${cpuScore} -- Press SPACE to play again`;
        return;
      }
      if (cpuScore >= WIN_SCORE) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'CPU WINS';
        overlayText.textContent = `${playerScore} - ${cpuScore} -- Press SPACE to play again`;
        return;
      }
      resetBall(-lastScorer);
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Center dashed line
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(W / 2, 0);
      ctx.lineTo(W / 2, H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Big score display
      ctx.fillStyle = '#16213e';
      ctx.font = '80px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(playerScore, W / 4, 90);
      ctx.fillText(cpuScore, 3 * W / 4, 90);

      // Player paddle
      ctx.fillStyle = '#88f';
      ctx.shadowColor = '#88f';
      ctx.shadowBlur = 12;
      ctx.fillRect(PADDLE_MARGIN, playerY, PADDLE_W, PADDLE_H);
      ctx.shadowBlur = 0;

      // CPU paddle
      ctx.fillStyle = '#88f';
      ctx.shadowColor = '#88f';
      ctx.shadowBlur = 12;
      ctx.fillRect(W - PADDLE_MARGIN - PADDLE_W, cpuY, PADDLE_W, PADDLE_H);
      ctx.shadowBlur = 0;

      // Ball
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#88f';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(ballX, ballY, BALL_SIZE, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', ' '].includes(e.key)) e.preventDefault();
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over' && e.key === ' ') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
</body>
</html>

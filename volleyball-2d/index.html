<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Volleyball 2D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 255, 0.5); }
    h1 { color: #4af; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4af; }
    canvas {
      border: 2px solid #4af;
      box-shadow: 0 0 20px rgba(68, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>VOLLEYBALL 2D</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="matchInfo" style="color:#aaa;">First to 15</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">VOLLEYBALL 2D</h2>
      <p id="overlayText">Press any key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const matchInfo = document.getElementById('matchInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Theme
    const THEME = '#4af';
    const THEME_RGB = '68, 170, 255';

    // Physics constants
    const GRAVITY = 0.4;
    const GROUND_Y = 360;         // where the court floor is
    const NET_X = 300;
    const NET_TOP = 220;
    const NET_WIDTH = 6;
    const NET_BOTTOM = GROUND_Y;
    const BALL_R = 12;
    const SLIME_W = 50;           // half-width of slime base
    const SLIME_H = 40;           // height of slime dome
    const BALL_FRICTION = 0.999;
    const BALL_BOUNCE = 0.75;
    const WALL_BOUNCE = 0.6;
    const MAX_BALL_SPEED = 12;
    const WIN_SCORE = 15;
    const MAX_BOUNCES = 3;

    // Trail
    const TRAIL_LEN = 12;

    let gameState; // 'waiting', 'playing', 'serving', 'scored', 'over'
    let score = 0;

    // Players
    let p1, p2, ball;
    let p1Score = 0, p2Score = 0;
    let serveSide = 1; // 1 = player serves, 2 = AI serves
    let bouncesLeft = 0; // bounces on the side the ball is on
    let bouncesRight = 0;
    let scoreTimer = 0;
    let ballTrail = [];
    let particles = [];
    let lastScoredSide = 0;

    // Input
    const keys = {};

    function createPlayer(x, side) {
      return {
        x: x,
        y: GROUND_Y,
        vx: 0,
        vy: 0,
        side: side,       // 1 = left, 2 = right
        onGround: true,
        color: side === 1 ? '#4af' : '#f64',
        spiking: false,
        spikeTimer: 0
      };
    }

    function createBall(x, y) {
      return {
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        lastHitBy: 0
      };
    }

    function init() {
      gameState = 'waiting';
      p1Score = 0;
      p2Score = 0;
      serveSide = 1;
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      matchInfo.textContent = 'First to 15';
      matchInfo.style.color = '#aaa';
      resetRound();
      showOverlay('VOLLEYBALL 2D', 'Press any key to start');
    }

    function resetRound() {
      p1 = createPlayer(150, 1);
      p2 = createPlayer(450, 2);
      bouncesLeft = 0;
      bouncesRight = 0;
      ballTrail = [];
      particles = [];

      if (serveSide === 1) {
        ball = createBall(150, 200);
      } else {
        ball = createBall(450, 200);
      }
      ball.vx = 0;
      ball.vy = 0;
      ball.lastHitBy = 0;
    }

    function showOverlay(title, text) {
      overlay.style.display = 'flex';
      overlayTitle.textContent = title;
      overlayText.textContent = text;
    }

    function hideOverlay() {
      overlay.style.display = 'none';
    }

    function startGame() {
      gameState = 'serving';
      hideOverlay();
      resetRound();
    }

    function serve() {
      gameState = 'playing';
      if (serveSide === 1) {
        ball.vy = -7;
        ball.vx = 1.5;
      } else {
        ball.vy = -7;
        ball.vx = -1.5;
      }
      ball.lastHitBy = serveSide;
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
        e.preventDefault();
        return;
      }
      if (gameState === 'serving') {
        serve();
        e.preventDefault();
        return;
      }
      e.preventDefault();
    });

    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // Click/tap to start
    canvas.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
      } else if (gameState === 'serving') {
        serve();
      }
    });

    // --- Player movement ---
    function updatePlayer(player) {
      // Apply gravity
      if (!player.onGround) {
        player.vy += GRAVITY;
      }

      // Move
      player.x += player.vx;
      player.y += player.vy;

      // Ground collision
      if (player.y >= GROUND_Y) {
        player.y = GROUND_Y;
        player.vy = 0;
        player.onGround = true;
      }

      // Wall constraints
      if (player.side === 1) {
        if (player.x - SLIME_W < 0) player.x = SLIME_W;
        if (player.x + SLIME_W > NET_X - NET_WIDTH / 2) player.x = NET_X - NET_WIDTH / 2 - SLIME_W;
      } else {
        if (player.x - SLIME_W < NET_X + NET_WIDTH / 2) player.x = NET_X + NET_WIDTH / 2 + SLIME_W;
        if (player.x + SLIME_W > W) player.x = W - SLIME_W;
      }

      // Friction
      if (player.onGround) {
        player.vx *= 0.8;
      }

      // Spike timer
      if (player.spikeTimer > 0) player.spikeTimer--;
      if (player.spikeTimer === 0) player.spiking = false;
    }

    function handlePlayerInput() {
      const MOVE_SPEED = 4;
      const JUMP_SPEED = -9.5;

      // Left/Right
      if (keys['ArrowLeft']) {
        p1.vx = -MOVE_SPEED;
      } else if (keys['ArrowRight']) {
        p1.vx = MOVE_SPEED;
      } else if (p1.onGround) {
        // friction handles decel
      }

      // Jump
      if (keys['ArrowUp'] && p1.onGround) {
        p1.vy = JUMP_SPEED;
        p1.onGround = false;
      }

      // Spike
      if (keys['Space'] && !p1.spiking) {
        p1.spiking = true;
        p1.spikeTimer = 12;
      }
    }

    // --- AI ---
    function predictBallLanding(bx, by, bvx, bvy) {
      // Simulate ball forward to find where it lands
      let sx = bx, sy = by, svx = bvx, svy = bvy;
      for (let i = 0; i < 200; i++) {
        svy += GRAVITY;
        sx += svx;
        sy += svy;
        // Net bounce (simplified)
        if (sx > NET_X - NET_WIDTH / 2 - BALL_R && sx < NET_X + NET_WIDTH / 2 + BALL_R && sy > NET_TOP) {
          svx = -svx * 0.7;
          sx = sx < NET_X ? NET_X - NET_WIDTH / 2 - BALL_R - 1 : NET_X + NET_WIDTH / 2 + BALL_R + 1;
        }
        // Wall bounce
        if (sx - BALL_R < 0) { sx = BALL_R; svx = Math.abs(svx) * 0.7; }
        if (sx + BALL_R > W) { sx = W - BALL_R; svx = -Math.abs(svx) * 0.7; }
        // Ground
        if (sy + BALL_R >= GROUND_Y) {
          return { x: sx, y: GROUND_Y - BALL_R, time: i };
        }
      }
      return { x: sx, y: sy, time: 200 };
    }

    function updateAI() {
      const MOVE_SPEED = 3.8;
      const JUMP_SPEED = -9.5;

      let prediction = predictBallLanding(ball.x, ball.y, ball.vx, ball.vy);
      let targetX = prediction.x;

      // Is ball heading toward AI side?
      let ballComingToAI = ball.vx > 0 || ball.x > NET_X;
      let ballOnAISide = ball.x > NET_X;

      if (!ballComingToAI && !ballOnAISide) {
        // Return to default position
        targetX = 450;
      } else {
        // Position under where ball will be, slightly offset for hitting it over
        if (targetX < NET_X + NET_WIDTH / 2 + SLIME_W) {
          targetX = NET_X + NET_WIDTH / 2 + SLIME_W + 20;
        }
      }

      // Move toward target
      let dx = targetX - p2.x;
      if (Math.abs(dx) > 5) {
        p2.vx = dx > 0 ? MOVE_SPEED : -MOVE_SPEED;
      } else {
        p2.vx = 0;
      }

      // Jump decision
      let ballNear = Math.abs(ball.x - p2.x) < 80;
      let ballAbove = ball.y < p2.y - 20;
      let ballDescending = ball.vy > 0;
      let ballOnRightSide = ball.x > NET_X;

      // Jump to intercept
      if (p2.onGround && ballOnRightSide) {
        // Jump when ball is coming down and close
        if (ballNear && ballAbove && ball.y < NET_TOP + 60 && ball.y > NET_TOP - 80) {
          p2.vy = JUMP_SPEED;
          p2.onGround = false;
        }
        // Jump for low balls
        if (ballNear && ball.y > GROUND_Y - 100 && ball.y < GROUND_Y - 30 && ballDescending) {
          p2.vy = JUMP_SPEED;
          p2.onGround = false;
        }
        // Emergency jump - ball very close and about to land
        if (Math.abs(ball.x - p2.x) < 50 && ball.y > GROUND_Y - 80 && ballDescending) {
          p2.vy = JUMP_SPEED;
          p2.onGround = false;
        }
      }

      // Spike when at top of jump and ball is close
      if (!p2.onGround && Math.abs(ball.x - p2.x) < 60 && Math.abs(ball.y - (p2.y - SLIME_H)) < 50) {
        if (!p2.spiking && p2.vy < 2) {
          p2.spiking = true;
          p2.spikeTimer = 12;
        }
      }
    }

    // --- Ball physics ---
    function distCircleSlime(bx, by, px, py) {
      // Slime is a half-circle dome on top of a flat base
      // Center of the dome arc is at (px, py) with radius SLIME_W
      // Only the top half is the dome
      let cx = px;
      let cy = py; // dome center at player base
      let dx = bx - cx;
      let dy = by - cy;

      // Only consider dome (top half)
      if (dy > 0) {
        // Below center - check against flat top edge, but slimes sit on ground
        // Actually just return large distance
        return { dist: 999, nx: 0, ny: -1 };
      }

      let dist = Math.sqrt(dx * dx + dy * dy);
      let nx = dist > 0 ? dx / dist : 0;
      let ny = dist > 0 ? dy / dist : -1;

      return { dist, nx, ny };
    }

    function spawnHitParticles(x, y, color) {
      for (let i = 0; i < 6; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          life: 20 + Math.random() * 15,
          color: color
        });
      }
    }

    function spawnScoreParticles(x, y) {
      for (let i = 0; i < 20; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = 2 + Math.random() * 5;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 3,
          life: 30 + Math.random() * 20,
          color: Math.random() > 0.5 ? '#4af' : '#fff'
        });
      }
    }

    function clampBallSpeed() {
      let speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      if (speed > MAX_BALL_SPEED) {
        ball.vx = (ball.vx / speed) * MAX_BALL_SPEED;
        ball.vy = (ball.vy / speed) * MAX_BALL_SPEED;
      }
    }

    function ballSlimeCollision(player) {
      let cx = player.x;
      let cy = player.y;
      let domeR = SLIME_W;

      let dx = ball.x - cx;
      let dy = ball.y - cy;

      // Only dome top
      if (dy > 5) return false;

      let dist = Math.sqrt(dx * dx + dy * dy);
      let minDist = domeR + BALL_R;

      if (dist < minDist && dist > 0) {
        // Normal from slime center to ball
        let nx = dx / dist;
        let ny = dy / dist;

        // Push ball out
        ball.x = cx + nx * minDist;
        ball.y = cy + ny * minDist;

        // Reflect velocity
        let relVx = ball.vx - player.vx;
        let relVy = ball.vy - player.vy;
        let dot = relVx * nx + relVy * ny;

        if (dot < 0) { // Only if moving toward slime
          ball.vx = ball.vx - 2 * dot * nx + player.vx * 0.3;
          ball.vy = ball.vy - 2 * dot * ny + player.vy * 0.3;

          // Extra upward boost
          if (ball.vy > -3) ball.vy -= 2;

          // Spike power - extra velocity toward opponent
          if (player.spiking) {
            let spikeDir = player.side === 1 ? 1 : -1;
            ball.vx += spikeDir * 4;
            ball.vy -= 1;
            spawnHitParticles(ball.x, ball.y, '#ff0');
          } else {
            spawnHitParticles(ball.x, ball.y, player.color);
          }

          ball.lastHitBy = player.side;

          // Reset bounces on the other side
          if (player.side === 1) bouncesLeft = 0;
          else bouncesRight = 0;
        }

        clampBallSpeed();
        return true;
      }
      return false;
    }

    function updateBall() {
      // Gravity
      ball.vy += GRAVITY;

      // Move
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Trail
      ballTrail.push({ x: ball.x, y: ball.y });
      if (ballTrail.length > TRAIL_LEN) ballTrail.shift();

      // Wall bounces
      if (ball.x - BALL_R < 0) {
        ball.x = BALL_R;
        ball.vx = Math.abs(ball.vx) * WALL_BOUNCE;
      }
      if (ball.x + BALL_R > W) {
        ball.x = W - BALL_R;
        ball.vx = -Math.abs(ball.vx) * WALL_BOUNCE;
      }

      // Ceiling
      if (ball.y - BALL_R < 0) {
        ball.y = BALL_R;
        ball.vy = Math.abs(ball.vy) * WALL_BOUNCE;
      }

      // Net collision
      let netLeft = NET_X - NET_WIDTH / 2;
      let netRight = NET_X + NET_WIDTH / 2;

      // Top of net
      if (ball.y + BALL_R > NET_TOP && ball.y - BALL_R < NET_TOP + 10 &&
          ball.x + BALL_R > netLeft && ball.x - BALL_R < netRight) {
        if (ball.vy > 0) {
          ball.y = NET_TOP - BALL_R;
          ball.vy = -ball.vy * 0.6;
        }
      }

      // Side of net
      if (ball.y + BALL_R > NET_TOP && ball.y < NET_BOTTOM) {
        if (ball.x + BALL_R > netLeft && ball.x < NET_X && ball.vx > 0) {
          ball.x = netLeft - BALL_R;
          ball.vx = -Math.abs(ball.vx) * WALL_BOUNCE;
        }
        if (ball.x - BALL_R < netRight && ball.x > NET_X && ball.vx < 0) {
          ball.x = netRight + BALL_R;
          ball.vx = Math.abs(ball.vx) * WALL_BOUNCE;
        }
      }

      // Slime collisions
      ballSlimeCollision(p1);
      ballSlimeCollision(p2);

      // Ground collision - scoring
      if (ball.y + BALL_R >= GROUND_Y) {
        ball.y = GROUND_Y - BALL_R;

        if (ball.x < NET_X) {
          // Ball hit ground on left (player) side
          bouncesLeft++;
          if (bouncesLeft > MAX_BOUNCES) {
            // AI scores
            scorePoint(2);
            return;
          }
          ball.vy = -ball.vy * BALL_BOUNCE;
          ball.vx *= 0.9;
          if (Math.abs(ball.vy) < 2) {
            // Ball barely bouncing - point for AI
            scorePoint(2);
            return;
          }
        } else {
          // Ball hit ground on right (AI) side
          bouncesRight++;
          if (bouncesRight > MAX_BOUNCES) {
            // Player scores
            scorePoint(1);
            return;
          }
          ball.vy = -ball.vy * BALL_BOUNCE;
          ball.vx *= 0.9;
          if (Math.abs(ball.vy) < 2) {
            // Ball barely bouncing - point for player
            scorePoint(1);
            return;
          }
        }
      }

      // Air friction
      ball.vx *= BALL_FRICTION;

      clampBallSpeed();
    }

    function scorePoint(side) {
      if (side === 1) {
        p1Score++;
        score = p1Score;
        scoreEl.textContent = p1Score;
        serveSide = 1;
        lastScoredSide = 1;
      } else {
        p2Score++;
        bestEl.textContent = p2Score;
        serveSide = 2;
        lastScoredSide = 2;
      }

      spawnScoreParticles(ball.x, ball.y);

      if (p1Score >= WIN_SCORE) {
        gameState = 'over';
        score = p1Score;
        showOverlay('YOU WIN!', p1Score + ' - ' + p2Score + ' | Press any key to play again');
        return;
      }
      if (p2Score >= WIN_SCORE) {
        gameState = 'over';
        score = p1Score;
        showOverlay('CPU WINS', p1Score + ' - ' + p2Score + ' | Press any key to play again');
        return;
      }

      // Match point indicator
      if (p1Score === WIN_SCORE - 1 || p2Score === WIN_SCORE - 1) {
        matchInfo.textContent = 'MATCH POINT';
        matchInfo.style.color = '#f44';
      } else {
        matchInfo.textContent = 'First to 15';
        matchInfo.style.color = '#aaa';
      }

      gameState = 'scored';
      scoreTimer = 60;
    }

    // --- Particles ---
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- Drawing ---
    function drawCourt() {
      // Sky gradient
      let skyGrad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      skyGrad.addColorStop(0, '#0a1628');
      skyGrad.addColorStop(1, '#162040');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, GROUND_Y);

      // Ground
      let groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, H);
      groundGrad.addColorStop(0, '#2a4020');
      groundGrad.addColorStop(1, '#1a2a10');
      ctx.fillStyle = groundGrad;
      ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

      // Court lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(W, GROUND_Y);
      ctx.stroke();

      // Center line under net
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(NET_X, GROUND_Y);
      ctx.lineTo(NET_X, H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Boundary lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(10, GROUND_Y + 2);
      ctx.lineTo(10, H);
      ctx.moveTo(W - 10, GROUND_Y + 2);
      ctx.lineTo(W - 10, H);
      ctx.stroke();

      // Net
      ctx.fillStyle = '#fff';
      ctx.fillRect(NET_X - NET_WIDTH / 2, NET_TOP, NET_WIDTH, NET_BOTTOM - NET_TOP);

      // Net pattern
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 0.5;
      for (let y = NET_TOP; y < NET_BOTTOM; y += 10) {
        ctx.beginPath();
        ctx.moveTo(NET_X - NET_WIDTH / 2, y);
        ctx.lineTo(NET_X + NET_WIDTH / 2, y);
        ctx.stroke();
      }

      // Net top cap
      ctx.fillStyle = '#ccc';
      ctx.fillRect(NET_X - NET_WIDTH / 2 - 2, NET_TOP - 3, NET_WIDTH + 4, 6);

      // Net glow
      ctx.shadowBlur = 8;
      ctx.shadowColor = 'rgba(255, 255, 255, 0.2)';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      ctx.fillRect(NET_X - 1, NET_TOP, 2, NET_BOTTOM - NET_TOP);
      ctx.shadowBlur = 0;
    }

    function drawSlime(player) {
      let x = player.x;
      let y = player.y;
      let color = player.color;

      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x, GROUND_Y + 2, SLIME_W * 0.8, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body - half dome
      ctx.beginPath();
      ctx.arc(x, y, SLIME_W, Math.PI, 0, false);
      ctx.closePath();

      // Gradient fill
      let grad = ctx.createRadialGradient(x - 10, y - 20, 5, x, y, SLIME_W);
      grad.addColorStop(0, player.side === 1 ? '#6cf' : '#f96');
      grad.addColorStop(1, color);
      ctx.fillStyle = grad;
      ctx.fill();

      // Outline glow
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Eye
      let eyeX = x + (player.side === 1 ? 12 : -12);
      let eyeY = y - 18;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(eyeX, eyeY, 7, 0, Math.PI * 2);
      ctx.fill();

      // Pupil - track ball
      let pbx = ball.x - eyeX;
      let pby = ball.y - eyeY;
      let pd = Math.sqrt(pbx * pbx + pby * pby);
      if (pd > 0) { pbx /= pd; pby /= pd; }
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(eyeX + pbx * 3, eyeY + pby * 3, 3.5, 0, Math.PI * 2);
      ctx.fill();

      // Spike indicator
      if (player.spiking) {
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0';
        ctx.beginPath();
        ctx.arc(x, y - SLIME_W - 8, 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Label
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(player.side === 1 ? 'YOU' : 'CPU', x, y + 14);
    }

    function drawBall() {
      // Trail
      for (let i = 0; i < ballTrail.length; i++) {
        let t = ballTrail[i];
        let alpha = (i / ballTrail.length) * 0.4;
        let r = BALL_R * (i / ballTrail.length) * 0.7;
        ctx.fillStyle = `rgba(255, 255, 150, ${alpha})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Ball shadow on ground
      if (ball.y < GROUND_Y - BALL_R) {
        let shadowScale = 1 - (GROUND_Y - ball.y) / 400;
        if (shadowScale < 0.2) shadowScale = 0.2;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(ball.x, GROUND_Y + 2, BALL_R * shadowScale, 3, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Ball
      let ballGrad = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 2, ball.x, ball.y, BALL_R);
      ballGrad.addColorStop(0, '#fff');
      ballGrad.addColorStop(1, '#dda');
      ctx.fillStyle = ballGrad;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();

      // Ball seam lines (volleyball look)
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R * 0.7, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(ball.x - BALL_R * 0.5, ball.y - BALL_R * 0.5);
      ctx.lineTo(ball.x + BALL_R * 0.5, ball.y + BALL_R * 0.5);
      ctx.stroke();

      // Glow
      ctx.shadowBlur = 12;
      ctx.shadowColor = 'rgba(255, 255, 200, 0.3)';
      ctx.strokeStyle = 'rgba(255, 255, 200, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      for (let p of particles) {
        let alpha = p.life / 40;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;
    }

    function drawBounceIndicator() {
      // Show bounce count on each side
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';

      if (bouncesLeft > 0) {
        ctx.fillStyle = bouncesLeft >= MAX_BOUNCES ? '#f44' : 'rgba(255, 255, 255, 0.4)';
        ctx.fillText('Bounces: ' + bouncesLeft + '/' + MAX_BOUNCES, NET_X / 2, GROUND_Y + 18);
      }
      if (bouncesRight > 0) {
        ctx.fillStyle = bouncesRight >= MAX_BOUNCES ? '#f44' : 'rgba(255, 255, 255, 0.4)';
        ctx.fillText('Bounces: ' + bouncesRight + '/' + MAX_BOUNCES, NET_X + (W - NET_X) / 2, GROUND_Y + 18);
      }
    }

    function drawScoreBoard() {
      // Large score on court
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#4af';
      ctx.font = 'bold 80px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p1Score, NET_X / 2, GROUND_Y - 60);
      ctx.fillStyle = '#f64';
      ctx.fillText(p2Score, NET_X + (W - NET_X) / 2, GROUND_Y - 60);
      ctx.globalAlpha = 1;
    }

    function drawControls() {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('\u2190\u2192 Move  \u2191 Jump  SPACE Spike', W / 2, H - 5);
    }

    function drawServeIndicator() {
      if (gameState === 'serving') {
        ctx.fillStyle = '#4af';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Press any key to serve', W / 2, 30);

        // Arrow pointing to ball
        let bx = ball.x;
        let by = ball.y - BALL_R - 15;
        ctx.strokeStyle = '#4af';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(bx, by + 8);
        ctx.moveTo(bx - 4, by + 4);
        ctx.lineTo(bx, by + 8);
        ctx.lineTo(bx + 4, by + 4);
        ctx.stroke();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      drawCourt();
      drawScoreBoard();
      drawSlime(p1);
      drawSlime(p2);
      drawBall();
      drawParticles();
      drawBounceIndicator();
      drawControls();
      drawServeIndicator();
    }

    // --- Game loop ---
    function update() {
      if (gameState === 'playing') {
        handlePlayerInput();
        updateAI();
        updatePlayer(p1);
        updatePlayer(p2);
        updateBall();
      } else if (gameState === 'serving') {
        handlePlayerInput();
        updateAI();
        updatePlayer(p1);
        updatePlayer(p2);
        // Ball floats above server
        if (serveSide === 1) {
          ball.x = p1.x;
          ball.y = p1.y - SLIME_W - BALL_R - 20;
        } else {
          ball.x = p2.x;
          ball.y = p2.y - SLIME_W - BALL_R - 20;
        }
      } else if (gameState === 'scored') {
        scoreTimer--;
        if (scoreTimer <= 0) {
          gameState = 'serving';
          resetRound();
        }
      }

      updateParticles();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

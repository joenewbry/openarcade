<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spaceship Circuit</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #aa44ff; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 68, 255, 0.4); }
    h1 { color: #aa44ff; font-size: 1.6rem; text-shadow: 0 0 15px rgba(170, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #aa44ff; }
    canvas {
      border: 2px solid #aa44ff;
      box-shadow: 0 0 20px rgba(170, 68, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #aa44ff;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(170, 68, 255, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 6px; }
    .overlay .keys { font-size: 0.8rem; color: #888; margin-top: 10px; line-height: 1.6; }
    .controls-hint { width: 600px; margin-top: 8px; font-size: 0.7rem; color: #555; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SPACESHIP CIRCUIT</h1>
  </div>
  <div class="score-bar">
    <div>Lap: <span id="lapDisplay">0/3</span></div>
    <div>Pos: <span id="posDisplay">-</span></div>
    <div>Boost: <span id="boostDisplay">100%</span></div>
    <div>Shield: <span id="shieldDisplay">100%</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">SPACESHIP CIRCUIT</h2>
      <p id="overlayText">Zero-gravity racing through the void</p>
      <div class="keys">
        Arrow Keys: Rotate &amp; Thrust | Space: Boost | Z: Shield<br>
        Click or press Enter to start
      </div>
    </div>
  </div>
  <div class="controls-hint">Left/Right=Rotate | Up=Thrust | Down=Brake | Space=Boost | Z=Shield</div>
  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const lapEl = document.getElementById('lapDisplay');
    const posEl = document.getElementById('posDisplay');
    const boostEl = document.getElementById('boostDisplay');
    const shieldEl = document.getElementById('shieldDisplay');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'menu';
    let score = 0;

    // Prevent scrolling on game keys
    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','z','Z'].includes(e.key)) e.preventDefault();
    });

    // ---------- CONSTANTS ----------
    const TOTAL_LAPS = 3;
    const NUM_GATES = 10;
    const TRACK_CX = 300, TRACK_CY = 250;
    const TRACK_RX = 220, TRACK_RY = 170;
    const GATE_WIDTH = 36;
    const SHIP_SIZE = 8;
    const THRUST_POWER = 0.12;
    const ROTATE_SPEED = 0.055;
    const BRAKE_FACTOR = 0.97;
    const BOOST_POWER = 0.35;
    const BOOST_MAX = 100;
    const BOOST_COST = 1.5;
    const BOOST_RECHARGE = 0.15;
    const SHIELD_MAX = 100;
    const SHIELD_COST = 0.6;
    const SHIELD_RECHARGE = 0.08;
    const MAX_SPEED = 6;
    const MAX_BOOST_SPEED = 9;
    const COLLISION_DAMAGE = 25;
    const NUM_ASTEROIDS = 12;
    const NUM_BARRIERS = 3;
    const NUM_GRAVITY_WELLS = 2;
    const NUM_STARS = 120;

    // ---------- COLORS ----------
    const COLORS = {
      player: '#aa44ff',
      ai1: '#ff4466',
      ai2: '#44ddff',
      ai3: '#ffaa22',
      gate: '#44ff88',
      gateNext: '#ffff44',
      asteroid: '#887766',
      barrier: '#ff2244',
      gravityWell: '#4444ff',
      boost: '#ffaa00',
      shield: '#44ccff',
      flame: '#ff8800',
      star: '#ffffff'
    };

    // ---------- WORLD DATA ----------
    let stars = [];
    let gates = [];
    let asteroids = [];
    let barriers = [];
    let gravityWells = [];
    let ships = [];
    let particles = [];
    let raceTime = 0;
    let raceOver = false;
    let countdown = 0;
    let countdownTimer = 0;
    let finishOrder = [];

    // Keys
    const keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // ---------- TRACK GENERATION ----------
    function getTrackPoint(t) {
      // Slightly wobbly ellipse for interesting track
      const wobble = Math.sin(t * 3) * 20 + Math.cos(t * 5) * 10;
      return {
        x: TRACK_CX + Math.cos(t) * (TRACK_RX + wobble),
        y: TRACK_CY + Math.sin(t) * (TRACK_RY + wobble * 0.6)
      };
    }

    function getTrackNormal(t) {
      const dt = 0.01;
      const p1 = getTrackPoint(t - dt);
      const p2 = getTrackPoint(t + dt);
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      return { x: -dy / len, y: dx / len };
    }

    function generateTrack() {
      gates = [];
      for (let i = 0; i < NUM_GATES; i++) {
        const t = (i / NUM_GATES) * Math.PI * 2;
        const p = getTrackPoint(t);
        const n = getTrackNormal(t);
        gates.push({
          x: p.x, y: p.y,
          nx: n.x, ny: n.y,
          angle: Math.atan2(n.y, n.x),
          t: t
        });
      }
    }

    function generateHazards() {
      asteroids = [];
      for (let i = 0; i < NUM_ASTEROIDS; i++) {
        let ax, ay, tooClose;
        let attempts = 0;
        do {
          tooClose = false;
          ax = 40 + Math.random() * (W - 80);
          ay = 40 + Math.random() * (H - 80);
          // Don't place too close to track or gates
          for (let g = 0; g < gates.length; g++) {
            const dx = ax - gates[g].x, dy = ay - gates[g].y;
            if (Math.sqrt(dx * dx + dy * dy) < 50) { tooClose = true; break; }
          }
          // Check distance from track path
          for (let t = 0; t < Math.PI * 2; t += 0.1) {
            const p = getTrackPoint(t);
            const dx = ax - p.x, dy = ay - p.y;
            if (Math.sqrt(dx * dx + dy * dy) < 30) { tooClose = true; break; }
          }
          attempts++;
        } while (tooClose && attempts < 50);
        if (attempts < 50) {
          asteroids.push({
            x: ax, y: ay,
            r: 8 + Math.random() * 12,
            rot: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.02,
            verts: generateAsteroidVerts()
          });
        }
      }

      barriers = [];
      for (let i = 0; i < NUM_BARRIERS; i++) {
        const t = (0.15 + (i / NUM_BARRIERS) * 0.7) * Math.PI * 2;
        const p = getTrackPoint(t);
        const n = getTrackNormal(t);
        // Place barrier slightly off the track centerline
        const offset = (Math.random() - 0.5) * 30;
        barriers.push({
          x: p.x + n.x * offset,
          y: p.y + n.y * offset,
          angle: Math.atan2(n.y, n.x),
          width: 30 + Math.random() * 20,
          phase: Math.random() * Math.PI * 2,
          active: true
        });
      }

      gravityWells = [];
      for (let i = 0; i < NUM_GRAVITY_WELLS; i++) {
        const t = (0.25 + i * 0.5) * Math.PI * 2;
        const p = getTrackPoint(t);
        const n = getTrackNormal(t);
        gravityWells.push({
          x: p.x + n.x * 40 * (Math.random() > 0.5 ? 1 : -1),
          y: p.y + n.y * 40 * (Math.random() > 0.5 ? 1 : -1),
          strength: 0.015 + Math.random() * 0.01,
          radius: 50 + Math.random() * 20,
          pulse: Math.random() * Math.PI * 2
        });
      }
    }

    function generateAsteroidVerts() {
      const n = 6 + Math.floor(Math.random() * 4);
      const verts = [];
      for (let i = 0; i < n; i++) {
        const a = (i / n) * Math.PI * 2;
        const r = 0.7 + Math.random() * 0.6;
        verts.push({ a, r });
      }
      return verts;
    }

    function generateStars() {
      stars = [];
      for (let i = 0; i < NUM_STARS; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          brightness: 0.2 + Math.random() * 0.8,
          size: 0.5 + Math.random() * 1.5,
          twinkle: Math.random() * Math.PI * 2
        });
      }
    }

    // ---------- SHIP ----------
    function createShip(id, color, isAI) {
      // Start near gate 0
      const g = gates[0];
      const offset = (id - 1.5) * 15;
      const startX = g.x - g.nx * 30 + g.ny * offset;
      const startY = g.y - g.ny * 30 - g.nx * offset;
      // Face along track direction
      const nextG = gates[1];
      const startAngle = Math.atan2(nextG.y - g.y, nextG.x - g.x);
      return {
        id, color, isAI,
        x: startX, y: startY,
        vx: 0, vy: 0,
        angle: startAngle,
        thrust: false,
        boosting: false,
        shielding: false,
        boost: BOOST_MAX,
        shield: SHIELD_MAX,
        lap: 0,
        nextGate: 0,
        gatesPassed: 0,
        finished: false,
        finishTime: 0,
        invulnerable: 0,
        // AI state
        aiThrust: false,
        aiBrake: false,
        aiTurnDir: 0,
        aiBoost: false,
        aiShield: false,
        // Visual
        flameFlicker: 0,
        trail: [],
        hitFlash: 0
      };
    }

    // ---------- AI LOGIC ----------
    function updateAI(ship) {
      const target = gates[ship.nextGate];
      if (!target) return;

      // Look ahead: aim for the gate after next too
      const nextNext = gates[(ship.nextGate + 1) % NUM_GATES];
      const dx = target.x - ship.x;
      const dy = target.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Blend target: when close to current gate, start aiming for the next one
      const blend = Math.max(0, 1 - dist / 150);
      const aimX = dx * (1 - blend) + (nextNext.x - ship.x) * blend;
      const aimY = dy * (1 - blend) + (nextNext.y - ship.y) * blend;

      const targetAngle = Math.atan2(aimY, aimX);
      let angleDiff = targetAngle - ship.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

      // Turning
      if (Math.abs(angleDiff) > 0.08) {
        ship.aiTurnDir = angleDiff > 0 ? 1 : -1;
      } else {
        ship.aiTurnDir = 0;
      }

      // Thrust: thrust when facing roughly right direction
      const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      ship.aiThrust = Math.abs(angleDiff) < 1.2 && speed < MAX_SPEED * 0.85;

      // Braking: when going too fast or facing wrong way
      ship.aiBrake = (Math.abs(angleDiff) > 1.8 && speed > 1.5) || speed > MAX_SPEED * 0.9;

      // Boost: use on straightaways when well-aligned and enough boost
      ship.aiBoost = Math.abs(angleDiff) < 0.3 && dist > 80 && ship.boost > 40 && speed < MAX_BOOST_SPEED * 0.7;

      // Shield: activate near hazards
      ship.aiShield = false;
      if (ship.shield > 20) {
        // Check asteroid proximity
        for (const ast of asteroids) {
          const adx = ast.x - ship.x, ady = ast.y - ship.y;
          if (Math.sqrt(adx * adx + ady * ady) < ast.r + 20) {
            ship.aiShield = true;
            break;
          }
        }
        // Check barrier proximity
        if (!ship.aiShield) {
          for (const b of barriers) {
            if (!b.active) continue;
            const bdx = b.x - ship.x, bdy = b.y - ship.y;
            if (Math.sqrt(bdx * bdx + bdy * bdy) < b.width + 15) {
              ship.aiShield = true;
              break;
            }
          }
        }
        // Check gravity well proximity
        if (!ship.aiShield) {
          for (const gw of gravityWells) {
            const gdx = gw.x - ship.x, gdy = gw.y - ship.y;
            if (Math.sqrt(gdx * gdx + gdy * gdy) < gw.radius * 0.7) {
              ship.aiShield = true;
              break;
            }
          }
        }
      }

      // Steer away from nearby asteroids (obstacle avoidance)
      for (const ast of asteroids) {
        const adx = ast.x - ship.x, ady = ast.y - ship.y;
        const adist = Math.sqrt(adx * adx + ady * ady);
        if (adist < ast.r + 35) {
          const avoidAngle = Math.atan2(-ady, -adx);
          let avoidDiff = avoidAngle - ship.angle;
          while (avoidDiff > Math.PI) avoidDiff -= Math.PI * 2;
          while (avoidDiff < -Math.PI) avoidDiff += Math.PI * 2;
          if (Math.abs(avoidDiff) < 1.0) {
            ship.aiTurnDir = avoidDiff > 0 ? 1 : -1;
            ship.aiThrust = true;
          }
        }
      }
    }

    // ---------- PHYSICS ----------
    function updateShip(ship, dt) {
      if (ship.finished) return;

      let rotating = 0, thrusting = false, braking = false, boosting = false, shielding = false;

      if (ship.isAI) {
        updateAI(ship);
        rotating = ship.aiTurnDir;
        thrusting = ship.aiThrust;
        braking = ship.aiBrake;
        boosting = ship.aiBoost;
        shielding = ship.aiShield;
      } else {
        if (keys['ArrowLeft']) rotating = -1;
        if (keys['ArrowRight']) rotating = 1;
        if (keys['ArrowUp']) thrusting = true;
        if (keys['ArrowDown']) braking = true;
        if (keys[' ']) boosting = true;
        if (keys['z'] || keys['Z']) shielding = true;
      }

      // Rotation
      ship.angle += rotating * ROTATE_SPEED;

      // Thrust
      ship.thrust = thrusting || boosting;
      if (thrusting) {
        ship.vx += Math.cos(ship.angle) * THRUST_POWER;
        ship.vy += Math.sin(ship.angle) * THRUST_POWER;
      }

      // Boost
      ship.boosting = false;
      if (boosting && ship.boost > 0) {
        ship.vx += Math.cos(ship.angle) * BOOST_POWER;
        ship.vy += Math.sin(ship.angle) * BOOST_POWER;
        ship.boost = Math.max(0, ship.boost - BOOST_COST);
        ship.boosting = true;
      }
      if (!boosting) {
        ship.boost = Math.min(BOOST_MAX, ship.boost + BOOST_RECHARGE);
      }

      // Shield
      ship.shielding = false;
      if (shielding && ship.shield > 0) {
        ship.shield = Math.max(0, ship.shield - SHIELD_COST);
        ship.shielding = true;
      }
      if (!shielding) {
        ship.shield = Math.min(SHIELD_MAX, ship.shield + SHIELD_RECHARGE);
      }

      // Braking (applies light friction)
      if (braking) {
        ship.vx *= BRAKE_FACTOR;
        ship.vy *= BRAKE_FACTOR;
      }

      // Gravity wells
      for (const gw of gravityWells) {
        const gdx = gw.x - ship.x, gdy = gw.y - ship.y;
        const gdist = Math.sqrt(gdx * gdx + gdy * gdy);
        if (gdist < gw.radius * 2) {
          const force = gw.strength * (1 - gdist / (gw.radius * 2));
          ship.vx += (gdx / gdist) * force;
          ship.vy += (gdy / gdist) * force;
        }
      }

      // Speed limit
      const spd = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      const maxSpd = ship.boosting ? MAX_BOOST_SPEED : MAX_SPEED;
      if (spd > maxSpd) {
        ship.vx = (ship.vx / spd) * maxSpd;
        ship.vy = (ship.vy / spd) * maxSpd;
      }

      // Move
      ship.x += ship.vx;
      ship.y += ship.vy;

      // Wrap around
      if (ship.x < -20) ship.x += W + 40;
      if (ship.x > W + 20) ship.x -= W + 40;
      if (ship.y < -20) ship.y += H + 40;
      if (ship.y > H + 20) ship.y -= H + 40;

      // Invulnerability timer
      if (ship.invulnerable > 0) ship.invulnerable--;
      if (ship.hitFlash > 0) ship.hitFlash--;

      // Trail
      if (ship.thrust || ship.boosting) {
        ship.trail.push({ x: ship.x, y: ship.y, life: 20, boost: ship.boosting });
      }
      ship.trail = ship.trail.filter(t => { t.life--; return t.life > 0; });

      // Collision with asteroids
      for (const ast of asteroids) {
        const adx = ast.x - ship.x, ady = ast.y - ship.y;
        const adist = Math.sqrt(adx * adx + ady * ady);
        if (adist < ast.r + SHIP_SIZE) {
          if (ship.shielding) {
            // Bounce off
            const nx = adx / adist, ny = ady / adist;
            const dot = ship.vx * nx + ship.vy * ny;
            ship.vx -= 2 * dot * nx;
            ship.vy -= 2 * dot * ny;
            ship.x = ast.x - nx * (ast.r + SHIP_SIZE + 2);
            ship.y = ast.y - ny * (ast.r + SHIP_SIZE + 2);
            spawnParticles(ship.x, ship.y, COLORS.shield, 5);
          } else if (ship.invulnerable <= 0) {
            // Take damage: slow down significantly
            ship.vx *= 0.3;
            ship.vy *= 0.3;
            ship.invulnerable = 30;
            ship.hitFlash = 15;
            spawnParticles(ship.x, ship.y, ship.color, 10);
          }
        }
      }

      // Collision with barriers (when active)
      for (const b of barriers) {
        if (!b.active) continue;
        const bdx = b.x - ship.x, bdy = b.y - ship.y;
        const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
        if (bdist < b.width * 0.5 + SHIP_SIZE) {
          if (ship.shielding) {
            const nx = bdx / bdist, ny = bdy / bdist;
            ship.vx -= nx * 0.5;
            ship.vy -= ny * 0.5;
            spawnParticles(ship.x, ship.y, COLORS.shield, 3);
          } else if (ship.invulnerable <= 0) {
            ship.vx *= 0.4;
            ship.vy *= 0.4;
            ship.invulnerable = 30;
            ship.hitFlash = 15;
            spawnParticles(ship.x, ship.y, COLORS.barrier, 8);
          }
        }
      }

      // Gate checking
      const gate = gates[ship.nextGate];
      const gx = gate.x - ship.x, gy = gate.y - ship.y;
      const gDist = Math.sqrt(gx * gx + gy * gy);
      if (gDist < GATE_WIDTH) {
        ship.gatesPassed++;
        ship.nextGate = (ship.nextGate + 1) % NUM_GATES;
        if (ship.nextGate === 0) {
          ship.lap++;
          if (ship.lap >= TOTAL_LAPS) {
            ship.finished = true;
            ship.finishTime = raceTime;
            finishOrder.push(ship);
          }
        }
        spawnParticles(gate.x, gate.y, COLORS.gateNext, 8);
      }

      // Flame animation
      ship.flameFlicker = (ship.flameFlicker + 0.3) % (Math.PI * 2);
    }

    // ---------- PARTICLES ----------
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 2;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 15 + Math.random() * 15,
          maxLife: 30,
          color,
          size: 1 + Math.random() * 2
        });
      }
    }

    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        return p.life > 0;
      });
    }

    // ---------- DRAWING ----------
    function drawStars() {
      for (const s of stars) {
        s.twinkle += 0.02;
        const b = s.brightness * (0.5 + 0.5 * Math.sin(s.twinkle));
        ctx.fillStyle = `rgba(255,255,255,${b})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawTrack() {
      // Draw track path (faint guide line)
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.08)';
      ctx.lineWidth = 40;
      ctx.beginPath();
      for (let t = 0; t <= Math.PI * 2; t += 0.05) {
        const p = getTrackPoint(t);
        if (t === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();

      // Draw track centerline
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 8]);
      ctx.beginPath();
      for (let t = 0; t <= Math.PI * 2; t += 0.05) {
        const p = getTrackPoint(t);
        if (t === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawGates(playerShip) {
      for (let i = 0; i < gates.length; i++) {
        const g = gates[i];
        const isNext = (i === playerShip.nextGate);
        const isPassed = playerShip.gatesPassed > 0 && (
          (playerShip.nextGate > i) || (playerShip.lap > 0 && i >= playerShip.nextGate)
        );

        const baseColor = isNext ? COLORS.gateNext : COLORS.gate;
        const alpha = isNext ? 0.9 : 0.35;
        const glowSize = isNext ? 8 : 3;

        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(g.angle);

        // Gate glow
        if (isNext) {
          ctx.shadowColor = baseColor;
          ctx.shadowBlur = 15;
        }

        // Gate posts
        ctx.strokeStyle = baseColor;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = isNext ? 3 : 2;
        ctx.beginPath();
        ctx.moveTo(0, -GATE_WIDTH / 2);
        ctx.lineTo(0, GATE_WIDTH / 2);
        ctx.stroke();

        // Gate markers
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.arc(0, -GATE_WIDTH / 2, isNext ? 4 : 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, GATE_WIDTH / 2, isNext ? 4 : 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Gate number
        if (isNext) {
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = '#fff';
          ctx.font = '8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText((i + 1).toString(), 0, 3);
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawAsteroids() {
      for (const ast of asteroids) {
        ast.rot += ast.rotSpeed;
        ctx.save();
        ctx.translate(ast.x, ast.y);
        ctx.rotate(ast.rot);
        ctx.fillStyle = COLORS.asteroid;
        ctx.strokeStyle = '#665544';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < ast.verts.length; i++) {
          const v = ast.verts[i];
          const x = Math.cos(v.a) * v.r * ast.r;
          const y = Math.sin(v.a) * v.r * ast.r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawBarriers(time) {
      for (const b of barriers) {
        // Pulse on/off
        const pulse = Math.sin(time * 0.03 + b.phase);
        b.active = pulse > -0.3;

        if (!b.active) continue;

        const alpha = 0.4 + 0.4 * Math.max(0, pulse);
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.angle);
        ctx.strokeStyle = COLORS.barrier;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 3;
        ctx.shadowColor = COLORS.barrier;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(-b.width / 2, 0);
        ctx.lineTo(b.width / 2, 0);
        ctx.stroke();

        // Energy crackle
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const ox = (Math.random() - 0.5) * b.width;
          const oy = (Math.random() - 0.5) * 6;
          ctx.beginPath();
          ctx.moveTo(ox, 0);
          ctx.lineTo(ox + (Math.random() - 0.5) * 8, oy);
          ctx.stroke();
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawGravityWells(time) {
      for (const gw of gravityWells) {
        gw.pulse += 0.02;
        const pulseR = gw.radius * (0.9 + 0.1 * Math.sin(gw.pulse));

        // Concentric rings
        for (let r = 0; r < 4; r++) {
          const ringR = pulseR * (0.3 + r * 0.2);
          const alpha = 0.15 - r * 0.03;
          ctx.strokeStyle = COLORS.gravityWell;
          ctx.globalAlpha = alpha;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(gw.x, gw.y, ringR, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Center glow
        const grad = ctx.createRadialGradient(gw.x, gw.y, 0, gw.x, gw.y, 15);
        grad.addColorStop(0, 'rgba(68, 68, 255, 0.3)');
        grad.addColorStop(1, 'rgba(68, 68, 255, 0)');
        ctx.fillStyle = grad;
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(gw.x, gw.y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    function drawShip(ship) {
      if (ship.finished && finishOrder.indexOf(ship) >= 0) {
        // Draw finished indicator
        ctx.globalAlpha = 0.3 + 0.2 * Math.sin(raceTime * 0.05);
      }

      // Trails
      for (const t of ship.trail) {
        const alpha = t.life / 20 * 0.4;
        ctx.fillStyle = t.boost ? COLORS.boost : COLORS.flame;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.boost ? 2.5 : 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      // Engine flame
      if (ship.thrust || ship.boosting) {
        const flameLen = ship.boosting ? 14 + Math.sin(ship.flameFlicker) * 6 : 8 + Math.sin(ship.flameFlicker) * 3;
        const flameColor = ship.boosting ? COLORS.boost : COLORS.flame;
        ctx.fillStyle = flameColor;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.moveTo(-SHIP_SIZE, -3);
        ctx.lineTo(-SHIP_SIZE - flameLen, 0);
        ctx.lineTo(-SHIP_SIZE, 3);
        ctx.closePath();
        ctx.fill();

        // Inner flame
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(-SHIP_SIZE, -1.5);
        ctx.lineTo(-SHIP_SIZE - flameLen * 0.5, 0);
        ctx.lineTo(-SHIP_SIZE, 1.5);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Ship body
      const flashMod = ship.hitFlash > 0 ? (ship.hitFlash % 4 < 2 ? 0.3 : 1) : 1;
      ctx.globalAlpha = flashMod;
      ctx.fillStyle = ship.color;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(SHIP_SIZE + 2, 0);           // Nose
      ctx.lineTo(-SHIP_SIZE, -SHIP_SIZE + 1);  // Top-left
      ctx.lineTo(-SHIP_SIZE + 3, 0);           // Rear center
      ctx.lineTo(-SHIP_SIZE, SHIP_SIZE - 1);   // Bottom-left
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Shield bubble
      if (ship.shielding) {
        ctx.strokeStyle = COLORS.shield;
        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(raceTime * 0.1);
        ctx.lineWidth = 2;
        ctx.shadowColor = COLORS.shield;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, SHIP_SIZE + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      ctx.restore();

      // Name label for AI
      if (ship.isAI) {
        ctx.fillStyle = ship.color;
        ctx.globalAlpha = 0.5;
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('AI-' + ship.id, ship.x, ship.y - 14);
        ctx.globalAlpha = 1;
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawHUD(playerShip) {
      // Minimap in top-right corner
      const mmX = W - 90, mmY = 10, mmW = 80, mmH = 65;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillRect(mmX, mmY, mmW, mmH);
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(mmX, mmY, mmW, mmH);

      // Track on minimap
      ctx.strokeStyle = 'rgba(170, 68, 255, 0.2)';
      ctx.beginPath();
      for (let t = 0; t <= Math.PI * 2; t += 0.1) {
        const p = getTrackPoint(t);
        const mx = mmX + (p.x / W) * mmW;
        const my = mmY + (p.y / H) * mmH;
        if (t === 0) ctx.moveTo(mx, my);
        else ctx.lineTo(mx, my);
      }
      ctx.closePath();
      ctx.stroke();

      // Ships on minimap
      for (const s of ships) {
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(mmX + (s.x / W) * mmW, mmY + (s.y / H) * mmH, s === playerShip ? 3 : 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // Timer
      ctx.fillStyle = '#aaa';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      const mins = Math.floor(raceTime / 3600);
      const secs = Math.floor((raceTime / 60) % 60);
      const ms = Math.floor((raceTime % 60) / 60 * 100);
      ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`, 10, 20);

      // Boost bar (bottom-left)
      const barX = 10, barY = H - 25, barW = 80, barH = 8;
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = COLORS.boost;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(barX, barY, barW * (playerShip.boost / BOOST_MAX), barH);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#aaa';
      ctx.font = '8px Courier New';
      ctx.fillText('BOOST', barX, barY - 3);

      // Shield bar (bottom-left, above boost)
      const sBarY = barY - 18;
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(barX, sBarY, barW, barH);
      ctx.fillStyle = COLORS.shield;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(barX, sBarY, barW * (playerShip.shield / SHIELD_MAX), barH);
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#aaa';
      ctx.fillText('SHIELD', barX, sBarY - 3);
    }

    function drawCountdown() {
      if (countdown > 0) {
        const num = Math.ceil(countdown / 60);
        ctx.fillStyle = '#aa44ff';
        ctx.font = 'bold 60px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#aa44ff';
        ctx.shadowBlur = 20;
        const scale = 1 + (countdown % 60) / 60 * 0.3;
        ctx.save();
        ctx.translate(W / 2, H / 2);
        ctx.scale(scale, scale);
        ctx.fillText(num > 0 ? num.toString() : 'GO!', 0, 15);
        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    function drawFinishScreen() {
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#aa44ff';
      ctx.font = 'bold 30px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#aa44ff';
      ctx.shadowBlur = 15;
      ctx.fillText('RACE COMPLETE', W / 2, 150);
      ctx.shadowBlur = 0;

      for (let i = 0; i < finishOrder.length; i++) {
        const s = finishOrder[i];
        const label = s.isAI ? `AI-${s.id}` : 'YOU';
        const mins = Math.floor(s.finishTime / 3600);
        const secs = Math.floor((s.finishTime / 60) % 60);
        const ms = Math.floor((s.finishTime % 60) / 60 * 100);
        const timeStr = `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;

        ctx.fillStyle = s.color;
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`${i + 1}. ${label}  ${timeStr}`, W / 2, 200 + i * 30);
      }

      ctx.fillStyle = '#aaa';
      ctx.font = '14px Courier New';
      ctx.fillText('Press Enter to race again', W / 2, 360);
    }

    // ---------- RANKING ----------
    function getRanking() {
      const sorted = [...ships].sort((a, b) => {
        if (a.finished && !b.finished) return -1;
        if (!a.finished && b.finished) return 1;
        if (a.finished && b.finished) return a.finishTime - b.finishTime;
        // More gates passed = better
        const aTotal = a.lap * NUM_GATES + a.gatesPassed;
        const bTotal = b.lap * NUM_GATES + b.gatesPassed;
        if (aTotal !== bTotal) return bTotal - aTotal;
        // Closer to next gate is better
        const aGate = gates[a.nextGate];
        const bGate = gates[b.nextGate];
        const aDist = Math.sqrt((aGate.x - a.x) ** 2 + (aGate.y - a.y) ** 2);
        const bDist = Math.sqrt((bGate.x - b.x) ** 2 + (bGate.y - b.y) ** 2);
        return aDist - bDist;
      });
      return sorted;
    }

    function getPositionStr(pos) {
      if (pos === 1) return '1st';
      if (pos === 2) return '2nd';
      if (pos === 3) return '3rd';
      return pos + 'th';
    }

    // ---------- GAME LOOP ----------
    function initGame() {
      generateStars();
      generateTrack();
      generateHazards();
      ships = [];
      ships.push(createShip(0, COLORS.player, false));
      ships.push(createShip(1, COLORS.ai1, true));
      ships.push(createShip(2, COLORS.ai2, true));
      ships.push(createShip(3, COLORS.ai3, true));
      particles = [];
      raceTime = 0;
      raceOver = false;
      finishOrder = [];
      countdown = 180; // 3 seconds
      countdownTimer = 0;
      score = 0;
    }

    function update() {
      if (gameState !== 'playing') return;

      // Countdown
      if (countdown > 0) {
        countdown--;
        return;
      }

      raceTime++;

      // Update barriers
      // (handled in draw for visual sync)

      for (const ship of ships) {
        updateShip(ship);
      }

      updateParticles();

      // Check if all ships finished or time limit
      const player = ships[0];
      if (!raceOver) {
        if (player.finished || raceTime > 60 * 60 * 5) { // 5 min limit
          // Force finish any unfinished
          if (!raceOver) {
            raceOver = true;
            for (const s of ships) {
              if (!s.finished) {
                s.finished = true;
                s.finishTime = raceTime;
                finishOrder.push(s);
              }
            }
            // Calculate score
            const ranking = finishOrder;
            const playerIdx = ranking.indexOf(player);
            const positionScore = (4 - playerIdx) * 250;
            const timeBonus = Math.max(0, Math.floor((18000 - player.finishTime) / 60));
            score = positionScore + timeBonus;
            gameState = 'gameover';
          }
        }
      }

      // Update HUD
      const ranking = getRanking();
      const playerPos = ranking.indexOf(player) + 1;
      lapEl.textContent = `${Math.min(player.lap + 1, TOTAL_LAPS)}/${TOTAL_LAPS}`;
      posEl.textContent = getPositionStr(playerPos);
      boostEl.textContent = Math.round(player.boost) + '%';
      shieldEl.textContent = Math.round(player.shield) + '%';
    }

    function draw() {
      ctx.fillStyle = '#0a0a18';
      ctx.fillRect(0, 0, W, H);

      drawStars();
      drawTrack();
      drawGravityWells(raceTime);
      drawBarriers(raceTime);
      drawGates(ships[0]);
      drawAsteroids();

      // Draw trails first, then ships
      for (const ship of ships) {
        drawShip(ship);
      }

      drawParticles();
      drawHUD(ships[0]);

      if (countdown > 0) {
        drawCountdown();
      }

      if (gameState === 'gameover') {
        drawFinishScreen();
      }
    }

    function gameLoop() {
      if (gameState === 'playing' || gameState === 'gameover') {
        update();
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    // ---------- INPUT HANDLING ----------
    function startGame() {
      overlay.style.display = 'none';
      gameState = 'playing';
      initGame();
    }

    overlay.style.pointerEvents = 'auto';
    overlay.addEventListener('click', () => {
      if (gameState === 'menu') startGame();
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        if (gameState === 'menu') {
          startGame();
        } else if (gameState === 'gameover') {
          startGame();
        }
      }
    });

    // Start loop
    gameLoop();

    // Recorder
    if (typeof GameRecorder !== 'undefined') {
      const rec = new GameRecorder(canvas);
    }
  </script>
</body>
</html>

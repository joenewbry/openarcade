<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>R-Type</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 512px;
    }
    .back { color: #f8e; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 238, 0.5); }
    h1 { color: #f8e; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 512px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f8e; }
    canvas {
      border: 2px solid #f8e;
      box-shadow: 0 0 20px rgba(255, 136, 238, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f8e;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>R-TYPE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Wave: <span id="wave">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="512" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:512px;height:400px;">
      <h2 id="overlayTitle">R-TYPE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const waveEl = document.getElementById('wave');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;
    let lives, wave, tick;
    let player, bullets, enemies, enemyBullets, particles, powerUps;
    let forcePod, scrollX, starField;
    let chargeTime, charging, chargeMax;
    let spawnTimer, spawnQueue;
    let keys = {};
    let terrain; // organic terrain segments
    let boss, bossActive;
    let waveIntroTimer, waveIntroText;
    let animFrame;

    // Constants
    const PLAYER_W = 28, PLAYER_H = 14;
    const PLAYER_SPEED = 3.5;
    const CHARGE_MAX = 90; // frames to full charge
    const SCROLL_SPEED = 1;

    // Power-up types
    const PU_FORCE = 0, PU_WAVE = 1, PU_BOUNCE = 2, PU_SPEED = 3;

    // Star field (parallax)
    function genStars() {
      starField = [];
      for (let i = 0; i < 80; i++) {
        starField.push({
          x: Math.random() * W,
          y: Math.random() * H,
          speed: 0.2 + Math.random() * 1.2,
          size: Math.random() < 0.3 ? 2 : 1,
          brightness: 40 + Math.floor(Math.random() * 60)
        });
      }
    }

    // Terrain generation for organic feel
    function genTerrain() {
      terrain = { top: [], bottom: [] };
      for (let x = 0; x < W + 200; x += 4) {
        const t = x * 0.01;
        terrain.top.push(Math.sin(t) * 15 + Math.sin(t * 2.3) * 8 + 25);
        terrain.bottom.push(Math.sin(t + 2) * 15 + Math.sin(t * 1.7 + 1) * 10 + 25);
      }
    }

    // Wave definitions
    const WAVES = [
      { // Wave 1: Basic scouts
        name: 'Scout Patrol',
        spawns: [
          { type: 'scout', count: 6, delay: 40, pattern: 'line' },
          { type: 'scout', count: 6, delay: 40, pattern: 'sine' },
          { type: 'powerup', puType: PU_FORCE, delay: 80 },
          { type: 'scout', count: 8, delay: 30, pattern: 'line' },
        ]
      },
      { // Wave 2: Drifters
        name: 'Drifter Swarm',
        spawns: [
          { type: 'drifter', count: 5, delay: 50, pattern: 'spread' },
          { type: 'scout', count: 6, delay: 35, pattern: 'sine' },
          { type: 'powerup', puType: PU_WAVE, delay: 60 },
          { type: 'drifter', count: 8, delay: 35, pattern: 'spread' },
          { type: 'scout', count: 5, delay: 40, pattern: 'line' },
        ]
      },
      { // Wave 3: Chargers
        name: 'Charger Rush',
        spawns: [
          { type: 'charger', count: 4, delay: 60, pattern: 'line' },
          { type: 'scout', count: 6, delay: 30, pattern: 'sine' },
          { type: 'powerup', puType: PU_BOUNCE, delay: 80 },
          { type: 'charger', count: 6, delay: 45, pattern: 'line' },
          { type: 'drifter', count: 5, delay: 40, pattern: 'spread' },
        ]
      },
      { // Wave 4: Turrets and mixed
        name: 'Organic Defenses',
        spawns: [
          { type: 'turret', count: 3, delay: 80, pattern: 'fixed' },
          { type: 'scout', count: 8, delay: 25, pattern: 'sine' },
          { type: 'powerup', puType: PU_SPEED, delay: 60 },
          { type: 'drifter', count: 6, delay: 35, pattern: 'spread' },
          { type: 'charger', count: 4, delay: 50, pattern: 'line' },
          { type: 'turret', count: 2, delay: 90, pattern: 'fixed' },
        ]
      },
      { // Wave 5: Boss - Dobkeratops
        name: 'BOSS: Dobkeratops',
        spawns: [
          { type: 'powerup', puType: PU_FORCE, delay: 30 },
          { type: 'boss', bossType: 'dobkeratops', delay: 120 },
        ]
      },
      { // Wave 6: Harder scouts + snakes
        name: 'Serpent Approach',
        spawns: [
          { type: 'snake', count: 1, delay: 60, segments: 8 },
          { type: 'scout', count: 8, delay: 25, pattern: 'sine' },
          { type: 'powerup', puType: PU_WAVE, delay: 60 },
          { type: 'snake', count: 1, delay: 50, segments: 10 },
          { type: 'charger', count: 6, delay: 40, pattern: 'line' },
          { type: 'drifter', count: 6, delay: 35, pattern: 'spread' },
        ]
      },
      { // Wave 7: Dense mixed
        name: 'Full Assault',
        spawns: [
          { type: 'turret', count: 4, delay: 70, pattern: 'fixed' },
          { type: 'charger', count: 6, delay: 35, pattern: 'line' },
          { type: 'powerup', puType: PU_BOUNCE, delay: 50 },
          { type: 'scout', count: 10, delay: 20, pattern: 'sine' },
          { type: 'snake', count: 1, delay: 50, segments: 12 },
          { type: 'drifter', count: 8, delay: 30, pattern: 'spread' },
        ]
      },
      { // Wave 8: Boss - Gomander
        name: 'BOSS: Gomander',
        spawns: [
          { type: 'powerup', puType: PU_FORCE, delay: 30 },
          { type: 'powerup', puType: PU_WAVE, delay: 60 },
          { type: 'boss', bossType: 'gomander', delay: 120 },
        ]
      },
    ];

    function init() {
      score = 0;
      lives = 3;
      wave = 0;
      tick = 0;
      scrollX = 0;
      charging = false;
      chargeTime = 0;
      chargeMax = CHARGE_MAX;
      bossActive = false;
      boss = null;
      waveIntroTimer = 0;
      waveIntroText = '';
      player = { x: 60, y: H / 2, weapon: 'normal', speedBoost: false, invuln: 0 };
      bullets = [];
      enemies = [];
      enemyBullets = [];
      particles = [];
      powerUps = [];
      forcePod = null;
      spawnTimer = 0;
      spawnQueue = [];
      keys = {};
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      waveEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'R-TYPE';
      overlayText.textContent = 'Press SPACE to start\n\nArrows: Move | Space: Fire (hold to charge)';
      genStars();
      genTerrain();
      drawFrame();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startWave();
      cancelAnimationFrame(animFrame);
      loop();
    }

    function startWave() {
      wave++;
      if (wave > WAVES.length) wave = WAVES.length; // repeat last
      waveEl.textContent = wave;
      const wDef = WAVES[wave - 1];
      spawnQueue = [];
      let totalDelay = 0;
      wDef.spawns.forEach(s => {
        totalDelay += s.delay;
        spawnQueue.push({ ...s, time: totalDelay });
      });
      spawnTimer = 0;
      bossActive = false;
      boss = null;
      waveIntroTimer = 90;
      waveIntroText = wDef.name;
    }

    function loop() {
      if (gameState === 'over') return;
      tick++;
      update();
      drawFrame();
      animFrame = requestAnimationFrame(loop);
    }

    function update() {
      scrollX += SCROLL_SPEED;

      // Stars
      starField.forEach(s => {
        s.x -= s.speed;
        if (s.x < 0) { s.x = W; s.y = Math.random() * H; }
      });

      if (waveIntroTimer > 0) {
        waveIntroTimer--;
        // Still allow movement during intro
      }

      // Player movement
      const spd = player.speedBoost ? PLAYER_SPEED * 1.4 : PLAYER_SPEED;
      if (keys['ArrowUp']) player.y -= spd;
      if (keys['ArrowDown']) player.y += spd;
      if (keys['ArrowLeft']) player.x -= spd;
      if (keys['ArrowRight']) player.x += spd;
      player.x = Math.max(4, Math.min(W - PLAYER_W - 4, player.x));
      player.y = Math.max(4, Math.min(H - PLAYER_H - 4, player.y));

      if (player.invuln > 0) player.invuln--;

      // Charge mechanic
      if (charging) {
        chargeTime = Math.min(chargeTime + 1, chargeMax);
      }

      // Force pod movement
      if (forcePod) {
        if (forcePod.attached) {
          if (forcePod.front) {
            forcePod.x = player.x + PLAYER_W + 2;
            forcePod.y = player.y + PLAYER_H / 2 - 6;
          } else {
            forcePod.x = player.x - 14;
            forcePod.y = player.y + PLAYER_H / 2 - 6;
          }
        } else {
          // Float toward player slowly
          const dx = player.x + PLAYER_W / 2 - forcePod.x;
          const dy = player.y + PLAYER_H / 2 - forcePod.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 3) {
            forcePod.x += dx / dist * 1.5;
            forcePod.y += dy / dist * 1.5;
          }
          // Check attach
          if (dist < 20) {
            forcePod.attached = true;
            forcePod.front = true;
          }
        }
        // Force pod fires
        if (forcePod.attached && tick % 15 === 0) {
          const dir = forcePod.front ? 1 : -1;
          bullets.push({
            x: forcePod.x + (forcePod.front ? 12 : 0),
            y: forcePod.y + 4,
            vx: 6 * dir, vy: 0,
            damage: 1, type: 'force', life: 200
          });
        }
      }

      // Spawning
      spawnTimer++;
      spawnQueue.forEach(s => {
        if (s.spawned) return;
        if (spawnTimer >= s.time) {
          s.spawned = true;
          if (s.type === 'powerup') {
            spawnPowerUp(s.puType);
          } else if (s.type === 'boss') {
            spawnBoss(s.bossType);
          } else if (s.type === 'snake') {
            spawnSnake(s.segments);
          } else {
            for (let i = 0; i < s.count; i++) {
              setTimeout(() => spawnEnemy(s.type, s.pattern, i, s.count), i * 180);
            }
          }
        }
      });

      // Check wave complete
      if (!bossActive && spawnQueue.every(s => s.spawned) && enemies.length === 0 && spawnTimer > 60) {
        if (wave < WAVES.length) {
          startWave();
        }
        // else loop the last wave
        else {
          wave = 0;
          startWave();
        }
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        b.life--;
        // Bounce laser
        if (b.type === 'bounce') {
          if (b.y <= 2 || b.y >= H - 2) b.vy *= -1;
        }
        if (b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10 || b.life <= 0) {
          bullets.splice(i, 1);
        }
      }

      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10) {
          enemyBullets.splice(i, 1);
          continue;
        }
        // Hit player
        if (!player.invuln && rectCollide(b.x - 3, b.y - 3, 6, 6, player.x + 4, player.y + 2, PLAYER_W - 8, PLAYER_H - 4)) {
          // Force pod absorbs from front
          if (forcePod && forcePod.attached && forcePod.front &&
              b.x > player.x + PLAYER_W - 5) {
            enemyBullets.splice(i, 1);
            spawnParticles(b.x, b.y, '#f8e', 3);
            continue;
          }
          enemyBullets.splice(i, 1);
          playerHit();
          continue;
        }
        // Force pod absorbs bullets
        if (forcePod) {
          if (rectCollide(b.x - 3, b.y - 3, 6, 6, forcePod.x, forcePod.y, 12, 12)) {
            enemyBullets.splice(i, 1);
            spawnParticles(b.x, b.y, '#f8e', 3);
          }
        }
      }

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.tick++;
        updateEnemy(e);

        // Off screen left? Remove
        if (e.x < -60 && !e.isBoss) {
          enemies.splice(i, 1);
          continue;
        }

        // Bullet vs enemy
        let hit = false;
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          const ew = e.w || 20, eh = e.h || 16;
          if (rectCollide(b.x - 2, b.y - 2, 4, 4, e.x, e.y, ew, eh)) {
            e.hp -= b.damage;
            bullets.splice(j, 1);
            spawnParticles(b.x, b.y, '#fff', 3);
            if (e.hp <= 0) {
              destroyEnemy(e, i);
              hit = true;
              break;
            }
          }
        }
        if (hit) { enemies.splice(i, 1); continue; }

        // Enemy vs player
        if (!player.invuln && !e.dead) {
          const ew = e.w || 20, eh = e.h || 16;
          if (rectCollide(e.x, e.y, ew, eh, player.x + 4, player.y + 2, PLAYER_W - 8, PLAYER_H - 4)) {
            playerHit();
          }
        }

        // Force pod damages enemies on contact
        if (forcePod && forcePod.attached) {
          const ew = e.w || 20, eh = e.h || 16;
          if (rectCollide(forcePod.x, forcePod.y, 12, 12, e.x, e.y, ew, eh)) {
            e.hp -= 0.5;
            spawnParticles(forcePod.x + 6, forcePod.y + 6, '#f8e', 2);
            if (e.hp <= 0) {
              destroyEnemy(e, i);
              enemies.splice(i, 1);
            }
          }
        }
      }

      // Boss update
      if (boss && boss.hp <= 0) {
        score += boss.points;
        scoreEl.textContent = score;
        if (score > best) { best = score; if (bestEl) bestEl.textContent = best; }
        spawnParticles(boss.x + boss.w / 2, boss.y + boss.h / 2, '#f80', 30);
        spawnParticles(boss.x + boss.w / 2, boss.y + boss.h / 2, '#ff0', 20);
        boss = null;
        bossActive = false;
        // Remove all enemy bullets on boss death
        enemyBullets = [];
      }

      // Update power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const p = powerUps[i];
        p.x -= 0.5;
        if (p.x < -20) { powerUps.splice(i, 1); continue; }
        if (rectCollide(p.x, p.y, 16, 16, player.x, player.y, PLAYER_W, PLAYER_H)) {
          collectPowerUp(p);
          powerUps.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.96;
        p.vy *= 0.96;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Terrain collision (top and bottom)
      const tIdx = Math.floor((scrollX % (terrain.top.length * 4)) / 4);
      if (tIdx >= 0 && tIdx < terrain.top.length) {
        const topH = terrain.top[tIdx % terrain.top.length];
        const botH = terrain.bottom[tIdx % terrain.bottom.length];
        if (!player.invuln) {
          if (player.y < topH - 5 || player.y + PLAYER_H > H - botH + 5) {
            // Only damage if deep in terrain
            if (player.y < topH - 10 || player.y + PLAYER_H > H - botH + 10) {
              playerHit();
            }
          }
        }
      }
    }

    function rectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    function spawnEnemy(type, pattern, idx, total) {
      if (gameState !== 'playing') return;
      const e = {
        type, x: W + 20, y: 0, vx: -2, vy: 0,
        hp: 1, points: 10, tick: 0,
        w: 20, h: 16, baseY: 0, phase: idx * 0.5,
        shootTimer: 60 + Math.floor(Math.random() * 60)
      };

      switch (type) {
        case 'scout':
          e.hp = 1; e.points = 10; e.w = 18; e.h = 14;
          e.vx = -2.5;
          if (pattern === 'sine') {
            e.y = H * 0.2 + (H * 0.6 / total) * idx;
            e.baseY = e.y;
            e.moveFn = 'sine';
          } else {
            e.y = 40 + (H - 80) * (idx / Math.max(total - 1, 1));
            e.moveFn = 'straight';
          }
          break;
        case 'drifter':
          e.hp = 2; e.points = 20; e.w = 22; e.h = 18;
          e.vx = -1.5;
          if (pattern === 'spread') {
            e.y = 30 + Math.random() * (H - 60);
            e.baseY = e.y;
          } else {
            e.y = H / 2;
            e.baseY = H / 2;
          }
          e.moveFn = 'drift';
          break;
        case 'charger':
          e.hp = 1; e.points = 25; e.w = 20; e.h = 12;
          e.vx = -1;
          e.y = 30 + Math.random() * (H - 60);
          e.moveFn = 'charge';
          e.charging = false;
          e.chargeTimer = 60 + Math.floor(Math.random() * 40);
          break;
        case 'turret':
          e.hp = 4; e.points = 40; e.w = 24; e.h = 24;
          e.vx = -0.8;
          if (pattern === 'fixed') {
            e.y = Math.random() < 0.5 ? 30 + Math.random() * 40 : H - 70 + Math.random() * 40;
          } else {
            e.y = 40 + Math.random() * (H - 80);
          }
          e.moveFn = 'turret';
          e.shootTimer = 30;
          break;
      }
      enemies.push(e);
    }

    function spawnSnake(segments) {
      if (gameState !== 'playing') return;
      const startY = 60 + Math.random() * (H - 120);
      for (let i = 0; i < segments; i++) {
        const e = {
          type: 'snake', x: W + 20 + i * 16, y: startY,
          vx: -2, vy: 0, hp: i === 0 ? 3 : 1,
          points: i === 0 ? 50 : 10, tick: 0,
          w: 16, h: 14, baseY: startY,
          phase: i * 0.4, segIdx: i, isHead: i === 0,
          moveFn: 'snake', shootTimer: 999
        };
        enemies.push(e);
      }
    }

    function spawnBoss(bossType) {
      bossActive = true;
      if (bossType === 'dobkeratops') {
        boss = {
          type: 'dobkeratops', x: W - 100, y: H / 2 - 50,
          w: 80, h: 100, hp: 60, maxHp: 60, points: 500,
          tick: 0, phase: 0, parts: [
            { x: 0, y: -20, w: 30, h: 20, hp: 15, maxHp: 15, alive: true }, // top claw
            { x: 0, y: 80, w: 30, h: 20, hp: 15, maxHp: 15, alive: true }, // bottom claw
            { x: 30, y: 30, w: 20, h: 40, hp: 30, maxHp: 30, alive: true }, // core
          ]
        };
      } else {
        boss = {
          type: 'gomander', x: W - 80, y: H / 2 - 60,
          w: 70, h: 120, hp: 90, maxHp: 90, points: 800,
          tick: 0, phase: 0, parts: [
            { x: -10, y: 0, w: 25, h: 30, hp: 20, maxHp: 20, alive: true },
            { x: -10, y: 90, w: 25, h: 30, hp: 20, maxHp: 20, alive: true },
            { x: 20, y: 40, w: 30, h: 40, hp: 50, maxHp: 50, alive: true },
          ]
        };
      }
      // Boss also adds as an enemy for bullet collision
      enemies.push({
        type: 'boss', x: boss.x, y: boss.y,
        w: boss.w, h: boss.h, hp: boss.hp,
        points: 0, tick: 0, moveFn: 'boss',
        isBoss: true, shootTimer: 40
      });
    }

    function updateEnemy(e) {
      switch (e.moveFn) {
        case 'straight':
          e.x += e.vx;
          break;
        case 'sine':
          e.x += e.vx;
          e.y = e.baseY + Math.sin(e.tick * 0.04 + e.phase) * 40;
          break;
        case 'drift':
          e.x += e.vx;
          e.y = e.baseY + Math.sin(e.tick * 0.02 + e.phase) * 60;
          break;
        case 'charge':
          if (!e.charging) {
            e.x += e.vx;
            e.chargeTimer--;
            if (e.chargeTimer <= 0 && e.x < W - 60) {
              e.charging = true;
              // Aim at player
              const dx = player.x - e.x;
              const dy = player.y - e.y;
              const dist = Math.sqrt(dx * dx + dy * dy) || 1;
              e.vx = dx / dist * 5;
              e.vy = dy / dist * 5;
            }
          } else {
            e.x += e.vx;
            e.y += e.vy;
          }
          break;
        case 'turret':
          e.x += e.vx;
          e.shootTimer--;
          if (e.shootTimer <= 0 && e.x < W - 20) {
            e.shootTimer = 50 + Math.floor(Math.random() * 30);
            // Aimed shot
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            enemyBullets.push({
              x: e.x, y: e.y + e.h / 2,
              vx: dx / dist * 3, vy: dy / dist * 3
            });
          }
          break;
        case 'snake':
          e.x += e.vx;
          e.y = e.baseY + Math.sin(e.tick * 0.05 + e.phase) * 50;
          break;
        case 'boss':
          if (boss) {
            boss.tick++;
            // Oscillate
            boss.y = H / 2 - boss.h / 2 + Math.sin(boss.tick * 0.015) * 80;
            boss.x = W - boss.w - 20 + Math.sin(boss.tick * 0.01) * 30;
            e.x = boss.x; e.y = boss.y;
            e.hp = boss.hp;

            // Boss shooting
            e.shootTimer--;
            if (e.shootTimer <= 0) {
              e.shootTimer = 35 + Math.floor(Math.random() * 20);
              // Spread shot from boss
              const bx = boss.x;
              const by = boss.y + boss.h / 2;
              for (let a = -2; a <= 2; a++) {
                enemyBullets.push({
                  x: bx, y: by,
                  vx: -3, vy: a * 1.2
                });
              }
              // Parts shoot too
              boss.parts.forEach(p => {
                if (p.alive) {
                  const px = boss.x + p.x;
                  const py = boss.y + p.y + p.h / 2;
                  const dx = player.x - px;
                  const dy = player.y - py;
                  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                  enemyBullets.push({
                    x: px, y: py,
                    vx: dx / dist * 2.5, vy: dy / dist * 2.5
                  });
                }
              });
            }

            // Bullet vs boss parts
            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              for (const p of boss.parts) {
                if (!p.alive) continue;
                const px = boss.x + p.x, py = boss.y + p.y;
                if (rectCollide(b.x - 2, b.y - 2, 4, 4, px, py, p.w, p.h)) {
                  p.hp -= b.damage;
                  boss.hp -= b.damage;
                  bullets.splice(j, 1);
                  spawnParticles(b.x, b.y, '#f80', 3);
                  if (p.hp <= 0) {
                    p.alive = false;
                    spawnParticles(px + p.w / 2, py + p.h / 2, '#ff0', 10);
                    score += 100;
                    scoreEl.textContent = score;
                  }
                  break;
                }
              }
            }
          }
          break;
      }

      // Regular enemy shooting
      if (e.moveFn !== 'boss' && e.moveFn !== 'snake') {
        e.shootTimer--;
        if (e.shootTimer <= 0 && e.x > 20 && e.x < W - 20) {
          e.shootTimer = 80 + Math.floor(Math.random() * 60);
          if (e.type === 'drifter') {
            // Triple shot
            for (let a = -1; a <= 1; a++) {
              enemyBullets.push({ x: e.x, y: e.y + (e.h || 16) / 2, vx: -3, vy: a * 1.5 });
            }
          } else {
            enemyBullets.push({ x: e.x, y: e.y + (e.h || 16) / 2, vx: -3.5, vy: 0 });
          }
        }
      }
    }

    function destroyEnemy(e, idx) {
      score += e.points;
      scoreEl.textContent = score;
      if (score > best) { best = score; if (bestEl) bestEl.textContent = best; }
      const color = e.type === 'scout' ? '#4f4' : e.type === 'drifter' ? '#48f' :
                    e.type === 'charger' ? '#f80' : e.type === 'turret' ? '#f44' :
                    e.type === 'snake' ? '#a4f' : '#ff0';
      spawnParticles(e.x + (e.w || 20) / 2, e.y + (e.h || 16) / 2, color, 8);
    }

    function playerHit() {
      if (player.invuln > 0) return;
      lives--;
      livesEl.textContent = lives;
      spawnParticles(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#f8e', 15);

      if (lives <= 0) {
        gameOver();
        return;
      }

      // Reset position, give invulnerability
      player.x = 60;
      player.y = H / 2;
      player.invuln = 120;
      player.weapon = 'normal';
      player.speedBoost = false;
      // Detach force pod but keep it
      if (forcePod) {
        forcePod.attached = false;
        forcePod.x = player.x + 40;
        forcePod.y = player.y;
      }
      chargeTime = 0;
      charging = false;
    }

    function gameOver() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} — Press any key to restart`;
    }

    function fire() {
      if (gameState !== 'playing') return;
      bullets.push({
        x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 1,
        vx: 7, vy: 0, damage: 1, type: 'normal', life: 120
      });
    }

    function fireCharged() {
      if (gameState !== 'playing') return;
      const power = chargeTime / chargeMax;
      if (power < 0.2) {
        // Weak, just a normal shot
        fire();
      } else if (power < 0.6) {
        // Medium charge
        bullets.push({
          x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 3,
          vx: 8, vy: 0, damage: 3, type: 'charge_med', life: 150
        });
      } else {
        // Full charge beam
        bullets.push({
          x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 5,
          vx: 6, vy: 0, damage: 8, type: 'charge_full', life: 180
        });
      }
      chargeTime = 0;
    }

    function fireWeapon() {
      if (gameState !== 'playing') return;
      switch (player.weapon) {
        case 'wave':
          bullets.push({
            x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 1,
            vx: 5, vy: 0, damage: 1, type: 'wave', life: 100,
            amplitude: 0, wavePhase: tick * 0.1
          });
          break;
        case 'bounce':
          bullets.push({
            x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 1,
            vx: 5, vy: 2.5, damage: 1, type: 'bounce', life: 200
          });
          bullets.push({
            x: player.x + PLAYER_W, y: player.y + PLAYER_H / 2 - 1,
            vx: 5, vy: -2.5, damage: 1, type: 'bounce', life: 200
          });
          break;
        default:
          fire();
          break;
      }
    }

    function spawnPowerUp(puType) {
      powerUps.push({
        type: puType,
        x: W + 10,
        y: 60 + Math.random() * (H - 120),
        tick: 0
      });
    }

    function collectPowerUp(p) {
      score += 50;
      scoreEl.textContent = score;
      spawnParticles(p.x + 8, p.y + 8, '#ff0', 8);
      switch (p.type) {
        case PU_FORCE:
          if (!forcePod) {
            forcePod = { x: p.x, y: p.y, attached: false, front: true };
          } else {
            // Toggle front/back
            forcePod.front = !forcePod.front;
          }
          break;
        case PU_WAVE:
          player.weapon = 'wave';
          break;
        case PU_BOUNCE:
          player.weapon = 'bounce';
          break;
        case PU_SPEED:
          player.speedBoost = true;
          break;
      }
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 0.5 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.floor(Math.random() * 15),
          color
        });
      }
    }

    // Update wave bullets (sine motion)
    function updateWaveBullets() {
      bullets.forEach(b => {
        if (b.type === 'wave') {
          b.amplitude += 0.15;
          b.y += Math.sin(b.amplitude + b.wavePhase) * 3;
        }
      });
    }

    // ── Drawing ──────────────────────────────────────────────
    function drawFrame() {
      // Background
      ctx.fillStyle = '#0a0a18';
      ctx.fillRect(0, 0, W, H);

      // Stars
      starField.forEach(s => {
        const alpha = s.brightness / 100;
        ctx.fillStyle = `rgba(200, 200, 255, ${alpha})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      });

      // Terrain
      drawTerrain();

      // Power-ups
      powerUps.forEach(p => {
        p.tick++;
        const pulse = Math.sin(p.tick * 0.1) * 0.3 + 0.7;
        const colors = ['#f8e', '#4ef', '#a4f', '#ff0'];
        const labels = ['F', 'W', 'B', 'S'];
        ctx.fillStyle = colors[p.type];
        ctx.shadowColor = colors[p.type];
        ctx.shadowBlur = 8 * pulse;
        ctx.beginPath();
        ctx.arc(p.x + 8, p.y + 8, 9, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(labels[p.type], p.x + 8, p.y + 12);
      });

      // Enemies
      enemies.forEach(e => {
        if (e.moveFn === 'boss') return; // drawn separately
        drawEnemy(e);
      });

      // Boss
      if (boss) drawBoss();

      // Force pod
      if (forcePod) {
        ctx.fillStyle = '#f8e';
        ctx.shadowColor = '#f8e';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(forcePod.x + 6, forcePod.y + 6, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#faf';
        ctx.beginPath();
        ctx.arc(forcePod.x + 6, forcePod.y + 6, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Player
      if (gameState === 'playing' || gameState === 'waiting') {
        if (player.invuln > 0 && tick % 4 < 2) {
          // Flicker when invulnerable
        } else {
          drawPlayer();
        }
      }

      // Bullets
      bullets.forEach(b => {
        switch (b.type) {
          case 'normal':
          case 'force':
            ctx.fillStyle = b.type === 'force' ? '#faf' : '#f8e';
            ctx.shadowColor = '#f8e';
            ctx.shadowBlur = 6;
            ctx.fillRect(b.x, b.y, 8, 3);
            break;
          case 'charge_med':
            ctx.fillStyle = '#faf';
            ctx.shadowColor = '#f8e';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(b.x + 8, b.y + 3, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'charge_full':
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#f8e';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.ellipse(b.x + 12, b.y + 5, 16, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fce';
            ctx.beginPath();
            ctx.ellipse(b.x + 12, b.y + 5, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'wave':
            ctx.fillStyle = '#4ef';
            ctx.shadowColor = '#4ef';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(b.x + 4, b.y + 1, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'bounce':
            ctx.fillStyle = '#a4f';
            ctx.shadowColor = '#a4f';
            ctx.shadowBlur = 6;
            ctx.fillRect(b.x, b.y, 6, 3);
            break;
        }
        ctx.shadowBlur = 0;
      });

      // Enemy bullets
      enemyBullets.forEach(b => {
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Particles
      particles.forEach(p => {
        const alpha = Math.min(1, p.life / 15);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
      });
      ctx.globalAlpha = 1;

      // Charge indicator on ship
      if (charging && chargeTime > 5) {
        const power = chargeTime / chargeMax;
        const r = 3 + power * 10;
        ctx.strokeStyle = power > 0.6 ? '#fff' : '#f8e';
        ctx.shadowColor = '#f8e';
        ctx.shadowBlur = power * 15;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x + PLAYER_W + 2, player.y + PLAYER_H / 2, r, 0, Math.PI * 2 * power);
        ctx.stroke();
        // Inner glow
        if (power > 0.3) {
          ctx.fillStyle = `rgba(255, 136, 238, ${power * 0.4})`;
          ctx.beginPath();
          ctx.arc(player.x + PLAYER_W + 2, player.y + PLAYER_H / 2, r * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }

      // Wave intro text
      if (waveIntroTimer > 0) {
        const alpha = Math.min(1, waveIntroTimer / 30);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#f8e';
        ctx.shadowColor = '#f8e';
        ctx.shadowBlur = 15;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(waveIntroText, W / 2, H / 2 - 10);
        ctx.font = '14px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText(`Wave ${wave}`, W / 2, H / 2 + 15);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctx.textAlign = 'left';
      }

      // Boss health bar
      if (boss) {
        const barW = 200, barH = 8;
        const bx = W / 2 - barW / 2, by = 10;
        ctx.fillStyle = '#400';
        ctx.fillRect(bx, by, barW, barH);
        const hpPct = Math.max(0, boss.hp / boss.maxHp);
        ctx.fillStyle = hpPct > 0.5 ? '#f8e' : hpPct > 0.25 ? '#f80' : '#f44';
        ctx.fillRect(bx, by, barW * hpPct, barH);
        ctx.strokeStyle = '#f8e';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, by, barW, barH);
        ctx.fillStyle = '#fff';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(boss.type.toUpperCase(), W / 2, by + barH + 12);
        ctx.textAlign = 'left';
      }

      // Lives display
      for (let i = 0; i < lives - 1; i++) {
        const lx = W - 30 - i * 18;
        const ly = H - 15;
        ctx.fillStyle = '#f8e';
        ctx.shadowColor = '#f8e';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(lx + 10, ly);
        ctx.lineTo(lx, ly + 6);
        ctx.lineTo(lx + 4, ly + 8);
        ctx.lineTo(lx + 10, ly + 4);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      updateWaveBullets();
    }

    function drawPlayer() {
      const px = player.x, py = player.y;
      // Ship body
      ctx.fillStyle = '#dde';
      ctx.shadowColor = '#f8e';
      ctx.shadowBlur = 8;
      // Main hull
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W + 4, py + PLAYER_H / 2); // nose
      ctx.lineTo(px + PLAYER_W - 4, py);
      ctx.lineTo(px + 6, py + 1);
      ctx.lineTo(px, py + PLAYER_H / 2 - 2);
      ctx.lineTo(px, py + PLAYER_H / 2 + 2);
      ctx.lineTo(px + 6, py + PLAYER_H - 1);
      ctx.lineTo(px + PLAYER_W - 4, py + PLAYER_H);
      ctx.closePath();
      ctx.fill();
      // Cockpit
      ctx.fillStyle = '#4ef';
      ctx.beginPath();
      ctx.ellipse(px + PLAYER_W - 6, py + PLAYER_H / 2, 4, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      // Engine glow
      ctx.fillStyle = '#f84';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 10;
      ctx.fillRect(px - 4, py + PLAYER_H / 2 - 2, 5, 4);
      ctx.shadowBlur = 0;
      // Wing accents
      ctx.fillStyle = '#f8e';
      ctx.fillRect(px + 8, py, 10, 2);
      ctx.fillRect(px + 8, py + PLAYER_H - 2, 10, 2);
    }

    function drawEnemy(e) {
      const ex = e.x, ey = e.y;
      switch (e.type) {
        case 'scout':
          ctx.fillStyle = '#4f4';
          ctx.shadowColor = '#4f4';
          ctx.shadowBlur = 6;
          // Bug-like shape
          ctx.beginPath();
          ctx.moveTo(ex, ey + e.h / 2);
          ctx.lineTo(ex + 6, ey);
          ctx.lineTo(ex + e.w - 4, ey + 2);
          ctx.lineTo(ex + e.w, ey + e.h / 2);
          ctx.lineTo(ex + e.w - 4, ey + e.h - 2);
          ctx.lineTo(ex + 6, ey + e.h);
          ctx.closePath();
          ctx.fill();
          // Eye
          ctx.fillStyle = '#ff0';
          ctx.beginPath();
          ctx.arc(ex + 5, ey + e.h / 2, 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'drifter':
          ctx.fillStyle = '#48f';
          ctx.shadowColor = '#48f';
          ctx.shadowBlur = 8;
          // Jellyfish-like
          ctx.beginPath();
          ctx.arc(ex + e.w / 2, ey + 8, e.w / 2, Math.PI, 0);
          ctx.lineTo(ex + e.w, ey + e.h - 4);
          const wobble = Math.sin(e.tick * 0.1);
          for (let t = e.w; t >= 0; t -= 4) {
            ctx.lineTo(ex + t, ey + e.h - 4 + Math.sin(t * 0.5 + wobble) * 3);
          }
          ctx.closePath();
          ctx.fill();
          // Eyes
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(ex + 7, ey + 7, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(ex + e.w - 7, ey + 7, 2.5, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'charger':
          ctx.fillStyle = e.charging ? '#f44' : '#f80';
          ctx.shadowColor = e.charging ? '#f44' : '#f80';
          ctx.shadowBlur = e.charging ? 12 : 6;
          // Arrow shape
          ctx.beginPath();
          ctx.moveTo(ex, ey + e.h / 2);
          ctx.lineTo(ex + 8, ey);
          ctx.lineTo(ex + e.w, ey + 2);
          ctx.lineTo(ex + e.w + 4, ey + e.h / 2);
          ctx.lineTo(ex + e.w, ey + e.h - 2);
          ctx.lineTo(ex + 8, ey + e.h);
          ctx.closePath();
          ctx.fill();
          break;
        case 'turret':
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 6;
          // Organic turret
          ctx.beginPath();
          ctx.arc(ex + e.w / 2, ey + e.h / 2, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
          // Gun barrel
          ctx.fillStyle = '#a22';
          const aimDx = player.x - ex;
          const aimDy = player.y - ey;
          const aimDist = Math.sqrt(aimDx * aimDx + aimDy * aimDy) || 1;
          ctx.save();
          ctx.translate(ex + e.w / 2, ey + e.h / 2);
          ctx.rotate(Math.atan2(aimDy / aimDist, aimDx / aimDist));
          ctx.fillRect(0, -2, 14, 4);
          ctx.restore();
          // Core
          ctx.fillStyle = '#ff0';
          ctx.beginPath();
          ctx.arc(ex + e.w / 2, ey + e.h / 2, 4, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'snake':
          const snakeColor = e.isHead ? '#c6f' : '#a4f';
          ctx.fillStyle = snakeColor;
          ctx.shadowColor = '#a4f';
          ctx.shadowBlur = 5;
          ctx.beginPath();
          ctx.arc(ex + e.w / 2, ey + e.h / 2, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
          if (e.isHead) {
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.arc(ex + 4, ey + e.h / 2 - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ex + 4, ey + e.h / 2 + 2, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
      }
      ctx.shadowBlur = 0;
    }

    function drawBoss() {
      const bx = boss.x, by = boss.y;
      const pulse = Math.sin(tick * 0.05) * 0.15 + 0.85;

      if (boss.type === 'dobkeratops') {
        // Main body - organic mass
        ctx.fillStyle = `rgba(180, 60, 60, ${pulse})`;
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.ellipse(bx + boss.w / 2, by + boss.h / 2, boss.w / 2 - 5, boss.h / 2 - 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Organic texture
        ctx.fillStyle = `rgba(200, 80, 80, ${pulse})`;
        for (let i = 0; i < 6; i++) {
          const ox = bx + 10 + Math.sin(tick * 0.02 + i) * 15 + i * 8;
          const oy = by + 20 + Math.cos(tick * 0.03 + i * 2) * 12 + i * 10;
          ctx.beginPath();
          ctx.arc(ox, oy, 6 + Math.sin(i) * 3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Core weak point
        const corePart = boss.parts[2];
        if (corePart.alive) {
          ctx.fillStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(bx + corePart.x + corePart.w / 2, by + corePart.y + corePart.h / 2,
                  12 + Math.sin(tick * 0.08) * 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#f80';
          ctx.beginPath();
          ctx.arc(bx + corePart.x + corePart.w / 2, by + corePart.y + corePart.h / 2, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Claws
        boss.parts.slice(0, 2).forEach((p, i) => {
          if (!p.alive) return;
          const px = bx + p.x, py = by + p.y;
          const clawWobble = Math.sin(tick * 0.04 + i * Math.PI) * 8;
          ctx.fillStyle = '#a33';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.moveTo(px + p.w, py + p.h / 2);
          ctx.lineTo(px + 5, py + clawWobble);
          ctx.lineTo(px - 15, py + p.h / 2 + clawWobble * 0.5);
          ctx.lineTo(px + 5, py + p.h + clawWobble);
          ctx.closePath();
          ctx.fill();
        });

        // Eye
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#f8e';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(bx + 20, by + boss.h / 2, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(bx + 18, by + boss.h / 2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(bx + 17, by + boss.h / 2, 2, 0, Math.PI * 2);
        ctx.fill();

      } else {
        // Gomander - serpentine boss
        ctx.fillStyle = `rgba(100, 180, 60, ${pulse})`;
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 15;
        // Body segments
        for (let i = 0; i < 8; i++) {
          const sx = bx + boss.w / 2 + Math.sin(tick * 0.02 + i * 0.8) * 20;
          const sy = by + i * 15 + Math.cos(tick * 0.015 + i * 0.6) * 5;
          ctx.beginPath();
          ctx.ellipse(sx, sy, 18 - i * 0.5, 10, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Mouth parts
        boss.parts.slice(0, 2).forEach((p, i) => {
          if (!p.alive) return;
          const px = bx + p.x, py = by + p.y;
          const jawMove = Math.sin(tick * 0.06) * 5 * (i === 0 ? -1 : 1);
          ctx.fillStyle = '#6b3';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.moveTo(px + p.w, py + p.h / 2);
          ctx.lineTo(px, py + jawMove);
          ctx.lineTo(px - 20, py + p.h / 2 + jawMove);
          ctx.lineTo(px, py + p.h + jawMove);
          ctx.closePath();
          ctx.fill();
          // Teeth
          ctx.fillStyle = '#fff';
          for (let t = 0; t < 3; t++) {
            ctx.fillRect(px - 15 + t * 7, py + p.h / 2 + jawMove - 2, 3, 4);
          }
        });

        // Core
        const core = boss.parts[2];
        if (core.alive) {
          ctx.fillStyle = '#f84';
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(bx + core.x + core.w / 2, by + core.y + core.h / 2,
                  14 + Math.sin(tick * 0.1) * 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#ff0';
          ctx.beginPath();
          ctx.arc(bx + core.x + core.w / 2, by + core.y + core.h / 2, 7, 0, Math.PI * 2);
          ctx.fill();
        }

        // Eyes
        for (let i = 0; i < 2; i++) {
          const ex = bx + 15, ey = by + 30 + i * 60;
          ctx.fillStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(ex, ey, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(ex - 1, ey, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.shadowBlur = 0;
    }

    function drawTerrain() {
      const tOffset = Math.floor(scrollX / 4) % terrain.top.length;

      // Top terrain
      ctx.fillStyle = '#12162a';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      for (let x = 0; x <= W; x += 4) {
        const idx = (tOffset + Math.floor(x / 4)) % terrain.top.length;
        ctx.lineTo(x, terrain.top[idx]);
      }
      ctx.lineTo(W, 0);
      ctx.closePath();
      ctx.fill();

      // Top terrain edge glow
      ctx.strokeStyle = 'rgba(255, 136, 238, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= W; x += 4) {
        const idx = (tOffset + Math.floor(x / 4)) % terrain.top.length;
        if (x === 0) ctx.moveTo(x, terrain.top[idx]);
        else ctx.lineTo(x, terrain.top[idx]);
      }
      ctx.stroke();

      // Bottom terrain
      ctx.fillStyle = '#12162a';
      ctx.beginPath();
      ctx.moveTo(0, H);
      for (let x = 0; x <= W; x += 4) {
        const idx = (tOffset + Math.floor(x / 4)) % terrain.bottom.length;
        ctx.lineTo(x, H - terrain.bottom[idx]);
      }
      ctx.lineTo(W, H);
      ctx.closePath();
      ctx.fill();

      // Bottom terrain edge glow
      ctx.strokeStyle = 'rgba(255, 136, 238, 0.15)';
      ctx.beginPath();
      for (let x = 0; x <= W; x += 4) {
        const idx = (tOffset + Math.floor(x / 4)) % terrain.bottom.length;
        if (x === 0) ctx.moveTo(x, H - terrain.bottom[idx]);
        else ctx.lineTo(x, H - terrain.bottom[idx]);
      }
      ctx.stroke();
    }

    // Auto-fire timer for held space
    let autoFireTimer = 0;
    const AUTO_FIRE_RATE = 8;

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') { startGame(); }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;

      if (e.key === ' ' && gameState === 'playing') {
        if (!charging) {
          charging = true;
          chargeTime = 0;
          fireWeapon(); // Immediate shot on press
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;

      if (e.key === ' ' && charging && gameState === 'playing') {
        charging = false;
        if (chargeTime > 15) {
          fireCharged();
        }
        chargeTime = 0;
      }
    });

    // Expose game data for ML
    window.gameData = {};
    setInterval(() => {
      if (gameState === 'playing') {
        window.gameData = {
          playerX: player.x,
          playerY: player.y,
          enemyCount: enemies.length,
          bulletCount: enemyBullets.length,
          charging: charging,
          chargeLevel: chargeTime / chargeMax,
          hasForcePod: !!forcePod,
          weapon: player.weapon,
          wave: wave,
          lives: lives
        };
      }
    }, 200);

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Sprint</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #ae4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 238, 68, 0.5); }
    h1 { color: #ae4; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 238, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ae4; }
    canvas {
      border: 2px solid #ae4;
      box-shadow: 0 0 20px rgba(170, 238, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ae4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SUPER SPRINT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">SUPER SPRINT</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // ── Track definition ──
    // Tracks are defined as a series of waypoints forming a closed loop.
    // The track is rendered as a wide path between inner and outer boundaries.
    const TRACK_WIDTH = 80;

    const tracks = [
      // Track 0: Oval
      {
        name: 'OVAL SPEEDWAY',
        waypoints: [
          {x: 300, y: 80}, {x: 460, y: 100}, {x: 530, y: 180},
          {x: 550, y: 300}, {x: 530, y: 420}, {x: 460, y: 500},
          {x: 300, y: 520}, {x: 140, y: 500}, {x: 70, y: 420},
          {x: 50, y: 300}, {x: 70, y: 180}, {x: 140, y: 100}
        ],
        startIdx: 0,
        lapsToWin: 3
      },
      // Track 1: Figure-8 ish
      {
        name: 'FIGURE EIGHT',
        waypoints: [
          {x: 300, y: 60}, {x: 480, y: 80}, {x: 540, y: 160},
          {x: 500, y: 260}, {x: 380, y: 300}, {x: 300, y: 300},
          {x: 220, y: 300}, {x: 100, y: 340}, {x: 60, y: 440},
          {x: 120, y: 520}, {x: 300, y: 540}, {x: 480, y: 520},
          {x: 540, y: 440}, {x: 500, y: 340}, {x: 380, y: 300},
          {x: 300, y: 300}, {x: 220, y: 300}, {x: 100, y: 260},
          {x: 60, y: 160}, {x: 120, y: 80}
        ],
        startIdx: 0,
        lapsToWin: 2
      },
      // Track 2: Tight corners
      {
        name: 'GRAND PRIX',
        waypoints: [
          {x: 100, y: 80}, {x: 300, y: 60}, {x: 500, y: 80},
          {x: 540, y: 150}, {x: 520, y: 230}, {x: 400, y: 260},
          {x: 350, y: 300}, {x: 380, y: 360}, {x: 530, y: 380},
          {x: 550, y: 460}, {x: 500, y: 530}, {x: 300, y: 550},
          {x: 100, y: 530}, {x: 60, y: 460}, {x: 80, y: 360},
          {x: 200, y: 320}, {x: 250, y: 280}, {x: 200, y: 230},
          {x: 80, y: 200}, {x: 60, y: 140}
        ],
        startIdx: 0,
        lapsToWin: 2
      }
    ];

    let currentTrack = 0;
    let track;

    // ── Car class ──
    const CAR_LENGTH = 18;
    const CAR_WIDTH = 10;

    class Car {
      constructor(color, glowColor, isPlayer) {
        this.color = color;
        this.glowColor = glowColor;
        this.isPlayer = isPlayer;
        this.x = 0;
        this.y = 0;
        this.angle = 0;
        this.speed = 0;
        this.maxSpeed = 3.0;
        this.acceleration = 0.08;
        this.braking = 0.05;
        this.friction = 0.02;
        this.turnSpeed = 0.04;
        this.waypointIdx = 0;
        this.lap = 0;
        this.passedHalf = false;
        this.finished = false;
        this.finishPosition = 0;
        this.spinTimer = 0;
        this.speedBoosts = 0;
        this.onOil = false;
      }

      reset(startWpIdx, offset) {
        const wp = track.waypoints[startWpIdx];
        const nextWp = track.waypoints[(startWpIdx + 1) % track.waypoints.length];
        this.angle = Math.atan2(nextWp.y - wp.y, nextWp.x - wp.x);
        // Offset cars perpendicular to track direction
        const perpAngle = this.angle + Math.PI / 2;
        this.x = wp.x + Math.cos(perpAngle) * offset;
        this.y = wp.y + Math.sin(perpAngle) * offset;
        this.speed = 0;
        this.waypointIdx = startWpIdx;
        this.lap = 0;
        this.passedHalf = false;
        this.finished = false;
        this.finishPosition = 0;
        this.spinTimer = 0;
        this.speedBoosts = 0;
        this.maxSpeed = 3.0;
        this.onOil = false;
      }

      getEffectiveMaxSpeed() {
        return this.maxSpeed + this.speedBoosts * 0.4;
      }

      update(steerLeft, steerRight, accelerate) {
        if (this.finished) return;

        if (this.spinTimer > 0) {
          this.spinTimer--;
          this.angle += 0.2;
          this.speed *= 0.95;
          return;
        }

        // Steering
        const turnMult = this.onOil ? 0.4 : 1.0;
        if (steerLeft) this.angle -= this.turnSpeed * turnMult * (0.5 + this.speed / this.getEffectiveMaxSpeed() * 0.5);
        if (steerRight) this.angle += this.turnSpeed * turnMult * (0.5 + this.speed / this.getEffectiveMaxSpeed() * 0.5);

        // Acceleration
        if (accelerate) {
          this.speed = Math.min(this.getEffectiveMaxSpeed(), this.speed + this.acceleration);
        } else {
          this.speed = Math.max(0, this.speed - this.braking);
        }

        // Friction
        this.speed = Math.max(0, this.speed - this.friction);

        // Move
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;

        // Keep on canvas
        this.x = Math.max(10, Math.min(W - 10, this.x));
        this.y = Math.max(10, Math.min(H - 10, this.y));

        // Check if off track (slow down)
        if (!this.isOnTrack()) {
          this.speed *= 0.92;
        }

        // Waypoint progression
        this.updateWaypoint();
      }

      isOnTrack() {
        // Check distance to nearest track segment
        const wps = track.waypoints;
        let minDist = Infinity;
        for (let i = 0; i < wps.length; i++) {
          const j = (i + 1) % wps.length;
          const d = distToSegment(this.x, this.y, wps[i].x, wps[i].y, wps[j].x, wps[j].y);
          if (d < minDist) minDist = d;
        }
        return minDist < TRACK_WIDTH / 2 + 10;
      }

      updateWaypoint() {
        const wps = track.waypoints;
        const nextIdx = (this.waypointIdx + 1) % wps.length;
        const wp = wps[nextIdx];
        const dx = wp.x - this.x;
        const dy = wp.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 50) {
          this.waypointIdx = nextIdx;

          // Check if passed halfway point
          const halfIdx = Math.floor(wps.length / 2);
          if (this.waypointIdx === halfIdx) {
            this.passedHalf = true;
          }

          // Check lap completion
          if (this.waypointIdx === track.startIdx && this.passedHalf) {
            this.lap++;
            this.passedHalf = false;

            if (this.isPlayer) {
              score += 100 * this.lap;
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }
            }
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Car body glow
        ctx.shadowColor = this.glowColor;
        ctx.shadowBlur = this.spinTimer > 0 ? 20 : 10;

        // Car body
        ctx.fillStyle = this.color;
        ctx.fillRect(-CAR_LENGTH / 2, -CAR_WIDTH / 2, CAR_LENGTH, CAR_WIDTH);

        // Windshield
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(CAR_LENGTH / 2 - 5, -CAR_WIDTH / 2 + 2, 3, CAR_WIDTH - 4);
        ctx.globalAlpha = 1.0;

        // Speed boost indicator
        if (this.speedBoosts > 0) {
          ctx.fillStyle = '#ff0';
          for (let i = 0; i < this.speedBoosts; i++) {
            ctx.fillRect(-CAR_LENGTH / 2 - 3, -CAR_WIDTH / 2 + 2 + i * 4, 2, 3);
          }
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // ── AI Controller ──
    class AIController {
      constructor(car, skillLevel) {
        this.car = car;
        this.skillLevel = skillLevel; // 0.0 to 1.0
        this.lookAhead = 2;
        this.wobbleTimer = 0;
        this.wobbleDir = 0;
      }

      update() {
        if (this.car.finished || this.car.spinTimer > 0) return;

        const wps = track.waypoints;
        // Look ahead a couple waypoints
        const targetIdx = (this.car.waypointIdx + this.lookAhead) % wps.length;
        const target = wps[targetIdx];

        const dx = target.x - this.car.x;
        const dy = target.y - this.car.y;
        let targetAngle = Math.atan2(dy, dx);

        // Add some wobble for imperfect driving
        this.wobbleTimer++;
        if (this.wobbleTimer > 30 + Math.random() * 30) {
          this.wobbleTimer = 0;
          this.wobbleDir = (Math.random() - 0.5) * (1.0 - this.skillLevel) * 0.3;
        }
        targetAngle += this.wobbleDir;

        // Calculate angle difference
        let angleDiff = targetAngle - this.car.angle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        const steerLeft = angleDiff < -0.05;
        const steerRight = angleDiff > 0.05;

        // Slow down for sharp turns
        const sharpTurn = Math.abs(angleDiff) > 0.5;
        const accelerate = !sharpTurn || this.car.speed < this.car.getEffectiveMaxSpeed() * 0.5;

        this.car.update(steerLeft, steerRight, accelerate);
      }
    }

    // ── Game objects ──
    let player, aiCars, aiControllers;
    let keys = {};
    let oilSlicks = [];
    let wrenches = [];
    let finishOrder = 0;
    let raceCountdown = 0;
    let lapDisplay = '';
    let particles = [];
    let trackSurface = null; // offscreen canvas for track

    // ── Utility functions ──
    function distToSegment(px, py, ax, ay, bx, by) {
      const dx = bx - ax, dy = by - ay;
      const lenSq = dx * dx + dy * dy;
      if (lenSq === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2);
      let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
      t = Math.max(0, Math.min(1, t));
      const projX = ax + t * dx, projY = ay + t * dy;
      return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
    }

    function pointOnTrack(x, y) {
      const wps = track.waypoints;
      for (let i = 0; i < wps.length; i++) {
        const j = (i + 1) % wps.length;
        if (distToSegment(x, y, wps[i].x, wps[i].y, wps[j].x, wps[j].y) < TRACK_WIDTH / 2 - 10) {
          return true;
        }
      }
      return false;
    }

    function randomOnTrack() {
      const wps = track.waypoints;
      const segIdx = Math.floor(Math.random() * wps.length);
      const nextIdx = (segIdx + 1) % wps.length;
      const t = 0.2 + Math.random() * 0.6;
      const x = wps[segIdx].x + (wps[nextIdx].x - wps[segIdx].x) * t;
      const y = wps[segIdx].y + (wps[nextIdx].y - wps[segIdx].y) * t;
      // Add some perpendicular offset
      const angle = Math.atan2(wps[nextIdx].y - wps[segIdx].y, wps[nextIdx].x - wps[segIdx].x);
      const perpAngle = angle + Math.PI / 2;
      const offset = (Math.random() - 0.5) * (TRACK_WIDTH * 0.4);
      return {x: x + Math.cos(perpAngle) * offset, y: y + Math.sin(perpAngle) * offset, segIdx};
    }

    // ── Pre-render track surface ──
    function renderTrackSurface() {
      trackSurface = document.createElement('canvas');
      trackSurface.width = W;
      trackSurface.height = H;
      const tc = trackSurface.getContext('2d');

      // Background
      tc.fillStyle = '#1a1a2e';
      tc.fillRect(0, 0, W, H);

      // Draw grass/terrain texture dots
      for (let i = 0; i < 200; i++) {
        tc.fillStyle = `rgba(20, 60, 20, ${0.3 + Math.random() * 0.3})`;
        tc.fillRect(Math.random() * W, Math.random() * H, 2, 2);
      }

      const wps = track.waypoints;

      // Track surface (dark gray)
      tc.strokeStyle = '#2a2a3e';
      tc.lineWidth = TRACK_WIDTH;
      tc.lineCap = 'round';
      tc.lineJoin = 'round';
      tc.beginPath();
      tc.moveTo(wps[0].x, wps[0].y);
      for (let i = 1; i < wps.length; i++) {
        tc.lineTo(wps[i].x, wps[i].y);
      }
      tc.closePath();
      tc.stroke();

      // Track borders (neon lines)
      // Outer border
      tc.strokeStyle = '#ae4';
      tc.lineWidth = 2;
      tc.globalAlpha = 0.5;
      tc.setLineDash([8, 8]);

      // Calculate inner and outer borders
      for (let border = -1; border <= 1; border += 2) {
        tc.beginPath();
        for (let i = 0; i <= wps.length; i++) {
          const idx = i % wps.length;
          const prevIdx = (idx - 1 + wps.length) % wps.length;
          const nextIdx = (idx + 1) % wps.length;

          // Average direction
          const dx1 = wps[idx].x - wps[prevIdx].x;
          const dy1 = wps[idx].y - wps[prevIdx].y;
          const dx2 = wps[nextIdx].x - wps[idx].x;
          const dy2 = wps[nextIdx].y - wps[idx].y;
          const angle = Math.atan2(dy1 + dy2, dx1 + dx2);
          const perpAngle = angle + Math.PI / 2;

          const bx = wps[idx].x + Math.cos(perpAngle) * border * TRACK_WIDTH / 2;
          const by = wps[idx].y + Math.sin(perpAngle) * border * TRACK_WIDTH / 2;

          if (i === 0) tc.moveTo(bx, by);
          else tc.lineTo(bx, by);
        }
        tc.stroke();
      }

      tc.setLineDash([]);
      tc.globalAlpha = 1.0;

      // Start/finish line
      const startWp = wps[track.startIdx];
      const nextWp = wps[(track.startIdx + 1) % wps.length];
      const startAngle = Math.atan2(nextWp.y - startWp.y, nextWp.x - startWp.x);
      const perpA = startAngle + Math.PI / 2;

      tc.strokeStyle = '#fff';
      tc.lineWidth = 3;
      tc.setLineDash([]);
      tc.beginPath();
      tc.moveTo(startWp.x + Math.cos(perpA) * TRACK_WIDTH / 2,
                startWp.y + Math.sin(perpA) * TRACK_WIDTH / 2);
      tc.lineTo(startWp.x - Math.cos(perpA) * TRACK_WIDTH / 2,
                startWp.y - Math.sin(perpA) * TRACK_WIDTH / 2);
      tc.stroke();

      // Checkerboard pattern at start line
      const checkSize = 6;
      const numChecks = Math.floor(TRACK_WIDTH / checkSize);
      for (let c = 0; c < numChecks; c++) {
        const t = (c + 0.5) / numChecks - 0.5;
        const cx = startWp.x + Math.cos(perpA) * t * TRACK_WIDTH;
        const cy = startWp.y + Math.sin(perpA) * t * TRACK_WIDTH;
        if (c % 2 === 0) {
          tc.fillStyle = '#fff';
          tc.fillRect(cx - checkSize / 2, cy - checkSize / 2, checkSize, checkSize);
        }
      }
    }

    // ── Spawn obstacles and pickups ──
    function spawnTrackItems() {
      oilSlicks = [];
      wrenches = [];

      // Oil slicks
      const numOils = 3 + currentTrack;
      for (let i = 0; i < numOils; i++) {
        const pos = randomOnTrack();
        // Avoid spawning near start line
        if (pos.segIdx === track.startIdx || pos.segIdx === (track.startIdx + 1) % track.waypoints.length) continue;
        oilSlicks.push({x: pos.x, y: pos.y, radius: 12 + Math.random() * 8});
      }

      // Wrenches
      const numWrenches = 2 + currentTrack;
      for (let i = 0; i < numWrenches; i++) {
        const pos = randomOnTrack();
        if (pos.segIdx === track.startIdx) continue;
        wrenches.push({x: pos.x, y: pos.y, collected: false, respawnTimer: 0});
      }
    }

    // ── Init game ──
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SUPER SPRINT';
      overlayText.textContent = `Track: ${tracks[currentTrack].name}\nPress SPACE to race!`;
      particles = [];
      setupRace();
      draw();
    }

    function setupRace() {
      track = tracks[currentTrack];
      finishOrder = 0;

      // Create cars
      player = new Car('#ae4', '#ae4', true);
      player.reset(track.startIdx, -15);

      const ai1 = new Car('#f44', '#f44', false);
      ai1.reset(track.startIdx, 0);
      const ai2 = new Car('#48f', '#48f', false);
      ai2.reset(track.startIdx, 15);

      aiCars = [ai1, ai2];
      aiControllers = [
        new AIController(ai1, 0.6 + currentTrack * 0.1),
        new AIController(ai2, 0.5 + currentTrack * 0.1)
      ];

      renderTrackSurface();
      spawnTrackItems();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      raceCountdown = 180; // 3 second countdown at 60fps
      requestAnimationFrame(loop);
    }

    let lastTime = 0;
    function loop(timestamp) {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Countdown
      if (raceCountdown > 0) {
        raceCountdown--;
        return;
      }

      // ── Player input ──
      const steerL = keys['ArrowLeft'] || keys['a'];
      const steerR = keys['ArrowRight'] || keys['d'];
      const accel = keys['ArrowUp'] || keys['w'];
      player.update(steerL, steerR, accel);

      // ── AI updates ──
      aiControllers.forEach(ai => ai.update());

      // ── All cars: check collisions with items ──
      const allCars = [player, ...aiCars];

      allCars.forEach(car => {
        car.onOil = false;

        // Oil slick collisions
        oilSlicks.forEach(oil => {
          const dx = car.x - oil.x;
          const dy = car.y - oil.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < oil.radius + 8) {
            car.onOil = true;
            if (car.speed > 1.5 && car.spinTimer === 0 && Math.random() < 0.03) {
              car.spinTimer = 30;
              // Particles
              for (let i = 0; i < 5; i++) {
                particles.push({
                  x: car.x, y: car.y,
                  vx: (Math.random() - 0.5) * 3,
                  vy: (Math.random() - 0.5) * 3,
                  life: 20 + Math.random() * 20,
                  color: '#654'
                });
              }
            }
          }
        });

        // Wrench pickups
        wrenches.forEach(wr => {
          if (wr.collected) {
            wr.respawnTimer--;
            if (wr.respawnTimer <= 0) wr.collected = false;
            return;
          }
          const dx = car.x - wr.x;
          const dy = car.y - wr.y;
          if (Math.sqrt(dx * dx + dy * dy) < 15) {
            wr.collected = true;
            wr.respawnTimer = 300; // 5 seconds
            car.speedBoosts = Math.min(car.speedBoosts + 1, 3);
            if (car.isPlayer) {
              score += 25;
              scoreEl.textContent = score;
              if (score > best) { best = score; bestEl.textContent = best; }
            }
            // Sparkle particles
            for (let i = 0; i < 8; i++) {
              particles.push({
                x: wr.x, y: wr.y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 15 + Math.random() * 15,
                color: '#ff0'
              });
            }
          }
        });

        // Car-to-car collisions
        allCars.forEach(other => {
          if (other === car) return;
          const dx = car.x - other.x;
          const dy = car.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 16 && dist > 0) {
            // Push apart
            const nx = dx / dist, ny = dy / dist;
            const overlap = 16 - dist;
            car.x += nx * overlap * 0.5;
            car.y += ny * overlap * 0.5;
            other.x -= nx * overlap * 0.5;
            other.y -= ny * overlap * 0.5;
            // Speed exchange
            const avgSpeed = (car.speed + other.speed) * 0.5;
            car.speed = avgSpeed * 0.8;
            other.speed = avgSpeed * 0.8;
            // Sparks
            for (let i = 0; i < 3; i++) {
              particles.push({
                x: (car.x + other.x) / 2, y: (car.y + other.y) / 2,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                life: 10 + Math.random() * 10,
                color: '#fa0'
              });
            }
          }
        });
      });

      // ── Check lap/race completion ──
      allCars.forEach(car => {
        if (!car.finished && car.lap >= track.lapsToWin) {
          car.finished = true;
          finishOrder++;
          car.finishPosition = finishOrder;
          car.speed = 0;
        }
      });

      // Check if race is over (player finishes or all AI finish)
      if (player.finished) {
        // Player finished -- score based on position
        const posBonus = [0, 300, 150, 50];
        score += posBonus[player.finishPosition] || 0;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }

        // Advance to next track if player won
        if (player.finishPosition === 1 && currentTrack < tracks.length - 1) {
          currentTrack++;
          raceWon();
        } else {
          gameOver();
        }
        return;
      }

      // If both AI finished and player hasn't
      const allAiDone = aiCars.every(c => c.finished);
      if (allAiDone && !player.finished) {
        // Give player a few more seconds (120 frames)
        if (!player._graceTimer) player._graceTimer = 120;
        player._graceTimer--;
        if (player._graceTimer <= 0) {
          player.finished = true;
          finishOrder++;
          player.finishPosition = finishOrder;
          gameOver();
          return;
        }
      }

      // ── Update particles ──
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        return p.life > 0;
      });

      // ── Lap display ──
      lapDisplay = `Lap ${Math.min(player.lap + 1, track.lapsToWin)}/${track.lapsToWin}`;

      // ── Expose game data for ML ──
      window.gameData = {
        playerX: player.x, playerY: player.y,
        playerAngle: player.angle, playerSpeed: player.speed,
        playerLap: player.lap,
        ai: aiCars.map(c => ({x: c.x, y: c.y, lap: c.lap})),
        oilSlicks: oilSlicks.map(o => ({x: o.x, y: o.y})),
        wrenches: wrenches.filter(w => !w.collected).map(w => ({x: w.x, y: w.y}))
      };
    }

    function raceWon() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'RACE WON!';
      overlayText.textContent = `Score: ${score} — Next track: ${tracks[currentTrack].name}\nPress any key to continue`;
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      const posText = ['', '1st', '2nd', '3rd'];
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Finished ${posText[player.finishPosition] || 'DNF'} — Score: ${score}\nPress any key to restart`;
      currentTrack = 0; // Reset to first track
    }

    // ── Drawing ──
    function draw() {
      // Draw pre-rendered track
      if (trackSurface) {
        ctx.drawImage(trackSurface, 0, 0);
      } else {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);
      }

      // Oil slicks
      oilSlicks.forEach(oil => {
        ctx.beginPath();
        ctx.arc(oil.x, oil.y, oil.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(40, 30, 20, 0.7)';
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1;
        ctx.stroke();
        // Sheen effect
        ctx.beginPath();
        ctx.arc(oil.x - 2, oil.y - 2, oil.radius * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(80, 60, 100, 0.3)';
        ctx.fill();
      });

      // Wrenches
      wrenches.forEach(wr => {
        if (wr.collected) return;
        ctx.save();
        ctx.translate(wr.x, wr.y);
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        // Draw wrench shape
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        // Handle
        ctx.beginPath();
        ctx.moveTo(-5, 5);
        ctx.lineTo(3, -3);
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.arc(5, -5, 4, -0.5, 2.5);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();
      });

      // Particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
      });
      ctx.globalAlpha = 1.0;

      // Draw cars (AI first, player on top)
      aiCars.forEach(car => car.draw());
      player.draw();

      // ── HUD ──
      // Lap counter
      if (gameState === 'playing') {
        ctx.fillStyle = '#ae4';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.shadowColor = '#ae4';
        ctx.shadowBlur = 6;
        ctx.fillText(lapDisplay, 10, 25);

        // Track name
        ctx.font = '12px Courier New';
        ctx.fillStyle = '#888';
        ctx.shadowBlur = 0;
        ctx.fillText(track.name, 10, 42);

        // Speed indicator
        ctx.fillStyle = '#ae4';
        ctx.textAlign = 'right';
        ctx.shadowColor = '#ae4';
        ctx.shadowBlur = 4;
        const speedPct = Math.round(player.speed / player.getEffectiveMaxSpeed() * 100);
        ctx.fillText(`Speed: ${speedPct}%`, W - 10, 25);

        // Upgrade indicator
        if (player.speedBoosts > 0) {
          ctx.fillStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.fillText(`Upgrades: ${'*'.repeat(player.speedBoosts)}`, W - 10, 42);
        }
        ctx.shadowBlur = 0;

        // Position indicator
        const allCars = [player, ...aiCars];
        const sorted = [...allCars].sort((a, b) => {
          if (a.lap !== b.lap) return b.lap - a.lap;
          return b.waypointIdx - a.waypointIdx;
        });
        const pos = sorted.indexOf(player) + 1;
        const posText = ['', '1st', '2nd', '3rd'];
        ctx.fillStyle = pos === 1 ? '#ae4' : (pos === 2 ? '#ff0' : '#f44');
        ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 8;
        ctx.fillText(posText[pos], W / 2, 25);
        ctx.shadowBlur = 0;

        // Countdown
        if (raceCountdown > 0) {
          const countNum = Math.ceil(raceCountdown / 60);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 60px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = '#ae4';
          ctx.shadowBlur = 20;
          ctx.fillText(countNum > 0 ? countNum : 'GO!', W / 2, H / 2);
          ctx.shadowBlur = 0;
          ctx.textBaseline = 'alphabetic';
        }

        // Mini-map (bottom right)
        drawMinimap();
      }

      // ── Waiting screen track preview ──
      if (gameState === 'waiting') {
        // Draw cars at starting positions
        aiCars.forEach(car => car.draw());
        player.draw();
      }
    }

    function drawMinimap() {
      const mmSize = 100;
      const mmX = W - mmSize - 10;
      const mmY = H - mmSize - 10;
      const scale = mmSize / W;

      // Background
      ctx.fillStyle = 'rgba(16, 16, 30, 0.8)';
      ctx.fillRect(mmX, mmY, mmSize, mmSize);
      ctx.strokeStyle = '#ae4';
      ctx.globalAlpha = 0.3;
      ctx.lineWidth = 1;
      ctx.strokeRect(mmX, mmY, mmSize, mmSize);
      ctx.globalAlpha = 1.0;

      // Track
      const wps = track.waypoints;
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(mmX + wps[0].x * scale, mmY + wps[0].y * scale);
      for (let i = 1; i < wps.length; i++) {
        ctx.lineTo(mmX + wps[i].x * scale, mmY + wps[i].y * scale);
      }
      ctx.closePath();
      ctx.stroke();

      // Cars on minimap
      const allCars = [player, ...aiCars];
      allCars.forEach(car => {
        ctx.fillStyle = car.color;
        ctx.beginPath();
        ctx.arc(mmX + car.x * scale, mmY + car.y * scale, 2.5, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ── Keyboard ──
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        player._graceTimer = 0;
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puzzle Race</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #a4f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 68, 255, 0.5); }
    h1 { color: #a4f; font-size: 1.8rem; text-shadow: 0 0 15px rgba(170, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a4f; }
    canvas {
      border: 2px solid #a4f;
      box-shadow: 0 0 20px rgba(170, 68, 255, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a4f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(170, 68, 255, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PUZZLE RACE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">PUZZLE RACE</h2>
      <p id="overlayText">Click to Start — Solve Sudoku faster than the AI!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
        e.preventDefault();
      }
    });

    let gameState = 'waiting';
    let score = 0;
    let bestScore = 0;

    // ===== Sudoku generator =====

    // Generate a complete valid Sudoku solution using backtracking
    function generateSolution() {
      const grid = Array.from({length: 9}, () => Array(9).fill(0));

      function isValid(grid, row, col, num) {
        for (let i = 0; i < 9; i++) {
          if (grid[row][i] === num) return false;
          if (grid[i][col] === num) return false;
        }
        const br = Math.floor(row / 3) * 3;
        const bc = Math.floor(col / 3) * 3;
        for (let r = br; r < br + 3; r++) {
          for (let c = bc; c < bc + 3; c++) {
            if (grid[r][c] === num) return false;
          }
        }
        return true;
      }

      function solve(grid) {
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0) {
              const nums = shuffle([1,2,3,4,5,6,7,8,9]);
              for (const n of nums) {
                if (isValid(grid, r, c, n)) {
                  grid[r][c] = n;
                  if (solve(grid)) return true;
                  grid[r][c] = 0;
                }
              }
              return false;
            }
          }
        }
        return true;
      }

      solve(grid);
      return grid;
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Remove cells to create a puzzle. Aim for ~32 given cells (medium difficulty).
    function createPuzzle(solution) {
      const puzzle = solution.map(r => r.slice());
      const positions = shuffle(
        Array.from({length: 81}, (_, i) => [Math.floor(i / 9), i % 9])
      );

      let removed = 0;
      const targetRemoved = 49; // 81 - 32 = 49 cells removed, 32 given

      for (const [r, c] of positions) {
        if (removed >= targetRemoved) break;
        const backup = puzzle[r][c];
        puzzle[r][c] = 0;

        // Check unique solution with a fast solver
        if (countSolutions(puzzle.map(row => row.slice()), 2) === 1) {
          removed++;
        } else {
          puzzle[r][c] = backup;
        }
      }

      return puzzle;
    }

    // Count solutions up to 'limit'
    function countSolutions(grid, limit) {
      let count = 0;

      function isValid(grid, row, col, num) {
        for (let i = 0; i < 9; i++) {
          if (grid[row][i] === num) return false;
          if (grid[i][col] === num) return false;
        }
        const br = Math.floor(row / 3) * 3;
        const bc = Math.floor(col / 3) * 3;
        for (let r = br; r < br + 3; r++) {
          for (let c = bc; c < bc + 3; c++) {
            if (grid[r][c] === num) return false;
          }
        }
        return true;
      }

      function solve(grid) {
        if (count >= limit) return;
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0) {
              for (let n = 1; n <= 9; n++) {
                if (isValid(grid, r, c, n)) {
                  grid[r][c] = n;
                  solve(grid);
                  if (count >= limit) return;
                  grid[r][c] = 0;
                }
              }
              return;
            }
          }
        }
        count++;
      }

      solve(grid);
      return count;
    }

    // ===== Game state =====
    let solution = [];
    let puzzle = [];         // original given cells (0 = empty)
    let playerGrid = [];     // player's current grid
    let aiGrid = [];         // AI's current grid
    let playerPencil = [];   // pencil marks: [row][col] = Set of numbers
    let aiPencil = [];
    let selectedRow = -1;
    let selectedCol = -1;
    let timerStart = 0;
    let elapsed = 0;
    let playerRemaining = 0;
    let aiRemaining = 0;
    let aiSolveQueue = [];   // ordered list of cells for AI to solve
    let aiNextTime = 0;      // when AI fills next cell
    let winner = '';
    let playerErrors = [];   // [{row, col, time}] for flash effect
    let aiSpeed = 2500;      // ms between AI fills (2-3 seconds)

    // Layout constants
    const GRID_SIZE = 9;
    const TOP_BAR = 30;      // timer/status area at top of canvas
    const GAP = 40;          // gap between grids
    const CELL = 30;
    const GRID_PX = CELL * 9; // 270
    const LEFT_X = (W - GRID_PX * 2 - GAP) / 2;  // 10
    const RIGHT_X = LEFT_X + GRID_PX + GAP;       // 320
    const GRID_Y = 62;      // top of grid (leaves room for timer + label)

    function init() {
      solution = generateSolution();
      puzzle = createPuzzle(solution);
      playerGrid = puzzle.map(r => r.slice());
      aiGrid = puzzle.map(r => r.slice());
      playerPencil = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));
      aiPencil = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));
      selectedRow = -1;
      selectedCol = -1;
      timerStart = 0;
      elapsed = 0;
      winner = '';
      playerErrors = [];
      playerRemaining = countEmpty(playerGrid);
      aiRemaining = countEmpty(aiGrid);

      // Build AI solve order: logic-based ordering
      aiSolveQueue = buildAISolveOrder();
      aiNextTime = 0;

      score = 0;
      scoreEl.textContent = '0';
    }

    function countEmpty(grid) {
      let c = 0;
      for (let r = 0; r < 9; r++)
        for (let cc = 0; cc < 9; cc++)
          if (grid[r][cc] === 0) c++;
      return c;
    }

    // AI solving order: simulate logic-based solving (naked singles first, then hidden singles)
    function buildAISolveOrder() {
      const order = [];
      const tempGrid = puzzle.map(r => r.slice());
      const candidates = Array.from({length: 9}, (_, r) =>
        Array.from({length: 9}, (_, c) => {
          if (tempGrid[r][c] !== 0) return new Set();
          const s = new Set([1,2,3,4,5,6,7,8,9]);
          for (let i = 0; i < 9; i++) {
            s.delete(tempGrid[r][i]);
            s.delete(tempGrid[i][c]);
          }
          const br = Math.floor(r / 3) * 3, bc = Math.floor(c / 3) * 3;
          for (let rr = br; rr < br + 3; rr++)
            for (let cc = bc; cc < bc + 3; cc++)
              s.delete(tempGrid[rr][cc]);
          return s;
        })
      );

      let changed = true;
      while (changed) {
        changed = false;

        // Naked singles
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (tempGrid[r][c] === 0 && candidates[r][c].size === 1) {
              const val = [...candidates[r][c]][0];
              tempGrid[r][c] = val;
              order.push({row: r, col: c, val});
              candidates[r][c].clear();
              // Eliminate from peers
              for (let i = 0; i < 9; i++) {
                candidates[r][i].delete(val);
                candidates[i][c].delete(val);
              }
              const br = Math.floor(r / 3) * 3, bc = Math.floor(c / 3) * 3;
              for (let rr = br; rr < br + 3; rr++)
                for (let cc = bc; cc < bc + 3; cc++)
                  candidates[rr][cc].delete(val);
              changed = true;
            }
          }
        }

        // Hidden singles
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (tempGrid[r][c] !== 0) continue;
            for (const val of candidates[r][c]) {
              // Check row
              let unique = true;
              for (let i = 0; i < 9; i++) {
                if (i !== c && candidates[r][i].has(val)) { unique = false; break; }
              }
              if (!unique) {
                unique = true;
                for (let i = 0; i < 9; i++) {
                  if (i !== r && candidates[i][c].has(val)) { unique = false; break; }
                }
              }
              if (!unique) {
                unique = true;
                const br = Math.floor(r / 3) * 3, bc = Math.floor(c / 3) * 3;
                for (let rr = br; rr < br + 3; rr++)
                  for (let cc = bc; cc < bc + 3; cc++)
                    if (!(rr === r && cc === c) && candidates[rr][cc].has(val)) { unique = false; }
              }
              if (unique) {
                tempGrid[r][c] = val;
                order.push({row: r, col: c, val});
                candidates[r][c].clear();
                for (let i = 0; i < 9; i++) {
                  candidates[r][i].delete(val);
                  candidates[i][c].delete(val);
                }
                const br = Math.floor(r / 3) * 3, bc = Math.floor(c / 3) * 3;
                for (let rr = br; rr < br + 3; rr++)
                  for (let cc = bc; cc < bc + 3; cc++)
                    candidates[rr][cc].delete(val);
                changed = true;
                break;
              }
            }
          }
        }
      }

      // Any remaining cells (rare for medium puzzles) - fill from solution
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (tempGrid[r][c] === 0) {
            order.push({row: r, col: c, val: solution[r][c]});
          }
        }
      }

      return order;
    }

    function startGame() {
      gameState = 'playing';
      timerStart = performance.now();
      aiNextTime = timerStart + aiSpeed + Math.random() * 1000;
      overlay.style.display = 'none';
    }

    function endGame(who) {
      gameState = 'over';
      winner = who;
      const cellsToSolve = 81 - countGiven();
      const timeBonus = Math.max(0, 600 - Math.floor(elapsed));
      if (who === 'player') {
        // Player wins: cells solved * 10 + time bonus
        score = cellsToSolve * 10 + timeBonus;
      } else {
        // AI wins: partial credit for cells player filled correctly
        let correctCells = 0;
        for (let r = 0; r < 9; r++)
          for (let c = 0; c < 9; c++)
            if (puzzle[r][c] === 0 && playerGrid[r][c] === solution[r][c]) correctCells++;
        score = correctCells * 5;
      }
      scoreEl.textContent = score;
      if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = bestScore;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = who === 'player' ? 'YOU WIN!' : 'AI WINS!';
      const t = formatTime(elapsed);
      overlayText.textContent = who === 'player'
        ? `Completed in ${t} — Score: ${score} — Click to play again`
        : `AI finished in ${t} — Score: ${score} — Click to play again`;
    }

    function countGiven() {
      let c = 0;
      for (let r = 0; r < 9; r++)
        for (let cc = 0; cc < 9; cc++)
          if (puzzle[r][cc] !== 0) c++;
      return c;
    }

    function formatTime(secs) {
      const m = Math.floor(secs / 60);
      const s = Math.floor(secs % 60);
      return m + ':' + (s < 10 ? '0' : '') + s;
    }

    // ===== AI logic =====
    let aiQueueIndex = 0;

    function updateAI(now) {
      if (gameState !== 'playing') return;
      if (aiQueueIndex >= aiSolveQueue.length) return;
      if (now < aiNextTime) return;

      const step = aiSolveQueue[aiQueueIndex];
      aiGrid[step.row][step.col] = step.val;
      aiQueueIndex++;
      aiRemaining = countEmpty(aiGrid);

      // Vary AI speed slightly each step: 2-4 seconds
      aiNextTime = now + 2000 + Math.random() * 2000;

      if (aiRemaining === 0) {
        endGame('ai');
      }
    }

    // ===== Input handling =====
    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'over') {
        init();
        aiQueueIndex = 0;
        startGame();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      // Check if click is on player grid (left grid)
      if (mx >= LEFT_X && mx < LEFT_X + GRID_PX && my >= GRID_Y && my < GRID_Y + GRID_PX) {
        const col = Math.floor((mx - LEFT_X) / CELL);
        const row = Math.floor((my - GRID_Y) / CELL);
        if (row >= 0 && row < 9 && col >= 0 && col < 9) {
          // Can only select non-given cells
          if (puzzle[row][col] === 0) {
            selectedRow = row;
            selectedCol = col;
          } else {
            selectedRow = row;
            selectedCol = col;
          }
        }
      }
    });

    document.addEventListener('keydown', (e) => {
      if (gameState !== 'playing') return;
      if (selectedRow < 0 || selectedCol < 0) return;

      const r = selectedRow, c = selectedCol;

      // Arrow keys to move selection
      if (e.key === 'ArrowUp') { selectedRow = Math.max(0, selectedRow - 1); return; }
      if (e.key === 'ArrowDown') { selectedRow = Math.min(8, selectedRow + 1); return; }
      if (e.key === 'ArrowLeft') { selectedCol = Math.max(0, selectedCol - 1); return; }
      if (e.key === 'ArrowRight') { selectedCol = Math.min(8, selectedCol + 1); return; }

      // Delete/Backspace to clear
      if (e.key === 'Backspace' || e.key === 'Delete') {
        if (puzzle[r][c] === 0) {
          playerGrid[r][c] = 0;
          playerPencil[r][c].clear();
          playerRemaining = countEmpty(playerGrid);
        }
        return;
      }

      const num = parseInt(e.key);
      if (num >= 1 && num <= 9) {
        if (puzzle[r][c] !== 0) return; // can't modify given cells

        if (e.shiftKey) {
          // Pencil mark toggle
          if (playerPencil[r][c].has(num)) {
            playerPencil[r][c].delete(num);
          } else {
            playerPencil[r][c].add(num);
          }
          return;
        }

        // Place number
        playerPencil[r][c].clear();
        playerGrid[r][c] = num;

        // Check if correct
        if (num !== solution[r][c]) {
          playerErrors.push({row: r, col: c, time: performance.now()});
        } else {
          // Clear pencil marks in same row/col/box that contain this number
          for (let i = 0; i < 9; i++) {
            playerPencil[r][i].delete(num);
            playerPencil[i][c].delete(num);
          }
          const br = Math.floor(r / 3) * 3, bc = Math.floor(c / 3) * 3;
          for (let rr = br; rr < br + 3; rr++)
            for (let cc = bc; cc < bc + 3; cc++)
              playerPencil[rr][cc].delete(num);
        }

        playerRemaining = countEmpty(playerGrid);

        // Check if player won (all cells filled correctly)
        if (playerRemaining === 0) {
          let allCorrect = true;
          for (let rr = 0; rr < 9; rr++)
            for (let cc = 0; cc < 9; cc++)
              if (playerGrid[rr][cc] !== solution[rr][cc]) allCorrect = false;
          if (allCorrect) {
            endGame('player');
          }
        }
      }
    });

    // ===== Drawing =====
    function drawGrid(grid, pencilMarks, x0, y0, label, isPlayer, highlightRow, highlightCol) {
      const now = performance.now();

      // Grid background
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(x0, y0, GRID_PX, GRID_PX);

      // Highlight selected row/col/box for player
      if (isPlayer && highlightRow >= 0 && highlightCol >= 0) {
        ctx.fillStyle = 'rgba(170, 68, 255, 0.08)';
        // Row
        ctx.fillRect(x0, y0 + highlightRow * CELL, GRID_PX, CELL);
        // Col
        ctx.fillRect(x0 + highlightCol * CELL, y0, CELL, GRID_PX);
        // Box
        const br = Math.floor(highlightRow / 3) * 3;
        const bc = Math.floor(highlightCol / 3) * 3;
        ctx.fillStyle = 'rgba(170, 68, 255, 0.06)';
        ctx.fillRect(x0 + bc * CELL, y0 + br * CELL, CELL * 3, CELL * 3);

        // Selected cell
        ctx.fillStyle = 'rgba(170, 68, 255, 0.25)';
        ctx.fillRect(x0 + highlightCol * CELL, y0 + highlightRow * CELL, CELL, CELL);
      }

      // Draw cell borders (thin)
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= 9; r++) {
        ctx.beginPath();
        ctx.moveTo(x0, y0 + r * CELL);
        ctx.lineTo(x0 + GRID_PX, y0 + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= 9; c++) {
        ctx.beginPath();
        ctx.moveTo(x0 + c * CELL, y0);
        ctx.lineTo(x0 + c * CELL, y0 + GRID_PX);
        ctx.stroke();
      }

      // Draw 3x3 box borders (thick)
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      for (let r = 0; r <= 3; r++) {
        ctx.beginPath();
        ctx.moveTo(x0, y0 + r * CELL * 3);
        ctx.lineTo(x0 + GRID_PX, y0 + r * CELL * 3);
        ctx.stroke();
      }
      for (let c = 0; c <= 3; c++) {
        ctx.beginPath();
        ctx.moveTo(x0 + c * CELL * 3, y0);
        ctx.lineTo(x0 + c * CELL * 3, y0 + GRID_PX);
        ctx.stroke();
      }

      // Draw numbers
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cx = x0 + c * CELL + CELL / 2;
          const cy = y0 + r * CELL + CELL / 2;
          const val = grid[r][c];

          if (val !== 0) {
            if (puzzle[r][c] !== 0) {
              // Given cell
              ctx.fillStyle = '#e0e0e0';
              ctx.font = 'bold 14px "Courier New", monospace';
            } else if (val !== solution[r][c]) {
              // Error
              ctx.fillStyle = '#f44';
              ctx.font = '14px "Courier New", monospace';
              ctx.shadowColor = '#f44';
              ctx.shadowBlur = 6;
            } else {
              // Correct player/AI entry
              ctx.fillStyle = '#a4f';
              ctx.font = '14px "Courier New", monospace';
              ctx.shadowColor = '#a4f';
              ctx.shadowBlur = 4;
            }
            ctx.fillText(val.toString(), cx, cy);
            ctx.shadowBlur = 0;
          } else if (isPlayer && pencilMarks[r][c].size > 0) {
            // Draw pencil marks
            ctx.fillStyle = '#667';
            ctx.font = '7px "Courier New", monospace';
            for (const n of pencilMarks[r][c]) {
              const pr = Math.floor((n - 1) / 3);
              const pc = (n - 1) % 3;
              const px = x0 + c * CELL + 4 + pc * 8;
              const py = y0 + r * CELL + 5 + pr * 8;
              ctx.fillText(n.toString(), px + 3, py + 3);
            }
          }
        }
      }

      // Label
      ctx.fillStyle = isPlayer ? '#a4f' : '#f94';
      ctx.font = 'bold 12px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = isPlayer ? '#a4f' : '#f94';
      ctx.shadowBlur = 8;
      ctx.fillText(label, x0 + GRID_PX / 2, y0 - 8);
      ctx.shadowBlur = 0;
    }

    function draw() {
      const now = performance.now();

      // Clear canvas
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Timer bar at top
      if (gameState === 'playing') {
        elapsed = (now - timerStart) / 1000;
      }
      ctx.fillStyle = '#a4f';
      ctx.font = 'bold 16px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#a4f';
      ctx.shadowBlur = 10;
      ctx.fillText(formatTime(elapsed), W / 2, 18);
      ctx.shadowBlur = 0;

      // Remaining cells
      ctx.font = '11px "Courier New", monospace';
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left';
      ctx.fillText('Left: ' + playerRemaining, LEFT_X, 18);
      ctx.textAlign = 'right';
      ctx.fillText('Left: ' + aiRemaining, RIGHT_X + GRID_PX, 18);

      // Draw both grids
      drawGrid(playerGrid, playerPencil, LEFT_X, GRID_Y, 'YOU', true, selectedRow, selectedCol);
      drawGrid(aiGrid, aiPencil, RIGHT_X, GRID_Y, 'AI', false, -1, -1);

      // Divider
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      const divX = W / 2;
      ctx.beginPath();
      ctx.moveTo(divX, GRID_Y - 14);
      ctx.lineTo(divX, GRID_Y + GRID_PX + 4);
      ctx.stroke();
      ctx.setLineDash([]);

      // Controls help at bottom
      ctx.fillStyle = '#556';
      ctx.font = '10px "Courier New", monospace';
      ctx.textAlign = 'center';
      const helpY = GRID_Y + GRID_PX + 18;
      ctx.fillText('Click cell + type 1-9 | Shift+# for pencil | Backspace to clear | Arrows to move', W / 2, helpY);

      // Flash errors
      const errNow = performance.now();
      playerErrors = playerErrors.filter(err => errNow - err.time < 800);
      for (const err of playerErrors) {
        const alpha = 1 - (errNow - err.time) / 800;
        ctx.strokeStyle = `rgba(255, 68, 68, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(
          LEFT_X + err.col * CELL + 1,
          GRID_Y + err.row * CELL + 1,
          CELL - 2,
          CELL - 2
        );
      }
    }

    // ===== Game loop =====
    function gameLoop() {
      const now = performance.now();
      if (gameState === 'playing') {
        updateAI(now);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wizard Card Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f6a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 170, 0.5); }
    h1 { color: #f6a; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 102, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f6a; }
    canvas {
      border: 2px solid #f6a;
      box-shadow: 0 0 20px rgba(255, 102, 170, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f6a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WIZARD</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="score">0</span></div>
    <div id="roundInfo" style="color:#aaa;font-size:0.9rem;">Round 1/10</div>
    <div>AI: <span id="aiScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="450"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:450px;">
      <h2 id="overlayTitle">WIZARD</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 450;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const roundInfoEl = document.getElementById('roundInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    // ── Constants ──
    const SUITS = ['spades', 'hearts', 'diamonds', 'clubs'];
    const SUIT_SYMBOLS = { spades: '\u2660', hearts: '\u2665', diamonds: '\u2666', clubs: '\u2663' };
    const SUIT_COLORS = { spades: '#fff', hearts: '#f44', diamonds: '#f44', clubs: '#fff' };
    const RANK_NAMES = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    const RANK_VALUES = { '2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14 };
    const MAX_ROUNDS = 10;

    const CARD_W = 50, CARD_H = 70;

    // ── Game State ──
    let round = 1;
    let aiScore = 0;
    let playerHand = [];
    let aiHand = [];
    let trumpSuit = null; // null means no trump
    let trumpCard = null; // the flipped card
    let playerBid = -1;
    let aiBid = -1;
    let playerTricks = 0;
    let aiTricks = 0;
    let trickCards = []; // {card, player} for current trick
    let leadPlayer = 'player'; // who leads this trick
    let cardsPlayed = []; // all cards played this round for tracking
    let phase = 'idle'; // idle, bidding, pick-trump, playing, trick-result, round-result
    let bidOptions = [];
    let hoverCard = -1;
    let hoverBid = -1;
    let message = '';
    let messageTimer = 0;
    let trickResultTimer = 0;
    let dealer = 'ai'; // dealer alternates; non-dealer leads first trick & bids first
    let animFrame = 0;
    let trumpPickSuit = -1; // for when dealer is player and wizard is trump card

    // ── Deck Building ──
    function buildDeck() {
      let deck = [];
      for (let s of SUITS) {
        for (let r of RANK_NAMES) {
          deck.push({ type: 'normal', suit: s, rank: r, value: RANK_VALUES[r] });
        }
      }
      for (let i = 0; i < 4; i++) {
        deck.push({ type: 'wizard', suit: null, rank: 'W', value: 100 + i });
        deck.push({ type: 'jester', suit: null, rank: 'J', value: -100 - i });
      }
      return deck;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ── Card Display Name ──
    function cardName(c) {
      if (c.type === 'wizard') return 'Wizard';
      if (c.type === 'jester') return 'Jester';
      return c.rank + SUIT_SYMBOLS[c.suit];
    }

    // ── Deal Round ──
    function dealRound() {
      let deck = shuffle(buildDeck());
      playerHand = deck.splice(0, round);
      aiHand = deck.splice(0, round);
      trumpCard = null;
      trumpSuit = null;

      if (deck.length > 0) {
        trumpCard = deck[0];
        if (trumpCard.type === 'wizard') {
          // Dealer picks trump
          if (dealer === 'player') {
            phase = 'pick-trump';
            return;
          } else {
            // AI picks trump: pick suit most represented in hand
            trumpSuit = aiPickTrumpSuit();
          }
        } else if (trumpCard.type === 'jester') {
          trumpSuit = null; // no trump
        } else {
          trumpSuit = trumpCard.suit;
        }
      }
      startBidding();
    }

    function aiPickTrumpSuit() {
      let counts = { spades: 0, hearts: 0, diamonds: 0, clubs: 0 };
      for (let c of aiHand) {
        if (c.type === 'normal') counts[c.suit]++;
      }
      let best = 'spades', bestN = -1;
      for (let s of SUITS) {
        if (counts[s] > bestN) { bestN = counts[s]; best = s; }
      }
      return best;
    }

    // ── Bidding ──
    function startBidding() {
      playerBid = -1;
      aiBid = -1;
      playerTricks = 0;
      aiTricks = 0;
      trickCards = [];
      cardsPlayed = [];
      phase = 'bidding';

      // Non-dealer bids first
      if (dealer === 'ai') {
        // Player bids first, then AI
        bidOptions = [];
        for (let i = 0; i <= round; i++) bidOptions.push(i);
      } else {
        // AI bids first
        aiBid = aiMakeBid();
        bidOptions = [];
        for (let i = 0; i <= round; i++) bidOptions.push(i);
      }
    }

    function aiMakeBid() {
      let tricks = 0;
      for (let c of aiHand) {
        if (c.type === 'wizard') { tricks++; continue; }
        if (c.type === 'jester') continue;
        if (trumpSuit && c.suit === trumpSuit && c.value >= 10) tricks += 0.7;
        else if (trumpSuit && c.suit === trumpSuit) tricks += 0.3;
        if (c.value >= 13) tricks += 0.5;
        if (c.value === 14) tricks += 0.3;
      }
      let bid = Math.round(tricks);
      return Math.max(0, Math.min(round, bid));
    }

    function playerMakeBid(bid) {
      playerBid = bid;
      if (aiBid === -1) {
        // AI bids second
        aiBid = aiMakeBid();
      }
      phase = 'playing';
      // Non-dealer leads first trick
      leadPlayer = (dealer === 'ai') ? 'player' : 'ai';
      if (leadPlayer === 'ai') {
        setTimeout(aiPlayCard, 600);
      }
    }

    // ── Card Legality ──
    function getLegalCards(hand, ledSuit) {
      if (ledSuit === null) return hand.map((_, i) => i); // leading: can play anything
      // Must follow suit if possible (Wizards and Jesters can always be played)
      let following = [];
      let all = [];
      for (let i = 0; i < hand.length; i++) {
        all.push(i);
        let c = hand[i];
        if (c.type === 'wizard' || c.type === 'jester') {
          following.push(i);
        } else if (c.suit === ledSuit) {
          following.push(i);
        }
      }
      // Check if we have any normal cards of led suit
      let hasLedSuit = hand.some(c => c.type === 'normal' && c.suit === ledSuit);
      if (hasLedSuit) return following;
      return all; // can't follow suit, play anything
    }

    function getLedSuit() {
      if (trickCards.length === 0) return null;
      let first = trickCards[0].card;
      if (first.type === 'wizard' || first.type === 'jester') {
        // If first card is wizard/jester, the led suit is determined by the first normal card
        // Actually in Wizard rules: if a Wizard is led, the other player can play anything
        // If a Jester is led, the next normal card determines suit
        for (let tc of trickCards) {
          if (tc.card.type === 'normal') return tc.card.suit;
        }
        return null;
      }
      return first.suit;
    }

    // ── Trick Winner ──
    function determineTrickWinner() {
      let c1 = trickCards[0];
      let c2 = trickCards[1];

      // Wizard rules: first wizard wins
      if (c1.card.type === 'wizard') return c1.player;
      if (c2.card.type === 'wizard') return c2.player;

      // Both jesters: first one wins
      if (c1.card.type === 'jester' && c2.card.type === 'jester') return c1.player;
      // One jester: the other wins
      if (c1.card.type === 'jester') return c2.player;
      if (c2.card.type === 'jester') return c1.player;

      // Both normal cards
      let ledSuit = c1.card.suit;

      // Trump logic
      let c1Trump = trumpSuit && c1.card.suit === trumpSuit;
      let c2Trump = trumpSuit && c2.card.suit === trumpSuit;

      if (c1Trump && !c2Trump) return c1.player;
      if (!c1Trump && c2Trump) return c2.player;
      if (c1Trump && c2Trump) return c1.card.value > c2.card.value ? c1.player : c2.player;

      // Same suit
      if (c2.card.suit === ledSuit) {
        return c1.card.value > c2.card.value ? c1.player : c2.player;
      }
      // c2 didn't follow suit and no trump: c1 wins
      return c1.player;
    }

    // ── Play Card ──
    function playerPlayCard(idx) {
      if (phase !== 'playing') return;
      let ledSuit = getLedSuit();
      let legal = getLegalCards(playerHand, ledSuit);
      if (!legal.includes(idx)) return;

      let card = playerHand.splice(idx, 1)[0];
      trickCards.push({ card, player: 'player' });
      cardsPlayed.push(card);

      if (trickCards.length === 2) {
        resolveTrick();
      } else {
        // AI plays second
        setTimeout(aiPlayCard, 500);
      }
    }

    function aiPlayCard() {
      if (phase !== 'playing') return;
      let ledSuit = getLedSuit();
      let legal = getLegalCards(aiHand, ledSuit);
      if (legal.length === 0) return;

      let idx = aiChooseCard(legal, ledSuit);
      let card = aiHand.splice(idx, 1)[0];
      trickCards.push({ card, player: 'ai' });
      cardsPlayed.push(card);

      if (trickCards.length === 2) {
        resolveTrick();
      }
      // If AI leads, player plays next (handled by render/click)
    }

    // ── AI Card Selection ──
    function aiChooseCard(legal, ledSuit) {
      let tricksNeeded = aiBid - aiTricks;
      let tricksRemaining = aiHand.length;
      let wantToWin = tricksNeeded > 0;

      if (trickCards.length === 0) {
        // AI is leading
        if (wantToWin) {
          // Lead with strongest card
          return pickStrongest(legal);
        } else {
          // Lead with weakest card
          return pickWeakest(legal);
        }
      } else {
        // AI is following
        let leadCard = trickCards[0].card;
        if (wantToWin) {
          // Try to win the trick
          let winning = findWinningCards(legal, leadCard);
          if (winning.length > 0) {
            // Play the weakest winning card
            return pickWeakestFrom(winning);
          }
          // Can't win, dump lowest
          return pickWeakest(legal);
        } else {
          // Try to lose
          let losing = findLosingCards(legal, leadCard);
          if (losing.length > 0) {
            return pickWeakestFrom(losing);
          }
          return pickWeakest(legal);
        }
      }
    }

    function cardStrength(c) {
      if (c.type === 'wizard') return 1000;
      if (c.type === 'jester') return -1000;
      let str = c.value;
      if (trumpSuit && c.suit === trumpSuit) str += 100;
      return str;
    }

    function pickStrongest(indices) {
      let best = indices[0], bestStr = -Infinity;
      for (let i of indices) {
        let s = cardStrength(aiHand[i]);
        if (s > bestStr) { bestStr = s; best = i; }
      }
      return best;
    }

    function pickWeakest(indices) {
      let best = indices[0], bestStr = Infinity;
      for (let i of indices) {
        let s = cardStrength(aiHand[i]);
        if (s < bestStr) { bestStr = s; best = i; }
      }
      return best;
    }

    function pickWeakestFrom(indices) {
      let best = indices[0], bestStr = Infinity;
      for (let i of indices) {
        let s = cardStrength(aiHand[i]);
        if (s < bestStr) { bestStr = s; best = i; }
      }
      return best;
    }

    function findWinningCards(legal, leadCard) {
      let winning = [];
      for (let i of legal) {
        let c = aiHand[i];
        // Simulate: would this card beat the lead?
        let testTrick = [{ card: leadCard, player: 'player' }, { card: c, player: 'ai' }];
        let oldTrick = trickCards;
        trickCards = testTrick;
        let winner = determineTrickWinner();
        trickCards = oldTrick;
        if (winner === 'ai') winning.push(i);
      }
      return winning;
    }

    function findLosingCards(legal, leadCard) {
      let losing = [];
      for (let i of legal) {
        let c = aiHand[i];
        let testTrick = [{ card: leadCard, player: 'player' }, { card: c, player: 'ai' }];
        let oldTrick = trickCards;
        trickCards = testTrick;
        let winner = determineTrickWinner();
        trickCards = oldTrick;
        if (winner === 'player') losing.push(i);
      }
      return losing;
    }

    // ── Trick Resolution ──
    function resolveTrick() {
      let winner = determineTrickWinner();
      if (winner === 'player') playerTricks++;
      else aiTricks++;

      phase = 'trick-result';
      message = winner === 'player' ? 'You win the trick!' : 'AI wins the trick!';
      trickResultTimer = 80;
      leadPlayer = winner;
    }

    function afterTrickResult() {
      trickCards = [];
      // Check if round is over
      if (playerHand.length === 0 && aiHand.length === 0) {
        // Score the round
        let pScore = calcScore(playerBid, playerTricks);
        let aScore = calcScore(aiBid, aiTricks);
        score += pScore;
        aiScore += aScore;
        scoreEl.textContent = score;
        aiScoreEl.textContent = aiScore;

        let pSign = pScore >= 0 ? '+' : '';
        let aSign = aScore >= 0 ? '+' : '';
        message = `Round ${round}: You bid ${playerBid}, won ${playerTricks} (${pSign}${pScore}) | AI bid ${aiBid}, won ${aiTricks} (${aSign}${aScore})`;
        phase = 'round-result';
        trickResultTimer = 180;
        return;
      }

      phase = 'playing';
      if (leadPlayer === 'ai') {
        setTimeout(aiPlayCard, 500);
      }
    }

    function afterRoundResult() {
      if (round >= MAX_ROUNDS) {
        gameState = 'over';
        let result = score > aiScore ? 'You Win!' : (score < aiScore ? 'AI Wins!' : 'Tie Game!');
        overlayTitle.textContent = result;
        overlayText.innerHTML = `Final Score: You ${score} - AI ${aiScore}<br>Click to Play Again`;
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
        return;
      }
      round++;
      dealer = (dealer === 'player') ? 'ai' : 'player';
      roundInfoEl.textContent = `Round ${round}/${MAX_ROUNDS}`;
      dealRound();
    }

    function calcScore(bid, tricks) {
      if (bid === tricks) return 20 + 10 * tricks;
      return -10 * Math.abs(bid - tricks);
    }

    // ── Drawing ──
    function drawCard(x, y, card, faceDown, highlight, grayed) {
      ctx.save();
      // Card background
      if (faceDown) {
        ctx.fillStyle = '#336';
        ctx.strokeStyle = '#558';
        ctx.fillRect(x, y, CARD_W, CARD_H);
        ctx.strokeRect(x, y, CARD_W, CARD_H);
        // Pattern on back
        ctx.strokeStyle = '#449';
        ctx.lineWidth = 0.5;
        for (let i = 5; i < CARD_W - 4; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x + i, y + 4);
          ctx.lineTo(x + i, y + CARD_H - 4);
          ctx.stroke();
        }
        for (let i = 5; i < CARD_H - 4; i += 8) {
          ctx.beginPath();
          ctx.moveTo(x + 4, y + i);
          ctx.lineTo(x + CARD_W - 4, y + i);
          ctx.stroke();
        }
      } else {
        // Face up
        let bg = '#f8f4e8';
        if (card.type === 'wizard') bg = '#e8d0ff';
        else if (card.type === 'jester') bg = '#d0ffe0';
        if (grayed) bg = '#555';

        ctx.fillStyle = bg;
        ctx.strokeStyle = highlight ? '#ff6' : '#888';
        ctx.lineWidth = highlight ? 2 : 1;
        ctx.fillRect(x, y, CARD_W, CARD_H);
        ctx.strokeRect(x, y, CARD_W, CARD_H);

        if (highlight) {
          ctx.shadowColor = '#ff6';
          ctx.shadowBlur = 8;
          ctx.strokeRect(x, y, CARD_W, CARD_H);
          ctx.shadowBlur = 0;
        }

        // Card content
        if (card.type === 'wizard') {
          ctx.fillStyle = '#80f';
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('W', x + CARD_W / 2, y + 16);
          ctx.font = '24px serif';
          ctx.fillText('\u2605', x + CARD_W / 2, y + CARD_H / 2 + 6);
          ctx.font = '9px Courier New';
          ctx.fillText('WIZARD', x + CARD_W / 2, y + CARD_H - 6);
        } else if (card.type === 'jester') {
          ctx.fillStyle = '#0a0';
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('J', x + CARD_W / 2, y + 16);
          ctx.font = '20px serif';
          ctx.fillText('\u2662', x + CARD_W / 2, y + CARD_H / 2 + 4);
          ctx.font = '9px Courier New';
          ctx.fillText('JESTER', x + CARD_W / 2, y + CARD_H - 6);
        } else {
          let col = SUIT_COLORS[card.suit];
          if (grayed) col = '#999';
          ctx.fillStyle = col;
          ctx.font = 'bold 13px Courier New';
          ctx.textAlign = 'left';
          ctx.fillText(card.rank, x + 4, y + 15);
          ctx.textAlign = 'right';
          ctx.fillText(card.rank, x + CARD_W - 4, y + CARD_H - 5);

          ctx.textAlign = 'center';
          ctx.font = '22px serif';
          ctx.fillText(SUIT_SYMBOLS[card.suit], x + CARD_W / 2, y + CARD_H / 2 + 6);
        }
      }
      ctx.restore();
    }

    function getHandX(handSize, index) {
      let totalW = handSize * (CARD_W + 6) - 6;
      let startX = (W - totalW) / 2;
      return startX + index * (CARD_W + 6);
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState !== 'playing') return;

      // ── Trump display ──
      ctx.fillStyle = '#aaa';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      if (trumpSuit) {
        ctx.fillText('Trump:', 10, 20);
        ctx.fillStyle = SUIT_COLORS[trumpSuit];
        ctx.font = '20px serif';
        ctx.fillText(SUIT_SYMBOLS[trumpSuit], 60, 22);
      } else {
        ctx.fillText('Trump: None', 10, 20);
      }

      // ── Bids and tricks ──
      ctx.fillStyle = '#aaa';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'right';
      if (playerBid >= 0) {
        ctx.fillText(`Your bid: ${playerBid}  Tricks: ${playerTricks}`, W - 10, H - 5);
      }
      if (aiBid >= 0) {
        ctx.fillText(`AI bid: ${aiBid}  Tricks: ${aiTricks}`, W - 10, 15);
      }

      // ── AI hand (face down) ──
      for (let i = 0; i < aiHand.length; i++) {
        let x = getHandX(aiHand.length, i);
        drawCard(x, 30, null, true, false, false);
      }

      // ── Trump card (small, top-left area) ──
      if (trumpCard && phase !== 'pick-trump') {
        ctx.fillStyle = '#888';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText('Trump card:', 10, 42);
        drawCardSmall(10, 48, trumpCard);
      }

      // ── Played cards in center ──
      if (trickCards.length > 0) {
        let cx = W / 2;
        let cy = H / 2;
        for (let i = 0; i < trickCards.length; i++) {
          let tc = trickCards[i];
          let ox = (i === 0 ? -30 : 30);
          let oy = tc.player === 'player' ? 20 : -20;
          drawCard(cx + ox - CARD_W / 2, cy + oy - CARD_H / 2, tc.card, false, false, false);
          // Label
          ctx.fillStyle = '#aaa';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(tc.player === 'player' ? 'You' : 'AI', cx + ox, cy + oy + CARD_H / 2 + 12);
        }
      }

      // ── Player hand ──
      if (phase === 'playing' || phase === 'trick-result' || phase === 'round-result') {
        let ledSuit = getLedSuit();
        let legal = (phase === 'playing' && trickCards.length < 2) ? getLegalCards(playerHand, ledSuit) : [];
        for (let i = 0; i < playerHand.length; i++) {
          let x = getHandX(playerHand.length, i);
          let isLegal = legal.includes(i);
          let isHover = (hoverCard === i && isLegal && phase === 'playing' && trickCards.length < 2);
          let yOff = isHover ? -8 : 0;
          let isWaiting = (phase === 'playing' && leadPlayer === 'ai' && trickCards.length === 0);
          drawCard(x, H - CARD_H - 20 + yOff, playerHand[i], false, isHover, phase === 'playing' && !isLegal && !isWaiting);
        }
      }

      // ── Bidding UI ──
      if (phase === 'bidding' && playerBid === -1) {
        // Show player's hand
        for (let i = 0; i < playerHand.length; i++) {
          let x = getHandX(playerHand.length, i);
          drawCard(x, H - CARD_H - 20, playerHand[i], false, false, false);
        }

        ctx.fillStyle = '#f6a';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Your Bid:', W / 2, H / 2 - 40);

        if (aiBid >= 0) {
          ctx.fillStyle = '#aaa';
          ctx.font = '12px Courier New';
          ctx.fillText(`AI bid: ${aiBid}`, W / 2, H / 2 - 58);
        }

        // Bid buttons
        let bw = 36, bh = 32;
        let totalBW = bidOptions.length * (bw + 6) - 6;
        let startBX = (W - totalBW) / 2;
        for (let i = 0; i < bidOptions.length; i++) {
          let bx = startBX + i * (bw + 6);
          let by = H / 2 - 16;
          let isHover = (hoverBid === i);
          ctx.fillStyle = isHover ? 'rgba(255,102,170,0.5)' : 'rgba(255,102,170,0.2)';
          ctx.strokeStyle = isHover ? '#f6a' : '#f6a';
          ctx.lineWidth = isHover ? 2 : 1;
          ctx.fillRect(bx, by, bw, bh);
          ctx.strokeRect(bx, by, bw, bh);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(bidOptions[i], bx + bw / 2, by + bh / 2 + 5);
        }
      }

      // ── Pick Trump UI ──
      if (phase === 'pick-trump') {
        // Show player's hand
        for (let i = 0; i < playerHand.length; i++) {
          let x = getHandX(playerHand.length, i);
          drawCard(x, H - CARD_H - 20, playerHand[i], false, false, false);
        }

        ctx.fillStyle = '#f6a';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Wizard flipped! Pick trump suit:', W / 2, H / 2 - 40);

        let sw = 50, sh = 40;
        let totalSW = 4 * (sw + 10) - 10;
        let startSX = (W - totalSW) / 2;
        for (let i = 0; i < 4; i++) {
          let sx = startSX + i * (sw + 10);
          let sy = H / 2 - 10;
          let isHover = (trumpPickSuit === i);
          ctx.fillStyle = isHover ? 'rgba(255,102,170,0.4)' : 'rgba(255,102,170,0.15)';
          ctx.strokeStyle = '#f6a';
          ctx.lineWidth = isHover ? 2 : 1;
          ctx.fillRect(sx, sy, sw, sh);
          ctx.strokeRect(sx, sy, sw, sh);
          ctx.fillStyle = SUIT_COLORS[SUITS[i]];
          ctx.font = '22px serif';
          ctx.textAlign = 'center';
          ctx.fillText(SUIT_SYMBOLS[SUITS[i]], sx + sw / 2, sy + sh / 2 + 7);
        }
      }

      // ── Message display ──
      if (phase === 'trick-result' || phase === 'round-result') {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
        ctx.fillRect(W / 2 - 250, H / 2 - 18, 500, 36);
        ctx.fillStyle = '#f6a';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(message, W / 2, H / 2 + 4);
      }
    }

    function drawCardSmall(x, y, card) {
      let sw = 30, sh = 42;
      ctx.save();
      if (card.type === 'wizard') {
        ctx.fillStyle = '#e8d0ff';
      } else if (card.type === 'jester') {
        ctx.fillStyle = '#d0ffe0';
      } else {
        ctx.fillStyle = '#f8f4e8';
      }
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.fillRect(x, y, sw, sh);
      ctx.strokeRect(x, y, sw, sh);

      if (card.type === 'wizard') {
        ctx.fillStyle = '#80f';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('W', x + sw / 2, y + 12);
        ctx.font = '16px serif';
        ctx.fillText('\u2605', x + sw / 2, y + 30);
      } else if (card.type === 'jester') {
        ctx.fillStyle = '#0a0';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('J', x + sw / 2, y + 12);
      } else {
        ctx.fillStyle = SUIT_COLORS[card.suit];
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(card.rank, x + sw / 2, y + 12);
        ctx.font = '14px serif';
        ctx.fillText(SUIT_SYMBOLS[card.suit], x + sw / 2, y + 30);
      }
      ctx.restore();
    }

    // ── Input Handling ──
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', (e) => {
      let rect = canvas.getBoundingClientRect();
      let scaleX = W / rect.width;
      let scaleY = H / rect.height;
      mouseX = (e.clientX - rect.left) * scaleX;
      mouseY = (e.clientY - rect.top) * scaleY;
      updateHover();
    });

    canvas.addEventListener('click', (e) => {
      let rect = canvas.getBoundingClientRect();
      let scaleX = W / rect.width;
      let scaleY = H / rect.height;
      mouseX = (e.clientX - rect.left) * scaleX;
      mouseY = (e.clientY - rect.top) * scaleY;
      handleClick();
    });

    function updateHover() {
      hoverCard = -1;
      hoverBid = -1;
      trumpPickSuit = -1;

      if (gameState !== 'playing') return;

      if (phase === 'bidding' && playerBid === -1) {
        let bw = 36, bh = 32;
        let totalBW = bidOptions.length * (bw + 6) - 6;
        let startBX = (W - totalBW) / 2;
        for (let i = 0; i < bidOptions.length; i++) {
          let bx = startBX + i * (bw + 6);
          let by = H / 2 - 16;
          if (mouseX >= bx && mouseX <= bx + bw && mouseY >= by && mouseY <= by + bh) {
            hoverBid = i;
          }
        }
      }

      if (phase === 'pick-trump') {
        let sw = 50, sh = 40;
        let totalSW = 4 * (sw + 10) - 10;
        let startSX = (W - totalSW) / 2;
        for (let i = 0; i < 4; i++) {
          let sx = startSX + i * (sw + 10);
          let sy = H / 2 - 10;
          if (mouseX >= sx && mouseX <= sx + sw && mouseY >= sy && mouseY <= sy + sh) {
            trumpPickSuit = i;
          }
        }
      }

      if (phase === 'playing' && trickCards.length < 2) {
        let ledSuit = getLedSuit();
        let legal = getLegalCards(playerHand, ledSuit);
        // Only allow hover when it's player's turn
        let isPlayerTurn = (trickCards.length === 0 && leadPlayer === 'player') ||
                           (trickCards.length === 1 && trickCards[0].player === 'ai');
        if (isPlayerTurn) {
          for (let i = 0; i < playerHand.length; i++) {
            let x = getHandX(playerHand.length, i);
            let y = H - CARD_H - 20;
            if (mouseX >= x && mouseX <= x + CARD_W && mouseY >= y && mouseY <= y + CARD_H) {
              if (legal.includes(i)) hoverCard = i;
            }
          }
        }
      }
    }

    function handleClick() {
      if (gameState === 'waiting') {
        startGame();
        return;
      }

      if (gameState === 'over') {
        startGame();
        return;
      }

      if (phase === 'bidding' && playerBid === -1 && hoverBid >= 0) {
        playerMakeBid(bidOptions[hoverBid]);
        return;
      }

      if (phase === 'pick-trump' && trumpPickSuit >= 0) {
        trumpSuit = SUITS[trumpPickSuit];
        trumpPickSuit = -1;
        startBidding();
        return;
      }

      if (phase === 'playing' && hoverCard >= 0) {
        let isPlayerTurn = (trickCards.length === 0 && leadPlayer === 'player') ||
                           (trickCards.length === 1 && trickCards[0].player === 'ai');
        if (isPlayerTurn) {
          playerPlayCard(hoverCard);
        }
        return;
      }
    }

    // ── Game Loop ──
    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';
      score = 0;
      aiScore = 0;
      round = 1;
      dealer = 'ai';
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      roundInfoEl.textContent = 'Round 1/10';
      dealRound();
    }

    function gameLoop() {
      animFrame++;

      if (phase === 'trick-result') {
        trickResultTimer--;
        if (trickResultTimer <= 0) {
          afterTrickResult();
        }
      }

      if (phase === 'round-result') {
        trickResultTimer--;
        if (trickResultTimer <= 0) {
          afterRoundResult();
        }
      }

      updateHover();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ── Overlay click ──
    overlay.style.pointerEvents = 'auto';
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        handleClick();
      }
    });

    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

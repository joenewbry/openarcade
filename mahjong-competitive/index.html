<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mahjong Competitive</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4a8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 136, 0.5); }
    h1 { color: #4a8; font-size: 1.4rem; text-shadow: 0 0 15px rgba(68, 170, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #4a8; }
    canvas {
      border: 2px solid #4a8;
      box-shadow: 0 0 20px rgba(68, 170, 136, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4a8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.7rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(68,170,136,0.5); }
    .overlay p { font-size: 0.95rem; color: #aaa; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>MAHJONG COMPETITIVE</h1>
  </div>
  <div class="score-bar">
    <div>Points: <span id="score">25000</span></div>
    <div>Round: <span id="roundInfo">E1</span></div>
    <div>Tiles: <span id="wallCount">70</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">MAHJONG COMPETITIVE</h2>
      <p id="overlayText">Click to Start<br><br>Japanese Riichi Mahjong<br>4 players &bull; Simplified scoring</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const roundInfoEl = document.getElementById('roundInfo');
    const wallCountEl = document.getElementById('wallCount');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 25000;

    // ========== TILE SYSTEM ==========
    const SUITS = ['m','p','s'];
    const SUIT_NAMES = {m:'Man',p:'Pin',s:'Sou'};
    const WIND_KANJI = ['\u6771','\u5357','\u897F','\u5317'];
    const DRAGON_KANJI = ['\u767D','\u767C','\u4E2D'];
    const WIND_NAMES = ['East','South','West','North'];
    const DRAGON_NAMES = ['Wht','Grn','Red'];

    function parseTile(t) {
      if (t[0]==='w') return {type:'wind',num:parseInt(t[1]),suit:'z'};
      if (t[0]==='d') return {type:'dragon',num:parseInt(t[1]),suit:'z'};
      return {type:'suit',suit:t[0],num:parseInt(t[1])};
    }

    function tileSort(a, b) {
      const pa = parseTile(a), pb = parseTile(b);
      const order = {m:0, p:1, s:2, z:3};
      const sa = pa.suit || 'z', sb = pb.suit || 'z';
      if (order[sa] !== order[sb]) return order[sa] - order[sb];
      const typeOrd = {suit:0, wind:1, dragon:2};
      if (pa.type !== pb.type) return typeOrd[pa.type] - typeOrd[pb.type];
      return pa.num - pb.num;
    }

    function buildWall() {
      let wall = [];
      for (let s of SUITS) for (let n = 1; n <= 9; n++) for (let c = 0; c < 4; c++) wall.push(s + n);
      for (let n = 1; n <= 4; n++) for (let c = 0; c < 4; c++) wall.push('w' + n);
      for (let n = 1; n <= 3; n++) for (let c = 0; c < 4; c++) wall.push('d' + n);
      for (let i = wall.length - 1; i > 0; i--) {
        let j = Math.random() * (i + 1) | 0;
        [wall[i], wall[j]] = [wall[j], wall[i]];
      }
      return wall; // 136 tiles
    }

    // ========== GAME STATE ==========
    let wall = [], deadWall = [];
    let players = [];
    let currentTurn = 0;
    let roundWind = 0;
    let handNum = 0;
    let turnPhase = '';
    let callOptions = [];
    let callButtons = [];
    let pendingAiCall = null; // stored separately so it survives callButtons reset
    let discardSeat = -1; // who discarded the tile being called on
    let selectedTile = -1;
    let hoveredTile = -1;
    let message = '';
    let messageTimer = 0;
    let riichiSticks = 0;
    let doraIndicators = [];
    let pendingRiichi = false;

    const SEAT_NAMES = ['You', 'West AI', 'North AI', 'East AI'];
    const SEAT_WIND = (seat) => (seat + (4 - handNum)) % 4;

    function initPlayer(seat) {
      return {
        seat, hand: [], discards: [], melds: [],
        riichi: false, riichiTurn: -1, points: 25000
      };
    }

    function dealHand() {
      wall = buildWall();
      deadWall = wall.splice(0, 14);
      doraIndicators = [deadWall[0]];
      players = [initPlayer(0), initPlayer(1), initPlayer(2), initPlayer(3)];
      for (let i = 0; i < 4; i++) {
        players[i].hand = wall.splice(0, 13).sort(tileSort);
        players[i].points = (i === 0) ? score : players[i].points;
      }
      // Keep AI scores persistent
      currentTurn = handNum; // dealer goes first
      turnPhase = 'draw';
      callOptions = [];
      callButtons = [];
      pendingAiCall = null;
      discardSeat = -1;
      selectedTile = -1;
      hoveredTile = -1;
      riichiSticks = 0;
      pendingRiichi = false;
      message = '';
      messageTimer = 0;
      updateUI();
    }

    function updateUI() {
      score = players[0].points;
      scoreEl.textContent = score;
      roundInfoEl.textContent = (roundWind === 0 ? 'E' : 'S') + (handNum + 1);
      wallCountEl.textContent = wall.length;
    }

    // ========== HAND EVALUATION ==========
    function countTiles(hand) {
      let c = {};
      for (let t of hand) c[t] = (c[t] || 0) + 1;
      return c;
    }

    function canWin(hand) {
      if (hand.length < 14) return false;
      let counts = countTiles(hand);
      // Seven pairs
      if (hand.length === 14) {
        let pairCount = 0;
        for (let k of Object.keys(counts)) {
          if (counts[k] === 2) pairCount++;
          else if (counts[k] === 4) pairCount += 2;
          else if (counts[k] !== 0 && counts[k] !== 2 && counts[k] !== 4) { /* not seven pairs */ }
        }
        // All tiles must be in pairs
        let allPairs = Object.values(counts).every(v => v === 2 || v === 4);
        if (allPairs && Object.keys(counts).length + Object.values(counts).filter(v=>v===4).length >= 7) {
          return true;
        }
      }
      // Standard form
      let tiles = Object.keys(counts);
      for (let pair of tiles) {
        if (counts[pair] < 2) continue;
        let rem = {...counts};
        rem[pair] -= 2;
        if (rem[pair] === 0) delete rem[pair];
        if (canFormSets(rem)) return true;
      }
      return false;
    }

    function canFormSets(counts) {
      let keys = Object.keys(counts).filter(k => counts[k] > 0).sort(tileSort);
      if (keys.length === 0) return true;
      let first = keys[0];
      let p = parseTile(first);
      // Try triplet
      if (counts[first] >= 3) {
        let rem = {...counts};
        rem[first] -= 3;
        if (rem[first] === 0) delete rem[first];
        if (canFormSets(rem)) return true;
      }
      // Try sequence
      if (p.type === 'suit' && p.num <= 7) {
        let t2 = p.suit + (p.num + 1), t3 = p.suit + (p.num + 2);
        if (counts[t2] > 0 && counts[t3] > 0) {
          let rem = {...counts};
          rem[first]--; if (rem[first] === 0) delete rem[first];
          rem[t2]--; if (rem[t2] === 0) delete rem[t2];
          rem[t3]--; if (rem[t3] === 0) delete rem[t3];
          if (canFormSets(rem)) return true;
        }
      }
      return false;
    }

    function getWaits(hand) {
      let waits = [];
      let allTileTypes = [];
      for (let s of SUITS) for (let n = 1; n <= 9; n++) allTileTypes.push(s + n);
      for (let n = 1; n <= 4; n++) allTileTypes.push('w' + n);
      for (let n = 1; n <= 3; n++) allTileTypes.push('d' + n);
      for (let t of allTileTypes) {
        let test = [...hand, t];
        if (canWin(test)) waits.push(t);
      }
      return waits;
    }

    function isTenpai(hand) {
      return getWaits(hand).length > 0;
    }

    // Simplified shanten estimate
    function getShantenSimple(hand) {
      let counts = countTiles(hand);
      let groups = 0, partials = 0, pairs = 0;
      let used = {};
      // Triplets
      for (let t of Object.keys(counts)) {
        let avail = counts[t] - (used[t] || 0);
        if (avail >= 3) { groups++; used[t] = (used[t] || 0) + 3; }
      }
      // Sequences
      for (let s of SUITS) {
        for (let n = 1; n <= 7; n++) {
          let t1 = s+n, t2 = s+(n+1), t3 = s+(n+2);
          let a1 = (counts[t1]||0) - (used[t1]||0);
          let a2 = (counts[t2]||0) - (used[t2]||0);
          let a3 = (counts[t3]||0) - (used[t3]||0);
          if (a1 > 0 && a2 > 0 && a3 > 0) {
            groups++;
            used[t1] = (used[t1]||0) + 1;
            used[t2] = (used[t2]||0) + 1;
            used[t3] = (used[t3]||0) + 1;
          }
        }
      }
      // Pairs from remaining
      for (let t of Object.keys(counts)) {
        let rem = (counts[t]||0) - (used[t]||0);
        if (rem >= 2) pairs++;
      }
      // Partial sequences
      for (let s of SUITS) {
        for (let n = 1; n <= 8; n++) {
          let t1 = s+n, t2 = s+(n+1);
          let a1 = (counts[t1]||0) - (used[t1]||0);
          let a2 = (counts[t2]||0) - (used[t2]||0);
          if (a1 > 0 && a2 > 0) partials++;
        }
      }
      let needed = 4;
      let sh = (needed - groups) * 2 - Math.min(partials + pairs, needed - groups) - (pairs > 0 ? 1 : 0);
      return Math.max(sh, -1);
    }

    // ========== SCORING ==========
    function countFan(hand, melds, winTile, isTsumo, seatWind, rndWind, isRiichi) {
      let fan = 0;
      let allTiles = [...hand];
      for (let m of melds) allTiles.push(...m.tiles);
      let counts = countTiles(allTiles);
      let isConcealed = melds.every(m => !m.open);

      if (isRiichi) fan += 1;
      if (isTsumo && isConcealed && melds.length === 0) fan += 1; // menzen tsumo

      // Tanyao (all simples)
      if (allTiles.every(t => {
        let p = parseTile(t);
        return p.type === 'suit' && p.num >= 2 && p.num <= 8;
      })) fan += 1;

      // Yakuhai (value tiles)
      let swt = 'w' + (seatWind + 1);
      let rwt = 'w' + (rndWind + 1);
      if ((counts[swt] || 0) >= 3) fan += 1;
      if ((counts[rwt] || 0) >= 3) fan += 1;
      for (let d = 1; d <= 3; d++) if ((counts['d'+d] || 0) >= 3) fan += 1;

      // Seven pairs
      let spCheck = Object.values(counts);
      if (hand.length === 14 && isConcealed && spCheck.every(v => v === 2 || v === 4) &&
          Object.keys(counts).length + spCheck.filter(v=>v===4).length >= 7) {
        fan += 2;
      }

      // Flush checks
      let suits = new Set(), hasHonor = false;
      for (let t of allTiles) {
        let p = parseTile(t);
        if (p.type === 'suit') suits.add(p.suit); else hasHonor = true;
      }
      if (suits.size === 1 && hasHonor) fan += (isConcealed ? 3 : 2); // half flush
      if (suits.size === 1 && !hasHonor) fan += (isConcealed ? 6 : 5); // full flush
      if (suits.size === 0) fan += 4; // all honors (simplified yakuman)

      // Minimum 1 fan to win
      if (fan === 0) fan = 1;
      return fan;
    }

    function fanToPoints(fan, isDealer) {
      let base;
      if (fan >= 13) base = 8000;
      else if (fan >= 11) base = 6000;
      else if (fan >= 8) base = 4000;
      else if (fan >= 6) base = 3000;
      else if (fan >= 5) base = 2000;
      else if (fan >= 4) base = 2000;
      else if (fan === 3) base = 1000;
      else if (fan === 2) base = 700;
      else base = 400;
      return isDealer ? base * 6 : base * 4;
    }

    // ========== AI LOGIC ==========
    function aiEvalDiscard(seat) {
      let p = players[seat];
      let hand = p.hand;
      if (p.riichi) return hand.length - 1; // tsumogiri

      let bestIdx = 0, bestScore = -9999;
      for (let i = 0; i < hand.length; i++) {
        let test = hand.filter((_, j) => j !== i);
        let sc = 0;
        let waits = getWaits(test);
        sc += waits.length * 12;

        let tp = parseTile(hand[i]);
        let cnt = hand.filter(t => t === hand[i]).length;

        if (cnt >= 3) sc -= 30;
        if (cnt >= 2) sc -= 15;

        // Isolated honors are safe discards
        if (tp.type !== 'suit' && cnt === 1) sc += 5;
        // Isolated terminals
        if (tp.type === 'suit' && (tp.num === 1 || tp.num === 9) && cnt === 1) sc += 3;

        // Already discarded = safer
        let discardedCount = 0;
        for (let pl of players) discardedCount += pl.discards.filter(t => t === hand[i]).length;
        sc += discardedCount * 2;

        // Shanten improvement
        sc -= getShantenSimple(test) * 8;

        if (sc > bestScore) { bestScore = sc; bestIdx = i; }
      }
      return bestIdx;
    }

    function aiShouldCall(seat, tile, fromSeat) {
      let p = players[seat];
      if (p.riichi) return null;
      let hand = p.hand;
      let counts = countTiles(hand);

      // Ron check
      if (canWin([...hand, tile])) return {type: 'ron'};

      // Pon check
      if ((counts[tile] || 0) >= 2) {
        let curSh = getShantenSimple(hand);
        let removed = 0;
        let nh = hand.filter(t => { if (t === tile && removed < 2) { removed++; return false; } return true; });
        let newSh = getShantenSimple(nh);
        if (newSh < curSh || (newSh <= 1 && Math.random() < 0.5)) {
          return {type: 'pon'};
        }
      }

      // Chi check (only from left player)
      if (fromSeat === (seat + 3) % 4) {
        let tp = parseTile(tile);
        if (tp.type === 'suit') {
          let curSh = getShantenSimple(hand);
          let combos = [];
          if (tp.num >= 3 && (counts[tp.suit+(tp.num-2)]||0) > 0 && (counts[tp.suit+(tp.num-1)]||0) > 0) {
            combos.push([tp.suit+(tp.num-2), tp.suit+(tp.num-1), tile]);
          }
          if (tp.num >= 2 && tp.num <= 8 && (counts[tp.suit+(tp.num-1)]||0) > 0 && (counts[tp.suit+(tp.num+1)]||0) > 0) {
            combos.push([tp.suit+(tp.num-1), tile, tp.suit+(tp.num+1)]);
          }
          if (tp.num <= 7 && (counts[tp.suit+(tp.num+1)]||0) > 0 && (counts[tp.suit+(tp.num+2)]||0) > 0) {
            combos.push([tile, tp.suit+(tp.num+1), tp.suit+(tp.num+2)]);
          }
          for (let combo of combos) {
            let nh = [...hand];
            for (let ct of combo) {
              if (ct !== tile) {
                let idx = nh.indexOf(ct);
                if (idx >= 0) nh.splice(idx, 1);
              }
            }
            let newSh = getShantenSimple(nh);
            if (newSh < curSh) return {type: 'chi', combo: combo.sort(tileSort)};
          }
        }
      }
      return null;
    }

    // ========== GAME FLOW ==========
    function drawTileFromWall() {
      if (wall.length === 0) { endHandDraw(); return; }
      let tile = wall.shift();
      let p = players[currentTurn];
      p.hand.push(tile);
      p.hand.sort(tileSort);

      // Check tsumo
      if (canWin(p.hand)) {
        if (currentTurn === 0) {
          callOptions = [{type: 'tsumo', seat: 0}];
          callButtons = [
            {label: 'TSUMO', x: 220, y: 300, w: 80, h: 30, action: 'tsumo'},
            {label: 'PASS', x: 310, y: 300, w: 80, h: 30, action: 'pass_tsumo'}
          ];
          turnPhase = 'call';
          return;
        } else {
          declareTsumo(currentTurn);
          return;
        }
      }

      // AI riichi check
      if (currentTurn !== 0) {
        if (!p.riichi && !p.melds.some(m => m.open) && p.points >= 1000) {
          // Check if any discard leaves tenpai
          for (let i = 0; i < p.hand.length; i++) {
            let test = p.hand.filter((_, j) => j !== i);
            if (isTenpai(test)) {
              p.riichi = true;
              p.riichiTurn = p.discards.length;
              p.points -= 1000;
              riichiSticks++;
              showMessage(SEAT_NAMES[currentTurn] + ' declares RIICHI!');
              break;
            }
          }
        }
      }

      if (currentTurn === 0) {
        turnPhase = 'discard';
      } else {
        setTimeout(() => {
          if (gameState !== 'playing') return;
          let idx = aiEvalDiscard(currentTurn);
          doDiscard(currentTurn, idx);
        }, 400 + Math.random() * 400);
      }
      updateUI();
    }

    function doDiscard(seat, tileIdx) {
      let p = players[seat];
      if (tileIdx < 0 || tileIdx >= p.hand.length) return;
      let tile = p.hand.splice(tileIdx, 1)[0];
      p.discards.push(tile);
      discardSeat = seat;

      // Check calls from other players
      let calls = [];
      for (let i = 0; i < 4; i++) {
        if (i === seat) continue;
        if (players[i].riichi) {
          // Riichi players can only ron
          if (canWin([...players[i].hand, tile])) {
            calls.push({type: 'ron', seat: i, tile, priority: 3});
          }
          continue;
        }
        // Ron
        if (canWin([...players[i].hand, tile])) {
          calls.push({type: 'ron', seat: i, tile, priority: 3});
        }
        // Pon
        let cnt = players[i].hand.filter(t => t === tile).length;
        if (cnt >= 2) {
          calls.push({type: 'pon', seat: i, tile, priority: 2});
        }
        // Chi (only from left = next player in turn order)
        if (i === (seat + 1) % 4) {
          let tp = parseTile(tile);
          if (tp.type === 'suit') {
            let hc = countTiles(players[i].hand);
            if (tp.num >= 3 && (hc[tp.suit+(tp.num-2)]||0) > 0 && (hc[tp.suit+(tp.num-1)]||0) > 0)
              calls.push({type:'chi',seat:i,tile,priority:1,combo:[tp.suit+(tp.num-2),tp.suit+(tp.num-1),tile]});
            if (tp.num >= 2 && tp.num <= 8 && (hc[tp.suit+(tp.num-1)]||0) > 0 && (hc[tp.suit+(tp.num+1)]||0) > 0)
              calls.push({type:'chi',seat:i,tile,priority:1,combo:[tp.suit+(tp.num-1),tile,tp.suit+(tp.num+1)]});
            if (tp.num <= 7 && (hc[tp.suit+(tp.num+1)]||0) > 0 && (hc[tp.suit+(tp.num+2)]||0) > 0)
              calls.push({type:'chi',seat:i,tile,priority:1,combo:[tile,tp.suit+(tp.num+1),tp.suit+(tp.num+2)]});
          }
        }
      }

      if (calls.length > 0) {
        calls.sort((a, b) => b.priority - a.priority);
        let humanCalls = calls.filter(c => c.seat === 0);
        let aiCalls = calls.filter(c => c.seat !== 0);

        // Determine best AI call
        let bestAi = null;
        for (let ac of aiCalls) {
          let decision = aiShouldCall(ac.seat, tile, seat);
          if (decision) {
            if (!bestAi || ac.priority > bestAi.priority) {
              bestAi = {...ac, decision};
            }
          }
        }

        if (humanCalls.length > 0) {
          callOptions = humanCalls;
          callButtons = [];
          pendingAiCall = bestAi;
          let bx = 140;
          // Deduplicate call types for buttons
          let seenTypes = new Set();
          for (let hc of humanCalls) {
            if (seenTypes.has(hc.type)) continue;
            seenTypes.add(hc.type);
            callButtons.push({label: hc.type.toUpperCase(), x: bx, y: 300, w: 80, h: 30, action: hc.type, data: hc});
            bx += 90;
          }
          callButtons.push({label: 'PASS', x: bx, y: 300, w: 80, h: 30, action: 'pass'});
          turnPhase = 'call';
          return;
        }

        if (bestAi) {
          setTimeout(() => {
            if (gameState !== 'playing') return;
            executeCall(bestAi.seat, bestAi.decision || bestAi, tile, seat);
          }, 400);
          return;
        }
      }

      nextTurn();
    }

    function executeCall(seat, call, tile, fromSeat) {
      let p = players[seat];
      if (call.type === 'ron') {
        p.hand.push(tile);
        let dIdx = players[fromSeat].discards.lastIndexOf(tile);
        if (dIdx >= 0) players[fromSeat].discards.splice(dIdx, 1);
        declareWin(seat, fromSeat, false);
        return;
      }
      if (call.type === 'pon') {
        let dIdx = players[fromSeat].discards.lastIndexOf(tile);
        if (dIdx >= 0) players[fromSeat].discards.splice(dIdx, 1);
        let removed = 0;
        p.hand = p.hand.filter(t => { if (t === tile && removed < 2) { removed++; return false; } return true; });
        p.melds.push({type: 'pon', tiles: [tile, tile, tile], open: true});
        currentTurn = seat;
        showMessage(SEAT_NAMES[seat] + ' calls PON!');
        if (seat === 0) {
          turnPhase = 'discard';
        } else {
          setTimeout(() => {
            if (gameState !== 'playing') return;
            let idx = aiEvalDiscard(seat);
            doDiscard(seat, idx);
          }, 500);
        }
        updateUI();
        return;
      }
      if (call.type === 'chi') {
        let dIdx = players[fromSeat].discards.lastIndexOf(tile);
        if (dIdx >= 0) players[fromSeat].discards.splice(dIdx, 1);
        let combo = call.combo || call.tiles || [];
        for (let ct of combo) {
          if (ct !== tile) {
            let idx = p.hand.indexOf(ct);
            if (idx >= 0) p.hand.splice(idx, 1);
          }
        }
        p.melds.push({type: 'chi', tiles: combo.sort(tileSort), open: true});
        currentTurn = seat;
        showMessage(SEAT_NAMES[seat] + ' calls CHI!');
        if (seat === 0) {
          turnPhase = 'discard';
        } else {
          setTimeout(() => {
            if (gameState !== 'playing') return;
            let idx = aiEvalDiscard(seat);
            doDiscard(seat, idx);
          }, 500);
        }
        updateUI();
        return;
      }
    }

    function declareTsumo(seat) {
      declareWin(seat, seat, true);
    }

    function declareWin(seat, fromSeat, isTsumo) {
      let p = players[seat];
      let sw = SEAT_WIND(seat);
      let isDealer = (seat === handNum);
      let fan = countFan(p.hand, p.melds, null, isTsumo, sw, roundWind, p.riichi);
      let pts = fanToPoints(fan, isDealer) + riichiSticks * 1000;

      if (isTsumo) {
        showMessage(SEAT_NAMES[seat] + ' TSUMO! +' + pts + 'pts (' + fan + ' fan)');
        let eachPay = Math.ceil(pts / 3 / 100) * 100;
        for (let i = 0; i < 4; i++) {
          if (i === seat) continue;
          let pay = isDealer ? eachPay : (i === handNum ? Math.ceil(pts/2/100)*100 : Math.ceil(pts/4/100)*100);
          players[i].points -= pay;
        }
        p.points += pts;
      } else {
        showMessage(SEAT_NAMES[seat] + ' RON from ' + SEAT_NAMES[fromSeat] + '! +' + pts + 'pts (' + fan + ' fan)');
        players[fromSeat].points -= pts;
        p.points += pts;
      }

      score = players[0].points;
      turnPhase = 'done';
      riichiSticks = 0;
      updateUI();

      setTimeout(() => {
        if (gameState !== 'playing') return;
        endHand(seat === handNum);
      }, 2500);
    }

    function endHandDraw() {
      showMessage('Exhaustive draw!');
      turnPhase = 'done';
      let tenpaiPlayers = [];
      for (let i = 0; i < 4; i++) {
        if (isTenpai(players[i].hand)) tenpaiPlayers.push(i);
      }
      if (tenpaiPlayers.length > 0 && tenpaiPlayers.length < 4) {
        let total = 3000;
        for (let i = 0; i < 4; i++) {
          if (tenpaiPlayers.includes(i)) {
            players[i].points += Math.floor(total / tenpaiPlayers.length);
          } else {
            players[i].points -= Math.floor(total / (4 - tenpaiPlayers.length));
          }
        }
      }
      score = players[0].points;
      updateUI();
      setTimeout(() => {
        if (gameState !== 'playing') return;
        endHand(tenpaiPlayers.includes(handNum));
      }, 2000);
    }

    function endHand(dealerWon) {
      if (!dealerWon) {
        handNum = (handNum + 1) % 4;
        if (handNum === 0) {
          roundWind++;
          if (roundWind >= 2) { endGame(); return; }
        }
      }
      updateUI();
      dealHand();
      turnPhase = 'draw';
      drawTileFromWall();
    }

    function endGame() {
      gameState = 'over';
      let sorted = [...players].sort((a, b) => b.points - a.points);
      let winnerSeat = sorted[0].seat;
      overlayTitle.textContent = winnerSeat === 0 ? 'YOU WIN!' : SEAT_NAMES[winnerSeat] + ' WINS';
      let details = players.map((p, i) => SEAT_NAMES[i] + ': ' + p.points).join('\n');
      overlayText.innerHTML = details.replace(/\n/g, '<br>') + '<br><br>Click to play again';
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      score = players[0].points;
      scoreEl.textContent = score;
    }

    function nextTurn() {
      currentTurn = (currentTurn + 1) % 4;
      turnPhase = 'draw';
      drawTileFromWall();
    }

    function showMessage(msg) { message = msg; messageTimer = 150; }

    // ========== DRAWING ==========
    const TW = 30, TH = 40;
    const TSW = 20, TSH = 28;

    function roundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r);
      ctx.lineTo(x+w, y+h-r);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      ctx.lineTo(x+r, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r);
      ctx.lineTo(x, y+r);
      ctx.quadraticCurveTo(x, y, x+r, y);
      ctx.closePath();
    }

    function drawTileGfx(x, y, tileId, w, h, highlight, faceDown) {
      ctx.save();
      let grad = ctx.createLinearGradient(x, y, x, y + h);
      if (faceDown) {
        grad.addColorStop(0, '#2a5a4a');
        grad.addColorStop(1, '#1a3a2a');
      } else {
        grad.addColorStop(0, '#f5f0e0');
        grad.addColorStop(1, '#d8d0b8');
      }
      ctx.fillStyle = grad;
      roundedRect(x, y, w, h, 3);
      ctx.fill();

      if (highlight) {
        ctx.strokeStyle = '#4a8';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#4a8';
        ctx.shadowBlur = 8;
      } else {
        ctx.strokeStyle = faceDown ? '#3a7a6a' : '#999';
        ctx.lineWidth = 1;
        ctx.shadowBlur = 0;
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      if (faceDown || !tileId) { ctx.restore(); return; }

      let p = parseTile(tileId);
      let cx = x + w / 2, cy = y + h / 2;

      if (p.type === 'suit') {
        let suitColor = {m: '#c33', p: '#28c', s: '#282'}[p.suit];
        ctx.fillStyle = suitColor;
        ctx.font = 'bold ' + (h * 0.42) + 'px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.num, cx, cy - h * 0.1);
        ctx.font = (h * 0.22) + 'px Courier New';
        ctx.fillText({m:'M', p:'P', s:'S'}[p.suit], cx, cy + h * 0.28);
      } else if (p.type === 'wind') {
        ctx.font = 'bold ' + (h * 0.48) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#333';
        ctx.fillText(WIND_KANJI[p.num - 1], cx, cy);
      } else if (p.type === 'dragon') {
        ctx.font = 'bold ' + (h * 0.48) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = ['#777', '#2a2', '#c22'][p.num - 1];
        ctx.fillText(DRAGON_KANJI[p.num - 1], cx, cy);
      }
      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Table center
      ctx.fillStyle = '#1a3828';
      roundedRect(100, 80, 400, 280, 8);
      ctx.fill();
      ctx.strokeStyle = '#2a5a4a';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Inner border
      ctx.strokeStyle = '#4a8';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(115, 95, 370, 250);

      // Center info
      ctx.fillStyle = '#4a8';
      ctx.font = '13px Courier New';
      ctx.textAlign = 'center';
      let windLabel = roundWind === 0 ? 'East' : 'South';
      ctx.fillText(windLabel + ' ' + (handNum + 1), 300, 195);
      ctx.font = '11px Courier New';
      ctx.fillStyle = '#6c6';
      ctx.fillText('Wall: ' + wall.length, 300, 210);

      // Dora
      if (doraIndicators.length > 0) {
        ctx.fillStyle = '#888';
        ctx.font = '9px Courier New';
        ctx.fillText('Dora Indicator', 300, 232);
        let dx = 300 - (doraIndicators.length * 10);
        for (let i = 0; i < doraIndicators.length; i++) {
          drawTileGfx(dx + i * 22, 237, doraIndicators[i], 18, 24, false, false);
        }
      }

      // Riichi sticks
      if (riichiSticks > 0) {
        ctx.fillStyle = '#ea0';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(riichiSticks + ' riichi stick' + (riichiSticks > 1 ? 's' : ''), 300, 275);
        // Draw stick visual
        for (let i = 0; i < riichiSticks && i < 4; i++) {
          ctx.fillStyle = '#ea0';
          ctx.fillRect(270 + i * 20, 280, 16, 3);
          ctx.fillStyle = '#c00';
          ctx.beginPath();
          ctx.arc(278 + i * 20, 281, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Turn indicator
      if (turnPhase !== 'done') {
        let turnNames = ['South(You)', 'West(AI)', 'North(AI)', 'East(AI)'];
        ctx.fillStyle = '#4a8';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Turn: ' + turnNames[currentTurn], 300, 180);
      }

      // Players
      drawPlayerSouth();
      drawPlayerWest();
      drawPlayerNorth();
      drawPlayerEast();

      // Discards
      drawDiscards();

      // Call buttons
      if (turnPhase === 'call' && callButtons.length > 0) {
        // Semi-transparent backdrop
        ctx.fillStyle = 'rgba(26,26,46,0.7)';
        ctx.fillRect(120, 290, 360, 50);
        for (let btn of callButtons) {
          ctx.fillStyle = btn.hover ? '#3a8a6a' : '#2a5a4a';
          roundedRect(btn.x, btn.y, btn.w, btn.h, 5);
          ctx.fill();
          ctx.strokeStyle = btn.hover ? '#6d6' : '#4a8';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 13px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2);
        }
      }

      // Riichi button
      if (turnPhase === 'discard' && currentTurn === 0 && !players[0].riichi && players[0].points >= 1000) {
        let p0 = players[0];
        if (!p0.melds.some(m => m.open)) {
          let canR = false;
          for (let i = 0; i < p0.hand.length; i++) {
            let test = p0.hand.filter((_, j) => j !== i);
            if (isTenpai(test)) { canR = true; break; }
          }
          if (canR) {
            let rbx = 500, rby = 412, rbw = 80, rbh = 24;
            ctx.fillStyle = '#4a2a2a';
            roundedRect(rbx, rby, rbw, rbh, 4);
            ctx.fill();
            ctx.strokeStyle = '#e44';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#e44';
            ctx.font = 'bold 11px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('RIICHI', rbx + rbw / 2, rby + rbh / 2);
          }
        }
      }

      // Message bar
      if (messageTimer > 0) {
        let alpha = Math.min(1, messageTimer / 30);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = 'rgba(26,26,46,0.85)';
        ctx.fillRect(80, 145, 440, 35);
        ctx.strokeStyle = '#4a8';
        ctx.lineWidth = 1;
        ctx.strokeRect(80, 145, 440, 35);
        ctx.fillStyle = '#4a8';
        ctx.font = 'bold 13px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#4a8';
        ctx.shadowBlur = 10;
        ctx.fillText(message, 300, 162);
        ctx.restore();
      }

      // Waiting for AI indicator
      if (turnPhase === 'discard' && currentTurn !== 0) {
        ctx.fillStyle = '#666';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        let dots = '.'.repeat(1 + (Date.now() / 500 | 0) % 3);
        ctx.fillText('AI thinking' + dots, 300, 395);
      }
    }

    function drawPlayerSouth() {
      let p = players[0];
      let handLen = p.hand.length;
      let meldTileCount = p.melds.reduce((s, m) => s + m.tiles.length, 0);
      let totalW = handLen * (TW + 2);
      let startX = Math.max(10, (W - totalW) / 2 - meldTileCount * 12);
      let y = H - TH - 18;

      // Label
      ctx.fillStyle = currentTurn === 0 ? '#4a8' : '#888';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      let windStr = WIND_NAMES[SEAT_WIND(0)];
      let label = 'You [' + windStr + '] ' + p.points + 'pts';
      if (p.riichi) label += ' RIICHI';
      ctx.fillText(label, 10, y - 6);

      // Hand
      for (let i = 0; i < handLen; i++) {
        let tx = startX + i * (TW + 2);
        let ty = y;
        let isHover = (i === hoveredTile && turnPhase === 'discard' && currentTurn === 0);
        if (isHover) ty -= 8;
        drawTileGfx(tx, ty, p.hand[i], TW, TH, isHover, false);
      }

      // Melds (right side)
      let mx = W - 8;
      for (let m of p.melds) {
        for (let i = m.tiles.length - 1; i >= 0; i--) {
          mx -= (TSW + 2);
          drawTileGfx(mx, y + 10, m.tiles[i], TSW, TSH, false, false);
        }
        mx -= 5;
      }
    }

    function drawPlayerWest() {
      let p = players[1];
      let y0 = 100;
      ctx.fillStyle = currentTurn === 1 ? '#4a8' : '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      let label = 'W:' + p.points;
      if (p.riichi) label += ' R';
      ctx.fillText(label, 3, y0 - 4);

      let count = p.hand.length;
      let gap = Math.min(16, 230 / Math.max(count, 1));
      for (let i = 0; i < count; i++) {
        drawTileGfx(8, y0 + i * gap, null, TSH, TSW - 2, false, true);
      }

      let my = y0 + count * gap + 8;
      for (let m of p.melds) {
        for (let t of m.tiles) {
          drawTileGfx(3, my, t, 16, 20, false, false);
          my += 17;
        }
        my += 3;
      }
    }

    function drawPlayerNorth() {
      let p = players[2];
      let handLen = p.hand.length;
      let totalW = handLen * (TSW + 1);
      let startX = (W - totalW) / 2;
      let y = 8;

      ctx.fillStyle = currentTurn === 2 ? '#4a8' : '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      let label = 'N:' + p.points;
      if (p.riichi) label += ' R';
      ctx.fillText(label, W / 2, y + TSH + 13);

      for (let i = 0; i < handLen; i++) {
        drawTileGfx(startX + i * (TSW + 1), y, null, TSW, TSH, false, true);
      }

      let mx = startX + handLen * (TSW + 1) + 8;
      for (let m of p.melds) {
        for (let t of m.tiles) {
          drawTileGfx(mx, y, t, 16, 20, false, false);
          mx += 17;
        }
        mx += 3;
      }
    }

    function drawPlayerEast() {
      let p = players[3];
      let y0 = 100;
      ctx.fillStyle = currentTurn === 3 ? '#4a8' : '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      let label = 'E:' + p.points;
      if (p.riichi) label += ' R';
      ctx.fillText(label, W - 3, y0 - 4);

      let count = p.hand.length;
      let gap = Math.min(16, 230 / Math.max(count, 1));
      for (let i = 0; i < count; i++) {
        drawTileGfx(W - 8 - TSH, y0 + i * gap, null, TSH, TSW - 2, false, true);
      }

      let my = y0 + count * gap + 8;
      for (let m of p.melds) {
        for (let t of m.tiles) {
          drawTileGfx(W - 22, my, t, 16, 20, false, false);
          my += 17;
        }
        my += 3;
      }
    }

    function drawDiscards() {
      // Each player's discard pool in the center area
      let tw = 15, th = 20;
      let pools = [
        {x: 200, y: 305, maxRow: 11, dx: 1}, // south (bottom of center)
        {x: 120, y: 160, maxRow: 6, dx: 0},   // west
        {x: 200, y: 100, maxRow: 11, dx: 1},  // north
        {x: 455, y: 160, maxRow: 6, dx: 0},   // east
      ];

      for (let pi = 0; pi < 4; pi++) {
        let p = players[pi];
        let pool = pools[pi];
        for (let di = 0; di < p.discards.length; di++) {
          let row = Math.floor(di / pool.maxRow);
          let col = di % pool.maxRow;
          let tx, ty;
          if (pool.dx === 1) {
            tx = pool.x + col * (tw + 1);
            ty = pool.y + row * (th + 1);
          } else {
            tx = pool.x + row * (tw + 1);
            ty = pool.y + col * (th + 1);
          }
          drawTileGfx(tx, ty, p.discards[di], tw, th, false, false);
        }
      }
    }

    // ========== INPUT ==========
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', (e) => {
      let rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);

      hoveredTile = -1;
      if (turnPhase === 'discard' && currentTurn === 0) {
        let p = players[0];
        let handLen = p.hand.length;
        let meldTileCount = p.melds.reduce((s, m) => s + m.tiles.length, 0);
        let totalW = handLen * (TW + 2);
        let startX = Math.max(10, (W - totalW) / 2 - meldTileCount * 12);
        let y = H - TH - 18;

        for (let i = 0; i < handLen; i++) {
          let tx = startX + i * (TW + 2);
          if (mouseX >= tx && mouseX <= tx + TW && mouseY >= y - 10 && mouseY <= y + TH) {
            hoveredTile = i;
          }
        }
      }

      // Button hover
      for (let btn of callButtons) {
        btn.hover = mouseX >= btn.x && mouseX <= btn.x + btn.w &&
                    mouseY >= btn.y && mouseY <= btn.y + btn.h;
      }
    });

    canvas.addEventListener('click', (e) => {
      let rect = canvas.getBoundingClientRect();
      let cx = (e.clientX - rect.left) * (W / rect.width);
      let cy = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
        return;
      }

      // Call buttons
      if (turnPhase === 'call') {
        for (let btn of callButtons) {
          if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {
            handleCallAction(btn);
            return;
          }
        }
        return;
      }

      // Riichi button
      if (turnPhase === 'discard' && currentTurn === 0 && !players[0].riichi && players[0].points >= 1000) {
        if (cx >= 500 && cx <= 580 && cy >= 412 && cy <= 436) {
          let p0 = players[0];
          if (!p0.melds.some(m => m.open)) {
            p0.riichi = true;
            p0.riichiTurn = p0.discards.length;
            p0.points -= 1000;
            riichiSticks++;
            showMessage('You declare RIICHI!');
            score = p0.points;
            scoreEl.textContent = score;
            // Auto-discard: pick first that keeps tenpai
            for (let i = 0; i < p0.hand.length; i++) {
              let test = p0.hand.filter((_, j) => j !== i);
              if (isTenpai(test)) {
                doDiscard(0, i);
                return;
              }
            }
          }
          return;
        }
      }

      // Tile discard
      if (turnPhase === 'discard' && currentTurn === 0) {
        let p = players[0];
        let handLen = p.hand.length;
        let meldTileCount = p.melds.reduce((s, m) => s + m.tiles.length, 0);
        let totalW = handLen * (TW + 2);
        let startX = Math.max(10, (W - totalW) / 2 - meldTileCount * 12);
        let y = H - TH - 18;

        for (let i = 0; i < handLen; i++) {
          let tx = startX + i * (TW + 2);
          if (cx >= tx && cx <= tx + TW && cy >= y - 10 && cy <= y + TH) {
            if (p.riichi) {
              doDiscard(0, p.hand.length - 1);
            } else {
              doDiscard(0, i);
            }
            return;
          }
        }
      }
    });

    function handleCallAction(btn) {
      let savedAiCall = pendingAiCall;

      if (btn.action === 'pass' || btn.action === 'pass_tsumo') {
        callOptions = [];
        callButtons = [];
        pendingAiCall = null;
        if (savedAiCall) {
          executeCall(savedAiCall.seat, savedAiCall.decision || savedAiCall, savedAiCall.tile, discardSeat);
        } else {
          nextTurn();
        }
        return;
      }

      callOptions = [];
      callButtons = [];
      pendingAiCall = null;

      if (btn.action === 'tsumo') {
        declareTsumo(0);
        return;
      }
      if (btn.action === 'ron') {
        let data = btn.data;
        executeCall(0, {type: 'ron'}, data.tile, discardSeat);
        return;
      }
      if (btn.action === 'pon') {
        let data = btn.data;
        executeCall(0, {type: 'pon'}, data.tile, discardSeat);
        return;
      }
      if (btn.action === 'chi') {
        let data = btn.data;
        executeCall(0, {type: 'chi', combo: data.combo, tiles: data.combo}, data.tile, discardSeat);
        return;
      }
    }

    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') startGame();
    });

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';
      score = 25000;
      roundWind = 0;
      handNum = 0;
      riichiSticks = 0;
      // Initialize AI scores
      for (let i = 0; i < 4; i++) {
        if (!players[i]) players[i] = initPlayer(i);
      }
      dealHand();
      // Set initial points
      for (let i = 0; i < 4; i++) players[i].points = 25000;
      score = 25000;
      drawTileFromWall();
    }

    // ========== GAME LOOP ==========
    function gameLoop() {
      if (messageTimer > 0) messageTimer--;
      if (gameState === 'playing') {
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    // Initial decorative draw
    (function drawStartScreen() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);
      let demoTiles = ['m1','m2','m3','p4','p5','p6','s7','s8','s9','w1','w2','w3','w4','d1','d2','d3'];
      let startX = (W - demoTiles.length * 34) / 2;
      for (let i = 0; i < demoTiles.length; i++) {
        drawTileGfx(startX + i * 35, 380, demoTiles[i], 32, 44, false, false);
      }
      // Title decorations
      ctx.fillStyle = '#4a8';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('4-Player Riichi Mahjong', 300, 440);
    })();

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

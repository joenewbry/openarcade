<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paperboy</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #6ca; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102, 204, 170, 0.5); }
    h1 { color: #6ca; font-size: 2rem; text-shadow: 0 0 15px rgba(102, 204, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #6ca; }
    canvas {
      border: 2px solid #6ca;
      box-shadow: 0 0 20px rgba(102, 204, 170, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6ca;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; white-space: pre-line; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PAPERBOY</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Day: <span id="day">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">PAPERBOY</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const dayEl = document.getElementById('day');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Game constants
    const ROAD_TOP = 60;
    const ROAD_BOTTOM = H - 20;
    const ROAD_HEIGHT = ROAD_BOTTOM - ROAD_TOP;
    const LANE_COUNT = 4;
    const LANE_HEIGHT = ROAD_HEIGHT / LANE_COUNT;
    const SIDEWALK_Y = ROAD_TOP;
    const HOUSE_ZONE_TOP = 0;
    const HOUSE_ZONE_BOTTOM = ROAD_TOP;

    // Player bike
    const BIKE_W = 20;
    const BIKE_H = 30;

    // Scrolling
    const BASE_SCROLL_SPEED = 2;
    const MAX_SCROLL_SPEED = 4;

    // Houses
    const HOUSE_W = 50;
    const HOUSE_H = 48;
    const HOUSE_SPACING = 90;

    // Newspapers
    const PAPER_SIZE = 8;
    const PAPER_SPEED = 4;

    // Obstacles
    const OBS_TYPES = ['car', 'dog', 'skater', 'cone', 'grate'];

    let score, best = 0, gameState;
    let lives, day;
    let bikeX, bikeY, bikeLane;
    let scrollOffset, scrollSpeed;
    let houses, papers, obstacles;
    let frameCount;
    let keys = {};
    let crashTimer, crashX, crashY;
    let dayLength, housesDelivered, housesTotal;
    let dayComplete;
    let paperCooldown;

    // Particle effects
    let particles = [];

    function init() {
      score = 0;
      lives = 3;
      day = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      dayEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PAPERBOY';
      overlayText.textContent = 'Arrow keys to move, SPACE to throw\nDeliver papers to lit houses!';
      initDay();
      draw();
    }

    function initDay() {
      bikeX = 80;
      bikeLane = 2;
      bikeY = laneToY(bikeLane);
      scrollOffset = 0;
      scrollSpeed = BASE_SCROLL_SPEED + (day - 1) * 0.3;
      if (scrollSpeed > MAX_SCROLL_SPEED) scrollSpeed = MAX_SCROLL_SPEED;
      houses = [];
      papers = [];
      obstacles = [];
      particles = [];
      frameCount = 0;
      crashTimer = 0;
      dayComplete = false;
      paperCooldown = 0;
      housesDelivered = 0;
      housesTotal = 0;

      // Generate houses for this day
      dayLength = 12 + day * 2;
      if (dayLength > 30) dayLength = 30;
      for (let i = 0; i < dayLength; i++) {
        const isSubscriber = Math.random() < 0.55;
        if (isSubscriber) housesTotal++;
        houses.push({
          x: 300 + i * HOUSE_SPACING,
          isSubscriber: isSubscriber,
          delivered: false,
          hit: false
        });
      }

      // Pre-generate some obstacles
      generateObstacles();
    }

    function generateObstacles() {
      const numObs = Math.floor(dayLength * 0.8 + day * 1.2);
      for (let i = 0; i < numObs; i++) {
        const lane = Math.floor(Math.random() * LANE_COUNT);
        const minX = 400;
        const maxX = 300 + dayLength * HOUSE_SPACING - 100;
        const x = minX + Math.random() * (maxX - minX);
        const type = OBS_TYPES[Math.floor(Math.random() * OBS_TYPES.length)];
        obstacles.push({
          x: x,
          lane: lane,
          type: type,
          w: type === 'car' ? 40 : type === 'grate' ? 25 : 20,
          h: type === 'car' ? 22 : 18,
          moveDir: type === 'dog' ? (Math.random() < 0.5 ? 1 : -1) : 0,
          moveTimer: 0
        });
      }
    }

    function laneToY(lane) {
      return ROAD_TOP + lane * LANE_HEIGHT + LANE_HEIGHT / 2 - BIKE_H / 2;
    }

    function laneCenterY(lane) {
      return ROAD_TOP + lane * LANE_HEIGHT + LANE_HEIGHT / 2;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      if (crashTimer > 0) {
        crashTimer--;
        if (crashTimer === 0) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver();
            return;
          }
          // Reset bike position
          bikeX = 80;
          bikeLane = 2;
          bikeY = laneToY(bikeLane);
        }
        updateParticles();
        return;
      }

      // Scroll
      scrollOffset += scrollSpeed;

      // Player movement
      if (keys['ArrowUp']) {
        bikeY -= 2.5;
        const minY = ROAD_TOP + 2;
        if (bikeY < minY) bikeY = minY;
        bikeLane = Math.round((bikeY - ROAD_TOP) / LANE_HEIGHT);
      }
      if (keys['ArrowDown']) {
        bikeY += 2.5;
        const maxY = ROAD_BOTTOM - BIKE_H - 2;
        if (bikeY > maxY) bikeY = maxY;
        bikeLane = Math.round((bikeY - ROAD_TOP) / LANE_HEIGHT);
      }
      if (keys['ArrowRight']) {
        scrollSpeed = BASE_SCROLL_SPEED + (day - 1) * 0.3 + 1.5;
        if (scrollSpeed > MAX_SCROLL_SPEED + 1) scrollSpeed = MAX_SCROLL_SPEED + 1;
      } else if (keys['ArrowLeft']) {
        scrollSpeed = Math.max(1, BASE_SCROLL_SPEED + (day - 1) * 0.3 - 1);
      } else {
        scrollSpeed = BASE_SCROLL_SPEED + (day - 1) * 0.3;
        if (scrollSpeed > MAX_SCROLL_SPEED) scrollSpeed = MAX_SCROLL_SPEED;
      }

      // Paper cooldown
      if (paperCooldown > 0) paperCooldown--;

      // Update papers (paper.x is in world coords, paper.y is in screen coords)
      for (let i = papers.length - 1; i >= 0; i--) {
        const p = papers[i];
        p.x += PAPER_SPEED + scrollSpeed;
        p.y -= 4;
        p.rotation += 0.3;

        // Screen position of paper
        const paperScreenX = p.x - scrollOffset;
        let hitHouse = false;

        // Check if paper hit a house mailbox zone
        for (let h = 0; h < houses.length; h++) {
          const house = houses[h];
          if (house.delivered || house.hit) continue;
          const houseScreenX = house.x - scrollOffset;
          const mailboxX = houseScreenX + HOUSE_W / 2;
          const mailboxY = HOUSE_ZONE_BOTTOM - 5;

          if (Math.abs(paperScreenX - mailboxX) < 25 && p.y < ROAD_TOP + 10) {
            if (house.isSubscriber) {
              house.delivered = true;
              housesDelivered++;
              // Perfect hit bonus
              if (Math.abs(paperScreenX - mailboxX) < 10) {
                score += 50;
                spawnParticles(paperScreenX, mailboxY, '#ff0', 8);
              } else {
                score += 25;
                spawnParticles(paperScreenX, mailboxY, '#6ca', 5);
              }
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }
            } else {
              // Hit non-subscriber - penalty
              house.hit = true;
              score = Math.max(0, score - 15);
              scoreEl.textContent = score;
              spawnParticles(paperScreenX, mailboxY, '#f44', 5);
            }
            hitHouse = true;
            papers.splice(i, 1);
            break;
          }
        }

        if (!hitHouse) {
          // Remove papers that go off screen
          if (paperScreenX > W + 50 || p.y < -20) {
            papers.splice(i, 1);
          }
        }
      }

      // Update obstacles
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        // Dogs wander between lanes
        if (obs.type === 'dog') {
          obs.moveTimer++;
          if (obs.moveTimer > 60) {
            obs.moveTimer = 0;
            obs.lane += obs.moveDir;
            if (obs.lane <= 0 || obs.lane >= LANE_COUNT - 1) {
              obs.moveDir *= -1;
              obs.lane = Math.max(0, Math.min(LANE_COUNT - 1, obs.lane));
            }
          }
        }

        // Collision with bike
        const obsScreenX = obs.x - scrollOffset;
        const obsY = laneCenterY(obs.lane) - obs.h / 2;
        if (obsScreenX > -50 && obsScreenX < W + 50) {
          if (rectsOverlap(
            bikeX, bikeY, BIKE_W, BIKE_H,
            obsScreenX, obsY, obs.w, obs.h
          )) {
            crash(bikeX, bikeY);
            return;
          }
        }
      }

      // Check for missed subscriber houses (scrolled past)
      for (let h = 0; h < houses.length; h++) {
        const house = houses[h];
        const houseScreenX = house.x - scrollOffset;
        if (houseScreenX < -HOUSE_W && house.isSubscriber && !house.delivered && !house.missed) {
          house.missed = true;
          score = Math.max(0, score - 10);
          scoreEl.textContent = score;
        }
      }

      // Check if day is complete (scrolled past all houses)
      const lastHouse = houses[houses.length - 1];
      if (lastHouse && (lastHouse.x - scrollOffset) < -HOUSE_W * 2) {
        completeDayLevel();
      }

      updateParticles();
    }

    function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    function crash(x, y) {
      crashTimer = 40;
      crashX = x;
      crashY = y;
      spawnParticles(x, y, '#f44', 15);
      spawnParticles(x, y, '#ff0', 8);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 20 + Math.random() * 20,
          maxLife: 40,
          color: color,
          size: 2 + Math.random() * 3
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function completeDayLevel() {
      // Bonus for deliveries
      const deliveryBonus = housesDelivered * 20;
      // Perfect day bonus
      const perfectBonus = (housesDelivered === housesTotal && housesTotal > 0) ? 100 * day : 0;
      score += deliveryBonus + perfectBonus;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      day++;
      dayEl.textContent = day;
      initDay();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Day ${day}\nDelivered: ${housesDelivered}/${housesTotal}\nPress any key to restart`;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function throwPaper() {
      if (paperCooldown > 0) return;
      paperCooldown = 15;
      papers.push({
        x: bikeX + BIKE_W + scrollOffset,
        y: bikeY,
        rotation: 0
      });
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Sky gradient at top
      const skyGrad = ctx.createLinearGradient(0, 0, 0, HOUSE_ZONE_BOTTOM);
      skyGrad.addColorStop(0, '#0d0d1a');
      skyGrad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, HOUSE_ZONE_BOTTOM);

      // Draw houses
      drawHouses();

      // Sidewalk
      ctx.fillStyle = '#2a2a3e';
      ctx.fillRect(0, ROAD_TOP - 8, W, 10);
      ctx.fillStyle = '#3a3a4e';
      // Sidewalk pattern
      for (let x = -(scrollOffset % 20); x < W; x += 20) {
        ctx.fillRect(x, ROAD_TOP - 8, 18, 2);
      }

      // Road
      ctx.fillStyle = '#111122';
      ctx.fillRect(0, ROAD_TOP, W, ROAD_HEIGHT);

      // Lane markings
      ctx.setLineDash([20, 15]);
      ctx.strokeStyle = '#333350';
      ctx.lineWidth = 1;
      for (let i = 1; i < LANE_COUNT; i++) {
        const ly = ROAD_TOP + i * LANE_HEIGHT;
        ctx.beginPath();
        ctx.moveTo(-(scrollOffset % 35), ly);
        ctx.lineTo(W, ly);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Road edges
      ctx.fillStyle = '#6ca';
      ctx.shadowColor = '#6ca';
      ctx.shadowBlur = 4;
      ctx.fillRect(0, ROAD_TOP, W, 2);
      ctx.fillRect(0, ROAD_BOTTOM, W, 2);
      ctx.shadowBlur = 0;

      // Curb
      ctx.fillStyle = '#444460';
      ctx.fillRect(0, ROAD_BOTTOM + 2, W, 18);
      // Curb detail
      for (let x = -(scrollOffset % 30); x < W; x += 30) {
        ctx.fillStyle = '#333348';
        ctx.fillRect(x, ROAD_BOTTOM + 4, 2, 14);
      }

      // Draw obstacles
      drawObstacles();

      // Draw newspapers in flight
      drawPapers();

      // Draw bike
      if (crashTimer > 0) {
        drawCrashBike();
      } else {
        drawBike(bikeX, bikeY);
      }

      // Draw particles
      drawParticles();

      // HUD on canvas: delivery progress
      ctx.fillStyle = '#6ca';
      ctx.shadowColor = '#6ca';
      ctx.shadowBlur = 6;
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`Deliveries: ${housesDelivered}/${housesTotal}`, 10, H - 5);
      ctx.shadowBlur = 0;

      // Papers remaining indicator
      ctx.textAlign = 'right';
      ctx.fillStyle = '#aaa';
      ctx.fillText('SPACE = throw', W - 10, H - 5);
    }

    function drawHouses() {
      for (let i = 0; i < houses.length; i++) {
        const house = houses[i];
        const sx = house.x - scrollOffset;
        if (sx < -HOUSE_W - 10 || sx > W + 10) continue;

        const baseY = HOUSE_ZONE_BOTTOM - HOUSE_H - 2;

        if (house.isSubscriber) {
          // Subscriber house - brighter, with glow
          if (house.delivered) {
            ctx.fillStyle = '#1a4a3a';
          } else {
            ctx.fillStyle = '#1a3a4a';
          }
        } else {
          // Non-subscriber - dimmer
          ctx.fillStyle = '#1a1a28';
        }

        // House body
        ctx.fillRect(sx, baseY + 12, HOUSE_W, HOUSE_H - 12);

        // Roof (triangle)
        ctx.beginPath();
        ctx.moveTo(sx - 4, baseY + 14);
        ctx.lineTo(sx + HOUSE_W / 2, baseY);
        ctx.lineTo(sx + HOUSE_W + 4, baseY + 14);
        ctx.closePath();
        if (house.isSubscriber) {
          ctx.fillStyle = house.delivered ? '#2a6a4a' : '#2a4a5a';
        } else {
          ctx.fillStyle = '#22222e';
        }
        ctx.fill();

        // Door
        ctx.fillStyle = house.isSubscriber ? '#3a6a7a' : '#222238';
        ctx.fillRect(sx + HOUSE_W / 2 - 5, baseY + 30, 10, 18);

        // Window
        if (house.isSubscriber && !house.delivered) {
          ctx.fillStyle = '#ff8';
          ctx.shadowColor = '#ff8';
          ctx.shadowBlur = 8;
          ctx.fillRect(sx + 8, baseY + 18, 10, 8);
          ctx.fillRect(sx + HOUSE_W - 18, baseY + 18, 10, 8);
          ctx.shadowBlur = 0;
        } else {
          ctx.fillStyle = '#1a1a2e';
          ctx.fillRect(sx + 8, baseY + 18, 10, 8);
          ctx.fillRect(sx + HOUSE_W - 18, baseY + 18, 10, 8);
        }

        // Mailbox
        const mbx = sx + HOUSE_W / 2;
        const mby = HOUSE_ZONE_BOTTOM - 6;
        ctx.fillStyle = house.isSubscriber ? '#6ca' : '#444';
        ctx.fillRect(mbx - 3, mby, 6, 6);
        ctx.fillRect(mbx - 1, mby - 4, 2, 4);

        // Subscriber indicator - glowing border
        if (house.isSubscriber && !house.delivered) {
          ctx.strokeStyle = '#6ca';
          ctx.shadowColor = '#6ca';
          ctx.shadowBlur = 6;
          ctx.lineWidth = 1;
          ctx.strokeRect(sx - 2, baseY - 2, HOUSE_W + 4, HOUSE_H + 6);
          ctx.shadowBlur = 0;
        }

        // Delivery checkmark
        if (house.delivered) {
          ctx.fillStyle = '#0f0';
          ctx.shadowColor = '#0f0';
          ctx.shadowBlur = 8;
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('\u2713', sx + HOUSE_W / 2, baseY + 10);
          ctx.shadowBlur = 0;
        }

        // Hit X mark
        if (house.hit) {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 8;
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('\u2717', sx + HOUSE_W / 2, baseY + 10);
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawObstacles() {
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        const sx = obs.x - scrollOffset;
        if (sx < -50 || sx > W + 50) continue;

        const oy = laneCenterY(obs.lane) - obs.h / 2;

        switch (obs.type) {
          case 'car':
            drawCar(sx, oy, obs.w, obs.h);
            break;
          case 'dog':
            drawDog(sx, oy);
            break;
          case 'skater':
            drawSkater(sx, oy);
            break;
          case 'cone':
            drawCone(sx, oy);
            break;
          case 'grate':
            drawGrate(sx, oy, obs.w);
            break;
        }
      }
    }

    function drawCar(x, y, w, h) {
      // Car body
      ctx.fillStyle = '#c44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      ctx.fillRect(x, y + 4, w, h - 4);
      // Windshield
      ctx.fillStyle = '#48f';
      ctx.fillRect(x + w - 10, y + 7, 8, h - 10);
      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(x + 4, y + 1, 8, 5);
      ctx.fillRect(x + 4, y + h - 2, 8, 5);
      ctx.fillRect(x + w - 12, y + 1, 8, 5);
      ctx.fillRect(x + w - 12, y + h - 2, 8, 5);
      // Headlights
      ctx.fillStyle = '#ff0';
      ctx.fillRect(x + w - 2, y + 6, 3, 4);
      ctx.fillRect(x + w - 2, y + h - 6, 3, 4);
      ctx.shadowBlur = 0;
    }

    function drawDog(x, y) {
      // Simple dog shape
      ctx.fillStyle = '#a86';
      ctx.shadowColor = '#a86';
      ctx.shadowBlur = 4;
      // Body
      ctx.fillRect(x, y + 6, 16, 10);
      // Head
      ctx.fillRect(x + 14, y + 3, 8, 10);
      // Legs
      ctx.fillStyle = '#865';
      ctx.fillRect(x + 2, y + 14, 3, 6);
      ctx.fillRect(x + 10, y + 14, 3, 6);
      // Eye
      ctx.fillStyle = '#f00';
      ctx.fillRect(x + 19, y + 5, 2, 2);
      // Tail
      ctx.fillRect(x - 3, y + 4, 4, 2);
      ctx.shadowBlur = 0;
    }

    function drawSkater(x, y) {
      // Skateboarder
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 4;
      // Board
      ctx.fillRect(x, y + 18, 20, 3);
      // Wheels
      ctx.fillStyle = '#888';
      ctx.fillRect(x + 2, y + 21, 4, 3);
      ctx.fillRect(x + 14, y + 21, 4, 3);
      // Body
      ctx.fillStyle = '#f80';
      ctx.fillRect(x + 6, y + 4, 8, 14);
      // Head
      ctx.fillStyle = '#fca';
      ctx.fillRect(x + 7, y, 6, 6);
      ctx.shadowBlur = 0;
    }

    function drawCone(x, y) {
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 6;
      // Base
      ctx.fillRect(x, y + 14, 16, 4);
      // Cone body
      ctx.beginPath();
      ctx.moveTo(x + 2, y + 14);
      ctx.lineTo(x + 8, y + 2);
      ctx.lineTo(x + 14, y + 14);
      ctx.closePath();
      ctx.fill();
      // Stripe
      ctx.fillStyle = '#fff';
      ctx.fillRect(x + 5, y + 8, 6, 2);
      ctx.shadowBlur = 0;
    }

    function drawGrate(x, y, w) {
      ctx.fillStyle = '#333';
      ctx.fillRect(x, y + 6, w, 16);
      // Grate lines
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      for (let gx = x + 3; gx < x + w - 2; gx += 4) {
        ctx.beginPath();
        ctx.moveTo(gx, y + 8);
        ctx.lineTo(gx, y + 20);
        ctx.stroke();
      }
    }

    function drawBike(x, y) {
      // Bike frame
      ctx.strokeStyle = '#6ca';
      ctx.shadowColor = '#6ca';
      ctx.shadowBlur = 8;
      ctx.lineWidth = 2;

      // Wheels
      ctx.beginPath();
      ctx.arc(x + 4, y + BIKE_H - 6, 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + BIKE_W - 4, y + BIKE_H - 6, 5, 0, Math.PI * 2);
      ctx.stroke();

      // Frame
      ctx.beginPath();
      ctx.moveTo(x + 4, y + BIKE_H - 6);
      ctx.lineTo(x + 10, y + 10);
      ctx.lineTo(x + BIKE_W - 4, y + BIKE_H - 6);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + 10, y + 10);
      ctx.lineTo(x + BIKE_W - 4, y + 10);
      ctx.lineTo(x + BIKE_W - 4, y + BIKE_H - 6);
      ctx.stroke();

      // Rider body
      ctx.fillStyle = '#6ca';
      ctx.fillRect(x + 8, y + 2, 6, 10);

      // Rider head
      ctx.fillStyle = '#fca';
      ctx.beginPath();
      ctx.arc(x + 11, y, 4, 0, Math.PI * 2);
      ctx.fill();

      // Newspaper bag
      ctx.fillStyle = '#886';
      ctx.fillRect(x + 14, y + 4, 6, 8);
      ctx.fillStyle = '#aaa';
      ctx.fillRect(x + 15, y + 5, 4, 2);

      ctx.shadowBlur = 0;
    }

    function drawCrashBike() {
      // Flashing crash effect
      const flash = Math.floor(crashTimer / 4) % 2 === 0;
      if (flash) {
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 15;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('CRASH!', bikeX + BIKE_W / 2, bikeY + BIKE_H / 2);
        ctx.shadowBlur = 0;
      }

      // Tilted bike
      ctx.save();
      ctx.translate(bikeX + BIKE_W / 2, bikeY + BIKE_H / 2);
      ctx.rotate((40 - crashTimer) * 0.05);
      ctx.globalAlpha = crashTimer / 40;
      drawBikeShape(0, 0);
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawBikeShape(cx, cy) {
      const x = cx - BIKE_W / 2;
      const y = cy - BIKE_H / 2;
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 4, y + BIKE_H - 6, 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x + BIKE_W - 4, y + BIKE_H - 6, 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + 4, y + BIKE_H - 6);
      ctx.lineTo(x + 10, y + 10);
      ctx.lineTo(x + BIKE_W - 4, y + BIKE_H - 6);
      ctx.stroke();
    }

    function drawPapers() {
      for (let i = 0; i < papers.length; i++) {
        const p = papers[i];
        const sx = p.x - scrollOffset;
        ctx.save();
        ctx.translate(sx, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 6;
        ctx.fillRect(-PAPER_SIZE / 2, -PAPER_SIZE / 2, PAPER_SIZE, PAPER_SIZE * 0.7);
        // Fold line
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(-PAPER_SIZE / 2, 0);
        ctx.lineTo(PAPER_SIZE / 2, 0);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawParticles() {
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
        if (e.key === ' ') {
          throwPaper();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Expose game data for ML training
    window.gameData = {
      get bikeX() { return bikeX; },
      get bikeY() { return bikeY; },
      get papers() { return papers.length; },
      get obstacles() { return obstacles.filter(o => {
        const sx = o.x - scrollOffset;
        return sx > -50 && sx < W + 50;
      }).map(o => ({ x: o.x - scrollOffset, lane: o.lane, type: o.type })); },
      get houses() { return houses.filter(h => {
        const sx = h.x - scrollOffset;
        return sx > -50 && sx < W + 50;
      }).map(h => ({ x: h.x - scrollOffset, isSubscriber: h.isSubscriber, delivered: h.delivered })); }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

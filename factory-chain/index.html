<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Factory Chain</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 12px;
      width: 600px;
    }
    .back { color: #fa0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 170, 0, 0.4); }
    h1 { color: #fa0; font-size: 1.7rem; text-shadow: 0 0 15px rgba(255, 170, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fa0; }
    .timer { color: #ccc; font-size: 1rem; font-weight: bold; }
    canvas {
      border: 2px solid #fa0;
      box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fa0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.9);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255, 170, 0, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 6px; line-height: 1.6; }
    .toolbar {
      display: flex;
      gap: 6px;
      width: 600px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .toolbar button {
      background: #16213e;
      color: #fa0;
      border: 1px solid #fa0;
      padding: 6px 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.82rem;
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.15s;
    }
    .toolbar button:hover { background: #1e2d4f; box-shadow: 0 0 8px rgba(255, 170, 0, 0.3); }
    .toolbar button.active { background: #fa0; color: #1a1a2e; font-weight: bold; }
    .info {
      width: 600px;
      margin-top: 6px;
      font-size: 0.75rem;
      color: #888;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>FACTORY CHAIN</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div class="timer" id="timer">3:00</div>
    <div>AI: <span id="aiScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">FACTORY CHAIN</h2>
      <p id="overlayText">Click anywhere to start</p>
    </div>
  </div>
  <div class="toolbar" id="toolbar">
    <button id="btnSmelter" onclick="selectTool('smelter')">Smelter $5</button>
    <button id="btnAssembler" onclick="selectTool('assembler')">Assembler $8</button>
    <button id="btnConstructor" onclick="selectTool('constructor')">Constructor $12</button>
    <button id="btnBelt" onclick="selectTool('belt')">Belt $1</button>
    <button id="btnDelete" onclick="selectTool('delete')">Delete</button>
  </div>
  <div class="info" id="infoText">Place machines on your factory floor. Connect with belts. Produce goods for points!</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const infoEl = document.getElementById('infoText');

    let gameState = 'waiting';
    let score = 0;

    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (e.key === '1') selectTool('smelter');
      if (e.key === '2') selectTool('assembler');
      if (e.key === '3') selectTool('constructor');
      if (e.key === '4') selectTool('belt');
      if (e.key === '5' || e.key === 'x') selectTool('delete');
      if (e.key === 'Escape') { selectedTool = null; beltStart = null; updateButtons(); }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // ---- Constants ----
    const COLS = 10, ROWS = 8, CELL = 27;
    const DIV_X = 300;
    const P_OX = 8, P_OY = 42;   // player factory pixel offset
    const A_OX = 308, A_OY = 42;  // AI factory pixel offset
    const GAME_SECS = 180;

    const MTYPE = {
      smelter:     { name:'Smelter',     cost:5,  w:2, h:2, ticks:80,  input:'ore',   output:'ingot',   col:'#e88030', sym:'S', val:2  },
      assembler:   { name:'Assembler',   cost:8,  w:2, h:2, ticks:110, input:'ingot', output:'part',    col:'#50a0e0', sym:'A', val:5  },
      constructor: { name:'Constructor', cost:12, w:2, h:2, ticks:150, input:'part',  output:'product', col:'#b060e0', sym:'C', val:15 },
    };

    // ---- State ----
    let timeLeft, playerMoney, aiMoney, pScore, aScore;
    let pGrid, aGrid; // 2D: 0=empty, 'b'=belt, 'm<id>'=machine cell
    let pMachines, aMachines; // [{id, type, gx, gy, inBuf, progress, outBuf}]
    let pBelts, aBelts; // [{gx, gy, dir}]  dir: 0=right,1=down,2=left,3=up
    let selectedTool, beltStart, hoverCell;
    let lastTime, aiTimer, machineIdCounter;

    function makeGrid() {
      const g = [];
      for (let r = 0; r < ROWS; r++) { g[r] = []; for (let c = 0; c < COLS; c++) g[r][c] = 0; }
      return g;
    }

    function init() {
      gameState = 'waiting';
      score = 0; pScore = 0; aScore = 0;
      playerMoney = 25; aiMoney = 25;
      timeLeft = GAME_SECS;
      pGrid = makeGrid(); aGrid = makeGrid();
      pMachines = []; aMachines = [];
      pBelts = []; aBelts = [];
      selectedTool = null; beltStart = null; hoverCell = null;
      lastTime = 0; aiTimer = 0; machineIdCounter = 1;
      updateButtons();
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'FACTORY CHAIN';
      overlayText.innerHTML = 'Build production chains faster than the AI!<br><br>Ore \u2192 Smelter \u2192 Ingot \u2192 Assembler \u2192 Part \u2192 Constructor \u2192 Product<br><br>Click to start';
      scoreEl.textContent = '0'; aiScoreEl.textContent = '0'; timerEl.textContent = '3:00';
      infoEl.textContent = 'Place machines on your factory floor. Connect with belts. Produce goods for points!';
      draw();
    }

    function startGame() {
      if (gameState === 'playing') return;
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    // ---- Placement helpers ----
    function canPlace(grid, gx, gy, type) {
      const t = MTYPE[type];
      if (gx < 0 || gy < 0 || gx + t.w > COLS || gy + t.h > ROWS) return false;
      for (let dy = 0; dy < t.h; dy++)
        for (let dx = 0; dx < t.w; dx++)
          if (grid[gy+dy][gx+dx] !== 0) return false;
      return true;
    }

    function placeMach(grid, machines, gx, gy, type) {
      const id = machineIdCounter++;
      const m = { id, type, gx, gy, inBuf: 0, progress: 0, outBuf: 0 };
      machines.push(m);
      const t = MTYPE[type];
      for (let dy = 0; dy < t.h; dy++)
        for (let dx = 0; dx < t.w; dx++)
          grid[gy+dy][gx+dx] = 'm'+id;
      return m;
    }

    function placeBeltLine(grid, belts, x1, y1, x2, y2) {
      // L-shaped path: horizontal first, then vertical
      let placed = 0;
      let cx = x1, cy = y1;
      const steps = Math.abs(x2-x1) + Math.abs(y2-y1);
      for (let s = 0; s <= steps && s < 40; s++) {
        if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS && grid[cy][cx] === 0) {
          grid[cy][cx] = 'b';
          // Determine direction
          let dir = 0; // right by default
          if (cx !== x2) dir = x2 > cx ? 0 : 2;
          else if (cy !== y2) dir = y2 > cy ? 1 : 3;
          belts.push({ gx: cx, gy: cy, dir });
          placed++;
        }
        if (cx !== x2) cx += x2 > cx ? 1 : -1;
        else if (cy !== y2) cy += y2 > cy ? 1 : -1;
        else break;
      }
      return placed;
    }

    function removeTile(grid, machines, belts, gx, gy) {
      if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return 0;
      const cell = grid[gy][gx];
      if (cell === 'b') {
        grid[gy][gx] = 0;
        const i = belts.findIndex(b => b.gx === gx && b.gy === gy);
        if (i >= 0) belts.splice(i, 1);
        return 0;
      }
      if (typeof cell === 'string' && cell[0] === 'm') {
        const mid = parseInt(cell.substring(1));
        const mi = machines.findIndex(m => m.id === mid);
        if (mi >= 0) {
          const m = machines[mi];
          const t = MTYPE[m.type];
          for (let dy = 0; dy < t.h; dy++)
            for (let dx = 0; dx < t.w; dx++)
              grid[m.gy+dy][m.gx+dx] = 0;
          machines.splice(mi, 1);
          return Math.floor(t.cost / 2); // refund half
        }
      }
      return 0;
    }

    // ---- Production simulation ----
    // For each machine, check connectivity:
    //  - Smelter: if left side touches column 0 or belt path leads to col 0 -> gets ore automatically
    //  - Assembler/Constructor: if connected to a machine that outputs its required input type
    //  - Output: right side connects to next machine or reaches right edge (col COLS-1 + belt to edge)

    function getMachineById(machines, id) {
      return machines.find(m => m.id === id);
    }

    // Walk belts in a direction from a starting cell to find what they connect to
    function walkBelts(grid, machines, startX, startY, direction) {
      // direction: 'left' or 'right'
      const dx = direction === 'right' ? 1 : -1;
      let x = startX, y = startY;
      const visited = new Set();
      for (let steps = 0; steps < 30; steps++) {
        const key = x + ',' + y;
        if (visited.has(key)) break;
        visited.add(key);
        const cell = grid[y] && grid[y][x];
        if (cell === undefined) break;

        // Check if we're at a machine cell (not the start)
        if (steps > 0 && typeof cell === 'string' && cell[0] === 'm') {
          const mid = parseInt(cell.substring(1));
          return { type: 'machine', machine: getMachineById(machines, mid) };
        }

        // Check edge
        if (direction === 'right' && x >= COLS) return { type: 'exit' };
        if (direction === 'left' && x < 0) return { type: 'edge' };

        // If not belt (and not start), stop
        if (steps > 0 && cell !== 'b') break;

        // Try to continue in primary direction, also check perpendicular
        let nx = x + dx, ny = y;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
          const nc = grid[ny][nx];
          if (nc === 'b' || (typeof nc === 'string' && nc[0] === 'm')) { x = nx; continue; }
        }
        // Check if stepping off the grid = exit/edge
        if (nx >= COLS && direction === 'right') return { type: 'exit' };
        if (nx < 0 && direction === 'left') return { type: 'edge' };

        // Try perpendicular (down then up)
        let found = false;
        for (const pdy of [1, -1]) {
          const py = y + pdy;
          if (py >= 0 && py < ROWS) {
            const pc = grid[py][x];
            if (pc === 'b' || (typeof pc === 'string' && pc[0] === 'm')) {
              y = py; found = true; break;
            }
          }
        }
        if (!found) break;
      }
      return null;
    }

    // Check if a machine's input is connected
    function getInputSource(grid, machines, m) {
      const t = MTYPE[m.type];
      // Check left side of machine
      const lx = m.gx - 1;
      if (m.gx === 0) return { type: 'edge' }; // at left edge

      for (let dy = 0; dy < t.h; dy++) {
        if (lx >= 0 && lx < COLS) {
          const cell = grid[m.gy + dy][lx];
          if (cell === 'b') {
            const result = walkBelts(grid, machines, lx, m.gy + dy, 'left');
            if (result) return result;
          }
          if (typeof cell === 'string' && cell[0] === 'm') {
            const mid = parseInt(cell.substring(1));
            const src = getMachineById(machines, mid);
            if (src) return { type: 'machine', machine: src };
          }
        }
      }
      return null;
    }

    // Check what a machine outputs to
    function getOutputDest(grid, machines, m) {
      const t = MTYPE[m.type];
      const rx = m.gx + t.w;
      if (rx >= COLS) return { type: 'exit' }; // at right edge

      for (let dy = 0; dy < t.h; dy++) {
        if (rx >= 0 && rx < COLS) {
          const cell = grid[m.gy + dy][rx];
          if (cell === 'b') {
            const result = walkBelts(grid, machines, rx, m.gy + dy, 'right');
            if (result) return result;
          }
          if (typeof cell === 'string' && cell[0] === 'm') {
            const mid = parseInt(cell.substring(1));
            const dst = getMachineById(machines, mid);
            if (dst) return { type: 'machine', machine: dst };
          }
        }
      }
      return null;
    }

    function simulate(dt, grid, machines, belts) {
      const tick = dt / (1000 / 60); // normalize to 60fps ticks
      let earned = 0;

      for (const m of machines) {
        const t = MTYPE[m.type];

        // Feed input
        if (m.inBuf < 3) {
          const src = getInputSource(grid, machines, m);
          if (src) {
            if (m.type === 'smelter') {
              // Smelter gets ore from edge or belt-to-edge
              if (src.type === 'edge') {
                m.inBuf = Math.min(3, m.inBuf + 0.025 * tick);
              } else if (src.type === 'machine' && src.machine) {
                const srcT = MTYPE[src.machine.type];
                if (srcT.output === t.input && src.machine.outBuf >= 1) {
                  src.machine.outBuf -= 1;
                  m.inBuf += 1;
                }
              }
            } else {
              // Assembler/Constructor: needs output from previous machine
              if (src.type === 'machine' && src.machine) {
                const srcT = MTYPE[src.machine.type];
                if (srcT.output === t.input && src.machine.outBuf >= 1) {
                  src.machine.outBuf -= 1;
                  m.inBuf += 1;
                }
              }
            }
          }
        }

        // Process
        if (m.inBuf >= 1 && m.outBuf < 3) {
          m.progress += tick;
          if (m.progress >= t.ticks) {
            m.progress = 0;
            m.inBuf -= 1;
            m.outBuf += 1;
          }
        }

        // Push output
        if (m.outBuf >= 1) {
          const dest = getOutputDest(grid, machines, m);
          if (dest) {
            if (dest.type === 'exit') {
              earned += MTYPE[m.type].val;
              m.outBuf -= 1;
            } else if (dest.type === 'machine' && dest.machine) {
              // Don't push here; let the downstream machine pull
            }
          }
        }
      }

      return earned;
    }

    // ---- AI Strategy ----
    // Greedy: build chains S->A->C from left to right with belts connecting
    let aiBuiltPhase = 0;

    function aiAct() {
      const sm = aMachines.filter(m => m.type === 'smelter');
      const as = aMachines.filter(m => m.type === 'assembler');
      const cs = aMachines.filter(m => m.type === 'constructor');

      // Phase 0: Build first smelter at col 0
      if (sm.length === 0 && aiMoney >= 5) {
        const pos = aiFind('smelter', 0, 1);
        if (pos) { aiMoney -= 5; placeMach(aGrid, aMachines, pos.x, pos.y, 'smelter'); return; }
      }

      // Phase 1: Connect smelter output with belts, add assembler
      if (sm.length >= 1 && as.length === 0 && aiMoney >= 10) {
        // Place assembler at col 4
        const pos = aiFind('assembler', 4, 6);
        if (pos) {
          aiMoney -= 8;
          const m = placeMach(aGrid, aMachines, pos.x, pos.y, 'assembler');
          // Belt from smelter to assembler
          const s = sm[0];
          const cost = aiConnectBelt(s, m);
          aiMoney -= cost;
          return;
        }
      }

      // Phase 2: Connect assembler to right edge with belts
      if (as.length >= 1 && cs.length === 0) {
        // First try to belt assembler output to exit
        const a = as[0];
        const dest = getOutputDest(aGrid, aMachines, a);
        if (!dest && aiMoney >= 2) {
          const rx = a.gx + MTYPE.assembler.w;
          for (let x = rx; x < COLS && aiMoney >= 1; x++) {
            if (aGrid[a.gy][x] === 0) {
              aGrid[a.gy][x] = 'b';
              aBelts.push({ gx: x, gy: a.gy, dir: 0 });
              aiMoney -= 1;
            }
          }
          return;
        }
      }

      // Phase 3: Add constructor
      if (as.length >= 1 && cs.length === 0 && aiMoney >= 14) {
        const pos = aiFind('constructor', 7, 8);
        if (pos) {
          aiMoney -= 12;
          const m = placeMach(aGrid, aMachines, pos.x, pos.y, 'constructor');
          const a = as[0];
          const cost = aiConnectBelt(a, m);
          aiMoney -= cost;
          // Belt constructor to right edge
          const rx2 = m.gx + MTYPE.constructor.w;
          for (let x = rx2; x < COLS && aiMoney >= 1; x++) {
            if (aGrid[m.gy][x] === 0) {
              aGrid[m.gy][x] = 'b';
              aBelts.push({ gx: x, gy: m.gy, dir: 0 });
              aiMoney -= 1;
            }
          }
          return;
        }
      }

      // Phase 4: Build second chain if money allows
      if (sm.length < 2 && aiMoney >= 6) {
        const pos = aiFind('smelter', 0, 1);
        if (pos) { aiMoney -= 5; placeMach(aGrid, aMachines, pos.x, pos.y, 'smelter'); return; }
      }

      if (sm.length >= 2 && as.length < 2 && aiMoney >= 10) {
        const pos = aiFind('assembler', 3, 6);
        if (pos) {
          aiMoney -= 8;
          const m = placeMach(aGrid, aMachines, pos.x, pos.y, 'assembler');
          const s = sm.find(s2 => !getOutputDest(aGrid, aMachines, s2) || getOutputDest(aGrid, aMachines, s2).type === 'exit') || sm[sm.length - 1];
          const cost = aiConnectBelt(s, m);
          aiMoney -= cost;
          // Belt to edge
          const rx = m.gx + MTYPE.assembler.w;
          for (let x = rx; x < COLS && aiMoney >= 1; x++) {
            if (aGrid[m.gy][x] === 0) {
              aGrid[m.gy][x] = 'b';
              aBelts.push({ gx: x, gy: m.gy, dir: 0 });
              aiMoney -= 1;
            }
          }
          return;
        }
      }

      // Phase 5: More constructors
      if (as.length >= 2 && cs.length < 2 && aiMoney >= 14) {
        const pos = aiFind('constructor', 6, 8);
        if (pos) {
          aiMoney -= 12;
          const m = placeMach(aGrid, aMachines, pos.x, pos.y, 'constructor');
          const a = as.find(a2 => {
            const d = getOutputDest(aGrid, aMachines, a2);
            return !d || d.type === 'exit';
          }) || as[as.length - 1];
          const cost = aiConnectBelt(a, m);
          aiMoney -= cost;
          const rx = m.gx + MTYPE.constructor.w;
          for (let x = rx; x < COLS && aiMoney >= 1; x++) {
            if (aGrid[m.gy][x] === 0) {
              aGrid[m.gy][x] = 'b';
              aBelts.push({ gx: x, gy: m.gy, dir: 0 });
              aiMoney -= 1;
            }
          }
          return;
        }
      }

      // Ensure all machine outputs have exit paths
      for (const m of aMachines) {
        const dest = getOutputDest(aGrid, aMachines, m);
        if (!dest && aiMoney >= 1) {
          const t = MTYPE[m.type];
          const rx = m.gx + t.w;
          for (let x = rx; x < COLS && aiMoney >= 1; x++) {
            if (aGrid[m.gy][x] === 0) {
              aGrid[m.gy][x] = 'b';
              aBelts.push({ gx: x, gy: m.gy, dir: 0 });
              aiMoney -= 1;
            }
          }
          return;
        }
      }
    }

    function aiFind(type, minC, maxC) {
      const t = MTYPE[type];
      for (let c = minC; c <= maxC && c + t.w <= COLS; c++)
        for (let r = 0; r + t.h <= ROWS; r++)
          if (canPlace(aGrid, c, r, type)) return { x: c, y: r };
      for (let c = 0; c + t.w <= COLS; c++)
        for (let r = 0; r + t.h <= ROWS; r++)
          if (canPlace(aGrid, c, r, type)) return { x: c, y: r };
      return null;
    }

    function aiConnectBelt(src, dst) {
      const srcT = MTYPE[src.type];
      const sx = src.gx + srcT.w;
      const sy = src.gy;
      const dx = dst.gx;
      const dy = dst.gy;
      let cost = 0;
      let x = sx, y = sy;
      const maxSteps = 25;
      for (let s = 0; s < maxSteps; s++) {
        if (x === dx && y === dy) break;
        if (x >= 0 && x < COLS && y >= 0 && y < ROWS && aGrid[y][x] === 0) {
          aGrid[y][x] = 'b';
          aBelts.push({ gx: x, gy: y, dir: 0 });
          cost++;
          if (aiMoney - cost < 0) break;
        }
        if (x < dx) x++;
        else if (x > dx) x--;
        else if (y < dy) y++;
        else if (y > dy) y--;
        else break;
      }
      return cost;
    }

    // ---- Input ----
    let mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      mouseX = (e.clientX - r.left) * (W / r.width);
      mouseY = (e.clientY - r.top) * (H / r.height);
      if (mouseX < DIV_X) {
        const gx = Math.floor((mouseX - P_OX) / CELL);
        const gy = Math.floor((mouseY - P_OY) / CELL);
        hoverCell = (gx >= 0 && gx < COLS && gy >= 0 && gy < ROWS) ? { gx, gy } : null;
      } else {
        hoverCell = null;
      }
    });

    canvas.addEventListener('click', e => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      const r = canvas.getBoundingClientRect();
      const mx = (e.clientX - r.left) * (W / r.width);
      const my = (e.clientY - r.top) * (H / r.height);
      if (mx >= DIV_X) return;

      const gx = Math.floor((mx - P_OX) / CELL);
      const gy = Math.floor((my - P_OY) / CELL);
      if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return;

      if (selectedTool === 'delete') {
        const refund = removeTile(pGrid, pMachines, pBelts, gx, gy);
        playerMoney += refund;
        if (refund > 0) infoEl.textContent = 'Removed! Refunded $' + refund;
        return;
      }

      if (selectedTool === 'belt') {
        if (!beltStart) {
          beltStart = { gx, gy };
          infoEl.textContent = 'Click endpoint to draw belt path (cost: $1/tile)';
        } else {
          const count = placeBeltLine(pGrid, pBelts, beltStart.gx, beltStart.gy, gx, gy);
          if (count > 0 && playerMoney >= count) {
            playerMoney -= count;
            infoEl.textContent = count + ' belt tiles placed ($' + count + ')';
          } else if (playerMoney < count) {
            infoEl.textContent = 'Not enough money for belts!';
          }
          beltStart = null;
        }
        return;
      }

      if (selectedTool && MTYPE[selectedTool]) {
        const t = MTYPE[selectedTool];
        if (playerMoney < t.cost) {
          infoEl.textContent = 'Need $' + t.cost + ' (have $' + Math.floor(playerMoney) + ')';
          return;
        }
        if (canPlace(pGrid, gx, gy, selectedTool)) {
          placeMach(pGrid, pMachines, gx, gy, selectedTool);
          playerMoney -= t.cost;
          infoEl.textContent = t.name + ' placed! (' + t.input + ' \u2192 ' + t.output + ')';
        } else {
          infoEl.textContent = 'Cannot place here - blocked';
        }
        return;
      }

      // No tool - inspect
      const cell = pGrid[gy][gx];
      if (typeof cell === 'string' && cell[0] === 'm') {
        const mid = parseInt(cell.substring(1));
        const m = pMachines.find(mm => mm.id === mid);
        if (m) {
          const t = MTYPE[m.type];
          const src = getInputSource(pGrid, pMachines, m);
          const dst = getOutputDest(pGrid, pMachines, m);
          const srcStr = src ? (src.type === 'edge' ? 'ore supply' : src.type === 'machine' ? src.machine.type : '?') : 'NONE';
          const dstStr = dst ? (dst.type === 'exit' ? 'sell exit' : dst.type === 'machine' ? dst.machine.type : '?') : 'NONE';
          infoEl.textContent = `${t.name}: in=${m.inBuf.toFixed(1)} prog=${Math.floor(m.progress)}/${t.ticks} out=${m.outBuf} | feed:${srcStr} \u2192 dest:${dstStr}`;
        }
      } else if (cell === 'b') {
        infoEl.textContent = 'Belt tile - carries items between machines';
      } else {
        infoEl.textContent = 'Empty cell. Select a tool to build!';
      }
    });

    function selectTool(tool) {
      if (gameState !== 'playing' && gameState !== 'waiting') return;
      selectedTool = selectedTool === tool ? null : tool;
      beltStart = null;
      if (selectedTool === 'belt') infoEl.textContent = 'Click start, then end to draw belt ($1/tile). Belts carry items right.';
      else if (selectedTool === 'delete') infoEl.textContent = 'Click machine (50% refund) or belt to remove';
      else if (MTYPE[selectedTool]) infoEl.textContent = `${MTYPE[selectedTool].name}: ${MTYPE[selectedTool].input}\u2192${MTYPE[selectedTool].output} ($${MTYPE[selectedTool].cost}, ${MTYPE[selectedTool].w}x${MTYPE[selectedTool].h})`;
      else infoEl.textContent = 'Place machines on your factory floor. Connect with belts.';
      updateButtons();
    }

    function updateButtons() {
      document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
      if (selectedTool) {
        const id = 'btn' + selectedTool.charAt(0).toUpperCase() + selectedTool.slice(1);
        const el = document.getElementById(id);
        if (el) el.classList.add('active');
      }
    }

    // ---- Drawing ----
    function drawFactory(ox, oy, grid, machines, belts, label, money, highlight, isPlayer) {
      const fw = COLS * CELL, fh = ROWS * CELL;

      // Background
      ctx.fillStyle = '#10102a';
      ctx.fillRect(ox, oy, fw, fh);

      // Grid
      ctx.strokeStyle = '#1c1c3a';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath(); ctx.moveTo(ox, oy + r * CELL); ctx.lineTo(ox + fw, oy + r * CELL); ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath(); ctx.moveTo(ox + c * CELL, oy); ctx.lineTo(ox + c * CELL, oy + fh); ctx.stroke();
      }

      // Edge indicators
      ctx.fillStyle = 'rgba(85, 204, 85, 0.12)';
      ctx.fillRect(ox, oy, 4, fh);
      ctx.fillStyle = 'rgba(255, 170, 0, 0.12)';
      ctx.fillRect(ox + fw - 4, oy, 4, fh);

      // Ore arrows on left
      ctx.fillStyle = '#5a5';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      for (let r = 1; r < ROWS; r += 2) ctx.fillText('\u25B6', ox + 1, oy + r * CELL + 4);

      // Exit arrows on right
      ctx.fillStyle = '#fa0';
      for (let r = 1; r < ROWS; r += 2) ctx.fillText('$', ox + fw - 9, oy + r * CELL + 4);

      // Belts
      for (const b of belts) {
        const bx = ox + b.gx * CELL, by = oy + b.gy * CELL;
        ctx.fillStyle = '#2a2a50';
        ctx.fillRect(bx + 1, by + 1, CELL - 2, CELL - 2);
        // Animated chevrons
        const phase = (performance.now() / 300 + b.gx) % 2;
        ctx.fillStyle = '#484870';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(phase < 1 ? '\u00BB' : '\u203A', bx + CELL / 2, by + CELL / 2 + 4);
      }

      // Machines
      for (const m of machines) {
        const t = MTYPE[m.type];
        const mx = ox + m.gx * CELL, my = oy + m.gy * CELL;
        const mw = t.w * CELL, mh = t.h * CELL;

        // Body glow
        ctx.fillStyle = t.col + '18';
        ctx.fillRect(mx, my, mw, mh);

        // Body
        ctx.fillStyle = t.col + '40';
        ctx.fillRect(mx + 2, my + 2, mw - 4, mh - 4);

        // Border
        ctx.strokeStyle = t.col;
        ctx.lineWidth = 2;
        ctx.strokeRect(mx + 2, my + 2, mw - 4, mh - 4);

        // Pulsing glow when processing
        if (m.inBuf >= 1 && m.progress > 0) {
          const pulse = 0.15 + 0.1 * Math.sin(performance.now() / 200);
          ctx.fillStyle = t.col;
          ctx.globalAlpha = pulse;
          ctx.fillRect(mx + 2, my + 2, mw - 4, mh - 4);
          ctx.globalAlpha = 1;
        }

        // Symbol
        ctx.fillStyle = t.col;
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(t.sym, mx + mw / 2, my + mh / 2 - 2);

        // Type name
        ctx.font = '8px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText(t.name.substring(0, 5), mx + mw / 2, my + mh / 2 + 10);

        // Progress bar
        if (m.inBuf >= 1) {
          const prog = Math.min(1, m.progress / t.ticks);
          ctx.fillStyle = '#222';
          ctx.fillRect(mx + 4, my + mh - 8, mw - 8, 4);
          ctx.fillStyle = t.col;
          ctx.fillRect(mx + 4, my + mh - 8, (mw - 8) * prog, 4);
        }

        // Input/output counts
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        if (m.inBuf > 0.1) {
          ctx.fillStyle = '#8a8';
          ctx.fillText(Math.floor(m.inBuf), mx + 3, my + 10);
        }
        if (m.outBuf > 0) {
          ctx.fillStyle = '#fc8';
          ctx.textAlign = 'right';
          ctx.fillText(m.outBuf, mx + mw - 3, my + 10);
        }
        ctx.textAlign = 'left';
      }

      // Label
      ctx.fillStyle = isPlayer ? '#fa0' : '#f66';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(label, ox + 2, oy - 6);

      // Money
      ctx.fillStyle = '#5c5';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('$' + Math.floor(money), ox + fw - 2, oy - 6);
      ctx.textAlign = 'left';

      // Hover preview
      if (isPlayer && hoverCell && selectedTool && gameState === 'playing') {
        const hx = ox + hoverCell.gx * CELL, hy = oy + hoverCell.gy * CELL;
        if (MTYPE[selectedTool]) {
          const t = MTYPE[selectedTool];
          const ok = canPlace(pGrid, hoverCell.gx, hoverCell.gy, selectedTool);
          ctx.fillStyle = ok ? 'rgba(255,170,0,0.15)' : 'rgba(255,50,50,0.15)';
          ctx.fillRect(hx, hy, t.w * CELL, t.h * CELL);
          ctx.strokeStyle = ok ? '#fa0' : '#f33';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(hx, hy, t.w * CELL, t.h * CELL);
          ctx.setLineDash([]);
        } else if (selectedTool === 'belt') {
          ctx.fillStyle = 'rgba(255,170,0,0.12)';
          ctx.fillRect(hx, hy, CELL, CELL);
          if (beltStart) {
            ctx.strokeStyle = '#fa0';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            const sx = ox + beltStart.gx * CELL + CELL / 2;
            const sy = oy + beltStart.gy * CELL + CELL / 2;
            ctx.moveTo(sx, sy);
            ctx.lineTo(ox + hoverCell.gx * CELL + CELL / 2, sy);
            ctx.lineTo(ox + hoverCell.gx * CELL + CELL / 2, hy + CELL / 2);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        } else if (selectedTool === 'delete') {
          ctx.fillStyle = 'rgba(255,50,50,0.2)';
          ctx.fillRect(hx, hy, CELL, CELL);
        }
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Section labels
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fa0';
      ctx.font = 'bold 12px Courier New';
      ctx.fillText('YOUR FACTORY', P_OX + COLS * CELL / 2, 16);
      ctx.fillStyle = '#f66';
      ctx.fillText('AI FACTORY', A_OX + COLS * CELL / 2, 16);

      // Divider
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 4]);
      ctx.beginPath();
      ctx.moveTo(DIV_X, 20);
      ctx.lineTo(DIV_X, H - 40);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.textAlign = 'left';

      // Factories
      drawFactory(P_OX, P_OY, pGrid, pMachines, pBelts, 'PLAYER', playerMoney, true, true);
      drawFactory(A_OX, A_OY, aGrid, aMachines, aBelts, 'AI', aiMoney, false, false);

      // Bottom legend
      ctx.fillStyle = '#555';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Ore(left) \u2192 Smelter \u2192 Ingot($2) \u2192 Assembler \u2192 Part($5) \u2192 Constructor \u2192 Product($15) \u2192 Exit(right)', W / 2, H - 22);
      ctx.fillText('Keys: 1=Smelter 2=Assembler 3=Constructor 4=Belt 5=Delete  Esc=Cancel', W / 2, H - 10);
      ctx.textAlign = 'left';

      // Belt start marker
      if (beltStart && selectedTool === 'belt') {
        ctx.beginPath();
        ctx.arc(P_OX + beltStart.gx * CELL + CELL / 2, P_OY + beltStart.gy * CELL + CELL / 2, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fa0';
        ctx.fill();
      }
    }

    // ---- Game Loop ----
    function loop(ts) {
      if (gameState !== 'playing') return;
      const dt = Math.min(ts - lastTime, 100); // cap delta
      lastTime = ts;

      // Timer
      timeLeft -= dt / 1000;
      if (timeLeft <= 0) { timeLeft = 0; endGame(); return; }
      const m = Math.floor(timeLeft / 60);
      const s = Math.floor(timeLeft % 60);
      timerEl.textContent = m + ':' + (s < 10 ? '0' : '') + s;
      if (timeLeft < 30) timerEl.style.color = '#f55';
      else timerEl.style.color = '#ccc';

      // Passive income
      const inc = (1 / 3) * (dt / 1000);
      playerMoney += inc;
      aiMoney += inc;

      // Simulate
      pScore += simulate(dt, pGrid, pMachines, pBelts);
      aScore += simulate(dt, aGrid, aMachines, aBelts);
      score = pScore;

      scoreEl.textContent = Math.floor(pScore);
      aiScoreEl.textContent = Math.floor(aScore);

      // AI
      aiTimer += dt;
      if (aiTimer >= 2000) {
        aiTimer = 0;
        aiAct();
      }

      draw();
      requestAnimationFrame(loop);
    }

    function endGame() {
      gameState = 'over';
      score = Math.floor(pScore);
      overlay.style.display = 'flex';
      const ps = Math.floor(pScore), as = Math.floor(aScore);
      if (ps > as) {
        overlayTitle.textContent = 'YOU WIN!';
        overlayTitle.style.color = '#fa0';
      } else if (as > ps) {
        overlayTitle.textContent = 'AI WINS';
        overlayTitle.style.color = '#f55';
      } else {
        overlayTitle.textContent = 'TIE GAME';
        overlayTitle.style.color = '#fa0';
      }
      overlayText.innerHTML = `Your score: ${ps}<br>AI score: ${as}<br><br>Click or press any key to play again`;
      draw();
    }

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

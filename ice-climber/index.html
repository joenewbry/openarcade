<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ice Climber</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #8af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 170, 255, 0.5); }
    h1 { color: #8af; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8af; }
    canvas {
      border: 2px solid #8af;
      box-shadow: 0 0 20px rgba(136, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ICE CLIMBER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">ICE CLIMBER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const TILE = 32;                    // tile size
    const COLS = Math.floor(W / TILE);  // 12 columns (400/32 = 12.5, floor = 12)
    const GRAVITY = 0.38;
    const JUMP_VEL = -9.5;
    const MOVE_SPEED = 3;
    const PLAYER_W = 24;
    const PLAYER_H = 28;
    const BLOCK_W = TILE;
    const BLOCK_H = TILE;

    // Floor config
    const FLOOR_GAP = 4;               // floors spaced every 4 tile rows
    const BLOCKS_PER_FLOOR = COLS;      // full row of blocks
    const HOLE_MIN = 2;                 // minimum hole width in blocks
    const HOLE_MAX = 4;                 // maximum hole width in blocks

    // Enemy (Topi) config
    const TOPI_W = 22;
    const TOPI_H = 20;
    const TOPI_SPEED = 1.2;

    // Bonus fruit
    const FRUIT_SIZE = 14;

    // Mountain/level config
    const FLOORS_PER_LEVEL = 8;
    const SUMMIT_FLOOR = FLOORS_PER_LEVEL;

    // Camera
    const SCROLL_THRESHOLD = H * 0.35;

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    let player, keys, floors, enemies, fruits, particles;
    let cameraY, level, floorsClimbed, topFloorGenerated;
    let animFrame, frameCount;
    let bonusActive, bonusTimer;

    // --- Init ---
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ICE CLIMBER';
      overlayText.textContent = 'Press SPACE to start';

      player = {
        x: W / 2 - PLAYER_W / 2,
        y: 0,
        vx: 0,
        vy: 0,
        onGround: false,
        jumping: false,
        headHit: false,
        headHitTimer: 0,
        facingRight: true,
        hammerSwing: 0,
        lives: 3
      };

      keys = {};
      floors = [];
      enemies = [];
      fruits = [];
      particles = [];
      cameraY = 0;
      level = 1;
      floorsClimbed = 0;
      topFloorGenerated = 0;
      frameCount = 0;
      bonusActive = false;
      bonusTimer = 0;

      generateMountain();

      // Place player on the ground floor
      player.x = W / 2 - PLAYER_W / 2;
      player.y = getFloorY(0) - PLAYER_H;
      player.onGround = true;

      draw();
    }

    function getFloorY(floorIndex) {
      // Floor 0 is at the bottom, higher floors go up
      // Each floor is FLOOR_GAP tile rows apart
      return (SUMMIT_FLOOR - floorIndex) * FLOOR_GAP * TILE;
    }

    function generateMountain() {
      floors = [];
      enemies = [];
      fruits = [];

      for (let f = 0; f <= SUMMIT_FLOOR; f++) {
        const floorY = getFloorY(f);
        const blocks = [];

        if (f === 0) {
          // Ground floor: solid, no holes
          for (let c = 0; c < COLS; c++) {
            blocks.push({ x: c * TILE, y: floorY, alive: true, repairing: false, repairTimer: 0 });
          }
        } else if (f === SUMMIT_FLOOR) {
          // Summit: special solid floor
          for (let c = 0; c < COLS; c++) {
            blocks.push({ x: c * TILE, y: floorY, alive: true, summit: true, repairing: false, repairTimer: 0 });
          }
        } else {
          // Normal floors: row of breakable ice blocks with a gap to jump through
          // Create a hole (gap) so there's an opening from below
          const holeWidth = HOLE_MIN + Math.floor(Math.random() * (HOLE_MAX - HOLE_MIN + 1));
          const holeStart = 1 + Math.floor(Math.random() * (COLS - holeWidth - 2));

          for (let c = 0; c < COLS; c++) {
            const isHole = c >= holeStart && c < holeStart + holeWidth;
            blocks.push({
              x: c * TILE,
              y: floorY,
              alive: !isHole,
              repairing: false,
              repairTimer: 0
            });
          }

          // Spawn fruit on some floors
          if (Math.random() < 0.5) {
            const fruitX = (holeStart + Math.floor(holeWidth / 2)) * TILE + TILE / 2 - FRUIT_SIZE / 2;
            fruits.push({
              x: fruitX,
              y: floorY - TILE - FRUIT_SIZE,
              collected: false,
              floor: f,
              type: Math.floor(Math.random() * 4) // 0=eggplant, 1=carrot, 2=cabbage, 3=mushroom
            });
          }
        }

        // Spawn Topi enemy on some mid-level floors
        if (f >= 2 && f < SUMMIT_FLOOR && Math.random() < 0.35 + level * 0.05) {
          const dir = Math.random() < 0.5 ? 1 : -1;
          enemies.push({
            x: dir > 0 ? 0 : W - TOPI_W,
            y: floorY - TOPI_H,
            vx: TOPI_SPEED * dir * (1 + level * 0.1),
            floor: f,
            alive: true,
            repairing: false,
            repairTarget: -1,
            repairCooldown: 0,
            frameOffset: Math.random() * 100
          });
        }

        floors.push({ y: floorY, blocks: blocks, index: f });
      }

      topFloorGenerated = SUMMIT_FLOOR;

      // Set initial camera so player is visible at bottom
      cameraY = getFloorY(0) - H + TILE * 2;
    }

    // --- Start ---
    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      cancelAnimationFrame(animFrame);
      loop();
    }

    // --- Game Loop ---
    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    // --- Update ---
    function update() {
      frameCount++;

      // Player horizontal movement
      if (keys['ArrowLeft'] || keys['a']) {
        player.vx = -MOVE_SPEED;
        player.facingRight = false;
      } else if (keys['ArrowRight'] || keys['d']) {
        player.vx = MOVE_SPEED;
        player.facingRight = true;
      } else {
        player.vx = 0;
      }

      player.x += player.vx;

      // Wall collision - wrap around
      if (player.x + PLAYER_W < 0) player.x = W;
      if (player.x > W) player.x = -PLAYER_W;

      // Jump
      if ((keys[' '] || keys['ArrowUp'] || keys['w']) && player.onGround && !player.jumping) {
        player.vy = JUMP_VEL;
        player.onGround = false;
        player.jumping = true;
      }

      // Reset jump flag when key released
      if (!keys[' '] && !keys['ArrowUp'] && !keys['w']) {
        player.jumping = false;
      }

      // Gravity
      player.vy += GRAVITY;
      player.y += player.vy;

      // Hammer swing animation
      if (player.hammerSwing > 0) {
        player.hammerSwing--;
      }

      // Head hit animation
      if (player.headHitTimer > 0) {
        player.headHitTimer--;
      }

      // --- Collision with floors ---
      player.onGround = false;

      for (let fi = 0; fi < floors.length; fi++) {
        const floor = floors[fi];

        for (let bi = 0; bi < floor.blocks.length; bi++) {
          const block = floor.blocks[bi];
          if (!block.alive) continue;

          const bx = block.x;
          const by = block.y;

          // Player landing on top of block (falling down)
          if (player.vy >= 0) {
            const playerBottom = player.y + PLAYER_H;
            const prevBottom = playerBottom - player.vy;

            if (playerBottom >= by && prevBottom <= by + 4 &&
                player.x + PLAYER_W > bx + 2 && player.x < bx + BLOCK_W - 2) {
              player.y = by - PLAYER_H;
              player.vy = 0;
              player.onGround = true;
            }
          }

          // Player hitting block from below (jumping up)
          if (player.vy < 0) {
            const playerTop = player.y;
            const prevTop = playerTop - player.vy;

            if (playerTop <= by + BLOCK_H && prevTop >= by + BLOCK_H - 4 &&
                player.x + PLAYER_W > bx + 2 && player.x < bx + BLOCK_W - 2) {

              if (!block.summit) {
                // Break the ice block!
                block.alive = false;
                player.headHit = true;
                player.headHitTimer = 8;
                player.hammerSwing = 10;

                // Score for breaking
                score += 10;
                scoreEl.textContent = score;
                if (score > best) { best = score; bestEl.textContent = best; }

                // Spawn ice particles
                for (let p = 0; p < 6; p++) {
                  particles.push({
                    x: bx + BLOCK_W / 2 + (Math.random() - 0.5) * BLOCK_W,
                    y: by + BLOCK_H / 2,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 4 - 1,
                    life: 30 + Math.random() * 20,
                    size: 3 + Math.random() * 4
                  });
                }

                // Check if any enemy was standing on this block
                for (let ei = 0; ei < enemies.length; ei++) {
                  const enemy = enemies[ei];
                  if (!enemy.alive) continue;
                  const enemyBottom = enemy.y + TOPI_H;
                  if (Math.abs(enemyBottom - by) < 4 &&
                      enemy.x + TOPI_W > bx && enemy.x < bx + BLOCK_W) {
                    // Enemy gets bumped off
                    enemy.alive = false;
                    score += 50;
                    scoreEl.textContent = score;
                    if (score > best) { best = score; bestEl.textContent = best; }

                    // Enemy death particles
                    for (let p = 0; p < 8; p++) {
                      particles.push({
                        x: enemy.x + TOPI_W / 2,
                        y: enemy.y + TOPI_H / 2,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -Math.random() * 5 - 2,
                        life: 25 + Math.random() * 15,
                        size: 3 + Math.random() * 3,
                        color: '#f66'
                      });
                    }
                  }
                }
              } else {
                // Bonk on summit - just stop upward movement
                player.vy = 0;
                player.y = by + BLOCK_H;
              }
            }
          }
        }
      }

      // Fruit collection
      for (let i = 0; i < fruits.length; i++) {
        const fruit = fruits[i];
        if (fruit.collected) continue;

        if (player.x + PLAYER_W > fruit.x &&
            player.x < fruit.x + FRUIT_SIZE &&
            player.y + PLAYER_H > fruit.y &&
            player.y < fruit.y + FRUIT_SIZE) {
          fruit.collected = true;
          score += 100;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }

          // Sparkle particles
          for (let p = 0; p < 10; p++) {
            particles.push({
              x: fruit.x + FRUIT_SIZE / 2,
              y: fruit.y + FRUIT_SIZE / 2,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              life: 20 + Math.random() * 15,
              size: 2 + Math.random() * 3,
              color: '#ff0'
            });
          }
        }
      }

      // --- Enemy (Topi) AI ---
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        if (!enemy.alive) continue;

        const floor = floors.find(f => f.index === enemy.floor);
        if (!floor) continue;

        // Find broken blocks on this floor to repair
        let targetBlock = null;
        if (enemy.repairCooldown > 0) {
          enemy.repairCooldown--;
        } else {
          for (let bi = 0; bi < floor.blocks.length; bi++) {
            if (!floor.blocks[bi].alive && !floor.blocks[bi].summit) {
              targetBlock = floor.blocks[bi];
              break;
            }
          }
        }

        if (targetBlock && !enemy.repairing) {
          // Move toward broken block
          const targetX = targetBlock.x + BLOCK_W / 2 - TOPI_W / 2;
          if (Math.abs(enemy.x - targetX) < 3) {
            // Start repairing
            enemy.repairing = true;
            enemy.repairTarget = targetBlock;
            targetBlock.repairing = true;
            targetBlock.repairTimer = 60; // frames to repair
          } else {
            enemy.x += (targetX > enemy.x ? 1 : -1) * Math.abs(enemy.vx);
          }
        } else if (enemy.repairing && enemy.repairTarget) {
          // Repairing a block
          enemy.repairTarget.repairTimer--;
          if (enemy.repairTarget.repairTimer <= 0) {
            enemy.repairTarget.alive = true;
            enemy.repairTarget.repairing = false;
            enemy.repairing = false;
            enemy.repairTarget = null;
            enemy.repairCooldown = 120;
          }
        } else {
          // Patrol back and forth
          enemy.x += enemy.vx;

          // Bounce off walls
          if (enemy.x <= 0) { enemy.x = 0; enemy.vx = Math.abs(enemy.vx); }
          if (enemy.x + TOPI_W >= W) { enemy.x = W - TOPI_W; enemy.vx = -Math.abs(enemy.vx); }
        }

        // Check if enemy touches player
        if (player.x + PLAYER_W > enemy.x + 3 &&
            player.x < enemy.x + TOPI_W - 3 &&
            player.y + PLAYER_H > enemy.y + 3 &&
            player.y < enemy.y + TOPI_H - 3) {

          // If player is above and falling, stomp the enemy
          if (player.vy > 0 && player.y + PLAYER_H < enemy.y + TOPI_H / 2) {
            enemy.alive = false;
            player.vy = JUMP_VEL * 0.7;
            score += 100;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }

            for (let p = 0; p < 8; p++) {
              particles.push({
                x: enemy.x + TOPI_W / 2,
                y: enemy.y + TOPI_H / 2,
                vx: (Math.random() - 0.5) * 6,
                vy: -Math.random() * 5 - 2,
                life: 25 + Math.random() * 15,
                size: 3 + Math.random() * 3,
                color: '#f66'
              });
            }
          } else {
            // Player gets hit
            die();
            return;
          }
        }
      }

      // --- Camera scrolling ---
      const playerScreenY = player.y - cameraY;
      if (playerScreenY < SCROLL_THRESHOLD) {
        cameraY = player.y - SCROLL_THRESHOLD;
      }

      // --- Check if player reached the summit ---
      const summitY = getFloorY(SUMMIT_FLOOR);
      if (player.y < summitY - PLAYER_H + 5 && player.onGround) {
        // Level complete!
        levelComplete();
        return;
      }

      // --- Fall death ---
      if (player.y - cameraY > H + PLAYER_H * 2) {
        die();
        return;
      }

      // --- Update particles ---
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerVY: player.vy,
        onGround: player.onGround,
        cameraY: cameraY,
        level: level,
        enemyCount: enemies.filter(e => e.alive).length
      };
    }

    function levelComplete() {
      // Award bonus points for remaining speed
      const levelBonus = 500 * level;
      score += levelBonus;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }

      // Celebration particles
      for (let p = 0; p < 30; p++) {
        particles.push({
          x: player.x + PLAYER_W / 2,
          y: player.y,
          vx: (Math.random() - 0.5) * 8,
          vy: -Math.random() * 8 - 2,
          life: 50 + Math.random() * 30,
          size: 3 + Math.random() * 5,
          color: ['#8af', '#ff0', '#f44', '#0f0', '#f0f'][Math.floor(Math.random() * 5)]
        });
      }

      level++;
      generateMountain();

      player.x = W / 2 - PLAYER_W / 2;
      player.y = getFloorY(0) - PLAYER_H;
      player.vy = 0;
      player.vx = 0;
      player.onGround = true;
    }

    function die() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Level: ${level} \u2014 Press any key to restart`;
    }

    // --- Draw ---
    function draw() {
      // Sky gradient background (gets colder higher up)
      const heightRatio = Math.min(Math.max(-cameraY / (SUMMIT_FLOOR * FLOOR_GAP * TILE), 0), 1);
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      const r1 = Math.round(26 - heightRatio * 10);
      const g1 = Math.round(26 - heightRatio * 10);
      const b1 = Math.round(46 + heightRatio * 20);
      const r2 = Math.round(15 - heightRatio * 5);
      const g2 = Math.round(15 + heightRatio * 5);
      const b2 = Math.round(35 + heightRatio * 30);
      grad.addColorStop(0, `rgb(${r2},${g2},${b2})`);
      grad.addColorStop(1, `rgb(${r1},${g1},${b1})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Snowflakes in background
      ctx.fillStyle = 'rgba(200, 220, 255, 0.15)';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 97 + frameCount * 0.3 * ((i % 3) + 1)) % (W + 20)) - 10;
        const sy = ((i * 131 + frameCount * 0.5 * ((i % 2) + 1) - cameraY * 0.1) % (H + 20)) - 10;
        const ss = 1 + (i % 3);
        ctx.fillRect(sx, sy, ss, ss);
      }

      // Mountain outline in background
      ctx.strokeStyle = 'rgba(136, 170, 255, 0.08)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, H);
      ctx.lineTo(W * 0.15, H * 0.5 - cameraY * 0.02);
      ctx.lineTo(W * 0.35, H * 0.7 - cameraY * 0.015);
      ctx.lineTo(W * 0.5, H * 0.3 - cameraY * 0.025);
      ctx.lineTo(W * 0.7, H * 0.6 - cameraY * 0.02);
      ctx.lineTo(W * 0.85, H * 0.35 - cameraY * 0.025);
      ctx.lineTo(W, H);
      ctx.stroke();

      // --- Draw floors / ice blocks ---
      for (let fi = 0; fi < floors.length; fi++) {
        const floor = floors[fi];

        for (let bi = 0; bi < floor.blocks.length; bi++) {
          const block = floor.blocks[bi];
          const drawX = block.x;
          const drawY = block.y - cameraY;

          // Skip off-screen
          if (drawY < -TILE * 2 || drawY > H + TILE) continue;

          if (block.alive) {
            if (block.summit) {
              // Summit blocks - golden/warm
              ctx.fillStyle = '#da4';
              ctx.shadowColor = '#fd6';
              ctx.shadowBlur = 10;
              ctx.fillRect(drawX, drawY, BLOCK_W, BLOCK_H);
              ctx.shadowBlur = 0;

              // Shiny highlight
              ctx.fillStyle = '#fe8';
              ctx.fillRect(drawX + 2, drawY + 2, BLOCK_W - 4, 4);

              // Flag on middle summit block
              if (bi === Math.floor(COLS / 2)) {
                ctx.fillStyle = '#f44';
                ctx.fillRect(drawX + BLOCK_W / 2 - 1, drawY - 24, 2, 24);
                // Flag triangle
                ctx.beginPath();
                ctx.moveTo(drawX + BLOCK_W / 2 + 1, drawY - 24);
                ctx.lineTo(drawX + BLOCK_W / 2 + 14, drawY - 18);
                ctx.lineTo(drawX + BLOCK_W / 2 + 1, drawY - 12);
                ctx.closePath();
                ctx.fillStyle = '#f44';
                ctx.shadowColor = '#f44';
                ctx.shadowBlur = 6;
                ctx.fill();
                ctx.shadowBlur = 0;
              }
            } else if (floor.index === 0) {
              // Ground floor - solid rock/ice
              ctx.fillStyle = '#445';
              ctx.fillRect(drawX, drawY, BLOCK_W, BLOCK_H);
              ctx.fillStyle = '#556';
              ctx.fillRect(drawX + 1, drawY + 1, BLOCK_W - 2, 3);
              // Ground texture lines
              ctx.strokeStyle = '#334';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(drawX + BLOCK_W * 0.3, drawY);
              ctx.lineTo(drawX + BLOCK_W * 0.3, drawY + BLOCK_H);
              ctx.stroke();
            } else {
              // Normal ice blocks
              ctx.fillStyle = '#68c';
              ctx.shadowColor = '#8af';
              ctx.shadowBlur = 4;
              ctx.fillRect(drawX, drawY, BLOCK_W, BLOCK_H);
              ctx.shadowBlur = 0;

              // Ice highlight/sheen
              ctx.fillStyle = 'rgba(170, 210, 255, 0.4)';
              ctx.fillRect(drawX + 2, drawY + 2, BLOCK_W - 4, 5);

              // Ice crack detail
              ctx.strokeStyle = 'rgba(100, 140, 200, 0.5)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(drawX + BLOCK_W * 0.2, drawY + BLOCK_H * 0.4);
              ctx.lineTo(drawX + BLOCK_W * 0.5, drawY + BLOCK_H * 0.6);
              ctx.lineTo(drawX + BLOCK_W * 0.8, drawY + BLOCK_H * 0.3);
              ctx.stroke();
            }
          } else if (block.repairing) {
            // Block being repaired - show ghost outline
            ctx.strokeStyle = 'rgba(136, 170, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(drawX + 2, drawY + 2, BLOCK_W - 4, BLOCK_H - 4);
            ctx.setLineDash([]);

            // Fill progress
            const progress = 1 - (block.repairTimer / 60);
            ctx.fillStyle = 'rgba(100, 140, 200, 0.3)';
            ctx.fillRect(drawX, drawY + BLOCK_H * (1 - progress), BLOCK_W, BLOCK_H * progress);
          }
        }
      }

      // --- Draw fruits ---
      for (let i = 0; i < fruits.length; i++) {
        const fruit = fruits[i];
        if (fruit.collected) continue;

        const fx = fruit.x;
        const fy = fruit.y - cameraY;
        if (fy < -20 || fy > H + 20) continue;

        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 8;

        const bobY = fy + Math.sin(frameCount * 0.06 + fruit.floor) * 3;

        switch (fruit.type) {
          case 0: // eggplant (purple)
            ctx.fillStyle = '#a4f';
            ctx.beginPath();
            ctx.ellipse(fx + FRUIT_SIZE / 2, bobY + FRUIT_SIZE / 2, FRUIT_SIZE / 2 - 1, FRUIT_SIZE / 2 + 1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4a2';
            ctx.fillRect(fx + FRUIT_SIZE / 2 - 2, bobY - 2, 4, 4);
            break;
          case 1: // carrot (orange)
            ctx.fillStyle = '#f80';
            ctx.beginPath();
            ctx.moveTo(fx + FRUIT_SIZE / 2, bobY + FRUIT_SIZE);
            ctx.lineTo(fx, bobY + 2);
            ctx.lineTo(fx + FRUIT_SIZE, bobY + 2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#4a2';
            ctx.fillRect(fx + FRUIT_SIZE / 2 - 3, bobY - 2, 6, 4);
            break;
          case 2: // cabbage (green)
            ctx.fillStyle = '#4c4';
            ctx.beginPath();
            ctx.arc(fx + FRUIT_SIZE / 2, bobY + FRUIT_SIZE / 2, FRUIT_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#6e6';
            ctx.beginPath();
            ctx.arc(fx + FRUIT_SIZE / 2, bobY + FRUIT_SIZE / 2, FRUIT_SIZE / 3, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 3: // mushroom (red)
            ctx.fillStyle = '#f44';
            ctx.beginPath();
            ctx.arc(fx + FRUIT_SIZE / 2, bobY + 4, FRUIT_SIZE / 2, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#edc';
            ctx.fillRect(fx + FRUIT_SIZE / 2 - 3, bobY + 4, 6, FRUIT_SIZE - 5);
            // White dots on cap
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(fx + FRUIT_SIZE / 2 - 2, bobY + 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(fx + FRUIT_SIZE / 2 + 3, bobY + 1, 1.5, 0, Math.PI * 2);
            ctx.fill();
            break;
        }
        ctx.shadowBlur = 0;
      }

      // --- Draw enemies (Topi) ---
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        if (!enemy.alive) continue;

        const ex = enemy.x;
        const ey = enemy.y - cameraY;
        if (ey < -30 || ey > H + 30) continue;

        const facing = enemy.vx >= 0 ? 1 : -1;

        // Body (seal/walrus shape)
        ctx.fillStyle = '#c4a';
        ctx.shadowColor = '#c4a';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.ellipse(ex + TOPI_W / 2, ey + TOPI_H / 2 + 2, TOPI_W / 2, TOPI_H / 2 - 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Lighter belly
        ctx.fillStyle = '#d6c';
        ctx.beginPath();
        ctx.ellipse(ex + TOPI_W / 2, ey + TOPI_H / 2 + 4, TOPI_W / 3, TOPI_H / 3 - 2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ex + TOPI_W / 2 + facing * 4, ey + TOPI_H / 3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(ex + TOPI_W / 2 + facing * 5, ey + TOPI_H / 3, 1.5, 0, Math.PI * 2);
        ctx.fill();

        // Little legs walking animation
        const walkPhase = Math.sin((frameCount + enemy.frameOffset) * 0.15);
        ctx.fillStyle = '#a38';
        ctx.fillRect(ex + TOPI_W / 2 - 6 + walkPhase * 2, ey + TOPI_H - 4, 4, 4);
        ctx.fillRect(ex + TOPI_W / 2 + 2 - walkPhase * 2, ey + TOPI_H - 4, 4, 4);

        // Repair indicator
        if (enemy.repairing) {
          ctx.fillStyle = '#ff0';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('\u2692', ex + TOPI_W / 2, ey - 4);
        }
      }

      // --- Draw player ---
      const px = player.x;
      const py = player.y - cameraY;

      ctx.save();
      ctx.translate(px + PLAYER_W / 2, py + PLAYER_H / 2);

      if (!player.facingRight) {
        ctx.scale(-1, 1);
      }

      // Parka body
      ctx.fillStyle = '#48f';
      ctx.shadowColor = '#8af';
      ctx.shadowBlur = 12;
      drawRoundedRect(-PLAYER_W / 2, -PLAYER_H / 2 + 6, PLAYER_W, PLAYER_H - 8, 4);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Parka highlight
      ctx.fillStyle = '#6af';
      ctx.fillRect(-PLAYER_W / 2 + 2, -PLAYER_H / 2 + 7, PLAYER_W - 4, 5);

      // Head
      ctx.fillStyle = '#fdb';
      ctx.beginPath();
      ctx.arc(0, -PLAYER_H / 2 + 4, 8, 0, Math.PI * 2);
      ctx.fill();

      // Hood/hat
      ctx.fillStyle = '#48f';
      ctx.beginPath();
      ctx.arc(0, -PLAYER_H / 2 + 1, 9, Math.PI, 0);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(2, -PLAYER_H / 2 + 4, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Hammer
      const hammerAngle = player.hammerSwing > 0 ? -0.5 - player.hammerSwing * 0.1 : -0.3;
      ctx.save();
      ctx.translate(PLAYER_W / 2 - 4, -2);
      ctx.rotate(hammerAngle);

      // Handle
      ctx.fillStyle = '#a73';
      ctx.fillRect(0, -2, 14, 3);

      // Head of hammer
      ctx.fillStyle = '#ccc';
      ctx.shadowColor = '#8af';
      ctx.shadowBlur = 4;
      ctx.fillRect(11, -5, 7, 9);
      ctx.shadowBlur = 0;

      ctx.restore();

      // Feet
      ctx.fillStyle = '#335';
      const walkAnim = player.onGround ? Math.sin(frameCount * 0.15) * (Math.abs(player.vx) > 0 ? 3 : 0) : 0;
      ctx.fillRect(-PLAYER_W / 2 + 2, PLAYER_H / 2 - 4 + walkAnim, 8, 4);
      ctx.fillRect(PLAYER_W / 2 - 10, PLAYER_H / 2 - 4 - walkAnim, 8, 4);

      ctx.restore();

      // --- Draw particles ---
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const alpha = Math.min(1, p.life / 15);
        const color = p.color || '#8af';
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x, p.y - cameraY, p.size, p.size);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // --- HUD ---
      // Level indicator
      if (gameState === 'playing') {
        ctx.fillStyle = '#8af';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`Mt. ${level}`, 8, 20);

        // Height meter on right side
        const totalHeight = SUMMIT_FLOOR * FLOOR_GAP * TILE;
        const currentHeight = Math.max(0, getFloorY(0) - player.y);
        const progress = Math.min(currentHeight / totalHeight, 1);

        // Track bar
        ctx.fillStyle = 'rgba(136, 170, 255, 0.15)';
        ctx.fillRect(W - 8, 30, 5, H - 60);

        // Progress fill
        ctx.fillStyle = '#8af';
        ctx.shadowColor = '#8af';
        ctx.shadowBlur = 6;
        const barH = H - 60;
        const fillH = progress * barH;
        ctx.fillRect(W - 8, 30 + barH - fillH, 5, fillH);
        ctx.shadowBlur = 0;

        // Summit marker
        ctx.fillStyle = '#fd6';
        ctx.fillRect(W - 10, 28, 9, 3);

        // Player marker
        const markerY = 30 + barH - fillH;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(W - 14, markerY);
        ctx.lineTo(W - 10, markerY - 3);
        ctx.lineTo(W - 10, markerY + 3);
        ctx.closePath();
        ctx.fill();
      }
    }

    // --- Utility ---
    function drawRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

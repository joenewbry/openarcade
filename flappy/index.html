<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flappy Bird</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #ff0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
    h1 { color: #ff0; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 255, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ff0; }
    canvas {
      border: 2px solid #ff0;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ff0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>FLAPPY BIRD</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">FLAPPY BIRD</h2>
      <p id="overlayText">Press Space or Up to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const GRAVITY = 0.45;
    const FLAP_FORCE = -7.5;
    const PIPE_WIDTH = 60;
    const PIPE_SPEED = 3;
    const BIRD_SIZE = 18;

    // Zone thresholds
    const ZONE_GAP = [180, 160, 140, 120];      // grace, early, mid, late
    const ZONE_SPACING = [240, 200, 200, 200];  // pipe spacing per zone
    const GRACE_PIPES = 5;  // first N pipes use zone 0 settings

    // Pipe color palettes per zone
    const PIPE_ZONES = [
      { body: '#2a7a2a', cap: '#4aba4a', highlight: '#6ddc6d' }, // day green
      { body: '#2a7a2a', cap: '#4aba4a', highlight: '#6ddc6d' }, // day green (score 5-9)
      { body: '#8a6a20', cap: '#c49a40', highlight: '#dcb860' }, // golden hour
      { body: '#3a2a7a', cap: '#5a4aba', highlight: '#7a6adc' }, // dusk purple
    ];

    // Sky color palettes per zone [top, bottom]
    const SKY_ZONES = [
      ['#87ceeb', '#b0e2ff'],  // bright day
      ['#87ceeb', '#b0e2ff'],  // day (score 5-9)
      ['#f4a460', '#ff7050'],  // golden hour
      ['#4b0082', '#6a2090'],  // dusk
    ];

    let bird, pipes, score, best = 0, gameState, animFrame, frameCount, pipesSpawned;

    function getZone(sc, pCount) {
      if (pCount < GRACE_PIPES) return 0;
      if (sc < 10) return 1;
      if (sc < 25) return 2;
      return 3;
    }

    function init() {
      bird = { x: 80, y: H / 2, vy: 0, rotation: 0 };
      pipes = [];
      score = 0;
      frameCount = 0;
      pipesSpawned = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'FLAPPY BIRD';
      overlayText.textContent = 'Press Space or Up to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      flap();
      cancelAnimationFrame(animFrame);
      loop();
    }

    function flap() {
      bird.vy = FLAP_FORCE;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Bird physics
      bird.vy += GRAVITY;
      bird.y += bird.vy;
      bird.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, bird.vy * 0.08));

      if (bird.y - BIRD_SIZE < 0) {
        bird.y = BIRD_SIZE;
        bird.vy = 0;
      }
      if (bird.y + BIRD_SIZE > H) {
        gameOver();
        return;
      }

      // Determine current zone settings
      const zone = getZone(score, pipesSpawned);
      const gap = ZONE_GAP[zone];
      const spacing = ZONE_SPACING[zone];

      // Spawn pipes
      if (pipes.length === 0 || pipes[pipes.length - 1].x < W - spacing) {
        const minTop = 80;
        const maxTop = H - gap - 80;
        const topH = minTop + Math.random() * (maxTop - minTop);
        pipes.push({ x: W, topH, gap, scored: false, zone });
        pipesSpawned++;
      }

      // Move pipes
      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= PIPE_SPEED;

        if (pipes[i].x + PIPE_WIDTH < 0) {
          pipes.splice(i, 1);
          continue;
        }

        if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < bird.x - BIRD_SIZE) {
          pipes[i].scored = true;
          score++;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
        }

        const p = pipes[i];
        const bx = bird.x, by = bird.y, br = BIRD_SIZE;
        if (bx + br > p.x && bx - br < p.x + PIPE_WIDTH) {
          if (by - br < p.topH || by + br > p.topH + p.gap) {
            gameOver();
            return;
          }
        }
      }
    }

    function gameOver() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function lerpColor(c1, c2, t) {
      // Parse hex colors and interpolate
      const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
      const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
      const r = Math.round(r1 + (r2-r1)*t);
      const g = Math.round(g1 + (g2-g1)*t);
      const b = Math.round(b1 + (b2-b1)*t);
      return `rgb(${r},${g},${b})`;
    }

    function getSkyColors() {
      // Smooth transition between zones based on score
      let z = 0, t = 0;
      if (score >= 25) { z = 2; t = Math.min(1, (score - 25) / 10); }
      else if (score >= 10) { z = 1; t = (score - 10) / 15; }
      else { z = 0; t = score / 10; }
      const s1 = SKY_ZONES[z], s2 = SKY_ZONES[Math.min(z + 1, SKY_ZONES.length - 1)];
      return [lerpColor(s1[0], s2[0], t), lerpColor(s1[1], s2[1], t)];
    }

    function drawPipe(p) {
      const pz = PIPE_ZONES[Math.min(p.zone, PIPE_ZONES.length - 1)];

      // Pipe body gradient
      const bodyGrad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_WIDTH, 0);
      bodyGrad.addColorStop(0, pz.body);
      bodyGrad.addColorStop(0.4, pz.cap);
      bodyGrad.addColorStop(1, pz.body);

      // Top pipe
      ctx.fillStyle = bodyGrad;
      ctx.fillRect(p.x, 0, PIPE_WIDTH, p.topH);
      // Top pipe cap
      ctx.fillStyle = pz.cap;
      ctx.fillRect(p.x - 5, p.topH - 22, PIPE_WIDTH + 10, 22);
      // Cap highlight
      ctx.fillStyle = pz.highlight;
      ctx.fillRect(p.x - 5, p.topH - 22, PIPE_WIDTH + 10, 4);
      // Cap outline
      ctx.strokeStyle = pz.body;
      ctx.lineWidth = 2;
      ctx.strokeRect(p.x - 5, p.topH - 22, PIPE_WIDTH + 10, 22);

      // Bottom pipe
      const botY = p.topH + p.gap;
      ctx.fillStyle = bodyGrad;
      ctx.fillRect(p.x, botY, PIPE_WIDTH, H - botY);
      // Bottom pipe cap
      ctx.fillStyle = pz.cap;
      ctx.fillRect(p.x - 5, botY, PIPE_WIDTH + 10, 22);
      // Cap highlight
      ctx.fillStyle = pz.highlight;
      ctx.fillRect(p.x - 5, botY, PIPE_WIDTH + 10, 4);
      ctx.strokeStyle = pz.body;
      ctx.strokeRect(p.x - 5, botY, PIPE_WIDTH + 10, 22);
    }

    function draw() {
      // Sky gradient (zone-based warm colors)
      const [skyTop, skyBot] = getSkyColors();
      const grad = ctx.createLinearGradient(0, 0, 0, H - 30);
      grad.addColorStop(0, skyTop);
      grad.addColorStop(1, skyBot);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Clouds (simple fluffy shapes that move slowly)
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      const cloudOffsets = [
        { x: ((frameCount * 0.2) % (W + 100)) - 50, y: 80 },
        { x: ((frameCount * 0.15 + 200) % (W + 100)) - 50, y: 150 },
        { x: ((frameCount * 0.1 + 350) % (W + 100)) - 50, y: 60 },
      ];
      cloudOffsets.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, 22, 0, Math.PI * 2);
        ctx.arc(c.x + 22, c.y - 6, 16, 0, Math.PI * 2);
        ctx.arc(c.x + 38, c.y, 18, 0, Math.PI * 2);
        ctx.fill();
      });

      // Pipes
      pipes.forEach(p => drawPipe(p));

      // Ground strip with texture
      ctx.fillStyle = '#3a6a20';
      ctx.fillRect(0, H - 30, W, 30);
      ctx.fillStyle = '#2a5a18';
      ctx.fillRect(0, H - 30, W, 6);
      // Grass blades
      ctx.fillStyle = '#4a8030';
      for (let gx = 3; gx < W; gx += 8) {
        const h = 4 + Math.sin(gx * 0.5) * 3;
        ctx.fillRect(gx, H - 30 - h, 2, h);
      }

      // Bird
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation);

      // Body (chunky rounded oval)
      ctx.fillStyle = '#ffdd22';
      ctx.shadowColor = '#ffaa00';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.ellipse(0, 0, BIRD_SIZE, BIRD_SIZE * 0.78, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Body shine highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.ellipse(-3, -4, BIRD_SIZE * 0.5, BIRD_SIZE * 0.35, -0.3, 0, Math.PI * 2);
      ctx.fill();

      // Wing (animated flap)
      const wingBeat = Math.sin(frameCount * 0.35) * 5;
      ctx.fillStyle = '#ff9900';
      ctx.beginPath();
      ctx.ellipse(-3, wingBeat, 11, 5, -0.3, 0, Math.PI * 2);
      ctx.fill();

      // Eye
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(8, -4, 5.5, 0, Math.PI * 2);
      ctx.fill();
      // Pupil shifts with velocity
      const pupilShift = bird.vy > 0 ? 1.5 : -1;
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(9, -4 + pupilShift, 2.5, 0, Math.PI * 2);
      ctx.fill();
      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(10, -5.5 + pupilShift, 1, 0, Math.PI * 2);
      ctx.fill();

      // Beak (chunky wedge)
      ctx.fillStyle = '#ff7700';
      ctx.beginPath();
      ctx.moveTo(BIRD_SIZE - 3, -4);
      ctx.lineTo(BIRD_SIZE + 9, -1);
      ctx.lineTo(BIRD_SIZE - 3, 4);
      ctx.closePath();
      ctx.fill();
      // Beak split line
      ctx.strokeStyle = '#cc5500';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(BIRD_SIZE - 3, 0);
      ctx.lineTo(BIRD_SIZE + 7, 0);
      ctx.stroke();

      ctx.restore();
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing' && (e.key === ' ' || e.key === 'ArrowUp')) {
        flap();
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Idle Clicker PvP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
      width: 600px;
    }
    .back { color: #ff6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 255, 102, 0.5); }
    h1 { color: #ff6; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 255, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 1rem;
    }
    .score-bar span { color: #ff6; }
    canvas {
      border: 2px solid #ff6;
      box-shadow: 0 0 20px rgba(255, 255, 102, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ff6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,255,102,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>IDLE CLICKER PVP</h1>
  </div>
  <div class="score-bar">
    <div>Coins: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">IDLE CLICKER PVP</h2>
      <p id="overlayText">Click to Start<br><br>Earn coins, buy upgrades, sabotage opponents!<br>3 minutes - highest coins wins</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    document.addEventListener('keydown', e => {
      if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
    });

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('idleClickerPvpBest') || '0');
    bestEl.textContent = bestScore;

    const THEME = '#ff6';
    const THEME_RGB = '255,255,102';
    const BG = '#1a1a2e';
    const PANEL_BG = '#16213e';
    const DARK_PANEL = '#0f1629';

    const COLORS = ['#4af','#f55','#5f5','#f90'];
    const PLAYER_NAMES = ['YOU','CPU-A','CPU-B','CPU-C'];

    const GAME_DURATION = 180;
    let gameTimer = 0;
    let lastTime = 0;

    const UPGRADE_DEFS = [
      { name:'Auto-Click', baseCost:15,  baseRate:0.5, icon:'\u2699' },
      { name:'Multiplier', baseCost:100, baseRate:3,   icon:'\u00d7' },
      { name:'Factory',    baseCost:500, baseRate:15,  icon:'\u2302' },
      { name:'Robot',      baseCost:2500,baseRate:80,  icon:'\u2318' },
    ];

    const DEFENSE_DEFS = [
      { name:'Firewall',  cost:200, icon:'\u2761', desc:'Block hacks' },
      { name:'Vault',     cost:350, icon:'\u2610', desc:'Protect coins' },
      { name:'Antivirus', cost:500, icon:'\u2020', desc:'Block viruses' },
    ];

    const SABOTAGE_DEFS = [
      { name:'Hack',  cost:150, icon:'\u26a1', desc:'-50% prod 10s', duration:10 },
      { name:'Steal', cost:250, icon:'\u2694', desc:'Steal 10% coins', duration:0 },
      { name:'Virus', cost:400, icon:'\u2623', desc:'Disable upg 15s', duration:15 },
    ];

    let particles = [];
    let warningFlashes = [];
    let floatingTexts = [];

    function spawnCoinParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random()-0.5)*5,
          vy: -Math.random()*5-2,
          life: 1,
          color: color || THEME,
          size: Math.random()*3+2,
        });
      }
    }

    function spawnFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color: color || THEME, life: 1 });
    }

    function spawnWarningFlash(playerIndex) {
      warningFlashes.push({ player: playerIndex, life: 1 });
    }

    function createPlayer(index) {
      return {
        index,
        coins: 0,
        totalCoins: 0,
        upgrades: [0,0,0,0],
        defenses: [false,false,false],
        disabledUpgrade: -1,
        disableTimer: 0,
        hackTimer: 0,
        productionRate: 0,
        clickPower: 1,
        isAI: index > 0,
        aiClickTimer: 0,
        aiSabotageTimer: 5 + Math.random()*10,
        aiStrategyBias: Math.random(),
      };
    }

    let players = [];
    let selectedSabotageType = -1;

    const LEADERBOARD_H = 38;
    const TIMER_H = 18;
    const TOP_H = LEADERBOARD_H + TIMER_H;
    const PANEL_W = 148;
    const CLICK_AREA_X = PANEL_W;
    const CLICK_AREA_W = W - PANEL_W*2;
    const CLICK_AREA_H = H - TOP_H;
    const CLICK_BTN = { x: W/2, y: TOP_H + 68, r: 42 };

    function getUpgradeBtn(i) { return { x:4, y:TOP_H+10+i*55, w:140, h:50 }; }
    function getDefenseBtn(i) { return { x:4, y:TOP_H+10+4*55+6+i*44, w:140, h:38 }; }
    function getSabotageBtn(i) { return { x:W-144, y:TOP_H+10+i*52, w:140, h:46 }; }
    function getTargetBtn(i) { return { x:W-144, y:TOP_H+10+3*52+10+i*36, w:140, h:30 }; }

    function calcProduction(p) {
      let rate = 0;
      for (let i = 0; i < 4; i++) {
        if (p.disabledUpgrade === i) continue;
        rate += p.upgrades[i] * UPGRADE_DEFS[i].baseRate;
      }
      if (p.hackTimer > 0) rate *= 0.5;
      p.productionRate = rate;
      return rate;
    }

    function upgradeCost(def, count) {
      return Math.floor(def.baseCost * Math.pow(1.18, count));
    }

    function init() {
      players = [];
      for (let i = 0; i < 4; i++) players.push(createPlayer(i));
      gameTimer = GAME_DURATION;
      particles = [];
      warningFlashes = [];
      floatingTexts = [];
      selectedSabotageType = -1;
      score = 0;
      scoreEl.textContent = '0';
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      init();
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function endGame() {
      gameState = 'over';
      score = Math.floor(players[0].totalCoins);
      scoreEl.textContent = formatNum(score);
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('idleClickerPvpBest', bestScore);
        bestEl.textContent = bestScore;
      }
      const ranked = players.slice().sort((a,b) => b.totalCoins - a.totalCoins);
      const playerRank = ranked.findIndex(p => p.index === 0) + 1;
      const suffix = playerRank===1?'st':playerRank===2?'nd':playerRank===3?'rd':'th';
      overlayTitle.textContent = playerRank === 1 ? 'VICTORY!' : 'GAME OVER';
      overlayTitle.style.color = playerRank === 1 ? '#ff6' : '#f55';
      let txt = `You placed ${playerRank}${suffix}!<br><br>Final Scores:<br>`;
      ranked.forEach((p, i) => {
        const marker = p.index === 0 ? ' \u2190' : '';
        txt += `${i+1}. ${PLAYER_NAMES[p.index]}: ${formatNum(Math.floor(p.totalCoins))} coins${marker}<br>`;
      });
      txt += '<br>Click to play again';
      overlayText.innerHTML = txt;
      overlay.style.display = 'flex';
    }

    function formatNum(n) {
      if (n >= 1000000) return (n/1000000).toFixed(1)+'M';
      if (n >= 10000) return (n/1000).toFixed(1)+'K';
      return Math.floor(n).toString();
    }

    // --- AI Logic ---
    function aiTick(p, dt) {
      if (gameState !== 'playing') return;

      // AI clicking
      p.aiClickTimer -= dt;
      if (p.aiClickTimer <= 0) {
        const clickRate = 2 + Math.random()*3;
        const earned = p.clickPower;
        p.coins += earned;
        p.totalCoins += earned;
        p.aiClickTimer = 1/clickRate;
      }

      // AI upgrade buying
      if (Math.random() < dt * 2) {
        let bestVal = -1, bestIdx = -1;
        for (let i = 0; i < 4; i++) {
          const cost = upgradeCost(UPGRADE_DEFS[i], p.upgrades[i]);
          if (cost <= p.coins) {
            const value = UPGRADE_DEFS[i].baseRate / cost;
            if (value > bestVal) { bestVal = value; bestIdx = i; }
          }
        }
        if (bestIdx >= 0) {
          const cost = upgradeCost(UPGRADE_DEFS[bestIdx], p.upgrades[bestIdx]);
          p.coins -= cost;
          p.upgrades[bestIdx]++;
        }
        // Consider defenses
        for (let i = 0; i < 3; i++) {
          if (!p.defenses[i] && p.coins >= DEFENSE_DEFS[i].cost && Math.random() < 0.25) {
            p.coins -= DEFENSE_DEFS[i].cost;
            p.defenses[i] = true;
          }
        }
      }

      // AI sabotage
      p.aiSabotageTimer -= dt;
      if (p.aiSabotageTimer <= 0) {
        p.aiSabotageTimer = 8 + Math.random()*15;
        let target = -1, maxCoins = -1;
        for (let i = 0; i < 4; i++) {
          if (i === p.index) continue;
          if (players[i].totalCoins > maxCoins) { maxCoins = players[i].totalCoins; target = i; }
        }
        if (target >= 0) {
          if (p.coins >= SABOTAGE_DEFS[2].cost && p.aiStrategyBias > 0.6 && Math.random() < 0.35) {
            if (!players[target].defenses[2]) { p.coins -= SABOTAGE_DEFS[2].cost; executeSabotage(2,p.index,target); }
          } else if (p.coins >= SABOTAGE_DEFS[1].cost && Math.random() < 0.45) {
            if (!players[target].defenses[1]) { p.coins -= SABOTAGE_DEFS[1].cost; executeSabotage(1,p.index,target); }
          } else if (p.coins >= SABOTAGE_DEFS[0].cost && Math.random() < 0.55) {
            if (!players[target].defenses[0]) { p.coins -= SABOTAGE_DEFS[0].cost; executeSabotage(0,p.index,target); }
          }
        }
      }
    }

    function executeSabotage(type, attackerIdx, targetIdx) {
      const target = players[targetIdx];
      const attacker = players[attackerIdx];

      if (type === 0) {
        if (target.defenses[0]) {
          if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, 'FIREWALL BLOCKED!', '#5f5');
          return;
        }
        target.hackTimer = Math.max(target.hackTimer, SABOTAGE_DEFS[0].duration);
        spawnWarningFlash(targetIdx);
        if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, 'HACKED! -50%', '#f55');
      } else if (type === 1) {
        if (target.defenses[1]) {
          if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, 'VAULT PROTECTED!', '#5f5');
          return;
        }
        const stolen = Math.floor(target.coins * 0.1);
        target.coins -= stolen;
        attacker.coins += stolen;
        attacker.totalCoins += stolen;
        spawnWarningFlash(targetIdx);
        if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, `-${formatNum(stolen)} STOLEN!`, '#f55');
        if (attackerIdx === 0) spawnFloatingText(W/2, TOP_H+80, `+${formatNum(stolen)} STOLEN!`, '#5f5');
      } else if (type === 2) {
        if (target.defenses[2]) {
          if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, 'ANTIVIRUS BLOCKED!', '#5f5');
          return;
        }
        const available = [];
        for (let i = 0; i < 4; i++) {
          if (target.upgrades[i] > 0 && target.disabledUpgrade !== i) available.push(i);
        }
        if (available.length > 0) {
          target.disabledUpgrade = available[Math.floor(Math.random()*available.length)];
          target.disableTimer = SABOTAGE_DEFS[2].duration;
          spawnWarningFlash(targetIdx);
          if (targetIdx === 0) spawnFloatingText(W/2, TOP_H+60, 'VIRUS! Upgrade disabled!', '#f55');
        }
      }
    }

    // --- Mouse ---
    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W/rect.width;
      const scaleY = H/rect.height;
      const cx = (e.clientX - rect.left)*scaleX;
      const cy = (e.clientY - rect.top)*scaleY;

      if (gameState !== 'playing') return;

      const p = players[0];

      // Click button
      const dx = cx - CLICK_BTN.x;
      const dy = cy - CLICK_BTN.y;
      if (dx*dx+dy*dy <= CLICK_BTN.r*CLICK_BTN.r) {
        const earned = p.clickPower;
        p.coins += earned;
        p.totalCoins += earned;
        spawnCoinParticles(CLICK_BTN.x, CLICK_BTN.y, 6+Math.min(Math.floor(earned),20), THEME);
        spawnFloatingText(CLICK_BTN.x + (Math.random()-0.5)*30, CLICK_BTN.y - 30, `+${earned.toFixed(1)}`, THEME);
        return;
      }

      // Upgrade buttons
      for (let i = 0; i < 4; i++) {
        const btn = getUpgradeBtn(i);
        if (cx>=btn.x && cx<=btn.x+btn.w && cy>=btn.y && cy<=btn.y+btn.h) {
          const cost = upgradeCost(UPGRADE_DEFS[i], p.upgrades[i]);
          if (p.coins >= cost) {
            p.coins -= cost;
            p.upgrades[i]++;
            spawnCoinParticles(btn.x+btn.w/2, btn.y+btn.h/2, 4, '#5f5');
            spawnFloatingText(btn.x+btn.w/2, btn.y, `+1 ${UPGRADE_DEFS[i].name}`, '#5f5');
          }
          return;
        }
      }

      // Defense buttons
      for (let i = 0; i < 3; i++) {
        const btn = getDefenseBtn(i);
        if (cx>=btn.x && cx<=btn.x+btn.w && cy>=btn.y && cy<=btn.y+btn.h) {
          if (!p.defenses[i] && p.coins >= DEFENSE_DEFS[i].cost) {
            p.coins -= DEFENSE_DEFS[i].cost;
            p.defenses[i] = true;
            spawnCoinParticles(btn.x+btn.w/2, btn.y+btn.h/2, 6, '#4af');
          }
          return;
        }
      }

      // Sabotage type buttons
      for (let i = 0; i < 3; i++) {
        const btn = getSabotageBtn(i);
        if (cx>=btn.x && cx<=btn.x+btn.w && cy>=btn.y && cy<=btn.y+btn.h) {
          if (p.coins >= SABOTAGE_DEFS[i].cost) {
            selectedSabotageType = (selectedSabotageType === i) ? -1 : i;
          }
          return;
        }
      }

      // Target buttons
      if (selectedSabotageType >= 0) {
        for (let i = 0; i < 3; i++) {
          const btn = getTargetBtn(i);
          if (cx>=btn.x && cx<=btn.x+btn.w && cy>=btn.y && cy<=btn.y+btn.h) {
            const targetIdx = i+1;
            const cost = SABOTAGE_DEFS[selectedSabotageType].cost;
            if (p.coins >= cost) {
              p.coins -= cost;
              executeSabotage(selectedSabotageType, 0, targetIdx);
              spawnCoinParticles(btn.x+btn.w/2, btn.y+btn.h/2, 8, '#f55');
              selectedSabotageType = -1;
            }
            return;
          }
        }
      }
    });

    // Overlay click
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') startGame();
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    // --- Update ---
    function update(dt) {
      if (gameState !== 'playing') return;

      gameTimer -= dt;
      if (gameTimer <= 0) { gameTimer = 0; endGame(); return; }

      for (let p of players) {
        calcProduction(p);
        const earned = p.productionRate * dt;
        p.coins += earned;
        p.totalCoins += earned;
        p.clickPower = 1 + p.upgrades[1]*0.5;
        if (p.hackTimer > 0) p.hackTimer -= dt;
        if (p.hackTimer < 0) p.hackTimer = 0;
        if (p.disableTimer > 0) {
          p.disableTimer -= dt;
          if (p.disableTimer <= 0) { p.disableTimer = 0; p.disabledUpgrade = -1; }
        }
        if (p.isAI) aiTick(p, dt);
      }

      score = Math.floor(players[0].totalCoins);
      scoreEl.textContent = formatNum(score);

      // Particles
      for (let i = particles.length-1; i >= 0; i--) {
        const pt = particles[i];
        pt.x += pt.vx;
        pt.y += pt.vy;
        pt.vy += 4*dt;
        pt.life -= dt*1.5;
        if (pt.life <= 0) particles.splice(i, 1);
      }

      // Floating texts
      for (let i = floatingTexts.length-1; i >= 0; i--) {
        const ft = floatingTexts[i];
        ft.y -= 30*dt;
        ft.life -= dt;
        if (ft.life <= 0) floatingTexts.splice(i, 1);
      }

      // Warning flashes
      for (let i = warningFlashes.length-1; i >= 0; i--) {
        warningFlashes[i].life -= dt*2.5;
        if (warningFlashes[i].life <= 0) warningFlashes.splice(i, 1);
      }
    }

    // --- Draw ---
    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'waiting') { drawIdleScreen(); return; }

      drawLeaderboard();
      drawTimer();
      drawLeftPanel();
      drawCenterArea();
      drawRightPanel();
      drawParticles();
      drawFloatingTexts();
      drawWarningFlashes();
    }

    function drawIdleScreen() {
      ctx.save();
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 25;
      ctx.font = 'bold 28px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('IDLE CLICKER PVP', W/2, H/2-30);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#aaa';
      ctx.font = '14px Courier New';
      ctx.fillText('Compete. Upgrade. Sabotage.', W/2, H/2+10);
      ctx.restore();
    }

    function drawLeaderboard() {
      ctx.fillStyle = DARK_PANEL;
      ctx.fillRect(0, 0, W, LEADERBOARD_H);
      const ranked = players.slice().sort((a,b) => b.totalCoins - a.totalCoins);
      const colW = W/4;
      for (let i = 0; i < 4; i++) {
        const p = ranked[i];
        const x = colW*i + colW/2;
        // Rank
        ctx.fillStyle = i===0?'#ff6':i===1?'#ccc':i===2?'#b87333':'#666';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`#${i+1}`, x-42, 15);
        // Name
        ctx.fillStyle = COLORS[p.index];
        ctx.shadowColor = COLORS[p.index];
        ctx.shadowBlur = p.index===0?8:3;
        ctx.font = 'bold 11px Courier New';
        ctx.fillText(PLAYER_NAMES[p.index], x, 15);
        ctx.shadowBlur = 0;
        // Coins
        ctx.fillStyle = '#ddd';
        ctx.font = '10px Courier New';
        ctx.fillText(formatNum(Math.floor(p.totalCoins)), x, 30);
      }
      ctx.strokeStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.moveTo(0, LEADERBOARD_H-1);
      ctx.lineTo(W, LEADERBOARD_H-1);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawTimer() {
      const y = LEADERBOARD_H;
      ctx.fillStyle = '#111';
      ctx.fillRect(0, y, W, TIMER_H);
      const pct = gameTimer/GAME_DURATION;
      const barX = 70;
      const barW = W-140;
      ctx.fillStyle = '#222';
      ctx.fillRect(barX, y+3, barW, 12);
      const barColor = pct>0.5?'#5f5':pct>0.2?'#ff6':'#f55';
      ctx.fillStyle = barColor;
      ctx.shadowColor = barColor;
      ctx.shadowBlur = 5;
      ctx.fillRect(barX, y+3, barW*pct, 12);
      ctx.shadowBlur = 0;
      const mins = Math.floor(gameTimer/60);
      const secs = Math.floor(gameTimer%60);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`${mins}:${secs.toString().padStart(2,'0')}`, 8, y+13);
      ctx.textAlign = 'right';
      ctx.fillStyle = '#888';
      ctx.font = '9px Courier New';
      ctx.fillText(`${formatNum(Math.floor(players[0].productionRate))}/s`, W-8, y+13);
    }

    function drawLeftPanel() {
      const p = players[0];
      ctx.fillStyle = PANEL_BG;
      ctx.fillRect(0, TOP_H, PANEL_W, H-TOP_H);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(0, TOP_H, PANEL_W, H-TOP_H);

      ctx.fillStyle = THEME;
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('UPGRADES', PANEL_W/2, TOP_H+8);

      for (let i = 0; i < 4; i++) {
        const btn = getUpgradeBtn(i);
        const def = UPGRADE_DEFS[i];
        const cost = upgradeCost(def, p.upgrades[i]);
        const canAfford = p.coins >= cost;
        const disabled = p.disabledUpgrade === i;

        ctx.fillStyle = disabled?'#331111':canAfford?'#1a2a4a':'#1a1a2a';
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = disabled?'#f55':canAfford?'#4af':'#333';
        if (canAfford && !disabled) { ctx.shadowColor='#4af'; ctx.shadowBlur=3; }
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.shadowBlur = 0;

        ctx.fillStyle = disabled?'#f55':canAfford?'#fff':'#666';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`${def.icon} ${def.name}`, btn.x+4, btn.y+13);

        ctx.fillStyle = disabled?'#f55':'#5f5';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(`x${p.upgrades[i]}`, btn.x+btn.w-4, btn.y+13);

        ctx.textAlign = 'left';
        ctx.fillStyle = canAfford?THEME:'#555';
        ctx.font = '9px Courier New';
        ctx.fillText(`\u00a2${formatNum(cost)}`, btn.x+4, btn.y+27);
        ctx.fillStyle = '#888';
        ctx.fillText(`+${def.baseRate}/s`, btn.x+4, btn.y+39);

        if (disabled) {
          ctx.fillStyle = '#f55';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'right';
          ctx.fillText(`\u2623 ${Math.ceil(p.disableTimer)}s`, btn.x+btn.w-4, btn.y+39);
        }
      }

      // Defense section
      const defLabelY = TOP_H + 4*55 + 1;
      ctx.fillStyle = '#4af';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('DEFENSES', PANEL_W/2, defLabelY+4);

      for (let i = 0; i < 3; i++) {
        const btn = getDefenseBtn(i);
        const def = DEFENSE_DEFS[i];
        const owned = p.defenses[i];

        ctx.fillStyle = owned?'#1a3a2a':p.coins>=def.cost?'#1a2a4a':'#1a1a2a';
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = owned?'#5f5':p.coins>=def.cost?'#4af':'#333';
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);

        ctx.fillStyle = owned?'#5f5':p.coins>=def.cost?'#fff':'#666';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`${def.icon} ${def.name}`, btn.x+4, btn.y+13);

        ctx.textAlign = 'right';
        if (owned) {
          ctx.fillStyle = '#5f5';
          ctx.font = 'bold 8px Courier New';
          ctx.fillText('\u2713 ON', btn.x+btn.w-4, btn.y+13);
        } else {
          ctx.fillStyle = p.coins>=def.cost?THEME:'#555';
          ctx.font = '9px Courier New';
          ctx.fillText(`\u00a2${def.cost}`, btn.x+btn.w-4, btn.y+13);
        }

        ctx.fillStyle = '#666';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(def.desc, btn.x+4, btn.y+26);
      }
    }

    function drawCenterArea() {
      const p = players[0];
      ctx.fillStyle = '#111827';
      ctx.fillRect(CLICK_AREA_X, TOP_H, CLICK_AREA_W, CLICK_AREA_H);

      // Big click button
      const pulse = (Math.sin(Date.now()*0.005)+1)/2;
      const pr = CLICK_BTN.r + pulse*3;

      // Outer glow ring
      ctx.beginPath();
      ctx.arc(CLICK_BTN.x, CLICK_BTN.y, pr+10, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${THEME_RGB},0.06)`;
      ctx.fill();

      // Button
      const grad = ctx.createRadialGradient(CLICK_BTN.x-8, CLICK_BTN.y-8, 0, CLICK_BTN.x, CLICK_BTN.y, pr);
      grad.addColorStop(0, '#ffe066');
      grad.addColorStop(0.6, '#cc9900');
      grad.addColorStop(1, '#886600');
      ctx.beginPath();
      ctx.arc(CLICK_BTN.x, CLICK_BTN.y, pr, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 15+pulse*10;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Coin symbol
      ctx.fillStyle = '#1a1a2e';
      ctx.font = 'bold 28px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('\u00a2', CLICK_BTN.x, CLICK_BTN.y);
      ctx.textBaseline = 'alphabetic';

      // Click power text
      ctx.fillStyle = THEME;
      ctx.font = 'bold 9px Courier New';
      ctx.fillText(`+${p.clickPower.toFixed(1)}/click`, CLICK_BTN.x, CLICK_BTN.y+pr+15);

      // Player coins
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 15px Courier New';
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 10;
      ctx.fillText(`\u00a2 ${formatNum(Math.floor(p.coins))}`, CLICK_BTN.x, CLICK_BTN.y-pr-18);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#aaa';
      ctx.font = '9px Courier New';
      ctx.fillText(`Total: ${formatNum(Math.floor(p.totalCoins))}`, CLICK_BTN.x, CLICK_BTN.y-pr-6);

      // Opponent mini panels
      drawOpponentPanels();

      // Hack overlay
      if (p.hackTimer > 0) {
        ctx.save();
        ctx.fillStyle = `rgba(255,50,50,${0.12+Math.sin(Date.now()*0.01)*0.08})`;
        ctx.fillRect(CLICK_AREA_X, TOP_H, CLICK_AREA_W, CLICK_AREA_H);
        ctx.fillStyle = '#f55';
        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#f55';
        ctx.shadowBlur = 10;
        ctx.fillText(`\u26a1 HACKED! -50% (${Math.ceil(p.hackTimer)}s)`, W/2, TOP_H+CLICK_AREA_H-10);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawOpponentPanels() {
      const pw = (CLICK_AREA_W-16)/3;
      const ph = 155;
      const py = TOP_H+135;

      for (let i = 1; i < 4; i++) {
        const p = players[i];
        const px = CLICK_AREA_X + 4 + (i-1)*(pw+4);

        ctx.fillStyle = DARK_PANEL;
        ctx.fillRect(px, py, pw, ph);

        // Top color bar
        ctx.fillStyle = COLORS[i];
        ctx.fillRect(px, py, pw, 3);

        // Name
        ctx.fillStyle = COLORS[i];
        ctx.shadowColor = COLORS[i];
        ctx.shadowBlur = 4;
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(PLAYER_NAMES[i], px+pw/2, py+17);
        ctx.shadowBlur = 0;

        // Coins
        ctx.fillStyle = '#ddd';
        ctx.font = '9px Courier New';
        ctx.fillText(`\u00a2${formatNum(Math.floor(p.coins))}`, px+pw/2, py+32);

        // Rate
        ctx.fillStyle = '#888';
        ctx.font = '8px Courier New';
        ctx.fillText(`${formatNum(Math.floor(p.productionRate))}/s`, px+pw/2, py+44);

        // Upgrades
        ctx.textAlign = 'left';
        ctx.font = '8px Courier New';
        for (let j = 0; j < 4; j++) {
          const uy = py+58 + j*13;
          const dis = p.disabledUpgrade === j;
          ctx.fillStyle = dis?'#f55':p.upgrades[j]>0?'#5f5':'#444';
          ctx.fillText(`${UPGRADE_DEFS[j].icon}`, px+3, uy);
          ctx.textAlign = 'right';
          ctx.fillText(`x${p.upgrades[j]}`, px+pw-3, uy);
          ctx.textAlign = 'left';
        }

        // Defense icons
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        for (let j = 0; j < 3; j++) {
          ctx.fillStyle = p.defenses[j]?'#5f5':'#333';
          ctx.fillText(DEFENSE_DEFS[j].icon, px+15+j*28, py+118);
        }

        // Status effects
        if (p.hackTimer > 0) {
          ctx.fillStyle = '#f55';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(`\u26a1HACKED ${Math.ceil(p.hackTimer)}s`, px+pw/2, py+ph-8);
        }
        if (p.disabledUpgrade >= 0) {
          ctx.fillStyle = '#f90';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(`\u2623VIRUS ${Math.ceil(p.disableTimer)}s`, px+pw/2, py+ph-20);
        }
      }
    }

    function drawRightPanel() {
      const p = players[0];
      ctx.fillStyle = PANEL_BG;
      ctx.fillRect(W-PANEL_W, TOP_H, PANEL_W, H-TOP_H);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(W-PANEL_W, TOP_H, PANEL_W, H-TOP_H);

      ctx.fillStyle = '#f55';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('SABOTAGE', W-PANEL_W/2, TOP_H+8);

      for (let i = 0; i < 3; i++) {
        const btn = getSabotageBtn(i);
        const def = SABOTAGE_DEFS[i];
        const canAfford = p.coins >= def.cost;
        const sel = selectedSabotageType === i;

        ctx.fillStyle = sel?'#3a1a1a':canAfford?'#2a1a1a':'#1a1a2a';
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = sel?'#f55':canAfford?'#f90':'#333';
        if (sel) { ctx.shadowColor='#f55'; ctx.shadowBlur=6; }
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.shadowBlur = 0;

        ctx.fillStyle = canAfford?'#fff':'#666';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`${def.icon} ${def.name}`, btn.x+4, btn.y+15);
        ctx.textAlign = 'right';
        ctx.fillStyle = canAfford?THEME:'#555';
        ctx.font = '9px Courier New';
        ctx.fillText(`\u00a2${def.cost}`, btn.x+btn.w-4, btn.y+15);
        ctx.textAlign = 'left';
        ctx.fillStyle = '#888';
        ctx.font = '8px Courier New';
        ctx.fillText(def.desc, btn.x+4, btn.y+30);

        if (sel) {
          ctx.fillStyle = '#f55';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'right';
          ctx.fillText('\u25bc TARGET', btn.x+btn.w-4, btn.y+42);
        }
      }

      if (selectedSabotageType >= 0) {
        const ty = TOP_H+3*52+4;
        ctx.fillStyle = '#f55';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('SELECT TARGET', W-PANEL_W/2, ty);

        for (let i = 0; i < 3; i++) {
          const btn = getTargetBtn(i);
          const targetIdx = i+1;
          const target = players[targetIdx];

          ctx.fillStyle = '#2a1a2a';
          ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
          ctx.strokeStyle = COLORS[targetIdx];
          ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);

          ctx.fillStyle = COLORS[targetIdx];
          ctx.font = 'bold 9px Courier New';
          ctx.textAlign = 'left';
          ctx.fillText(PLAYER_NAMES[targetIdx], btn.x+4, btn.y+13);

          const defended = target.defenses[selectedSabotageType];
          ctx.textAlign = 'right';
          if (defended) {
            ctx.fillStyle = '#5f5';
            ctx.font = 'bold 8px Courier New';
            ctx.fillText('\u2761 SHIELDED', btn.x+btn.w-4, btn.y+13);
          } else {
            ctx.fillStyle = THEME;
            ctx.font = '8px Courier New';
            ctx.fillText(`\u00a2${formatNum(Math.floor(target.coins))}`, btn.x+btn.w-4, btn.y+13);
          }
        }
      } else {
        const iy = TOP_H+3*52+16;
        ctx.fillStyle = '#555';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        const lines = [
          'Select a sabotage',
          'action above, then',
          'pick a target.',
          '',
          '\u26a1 Hack: halves',
          '  production rate',
          '',
          '\u2694 Steal: takes 10%',
          '  of their coins',
          '',
          '\u2623 Virus: disables',
          '  one upgrade',
        ];
        lines.forEach((l,i) => {
          ctx.fillText(l, W-PANEL_W/2, iy+i*13);
        });
      }
    }

    function drawParticles() {
      for (const pt of particles) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, pt.life);
        ctx.fillStyle = pt.color;
        ctx.shadowColor = pt.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.size*pt.life, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawFloatingTexts() {
      for (const ft of floatingTexts) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, ft.life);
        ctx.fillStyle = ft.color;
        ctx.shadowColor = ft.color;
        ctx.shadowBlur = 8;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.restore();
      }
    }

    function drawWarningFlashes() {
      for (const wf of warningFlashes) {
        if (wf.player === 0) {
          ctx.save();
          ctx.globalAlpha = wf.life*0.3;
          ctx.fillStyle = '#f55';
          ctx.fillRect(CLICK_AREA_X, TOP_H, CLICK_AREA_W, CLICK_AREA_H);
          ctx.restore();
        } else {
          const pw2 = (CLICK_AREA_W-16)/3;
          const px = CLICK_AREA_X + 4 + (wf.player-1)*(pw2+4);
          ctx.save();
          ctx.globalAlpha = wf.life*0.4;
          ctx.fillStyle = '#f55';
          ctx.fillRect(px, TOP_H+135, pw2, 155);
          ctx.restore();
        }
      }
    }

    // --- Game Loop ---
    function gameLoop(now) {
      const dt = Math.min((now-lastTime)/1000, 0.1);
      lastTime = now;
      update(dt);
      draw();
      if (gameState === 'playing' || gameState === 'over') {
        requestAnimationFrame(gameLoop);
      }
    }

    // Initial draw
    draw();

    // Expose game data
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState, score, gameTimer,
        players: players.map(p => ({
          coins: Math.floor(p.coins),
          totalCoins: Math.floor(p.totalCoins),
          productionRate: p.productionRate,
          upgrades: [...p.upgrades],
          defenses: [...p.defenses],
        })),
      };
    }
    setInterval(updateGameData, 500);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arkanoid</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #4fb; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 255, 187, 0.5); }
    h1 { color: #4fb; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 255, 187, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4fb; }
    canvas {
      border: 2px solid #4fb;
      box-shadow: 0 0 20px rgba(68, 255, 187, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4fb;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ARKANOID</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">ARKANOID</h2>
      <p id="overlayText">Press SPACE or click to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const PADDLE_BASE_W = 80;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 40;
    const PADDLE_SPEED = 7;
    const BALL_R = 5;
    const BASE_BALL_SPEED = 5.5;
    const BRICK_COLS = 12;
    const BRICK_ROWS = 10;
    const BRICK_W = (W - 20) / BRICK_COLS;
    const BRICK_H = 18;
    const BRICK_TOP = 60;
    const BRICK_PAD = 2;
    const POWERUP_W = 24;
    const POWERUP_H = 14;
    const POWERUP_SPEED = 2.5;
    const LASER_W = 3;
    const LASER_H = 14;
    const LASER_SPEED = 8;

    // Brick types
    const BRICK_NORMAL = 1;
    const BRICK_TOUGH = 2;
    const BRICK_METAL = 3;

    // Power-up types
    const PU_EXPAND = 'E';
    const PU_LASER = 'L';
    const PU_MULTI = 'M';
    const PU_STRONG = 'P';
    const PU_LIFE = '1';

    const PU_COLORS = {
      [PU_EXPAND]: '#4fb',
      [PU_LASER]: '#f44',
      [PU_MULTI]: '#88f',
      [PU_STRONG]: '#fa0',
      [PU_LIFE]: '#f0f'
    };

    const PU_LABELS = {
      [PU_EXPAND]: 'E',
      [PU_LASER]: 'L',
      [PU_MULTI]: 'M',
      [PU_STRONG]: 'P',
      [PU_LIFE]: '+'
    };

    const PU_TYPES = [PU_EXPAND, PU_LASER, PU_MULTI, PU_STRONG, PU_LIFE];

    // Row colors for normal bricks
    const ROW_COLORS = ['#f44', '#f80', '#fa0', '#ff0', '#8f0', '#0f0', '#0f8', '#0ff', '#08f', '#88f'];

    // --- Game state ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let lives, level;
    let paddleX, paddleW;
    let balls; // Array of {x, y, vx, vy}
    let bricks; // 2D array of {type, hits, alive}
    let powerups; // Array of {x, y, type}
    let lasers; // Array of {x, y}
    let keys = {};
    let mouseX = null;
    let useMouseControl = false;
    let hasLaser = false;
    let laserTimer = 0;
    let expandTimer = 0;
    let strongTimer = 0;
    let laserHintTimer = 0;
    let frameCount = 0;
    let comboCount = 0;
    let lastHitTime = 0;
    let particles = [];

    // --- Level layouts ---
    // 0 = empty, 1 = normal, 2 = tough, 3 = metal
    function generateLevel(lvl) {
      const layout = [];
      for (let r = 0; r < BRICK_ROWS; r++) {
        layout[r] = [];
        for (let c = 0; c < BRICK_COLS; c++) {
          layout[r][c] = 0;
        }
      }

      switch ((lvl - 1) % 16) {
        case 0: // Welcome Mat — simple full grid
          for (let r = 0; r < 6; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              layout[r][c] = BRICK_NORMAL;
            }
          }
          break;

        case 1: // Checkerboard with tough bricks
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              if ((r + c) % 2 === 0) {
                layout[r][c] = r < 2 ? BRICK_TOUGH : BRICK_NORMAL;
              }
            }
          }
          break;

        case 2: // Diamond — partial metal border with openings
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              const cx = BRICK_COLS / 2 - 0.5;
              const cy = 4;
              const dist = Math.abs(c - cx) + Math.abs(r - cy);
              if (dist <= 5) {
                if (dist === 5 && (c + r) % 2 === 0) layout[r][c] = BRICK_METAL;
                else if (dist === 5) layout[r][c] = BRICK_TOUGH;
                else if (dist <= 2) layout[r][c] = BRICK_TOUGH;
                else layout[r][c] = BRICK_NORMAL;
              }
            }
          }
          break;

        case 3: // Stripes — alternating normal/tough rows, no metal
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              layout[r][c] = r % 2 === 0 ? BRICK_NORMAL : BRICK_TOUGH;
            }
          }
          break;

        case 4: // Inverted pyramid
          for (let r = 0; r < 7; r++) {
            const indent = r;
            for (let c = indent; c < BRICK_COLS - indent; c++) {
              if (c >= 0 && c < BRICK_COLS) {
                layout[r][c] = r === 0 ? BRICK_TOUGH : BRICK_NORMAL;
              }
            }
          }
          layout[0][0] = BRICK_METAL;
          layout[0][BRICK_COLS - 1] = BRICK_METAL;
          break;

        case 5: // Cross pattern
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              const midC = Math.floor(BRICK_COLS / 2);
              const midR = 4;
              if (c >= midC - 1 && c <= midC || r >= midR - 1 && r <= midR) {
                layout[r][c] = BRICK_NORMAL;
              }
              if (c >= midC - 1 && c <= midC && r >= midR - 1 && r <= midR) {
                layout[r][c] = BRICK_TOUGH;
              }
            }
          }
          layout[0][Math.floor(BRICK_COLS / 2) - 1] = BRICK_METAL;
          layout[0][Math.floor(BRICK_COLS / 2)] = BRICK_METAL;
          break;

        case 6: // Zigzag
          for (let r = 0; r < 8; r++) {
            const offset = (r % 2 === 0) ? 0 : 3;
            for (let c = 0; c < BRICK_COLS; c++) {
              if ((c + offset) % 6 < 4) {
                layout[r][c] = r < 3 ? BRICK_TOUGH : BRICK_NORMAL;
              }
            }
          }
          break;

        case 7: // Fortress — metal top + corner pillars, wide bottom gate
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              if (r === 0) {
                layout[r][c] = BRICK_METAL;
              } else if (r <= 5 && (c <= 1 || c >= BRICK_COLS - 2)) {
                layout[r][c] = BRICK_METAL;
              } else if (r === 1 && c >= 2 && c <= BRICK_COLS - 3) {
                layout[r][c] = BRICK_TOUGH;
              } else if (r >= 2 && r <= 7 && c >= 2 && c <= BRICK_COLS - 3) {
                layout[r][c] = BRICK_NORMAL;
              }
            }
          }
          break;

        case 8: // Corridor — vertical metal walls, normal center, tough sides
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              if (c === 4 || c === 7) {
                layout[r][c] = BRICK_METAL;
              } else if (c === 5 || c === 6) {
                layout[r][c] = BRICK_NORMAL;
              } else {
                layout[r][c] = BRICK_TOUGH;
              }
            }
          }
          break;

        case 9: { // Bullseye — concentric rings
          const cx9 = BRICK_COLS / 2 - 0.5;
          const cy9 = 4.5;
          for (let r = 0; r < BRICK_ROWS; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              const dist = Math.sqrt((c - cx9) * (c - cx9) + (r - cy9) * (r - cy9));
              if (dist <= 1.5) {
                layout[r][c] = r <= 3 ? 0 : BRICK_METAL;
              } else if (dist <= 3) {
                layout[r][c] = BRICK_TOUGH;
              } else if (dist <= 5) {
                layout[r][c] = BRICK_NORMAL;
              }
            }
          }
          break;
        }

        case 10: // Maze — metal walls with normal brick paths
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              layout[r][c] = BRICK_NORMAL;
            }
          }
          for (let c = 0; c < 5; c++) layout[2][c] = BRICK_METAL;
          for (let c = 7; c < BRICK_COLS; c++) layout[4][c] = BRICK_METAL;
          for (let c = 0; c < 5; c++) layout[6][c] = BRICK_METAL;
          for (let r = 0; r < 3; r++) layout[r][8] = BRICK_METAL;
          for (let r = 4; r < 7; r++) layout[r][3] = BRICK_METAL;
          for (let r = 6; r < 9; r++) layout[r][8] = BRICK_METAL;
          break;

        case 11: // Shields — 3 shielded groups
          for (let g = 0; g < 3; g++) {
            const cOff = g * 4;
            for (let r = 5; r <= 7; r++) {
              for (let c = cOff; c < cOff + 4; c++) {
                layout[r][c] = BRICK_NORMAL;
              }
            }
            layout[2][cOff + 1] = BRICK_TOUGH;
            layout[2][cOff + 2] = BRICK_TOUGH;
            for (let c = cOff; c < cOff + 4; c++) layout[3][c] = BRICK_TOUGH;
            for (let c = cOff; c < cOff + 4; c++) layout[4][c] = BRICK_TOUGH;
          }
          break;

        case 12: // Staircase — descending steps
          for (let step = 0; step < 6; step++) {
            const r = step + 1;
            const cStart = step * 2;
            for (let c = cStart; c < cStart + 2 && c < BRICK_COLS; c++) {
              layout[r][c] = step < 2 ? BRICK_TOUGH : BRICK_NORMAL;
              if (r + 1 < BRICK_ROWS) layout[r + 1][c] = BRICK_NORMAL;
            }
            if (cStart < BRICK_COLS) layout[r][cStart] = BRICK_METAL;
          }
          break;

        case 13: // Honeycomb — offset hex-like pattern
          for (let r = 0; r < 8; r++) {
            const off = (r % 2 === 0) ? 0 : 1;
            for (let c = off; c < BRICK_COLS; c += 2) {
              layout[r][c] = BRICK_NORMAL;
              if (r >= 1 && r <= 6 && c >= 2 && c <= 9 && (r + c) % 4 === 0) {
                layout[r][c] = BRICK_TOUGH;
              }
            }
          }
          break;

        case 14: // Gauntlet — dense field with metal column gap
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              if (c === 5 || c === 6) {
                layout[r][c] = r >= 6 ? BRICK_NORMAL : 0;
              } else if (c === 4 || c === 7) {
                layout[r][c] = BRICK_METAL;
              } else if (r < 4) {
                layout[r][c] = BRICK_TOUGH;
              } else {
                layout[r][c] = BRICK_NORMAL;
              }
            }
          }
          break;

        case 15: { // Boss — skull pattern
          const skull = [
            [0,0,2,2,2,2,2,2,2,2,0,0],
            [0,2,2,2,2,2,2,2,2,2,2,0],
            [0,2,1,3,3,1,1,3,3,1,2,0],
            [0,2,1,1,1,1,1,1,1,1,2,0],
            [0,0,2,1,1,2,2,1,1,2,0,0],
            [0,0,0,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,0,1,1,0,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,0,0,0],
          ];
          for (let r = 0; r < skull.length; r++) {
            for (let c = 0; c < BRICK_COLS; c++) {
              layout[r][c] = skull[r][c];
            }
          }
          break;
        }
      }

      // Add extra tough bricks for higher levels (after first cycle)
      if (lvl > 16) {
        const extraTough = Math.min(lvl - 16, 10);
        for (let i = 0; i < extraTough; i++) {
          const r = Math.floor(Math.random() * BRICK_ROWS);
          const c = Math.floor(Math.random() * BRICK_COLS);
          if (layout[r][c] === BRICK_NORMAL) {
            layout[r][c] = BRICK_TOUGH;
          }
        }
      }

      return layout;
    }

    function initBricks(lvl) {
      const layout = generateLevel(lvl);
      bricks = [];
      for (let r = 0; r < BRICK_ROWS; r++) {
        bricks[r] = [];
        for (let c = 0; c < BRICK_COLS; c++) {
          const type = layout[r][c];
          bricks[r][c] = {
            type: type,
            hits: type === BRICK_TOUGH ? 2 : (type === BRICK_METAL ? -1 : 1),
            alive: type > 0
          };
        }
      }
    }

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      paddleW = PADDLE_BASE_W;
      paddleX = W / 2 - paddleW / 2;
      balls = [];
      powerups = [];
      lasers = [];
      particles = [];
      hasLaser = false;
      laserTimer = 0;
      expandTimer = 0;
      strongTimer = 0;
      laserHintTimer = 0;
      frameCount = 0;
      comboCount = 0;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      initBricks(1);
      resetBall();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ARKANOID';
      overlayText.textContent = 'Press SPACE or click to start';
      draw();
    }

    function resetBall() {
      balls = [];
      const speed = getEffectiveBallSpeed();
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;
      balls.push({
        x: W / 2,
        y: PADDLE_Y - BALL_R - 2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed
      });
    }

    function getEffectiveBallSpeed() {
      return BASE_BALL_SPEED + (level - 1) * 0.3;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      frameCount++;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 20 + Math.random() * 20,
          maxLife: 40,
          color: color,
          size: 2 + Math.random() * 3
        });
      }
    }

    function maybeDropPowerup(x, y) {
      if (Math.random() < 0.20) {
        const type = PU_TYPES[Math.floor(Math.random() * PU_TYPES.length)];
        powerups.push({ x: x, y: y, type: type });
      }
    }

    function activatePowerup(type) {
      switch (type) {
        case PU_EXPAND:
          paddleW = PADDLE_BASE_W * 1.6;
          expandTimer = 600;
          break;

        case PU_LASER:
          hasLaser = true;
          laserTimer = 600;
          laserHintTimer = 120;
          break;

        case PU_MULTI:
          if (balls.length > 0) {
            const newBalls = [];
            const sourceBall = balls[0];
            const speed = Math.sqrt(sourceBall.vx * sourceBall.vx + sourceBall.vy * sourceBall.vy);
            for (let i = 0; i < 2; i++) {
              const angleOffset = (i === 0 ? -0.5 : 0.5);
              const currentAngle = Math.atan2(sourceBall.vy, sourceBall.vx);
              const newAngle = currentAngle + angleOffset;
              newBalls.push({
                x: sourceBall.x,
                y: sourceBall.y,
                vx: Math.cos(newAngle) * speed,
                vy: Math.sin(newAngle) * speed
              });
            }
            balls.push(...newBalls);
          }
          break;

        case PU_STRONG:
          strongTimer = 480;
          break;

        case PU_LIFE:
          lives++;
          livesEl.textContent = lives;
          break;
      }
    }

    function update() {
      // Decrement timers
      if (expandTimer > 0) {
        expandTimer--;
        if (expandTimer <= 0) {
          paddleW = PADDLE_BASE_W;
          paddleX = Math.min(paddleX, W - paddleW);
        }
      }
      if (laserTimer > 0) {
        laserTimer--;
        if (laserTimer <= 0) hasLaser = false;
      }
      if (strongTimer > 0) {
        strongTimer--;
      }
      if (laserHintTimer > 0) {
        laserHintTimer--;
      }

      // Move paddle via keys
      if (keys['ArrowLeft'] || keys['a']) paddleX -= PADDLE_SPEED;
      if (keys['ArrowRight'] || keys['d']) paddleX += PADDLE_SPEED;

      // Move paddle via mouse
      if (useMouseControl && mouseX !== null) {
        const targetX = mouseX - paddleW / 2;
        const diff = targetX - paddleX;
        paddleX += diff * 0.3;
      }

      paddleX = Math.max(0, Math.min(W - paddleW, paddleX));

      // Update balls
      for (let bi = balls.length - 1; bi >= 0; bi--) {
        const ball = balls[bi];
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall collisions
        if (ball.x - BALL_R <= 0) {
          ball.x = BALL_R;
          ball.vx = Math.abs(ball.vx);
        }
        if (ball.x + BALL_R >= W) {
          ball.x = W - BALL_R;
          ball.vx = -Math.abs(ball.vx);
        }
        if (ball.y - BALL_R <= 0) {
          ball.y = BALL_R;
          ball.vy = Math.abs(ball.vy);
        }

        // Paddle collision
        if (ball.vy > 0 &&
            ball.y + BALL_R >= PADDLE_Y &&
            ball.y + BALL_R <= PADDLE_Y + PADDLE_H + 6 &&
            ball.x >= paddleX - 2 &&
            ball.x <= paddleX + paddleW + 2) {
          ball.y = PADDLE_Y - BALL_R;
          const hit = (ball.x - paddleX) / paddleW;
          const angle = -Math.PI * (0.15 + 0.7 * (1 - hit));
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          ball.vx = Math.cos(angle) * speed;
          ball.vy = Math.sin(angle) * speed;
          comboCount = 0;
        }

        // Ball falls below
        if (ball.y - BALL_R > H) {
          balls.splice(bi, 1);
          continue;
        }

        // Brick collisions
        for (let r = 0; r < BRICK_ROWS; r++) {
          for (let c = 0; c < BRICK_COLS; c++) {
            if (!bricks[r][c].alive) continue;
            const bx = 10 + c * BRICK_W + BRICK_PAD;
            const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
            const bw = BRICK_W - BRICK_PAD * 2;
            const bh = BRICK_H - BRICK_PAD * 2;

            if (ball.x + BALL_R > bx && ball.x - BALL_R < bx + bw &&
                ball.y + BALL_R > by && ball.y - BALL_R < by + bh) {

              if (strongTimer > 0) {
                // Power ball — plow through everything
                hitBrickStrong(r, c);
              } else {
                // Normal bounce
                const overlapLeft = (ball.x + BALL_R) - bx;
                const overlapRight = (bx + bw) - (ball.x - BALL_R);
                const overlapTop = (ball.y + BALL_R) - by;
                const overlapBottom = (by + bh) - (ball.y - BALL_R);
                const minOverlapX = Math.min(overlapLeft, overlapRight);
                const minOverlapY = Math.min(overlapTop, overlapBottom);

                if (minOverlapX < minOverlapY) {
                  ball.vx = -ball.vx;
                } else {
                  ball.vy = -ball.vy;
                }

                hitBrick(r, c);
                break;
              }
            }
          }
        }
      }

      // All balls lost
      if (balls.length === 0) {
        lives--;
        livesEl.textContent = lives;
        paddleW = PADDLE_BASE_W;
        hasLaser = false;
        laserTimer = 0;
        expandTimer = 0;
        strongTimer = 0;
        laserHintTimer = 0;
        if (lives <= 0) {
          gameState = 'over';
          if (score > best) best = score;
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'GAME OVER';
          overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
          return;
        }
        resetBall();
      }

      // Update power-ups
      for (let i = powerups.length - 1; i >= 0; i--) {
        powerups[i].y += POWERUP_SPEED;

        const pu = powerups[i];
        if (pu.y + POWERUP_H >= PADDLE_Y &&
            pu.y <= PADDLE_Y + PADDLE_H &&
            pu.x + POWERUP_W / 2 >= paddleX &&
            pu.x - POWERUP_W / 2 <= paddleX + paddleW) {
          activatePowerup(pu.type);
          spawnParticles(pu.x, pu.y, PU_COLORS[pu.type], 8);
          powerups.splice(i, 1);
          continue;
        }

        if (pu.y > H) {
          powerups.splice(i, 1);
        }
      }

      // Update lasers
      for (let i = lasers.length - 1; i >= 0; i--) {
        lasers[i].y -= LASER_SPEED;

        if (lasers[i].y < 0) {
          lasers.splice(i, 1);
          continue;
        }

        const laser = lasers[i];
        let hitSomething = false;
        for (let r = 0; r < BRICK_ROWS && !hitSomething; r++) {
          for (let c = 0; c < BRICK_COLS && !hitSomething; c++) {
            if (!bricks[r][c].alive) continue;
            const bx = 10 + c * BRICK_W + BRICK_PAD;
            const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
            const bw = BRICK_W - BRICK_PAD * 2;
            const bh = BRICK_H - BRICK_PAD * 2;

            if (laser.x >= bx && laser.x <= bx + bw &&
                laser.y >= by && laser.y <= by + bh) {
              hitBrick(r, c);
              lasers.splice(i, 1);
              hitSomething = true;
            }
          }
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.08;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Check level clear
      let allClear = true;
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (bricks[r][c].alive && bricks[r][c].type !== BRICK_METAL) {
            allClear = false;
            break;
          }
        }
        if (!allClear) break;
      }
      if (allClear) {
        level++;
        levelEl.textContent = level;
        score += 500 * level;
        scoreEl.textContent = score;
        initBricks(level);
        resetBall();
        powerups = [];
        lasers = [];
      }

      // Update game data for ML
      window.gameData = {
        paddleX: paddleX,
        paddleW: paddleW,
        balls: balls.map(b => ({ x: b.x, y: b.y, vx: b.vx, vy: b.vy })),
        lives: lives,
        level: level,
        hasLaser: hasLaser,
        hasStrong: strongTimer > 0,
        powerupsOnScreen: powerups.length,
        activeBricks: bricks.flat().filter(b => b.alive).length
      };
    }

    function hitBrick(r, c) {
      const brick = bricks[r][c];
      if (brick.type === BRICK_METAL) {
        const bx = 10 + c * BRICK_W + BRICK_W / 2;
        const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;
        spawnParticles(bx, by, '#888', 4);
        return;
      }

      brick.hits--;
      if (brick.hits <= 0) {
        brick.alive = false;
        const bx = 10 + c * BRICK_W + BRICK_W / 2;
        const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;
        const color = getBrickColor(r, brick.type);
        spawnParticles(bx, by, color, 10);
        maybeDropPowerup(bx, by);

        const now = Date.now();
        if (now - lastHitTime < 500) {
          comboCount++;
        } else {
          comboCount = 1;
        }
        lastHitTime = now;

        const basePoints = 10 + (BRICK_ROWS - r) * 5;
        const comboBonus = Math.min(comboCount, 10);
        score += basePoints * comboBonus;
      } else {
        const bx = 10 + c * BRICK_W + BRICK_W / 2;
        const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;
        spawnParticles(bx, by, '#ff8', 4);
      }

      scoreEl.textContent = score;
      if (score > best) {
        best = score;
      }
    }

    function hitBrickStrong(r, c) {
      const brick = bricks[r][c];
      brick.alive = false;
      const bx = 10 + c * BRICK_W + BRICK_W / 2;
      const by = BRICK_TOP + r * BRICK_H + BRICK_H / 2;
      const color = brick.type === BRICK_METAL ? '#fa0' : getBrickColor(r, brick.type);
      spawnParticles(bx, by, color, 12);
      if (brick.type !== BRICK_METAL) {
        maybeDropPowerup(bx, by);
      }

      const now = Date.now();
      if (now - lastHitTime < 500) {
        comboCount++;
      } else {
        comboCount = 1;
      }
      lastHitTime = now;

      const basePoints = brick.type === BRICK_METAL ? 100 : (10 + (BRICK_ROWS - r) * 5);
      const comboBonus = Math.min(comboCount, 10);
      score += basePoints * comboBonus;
      scoreEl.textContent = score;
      if (score > best) best = score;
    }

    function getBrickColor(row, type) {
      if (type === BRICK_TOUGH) return '#fff';
      if (type === BRICK_METAL) return '#888';
      return ROW_COLORS[row % ROW_COLORS.length];
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Subtle background grid
      ctx.strokeStyle = 'rgba(15, 52, 96, 0.3)';
      ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y < H; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Bricks — 3D beveled
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (!bricks[r][c].alive) continue;
          const brick = bricks[r][c];
          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;

          if (brick.type === BRICK_METAL) {
            // Metal brick — darker base with 3D detail
            ctx.fillStyle = '#556';
            ctx.fillRect(bx, by, bw, bh);
            // Top third lighter stripe
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.fillRect(bx + 2, by, bw - 4, bh / 3);
            // Specular highlight line
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx + 4, by + 2, bw - 8, 1);
            // Bevel edges
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx, by, bw, 2);
            ctx.fillRect(bx, by, 2, bh);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by + bh - 2, bw, 2);
            ctx.fillRect(bx + bw - 2, by, 2, bh);
            // Rivet dots at corners
            ctx.fillStyle = 'rgba(200, 200, 220, 0.5)';
            ctx.beginPath();
            ctx.arc(bx + 4, by + 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(bx + bw - 4, by + 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(bx + 4, by + bh - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(bx + bw - 4, by + bh - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (brick.type === BRICK_TOUGH) {
            const color = ROW_COLORS[r % ROW_COLORS.length];
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 6;
            ctx.fillRect(bx, by, bw, bh);
            ctx.shadowBlur = 0;
            // Bevel edges
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx, by, bw, 2);
            ctx.fillRect(bx, by, 2, bh);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by + bh - 2, bw, 2);
            ctx.fillRect(bx + bw - 2, by, 2, bh);
            // Inner shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx + 2, by + 2, bw - 4, 4);
            ctx.fillRect(bx + 2, by + 2, 4, bh - 4);
            // Crack line if damaged
            if (brick.hits === 1) {
              ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(bx + bw * 0.3, by);
              ctx.lineTo(bx + bw * 0.5, by + bh * 0.5);
              ctx.lineTo(bx + bw * 0.7, by + bh);
              ctx.stroke();
            }
          } else {
            const color = ROW_COLORS[r % ROW_COLORS.length];
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 6;
            ctx.fillRect(bx, by, bw, bh);
            ctx.shadowBlur = 0;
            // Bevel edges
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx, by, bw, 2);
            ctx.fillRect(bx, by, 2, bh);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx, by + bh - 2, bw, 2);
            ctx.fillRect(bx + bw - 2, by, 2, bh);
            // Inner face highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(bx + 2, by + 2, bw - 4, (bh - 4) / 2);
          }
        }
      }
      ctx.shadowBlur = 0;

      // Power-ups — rotating 3D capsules
      powerups.forEach(pu => {
        const puColor = PU_COLORS[pu.type];
        const phase = Math.sin(frameCount * 0.08 + pu.y * 0.1);
        const visibleW = POWERUP_W * Math.abs(phase);

        if (visibleW < 2) {
          // Edge-on: thin line
          ctx.fillStyle = puColor;
          ctx.fillRect(pu.x - 1, pu.y - POWERUP_H / 2, 2, POWERUP_H);
        } else {
          const px = pu.x - visibleW / 2;
          const py = pu.y - POWERUP_H / 2;
          const radius = Math.min(POWERUP_H / 2, visibleW / 2);

          ctx.fillStyle = puColor;
          ctx.shadowColor = puColor;
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(px + radius, py);
          ctx.lineTo(px + visibleW - radius, py);
          ctx.arc(px + visibleW - radius, py + POWERUP_H / 2, radius, -Math.PI / 2, Math.PI / 2);
          ctx.lineTo(px + radius, py + POWERUP_H);
          ctx.arc(px + radius, py + POWERUP_H / 2, radius, Math.PI / 2, -Math.PI / 2);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;

          // 3D highlight on top half
          if (phase > 0) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.fillRect(px + 2, py + 1, visibleW - 4, POWERUP_H / 3);
          }

          // Letter label — only visible when capsule > 50% width
          if (visibleW > POWERUP_W * 0.5) {
            const labelAlpha = (visibleW / POWERUP_W - 0.5) * 2;
            ctx.fillStyle = `rgba(26, 26, 46, ${labelAlpha})`;
            ctx.font = 'bold 10px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(PU_LABELS[pu.type], pu.x, pu.y);
          }
        }
      });

      // Lasers
      lasers.forEach(laser => {
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 8;
        ctx.fillRect(laser.x - LASER_W / 2, laser.y, LASER_W, LASER_H);
      });
      ctx.shadowBlur = 0;

      // Paddle
      const paddleColor = hasLaser ? '#f44' : '#4fb';
      ctx.fillStyle = paddleColor;
      ctx.shadowColor = paddleColor;
      ctx.shadowBlur = 14;
      const pr = PADDLE_H / 2;
      ctx.beginPath();
      ctx.moveTo(paddleX + pr, PADDLE_Y);
      ctx.lineTo(paddleX + paddleW - pr, PADDLE_Y);
      ctx.arc(paddleX + paddleW - pr, PADDLE_Y + pr, pr, -Math.PI / 2, Math.PI / 2);
      ctx.lineTo(paddleX + pr, PADDLE_Y + PADDLE_H);
      ctx.arc(paddleX + pr, PADDLE_Y + pr, pr, Math.PI / 2, -Math.PI / 2);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Laser cannons on paddle
      if (hasLaser) {
        ctx.fillStyle = '#f88';
        ctx.fillRect(paddleX + 4, PADDLE_Y - 4, 4, 6);
        ctx.fillRect(paddleX + paddleW - 8, PADDLE_Y - 4, 4, 6);
      }

      // Paddle highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.beginPath();
      ctx.moveTo(paddleX + pr + 4, PADDLE_Y + 2);
      ctx.lineTo(paddleX + paddleW - pr - 4, PADDLE_Y + 2);
      ctx.lineTo(paddleX + paddleW - pr - 4, PADDLE_Y + 4);
      ctx.lineTo(paddleX + pr + 4, PADDLE_Y + 4);
      ctx.closePath();
      ctx.fill();

      // Laser hint
      if (laserHintTimer > 0) {
        let alpha = 1;
        if (laserHintTimer < 30) alpha = laserHintTimer / 30;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#f44';
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText('PRESS SPACE TO FIRE', W / 2, PADDLE_Y - 20);
        ctx.globalAlpha = 1;
      }

      // Balls — glow gold when strong
      balls.forEach(ball => {
        if (strongTimer > 0) {
          ctx.fillStyle = '#fa0';
          ctx.shadowColor = '#fa0';
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, BALL_R + 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#4fb';
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        // Ball highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(ball.x - 1, ball.y - 1, BALL_R * 0.4, 0, Math.PI * 2);
        ctx.fill();
      });

      // Particles
      particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Lives indicator
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#4fb';
        ctx.shadowColor = '#4fb';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(W - 20 - i * 18, H - 15, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Power-up legend (bottom-right, above lives)
      ctx.font = '8px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.globalAlpha = 0.5;
      const legendX = W - 140;
      const legendY = H - 55;
      const legendItems = [
        { color: PU_COLORS[PU_EXPAND], letter: 'E', name: 'Expand' },
        { color: PU_COLORS[PU_LASER], letter: 'L', name: 'Laser' },
        { color: PU_COLORS[PU_MULTI], letter: 'M', name: 'Multi' },
        { color: PU_COLORS[PU_STRONG], letter: 'P', name: 'Power' },
        { color: PU_COLORS[PU_LIFE], letter: '+', name: 'Life' },
      ];
      legendItems.forEach((item, i) => {
        const ly = legendY + i * 10;
        ctx.fillStyle = item.color;
        ctx.beginPath();
        ctx.arc(legendX + 3, ly, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillText(item.letter + ' ' + item.name, legendX + 9, ly);
      });
      ctx.globalAlpha = 1;

      // Active power-up indicators
      let indicatorY = H - 12;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      let indicatorX = 10;
      if (expandTimer > 0) {
        ctx.fillStyle = PU_COLORS[PU_EXPAND];
        ctx.fillText('EXPAND ' + Math.ceil(expandTimer / 60) + 's', indicatorX, indicatorY);
        indicatorX += 80;
      }
      if (laserTimer > 0) {
        ctx.fillStyle = PU_COLORS[PU_LASER];
        ctx.fillText('LASER ' + Math.ceil(laserTimer / 60) + 's', indicatorX, indicatorY);
        indicatorX += 72;
      }
      if (strongTimer > 0) {
        ctx.fillStyle = PU_COLORS[PU_STRONG];
        ctx.fillText('POWER ' + Math.ceil(strongTimer / 60) + 's', indicatorX, indicatorY);
        indicatorX += 72;
      }

      // Combo indicator
      if (comboCount > 1 && Date.now() - lastHitTime < 1000) {
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('COMBO x' + comboCount, W / 2, BRICK_TOP - 10);
        ctx.shadowBlur = 0;
      }
    }

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ' && hasLaser) {
          lasers.push({ x: paddleX + 6, y: PADDLE_Y - 4 });
          lasers.push({ x: paddleX + paddleW - 6, y: PADDLE_Y - 4 });
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Mouse handler
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      useMouseControl = true;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing' && hasLaser) {
        lasers.push({ x: paddleX + 6, y: PADDLE_Y - 4 });
        lasers.push({ x: paddleX + paddleW - 6, y: PADDLE_Y - 4 });
      }
    });

    // Disable mouse control when keys are pressed for movement
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'a' || e.key === 'd') {
        useMouseControl = false;
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BurgerTime</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #e4a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 68, 170, 0.5); }
    h1 { color: #e4a; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e4a; }
    canvas {
      border: 2px solid #e4a;
      box-shadow: 0 0 20px rgba(238, 68, 170, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e4a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BURGERTIME</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Pepper: <span id="pepper">5</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">BURGERTIME</h2>
      <p id="overlayText">Arrows: Move/Climb | Space: Pepper<br>Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const pepperEl = document.getElementById('pepper');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ==========================================
    // CONSTANTS
    // ==========================================
    const TILE = 16;
    const COLS = W / TILE;  // 30
    const ROWS = H / TILE;  // 35

    // Platform rows (tile Y positions) - 6 horizontal floors
    const PLAT_ROWS = [4, 10, 16, 22, 28, 33];
    const PLAT_THICKNESS = 3; // pixels thick for drawing
    const NUM_FLOORS = PLAT_ROWS.length;

    // Ingredient dimensions
    const ING_W = 6;      // width in tiles
    const ING_H = 8;      // pixel height for drawing

    // Burger column X positions (in tiles)
    const BURGER_COLS = [1, 9, 17, 25];

    // Ladder X positions (in tiles) - between floors
    const LADDER_XS = [0, 5, 12, 19, 24, 29];
    const LADDER_W = 2; // tiles wide

    // Player
    const P_W = 14;
    const P_H = 28;
    const P_SPEED = 1.6;

    // ==========================================
    // GLOBAL STATE (recorder reads gameState and score)
    // ==========================================
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let pepperCount, lives, level;
    let player, enemies, ingredients, platYPixels;
    let keys = {};
    let pepperCloud, frameCount, invincibleTimer, levelCompleteTimer;

    // ==========================================
    // LEVEL GENERATION
    // ==========================================
    function buildLevel() {
      // Convert platform rows to pixel Y positions
      platYPixels = PLAT_ROWS.map(r => r * TILE);

      // Build ingredients: 4 burgers x 4 ingredient layers
      // Each ingredient sits on a platform (floors 0-3)
      // Floor 4 is where partial stacks accumulate, floor 5 is final catch tray
      ingredients = [];
      const types = ['bunTop', 'lettuce', 'patty', 'bunBottom'];

      for (let bi = 0; bi < BURGER_COLS.length; bi++) {
        for (let ti = 0; ti < types.length; ti++) {
          const floorIdx = ti; // bunTop on floor 0, lettuce on floor 1, etc.
          ingredients.push({
            type: types[ti],
            burgerIdx: bi,
            x: BURGER_COLS[bi] * TILE,
            y: platYPixels[floorIdx] - ING_H, // sit right on top of platform
            restY: platYPixels[floorIdx] - ING_H,
            w: ING_W * TILE,
            floorIdx: floorIdx,
            // Walk tracking: player must walk across entire width
            sections: new Array(ING_W).fill(false),
            sectionsWalked: 0,
            // Falling state
            falling: false,
            fallVel: 0,
            landed: false,
            // For stacking at bottom
            stackOrder: ti // 0=bunTop first to fall, 3=bunBottom last
          });
        }
      }

      // Player starts on floor 2, center
      player = {
        x: W / 2 - P_W / 2,
        y: platYPixels[2] - P_H,
        w: P_W,
        h: P_H,
        speed: P_SPEED,
        onLadder: false,
        dir: 1,
        frame: 0
      };

      // Enemies
      enemies = [];
      const numEnemies = Math.min(2 + level, 6);
      const enemyTypes = ['hotdog', 'pickle', 'egg'];
      for (let i = 0; i < numEnemies; i++) {
        const floor = 3 + (i % 2); // spawn on floors 3-4
        const side = i % 2 === 0;
        enemies.push({
          type: enemyTypes[i % 3],
          x: side ? TILE * 2 : W - TILE * 4,
          y: platYPixels[floor] - P_H,
          w: P_W,
          h: P_H,
          speed: 0.5 + level * 0.08,
          dir: side ? 1 : -1,
          onLadder: false,
          stunned: false,
          stunTimer: 0,
          alive: true,
          respawnTimer: 0,
          frame: 0,
          targetLadder: null,
          climbDir: 0 // 1=down, -1=up
        });
      }

      pepperCloud = null;
      invincibleTimer = 0;
      levelCompleteTimer = 0;
      frameCount = 0;
    }

    // ==========================================
    // PLATFORM & LADDER HELPERS
    // ==========================================
    function getFloorY(entity) {
      // Returns the floor pixel-Y the entity is standing on, or null
      const feetY = entity.y + entity.h;
      for (const py of platYPixels) {
        if (feetY >= py - 2 && feetY <= py + PLAT_THICKNESS + 2) {
          return py;
        }
      }
      return null;
    }

    function getFloorIndex(pixelY) {
      for (let i = 0; i < platYPixels.length; i++) {
        if (Math.abs(platYPixels[i] - pixelY) < 4) return i;
      }
      return -1;
    }

    function getLadderAt(cx, feetY) {
      // Check if center-x is over a ladder, and feetY is in range
      for (let li = 0; li < LADDER_XS.length; li++) {
        const lx = LADDER_XS[li] * TILE;
        const lw = LADDER_W * TILE;
        if (cx >= lx && cx <= lx + lw) {
          // Ladder exists between every adjacent pair of floors
          for (let fi = 0; fi < NUM_FLOORS - 1; fi++) {
            // Only place ladders based on pattern per level
            if (!ladderExists(li, fi)) continue;
            const top = platYPixels[fi];
            const bottom = platYPixels[fi + 1] + PLAT_THICKNESS;
            if (feetY >= top - 4 && feetY <= bottom + 4) {
              return { lx, top, bottom, lw, floorTop: fi, floorBot: fi + 1, ladderIdx: li };
            }
          }
        }
      }
      return null;
    }

    function ladderExists(ladderIdx, floorIdx) {
      // Vary ladder placement by level to add variety
      // Always have edge ladders and at least 3 per gap
      if (ladderIdx === 0 || ladderIdx === LADDER_XS.length - 1) return true;
      return ((ladderIdx + floorIdx + level) % 3) !== 0;
    }

    function snapToFloor(entity, floorPixelY) {
      entity.y = floorPixelY - entity.h;
      entity.onLadder = false;
    }

    // ==========================================
    // INIT / START / GAME OVER
    // ==========================================
    function init() {
      score = 0;
      pepperCount = 5;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      pepperEl.textContent = pepperCount;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BURGERTIME';
      overlayText.innerHTML = 'Arrows: Move/Climb &nbsp;|&nbsp; Space: Pepper<br>Press SPACE to start';
      buildLevel();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ==========================================
    // UPDATE
    // ==========================================
    function update() {
      frameCount++;

      if (levelCompleteTimer > 0) {
        levelCompleteTimer--;
        if (levelCompleteTimer === 0) {
          level++;
          pepperCount = Math.min(pepperCount + 2, 9);
          pepperEl.textContent = pepperCount;
          buildLevel();
        }
        return;
      }

      if (invincibleTimer > 0) invincibleTimer--;

      updatePlayer();
      updateIngredients();
      updateEnemies();
      updatePepper();
      checkCollisions();
      checkLevelComplete();

      window.gameData = {
        playerX: player.x, playerY: player.y,
        enemies: enemies.filter(e => e.alive).map(e => ({ x: e.x, y: e.y, type: e.type })),
        pepper: pepperCount, level: level, lives: lives
      };
    }

    function updatePlayer() {
      player.frame += 0.12;
      const floorY = getFloorY(player);

      if (player.onLadder) {
        // On a ladder: can only go up/down, or step off onto a platform
        if (keys['ArrowUp']) {
          player.y -= player.speed;
        }
        if (keys['ArrowDown']) {
          player.y += player.speed;
        }

        // Check if we've arrived at a floor
        const newFloor = getFloorY(player);
        if (newFloor !== null) {
          // If pressing left/right, or not pressing up/down, step off
          if (keys['ArrowLeft'] || keys['ArrowRight'] ||
              (!keys['ArrowUp'] && !keys['ArrowDown'])) {
            snapToFloor(player, newFloor);
          }
        }

        // Clamp to ladder bounds
        const ladder = getLadderAt(player.x + player.w / 2, player.y + player.h);
        if (!ladder) {
          // Fell off ladder somehow, find nearest floor
          const nearest = platYPixels.reduce((best, py) =>
            Math.abs(py - (player.y + player.h)) < Math.abs(best - (player.y + player.h)) ? py : best
          );
          snapToFloor(player, nearest);
        }
      } else {
        // On a platform: horizontal movement
        if (keys['ArrowLeft']) {
          player.x -= player.speed;
          player.dir = -1;
        }
        if (keys['ArrowRight']) {
          player.x += player.speed;
          player.dir = 1;
        }
        player.x = Math.max(0, Math.min(W - player.w, player.x));

        // Keep on floor
        if (floorY !== null) {
          snapToFloor(player, floorY);
        }

        // Try to climb up
        if (keys['ArrowUp'] && floorY !== null) {
          const ladder = getLadderAt(player.x + player.w / 2, player.y + player.h);
          if (ladder && getFloorIndex(floorY) > 0) {
            player.onLadder = true;
            player.x = ladder.lx + (ladder.lw - player.w) / 2;
          }
        }

        // Try to climb down
        if (keys['ArrowDown'] && floorY !== null) {
          const ladder = getLadderAt(player.x + player.w / 2, floorY + PLAT_THICKNESS + 2);
          if (ladder) {
            player.onLadder = true;
            player.x = ladder.lx + (ladder.lw - player.w) / 2;
            player.y += 4; // push below platform to start climbing
          }
        }

        // Gravity if somehow not on a floor
        if (floorY === null && !player.onLadder) {
          player.y += 3;
          const newFloor = getFloorY(player);
          if (newFloor !== null) snapToFloor(player, newFloor);
        }

        // Check ingredient walk
        if (floorY !== null) {
          checkIngredientWalk(floorY);
        }
      }

      player.y = Math.max(0, Math.min(H - player.h, player.y));
    }

    function checkIngredientWalk(floorY) {
      const floorIdx = getFloorIndex(floorY);
      if (floorIdx < 0) return;

      for (const ing of ingredients) {
        if (ing.landed || ing.falling) continue;
        if (ing.floorIdx !== floorIdx) continue;

        // Is player overlapping this ingredient horizontally?
        if (player.x + player.w > ing.x + 2 && player.x < ing.x + ing.w - 2) {
          const playerCenter = player.x + player.w / 2;
          const secIdx = Math.floor((playerCenter - ing.x) / TILE);
          if (secIdx >= 0 && secIdx < ING_W && !ing.sections[secIdx]) {
            ing.sections[secIdx] = true;
            ing.sectionsWalked++;

            // All sections walked? Drop it!
            if (ing.sectionsWalked >= ING_W) {
              dropIngredient(ing);
            }
          }
        }
      }
    }

    function dropIngredient(ing) {
      if (ing.falling || ing.landed) return;
      ing.falling = true;
      ing.fallVel = 0;
      ing.sections = new Array(ING_W).fill(false);
      ing.sectionsWalked = 0;

      addScore(50);

      // Squash enemies standing on this ingredient
      for (const e of enemies) {
        if (!e.alive || e.stunned) continue;
        if (e.x + e.w > ing.x && e.x < ing.x + ing.w &&
            Math.abs((e.y + e.h) - (ing.y + ING_H)) < TILE * 2) {
          e.alive = false;
          e.respawnTimer = 240 + Math.random() * 120;
          addScore(300);
        }
      }
    }

    function updateIngredients() {
      for (const ing of ingredients) {
        if (!ing.falling || ing.landed) continue;

        ing.fallVel = Math.min(ing.fallVel + 0.15, 4);
        ing.y += ing.fallVel;

        // Check if reached next floor below
        const nextFloorIdx = ing.floorIdx + 1;
        if (nextFloorIdx < NUM_FLOORS) {
          const nextFloorY = platYPixels[nextFloorIdx] - ING_H;

          if (ing.y >= nextFloorY) {
            ing.y = nextFloorY;
            ing.floorIdx = nextFloorIdx;
            ing.falling = false;
            ing.fallVel = 0;
            ing.restY = nextFloorY;

            // Check if this is the bottom floor
            if (nextFloorIdx >= NUM_FLOORS - 1) {
              ing.landed = true;
              addScore(100);
            }

            // Cascade: push any same-burger ingredient already on this floor down
            for (const other of ingredients) {
              if (other === ing) continue;
              if (other.burgerIdx !== ing.burgerIdx) continue;
              if (other.landed || other.falling) continue;
              if (other.floorIdx === ing.floorIdx) {
                dropIngredient(other);
              }
            }

            // Also squash enemies on the landing platform
            for (const e of enemies) {
              if (!e.alive || e.stunned) continue;
              if (e.x + e.w > ing.x && e.x < ing.x + ing.w) {
                const eFloor = getFloorY(e);
                if (eFloor !== null && getFloorIndex(eFloor) === nextFloorIdx) {
                  e.alive = false;
                  e.respawnTimer = 240 + Math.random() * 120;
                  addScore(200);
                }
              }
            }
          }
        } else {
          // Past last floor - land at bottom
          ing.y = platYPixels[NUM_FLOORS - 1] - ING_H;
          ing.floorIdx = NUM_FLOORS - 1;
          ing.landed = true;
          ing.falling = false;
          addScore(100);
        }
      }
    }

    function updateEnemies() {
      for (const e of enemies) {
        if (!e.alive) {
          e.respawnTimer--;
          if (e.respawnTimer <= 0) {
            e.alive = true;
            e.stunned = false;
            // Respawn at a random edge on floor 3 or 4
            const fi = 3 + Math.floor(Math.random() * 2);
            e.y = platYPixels[fi] - e.h;
            e.x = Math.random() > 0.5 ? TILE : W - TILE * 3;
            e.dir = e.x < W / 2 ? 1 : -1;
            e.onLadder = false;
          }
          continue;
        }

        if (e.stunned) {
          e.stunTimer--;
          if (e.stunTimer <= 0) e.stunned = false;
          continue;
        }

        e.frame += 0.08;

        // AI: move toward player
        const dx = player.x - e.x;
        const dy = player.y - e.y;

        if (e.onLadder) {
          // Climb in the chosen direction
          e.y += e.climbDir * e.speed;

          // Check if reached a floor
          const floorY = getFloorY(e);
          if (floorY !== null) {
            const fi = getFloorIndex(floorY);
            // Get off ladder if we're closer to player's floor now, or random chance
            const playerFloor = getFloorY(player);
            const pfi = playerFloor !== null ? getFloorIndex(playerFloor) : -1;
            if (fi === pfi || Math.random() < 0.03) {
              snapToFloor(e, floorY);
              e.targetLadder = null;
            }
          }

          // Safety: don't climb off screen
          if (e.y < platYPixels[0] - e.h - 10 || e.y + e.h > platYPixels[NUM_FLOORS - 1] + 20) {
            const nearest = platYPixels.reduce((b, py) =>
              Math.abs(py - (e.y + e.h)) < Math.abs(b - (e.y + e.h)) ? py : b
            );
            snapToFloor(e, nearest);
          }
        } else {
          // On platform
          const floorY = getFloorY(e);
          if (floorY !== null) {
            snapToFloor(e, floorY);

            // Walk toward player horizontally
            if (Math.abs(dx) > 4) {
              e.x += (dx > 0 ? 1 : -1) * e.speed;
              e.dir = dx > 0 ? 1 : -1;
            }

            // Consider using a ladder
            if (Math.abs(dy) > TILE * 3 && Math.random() < 0.02) {
              const climbDir = dy < 0 ? -1 : 1; // -1 = up, 1 = down
              const ladder = getLadderAt(e.x + e.w / 2, e.y + e.h);
              if (ladder) {
                e.onLadder = true;
                e.climbDir = climbDir;
                e.x = ladder.lx + (ladder.lw - e.w) / 2;
              } else {
                // Walk toward nearest usable ladder
                let bestLadder = null, bestDist = Infinity;
                for (let li = 0; li < LADDER_XS.length; li++) {
                  const fi = getFloorIndex(floorY);
                  const checkFi = climbDir < 0 ? fi - 1 : fi;
                  if (checkFi >= 0 && checkFi < NUM_FLOORS - 1 && ladderExists(li, checkFi)) {
                    const lx = LADDER_XS[li] * TILE + LADDER_W * TILE / 2;
                    const d = Math.abs(e.x + e.w / 2 - lx);
                    if (d < bestDist) { bestDist = d; bestLadder = lx; }
                  }
                }
                if (bestLadder !== null) {
                  e.x += (bestLadder > e.x + e.w / 2 ? 1 : -1) * e.speed;
                }
              }
            }
          } else {
            // Gravity
            e.y += 3;
            const newFloor = getFloorY(e);
            if (newFloor !== null) snapToFloor(e, newFloor);
          }
        }

        e.x = Math.max(0, Math.min(W - e.w, e.x));
        e.y = Math.max(0, Math.min(H - e.h, e.y));
      }
    }

    function updatePepper() {
      if (!pepperCloud) return;
      pepperCloud.timer--;
      pepperCloud.x += pepperCloud.dir * 4;

      if (pepperCloud.timer <= 0) {
        pepperCloud = null;
        return;
      }

      for (const e of enemies) {
        if (!e.alive || e.stunned) continue;
        if (Math.abs(e.x + e.w / 2 - pepperCloud.x) < TILE * 2.5 &&
            Math.abs(e.y + e.h / 2 - pepperCloud.y) < TILE * 2.5) {
          e.stunned = true;
          e.stunTimer = 150;
          addScore(100);
        }
      }
    }

    function checkCollisions() {
      if (invincibleTimer > 0) return;
      for (const e of enemies) {
        if (!e.alive || e.stunned) continue;
        if (player.x < e.x + e.w && player.x + player.w > e.x &&
            player.y < e.y + e.h && player.y + player.h > e.y) {
          lives--;
          if (lives <= 0) { gameOver(); return; }
          // Respawn player on floor 2
          player.x = W / 2 - P_W / 2;
          player.y = platYPixels[2] - P_H;
          player.onLadder = false;
          invincibleTimer = 120;
        }
      }
    }

    function checkLevelComplete() {
      if (levelCompleteTimer > 0) return;
      const allLanded = ingredients.every(ing => ing.landed);
      if (allLanded) {
        levelCompleteTimer = 90;
        addScore(1000 * level);
      }
    }

    function throwPepper() {
      if (pepperCount <= 0 || pepperCloud) return;
      pepperCount--;
      pepperEl.textContent = pepperCount;
      pepperCloud = {
        x: player.x + player.w / 2 + player.dir * TILE,
        y: player.y + player.h / 2,
        dir: player.dir,
        timer: 25
      };
    }

    function addScore(pts) {
      score += pts;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    // ==========================================
    // DRAWING
    // ==========================================
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawLadders();
      drawPlatforms();
      drawIngredients();
      drawPlayer();
      drawEnemies();
      drawPepperCloud();
      drawHUD();
    }

    function drawPlatforms() {
      for (const py of platYPixels) {
        // Main platform line
        ctx.fillStyle = '#3a6a3a';
        ctx.shadowColor = '#4a8a4a';
        ctx.shadowBlur = 3;
        ctx.fillRect(0, py, W, PLAT_THICKNESS);
        ctx.shadowBlur = 0;

        // Brick details
        ctx.fillStyle = '#2a5a2a';
        for (let bx = 0; bx < W; bx += TILE) {
          ctx.fillRect(bx, py, 1, PLAT_THICKNESS);
        }
        // Top highlight
        ctx.fillStyle = '#5aaa5a';
        ctx.fillRect(0, py, W, 1);
      }
    }

    function drawLadders() {
      for (let li = 0; li < LADDER_XS.length; li++) {
        const lx = LADDER_XS[li] * TILE;
        const lw = LADDER_W * TILE;

        for (let fi = 0; fi < NUM_FLOORS - 1; fi++) {
          if (!ladderExists(li, fi)) continue;
          const top = platYPixels[fi];
          const bottom = platYPixels[fi + 1] + PLAT_THICKNESS;
          const lh = bottom - top;

          // Rails
          ctx.fillStyle = '#5a4a3a';
          ctx.fillRect(lx + 2, top, 2, lh);
          ctx.fillRect(lx + lw - 4, top, 2, lh);

          // Rungs
          ctx.fillStyle = '#8a7a6a';
          for (let ry = top + 8; ry < bottom - 4; ry += 10) {
            ctx.fillRect(lx + 4, ry, lw - 8, 2);
          }
        }
      }
    }

    function drawIngredients() {
      for (const ing of ingredients) {
        const ix = ing.x;
        const iy = ing.y;
        const iw = ing.w;

        // Drop shadow hint (where it's headed)
        if (!ing.landed && !ing.falling) {
          const progress = ing.sectionsWalked / ING_W;
          if (progress > 0) {
            ctx.fillStyle = `rgba(238, 68, 170, ${progress * 0.15})`;
            ctx.fillRect(ix, iy + ING_H + 2, iw, 2);
          }
        }

        ctx.shadowBlur = 4;

        switch (ing.type) {
          case 'bunTop':
            ctx.fillStyle = '#d4a030';
            ctx.shadowColor = '#d4a030';
            // Rounded dome
            ctx.beginPath();
            ctx.moveTo(ix + 2, iy + ING_H);
            ctx.quadraticCurveTo(ix + 2, iy, ix + iw / 2, iy);
            ctx.quadraticCurveTo(ix + iw - 2, iy, ix + iw - 2, iy + ING_H);
            ctx.closePath();
            ctx.fill();
            // Sesame seeds
            ctx.fillStyle = '#f0e0a0';
            ctx.fillRect(ix + iw * 0.25, iy + 2, 3, 2);
            ctx.fillRect(ix + iw * 0.5, iy + 1, 3, 2);
            ctx.fillRect(ix + iw * 0.75, iy + 3, 3, 2);
            break;

          case 'lettuce':
            ctx.fillStyle = '#30c040';
            ctx.shadowColor = '#30c040';
            ctx.beginPath();
            ctx.moveTo(ix, iy + ING_H);
            for (let wx = 0; wx <= iw; wx += 6) {
              ctx.lineTo(ix + wx, iy + (wx % 12 < 6 ? 1 : ING_H * 0.6));
            }
            ctx.lineTo(ix + iw, iy + ING_H);
            ctx.closePath();
            ctx.fill();
            break;

          case 'patty':
            ctx.fillStyle = '#8b4513';
            ctx.shadowColor = '#c06020';
            ctx.fillRect(ix + 2, iy + 1, iw - 4, ING_H - 2);
            // Grill marks
            ctx.fillStyle = '#5a2a08';
            for (let gx = ix + 8; gx < ix + iw - 8; gx += 14) {
              ctx.fillRect(gx, iy + 3, 8, 1);
              ctx.fillRect(gx + 2, iy + 6, 8, 1);
            }
            break;

          case 'bunBottom':
            ctx.fillStyle = '#c89020';
            ctx.shadowColor = '#c89020';
            ctx.fillRect(ix + 2, iy, iw - 4, ING_H);
            // Bottom curve
            ctx.fillStyle = '#b08018';
            ctx.fillRect(ix + 4, iy + ING_H - 2, iw - 8, 2);
            break;
        }
        ctx.shadowBlur = 0;

        // Walk progress overlay
        if (!ing.falling && !ing.landed && ing.sectionsWalked > 0) {
          for (let s = 0; s < ING_W; s++) {
            if (ing.sections[s]) {
              ctx.fillStyle = 'rgba(255, 255, 100, 0.25)';
              ctx.fillRect(ix + s * TILE, iy, TILE, ING_H);
            }
          }
        }

        // Landed glow
        if (ing.landed) {
          ctx.strokeStyle = 'rgba(238, 68, 170, 0.3)';
          ctx.lineWidth = 1;
          ctx.strokeRect(ix, iy, iw, ING_H);
        }
      }
    }

    function drawPlayer() {
      if (invincibleTimer > 0 && frameCount % 8 < 4) return;

      const px = player.x;
      const py = player.y;

      ctx.shadowColor = '#e4a';
      ctx.shadowBlur = 8;

      // Hat
      ctx.fillStyle = '#fff';
      ctx.fillRect(px, py, P_W, 5);
      ctx.fillRect(px + 2, py - 4, P_W - 4, 5);

      // Head
      ctx.fillStyle = '#ffcc88';
      ctx.fillRect(px + 1, py + 5, P_W - 2, 7);

      // Eyes
      ctx.fillStyle = '#222';
      if (player.dir > 0) {
        ctx.fillRect(px + 7, py + 7, 2, 2);
        ctx.fillRect(px + 11, py + 7, 2, 2);
      } else {
        ctx.fillRect(px + 1, py + 7, 2, 2);
        ctx.fillRect(px + 5, py + 7, 2, 2);
      }

      // Body (white chef coat)
      ctx.fillStyle = '#fff';
      ctx.fillRect(px + 1, py + 12, P_W - 2, 9);

      // Arms
      const arm = Math.sin(player.frame * 3) * 2;
      ctx.fillStyle = '#ffcc88';
      ctx.fillRect(px - 3, py + 14 + arm, 4, 5);
      ctx.fillRect(px + P_W - 1, py + 14 - arm, 4, 5);

      // Legs
      const leg = Math.sin(player.frame * 3) * 2;
      ctx.fillStyle = '#338';
      ctx.fillRect(px + 2, py + 21, 4, 7 + leg);
      ctx.fillRect(px + P_W - 6, py + 21, 4, 7 - leg);

      ctx.shadowBlur = 0;
    }

    function drawEnemies() {
      for (const e of enemies) {
        if (!e.alive) continue;

        const ex = e.x, ey = e.y;

        if (e.stunned) {
          // Stun stars
          ctx.fillStyle = '#ff0';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          const starY = ey - 4 + Math.sin(frameCount * 0.3) * 3;
          ctx.fillText('*  *', ex + e.w / 2, starY);
        }

        let bodyCol, detailCol;
        switch (e.type) {
          case 'hotdog':
            bodyCol = '#d44';
            detailCol = '#f88';
            break;
          case 'pickle':
            bodyCol = '#4a4';
            detailCol = '#8d8';
            break;
          case 'egg':
            bodyCol = '#ee8';
            detailCol = '#fff';
            break;
        }

        const alpha = e.stunned ? 0.5 : 1;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = bodyCol;
        ctx.shadowBlur = 5;

        // Body
        ctx.fillStyle = bodyCol;
        ctx.beginPath();
        ctx.ellipse(ex + e.w / 2, ey + e.h * 0.4, e.w / 2 + 2, e.h * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Detail
        ctx.fillStyle = detailCol;
        if (e.type === 'hotdog') {
          ctx.fillRect(ex + 3, ey + e.h * 0.3, e.w - 6, 2);
        } else if (e.type === 'pickle') {
          for (let pi = 0; pi < 3; pi++) {
            ctx.fillRect(ex + 3 + pi * 4, ey + 4 + pi * 3, 2, 2);
          }
        } else {
          // Yolk
          ctx.fillStyle = '#f80';
          ctx.beginPath();
          ctx.arc(ex + e.w / 2, ey + e.h * 0.35, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(ex + 3, ey + 6, 3, 3);
        ctx.fillRect(ex + e.w - 6, ey + 6, 3, 3);
        ctx.fillStyle = '#000';
        const po = e.dir > 0 ? 1 : 0;
        ctx.fillRect(ex + 3 + po, ey + 7, 2, 2);
        ctx.fillRect(ex + e.w - 6 + po, ey + 7, 2, 2);

        // Feet
        const legA = Math.sin(e.frame * 3) * 2;
        ctx.fillStyle = bodyCol;
        ctx.fillRect(ex + 2, ey + e.h - 6, 4, 6 + legA);
        ctx.fillRect(ex + e.w - 6, ey + e.h - 6, 4, 6 - legA);

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }
    }

    function drawPepperCloud() {
      if (!pepperCloud) return;

      ctx.fillStyle = 'rgba(255, 200, 50, 0.7)';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 12;

      for (let i = 0; i < 6; i++) {
        const a = frameCount * 0.3 + i * Math.PI / 3;
        const r = 6 + Math.sin(a * 2) * 3;
        ctx.beginPath();
        ctx.arc(pepperCloud.x + Math.cos(a) * r, pepperCloud.y + Math.sin(a) * r, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ff0';
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('PEPPER!', pepperCloud.x, pepperCloud.y - 12);
    }

    function drawHUD() {
      // Lives
      ctx.fillStyle = '#e4a';
      ctx.shadowColor = '#e4a';
      ctx.shadowBlur = 4;
      ctx.font = '13px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Lives: ' + '\u2665'.repeat(Math.max(0, lives)), 6, H - 6);

      // Level
      ctx.textAlign = 'right';
      ctx.fillText('Lv ' + level, W - 6, H - 6);
      ctx.shadowBlur = 0;

      // Level complete banner
      if (levelCompleteTimer > 0) {
        const pulse = 0.7 + 0.3 * Math.sin(frameCount * 0.15);
        ctx.fillStyle = `rgba(238, 68, 170, ${pulse})`;
        ctx.shadowColor = '#e4a';
        ctx.shadowBlur = 25;
        ctx.font = 'bold 26px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', W / 2, H / 2 - 10);
        ctx.font = '14px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText(`+${1000 * level} pts`, W / 2, H / 2 + 14);
        ctx.shadowBlur = 0;
      }
    }

    // ==========================================
    // INPUT
    // ==========================================
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
        if (e.key === ' ') throwPepper();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dungeon Tactician</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #a64; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 102, 68, 0.4); }
    h1 { color: #a64; font-size: 1.6rem; text-shadow: 0 0 15px rgba(170, 102, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #a64; }
    .info-bar {
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
      color: #aaa;
      display: flex;
      justify-content: space-between;
    }
    .info-bar .phase { color: #a64; font-weight: bold; }
    .info-bar .budget { color: #fc6; }
    canvas {
      border: 2px solid #a64;
      box-shadow: 0 0 20px rgba(170, 102, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a64;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(170, 102, 68, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-bottom: 6px; }
    .overlay .highlight { color: #fc6; }
    .toolbar {
      width: 600px;
      margin-top: 8px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .toolbar button {
      background: #2a2a4e;
      color: #e0e0e0;
      border: 1px solid #a64;
      padding: 5px 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 3px;
    }
    .toolbar button:hover { background: #3a3a5e; }
    .toolbar button.active { background: #a64; color: #fff; }
    .toolbar button:disabled { opacity: 0.4; cursor: default; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DUNGEON TACTICIAN</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="playerScore">0</span></div>
    <div>Round: <span id="roundNum">1</span>/3</div>
    <div>AI: <span id="aiScore">0</span></div>
  </div>
  <div class="info-bar">
    <span class="phase" id="phaseText">BUILD PHASE</span>
    <span id="infoText">Place traps and monsters</span>
    <span class="budget" id="budgetText">Budget: 10</span>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">DUNGEON TACTICIAN</h2>
      <p id="overlayText">Build dungeons. Raid dungeons.</p>
      <p class="highlight" id="overlaySubText">Click to start</p>
    </div>
  </div>
  <div class="toolbar" id="toolbar"></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const playerScoreEl = document.getElementById('playerScore');
    const aiScoreEl = document.getElementById('aiScore');
    const roundNumEl = document.getElementById('roundNum');
    const phaseTextEl = document.getElementById('phaseText');
    const infoTextEl = document.getElementById('infoText');
    const budgetTextEl = document.getElementById('budgetText');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlaySubText = document.getElementById('overlaySubText');
    const toolbarEl = document.getElementById('toolbar');

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ---- CONSTANTS ----
    const COLS = 10, ROWS = 10;
    const CELL = 42;
    const GRID_X = 30, GRID_Y = 30;
    const SIDEBAR_X = GRID_X + COLS * CELL + 20;

    const TRAP_SPIKE = 'spike';
    const TRAP_PIT = 'pit';
    const TRAP_ARROW = 'arrow';
    const MON_GOBLIN = 'goblin';
    const MON_SKELETON = 'skeleton';
    const MON_DRAGON = 'dragon';
    const WALL = 'wall';
    const TREASURE = 'treasure';
    const ENTRANCE = 'entrance';

    const PLACEMENT_COSTS = {
      [WALL]: 1, [TRAP_SPIKE]: 2, [TRAP_PIT]: 2, [TRAP_ARROW]: 3,
      [MON_GOBLIN]: 2, [MON_SKELETON]: 3, [MON_DRAGON]: 5
    };

    const TRAP_DAMAGE = { [TRAP_SPIKE]: 3, [TRAP_PIT]: 5, [TRAP_ARROW]: 4 };
    const MON_HP = { [MON_GOBLIN]: 4, [MON_SKELETON]: 6, [MON_DRAGON]: 12 };
    const MON_ATK = { [MON_GOBLIN]: 2, [MON_SKELETON]: 3, [MON_DRAGON]: 6 };

    const HERO_WARRIOR = 'warrior';
    const HERO_MAGE = 'mage';
    const HERO_ROGUE = 'rogue';
    const HERO_STATS = {
      [HERO_WARRIOR]: { hp: 15, atk: 4, range: 1, icon: 'W', color: '#48f', ability: 'Tank: takes reduced damage' },
      [HERO_MAGE]:    { hp: 8,  atk: 6, range: 3, icon: 'M', color: '#c4f', ability: 'Ranged: attacks from distance' },
      [HERO_ROGUE]:   { hp: 10, atk: 3, range: 1, icon: 'R', color: '#4f8', ability: 'Disarms traps automatically' }
    };

    const BUILD_BUDGET = 15;

    // ---- GAME STATE ----
    let gameState = 'waiting';
    let score = 0;
    let grid = [];
    let round = 1;
    let playerScore = 0;
    let aiScore = 0;
    let phase = 'build'; // 'build' or 'raid'
    let playerRole = 'builder'; // 'builder' or 'raider'
    let selectedTool = null;
    let budget = BUILD_BUDGET;
    let heroes = [];
    let selectedHero = null;
    let heroesKilled = 0;
    let treasureReached = false;
    let fogOfWar = [];
    let animQueue = [];
    let animating = false;
    let turnLog = [];
    let monsterHPs = {};
    let raidTurn = 0;
    let raidComplete = false;
    let aiThinking = false;
    let showAllForBuilder = true;

    // ---- ICONS ----
    const ICONS = {
      [WALL]:        { ch: '#', color: '#666' },
      [TRAP_SPIKE]:  { ch: '\u25B2', color: '#f44' },
      [TRAP_PIT]:    { ch: 'O', color: '#840' },
      [TRAP_ARROW]:  { ch: '\u2192', color: '#f84' },
      [MON_GOBLIN]:  { ch: 'g', color: '#4a4' },
      [MON_SKELETON]:{ ch: 's', color: '#aaa' },
      [MON_DRAGON]:  { ch: 'D', color: '#f44' },
      [TREASURE]:    { ch: '\u2666', color: '#fc4' },
      [ENTRANCE]:    { ch: '\u25A1', color: '#4af' }
    };

    // ---- INIT ----
    function init() {
      gameState = 'waiting';
      round = 1;
      playerScore = 0;
      aiScore = 0;
      playerRole = 'builder';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DUNGEON TACTICIAN';
      overlayText.textContent = 'Build dungeons. Raid dungeons. Outsmart the AI.';
      overlaySubText.textContent = 'Click to start';
      updateScoreboard();
      clearToolbar();
      draw();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startRound();
    }

    function startRound() {
      roundNumEl.textContent = round;
      resetGrid();
      heroesKilled = 0;
      treasureReached = false;
      raidComplete = false;
      raidTurn = 0;

      if (playerRole === 'builder') {
        startBuildPhase(true);
      } else {
        startAIBuildPhase();
      }
    }

    function resetGrid() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = { type: 'empty', revealed: false };
        }
      }
      // Place entrance (top-left) and treasure (bottom-right)
      grid[0][0] = { type: ENTRANCE, revealed: true };
      grid[ROWS-1][COLS-1] = { type: TREASURE, revealed: false };
      fogOfWar = [];
      for (let r = 0; r < ROWS; r++) {
        fogOfWar[r] = [];
        for (let c = 0; c < COLS; c++) {
          fogOfWar[r][c] = false;
        }
      }
    }

    // ---- BUILD PHASE (Human) ----
    function startBuildPhase(isHuman) {
      phase = 'build';
      budget = BUILD_BUDGET;
      selectedTool = null;
      showAllForBuilder = true;
      phaseTextEl.textContent = 'BUILD PHASE (You)';
      infoTextEl.textContent = 'Place traps, monsters, walls';
      budgetTextEl.textContent = 'Budget: ' + budget;
      buildToolbar();
      draw();
    }

    function buildToolbar() {
      clearToolbar();
      const items = [
        { id: WALL, label: 'Wall (1)', cost: 1 },
        { id: TRAP_SPIKE, label: 'Spike (2)', cost: 2 },
        { id: TRAP_PIT, label: 'Pit (2)', cost: 2 },
        { id: TRAP_ARROW, label: 'Arrow (3)', cost: 3 },
        { id: MON_GOBLIN, label: 'Goblin (2)', cost: 2 },
        { id: MON_SKELETON, label: 'Skeleton (3)', cost: 3 },
        { id: MON_DRAGON, label: 'Dragon (5)', cost: 5 },
      ];
      items.forEach(it => {
        const btn = document.createElement('button');
        btn.textContent = it.label;
        btn.id = 'btn-' + it.id;
        btn.onclick = () => selectTool(it.id);
        if (it.cost > budget) btn.disabled = true;
        toolbarEl.appendChild(btn);
      });
      // Done button
      const doneBtn = document.createElement('button');
      doneBtn.textContent = 'DONE \u2713';
      doneBtn.style.background = '#a64';
      doneBtn.style.color = '#fff';
      doneBtn.onclick = finishBuildPhase;
      toolbarEl.appendChild(doneBtn);
      // Erase button
      const eraseBtn = document.createElement('button');
      eraseBtn.textContent = 'Erase';
      eraseBtn.id = 'btn-erase';
      eraseBtn.onclick = () => selectTool('erase');
      toolbarEl.appendChild(eraseBtn);
    }

    function selectTool(tool) {
      selectedTool = tool;
      toolbarEl.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      const btn = document.getElementById('btn-' + tool);
      if (btn) btn.classList.add('active');
    }

    function clearToolbar() {
      toolbarEl.innerHTML = '';
    }

    function finishBuildPhase() {
      clearToolbar();
      if (playerRole === 'builder') {
        startAIRaidPhase();
      } else {
        startRaidPhase(true);
      }
    }

    // ---- BUILD PHASE (AI) ----
    function startAIBuildPhase() {
      phase = 'build';
      budget = BUILD_BUDGET;
      showAllForBuilder = false;
      phaseTextEl.textContent = 'BUILD PHASE (AI)';
      infoTextEl.textContent = 'AI is building the dungeon...';
      budgetTextEl.textContent = '';
      clearToolbar();
      draw();

      setTimeout(() => {
        aiBuildDungeon();
        if (playerRole === 'raider') {
          startRaidPhase(true);
        } else {
          startAIRaidPhase();
        }
      }, 800);
    }

    function aiBuildDungeon() {
      // AI strategy: place things near treasure path
      let remaining = BUILD_BUDGET;
      const treasureR = ROWS - 1, treasureC = COLS - 1;

      // Score cells by proximity to treasure and paths
      let cells = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c].type !== 'empty') continue;
          const dist = Math.abs(r - treasureR) + Math.abs(c - treasureC);
          const distToEntrance = r + c;
          // Prefer cells on the diagonal path, near treasure but not blocking completely
          const score = 20 - dist + Math.min(distToEntrance, 5);
          cells.push({ r, c, score: score + Math.random() * 4 });
        }
      }
      cells.sort((a, b) => b.score - a.score);

      // Place a dragon near treasure if budget allows
      if (remaining >= 5) {
        const dragonCells = cells.filter(c =>
          Math.abs(c.r - treasureR) + Math.abs(c.c - treasureC) <= 3 &&
          Math.abs(c.r - treasureR) + Math.abs(c.c - treasureC) >= 1
        );
        if (dragonCells.length > 0) {
          const dc = dragonCells[0];
          grid[dc.r][dc.c] = { type: MON_DRAGON, revealed: false };
          remaining -= 5;
          cells = cells.filter(c => c.r !== dc.r || c.c !== dc.c);
        }
      }

      // Place skeletons
      while (remaining >= 3) {
        const monCells = cells.filter(c => {
          const d = Math.abs(c.r - treasureR) + Math.abs(c.c - treasureC);
          return d >= 2 && d <= 7;
        });
        if (monCells.length === 0) break;
        const mc = monCells[0];
        grid[mc.r][mc.c] = { type: MON_SKELETON, revealed: false };
        remaining -= 3;
        cells = cells.filter(c => c.r !== mc.r || c.c !== mc.c);
        if (remaining < 2) break;
        // Also place some traps
        if (remaining >= 2) {
          const trapCells = cells.filter(c => {
            const d = Math.abs(c.r - treasureR) + Math.abs(c.c - treasureC);
            return d >= 1 && d <= 5;
          });
          if (trapCells.length > 0) {
            const tc = trapCells[0];
            const trapType = [TRAP_SPIKE, TRAP_PIT, TRAP_ARROW][Math.floor(Math.random() * 3)];
            const cost = PLACEMENT_COSTS[trapType];
            if (remaining >= cost) {
              grid[tc.r][tc.c] = { type: trapType, revealed: false };
              remaining -= cost;
              cells = cells.filter(c => c.r !== tc.r || c.c !== tc.c);
            }
          }
        }
      }

      // Spend remaining on walls or goblins
      while (remaining >= 1 && cells.length > 0) {
        const wc = cells.shift();
        if (remaining >= 2 && Math.random() < 0.4) {
          grid[wc.r][wc.c] = { type: MON_GOBLIN, revealed: false };
          remaining -= 2;
        } else {
          grid[wc.r][wc.c] = { type: WALL, revealed: false };
          remaining -= 1;
        }
      }

      // Ensure there's a path from entrance to treasure
      ensurePath();
    }

    function ensurePath() {
      // BFS to check path exists
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const queue = [{r: 0, c: 0}];
      visited[0][0] = true;
      while (queue.length > 0) {
        const {r, c} = queue.shift();
        if (r === ROWS-1 && c === COLS-1) return; // path exists
        for (const [dr, dc] of [[0,1],[0,-1],[1,0],[-1,0]]) {
          const nr = r+dr, nc = c+dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc] && grid[nr][nc].type !== WALL) {
            visited[nr][nc] = true;
            queue.push({r: nr, c: nc});
          }
        }
      }
      // No path! Remove walls along a random path
      let r = 0, c = 0;
      while (r < ROWS-1 || c < COLS-1) {
        if (grid[r][c].type === WALL) grid[r][c] = { type: 'empty', revealed: false };
        if (r < ROWS-1 && c < COLS-1) {
          if (Math.random() < 0.5) r++; else c++;
        } else if (r < ROWS-1) r++;
        else c++;
      }
    }

    // ---- RAID PHASE (Human) ----
    function startRaidPhase(isHuman) {
      phase = 'raid';
      showAllForBuilder = false;
      heroes = [
        { type: HERO_WARRIOR, hp: HERO_STATS[HERO_WARRIOR].hp, maxHp: HERO_STATS[HERO_WARRIOR].hp, r: 0, c: 0, alive: true, moved: false },
        { type: HERO_MAGE,    hp: HERO_STATS[HERO_MAGE].hp,    maxHp: HERO_STATS[HERO_MAGE].hp,    r: 0, c: 0, alive: true, moved: false },
        { type: HERO_ROGUE,   hp: HERO_STATS[HERO_ROGUE].hp,   maxHp: HERO_STATS[HERO_ROGUE].hp,   r: 0, c: 0, alive: true, moved: false }
      ];
      selectedHero = 0;
      raidTurn = 0;
      raidComplete = false;
      heroesKilled = 0;
      treasureReached = false;
      monsterHPs = {};
      turnLog = [];

      // Initialize monster HPs
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (MON_HP[grid[r][c].type]) {
            monsterHPs[r + ',' + c] = MON_HP[grid[r][c].type];
          }
        }
      }

      // Reveal around entrance
      revealAround(0, 0);
      phaseTextEl.textContent = 'RAID PHASE (You)';
      infoTextEl.textContent = 'Move heroes to reach treasure';
      budgetTextEl.textContent = '';
      buildRaidToolbar();
      draw();
    }

    function buildRaidToolbar() {
      clearToolbar();
      heroes.forEach((h, i) => {
        if (!h.alive) return;
        const btn = document.createElement('button');
        const stats = HERO_STATS[h.type];
        btn.textContent = stats.icon + ' ' + h.type.charAt(0).toUpperCase() + h.type.slice(1) + ' HP:' + h.hp;
        btn.id = 'btn-hero-' + i;
        btn.style.borderColor = stats.color;
        if (i === selectedHero) btn.classList.add('active');
        btn.onclick = () => { selectedHero = i; updateRaidToolbar(); };
        toolbarEl.appendChild(btn);
      });
      // End turn button
      const endBtn = document.createElement('button');
      endBtn.textContent = 'END TURN';
      endBtn.style.background = '#a64';
      endBtn.style.color = '#fff';
      endBtn.onclick = endRaidTurn;
      toolbarEl.appendChild(endBtn);
    }

    function updateRaidToolbar() {
      toolbarEl.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      heroes.forEach((h, i) => {
        const btn = document.getElementById('btn-hero-' + i);
        if (btn) {
          const stats = HERO_STATS[h.type];
          btn.textContent = stats.icon + ' ' + h.type.charAt(0).toUpperCase() + h.type.slice(1) + ' HP:' + h.hp;
          if (i === selectedHero) btn.classList.add('active');
          if (!h.alive) { btn.disabled = true; btn.textContent += ' DEAD'; }
        }
      });
    }

    function revealAround(r, c) {
      for (let dr = -2; dr <= 2; dr++) {
        for (let dc = -2; dc <= 2; dc++) {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && Math.abs(dr) + Math.abs(dc) <= 2) {
            fogOfWar[nr][nc] = true;
          }
        }
      }
    }

    function endRaidTurn() {
      raidTurn++;
      heroes.forEach(h => h.moved = false);

      // Monsters attack nearby heroes
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (MON_ATK[grid[r][c].type] && monsterHPs[r+','+c] > 0) {
            heroes.forEach(h => {
              if (!h.alive) return;
              const dist = Math.abs(h.r - r) + Math.abs(h.c - c);
              if (dist <= 1) {
                let dmg = MON_ATK[grid[r][c].type];
                if (h.type === HERO_WARRIOR) dmg = Math.max(1, dmg - 1); // Tank reduces damage
                h.hp -= dmg;
                addLog(grid[r][c].type + ' attacks ' + h.type + ' for ' + dmg + ' dmg');
                if (h.hp <= 0) {
                  h.alive = false;
                  h.hp = 0;
                  heroesKilled++;
                  addLog(h.type + ' has fallen!');
                }
              }
            });
          }
        }
      }

      checkRaidEnd();
      if (!raidComplete) {
        updateRaidToolbar();
        // Auto-select first alive, unmoved hero
        const nextH = heroes.findIndex(h => h.alive && !h.moved);
        if (nextH >= 0) selectedHero = nextH;
        updateRaidToolbar();
      }
      draw();
    }

    function addLog(msg) {
      turnLog.push(msg);
      if (turnLog.length > 5) turnLog.shift();
    }

    function checkRaidEnd() {
      const allDead = heroes.every(h => !h.alive);
      if (allDead || treasureReached || raidTurn >= 30) {
        raidComplete = true;
        endRaidPhase();
      }
    }

    function endRaidPhase() {
      clearToolbar();

      let builderPoints = heroesKilled * 2;
      let raiderPoints = treasureReached ? 5 : 0;
      // Bonus for surviving heroes
      raiderPoints += heroes.filter(h => h.alive).length;

      if (playerRole === 'builder') {
        playerScore += builderPoints;
        aiScore += raiderPoints;
      } else {
        playerScore += raiderPoints;
        aiScore += builderPoints;
      }

      updateScoreboard();

      // Show transition
      const msg = treasureReached ? 'Treasure reached!' : 'All heroes fell!';
      phaseTextEl.textContent = 'ROUND ' + round + ' COMPLETE';
      infoTextEl.textContent = msg;
      budgetTextEl.textContent = '';

      setTimeout(() => {
        round++;
        if (round > 3) {
          endGame();
        } else {
          playerRole = playerRole === 'builder' ? 'raider' : 'builder';
          showTransition();
        }
      }, 1500);
    }

    function showTransition() {
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ROUND ' + round;
      overlayText.textContent = 'You are the ' + playerRole.toUpperCase();
      overlaySubText.textContent = 'Click to continue';
      gameState = 'transition';
    }

    function endGame() {
      gameState = 'over';
      overlay.style.display = 'flex';
      const winner = playerScore > aiScore ? 'YOU WIN!' : (playerScore < aiScore ? 'AI WINS!' : 'TIE!');
      overlayTitle.textContent = winner;
      overlayText.textContent = 'Player: ' + playerScore + ' | AI: ' + aiScore;
      overlaySubText.textContent = 'Click to play again';
      score = playerScore;
    }

    // ---- AI RAID PHASE ----
    function startAIRaidPhase() {
      phase = 'raid';
      showAllForBuilder = true;
      heroes = [
        { type: HERO_WARRIOR, hp: HERO_STATS[HERO_WARRIOR].hp, maxHp: HERO_STATS[HERO_WARRIOR].hp, r: 0, c: 0, alive: true, moved: false },
        { type: HERO_MAGE,    hp: HERO_STATS[HERO_MAGE].hp,    maxHp: HERO_STATS[HERO_MAGE].hp,    r: 0, c: 0, alive: true, moved: false },
        { type: HERO_ROGUE,   hp: HERO_STATS[HERO_ROGUE].hp,   maxHp: HERO_STATS[HERO_ROGUE].hp,   r: 0, c: 0, alive: true, moved: false }
      ];
      raidTurn = 0;
      raidComplete = false;
      heroesKilled = 0;
      treasureReached = false;
      monsterHPs = {};
      turnLog = [];

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (MON_HP[grid[r][c].type]) {
            monsterHPs[r + ',' + c] = MON_HP[grid[r][c].type];
          }
        }
      }

      // Reveal all for builder view
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          fogOfWar[r][c] = true;
        }
      }

      phaseTextEl.textContent = 'RAID PHASE (AI)';
      infoTextEl.textContent = 'AI is raiding your dungeon...';
      budgetTextEl.textContent = '';
      clearToolbar();
      draw();

      aiRaidStep();
    }

    function aiRaidStep() {
      if (raidComplete || gameState !== 'playing') return;

      aiThinking = true;
      setTimeout(() => {
        const aliveHeroes = heroes.filter(h => h.alive);
        if (aliveHeroes.length === 0) {
          raidComplete = true;
          endRaidPhase();
          return;
        }

        // AI moves each hero toward treasure using pathfinding
        aliveHeroes.forEach(hero => {
          if (!hero.alive || hero.moved) return;
          const target = findPathStep(hero.r, hero.c, ROWS-1, COLS-1, hero.type);
          if (target) {
            moveHero(heroes.indexOf(hero), target.r, target.c);
          }
          hero.moved = true;
        });

        // Monster attacks
        raidTurn++;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (MON_ATK[grid[r][c].type] && monsterHPs[r+','+c] > 0) {
              heroes.forEach(h => {
                if (!h.alive) return;
                const dist = Math.abs(h.r - r) + Math.abs(h.c - c);
                if (dist <= 1) {
                  let dmg = MON_ATK[grid[r][c].type];
                  if (h.type === HERO_WARRIOR) dmg = Math.max(1, dmg - 1);
                  h.hp -= dmg;
                  if (h.hp <= 0) {
                    h.alive = false;
                    h.hp = 0;
                    heroesKilled++;
                  }
                }
              });
            }
          }
        }

        heroes.forEach(h => h.moved = false);
        aiThinking = false;
        draw();

        checkRaidEnd();
        if (!raidComplete && raidTurn < 30) {
          aiRaidStep();
        } else if (!raidComplete) {
          raidComplete = true;
          endRaidPhase();
        }
      }, 500);
    }

    function findPathStep(fromR, fromC, toR, toC, heroType) {
      // BFS pathfinding, avoiding walls. Rogue ignores traps in cost.
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const parent = Array.from({length: ROWS}, () => Array(COLS).fill(null));
      const queue = [{r: fromR, c: fromC}];
      visited[fromR][fromC] = true;

      while (queue.length > 0) {
        const {r, c} = queue.shift();
        if (r === toR && c === toC) {
          // Trace back to find first step
          let cr = toR, cc = toC;
          while (parent[cr][cc]) {
            const p = parent[cr][cc];
            if (p.r === fromR && p.c === fromC) return {r: cr, c: cc};
            cr = p.r; cc = p.c;
          }
          return {r: cr, c: cc};
        }
        // Shuffle directions for variety
        const dirs = [[0,1],[1,0],[0,-1],[-1,0]].sort(() => Math.random() - 0.5);
        for (const [dr, dc] of dirs) {
          const nr = r+dr, nc = c+dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc]) {
            const cellType = grid[nr][nc].type;
            if (cellType === WALL) continue;
            // AI tries to send rogue first for traps, warrior for monsters
            visited[nr][nc] = true;
            parent[nr][nc] = {r, c};
            queue.push({r: nr, c: nc});
          }
        }
      }
      // No path found - try to move closer
      let bestDist = Infinity, bestPos = null;
      for (const [dr, dc] of [[0,1],[1,0],[0,-1],[-1,0]]) {
        const nr = fromR+dr, nc = fromC+dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && grid[nr][nc].type !== WALL) {
          const dist = Math.abs(nr - toR) + Math.abs(nc - toC);
          if (dist < bestDist) {
            bestDist = dist;
            bestPos = {r: nr, c: nc};
          }
        }
      }
      return bestPos;
    }

    // ---- HERO MOVEMENT ----
    function moveHero(idx, tr, tc) {
      const hero = heroes[idx];
      if (!hero || !hero.alive) return false;

      const dist = Math.abs(hero.r - tr) + Math.abs(hero.c - tc);
      if (dist !== 1) return false;

      const cell = grid[tr][tc];
      if (cell.type === WALL) return false;

      hero.r = tr;
      hero.c = tc;
      hero.moved = true;
      revealAround(tr, tc);

      // Handle traps
      if (TRAP_DAMAGE[cell.type]) {
        if (hero.type === HERO_ROGUE) {
          addLog('Rogue disarms ' + cell.type + '!');
          grid[tr][tc] = { type: 'empty', revealed: true };
        } else {
          const dmg = TRAP_DAMAGE[cell.type];
          hero.hp -= dmg;
          addLog(hero.type + ' triggers ' + cell.type + '! -' + dmg + ' HP');
          grid[tr][tc] = { type: 'empty', revealed: true };
          if (hero.hp <= 0) {
            hero.alive = false;
            hero.hp = 0;
            heroesKilled++;
            addLog(hero.type + ' has fallen!');
          }
        }
      }

      // Handle monsters - combat
      if (MON_HP[cell.type] && monsterHPs[tr+','+tc] > 0) {
        const monKey = tr + ',' + tc;
        const heroAtk = HERO_STATS[hero.type].atk;
        monsterHPs[monKey] -= heroAtk;
        addLog(hero.type + ' attacks ' + cell.type + ' for ' + heroAtk);
        if (monsterHPs[monKey] <= 0) {
          grid[tr][tc] = { type: 'empty', revealed: true };
          addLog(cell.type + ' defeated!');
        } else {
          // Monster counter-attacks
          let dmg = MON_ATK[cell.type];
          if (hero.type === HERO_WARRIOR) dmg = Math.max(1, dmg - 1);
          hero.hp -= dmg;
          addLog(cell.type + ' hits back for ' + dmg);
          if (hero.hp <= 0) {
            hero.alive = false;
            hero.hp = 0;
            heroesKilled++;
            addLog(hero.type + ' has fallen!');
          }
        }
      }

      // Mage ranged attack on nearby monsters
      if (hero.type === HERO_MAGE && hero.alive) {
        for (let dr = -HERO_STATS[HERO_MAGE].range; dr <= HERO_STATS[HERO_MAGE].range; dr++) {
          for (let dc = -HERO_STATS[HERO_MAGE].range; dc <= HERO_STATS[HERO_MAGE].range; dc++) {
            if (dr === 0 && dc === 0) continue;
            const mr = tr + dr, mc = tc + dc;
            if (mr >= 0 && mr < ROWS && mc >= 0 && mc < COLS) {
              const mKey = mr + ',' + mc;
              if (MON_HP[grid[mr][mc].type] && monsterHPs[mKey] > 0) {
                const monType = grid[mr][mc].type;
                monsterHPs[mKey] -= 2; // Ranged splash damage
                addLog('Mage zaps ' + monType + ' from range');
                if (monsterHPs[mKey] <= 0) {
                  grid[mr][mc] = { type: 'empty', revealed: true };
                  addLog(monType + ' defeated by magic!');
                }
              }
            }
          }
        }
      }

      // Check treasure
      if (tr === ROWS-1 && tc === COLS-1) {
        treasureReached = true;
        addLog('TREASURE REACHED!');
      }

      return true;
    }

    // ---- INPUT HANDLING ----
    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState === 'transition') {
        gameState = 'playing';
        overlay.style.display = 'none';
        startRound();
        return;
      }
      if (aiThinking) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Convert to grid coords
      const gc = Math.floor((mx - GRID_X) / CELL);
      const gr = Math.floor((my - GRID_Y) / CELL);

      if (gc < 0 || gc >= COLS || gr < 0 || gr >= ROWS) return;

      if (phase === 'build' && playerRole === 'builder') {
        handleBuildClick(gr, gc);
      } else if (phase === 'raid' && playerRole === 'raider') {
        handleRaidClick(gr, gc);
      }
    });

    function handleBuildClick(r, c) {
      if (grid[r][c].type === ENTRANCE || grid[r][c].type === TREASURE) return;

      if (selectedTool === 'erase') {
        const existing = grid[r][c].type;
        if (existing !== 'empty') {
          const refund = PLACEMENT_COSTS[existing] || 0;
          budget += refund;
          grid[r][c] = { type: 'empty', revealed: false };
          budgetTextEl.textContent = 'Budget: ' + budget;
          updateBuildButtons();
          draw();
        }
        return;
      }

      if (!selectedTool || !PLACEMENT_COSTS[selectedTool]) return;
      if (grid[r][c].type !== 'empty') return;

      const cost = PLACEMENT_COSTS[selectedTool];
      if (budget < cost) return;

      grid[r][c] = { type: selectedTool, revealed: false };
      budget -= cost;
      budgetTextEl.textContent = 'Budget: ' + budget;

      // Verify path still exists
      if (!pathExists()) {
        grid[r][c] = { type: 'empty', revealed: false };
        budget += cost;
        budgetTextEl.textContent = 'Budget: ' + budget;
        addLog('Cannot block all paths!');
      }

      updateBuildButtons();
      draw();
    }

    function pathExists() {
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const queue = [{r: 0, c: 0}];
      visited[0][0] = true;
      while (queue.length > 0) {
        const {r, c} = queue.shift();
        if (r === ROWS-1 && c === COLS-1) return true;
        for (const [dr, dc] of [[0,1],[0,-1],[1,0],[-1,0]]) {
          const nr = r+dr, nc = c+dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc] && grid[nr][nc].type !== WALL) {
            visited[nr][nc] = true;
            queue.push({r: nr, c: nc});
          }
        }
      }
      return false;
    }

    function updateBuildButtons() {
      Object.keys(PLACEMENT_COSTS).forEach(key => {
        const btn = document.getElementById('btn-' + key);
        if (btn) btn.disabled = PLACEMENT_COSTS[key] > budget;
      });
    }

    function handleRaidClick(r, c) {
      if (raidComplete) return;
      const hero = heroes[selectedHero];
      if (!hero || !hero.alive || hero.moved) {
        // Try to select a hero at clicked position
        const clickedHero = heroes.findIndex(h => h.alive && h.r === r && h.c === c);
        if (clickedHero >= 0) {
          selectedHero = clickedHero;
          updateRaidToolbar();
          draw();
        }
        return;
      }

      const dist = Math.abs(hero.r - r) + Math.abs(hero.c - c);
      if (dist !== 1) return;

      moveHero(selectedHero, r, c);
      updateRaidToolbar();

      // Auto-advance to next hero
      const nextAlive = heroes.findIndex((h, i) => i > selectedHero && h.alive && !h.moved);
      if (nextAlive >= 0) {
        selectedHero = nextAlive;
      } else {
        const firstAlive = heroes.findIndex(h => h.alive && !h.moved);
        if (firstAlive >= 0) selectedHero = firstAlive;
      }
      updateRaidToolbar();

      checkRaidEnd();
      draw();
    }

    // ---- DRAWING ----
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawGrid();
      if (phase === 'raid') {
        drawHeroes();
      }
      drawSidebar();
    }

    function drawGrid() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = GRID_X + c * CELL;
          const y = GRID_Y + r * CELL;
          const cell = grid[r][c];
          const revealed = showAllForBuilder || fogOfWar[r][c];

          // Cell background
          if (!revealed && phase === 'raid') {
            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(x, y, CELL - 1, CELL - 1);
            ctx.fillStyle = '#1a1a3e';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', x + CELL/2, y + CELL/2);
          } else {
            // Floor
            ctx.fillStyle = (r + c) % 2 === 0 ? '#2a2218' : '#241e14';
            ctx.fillRect(x, y, CELL - 1, CELL - 1);

            // Draw cell contents
            if (cell.type !== 'empty') {
              const icon = ICONS[cell.type];
              if (icon) {
                // Glow effect for special items
                if (cell.type === TREASURE) {
                  ctx.shadowColor = '#fc4';
                  ctx.shadowBlur = 8;
                } else if (MON_HP[cell.type]) {
                  ctx.shadowColor = '#f44';
                  ctx.shadowBlur = 4;
                } else if (TRAP_DAMAGE[cell.type]) {
                  ctx.shadowColor = '#f84';
                  ctx.shadowBlur = 4;
                }
                ctx.fillStyle = icon.color;
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(icon.ch, x + CELL/2, y + CELL/2);
                ctx.shadowBlur = 0;

                // Show monster HP if in raid
                if (phase === 'raid' && MON_HP[cell.type] && monsterHPs[r+','+c] > 0) {
                  ctx.fillStyle = '#fff';
                  ctx.font = '9px Courier New';
                  ctx.fillText(monsterHPs[r+','+c] + '/' + MON_HP[cell.type], x + CELL/2, y + CELL - 8);
                }
              }
            }
          }

          // Grid border
          ctx.strokeStyle = '#3a2a1a';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, CELL - 1, CELL - 1);
        }
      }
    }

    function drawHeroes() {
      heroes.forEach((h, i) => {
        if (!h.alive) return;
        const x = GRID_X + h.c * CELL;
        const y = GRID_Y + h.r * CELL;
        const stats = HERO_STATS[h.type];

        // Hero background circle
        ctx.beginPath();
        ctx.arc(x + CELL/2, y + CELL/2, CELL/3, 0, Math.PI * 2);
        ctx.fillStyle = i === selectedHero && playerRole === 'raider' ? stats.color : stats.color + '88';
        ctx.fill();
        ctx.strokeStyle = i === selectedHero && playerRole === 'raider' ? '#fff' : stats.color;
        ctx.lineWidth = i === selectedHero && playerRole === 'raider' ? 2 : 1;
        ctx.stroke();

        // Hero letter
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(stats.icon, x + CELL/2, y + CELL/2);

        // HP bar
        const barW = CELL - 8;
        const barH = 3;
        const barX = x + 4;
        const barY = y + CELL - 7;
        ctx.fillStyle = '#400';
        ctx.fillRect(barX, barY, barW, barH);
        ctx.fillStyle = h.hp > h.maxHp * 0.5 ? '#4f4' : (h.hp > h.maxHp * 0.25 ? '#ff4' : '#f44');
        ctx.fillRect(barX, barY, barW * (h.hp / h.maxHp), barH);

        // Moved indicator
        if (h.moved) {
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.fillRect(x, y, CELL - 1, CELL - 1);
        }
      });
    }

    function drawSidebar() {
      const sx = SIDEBAR_X;
      let sy = GRID_Y;

      ctx.fillStyle = '#a64';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'left';

      if (phase === 'build') {
        ctx.fillText('BUILD MODE', sx, sy);
        sy += 18;
        ctx.fillStyle = '#aaa';
        ctx.font = '10px Courier New';
        ctx.fillText('Budget: ' + budget, sx, sy); sy += 14;
        ctx.fillText('Round: ' + round + '/3', sx, sy); sy += 14;
        ctx.fillText('Role: Builder', sx, sy); sy += 20;
        ctx.fillStyle = '#888';
        ctx.fillText('Click grid to', sx, sy); sy += 12;
        ctx.fillText('place items', sx, sy); sy += 18;

        // Legend
        ctx.fillStyle = '#a64';
        ctx.font = 'bold 10px Courier New';
        ctx.fillText('LEGEND:', sx, sy); sy += 14;
        const legend = [
          { ch: '#', color: '#666', label: 'Wall' },
          { ch: '\u25B2', color: '#f44', label: 'Spike' },
          { ch: 'O', color: '#840', label: 'Pit' },
          { ch: '\u2192', color: '#f84', label: 'Arrow' },
          { ch: 'g', color: '#4a4', label: 'Goblin' },
          { ch: 's', color: '#aaa', label: 'Skeleton' },
          { ch: 'D', color: '#f44', label: 'Dragon' },
        ];
        legend.forEach(l => {
          ctx.fillStyle = l.color;
          ctx.font = 'bold 12px Courier New';
          ctx.fillText(l.ch, sx, sy);
          ctx.fillStyle = '#888';
          ctx.font = '10px Courier New';
          ctx.fillText(' ' + l.label, sx + 14, sy);
          sy += 14;
        });
      } else {
        ctx.fillText('RAID MODE', sx, sy);
        sy += 18;
        ctx.fillStyle = '#aaa';
        ctx.font = '10px Courier New';
        ctx.fillText('Turn: ' + raidTurn, sx, sy); sy += 14;
        ctx.fillText('Round: ' + round + '/3', sx, sy); sy += 14;
        ctx.fillText('Killed: ' + heroesKilled, sx, sy); sy += 20;

        // Hero status
        heroes.forEach((h, i) => {
          const stats = HERO_STATS[h.type];
          ctx.fillStyle = h.alive ? stats.color : '#444';
          ctx.font = 'bold 11px Courier New';
          ctx.fillText(stats.icon + ' ' + h.type, sx, sy);
          sy += 13;
          ctx.fillStyle = h.alive ? '#aaa' : '#444';
          ctx.font = '10px Courier New';
          ctx.fillText('HP:' + h.hp + '/' + h.maxHp, sx, sy);
          sy += 13;
          ctx.fillText(stats.ability, sx, sy);
          sy += 16;
        });

        // Turn log
        if (turnLog.length > 0) {
          sy += 6;
          ctx.fillStyle = '#a64';
          ctx.font = 'bold 10px Courier New';
          ctx.fillText('LOG:', sx, sy); sy += 13;
          turnLog.forEach(msg => {
            ctx.fillStyle = '#888';
            ctx.font = '9px Courier New';
            // Truncate long messages
            const displayMsg = msg.length > 20 ? msg.substring(0, 19) + '..' : msg;
            ctx.fillText(displayMsg, sx, sy);
            sy += 11;
          });
        }
      }
    }

    function updateScoreboard() {
      playerScoreEl.textContent = playerScore;
      aiScoreEl.textContent = aiScore;
      roundNumEl.textContent = round > 3 ? 3 : round;
    }

    // ---- GAME LOOP ----
    function gameLoop() {
      draw();
      updateGameData();
      requestAnimationFrame(gameLoop);
    }

    // ---- Expose game data ----
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState,
        score,
        playerScore,
        aiScore,
        round,
        phase,
        playerRole,
        heroesKilled,
        treasureReached
      };
    }

    // ---- Initialize ----
    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

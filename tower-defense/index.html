<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #cf4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 255, 68, 0.5); }
    h1 { color: #cf4; font-size: 2rem; text-shadow: 0 0 15px rgba(204, 255, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #cf4; }
    canvas {
      border: 2px solid #cf4;
      box-shadow: 0 0 20px rgba(204, 255, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #cf4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-top: 8px;
      font-size: 0.85rem;
      color: #888;
    }
    .info-bar .tower-info { display: flex; gap: 14px; }
    .info-bar .tkey { padding: 1px 5px; border: 1px solid #555; border-radius: 3px; font-size: 0.8rem; color: #aaa; }
    .info-bar .tkey.active { border-color: #cf4; color: #cf4; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TOWER DEFENSE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:480px;">
      <h2 id="overlayTitle">TOWER DEFENSE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>
  <div class="info-bar">
    <div class="tower-info">
      <span><span class="tkey" id="tk1">1</span> Blaster $50</span>
      <span><span class="tkey" id="tk2">2</span> Cannon $100</span>
      <span><span class="tkey" id="tk3">3</span> Frost $75</span>
      <span><span class="tkey" id="tk4">4</span> Sniper $150</span>
    </div>
    <div>Click or Arrows+Space to place</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const CELL = 40;
    const COLS = W / CELL;  // 15
    const ROWS = H / CELL;  // 12

    // Path definition: array of grid cells the enemies follow (S-shaped path)
    // Path goes: right across top, down, left across middle, down, right across bottom
    const PATH = [];
    function buildPath() {
      PATH.length = 0;
      // Row 1: left to right (y=1, x=0..13)
      for (let x = 0; x <= 13; x++) PATH.push({ x, y: 1 });
      // Down right side (x=13, y=2..3)
      for (let y = 2; y <= 3; y++) PATH.push({ x: 13, y });
      // Row 3: right to left (y=3, x=12..1)
      for (let x = 12; x >= 1; x--) PATH.push({ x, y: 3 });
      // Down left side (x=1, y=4..5)
      for (let y = 4; y <= 5; y++) PATH.push({ x: 1, y });
      // Row 5: left to right (y=5, x=2..13)
      for (let x = 2; x <= 13; x++) PATH.push({ x, y: 5 });
      // Down right side (x=13, y=6..7)
      for (let y = 6; y <= 7; y++) PATH.push({ x: 13, y });
      // Row 7: right to left (y=7, x=12..1)
      for (let x = 12; x >= 1; x--) PATH.push({ x, y: 7 });
      // Down left side (x=1, y=8..9)
      for (let y = 8; y <= 9; y++) PATH.push({ x: 1, y });
      // Row 9: left to right (y=9, x=2..14)
      for (let x = 2; x <= 14; x++) PATH.push({ x, y: 9 });
    }
    buildPath();

    // Path lookup set for quick collision check
    const pathSet = new Set();
    function rebuildPathSet() {
      pathSet.clear();
      PATH.forEach(p => pathSet.add(p.x + ',' + p.y));
    }
    rebuildPathSet();

    // Tower types
    const TOWER_TYPES = {
      blaster: { name: 'Blaster', cost: 50, range: 3, damage: 8, fireRate: 8, color: '#4f4', splash: 0, slow: 0, bulletSpeed: 6, bulletSize: 3 },
      cannon:  { name: 'Cannon', cost: 100, range: 2.5, damage: 40, fireRate: 30, color: '#f80', splash: 1.2, slow: 0, bulletSpeed: 4, bulletSize: 5 },
      frost:   { name: 'Frost', cost: 75, range: 2.8, damage: 5, fireRate: 12, color: '#0ef', splash: 0, slow: 0.5, bulletSpeed: 5, bulletSize: 4 },
      sniper:  { name: 'Sniper', cost: 150, range: 5.5, damage: 60, fireRate: 50, color: '#f4f', splash: 0, slow: 0, bulletSpeed: 10, bulletSize: 2 }
    };

    // Enemy types
    const ENEMY_TYPES = {
      basic: { hp: 40, speed: 1.0, reward: 10, color: '#f44', size: 12 },
      fast:  { hp: 25, speed: 2.0, reward: 15, color: '#ff0', size: 10 },
      tank:  { hp: 150, speed: 0.6, reward: 25, color: '#f80', size: 16 },
      boss:  { hp: 500, speed: 0.4, reward: 100, color: '#f0f', size: 20 }
    };

    // Wave definitions
    function getWave(n) {
      const waves = [];
      // Scaling: more enemies and tougher types as waves progress
      if (n <= 3) {
        // Early: just basics
        for (let i = 0; i < 5 + n * 2; i++) waves.push('basic');
      } else if (n <= 6) {
        for (let i = 0; i < 4 + n; i++) waves.push('basic');
        for (let i = 0; i < n - 2; i++) waves.push('fast');
      } else if (n <= 10) {
        for (let i = 0; i < 3 + n; i++) waves.push('basic');
        for (let i = 0; i < n - 3; i++) waves.push('fast');
        for (let i = 0; i < Math.floor((n - 5) / 2); i++) waves.push('tank');
      } else if (n <= 15) {
        for (let i = 0; i < n; i++) waves.push('basic');
        for (let i = 0; i < n - 4; i++) waves.push('fast');
        for (let i = 0; i < Math.floor(n / 4); i++) waves.push('tank');
        if (n % 5 === 0) waves.push('boss');
      } else {
        // Late game: lots of everything
        for (let i = 0; i < n + 2; i++) waves.push('basic');
        for (let i = 0; i < n - 2; i++) waves.push('fast');
        for (let i = 0; i < Math.floor(n / 3); i++) waves.push('tank');
        if (n % 3 === 0) waves.push('boss');
      }
      // Scale HP with wave number
      const hpMult = 1 + (n - 1) * 0.12;
      return waves.map(type => {
        const e = ENEMY_TYPES[type];
        return { type, hp: Math.round(e.hp * hpMult), maxHp: Math.round(e.hp * hpMult), speed: e.speed, reward: e.reward, color: e.color, size: e.size };
      });
    }

    // Game state
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let gold, lives, wave, waveEnemies, spawnTimer, spawnIndex;
    let enemies, towers, bullets, particles;
    let selectedTower, cursorX, cursorY;
    let mouseX, mouseY;
    let frameCount;
    let waveDelay;
    let keys = {};

    function init() {
      score = 0;
      gold = 200;
      lives = 20;
      wave = 0;
      enemies = [];
      towers = [];
      bullets = [];
      particles = [];
      waveEnemies = [];
      spawnTimer = 0;
      spawnIndex = 0;
      frameCount = 0;
      waveDelay = 0;
      selectedTower = 'blaster';
      cursorX = 7;
      cursorY = 0;
      mouseX = -1;
      mouseY = -1;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TOWER DEFENSE';
      overlayText.textContent = 'Press SPACE to start';
      updateTowerKeyIndicators();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      nextWave();
      requestAnimationFrame(loop);
    }

    function nextWave() {
      wave++;
      waveEnemies = getWave(wave);
      // Shuffle wave enemies for variety
      for (let i = waveEnemies.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [waveEnemies[i], waveEnemies[j]] = [waveEnemies[j], waveEnemies[i]];
      }
      spawnIndex = 0;
      spawnTimer = 0;
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Wave: ${wave} â€” Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Spawn enemies from current wave
      if (spawnIndex < waveEnemies.length) {
        spawnTimer++;
        const spawnInterval = Math.max(15, 40 - wave);
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          const template = waveEnemies[spawnIndex];
          enemies.push({
            pathIdx: 0,
            progress: 0,
            hp: template.hp,
            maxHp: template.maxHp,
            speed: template.speed,
            reward: template.reward,
            color: template.color,
            size: template.size,
            type: template.type,
            slowTimer: 0,
            x: PATH[0].x * CELL + CELL / 2,
            y: PATH[0].y * CELL + CELL / 2
          });
          spawnIndex++;
        }
      }

      // Check for wave complete
      if (spawnIndex >= waveEnemies.length && enemies.length === 0) {
        waveDelay++;
        if (waveDelay >= 90) { // Brief pause between waves
          waveDelay = 0;
          // Bonus gold for completing a wave
          gold += 20 + wave * 5;
          nextWave();
        }
      }

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        let speed = e.speed;
        if (e.slowTimer > 0) {
          speed *= 0.4;
          e.slowTimer--;
        }

        // Move along path
        e.progress += speed * 0.03;

        // Calculate position from path index and progress
        const idx = Math.floor(e.pathIdx + e.progress);
        if (idx >= PATH.length - 1) {
          // Enemy reached the end
          lives--;
          enemies.splice(i, 1);
          // Spawn damage particles at base
          for (let p = 0; p < 5; p++) {
            particles.push({
              x: PATH[PATH.length - 1].x * CELL + CELL / 2,
              y: PATH[PATH.length - 1].y * CELL + CELL / 2,
              vx: (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 3,
              life: 20,
              color: '#f00'
            });
          }
          if (lives <= 0) {
            lives = 0;
            gameOver();
            return;
          }
          continue;
        }

        const currNode = PATH[idx];
        const nextNode = PATH[Math.min(idx + 1, PATH.length - 1)];
        const frac = (e.pathIdx + e.progress) - idx;
        e.x = (currNode.x + (nextNode.x - currNode.x) * frac) * CELL + CELL / 2;
        e.y = (currNode.y + (nextNode.y - currNode.y) * frac) * CELL + CELL / 2;
      }

      // Update towers (fire at enemies)
      towers.forEach(t => {
        if (t.cooldown > 0) {
          t.cooldown--;
          return;
        }

        // Find closest enemy in range
        let target = null;
        let bestDist = Infinity;
        const rangePixels = t.range * CELL;

        enemies.forEach(e => {
          const dx = e.x - (t.x * CELL + CELL / 2);
          const dy = e.y - (t.y * CELL + CELL / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          // Prioritize enemies furthest along the path
          if (dist <= rangePixels) {
            const pathProgress = e.pathIdx + e.progress;
            if (!target || pathProgress > (target._pathProgress || 0)) {
              target = e;
              target._pathProgress = pathProgress;
              bestDist = dist;
            }
          }
        });

        if (target) {
          t.cooldown = t.fireRate;
          t.angle = Math.atan2(target.y - (t.y * CELL + CELL / 2), target.x - (t.x * CELL + CELL / 2));

          // Create bullet
          bullets.push({
            x: t.x * CELL + CELL / 2,
            y: t.y * CELL + CELL / 2,
            tx: target.x,
            ty: target.y,
            target: target,
            speed: t.bulletSpeed,
            damage: t.damage,
            splash: t.splash,
            slow: t.slow,
            color: t.color,
            size: t.bulletSize
          });
        }
      });

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];

        // Move toward target position (or last known position)
        if (b.target && enemies.includes(b.target)) {
          b.tx = b.target.x;
          b.ty = b.target.y;
        }

        const dx = b.tx - b.x;
        const dy = b.ty - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < b.speed * 2) {
          // Hit
          if (b.splash > 0) {
            // Splash damage
            const splashR = b.splash * CELL;
            enemies.forEach(e => {
              const edx = e.x - b.tx;
              const edy = e.y - b.ty;
              if (Math.sqrt(edx * edx + edy * edy) <= splashR) {
                damageEnemy(e, b.damage * 0.6);
              }
            });
            // Hit direct target for full damage
            if (b.target && enemies.includes(b.target)) {
              damageEnemy(b.target, b.damage * 0.4); // Extra on top of splash
            }
            // Explosion particles
            for (let p = 0; p < 8; p++) {
              particles.push({
                x: b.tx, y: b.ty,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 15,
                color: b.color
              });
            }
          } else {
            // Single target
            if (b.target && enemies.includes(b.target)) {
              damageEnemy(b.target, b.damage);
              if (b.slow > 0) {
                b.target.slowTimer = 60; // 1 second slow
              }
            }
            // Small hit particles
            for (let p = 0; p < 3; p++) {
              particles.push({
                x: b.tx, y: b.ty,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 10,
                color: b.color
              });
            }
          }
          bullets.splice(i, 1);
          continue;
        }

        b.x += (dx / dist) * b.speed;
        b.y += (dy / dist) * b.speed;

        // Remove bullets that have traveled too far (missed target)
        if (b.x < -50 || b.x > W + 50 || b.y < -50 || b.y > H + 50) {
          bullets.splice(i, 1);
        }
      }

      // Remove dead enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].hp <= 0) {
          const e = enemies[i];
          gold += e.reward;
          score += e.reward;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
          // Death particles
          for (let p = 0; p < 6; p++) {
            particles.push({
              x: e.x, y: e.y,
              vx: (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 3,
              life: 20,
              color: e.color
            });
          }
          enemies.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function damageEnemy(e, dmg) {
      e.hp -= dmg;
    }

    function canPlace(gx, gy) {
      // Must be within grid
      if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return false;
      // Cannot place on path
      if (pathSet.has(gx + ',' + gy)) return false;
      // Cannot place on existing tower
      if (towers.some(t => t.x === gx && t.y === gy)) return false;
      // Must be adjacent to path (within 1 cell) for strategic placement
      let adjacent = false;
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          if (pathSet.has((gx + dx) + ',' + (gy + dy))) {
            adjacent = true;
            break;
          }
        }
        if (adjacent) break;
      }
      return adjacent;
    }

    function placeTower(gx, gy) {
      if (gameState !== 'playing') return;
      const type = TOWER_TYPES[selectedTower];
      if (gold < type.cost) return;
      if (!canPlace(gx, gy)) return;

      gold -= type.cost;
      towers.push({
        x: gx, y: gy,
        range: type.range,
        damage: type.damage,
        fireRate: type.fireRate,
        cooldown: 0,
        color: type.color,
        splash: type.splash,
        slow: type.slow,
        bulletSpeed: type.bulletSpeed,
        bulletSize: type.bulletSize,
        angle: 0,
        type: selectedTower
      });

      // Placement particles
      for (let p = 0; p < 4; p++) {
        particles.push({
          x: gx * CELL + CELL / 2,
          y: gy * CELL + CELL / 2,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 15,
          color: type.color
        });
      }
    }

    function updateTowerKeyIndicators() {
      const map = { blaster: 'tk1', cannon: 'tk2', frost: 'tk3', sniper: 'tk4' };
      Object.entries(map).forEach(([type, id]) => {
        const el = document.getElementById(id);
        if (type === selectedTower) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Draw path
      PATH.forEach((p, i) => {
        ctx.fillStyle = '#1e2a4a';
        ctx.fillRect(p.x * CELL, p.y * CELL, CELL, CELL);

        // Path direction indicators
        if (i < PATH.length - 1) {
          const next = PATH[i + 1];
          ctx.strokeStyle = '#2a3a5e';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x * CELL + CELL / 2, p.y * CELL + CELL / 2);
          ctx.lineTo(
            p.x * CELL + CELL / 2 + (next.x - p.x) * CELL * 0.3,
            p.y * CELL + CELL / 2 + (next.y - p.y) * CELL * 0.3
          );
          ctx.stroke();
        }
      });

      // Entry marker
      ctx.fillStyle = '#4f4';
      ctx.shadowColor = '#4f4';
      ctx.shadowBlur = 8;
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('IN', PATH[0].x * CELL + CELL / 2, PATH[0].y * CELL + CELL / 2);
      ctx.shadowBlur = 0;

      // Exit marker
      const lastP = PATH[PATH.length - 1];
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 8;
      ctx.fillText('END', lastP.x * CELL + CELL / 2, lastP.y * CELL + CELL / 2);
      ctx.shadowBlur = 0;

      // Draw towers
      towers.forEach(t => {
        // Base
        ctx.fillStyle = '#16213e';
        ctx.strokeStyle = t.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(t.x * CELL + CELL / 2, t.y * CELL + CELL / 2, CELL / 2 - 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Turret (rotates toward target)
        ctx.save();
        ctx.translate(t.x * CELL + CELL / 2, t.y * CELL + CELL / 2);
        ctx.rotate(t.angle);
        ctx.fillStyle = t.color;
        ctx.shadowColor = t.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(0, -2, CELL / 2 - 2, 4);
        ctx.shadowBlur = 0;

        // Center dot
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = t.color;
        ctx.fill();
        ctx.restore();

        // Range ring for selected tower at cursor
        // (only show range for hovered tower)
      });

      // Draw cursor / placement preview
      if (gameState === 'playing') {
        let cx, cy;
        // Use mouse position if available, otherwise keyboard cursor
        if (mouseX >= 0 && mouseY >= 0) {
          cx = Math.floor(mouseX / CELL);
          cy = Math.floor(mouseY / CELL);
        } else {
          cx = cursorX;
          cy = cursorY;
        }

        if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS) {
          const valid = canPlace(cx, cy);
          const type = TOWER_TYPES[selectedTower];
          const affordable = gold >= type.cost;

          // Range preview circle
          ctx.beginPath();
          ctx.arc(cx * CELL + CELL / 2, cy * CELL + CELL / 2, type.range * CELL, 0, Math.PI * 2);
          ctx.strokeStyle = valid && affordable ? 'rgba(204, 255, 68, 0.25)' : 'rgba(255, 68, 68, 0.15)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Cell highlight
          ctx.fillStyle = valid && affordable ? 'rgba(204, 255, 68, 0.15)' : 'rgba(255, 68, 68, 0.15)';
          ctx.fillRect(cx * CELL, cy * CELL, CELL, CELL);
          ctx.strokeStyle = valid && affordable ? '#cf4' : '#f44';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(cx * CELL, cy * CELL, CELL, CELL);

          // Tower type label
          ctx.fillStyle = valid && affordable ? '#cf4' : '#f44';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(type.name + ' $' + type.cost, cx * CELL + CELL / 2, cy * CELL - 2);
        }
      }

      // Draw enemies
      enemies.forEach(e => {
        // Shadow / glow
        ctx.shadowColor = e.color;
        ctx.shadowBlur = e.slowTimer > 0 ? 12 : 6;

        // Enemy body
        ctx.fillStyle = e.slowTimer > 0 ? '#88f' : e.color;
        ctx.beginPath();
        if (e.type === 'tank' || e.type === 'boss') {
          // Square for tanks/bosses
          ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
        } else {
          // Circle for basic/fast
          ctx.arc(e.x, e.y, e.size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Health bar
        const barW = e.size + 4;
        const barH = 3;
        const barX = e.x - barW / 2;
        const barY = e.y - e.size / 2 - 6;
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barW, barH);
        const hpRatio = Math.max(0, e.hp / e.maxHp);
        ctx.fillStyle = hpRatio > 0.5 ? '#4f4' : hpRatio > 0.25 ? '#ff0' : '#f44';
        ctx.fillRect(barX, barY, barW * hpRatio, barH);
      });

      // Draw bullets
      bullets.forEach(b => {
        ctx.fillStyle = b.color;
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Draw particles
      particles.forEach(p => {
        const alpha = p.life / 20;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // HUD on canvas
      ctx.fillStyle = '#cf4';
      ctx.shadowColor = '#cf4';
      ctx.shadowBlur = 4;
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`Gold: ${gold}`, 8, 8);
      ctx.fillText(`Lives: ${lives}`, 8, 26);
      ctx.fillText(`Wave: ${wave}`, 8, 44);
      ctx.shadowBlur = 0;

      // Selected tower indicator
      const st = TOWER_TYPES[selectedTower];
      ctx.fillStyle = st.color;
      ctx.textAlign = 'right';
      ctx.fillText(`[${selectedTower.toUpperCase()}]`, W - 8, 8);

      // Wave incoming text
      if (spawnIndex < waveEnemies.length) {
        const remaining = waveEnemies.length - spawnIndex + enemies.length;
        ctx.fillStyle = '#888';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(`Enemies: ${remaining}`, W - 8, 26);
      } else if (enemies.length === 0 && waveDelay > 0) {
        ctx.fillStyle = '#cf4';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#cf4';
        ctx.shadowBlur = 8;
        ctx.fillText(`Wave ${wave} cleared!`, W / 2, H / 2 - 20);
        ctx.fillStyle = '#aaa';
        ctx.font = '12px Courier New';
        ctx.fillText(`Next wave incoming...`, W / 2, H / 2 + 5);
        ctx.shadowBlur = 0;
      }

      // Expose game data for ML
      window.gameData = {
        gold, lives, wave, score,
        towerCount: towers.length,
        enemyCount: enemies.length,
        selectedTower,
        cursorX, cursorY
      };
    }

    // Mouse handlers
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('mouseleave', () => {
      mouseX = -1;
      mouseY = -1;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const gx = Math.floor(mx / CELL);
      const gy = Math.floor(my / CELL);
      placeTower(gx, gy);
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowLeft':
            cursorX = Math.max(0, cursorX - 1);
            mouseX = -1; mouseY = -1; // Switch to keyboard cursor
            break;
          case 'ArrowRight':
            cursorX = Math.min(COLS - 1, cursorX + 1);
            mouseX = -1; mouseY = -1;
            break;
          case 'ArrowUp':
            cursorY = Math.max(0, cursorY - 1);
            mouseX = -1; mouseY = -1;
            break;
          case 'ArrowDown':
            cursorY = Math.min(ROWS - 1, cursorY + 1);
            mouseX = -1; mouseY = -1;
            break;
          case ' ':
            placeTower(cursorX, cursorY);
            break;
          case '1':
            selectedTower = 'blaster';
            updateTowerKeyIndicators();
            break;
          case '2':
            selectedTower = 'cannon';
            updateTowerKeyIndicators();
            break;
          case '3':
            selectedTower = 'frost';
            updateTowerKeyIndicators();
            break;
          case '4':
            selectedTower = 'sniper';
            updateTowerKeyIndicators();
            break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

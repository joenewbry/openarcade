<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Micro RTS - OpenArcade</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow: hidden; }
#top-bar { width: 600px; display: flex; justify-content: space-between; align-items: center; padding: 6px 12px; background: #16213e; border-bottom: 2px solid #e84; }
#top-bar a { color: #e84; text-decoration: none; font-size: 14px; }
#top-bar a:hover { text-shadow: 0 0 8px #e84; }
#score-display { color: #e84; font-size: 14px; font-weight: bold; text-shadow: 0 0 6px #e84; }
#game-wrap { position: relative; }
canvas#game { display: block; border: 2px solid #e84; box-shadow: 0 0 20px rgba(238,136,68,0.3); cursor: crosshair; }
#hud { width: 600px; display: flex; justify-content: space-between; align-items: flex-start; padding: 6px 8px; background: #16213e; border-top: 2px solid #e84; font-size: 12px; gap: 8px; }
#resources-panel { display: flex; flex-direction: column; gap: 2px; min-width: 130px; }
#resources-panel span { color: #e84; }
#production-panel { display: flex; gap: 4px; }
#production-panel button { background: #1a1a2e; color: #e84; border: 1px solid #e84; padding: 4px 8px; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer; white-space: nowrap; }
#production-panel button:hover { background: #e84; color: #1a1a2e; }
#production-panel button:disabled { opacity: 0.4; cursor: default; background: #1a1a2e; color: #666; border-color: #666; }
#info-panel { min-width: 140px; text-align: right; font-size: 11px; color: #aaa; }
#minimap-wrap { position: absolute; bottom: 42px; right: 4px; border: 1px solid #e84; }
canvas#minimap { display: block; }
#overlay { position: absolute; top: 0; left: 0; width: 600px; height: 400px; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(26,26,46,0.92); z-index: 10; }
#overlay h1 { color: #e84; font-size: 28px; text-shadow: 0 0 15px #e84; margin-bottom: 12px; }
#overlay p { color: #ccc; font-size: 13px; margin-bottom: 6px; text-align: center; max-width: 460px; line-height: 1.5; }
#overlay button { margin-top: 16px; background: #e84; color: #1a1a2e; border: none; padding: 10px 32px; font-family: 'Courier New', monospace; font-size: 16px; cursor: pointer; font-weight: bold; }
#overlay button:hover { box-shadow: 0 0 15px #e84; }
.hidden { display: none !important; }
#timer-display { color: #e84; font-size: 13px; position: absolute; top: 32px; left: 50%; transform: translateX(-50%); text-shadow: 0 0 6px #e84; z-index: 5; pointer-events: none; }
</style>
</head>
<body>
<div id="top-bar">
  <a href="../index.html">&larr; OpenArcade</a>
  <span id="score-display">SCORE: 0</span>
</div>
<div id="game-wrap">
  <canvas id="game" width="600" height="400"></canvas>
  <div id="timer-display">5:00</div>
  <div id="minimap-wrap"><canvas id="minimap" width="100" height="67"></canvas></div>
  <div id="overlay">
    <h1>MICRO RTS</h1>
    <p>Gather minerals. Build an army. Destroy the enemy base.</p>
    <p style="font-size:11px; color:#e84;">Click/drag to select &bull; Right-click to move/attack<br>
    [W] Worker $50 &bull; [S] Soldier $75 &bull; [T] Tank $150<br>
    [A] Select all army &bull; [Q] Select all workers</p>
    <button id="start-btn">START GAME</button>
  </div>
</div>
<div id="hud">
  <div id="resources-panel">
    <span id="res-minerals">Minerals: 100</span>
    <span id="res-units">Units: 2 / 30</span>
    <span id="res-supply">Workers: 2 | Army: 0</span>
  </div>
  <div id="production-panel">
    <button id="btn-worker" title="Hotkey: W">Worker $50</button>
    <button id="btn-soldier" title="Hotkey: S">Soldier $75</button>
    <button id="btn-tank" title="Hotkey: T">Tank $150</button>
  </div>
  <div id="info-panel">
    <div id="selection-info">No selection</div>
  </div>
</div>

<script>
// === GAME CONSTANTS ===
const MAP_W = 1200, MAP_H = 800;
const CANVAS_W = 600, CANVAS_H = 400;
const TILE = 20;
const MAX_UNITS = 30;
const GAME_TIME = 300; // 5 minutes
const FOG_RADIUS = 120;
const THEME = '#e84';

const UNIT_DEFS = {
  worker:  { hp: 40, speed: 1.5, damage: 5, range: 15, atkSpeed: 1000, cost: 50, buildTime: 60, radius: 6, color: '#4f4' },
  soldier: { hp: 80, speed: 1.8, damage: 15, range: 18, atkSpeed: 700, cost: 75, buildTime: 80, radius: 7, color: '#f44' },
  tank:    { hp: 200, speed: 0.9, damage: 40, range: 60, atkSpeed: 1500, cost: 150, buildTime: 140, radius: 10, color: '#ff4' }
};

const BASE_HP = 500;
const BASE_RADIUS = 24;
const MINERAL_AMT = 500;
const GATHER_AMT = 8;
const GATHER_TIME = 800;
const CARRY_MAX = 40;

// === GAME STATE ===
let gameState = 'menu'; // menu, playing, gameover
let score = 0;

let camera = { x: 0, y: 0 };
let players = [];
let minerals = [];
let units = [];
let projectiles = [];
let fogGrid = []; // 2D for player 0 visibility
let selectedUnits = [];
let selBox = null; // drag selection
let mousePos = { x: 0, y: 0 };
let gameTimer = GAME_TIME;
let particles = [];
let prodQueue = []; // player 0 production queue

// AI state
let aiState = { phase: 'eco', attackTimer: 0, scoutTimer: 0, rallyPoint: null, lastAttackTime: 0 };
let influenceMap = [];

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const mctx = miniCanvas.getContext('2d');

// === INITIALIZATION ===
function initGame() {
  gameState = 'playing';
  score = 0;
  gameTimer = GAME_TIME;
  units = [];
  projectiles = [];
  particles = [];
  selectedUnits = [];
  prodQueue = [];
  
  // Players
  players = [
    { id: 0, minerals: 100, baseX: 80, baseY: MAP_H/2, baseHp: BASE_HP, alive: true, unitsKilled: 0, resourcesGathered: 0, color: '#4af', prodTimer: 0, prodType: null },
    { id: 1, minerals: 100, baseX: MAP_W - 80, baseY: MAP_H/2, baseHp: BASE_HP, alive: true, unitsKilled: 0, resourcesGathered: 0, color: '#f44', prodTimer: 0, prodType: null }
  ];
  
  // Mineral patches - scattered between bases
  minerals = [];
  const patchPositions = [
    { x: 300, y: 200 }, { x: 300, y: 600 },
    { x: 600, y: 400 },
    { x: 900, y: 200 }, { x: 900, y: 600 },
    { x: 500, y: 100 }, { x: 700, y: 700 },
    { x: 600, y: 250 }, { x: 600, y: 550 }
  ];
  for (let p of patchPositions) {
    for (let i = 0; i < 3; i++) {
      minerals.push({
        x: p.x + (Math.random()-0.5)*40,
        y: p.y + (Math.random()-0.5)*40,
        amount: MINERAL_AMT,
        maxAmount: MINERAL_AMT
      });
    }
  }
  
  // Starting workers
  for (let pid = 0; pid < 2; pid++) {
    for (let i = 0; i < 2; i++) {
      spawnUnit(pid, 'worker', players[pid].baseX + (i-0.5)*30, players[pid].baseY + (i-0.5)*20);
    }
  }
  
  // Init fog
  const fogW = Math.ceil(MAP_W / TILE);
  const fogH = Math.ceil(MAP_H / TILE);
  fogGrid = [];
  for (let y = 0; y < fogH; y++) {
    fogGrid[y] = [];
    for (let x = 0; x < fogW; x++) {
      fogGrid[y][x] = 0;
    }
  }
  
  // Init influence map
  const infW = Math.ceil(MAP_W / 40);
  const infH = Math.ceil(MAP_H / 40);
  influenceMap = [];
  for (let y = 0; y < infH; y++) {
    influenceMap[y] = [];
    for (let x = 0; x < infW; x++) {
      influenceMap[y][x] = 0;
    }
  }
  
  // AI state
  aiState = { phase: 'eco', attackTimer: 0, scoutTimer: 0, rallyPoint: { x: MAP_W - 200, y: MAP_H/2 }, lastAttackTime: 0 };
  
  // Camera starts on player base
  camera.x = Math.max(0, players[0].baseX - CANVAS_W/2);
  camera.y = Math.max(0, players[0].baseY - CANVAS_H/2);
  
  document.getElementById('overlay').classList.add('hidden');
}

function spawnUnit(playerId, type, x, y) {
  const def = UNIT_DEFS[type];
  const playerUnits = units.filter(u => u.playerId === playerId && u.alive);
  if (playerUnits.length >= MAX_UNITS) return null;
  
  const unit = {
    id: Math.random().toString(36).substr(2,9),
    playerId,
    type,
    x, y,
    hp: def.hp,
    maxHp: def.hp,
    speed: def.speed,
    damage: def.damage,
    range: def.range,
    atkSpeed: def.atkSpeed,
    radius: def.radius,
    alive: true,
    targetX: null, targetY: null,
    targetUnit: null,
    lastAttack: 0,
    carrying: 0, // minerals carried (workers)
    gatherTarget: null,
    gathering: false,
    gatherTimer: 0,
    returning: false,
    selected: false
  };
  units.push(unit);
  return unit;
}

// === INPUT HANDLING ===
let mouseDown = false;
let mouseButton = 0;
let dragStart = null;

function getWorldPos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) + camera.x,
    y: (e.clientY - rect.top) + camera.y
  };
}

canvas.addEventListener('mousedown', (e) => {
  e.preventDefault();
  if (gameState !== 'playing') return;
  mouseDown = true;
  mouseButton = e.button;
  const wp = getWorldPos(e);
  
  if (e.button === 0) {
    dragStart = { x: e.clientX - canvas.getBoundingClientRect().left, y: e.clientY - canvas.getBoundingClientRect().top };
    selBox = null;
  } else if (e.button === 2) {
    issueCommand(wp);
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mousePos.x = e.clientX - rect.left;
  mousePos.y = e.clientY - rect.top;
  
  if (mouseDown && mouseButton === 0 && dragStart) {
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    selBox = {
      x: Math.min(dragStart.x, cx),
      y: Math.min(dragStart.y, cy),
      w: Math.abs(cx - dragStart.x),
      h: Math.abs(cy - dragStart.y)
    };
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (gameState !== 'playing') return;
  
  if (e.button === 0) {
    if (selBox && selBox.w > 4 && selBox.h > 4) {
      // Box select
      const bx = selBox.x + camera.x;
      const by = selBox.y + camera.y;
      const bw = selBox.w;
      const bh = selBox.h;
      
      if (!e.shiftKey) {
        selectedUnits.forEach(u => u.selected = false);
        selectedUnits = [];
      }
      
      for (let u of units) {
        if (u.alive && u.playerId === 0 && u.x >= bx && u.x <= bx+bw && u.y >= by && u.y <= by+bh) {
          u.selected = true;
          if (!selectedUnits.includes(u)) selectedUnits.push(u);
        }
      }
    } else {
      // Click select
      const wp = getWorldPos(e);
      const clicked = findUnitAt(wp.x, wp.y, 0);
      
      if (!e.shiftKey) {
        selectedUnits.forEach(u => u.selected = false);
        selectedUnits = [];
      }
      
      if (clicked) {
        clicked.selected = true;
        if (!selectedUnits.includes(clicked)) selectedUnits.push(clicked);
      }
    }
    selBox = null;
    dragStart = null;
  }
  mouseDown = false;
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

function findUnitAt(wx, wy, playerId) {
  let closest = null, closestDist = 20;
  for (let u of units) {
    if (!u.alive || (playerId !== undefined && u.playerId !== playerId)) continue;
    const d = dist(u.x, u.y, wx, wy);
    if (d < closestDist) { closest = u; closestDist = d; }
  }
  return closest;
}

function issueCommand(wp) {
  if (selectedUnits.length === 0) return;
  
  // Check if right-clicking enemy unit
  const enemy = findEnemyAt(wp.x, wp.y);
  // Check if right-clicking mineral
  const mineral = findMineralAt(wp.x, wp.y);
  
  for (let u of selectedUnits) {
    if (!u.alive || u.playerId !== 0) continue;
    
    if (enemy) {
      u.targetUnit = enemy;
      u.targetX = null; u.targetY = null;
      u.gathering = false; u.gatherTarget = null; u.returning = false;
    } else if (mineral && u.type === 'worker') {
      u.gatherTarget = mineral;
      u.gathering = false;
      u.returning = false;
      u.targetUnit = null;
      u.targetX = mineral.x; u.targetY = mineral.y;
    } else {
      u.targetX = wp.x; u.targetY = wp.y;
      u.targetUnit = null;
      u.gathering = false; u.gatherTarget = null; u.returning = false;
    }
  }
  
  // Move command particle
  spawnParticle(wp.x, wp.y, '#4af', 15);
}

function findEnemyAt(wx, wy) {
  let closest = null, closestDist = 20;
  for (let u of units) {
    if (!u.alive || u.playerId === 0) continue;
    const d = dist(u.x, u.y, wx, wy);
    if (d < closestDist) { closest = u; closestDist = d; }
  }
  // Also check enemy base
  const p1 = players[1];
  if (p1.alive && dist(p1.baseX, p1.baseY, wx, wy) < BASE_RADIUS + 10) {
    return { isBase: true, playerId: 1, x: p1.baseX, y: p1.baseY };
  }
  return closest;
}

function findMineralAt(wx, wy) {
  for (let m of minerals) {
    if (m.amount > 0 && dist(m.x, m.y, wx, wy) < 16) return m;
  }
  return null;
}

// Keyboard
document.addEventListener('keydown', (e) => {
  if (gameState !== 'playing') return;
  
  switch(e.key.toLowerCase()) {
    case 'w': produceUnit('worker'); break;
    case 's': produceUnit('soldier'); break;
    case 't': produceUnit('tank'); break;
    case 'a': // Select all army
      selectedUnits.forEach(u => u.selected = false);
      selectedUnits = units.filter(u => u.alive && u.playerId === 0 && u.type !== 'worker');
      selectedUnits.forEach(u => u.selected = true);
      break;
    case 'q': // Select all workers
      selectedUnits.forEach(u => u.selected = false);
      selectedUnits = units.filter(u => u.alive && u.playerId === 0 && u.type === 'worker');
      selectedUnits.forEach(u => u.selected = true);
      break;
  }
});

// Minimap click
miniCanvas.addEventListener('mousedown', (e) => {
  if (gameState !== 'playing') return;
  const rect = miniCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / 100 * MAP_W;
  const my = (e.clientY - rect.top) / 67 * MAP_H;
  camera.x = mx - CANVAS_W/2;
  camera.y = my - CANVAS_H/2;
  clampCamera();
});

// Production buttons
document.getElementById('btn-worker').addEventListener('click', () => produceUnit('worker'));
document.getElementById('btn-soldier').addEventListener('click', () => produceUnit('soldier'));
document.getElementById('btn-tank').addEventListener('click', () => produceUnit('tank'));

function produceUnit(type) {
  const p = players[0];
  const def = UNIT_DEFS[type];
  const playerUnits = units.filter(u => u.playerId === 0 && u.alive);
  if (p.minerals < def.cost || playerUnits.length >= MAX_UNITS) return;
  if (prodQueue.length >= 5) return; // max queue
  p.minerals -= def.cost;
  prodQueue.push({ type, timer: def.buildTime, maxTimer: def.buildTime });
}

// === CAMERA ===
function clampCamera() {
  camera.x = Math.max(0, Math.min(MAP_W - CANVAS_W, camera.x));
  camera.y = Math.max(0, Math.min(MAP_H - CANVAS_H, camera.y));
}

// Edge scrolling
function updateCamera() {
  const EDGE = 15, SCROLL_SPEED = 5;
  if (mousePos.x < EDGE) camera.x -= SCROLL_SPEED;
  if (mousePos.x > CANVAS_W - EDGE) camera.x += SCROLL_SPEED;
  if (mousePos.y < EDGE) camera.y -= SCROLL_SPEED;
  if (mousePos.y > CANVAS_H - EDGE) camera.y += SCROLL_SPEED;
  clampCamera();
}

// === UTILITY ===
function dist(x1, y1, x2, y2) {
  return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

function spawnParticle(x, y, color, size) {
  for (let i = 0; i < 6; i++) {
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*3,
      vy: (Math.random()-0.5)*3,
      life: 20 + Math.random()*15,
      maxLife: 35,
      color,
      size: size * (0.3 + Math.random()*0.7)
    });
  }
}

// === FOG OF WAR ===
function updateFog() {
  const fogW = Math.ceil(MAP_W / TILE);
  const fogH = Math.ceil(MAP_H / TILE);
  
  // Decay fog
  for (let y = 0; y < fogH; y++) {
    for (let x = 0; x < fogW; x++) {
      if (fogGrid[y][x] > 0) fogGrid[y][x] = Math.max(0, fogGrid[y][x] - 0.02);
    }
  }
  
  // Reveal around player 0 units and base
  const reveals = units.filter(u => u.alive && u.playerId === 0).map(u => ({ x: u.x, y: u.y }));
  reveals.push({ x: players[0].baseX, y: players[0].baseY });
  
  for (let r of reveals) {
    const cr = FOG_RADIUS / TILE;
    const cx = Math.floor(r.x / TILE);
    const cy = Math.floor(r.y / TILE);
    for (let dy = -Math.ceil(cr); dy <= Math.ceil(cr); dy++) {
      for (let dx = -Math.ceil(cr); dx <= Math.ceil(cr); dx++) {
        const fx = cx + dx, fy = cy + dy;
        if (fx >= 0 && fx < fogW && fy >= 0 && fy < fogH) {
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d <= cr) {
            fogGrid[fy][fx] = 1;
          }
        }
      }
    }
  }
}

function isVisible(x, y) {
  const fx = Math.floor(x / TILE);
  const fy = Math.floor(y / TILE);
  const fogW = Math.ceil(MAP_W / TILE);
  const fogH = Math.ceil(MAP_H / TILE);
  if (fx < 0 || fx >= fogW || fy < 0 || fy >= fogH) return false;
  return fogGrid[fy][fx] > 0.5;
}

// === AI ===
function updateAI(dt) {
  const ai = players[1];
  if (!ai.alive) return;
  
  const aiUnits = units.filter(u => u.alive && u.playerId === 1);
  const aiWorkers = aiUnits.filter(u => u.type === 'worker');
  const aiArmy = aiUnits.filter(u => u.type !== 'worker');
  const playerUnits = units.filter(u => u.alive && u.playerId === 0);
  
  // Update influence map
  updateInfluenceMap();
  
  // Determine phase
  const elapsed = GAME_TIME - gameTimer;
  if (elapsed < 60) aiState.phase = 'eco';
  else if (elapsed < 120) aiState.phase = 'build';
  else aiState.phase = 'attack';
  
  // Adjust phase based on threat
  if (playerUnits.some(u => dist(u.x, u.y, ai.baseX, ai.baseY) < 200)) {
    aiState.phase = 'defend';
  }
  
  // Production
  if (ai.prodTimer > 0) {
    ai.prodTimer--;
    if (ai.prodTimer <= 0 && ai.prodType) {
      const angle = Math.random() * Math.PI * 2;
      spawnUnit(1, ai.prodType, ai.baseX + Math.cos(angle)*35, ai.baseY + Math.sin(angle)*35);
      ai.prodType = null;
    }
  } else {
    // Decide what to build
    if (aiUnits.length < MAX_UNITS) {
      let buildType = null;
      if (aiState.phase === 'eco') {
        if (aiWorkers.length < 5) buildType = 'worker';
        else if (aiArmy.length < 2) buildType = 'soldier';
        else buildType = 'worker';
      } else if (aiState.phase === 'build') {
        if (aiWorkers.length < 4) buildType = 'worker';
        else if (ai.minerals >= 150 && aiArmy.length > 3 && Math.random() < 0.3) buildType = 'tank';
        else buildType = 'soldier';
      } else if (aiState.phase === 'attack' || aiState.phase === 'defend') {
        if (aiWorkers.length < 3) buildType = 'worker';
        else if (ai.minerals >= 150 && Math.random() < 0.35) buildType = 'tank';
        else buildType = 'soldier';
      }
      
      if (buildType && ai.minerals >= UNIT_DEFS[buildType].cost) {
        ai.minerals -= UNIT_DEFS[buildType].cost;
        ai.prodTimer = UNIT_DEFS[buildType].buildTime;
        ai.prodType = buildType;
      }
    }
  }
  
  // Command workers
  for (let w of aiWorkers) {
    if (w.targetUnit || (w.gatherTarget && w.gatherTarget.amount > 0) || w.returning) continue;
    
    // Find nearest mineral
    let nearestMineral = null, nearestDist = Infinity;
    for (let m of minerals) {
      if (m.amount <= 0) continue;
      const d = dist(w.x, w.y, m.x, m.y);
      if (d < nearestDist) { nearestDist = d; nearestMineral = m; }
    }
    if (nearestMineral) {
      w.gatherTarget = nearestMineral;
      w.targetX = nearestMineral.x;
      w.targetY = nearestMineral.y;
      w.gathering = false;
      w.returning = false;
    }
  }
  
  // Command army
  aiState.attackTimer += dt;
  
  if (aiState.phase === 'defend') {
    // Defend base - attack nearby enemies
    const threats = playerUnits.filter(u => dist(u.x, u.y, ai.baseX, ai.baseY) < 250);
    for (let a of aiArmy) {
      if (threats.length > 0) {
        let nearest = threats[0], nd = Infinity;
        for (let t of threats) {
          const d = dist(a.x, a.y, t.x, t.y);
          if (d < nd) { nd = d; nearest = t; }
        }
        a.targetUnit = nearest;
      }
    }
  } else if (aiState.phase === 'attack' && aiArmy.length >= 4) {
    // Attack player base
    if (aiState.attackTimer > 3) {
      aiState.attackTimer = 0;
      for (let a of aiArmy) {
        // Find nearest player unit or go to base
        let nearestEnemy = null, nd = Infinity;
        for (let pu of playerUnits) {
          const d = dist(a.x, a.y, pu.x, pu.y);
          if (d < nd && d < 200) { nd = d; nearestEnemy = pu; }
        }
        if (nearestEnemy) {
          a.targetUnit = nearestEnemy;
        } else {
          a.targetX = players[0].baseX;
          a.targetY = players[0].baseY;
          a.targetUnit = null;
        }
      }
    }
  } else {
    // Rally near base
    if (aiState.attackTimer > 5) {
      aiState.attackTimer = 0;
      for (let a of aiArmy) {
        if (!a.targetUnit) {
          a.targetX = ai.baseX + (Math.random()-0.5)*100 - 80;
          a.targetY = ai.baseY + (Math.random()-0.5)*100;
        }
      }
    }
  }
  
  // Auto-attack: AI units that see enemies
  for (let a of aiArmy) {
    if (a.targetUnit && a.targetUnit.alive) continue;
    a.targetUnit = null;
    let nearestEnemy = null, nd = Infinity;
    for (let pu of playerUnits) {
      const d = dist(a.x, a.y, pu.x, pu.y);
      if (d < 150 && d < nd) { nd = d; nearestEnemy = pu; }
    }
    if (nearestEnemy) a.targetUnit = nearestEnemy;
  }
}

function updateInfluenceMap() {
  const infW = Math.ceil(MAP_W / 40);
  const infH = Math.ceil(MAP_H / 40);
  for (let y = 0; y < infH; y++) {
    for (let x = 0; x < infW; x++) {
      influenceMap[y][x] = 0;
    }
  }
  for (let u of units) {
    if (!u.alive) continue;
    const ix = Math.floor(u.x / 40);
    const iy = Math.floor(u.y / 40);
    const val = u.playerId === 0 ? -1 : 1;
    const str = u.type === 'tank' ? 3 : u.type === 'soldier' ? 2 : 0.5;
    for (let dy = -3; dy <= 3; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        const fx = ix+dx, fy = iy+dy;
        if (fx >= 0 && fx < infW && fy >= 0 && fy < infH) {
          const d = Math.max(1, Math.sqrt(dx*dx+dy*dy));
          influenceMap[fy][fx] += val * str / d;
        }
      }
    }
  }
}

// === UNIT UPDATE ===
function updateUnits(dt, now) {
  for (let u of units) {
    if (!u.alive) continue;
    
    // Clean dead target
    if (u.targetUnit && !u.targetUnit.alive && !u.targetUnit.isBase) {
      u.targetUnit = null;
    }
    
    // Worker gathering logic
    if (u.type === 'worker' && u.playerId >= 0) {
      // Returning minerals to base
      if (u.returning && u.carrying > 0) {
        const base = players[u.playerId];
        const bd = dist(u.x, u.y, base.baseX, base.baseY);
        if (bd < BASE_RADIUS + 10) {
          base.minerals += u.carrying;
          if (u.playerId === 0) players[0].resourcesGathered += u.carrying;
          else players[1].resourcesGathered += u.carrying;
          u.carrying = 0;
          u.returning = false;
          // Go back to gather
          if (u.gatherTarget && u.gatherTarget.amount > 0) {
            u.targetX = u.gatherTarget.x;
            u.targetY = u.gatherTarget.y;
          } else {
            u.gatherTarget = null;
          }
        } else {
          u.targetX = base.baseX;
          u.targetY = base.baseY;
        }
        u.targetUnit = null;
      }
      
      // At mineral patch
      if (u.gatherTarget && !u.returning && u.carrying < CARRY_MAX) {
        const md = dist(u.x, u.y, u.gatherTarget.x, u.gatherTarget.y);
        if (md < 18) {
          u.gathering = true;
          u.gatherTimer += dt * 1000;
          if (u.gatherTimer >= GATHER_TIME) {
            u.gatherTimer = 0;
            const amt = Math.min(GATHER_AMT, u.gatherTarget.amount, CARRY_MAX - u.carrying);
            u.carrying += amt;
            u.gatherTarget.amount -= amt;
            if (u.carrying >= CARRY_MAX || u.gatherTarget.amount <= 0) {
              u.returning = true;
              u.gathering = false;
              if (u.gatherTarget.amount <= 0) u.gatherTarget = null;
            }
          }
          continue; // Don't move while gathering
        } else {
          u.gathering = false;
        }
      }
    }
    
    // Attack target (including bases)
    if (u.targetUnit) {
      const target = u.targetUnit;
      let tx = target.x || target.x;
      let ty = target.y || target.y;
      const td = dist(u.x, u.y, tx, ty);
      
      if (td <= u.range + (target.isBase ? BASE_RADIUS : (target.radius || 8))) {
        // In range - attack
        if (now - u.lastAttack >= u.atkSpeed) {
          u.lastAttack = now;
          
          if (target.isBase) {
            const base = players[target.playerId];
            base.baseHp -= u.damage;
            spawnParticle(tx, ty, '#f84', 8);
            if (base.baseHp <= 0) {
              base.alive = false;
              base.baseHp = 0;
            }
          } else if (target.alive) {
            // Projectile for tanks, instant for others
            if (u.type === 'tank') {
              projectiles.push({
                x: u.x, y: u.y,
                tx: target.x, ty: target.y,
                target: target,
                damage: u.damage,
                playerId: u.playerId,
                speed: 5,
                life: 60
              });
            } else {
              target.hp -= u.damage;
              spawnParticle(target.x, target.y, '#f44', 5);
              if (target.hp <= 0) {
                killUnit(target, u.playerId);
              }
            }
          }
        }
      } else {
        // Move toward target
        moveToward(u, tx, ty, dt);
      }
    }
    // Move to point
    else if (u.targetX !== null && u.targetY !== null) {
      const td = dist(u.x, u.y, u.targetX, u.targetY);
      if (td < 5) {
        u.targetX = null;
        u.targetY = null;
      } else {
        moveToward(u, u.targetX, u.targetY, dt);
      }
    }
    // Auto-attack nearby enemies (player units)
    else if (u.type !== 'worker' || u.carrying === 0) {
      let nearestEnemy = null, nd = Infinity;
      for (let e of units) {
        if (!e.alive || e.playerId === u.playerId) continue;
        const d = dist(u.x, u.y, e.x, e.y);
        if (d < u.range + 60 && d < nd) { nd = d; nearestEnemy = e; }
      }
      if (nearestEnemy) u.targetUnit = nearestEnemy;
    }
  }
  
  // Remove dead units
  units = units.filter(u => u.alive);
  selectedUnits = selectedUnits.filter(u => u.alive);
}

function moveToward(u, tx, ty, dt) {
  const dx = tx - u.x;
  const dy = ty - u.y;
  const d = Math.sqrt(dx*dx + dy*dy);
  if (d < 1) return;
  
  const mx = (dx/d) * u.speed;
  const my = (dy/d) * u.speed;
  
  let nx = u.x + mx;
  let ny = u.y + my;
  
  // Simple collision with other units
  for (let other of units) {
    if (other === u || !other.alive) continue;
    const od = dist(nx, ny, other.x, other.y);
    const minD = u.radius + other.radius;
    if (od < minD && od > 0) {
      const push = (minD - od) * 0.3;
      nx += ((nx - other.x) / od) * push;
      ny += ((ny - other.y) / od) * push;
    }
  }
  
  // Clamp to map
  nx = Math.max(u.radius, Math.min(MAP_W - u.radius, nx));
  ny = Math.max(u.radius, Math.min(MAP_H - u.radius, ny));
  
  u.x = nx;
  u.y = ny;
}

function killUnit(unit, killerPlayerId) {
  unit.alive = false;
  unit.selected = false;
  spawnParticle(unit.x, unit.y, unit.playerId === 0 ? '#4af' : '#f44', 12);
  if (killerPlayerId === 0) {
    players[0].unitsKilled++;
  } else {
    players[1].unitsKilled++;
  }
}

// === PROJECTILES ===
function updateProjectiles(dt) {
  for (let p of projectiles) {
    if (p.target && p.target.alive) {
      p.tx = p.target.x;
      p.ty = p.target.y;
    }
    const dx = p.tx - p.x;
    const dy = p.ty - p.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < p.speed + 5) {
      // Hit
      if (p.target && p.target.alive) {
        p.target.hp -= p.damage;
        spawnParticle(p.target.x, p.target.y, '#ff4', 8);
        if (p.target.hp <= 0) {
          killUnit(p.target, p.playerId);
        }
      }
      p.life = 0;
    } else {
      p.x += (dx/d) * p.speed;
      p.y += (dy/d) * p.speed;
    }
    p.life--;
  }
  projectiles = projectiles.filter(p => p.life > 0);
}

// === PARTICLES ===
function updateParticles() {
  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.life--;
  }
  particles = particles.filter(p => p.life > 0);
}

// === PRODUCTION QUEUE ===
function updateProduction() {
  // Player production
  if (prodQueue.length > 0 && players[0].alive) {
    prodQueue[0].timer--;
    if (prodQueue[0].timer <= 0) {
      const type = prodQueue[0].type;
      const angle = Math.random() * Math.PI * 2;
      const u = spawnUnit(0, type, players[0].baseX + Math.cos(angle)*35, players[0].baseY + Math.sin(angle)*35);
      prodQueue.shift();
    }
  }
}

// === RENDERING ===
function render(now) {
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
  
  const cx = camera.x, cy = camera.y;
  
  // Draw ground grid
  ctx.strokeStyle = '#1a1a2e';
  ctx.lineWidth = 0.5;
  for (let x = -cx % TILE; x < CANVAS_W; x += TILE) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_H); ctx.stroke();
  }
  for (let y = -cy % TILE; y < CANVAS_H; y += TILE) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_W, y); ctx.stroke();
  }
  
  // Draw minerals
  for (let m of minerals) {
    if (!isVisible(m.x, m.y)) continue;
    if (m.amount <= 0) continue;
    const sx = m.x - cx, sy = m.y - cy;
    if (sx < -20 || sx > CANVAS_W+20 || sy < -20 || sy > CANVAS_H+20) continue;
    
    const a = m.amount / m.maxAmount;
    ctx.fillStyle = `rgba(100,200,255,${0.4 + a*0.6})`;
    ctx.shadowColor = '#4cf';
    ctx.shadowBlur = 6;
    const sz = 4 + a * 6;
    ctx.beginPath();
    // Crystal shape
    ctx.moveTo(sx, sy - sz);
    ctx.lineTo(sx + sz*0.6, sy);
    ctx.lineTo(sx, sy + sz*0.5);
    ctx.lineTo(sx - sz*0.6, sy);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  
  // Draw bases
  for (let p of players) {
    if (!p.alive && p.baseHp <= 0) {
      // Destroyed base rubble
      const sx = p.baseX - cx, sy = p.baseY - cy;
      if (p.id === 1 && !isVisible(p.baseX, p.baseY)) continue;
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(sx, sy, BASE_RADIUS * 0.7, 0, Math.PI*2);
      ctx.fill();
      continue;
    }
    const sx = p.baseX - cx, sy = p.baseY - cy;
    if (p.id === 1 && !isVisible(p.baseX, p.baseY)) continue;
    if (sx < -40 || sx > CANVAS_W+40 || sy < -40 || sy > CANVAS_H+40) continue;
    
    // Base
    ctx.fillStyle = p.id === 0 ? '#234' : '#422';
    ctx.strokeStyle = p.id === 0 ? '#4af' : '#f44';
    ctx.lineWidth = 2;
    ctx.shadowColor = ctx.strokeStyle;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.rect(sx - BASE_RADIUS, sy - BASE_RADIUS, BASE_RADIUS*2, BASE_RADIUS*2);
    ctx.fill();
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // HP bar
    const hpPct = p.baseHp / BASE_HP;
    ctx.fillStyle = '#300';
    ctx.fillRect(sx - BASE_RADIUS, sy - BASE_RADIUS - 8, BASE_RADIUS*2, 4);
    ctx.fillStyle = hpPct > 0.5 ? '#4f4' : hpPct > 0.25 ? '#ff4' : '#f44';
    ctx.fillRect(sx - BASE_RADIUS, sy - BASE_RADIUS - 8, BASE_RADIUS*2 * hpPct, 4);
    
    // Production indicator
    if (p.id === 0 && prodQueue.length > 0) {
      const prog = 1 - prodQueue[0].timer / prodQueue[0].maxTimer;
      ctx.fillStyle = '#e84';
      ctx.fillRect(sx - BASE_RADIUS, sy + BASE_RADIUS + 4, BASE_RADIUS*2 * prog, 3);
      ctx.strokeStyle = '#e84';
      ctx.strokeRect(sx - BASE_RADIUS, sy + BASE_RADIUS + 4, BASE_RADIUS*2, 3);
    }
    if (p.id === 1 && p.prodTimer > 0 && p.prodType) {
      // Only show if visible
    }
    
    // Base label
    ctx.fillStyle = p.id === 0 ? '#4af' : '#f44';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(p.id === 0 ? 'BASE' : 'ENEMY', sx, sy + 4);
  }
  
  // Draw units
  for (let u of units) {
    if (u.playerId === 1 && !isVisible(u.x, u.y)) continue;
    const sx = u.x - cx, sy = u.y - cy;
    if (sx < -20 || sx > CANVAS_W+20 || sy < -20 || sy > CANVAS_H+20) continue;
    
    const pColor = u.playerId === 0 ? players[0].color : players[1].color;
    const tColor = UNIT_DEFS[u.type].color;
    
    // Unit body
    ctx.fillStyle = tColor;
    ctx.strokeStyle = pColor;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = pColor;
    ctx.shadowBlur = u.selected ? 10 : 3;
    
    ctx.beginPath();
    if (u.type === 'worker') {
      ctx.arc(sx, sy, u.radius, 0, Math.PI*2);
    } else if (u.type === 'soldier') {
      // Triangle
      ctx.moveTo(sx, sy - u.radius);
      ctx.lineTo(sx + u.radius, sy + u.radius*0.7);
      ctx.lineTo(sx - u.radius, sy + u.radius*0.7);
      ctx.closePath();
    } else { // tank
      ctx.rect(sx - u.radius, sy - u.radius*0.7, u.radius*2, u.radius*1.4);
    }
    ctx.fill();
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Selection ring
    if (u.selected) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.arc(sx, sy, u.radius + 4, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    
    // HP bar
    if (u.hp < u.maxHp) {
      const hpPct = u.hp / u.maxHp;
      const barW = u.radius * 2 + 4;
      ctx.fillStyle = '#300';
      ctx.fillRect(sx - barW/2, sy - u.radius - 6, barW, 3);
      ctx.fillStyle = hpPct > 0.5 ? '#4f4' : hpPct > 0.25 ? '#ff4' : '#f44';
      ctx.fillRect(sx - barW/2, sy - u.radius - 6, barW * hpPct, 3);
    }
    
    // Carrying indicator for workers
    if (u.type === 'worker' && u.carrying > 0) {
      ctx.fillStyle = '#4cf';
      ctx.fillRect(sx - 2, sy - 2, 4, 4);
    }
  }
  
  // Projectiles
  for (let p of projectiles) {
    if (!isVisible(p.x, p.y)) continue;
    const sx = p.x - cx, sy = p.y - cy;
    ctx.fillStyle = '#ff4';
    ctx.shadowColor = '#ff4';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(sx, sy, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  
  // Particles
  for (let p of particles) {
    if (!isVisible(p.x, p.y)) continue;
    const sx = p.x - cx, sy = p.y - cy;
    const a = p.life / p.maxLife;
    ctx.globalAlpha = a;
    ctx.fillStyle = p.color;
    ctx.fillRect(sx - p.size/2, sy - p.size/2, p.size * a, p.size * a);
    ctx.globalAlpha = 1;
  }
  
  // Fog of war
  const fogW = Math.ceil(MAP_W / TILE);
  const fogH = Math.ceil(MAP_H / TILE);
  for (let fy = Math.floor(cy/TILE); fy <= Math.floor((cy+CANVAS_H)/TILE); fy++) {
    for (let fx = Math.floor(cx/TILE); fx <= Math.floor((cx+CANVAS_W)/TILE); fx++) {
      if (fx < 0 || fx >= fogW || fy < 0 || fy >= fogH) continue;
      const v = fogGrid[fy][fx];
      if (v >= 1) continue;
      const sx = fx * TILE - cx;
      const sy = fy * TILE - cy;
      ctx.fillStyle = `rgba(10,10,20,${1 - v})`;
      ctx.fillRect(sx, sy, TILE+1, TILE+1);
    }
  }
  
  // Selection box
  if (selBox && selBox.w > 2) {
    ctx.strokeStyle = '#4af';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(selBox.x, selBox.y, selBox.w, selBox.h);
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(68,170,255,0.1)';
    ctx.fillRect(selBox.x, selBox.y, selBox.w, selBox.h);
  }
  
  // === MINIMAP ===
  mctx.fillStyle = '#111';
  mctx.fillRect(0, 0, 100, 67);
  
  // Fog on minimap
  const mScaleX = 100/MAP_W, mScaleY = 67/MAP_H;
  
  // Minerals
  for (let m of minerals) {
    if (m.amount <= 0) continue;
    mctx.fillStyle = '#4cf';
    mctx.fillRect(m.x * mScaleX - 1, m.y * mScaleY - 1, 2, 2);
  }
  
  // Bases
  for (let p of players) {
    if (p.id === 1 && !isVisible(p.baseX, p.baseY)) continue;
    mctx.fillStyle = p.id === 0 ? '#4af' : '#f44';
    mctx.fillRect(p.baseX * mScaleX - 3, p.baseY * mScaleY - 3, 6, 6);
  }
  
  // Units
  for (let u of units) {
    if (u.playerId === 1 && !isVisible(u.x, u.y)) continue;
    mctx.fillStyle = u.playerId === 0 ? '#4af' : '#f44';
    mctx.fillRect(u.x * mScaleX - 1, u.y * mScaleY - 1, 2, 2);
  }
  
  // Camera rect
  mctx.strokeStyle = '#fff';
  mctx.lineWidth = 1;
  mctx.strokeRect(cx * mScaleX, cy * mScaleY, CANVAS_W * mScaleX, CANVAS_H * mScaleY);
}

// === HUD UPDATE ===
function updateHUD() {
  const p = players[0];
  const myUnits = units.filter(u => u.alive && u.playerId === 0);
  const workers = myUnits.filter(u => u.type === 'worker').length;
  const army = myUnits.length - workers;
  
  document.getElementById('res-minerals').textContent = `Minerals: ${p.minerals}`;
  document.getElementById('res-units').textContent = `Units: ${myUnits.length} / ${MAX_UNITS}`;
  document.getElementById('res-supply').textContent = `Workers: ${workers} | Army: ${army}`;
  
  // Buttons
  document.getElementById('btn-worker').disabled = p.minerals < 50 || myUnits.length >= MAX_UNITS || prodQueue.length >= 5;
  document.getElementById('btn-soldier').disabled = p.minerals < 75 || myUnits.length >= MAX_UNITS || prodQueue.length >= 5;
  document.getElementById('btn-tank').disabled = p.minerals < 150 || myUnits.length >= MAX_UNITS || prodQueue.length >= 5;
  
  // Score
  score = p.unitsKilled * 50 + p.resourcesGathered;
  document.getElementById('score-display').textContent = `SCORE: ${score}`;
  
  // Timer
  const min = Math.floor(gameTimer / 60);
  const sec = Math.floor(gameTimer % 60);
  document.getElementById('timer-display').textContent = `${min}:${sec.toString().padStart(2,'0')}`;
  
  // Selection info
  if (selectedUnits.length === 0) {
    document.getElementById('selection-info').textContent = 'No selection';
  } else if (selectedUnits.length === 1) {
    const u = selectedUnits[0];
    document.getElementById('selection-info').innerHTML = 
      `${u.type.toUpperCase()} HP:${u.hp}/${u.maxHp}` + 
      (u.type === 'worker' ? ` Carry:${u.carrying}` : '');
  } else {
    const types = {};
    for (let u of selectedUnits) { types[u.type] = (types[u.type]||0) + 1; }
    document.getElementById('selection-info').textContent = 
      Object.entries(types).map(([t,c]) => `${c}${t[0].toUpperCase()}`).join(' ');
  }
  
  // Queue indicator on buttons
  const queueTypes = {};
  for (let q of prodQueue) { queueTypes[q.type] = (queueTypes[q.type]||0)+1; }
  document.getElementById('btn-worker').textContent = `Worker $50${queueTypes.worker ? ' ('+queueTypes.worker+')':''}`;
  document.getElementById('btn-soldier').textContent = `Soldier $75${queueTypes.soldier ? ' ('+queueTypes.soldier+')':''}`;
  document.getElementById('btn-tank').textContent = `Tank $150${queueTypes.tank ? ' ('+queueTypes.tank+')':''}`;
}

// === GAME OVER ===
function showGameOver(message) {
  gameState = 'gameover';
  const overlay = document.getElementById('overlay');
  overlay.classList.remove('hidden');
  overlay.innerHTML = `
    <h1>${message}</h1>
    <p>Score: ${score}</p>
    <p>Units killed: ${players[0].unitsKilled} | Resources gathered: ${players[0].resourcesGathered}</p>
    <button onclick="initGame()">PLAY AGAIN</button>
  `;
}

// === MAIN LOOP ===
let lastTime = 0;
let accumulator = 0;
const TICK = 1000/60;

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = timestamp - lastTime;
  lastTime = timestamp;
  
  if (gameState === 'playing') {
    // Cap dt to avoid spiraling
    dt = Math.min(dt, 50);
    accumulator += dt;
    
    while (accumulator >= TICK) {
      accumulator -= TICK;
      const tickDt = 1;
      
      updateCamera();
      updateFog();
      updateUnits(tickDt, timestamp);
      updateProjectiles(tickDt);
      updateParticles();
      updateProduction();
      updateAI(TICK / 1000);
      
      // Timer
      gameTimer -= TICK / 1000;
      if (gameTimer <= 0) {
        gameTimer = 0;
        // Score-based win
        const p0score = players[0].unitsKilled * 50 + players[0].resourcesGathered;
        const p1score = players[1].unitsKilled * 50 + players[1].resourcesGathered;
        if (p0score > p1score) showGameOver('TIME UP - VICTORY!');
        else if (p0score < p1score) showGameOver('TIME UP - DEFEAT');
        else showGameOver('TIME UP - DRAW');
      }
      
      // Win/loss check
      if (!players[0].alive) showGameOver('BASE DESTROYED - DEFEAT');
      else if (!players[1].alive) showGameOver('ENEMY DESTROYED - VICTORY!');
    }
    
    updateHUD();
  }
  
  render(timestamp);
  requestAnimationFrame(gameLoop);
}

// === START ===
document.getElementById('start-btn').addEventListener('click', initGame);
requestAnimationFrame(gameLoop);
</script>
<script src="../recorder.js"></script>
</body>
</html>

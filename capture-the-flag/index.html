<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Capture the Flag</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #44f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 68, 255, 0.5); }
    h1 { color: #44f; font-size: 1.8rem; text-shadow: 0 0 15px rgba(68, 68, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #44f; }
    .class-select {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .class-btn {
      background: #2a2a4e;
      color: #aaa;
      border: 1px solid #44f;
      padding: 4px 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      border-radius: 3px;
    }
    .class-btn:hover { background: #3a3a5e; }
    .class-btn.active { background: #44f; color: #fff; }
    canvas {
      border: 2px solid #44f;
      box-shadow: 0 0 20px rgba(68, 68, 255, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #44f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 6px; }
    .controls-info {
      width: 600px;
      margin-top: 10px;
      font-size: 0.75rem;
      color: #667;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CAPTURE THE FLAG</h1>
  </div>
  <div class="score-bar">
    <div>Blue: <span id="blueScore">0</span>/3 | Kills: <span id="blueKills">0</span></div>
    <div>Score: <span id="score">0</span></div>
    <div>Red: <span id="redScore">0</span>/3 | Kills: <span id="redKills">0</span></div>
  </div>
  <div class="class-select">
    <button class="class-btn active" data-cls="scout">Scout</button>
    <button class="class-btn" data-cls="heavy">Heavy</button>
    <button class="class-btn" data-cls="medic">Medic</button>
    <button class="class-btn" data-cls="engineer">Engineer</button>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">CAPTURE THE FLAG</h2>
      <p id="overlayText">Choose class above, then click to start</p>
      <p>WASD=Move | Mouse=Aim+Shoot | E=Interact | Q=Ability</p>
    </div>
  </div>
  <div class="controls-info">WASD move | Mouse aim+click shoot | E interact near flag/turret | Q class ability | First to 3 captures wins</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const blueScoreEl = document.getElementById('blueScore');
    const redScoreEl = document.getElementById('redScore');
    const blueKillsEl = document.getElementById('blueKills');
    const redKillsEl = document.getElementById('redKills');
    const scoreEl = document.getElementById('score');

    let gameState = 'menu';
    let score = 0;

    // Map constants
    const MAP_W = 1200, MAP_H = 800;
    const TILE = 40;
    const COLS = MAP_W / TILE, ROWS = MAP_H / TILE;

    // Class definitions
    const CLASSES = {
      scout:    { speed: 3.2, hp: 60,  damage: 8,  fireRate: 180, ability: 'dash',     abilityCD: 3000, color: '#6cf', label: 'SCT' },
      heavy:    { speed: 1.6, hp: 150, damage: 18, fireRate: 400, ability: 'shield',   abilityCD: 8000, color: '#f66', label: 'HVY' },
      medic:    { speed: 2.2, hp: 80,  damage: 6,  fireRate: 250, ability: 'heal',     abilityCD: 5000, color: '#6f6', label: 'MED' },
      engineer: { speed: 2.0, hp: 90,  damage: 10, fireRate: 300, ability: 'turret',   abilityCD: 10000,color: '#ff6', label: 'ENG' }
    };

    // Walls/obstacles on the map
    let walls = [];
    let turrets = [];
    let bullets = [];
    let particles = [];
    let players = [];
    let flags = { blue: null, red: null };
    let bases = { blue: { x: 80, y: MAP_H / 2 }, red: { x: MAP_W - 80, y: MAP_H / 2 } };
    let teamCaptures = { blue: 0, red: 0 };
    let teamKills = { blue: 0, red: 0 };
    let camera = { x: 0, y: 0 };
    let mouse = { x: W / 2, y: H / 2 };
    let keys = {};
    let mouseDown = false;
    let selectedClass = 'scout';
    let humanPlayer = null;
    let lastTime = 0;
    let roundOver = false;
    let respawnMessages = [];

    // Class button handling
    document.querySelectorAll('.class-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gameState !== 'menu') return;
        document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedClass = btn.dataset.cls;
      });
    });

    function generateMap() {
      walls = [];
      // Center barriers
      for (let y = 4; y < ROWS - 4; y += 3) {
        walls.push({ x: COLS / 2 * TILE - TILE, y: y * TILE, w: TILE * 2, h: TILE });
      }
      // Scattered cover
      const rng = (a, b) => Math.floor(Math.random() * (b - a)) + a;
      for (let i = 0; i < 30; i++) {
        let wx = rng(4, COLS - 4) * TILE;
        let wy = rng(2, ROWS - 2) * TILE;
        let ww = rng(1, 3) * TILE;
        let wh = rng(1, 2) * TILE;
        // Keep clear of bases
        if (wx < 200 || wx + ww > MAP_W - 200) continue;
        walls.push({ x: wx, y: wy, w: ww, h: wh });
      }
      // Side walls (boundary cover near bases)
      walls.push({ x: 200, y: 100, w: TILE, h: TILE * 4 });
      walls.push({ x: 200, y: MAP_H - 100 - TILE * 4, w: TILE, h: TILE * 4 });
      walls.push({ x: MAP_W - 200 - TILE, y: 100, w: TILE, h: TILE * 4 });
      walls.push({ x: MAP_W - 200 - TILE, y: MAP_H - 100 - TILE * 4, w: TILE, h: TILE * 4 });
    }

    function createPlayer(team, cls, isHuman) {
      const base = bases[team];
      const classDef = CLASSES[cls];
      const offsetX = (Math.random() - 0.5) * 60;
      const offsetY = (Math.random() - 0.5) * 120;
      return {
        x: base.x + offsetX,
        y: base.y + offsetY,
        vx: 0, vy: 0,
        team: team,
        cls: cls,
        isHuman: isHuman,
        hp: classDef.hp,
        maxHp: classDef.hp,
        speed: classDef.speed,
        damage: classDef.damage,
        fireRate: classDef.fireRate,
        lastFire: 0,
        angle: team === 'blue' ? 0 : Math.PI,
        alive: true,
        respawnTimer: 0,
        carryingFlag: null,
        abilityCD: 0,
        abilityCooldown: classDef.abilityCD,
        abilityActive: 0,
        shieldHP: 0,
        dashTimer: 0,
        // AI state
        aiRole: null,
        aiTarget: null,
        aiPathTimer: 0,
        aiGoal: null,
        kills: 0,
        radius: 10,
        label: classDef.label
      };
    }

    function initGame() {
      players = [];
      bullets = [];
      turrets = [];
      particles = [];
      respawnMessages = [];
      teamCaptures = { blue: 0, red: 0 };
      teamKills = { blue: 0, red: 0 };
      score = 0;
      roundOver = false;

      generateMap();

      // Blue team: human + 3 AI
      const aiClasses = ['heavy', 'medic', 'engineer'];
      // Remove human's class from AI pool and replace
      const remaining = ['scout', 'heavy', 'medic', 'engineer'].filter(c => c !== selectedClass);
      humanPlayer = createPlayer('blue', selectedClass, true);
      players.push(humanPlayer);
      for (let i = 0; i < 3; i++) {
        const p = createPlayer('blue', remaining[i], false);
        p.aiRole = i === 0 ? 'attacker' : (i === 1 ? 'medic_support' : 'defender');
        players.push(p);
      }

      // Red team: 4 AI
      const redClasses = ['scout', 'heavy', 'medic', 'engineer'];
      for (let i = 0; i < 4; i++) {
        const p = createPlayer('red', redClasses[i], false);
        p.aiRole = i < 2 ? 'attacker' : (i === 2 ? 'medic_support' : 'defender');
        players.push(p);
      }

      // Flags
      flags.blue = { x: bases.blue.x, y: bases.blue.y, team: 'blue', carrier: null, atBase: true };
      flags.red = { x: bases.red.x, y: bases.red.y, team: 'red', carrier: null, atBase: true };

      camera.x = humanPlayer.x - W / 2;
      camera.y = humanPlayer.y - H / 2;
    }

    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    function rectCollide(ax, ay, ar, rect) {
      const cx = Math.max(rect.x, Math.min(ax, rect.x + rect.w));
      const cy = Math.max(rect.y, Math.min(ay, rect.y + rect.h));
      return Math.hypot(ax - cx, ay - cy) < ar;
    }

    function lineOfSight(a, b) {
      const dx = b.x - a.x, dy = b.y - a.y;
      const d = Math.hypot(dx, dy);
      const steps = Math.ceil(d / 20);
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const px = a.x + dx * t, py = a.y + dy * t;
        for (const w of walls) {
          if (px > w.x && px < w.x + w.w && py > w.y && py < w.y + w.h) return false;
        }
      }
      return true;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 20 + Math.random() * 20,
          color: color,
          size: 1 + Math.random() * 2
        });
      }
    }

    function fireBullet(p) {
      const now = performance.now();
      if (now - p.lastFire < p.fireRate) return;
      p.lastFire = now;
      const speed = 7;
      bullets.push({
        x: p.x + Math.cos(p.angle) * 14,
        y: p.y + Math.sin(p.angle) * 14,
        vx: Math.cos(p.angle) * speed,
        vy: Math.sin(p.angle) * speed,
        team: p.team,
        damage: p.damage,
        life: 80,
        owner: p
      });
    }

    function useAbility(p) {
      if (p.abilityCD > 0 || !p.alive) return;
      p.abilityCD = p.abilityCooldown;

      if (p.cls === 'scout') {
        // Dash forward
        p.dashTimer = 200;
        p.vx = Math.cos(p.angle) * 8;
        p.vy = Math.sin(p.angle) * 8;
      } else if (p.cls === 'heavy') {
        // Shield
        p.shieldHP = 80;
        p.abilityActive = 3000;
      } else if (p.cls === 'medic') {
        // Heal nearby allies
        for (const ally of players) {
          if (ally.team === p.team && ally.alive && dist(p, ally) < 100) {
            ally.hp = Math.min(ally.maxHp, ally.hp + 30);
            spawnParticles(ally.x, ally.y, '#6f6', 6);
          }
        }
      } else if (p.cls === 'engineer') {
        // Place turret
        if (turrets.filter(t => t.team === p.team).length < 3) {
          turrets.push({
            x: p.x - Math.cos(p.angle) * 25,
            y: p.y - Math.sin(p.angle) * 25,
            team: p.team,
            hp: 80,
            maxHp: 80,
            damage: 5,
            fireRate: 500,
            lastFire: 0,
            range: 150,
            angle: p.angle
          });
        }
      }
    }

    function respawnPlayer(p) {
      const base = bases[p.team];
      p.x = base.x + (Math.random() - 0.5) * 60;
      p.y = base.y + (Math.random() - 0.5) * 120;
      p.hp = p.maxHp;
      p.alive = true;
      p.respawnTimer = 0;
      p.carryingFlag = null;
      p.shieldHP = 0;
      p.abilityActive = 0;
      p.vx = 0;
      p.vy = 0;
    }

    function dropFlag(p) {
      if (!p.carryingFlag) return;
      const flagTeam = p.carryingFlag;
      const flag = flags[flagTeam];
      flag.x = p.x;
      flag.y = p.y;
      flag.carrier = null;
      flag.atBase = false;
      p.carryingFlag = null;
    }

    // AI behavior
    function updateAI(p, dt) {
      if (!p.alive || p.isHuman) return;

      const now = performance.now();
      const enemyTeam = p.team === 'blue' ? 'red' : 'blue';
      const enemyFlag = flags[enemyTeam];
      const ownFlag = flags[p.team];
      const base = bases[p.team];
      const enemyBase = bases[enemyTeam];

      // Find nearest enemy
      let nearestEnemy = null;
      let nearestEnemyDist = Infinity;
      for (const e of players) {
        if (e.team !== p.team && e.alive) {
          const d = dist(p, e);
          if (d < nearestEnemyDist) {
            nearestEnemy = e;
            nearestEnemyDist = d;
          }
        }
      }

      // Find nearest injured ally (for medic)
      let nearestInjured = null;
      let nearestInjuredDist = Infinity;
      if (p.cls === 'medic' || p.aiRole === 'medic_support') {
        for (const a of players) {
          if (a.team === p.team && a.alive && a !== p && a.hp < a.maxHp * 0.7) {
            const d = dist(p, a);
            if (d < nearestInjuredDist) {
              nearestInjured = a;
              nearestInjuredDist = d;
            }
          }
        }
      }

      let goalX = p.x, goalY = p.y;
      let shouldShoot = false;

      // Role-based behavior
      if (p.carryingFlag) {
        // Carrying flag - head home!
        goalX = base.x;
        goalY = base.y;
        // Shoot enemies in the way
        if (nearestEnemy && nearestEnemyDist < 200 && lineOfSight(p, nearestEnemy)) {
          shouldShoot = true;
          p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
        }
      } else if (p.aiRole === 'defender') {
        // Guard own flag
        if (!ownFlag.atBase && !ownFlag.carrier) {
          // Flag dropped, go recover it
          goalX = ownFlag.x;
          goalY = ownFlag.y;
        } else if (ownFlag.carrier && ownFlag.carrier.team !== p.team) {
          // Chase flag carrier
          goalX = ownFlag.carrier.x;
          goalY = ownFlag.carrier.y;
        } else {
          // Patrol near base
          const angle = (now / 3000 + (p === players[0] ? 0 : Math.PI)) % (Math.PI * 2);
          goalX = base.x + Math.cos(angle) * 60;
          goalY = base.y + Math.sin(angle) * 80;
        }
        if (nearestEnemy && nearestEnemyDist < 200 && lineOfSight(p, nearestEnemy)) {
          shouldShoot = true;
          p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
        }
      } else if (p.aiRole === 'medic_support') {
        // Follow nearest ally, prioritize injured
        if (nearestInjured && nearestInjuredDist < 300) {
          goalX = nearestInjured.x;
          goalY = nearestInjured.y;
          // Use heal ability when close
          if (nearestInjuredDist < 100 && p.abilityCD <= 0) {
            useAbility(p);
          }
        } else {
          // Follow nearest attacker ally
          let nearestAlly = null;
          let nad = Infinity;
          for (const a of players) {
            if (a.team === p.team && a.alive && a !== p && a.aiRole === 'attacker') {
              const d = dist(p, a);
              if (d < nad) { nearestAlly = a; nad = d; }
            }
          }
          if (nearestAlly) {
            goalX = nearestAlly.x + 30;
            goalY = nearestAlly.y + 20;
          }
        }
        if (nearestEnemy && nearestEnemyDist < 180 && lineOfSight(p, nearestEnemy)) {
          shouldShoot = true;
          p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
        }
      } else {
        // Attacker - go for enemy flag
        if (enemyFlag.atBase || (!enemyFlag.carrier && !enemyFlag.atBase)) {
          goalX = enemyFlag.x;
          goalY = enemyFlag.y;
        } else {
          // Flag is taken, engage enemies
          if (nearestEnemy) {
            goalX = nearestEnemy.x;
            goalY = nearestEnemy.y;
          }
        }
        if (nearestEnemy && nearestEnemyDist < 220 && lineOfSight(p, nearestEnemy)) {
          shouldShoot = true;
          p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
          // Engage: stop moving if close
          if (nearestEnemyDist < 120) {
            goalX = p.x;
            goalY = p.y;
          }
        }
      }

      // Move toward goal with obstacle avoidance
      const dx = goalX - p.x;
      const dy = goalY - p.y;
      const goalDist = Math.hypot(dx, dy);
      if (goalDist > 5) {
        let moveAngle = Math.atan2(dy, dx);

        // Simple wall avoidance
        const lookAhead = 30;
        const testX = p.x + Math.cos(moveAngle) * lookAhead;
        const testY = p.y + Math.sin(moveAngle) * lookAhead;
        let blocked = false;
        for (const w of walls) {
          if (rectCollide(testX, testY, p.radius + 5, w)) {
            blocked = true;
            // Try perpendicular directions
            const alt1 = moveAngle + Math.PI / 3;
            const alt2 = moveAngle - Math.PI / 3;
            const t1x = p.x + Math.cos(alt1) * lookAhead;
            const t1y = p.y + Math.sin(alt1) * lookAhead;
            let b1 = false;
            for (const w2 of walls) {
              if (rectCollide(t1x, t1y, p.radius + 5, w2)) { b1 = true; break; }
            }
            if (!b1) { moveAngle = alt1; break; }
            moveAngle = alt2;
            break;
          }
        }

        const spd = p.dashTimer > 0 ? p.speed * 2.5 : p.speed;
        p.vx = Math.cos(moveAngle) * spd;
        p.vy = Math.sin(moveAngle) * spd;
        if (!shouldShoot) p.angle = moveAngle;
      } else {
        p.vx = 0;
        p.vy = 0;
      }

      // AI ability usage
      if (p.abilityCD <= 0) {
        if (p.cls === 'scout' && nearestEnemy && nearestEnemyDist < 150) {
          useAbility(p);
        } else if (p.cls === 'heavy' && nearestEnemy && nearestEnemyDist < 130) {
          useAbility(p);
        } else if (p.cls === 'engineer' && p.aiRole === 'defender' && dist(p, base) < 120) {
          useAbility(p);
        }
      }

      if (shouldShoot) fireBullet(p);
    }

    function update(dt) {
      if (gameState !== 'playing' || roundOver) return;
      const now = performance.now();

      // Update human input
      if (humanPlayer && humanPlayer.alive) {
        const p = humanPlayer;
        let mx = 0, my = 0;
        if (keys['w'] || keys['arrowup']) my -= 1;
        if (keys['s'] || keys['arrowdown']) my += 1;
        if (keys['a'] || keys['arrowleft']) mx -= 1;
        if (keys['d'] || keys['arrowright']) mx += 1;
        const len = Math.hypot(mx, my) || 1;
        const spd = p.dashTimer > 0 ? p.speed * 2.5 : p.speed;
        p.vx = (mx / len) * spd * (mx || my ? 1 : 0);
        p.vy = (my / len) * spd * (mx || my ? 1 : 0);

        // Aim at mouse
        const worldMouseX = mouse.x + camera.x;
        const worldMouseY = mouse.y + camera.y;
        p.angle = Math.atan2(worldMouseY - p.y, worldMouseX - p.x);

        if (mouseDown) fireBullet(p);
      }

      // Update all players
      for (const p of players) {
        if (!p.alive) {
          p.respawnTimer -= dt;
          if (p.respawnTimer <= 0) respawnPlayer(p);
          continue;
        }

        // Update AI
        if (!p.isHuman) updateAI(p, dt);

        // Cooldowns
        if (p.abilityCD > 0) p.abilityCD -= dt * 1000;
        if (p.dashTimer > 0) p.dashTimer -= dt * 1000;
        if (p.abilityActive > 0) {
          p.abilityActive -= dt * 1000;
          if (p.abilityActive <= 0) p.shieldHP = 0;
        }

        // Apply movement
        let nx = p.x + p.vx;
        let ny = p.y + p.vy;

        // Wall collision
        for (const w of walls) {
          if (rectCollide(nx, ny, p.radius, w)) {
            // Push out
            const cx = Math.max(w.x, Math.min(nx, w.x + w.w));
            const cy = Math.max(w.y, Math.min(ny, w.y + w.h));
            const pushDist = Math.hypot(nx - cx, ny - cy);
            if (pushDist < p.radius && pushDist > 0) {
              const pushX = (nx - cx) / pushDist;
              const pushY = (ny - cy) / pushDist;
              nx = cx + pushX * p.radius;
              ny = cy + pushY * p.radius;
            }
          }
        }

        // Map bounds
        nx = Math.max(p.radius, Math.min(MAP_W - p.radius, nx));
        ny = Math.max(p.radius, Math.min(MAP_H - p.radius, ny));
        p.x = nx;
        p.y = ny;

        // Flag pickup (E key for human, auto for AI)
        const enemyTeam = p.team === 'blue' ? 'red' : 'blue';
        const enemyFlag = flags[enemyTeam];
        const ownFlag = flags[p.team];

        if (!p.carryingFlag && !enemyFlag.carrier) {
          const fd = dist(p, enemyFlag);
          if (fd < 25) {
            if (!p.isHuman || keys['e']) {
              p.carryingFlag = enemyTeam;
              enemyFlag.carrier = p;
              spawnParticles(p.x, p.y, p.team === 'blue' ? '#4488ff' : '#ff4444', 15);
            }
          }
        }

        // Return own flag to base
        if (!ownFlag.atBase && !ownFlag.carrier && dist(p, ownFlag) < 25) {
          ownFlag.x = bases[p.team].x;
          ownFlag.y = bases[p.team].y;
          ownFlag.atBase = true;
          spawnParticles(ownFlag.x, ownFlag.y, p.team === 'blue' ? '#4488ff' : '#ff4444', 12);
        }

        // Score: bring enemy flag to own base
        if (p.carryingFlag && dist(p, bases[p.team]) < 40) {
          // Must own flag be at base? Yes, classic CTF rule
          if (ownFlag.atBase) {
            teamCaptures[p.team]++;
            if (p.team === 'blue') score += 50;
            spawnParticles(bases[p.team].x, bases[p.team].y, '#fff', 30);

            // Reset flag
            const capturedTeam = p.carryingFlag;
            flags[capturedTeam].x = bases[capturedTeam].x;
            flags[capturedTeam].y = bases[capturedTeam].y;
            flags[capturedTeam].carrier = null;
            flags[capturedTeam].atBase = true;
            p.carryingFlag = null;

            // Check win
            if (teamCaptures[p.team] >= 3) {
              roundOver = true;
              gameState = 'over';
              const won = p.team === 'blue';
              overlayTitle.textContent = won ? 'VICTORY!' : 'DEFEAT';
              overlayText.textContent = `Blue ${teamCaptures.blue} - ${teamCaptures.red} Red | Score: ${score} | Click to play again`;
              overlay.style.display = 'flex';
              overlay.style.pointerEvents = 'auto';
              return;
            }
          }
        }

        // Carry flag position
        if (p.carryingFlag) {
          flags[p.carryingFlag].x = p.x;
          flags[p.carryingFlag].y = p.y;
        }
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        b.life--;

        // Wall collision
        let hitWall = false;
        for (const w of walls) {
          if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
            hitWall = true;
            break;
          }
        }

        // Player collision
        let hitPlayer = false;
        if (!hitWall) {
          for (const p of players) {
            if (!p.alive || p.team === b.team) continue;
            if (dist(b, p) < p.radius + 3) {
              // Damage
              if (p.shieldHP > 0) {
                p.shieldHP -= b.damage;
                if (p.shieldHP < 0) {
                  p.hp += p.shieldHP;
                  p.shieldHP = 0;
                }
              } else {
                p.hp -= b.damage;
              }
              spawnParticles(b.x, b.y, p.team === 'blue' ? '#4488ff' : '#ff4444', 3);

              if (p.hp <= 0) {
                p.alive = false;
                p.respawnTimer = 5;
                dropFlag(p);
                if (b.owner) {
                  b.owner.kills++;
                  teamKills[b.owner.team]++;
                  if (b.owner.team === 'blue') score += 10;
                }
                spawnParticles(p.x, p.y, p.team === 'blue' ? '#4488ff' : '#ff4444', 20);
                respawnMessages.push({ text: `${p.label} eliminated!`, timer: 2, color: p.team === 'blue' ? '#4488ff' : '#ff4444' });
              }
              hitPlayer = true;
              break;
            }
          }
        }

        // Turret collision
        if (!hitWall && !hitPlayer) {
          for (let t = turrets.length - 1; t >= 0; t--) {
            const turr = turrets[t];
            if (turr.team === b.team) continue;
            if (dist(b, turr) < 12) {
              turr.hp -= b.damage;
              spawnParticles(b.x, b.y, '#ff6', 3);
              if (turr.hp <= 0) {
                spawnParticles(turr.x, turr.y, '#ff6', 15);
                turrets.splice(t, 1);
              }
              hitPlayer = true;
              break;
            }
          }
        }

        if (hitWall || hitPlayer || b.life <= 0 || b.x < 0 || b.x > MAP_W || b.y < 0 || b.y > MAP_H) {
          bullets.splice(i, 1);
        }
      }

      // Update turrets
      for (const t of turrets) {
        let nearestEnemy = null;
        let ned = Infinity;
        for (const p of players) {
          if (p.team !== t.team && p.alive) {
            const d = dist(t, p);
            if (d < t.range && d < ned && lineOfSight(t, p)) {
              nearestEnemy = p;
              ned = d;
            }
          }
        }
        if (nearestEnemy) {
          t.angle = Math.atan2(nearestEnemy.y - t.y, nearestEnemy.x - t.x);
          if (now - t.lastFire > t.fireRate) {
            t.lastFire = now;
            bullets.push({
              x: t.x + Math.cos(t.angle) * 10,
              y: t.y + Math.sin(t.angle) * 10,
              vx: Math.cos(t.angle) * 6,
              vy: Math.sin(t.angle) * 6,
              team: t.team,
              damage: t.damage,
              life: 60,
              owner: null
            });
          }
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update respawn messages
      for (let i = respawnMessages.length - 1; i >= 0; i--) {
        respawnMessages[i].timer -= dt;
        if (respawnMessages[i].timer <= 0) respawnMessages.splice(i, 1);
      }

      // Camera follow
      if (humanPlayer) {
        const targetX = humanPlayer.x - W / 2;
        const targetY = humanPlayer.y - H / 2;
        camera.x += (targetX - camera.x) * 0.1;
        camera.y += (targetY - camera.y) * 0.1;
        camera.x = Math.max(0, Math.min(MAP_W - W, camera.x));
        camera.y = Math.max(0, Math.min(MAP_H - H, camera.y));
      }

      // Update UI
      blueScoreEl.textContent = teamCaptures.blue;
      redScoreEl.textContent = teamCaptures.red;
      blueKillsEl.textContent = teamKills.blue;
      redKillsEl.textContent = teamKills.red;
      scoreEl.textContent = score;
    }

    function draw() {
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.translate(-camera.x, -camera.y);

      // Draw map background grid
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= MAP_W; x += TILE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, MAP_H);
        ctx.stroke();
      }
      for (let y = 0; y <= MAP_H; y += TILE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(MAP_W, y);
        ctx.stroke();
      }

      // Draw team zones (subtle)
      ctx.fillStyle = 'rgba(68, 68, 255, 0.03)';
      ctx.fillRect(0, 0, MAP_W / 2, MAP_H);
      ctx.fillStyle = 'rgba(255, 68, 68, 0.03)';
      ctx.fillRect(MAP_W / 2, 0, MAP_W / 2, MAP_H);

      // Draw bases
      // Blue base
      ctx.fillStyle = 'rgba(68, 68, 255, 0.15)';
      ctx.fillRect(bases.blue.x - 50, bases.blue.y - 60, 100, 120);
      ctx.strokeStyle = '#44f';
      ctx.lineWidth = 2;
      ctx.strokeRect(bases.blue.x - 50, bases.blue.y - 60, 100, 120);
      ctx.fillStyle = '#44f';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('BLUE BASE', bases.blue.x, bases.blue.y - 68);

      // Red base
      ctx.fillStyle = 'rgba(255, 68, 68, 0.15)';
      ctx.fillRect(bases.red.x - 50, bases.red.y - 60, 100, 120);
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 2;
      ctx.strokeRect(bases.red.x - 50, bases.red.y - 60, 100, 120);
      ctx.fillStyle = '#f44';
      ctx.fillText('RED BASE', bases.red.x, bases.red.y - 68);

      // Draw walls
      for (const w of walls) {
        ctx.fillStyle = '#2a2a4e';
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeStyle = '#3a3a6e';
        ctx.lineWidth = 1;
        ctx.strokeRect(w.x, w.y, w.w, w.h);
      }

      // Draw turrets
      for (const t of turrets) {
        const tc = t.team === 'blue' ? '#44f' : '#f44';
        ctx.fillStyle = t.team === 'blue' ? 'rgba(68,68,255,0.3)' : 'rgba(255,68,68,0.3)';
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
        ctx.fill();

        // Turret body
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = tc;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Barrel
        ctx.strokeStyle = tc;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(t.x, t.y);
        ctx.lineTo(t.x + Math.cos(t.angle) * 14, t.y + Math.sin(t.angle) * 14);
        ctx.stroke();

        // Health bar
        const hpPct = t.hp / t.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(t.x - 10, t.y - 18, 20, 3);
        ctx.fillStyle = hpPct > 0.5 ? '#6f6' : (hpPct > 0.25 ? '#ff6' : '#f44');
        ctx.fillRect(t.x - 10, t.y - 18, 20 * hpPct, 3);
      }

      // Draw flags
      for (const team of ['blue', 'red']) {
        const f = flags[team];
        if (f.carrier) continue; // drawn on carrier
        const fc = team === 'blue' ? '#4488ff' : '#ff4444';
        // Flag pole
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(f.x, f.y + 8);
        ctx.lineTo(f.x, f.y - 12);
        ctx.stroke();
        // Flag cloth
        ctx.fillStyle = fc;
        ctx.beginPath();
        ctx.moveTo(f.x, f.y - 12);
        ctx.lineTo(f.x + 12, f.y - 8);
        ctx.lineTo(f.x, f.y - 4);
        ctx.closePath();
        ctx.fill();
        // Glow
        ctx.shadowColor = fc;
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.shadowBlur = 0;
        // Flag label
        if (f.atBase) {
          ctx.fillStyle = '#aaa';
          ctx.font = '8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('FLAG', f.x, f.y + 18);
        }
      }

      // Draw players
      for (const p of players) {
        if (!p.alive) continue;
        const teamColor = p.team === 'blue' ? '#4488ff' : '#ff4444';
        const classColor = CLASSES[p.cls].color;

        // Player body
        ctx.fillStyle = teamColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();

        // Class inner circle
        ctx.fillStyle = classColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fill();

        // Direction indicator (gun barrel)
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x + Math.cos(p.angle) * 8, p.y + Math.sin(p.angle) * 8);
        ctx.lineTo(p.x + Math.cos(p.angle) * 16, p.y + Math.sin(p.angle) * 16);
        ctx.stroke();

        // Shield effect
        if (p.shieldHP > 0) {
          ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius + 4, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Carrying flag indicator
        if (p.carryingFlag) {
          const fc = p.carryingFlag === 'blue' ? '#4488ff' : '#ff4444';
          ctx.strokeStyle = fc;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x - 5, p.y - 14);
          ctx.lineTo(p.x - 5, p.y - 24);
          ctx.stroke();
          ctx.fillStyle = fc;
          ctx.beginPath();
          ctx.moveTo(p.x - 5, p.y - 24);
          ctx.lineTo(p.x + 5, p.y - 21);
          ctx.lineTo(p.x - 5, p.y - 18);
          ctx.closePath();
          ctx.fill();
        }

        // Health bar
        const hpPct = p.hp / p.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(p.x - 12, p.y - 18, 24, 3);
        ctx.fillStyle = hpPct > 0.5 ? '#6f6' : (hpPct > 0.25 ? '#ff6' : '#f44');
        ctx.fillRect(p.x - 12, p.y - 18, 24 * hpPct, 3);

        // Shield bar
        if (p.shieldHP > 0) {
          ctx.fillStyle = '#6cf';
          ctx.fillRect(p.x - 12, p.y - 22, 24 * (p.shieldHP / 80), 2);
        }

        // Class label
        ctx.fillStyle = '#fff';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(p.label, p.x, p.y + 3);

        // Human indicator
        if (p.isHuman) {
          ctx.fillStyle = '#fff';
          ctx.font = '8px Courier New';
          ctx.fillText('YOU', p.x, p.y + 22);
        }
      }

      // Respawn indicators for dead players
      for (const p of players) {
        if (p.alive) continue;
        const teamColor = p.team === 'blue' ? 'rgba(68,68,255,0.3)' : 'rgba(255,68,68,0.3)';
        ctx.fillStyle = teamColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#aaa';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(Math.ceil(p.respawnTimer) + 's', p.x, p.y + 3);
      }

      // Draw bullets
      for (const b of bullets) {
        const bc = b.team === 'blue' ? '#6af' : '#f66';
        ctx.fillStyle = bc;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = bc;
        ctx.shadowBlur = 4;
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw particles
      for (const p of particles) {
        const alpha = p.life / 40;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      // HUD overlay
      if (humanPlayer && humanPlayer.alive) {
        // Minimap
        const mmW = 120, mmH = 80;
        const mmX = W - mmW - 8, mmY = H - mmH - 8;
        ctx.fillStyle = 'rgba(13, 13, 26, 0.8)';
        ctx.fillRect(mmX, mmY, mmW, mmH);
        ctx.strokeStyle = '#44f';
        ctx.lineWidth = 1;
        ctx.strokeRect(mmX, mmY, mmW, mmH);

        const scaleX = mmW / MAP_W, scaleY = mmH / MAP_H;

        // Minimap walls
        ctx.fillStyle = '#2a2a4e';
        for (const w of walls) {
          ctx.fillRect(mmX + w.x * scaleX, mmY + w.y * scaleY, Math.max(1, w.w * scaleX), Math.max(1, w.h * scaleY));
        }

        // Minimap players
        for (const p of players) {
          if (!p.alive) continue;
          ctx.fillStyle = p.team === 'blue' ? '#4488ff' : '#ff4444';
          const px = mmX + p.x * scaleX, py = mmY + p.y * scaleY;
          ctx.fillRect(px - 1.5, py - 1.5, 3, 3);
          if (p.isHuman) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(px - 2.5, py - 2.5, 5, 5);
          }
        }

        // Minimap flags
        for (const team of ['blue', 'red']) {
          const f = flags[team];
          ctx.fillStyle = team === 'blue' ? '#4488ff' : '#ff4444';
          const fx = mmX + f.x * scaleX, fy = mmY + f.y * scaleY;
          ctx.beginPath();
          ctx.moveTo(fx, fy - 4);
          ctx.lineTo(fx + 3, fy);
          ctx.lineTo(fx - 3, fy);
          ctx.closePath();
          ctx.fill();
        }

        // Camera viewport on minimap
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(mmX + camera.x * scaleX, mmY + camera.y * scaleY, W * scaleX, H * scaleY);

        // Player stats HUD
        const hp = humanPlayer;
        // Health
        ctx.fillStyle = 'rgba(13, 13, 26, 0.7)';
        ctx.fillRect(8, H - 40, 160, 32);
        ctx.strokeStyle = '#44f';
        ctx.lineWidth = 1;
        ctx.strokeRect(8, H - 40, 160, 32);

        ctx.fillStyle = '#aaa';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`HP: ${Math.ceil(hp.hp)}/${hp.maxHp}  ${CLASSES[hp.cls].label}`, 14, H - 26);

        // HP bar
        const hpPct = hp.hp / hp.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(14, H - 18, 148, 6);
        ctx.fillStyle = hpPct > 0.5 ? '#6f6' : (hpPct > 0.25 ? '#ff6' : '#f44');
        ctx.fillRect(14, H - 18, 148 * hpPct, 6);

        // Ability cooldown
        const abPct = Math.max(0, hp.abilityCD / hp.abilityCooldown);
        ctx.fillStyle = 'rgba(13, 13, 26, 0.7)';
        ctx.fillRect(8, H - 58, 100, 14);
        ctx.fillStyle = abPct > 0 ? '#666' : '#6cf';
        ctx.font = '9px Courier New';
        const abName = CLASSES[hp.cls].ability.toUpperCase();
        ctx.fillText(`[Q] ${abName} ${abPct > 0 ? Math.ceil(hp.abilityCD / 1000) + 's' : 'READY'}`, 14, H - 48);

        // Shield indicator
        if (hp.shieldHP > 0) {
          ctx.fillStyle = '#6cf';
          ctx.fillText(`SHIELD: ${Math.ceil(hp.shieldHP)}`, 120, H - 48);
        }
      } else if (humanPlayer && !humanPlayer.alive) {
        // Death screen
        ctx.fillStyle = 'rgba(13, 13, 26, 0.6)';
        ctx.fillRect(W / 2 - 100, H / 2 - 20, 200, 40);
        ctx.fillStyle = '#f44';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('ELIMINATED', W / 2, H / 2);
        ctx.fillStyle = '#aaa';
        ctx.font = '12px Courier New';
        ctx.fillText(`Respawn in ${Math.ceil(humanPlayer.respawnTimer)}s`, W / 2, H / 2 + 16);
      }

      // Kill feed
      let feedY = 14;
      for (const msg of respawnMessages) {
        const alpha = Math.min(1, msg.timer);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = msg.color;
        ctx.font = '9px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(msg.text, W - 10, feedY);
        feedY += 12;
      }
      ctx.globalAlpha = 1;

      // Score captures display at top center
      ctx.textAlign = 'center';
      ctx.font = '12px Courier New';
      const capText = '';
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < teamCaptures.blue ? '#4488ff' : '#333';
        ctx.fillRect(W / 2 - 40 + i * 12, 6, 8, 8);
      }
      ctx.fillStyle = '#667';
      ctx.fillText('vs', W / 2, 14);
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < teamCaptures.red ? '#ff4444' : '#333';
        ctx.fillRect(W / 2 + 12 + i * 12, 6, 8, 8);
      }
    }

    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Input handlers
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = (e.clientX - rect.left) * (W / rect.width);
      mouse.y = (e.clientY - rect.top) * (H / rect.height);
    });

    canvas.addEventListener('mousedown', e => {
      e.preventDefault();
      if (gameState === 'menu') {
        gameState = 'playing';
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        initGame();
        return;
      }
      if (gameState === 'over') {
        gameState = 'menu';
        overlayTitle.textContent = 'CAPTURE THE FLAG';
        overlayText.textContent = 'Choose class above, then click to start';
        overlay.style.display = 'flex';
        return;
      }
      mouseDown = true;
    });

    canvas.addEventListener('mouseup', () => { mouseDown = false; });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'q' && humanPlayer && humanPlayer.alive) {
        useAbility(humanPlayer);
      }
      if (e.key.toLowerCase() === 'e') {
        // E key is handled in update loop for flag interaction
      }
    });

    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    // Prevent scrolling with WASD
    window.addEventListener('keydown', e => {
      if (['w', 'a', 's', 'd', ' ', 'e', 'q'].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
    });

    // Start
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

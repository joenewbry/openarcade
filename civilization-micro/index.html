<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Civilization Micro</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
      user-select: none;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
      width: 600px;
    }
    .back { color: #ca4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204,170,68,0.4); }
    h1 { color: #ca4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(204,170,68,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
    }
    .score-bar span { color: #ca4; }
    canvas {
      border: 2px solid #ca4;
      box-shadow: 0 0 20px rgba(204,170,68,0.2);
      display: block;
      cursor: pointer;
    }
    .game-wrap { position: relative; display: inline-block; }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 600px; height: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ca4;
      text-align: center;
      background: rgba(26,26,46,0.92);
      z-index: 10;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(204,170,68,0.5); }
    .overlay p { font-size: 0.95rem; color: #aaa; margin: 4px 0; }
    .overlay .start-btn {
      margin-top: 16px; padding: 10px 28px;
      background: #ca4; color: #1a1a2e; border: none;
      font-family: 'Courier New', monospace; font-size: 1rem;
      cursor: pointer; font-weight: bold;
    }
    .overlay .start-btn:hover { background: #db5; }
    .overlay select {
      margin: 6px 4px; padding: 4px 8px;
      background: #16213e; color: #ca4; border: 1px solid #ca4;
      font-family: 'Courier New', monospace; font-size: 0.85rem;
    }
    .panel {
      width: 600px;
      margin-top: 6px;
      display: flex;
      gap: 6px;
      font-size: 0.75rem;
    }
    .panel-box {
      background: #16213e;
      border: 1px solid #333;
      padding: 6px;
      flex: 1;
    }
    .panel-box h3 { color: #ca4; font-size: 0.8rem; margin-bottom: 4px; }
    .panel-box .info { color: #aaa; line-height: 1.4; }
    .panel-box .info b { color: #e0e0e0; }
    .action-btn {
      display: inline-block; margin: 2px; padding: 2px 6px;
      background: #ca4; color: #1a1a2e; border: none;
      font-family: 'Courier New', monospace; font-size: 0.7rem;
      cursor: pointer; font-weight: bold;
    }
    .action-btn:hover { background: #db5; }
    .action-btn:disabled { background: #555; color: #888; cursor: default; }
    #endTurnBtn {
      padding: 4px 14px; font-size: 0.85rem;
    }
    #log { color: #888; font-size: 0.7rem; max-height: 52px; overflow-y: auto; line-height: 1.3; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CIVILIZATION MICRO</h1>
  </div>
  <div class="score-bar">
    <div>Turn: <span id="turnNum">0</span>/40</div>
    <div>Score: <span id="score">0</span></div>
    <div id="turnInfo" style="color:#aaa;">--</div>
    <button class="action-btn" id="endTurnBtn" style="display:none;">END TURN</button>
  </div>
  <div class="game-wrap">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay">
      <h2>CIVILIZATION MICRO</h2>
      <p>4X Strategy in 40 Turns</p>
      <p style="color:#ca4;font-size:0.8rem;margin-top:8px;">Explore. Expand. Exploit. Exterminate.</p>
      <div style="margin-top:12px;">
        <label style="color:#aaa;">Players: </label>
        <select id="playerCount">
          <option value="2">2 (You + 1 AI)</option>
          <option value="3">3 (You + 2 AI)</option>
          <option value="4">4 (You + 3 AI)</option>
        </select>
      </div>
      <button class="start-btn" id="startBtn">START GAME</button>
    </div>
  </div>
  <div class="panel" id="infoPanel" style="display:none;">
    <div class="panel-box" style="flex:1.4;">
      <h3>SELECTED</h3>
      <div class="info" id="selectedInfo">Click a unit or city</div>
    </div>
    <div class="panel-box" style="flex:1;">
      <h3>TECH TREE</h3>
      <div class="info" id="techInfo">--</div>
    </div>
    <div class="panel-box" style="flex:1.2;">
      <h3>LOG</h3>
      <div id="log"></div>
    </div>
  </div>

  <script>
  // ========== GLOBALS ==========
  const C = document.getElementById('game');
  const X = C.getContext('2d');
  const W = 600, H = 500;
  let gameState = 'waiting';
  let score = 0;

  const COLS = 15, ROWS = 12;
  const HEX_W = 38, HEX_H = 34;
  const MAP_OX = 14, MAP_OY = 14;

  // Terrain types
  const T_PLAINS = 0, T_HILLS = 1, T_FOREST = 2, T_MOUNTAIN = 3, T_WATER = 4;
  const TERRAIN_NAMES = ['Plains','Hills','Forest','Mountain','Water'];
  const TERRAIN_COLORS = ['#5a7a3a','#8a7a4a','#3a6a3a','#6a6a6a','#3a5a8a'];
  const TERRAIN_FOOD = [3,1,2,0,0];
  const TERRAIN_PROD = [1,3,1,0,0];
  const TERRAIN_MOVE = [1,2,2,99,99]; // movement cost

  // Unit types
  const U_SCOUT = 0, U_WARRIOR = 1, U_SETTLER = 2, U_BUILDER = 3;
  const UNIT_NAMES = ['Scout','Warrior','Settler','Builder'];
  const UNIT_MOVE = [3,2,2,2];
  const UNIT_STR = [1,4,0,0];
  const UNIT_HP_MAX = [3,6,2,2];
  const UNIT_COST = [15,25,40,20];
  const UNIT_SYMBOLS = ['\u2667','\u2694','\u2691','\u2692']; // club, swords, flag, hammer

  // Player colors
  const P_COLORS = ['#4488ff','#ff4444','#44cc44','#cc44cc'];
  const P_NAMES = ['You','Red AI','Green AI','Purple AI'];

  // Tech tree
  const TECHS = [
    { name:'Agriculture', cost:15, desc:'+1 food per city', foodBonus:1 },
    { name:'Mining', cost:25, desc:'+1 prod per city, unlock Builder', prodBonus:1, unlock:U_BUILDER },
    { name:'Construction', cost:35, desc:'Cities +2 defense, +1 prod', defBonus:2, prodBonus:1 },
    { name:'Military', cost:45, desc:'Units +2 str, unlock faster prod', strBonus:2, prodBonus:1 }
  ];

  // ========== STATE ==========
  let numPlayers = 2;
  let terrain = [];   // [row][col]
  let visible = [];    // [row][col] for player 0 (fog of war)
  let explored = [];   // [row][col] ever seen
  let cities = [];     // { r, c, owner, hp, hpMax, name, prod, prodTarget, prodProgress, food, pop }
  let units = [];      // { r, c, owner, type, hp, hpMax, moves, movesMax }
  let players = [];    // { alive, techLevel, score, capital:{r,c}, gold, prodBonus }
  let turn = 0;
  let currentPlayer = 0;
  let selectedUnit = null;
  let selectedCity = null;
  let reachable = [];  // hex positions reachable by selected unit
  let animQueue = [];
  let logLines = [];

  const cityNames = ['Rome','Athens','Babylon','Memphis','Kyoto','Delhi','London','Paris',
    'Beijing','Cairo','Sparta','Thebes','Troy','Ur','Cusco','Axum','Angkor','Knossos',
    'Nineveh','Persepolis','Carthage','Mohenjo','Syracuse','Olympia'];
  let cityNameIdx = 0;

  // ========== HEX MATH ==========
  function hexToPixel(r, c) {
    let x = MAP_OX + c * HEX_W * 0.75 + HEX_W / 2;
    let y = MAP_OY + r * HEX_H + (c % 2 === 1 ? HEX_H / 2 : 0) + HEX_H / 2;
    return { x, y };
  }

  function pixelToHex(px, py) {
    let bestD = 999, bestR = -1, bestC = -1;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let { x, y } = hexToPixel(r, c);
        let d = Math.hypot(px - x, py - y);
        if (d < bestD) { bestD = d; bestR = r; bestC = c; }
      }
    }
    if (bestD < HEX_W * 0.6) return { r: bestR, c: bestC };
    return null;
  }

  function hexNeighbors(r, c) {
    let n = [];
    let odd = c % 2 === 1;
    let dirs = odd
      ? [[-1,0],[0,-1],[1,-1],[1,0],[1,1],[0,1]]
      : [[-1,0],[-1,-1],[0,-1],[1,0],[0,1],[-1,1]];
    for (let [dr, dc] of dirs) {
      let nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) n.push({ r: nr, c: nc });
    }
    return n;
  }

  function hexDist(r1, c1, r2, c2) {
    // Convert offset to cube coordinates
    function toCube(r, c) {
      let x = c;
      let z = r - (c - (c & 1)) / 2;
      let y = -x - z;
      return { x, y, z };
    }
    let a = toCube(r1, c1), b = toCube(r2, c2);
    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
  }

  function drawHex(cx, cy, size, fill, stroke, lw) {
    X.beginPath();
    for (let i = 0; i < 6; i++) {
      let ang = Math.PI / 180 * (60 * i - 30);
      let hx = cx + size * 0.52 * Math.cos(ang);
      let hy = cy + size * 0.6 * Math.sin(ang);
      if (i === 0) X.moveTo(hx, hy); else X.lineTo(hx, hy);
    }
    X.closePath();
    if (fill) { X.fillStyle = fill; X.fill(); }
    if (stroke) { X.strokeStyle = stroke; X.lineWidth = lw || 1; X.stroke(); }
  }

  // ========== MAP GENERATION ==========
  function generateMap() {
    terrain = [];
    for (let r = 0; r < ROWS; r++) {
      terrain[r] = [];
      for (let c = 0; c < COLS; c++) {
        let n = Math.random();
        if (n < 0.45) terrain[r][c] = T_PLAINS;
        else if (n < 0.62) terrain[r][c] = T_HILLS;
        else if (n < 0.78) terrain[r][c] = T_FOREST;
        else if (n < 0.88) terrain[r][c] = T_MOUNTAIN;
        else terrain[r][c] = T_WATER;
      }
    }
    // Ensure start positions are plains
    let starts = getStartPositions(numPlayers);
    for (let s of starts) {
      terrain[s.r][s.c] = T_PLAINS;
      for (let nb of hexNeighbors(s.r, s.c)) {
        if (terrain[nb.r][nb.c] === T_WATER || terrain[nb.r][nb.c] === T_MOUNTAIN)
          terrain[nb.r][nb.c] = T_PLAINS;
      }
    }
  }

  function getStartPositions(n) {
    let pos = [
      { r: 2, c: 2 },
      { r: ROWS - 3, c: COLS - 3 },
      { r: 2, c: COLS - 3 },
      { r: ROWS - 3, c: 2 }
    ];
    return pos.slice(0, n);
  }

  // ========== FOG OF WAR ==========
  function resetVisibility() {
    visible = [];
    for (let r = 0; r < ROWS; r++) {
      visible[r] = [];
      for (let c = 0; c < COLS; c++) visible[r][c] = false;
    }
  }

  function updateVisibility() {
    resetVisibility();
    // Units reveal 2 hex radius, scouts reveal 3
    for (let u of units) {
      if (u.owner !== 0) continue;
      let radius = u.type === U_SCOUT ? 3 : 2;
      revealAround(u.r, u.c, radius);
    }
    // Cities reveal 2 hex radius
    for (let city of cities) {
      if (city.owner !== 0) continue;
      revealAround(city.r, city.c, 2);
    }
  }

  function revealAround(cr, cc, radius) {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (hexDist(cr, cc, r, c) <= radius) {
          visible[r][c] = true;
          explored[r][c] = true;
        }
      }
    }
  }

  // ========== PATHFINDING ==========
  function getReachable(unit) {
    let open = [{ r: unit.r, c: unit.c, moves: unit.moves }];
    let visited = {};
    let key = (r, c) => r * 100 + c;
    visited[key(unit.r, unit.c)] = true;
    let result = [];

    while (open.length > 0) {
      let cur = open.shift();
      for (let nb of hexNeighbors(cur.r, cur.c)) {
        let k = key(nb.r, nb.c);
        if (visited[k]) continue;
        let t = terrain[nb.r][nb.c];
        let cost = TERRAIN_MOVE[t];
        if (cost >= 99) continue; // impassable
        // Can't move through enemy units (but can move TO attack)
        let enemyUnit = units.find(u => u.r === nb.r && u.c === nb.c && u.owner !== unit.owner);
        let friendUnit = units.find(u => u.r === nb.r && u.c === nb.c && u.owner === unit.owner && u !== unit);
        if (friendUnit) continue; // can't stack
        let remaining = cur.moves - cost;
        if (remaining < 0) continue;
        visited[k] = true;
        result.push({ r: nb.r, c: nb.c, enemy: enemyUnit || null });
        if (!enemyUnit) {
          open.push({ r: nb.r, c: nb.c, moves: remaining });
        }
      }
    }
    return result;
  }

  // ========== INIT ==========
  function init() {
    numPlayers = parseInt(document.getElementById('playerCount').value);
    turn = 1;
    currentPlayer = 0;
    selectedUnit = null;
    selectedCity = null;
    reachable = [];
    cities = [];
    units = [];
    logLines = [];
    cityNameIdx = 0;

    players = [];
    for (let i = 0; i < numPlayers; i++) {
      players.push({ alive: true, techLevel: -1, techProgress: 0, score: 0, capital: null, gold: 0, prodBonus: 0, strBonus: 0, foodBonus: 0, defBonus: 0 });
    }

    generateMap();

    explored = [];
    for (let r = 0; r < ROWS; r++) {
      explored[r] = [];
      for (let c = 0; c < COLS; c++) explored[r][c] = false;
    }

    // Place starting units
    let starts = getStartPositions(numPlayers);
    for (let i = 0; i < numPlayers; i++) {
      let s = starts[i];
      units.push(makeUnit(U_SETTLER, i, s.r, s.c));
      units.push(makeUnit(U_WARRIOR, i, s.r, s.c + 1));
    }

    updateVisibility();
    updateScore();
    gameState = 'playing';
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('infoPanel').style.display = 'flex';
    document.getElementById('endTurnBtn').style.display = 'inline-block';
    addLog('Game started! Found a city with your Settler.');
    draw();
  }

  function makeUnit(type, owner, r, c) {
    return {
      r, c, owner, type,
      hp: UNIT_HP_MAX[type], hpMax: UNIT_HP_MAX[type],
      moves: UNIT_MOVE[type], movesMax: UNIT_MOVE[type]
    };
  }

  // ========== CITY MANAGEMENT ==========
  function foundCity(unit) {
    if (unit.type !== U_SETTLER) return;
    if (terrain[unit.r][unit.c] === T_WATER || terrain[unit.r][unit.c] === T_MOUNTAIN) return;
    if (cities.find(c => c.r === unit.r && c.c === unit.c)) return;
    // Check distance from other cities
    for (let city of cities) {
      if (hexDist(city.r, city.c, unit.r, unit.c) < 3) return;
    }

    let name = cityNames[cityNameIdx++ % cityNames.length];
    let food = TERRAIN_FOOD[terrain[unit.r][unit.c]];
    let prod = TERRAIN_PROD[terrain[unit.r][unit.c]];
    // Add neighbor bonuses
    for (let nb of hexNeighbors(unit.r, unit.c)) {
      food += TERRAIN_FOOD[terrain[nb.r][nb.c]] * 0.3;
      prod += TERRAIN_PROD[terrain[nb.r][nb.c]] * 0.3;
    }

    let city = {
      r: unit.r, c: unit.c, owner: unit.owner,
      name, hp: 10, hpMax: 10, defense: 3,
      prod: Math.max(2, Math.floor(prod + 1)),
      food: Math.max(1, Math.floor(food)),
      pop: 1,
      prodTarget: null, prodProgress: 0,
      isCapital: false
    };

    if (!players[unit.owner].capital) {
      players[unit.owner].capital = { r: unit.r, c: unit.c };
      city.isCapital = true;
      city.hp = 15; city.hpMax = 15; city.defense = 5;
    }

    cities.push(city);
    // Remove settler
    units = units.filter(u => u !== unit);
    if (unit.owner === 0) {
      addLog(`Founded ${name}!`);
      selectedUnit = null;
    }
    updateVisibility();
  }

  function cityProduce(city) {
    if (!city.prodTarget && city.prodTarget !== 0) return;
    let p = city.prod + (players[city.owner].prodBonus || 0);
    city.prodProgress += p;
    let targetCost = UNIT_COST[city.prodTarget];
    if (city.prodProgress >= targetCost) {
      city.prodProgress = 0;
      // Find empty adjacent hex to spawn
      let spawn = null;
      let candidates = [{ r: city.r, c: city.c }, ...hexNeighbors(city.r, city.c)];
      for (let pos of candidates) {
        if (terrain[pos.r][pos.c] >= T_MOUNTAIN) continue;
        if (units.find(u => u.r === pos.r && u.c === pos.c)) continue;
        spawn = pos;
        break;
      }
      if (spawn) {
        units.push(makeUnit(city.prodTarget, city.owner, spawn.r, spawn.c));
        if (city.owner === 0) addLog(`${city.name} produced ${UNIT_NAMES[city.prodTarget]}`);
      }
      city.prodTarget = null;
    }
  }

  function cityResearch(city) {
    let p = players[city.owner];
    if (p.techLevel >= TECHS.length - 1) return;
    let nextTech = p.techLevel + 1;
    // Each city contributes food as research points
    p.techProgress += city.food + (p.foodBonus || 0);
    if (p.techProgress >= TECHS[nextTech].cost) {
      p.techProgress -= TECHS[nextTech].cost;
      p.techLevel = nextTech;
      let tech = TECHS[nextTech];
      if (tech.foodBonus) p.foodBonus = (p.foodBonus || 0) + tech.foodBonus;
      if (tech.prodBonus) p.prodBonus = (p.prodBonus || 0) + tech.prodBonus;
      if (tech.strBonus) p.strBonus = (p.strBonus || 0) + tech.strBonus;
      if (tech.defBonus) p.defBonus = (p.defBonus || 0) + tech.defBonus;
      if (city.owner === 0) addLog(`Researched ${tech.name}!`);
    }
  }

  // ========== COMBAT ==========
  function combat(attacker, defender) {
    let atkStr = UNIT_STR[attacker.type] + (players[attacker.owner].strBonus || 0);
    let defStr = UNIT_STR[defender.type] + (players[defender.owner].strBonus || 0);
    // Terrain defense bonus
    let t = terrain[defender.r][defender.c];
    if (t === T_HILLS) defStr += 1;
    if (t === T_FOREST) defStr += 1;

    let atkDmg = Math.max(1, atkStr - Math.floor(defStr * 0.3) + Math.floor(Math.random() * 2));
    let defDmg = Math.max(1, defStr - Math.floor(atkStr * 0.3) + Math.floor(Math.random() * 2));

    defender.hp -= atkDmg;
    attacker.hp -= Math.floor(defDmg * 0.6); // Attacker takes less counter-damage

    let result = '';
    if (defender.hp <= 0) {
      result = `${UNIT_NAMES[attacker.type]} destroyed ${UNIT_NAMES[defender.type]}`;
      units = units.filter(u => u !== defender);
      // Move attacker to defender position
      attacker.r = defender.r;
      attacker.c = defender.c;
    }
    if (attacker.hp <= 0) {
      result = `${UNIT_NAMES[attacker.type]} was destroyed`;
      units = units.filter(u => u !== attacker);
    }
    if (result && (attacker.owner === 0 || defender.owner === 0)) addLog(result);
    attacker.moves = 0;

    return defender.hp <= 0;
  }

  function attackCity(unit, city) {
    let str = UNIT_STR[unit.type] + (players[unit.owner].strBonus || 0);
    let def = city.defense + (players[city.owner].defBonus || 0);
    let dmg = Math.max(1, str - Math.floor(def * 0.3) + Math.floor(Math.random() * 2));
    city.hp -= dmg;
    unit.hp -= Math.max(1, Math.floor(def * 0.3));
    unit.moves = 0;

    if (unit.hp <= 0) {
      units = units.filter(u => u !== unit);
      if (unit.owner === 0) addLog(`${UNIT_NAMES[unit.type]} fell attacking ${city.name}`);
    }

    if (city.hp <= 0) {
      let oldOwner = city.owner;
      city.owner = unit.owner;
      city.hp = Math.floor(city.hpMax / 2);
      city.prodTarget = null;
      city.prodProgress = 0;
      if (unit.owner === 0 || oldOwner === 0) addLog(`${city.name} captured!`);
      // Check if capital captured
      if (city.isCapital) {
        let ownerCities = cities.filter(c => c.owner === oldOwner);
        if (ownerCities.length === 0) {
          players[oldOwner].alive = false;
          if (oldOwner === 0) addLog('Your civilization has fallen!');
          else addLog(`${P_NAMES[oldOwner]} eliminated!`);
        }
      }
      checkWin();
    }
  }

  // ========== IMPROVEMENT (Builder) ==========
  function buildImprovement(unit) {
    if (unit.type !== U_BUILDER) return;
    let city = cities.find(c => hexDist(c.r, c.c, unit.r, unit.c) <= 2 && c.owner === unit.owner);
    if (!city) return;
    // Improve nearest city
    city.prod += 1;
    city.food += 1;
    unit.moves = 0;
    units = units.filter(u => u !== unit); // Builder consumed
    if (unit.owner === 0) addLog(`Builder improved area near ${city.name}`);
  }

  // ========== TURN MANAGEMENT ==========
  function endTurn() {
    if (gameState !== 'playing') return;

    // Process current player's cities
    let pCities = cities.filter(c => c.owner === currentPlayer);
    for (let city of pCities) {
      cityProduce(city);
      cityResearch(city);
      // City heals
      if (city.hp < city.hpMax) city.hp = Math.min(city.hpMax, city.hp + 1);
    }

    // Heal units on friendly territory
    for (let u of units) {
      if (u.owner !== currentPlayer) continue;
      let inCity = cities.find(c => c.r === u.r && c.c === u.c && c.owner === u.owner);
      if (inCity) u.hp = Math.min(u.hpMax, u.hp + 2);
      else u.hp = Math.min(u.hpMax, u.hp + 1);
    }

    // Next player
    currentPlayer++;
    while (currentPlayer < numPlayers && !players[currentPlayer].alive) currentPlayer++;

    if (currentPlayer >= numPlayers) {
      // New turn
      currentPlayer = 0;
      while (currentPlayer < numPlayers && !players[currentPlayer].alive) currentPlayer++;
      turn++;
      if (turn > 40) { endGame(); return; }
    }

    // Reset movement for current player's units
    for (let u of units) {
      if (u.owner === currentPlayer) u.moves = u.movesMax;
    }

    selectedUnit = null;
    selectedCity = null;
    reachable = [];

    if (currentPlayer === 0) {
      updateVisibility();
      updateScore();
      draw();
    } else {
      runAI(currentPlayer);
    }
  }

  // ========== AI ==========
  function runAI(pid) {
    if (!players[pid].alive) { endTurn(); return; }

    let p = players[pid];
    let myCities = cities.filter(c => c.owner === pid);
    let myUnits = units.filter(u => u.owner === pid);

    // Auto-found cities with settlers
    for (let u of myUnits.filter(u => u.type === U_SETTLER)) {
      let nearCity = cities.find(c => hexDist(c.r, c.c, u.r, u.c) < 3);
      if (!nearCity && terrain[u.r][u.c] !== T_WATER && terrain[u.r][u.c] !== T_MOUNTAIN) {
        foundCity(u);
      } else if (u.moves > 0) {
        aiMoveToward(u, aiFindSettleSpot(pid));
      }
    }

    // Set city production
    myCities = cities.filter(c => c.owner === pid); // refresh
    for (let city of myCities) {
      if (city.prodTarget === null) {
        city.prodTarget = aiChooseProduction(pid, city);
      }
    }

    // Move and fight with military units
    myUnits = units.filter(u => u.owner === pid); // refresh
    for (let u of myUnits) {
      if (u.type === U_SETTLER) continue;
      if (u.moves <= 0) continue;

      if (u.type === U_BUILDER) {
        // Move toward own city to build improvement
        let nearCity = cities.find(c => hexDist(c.r, c.c, u.r, u.c) <= 2 && c.owner === pid);
        if (nearCity) {
          buildImprovement(u);
        } else if (myCities.length > 0) {
          aiMoveToward(u, { r: myCities[0].r, c: myCities[0].c });
        }
        continue;
      }

      // Scout: explore fog
      if (u.type === U_SCOUT) {
        let target = aiFindExploreTarget(u);
        if (target) aiMoveToward(u, target);
        continue;
      }

      // Warrior: attack if strong, otherwise defend/explore
      let enemyNear = null;
      let bestDist = 999;
      for (let e of units) {
        if (e.owner === pid) continue;
        let d = hexDist(u.r, u.c, e.r, e.c);
        if (d < bestDist) { bestDist = d; enemyNear = e; }
      }

      // Check for enemy cities too
      let enemyCityNear = null;
      let bestCityDist = 999;
      for (let ec of cities) {
        if (ec.owner === pid) continue;
        let d = hexDist(u.r, u.c, ec.r, ec.c);
        if (d < bestCityDist) { bestCityDist = d; enemyCityNear = ec; }
      }

      // Count military strength
      let myStr = myUnits.filter(mu => mu.type === U_WARRIOR).length;
      let shouldAttack = myStr >= 2 + Math.floor(turn / 10) || turn > 25;

      if (shouldAttack && enemyCityNear && bestCityDist <= 6) {
        // Try to attack city
        if (bestCityDist === 1 || (u.r === enemyCityNear.r && u.c === enemyCityNear.c)) {
          // Adjacent - attack
          let nb = hexNeighbors(u.r, u.c);
          if (nb.find(n => n.r === enemyCityNear.r && n.c === enemyCityNear.c) || (u.r === enemyCityNear.r && u.c === enemyCityNear.c)) {
            attackCity(u, enemyCityNear);
          }
        } else {
          aiMoveToward(u, { r: enemyCityNear.r, c: enemyCityNear.c });
          // Check if we're now adjacent to the city
          let nbs = hexNeighbors(u.r, u.c);
          if (nbs.find(n => n.r === enemyCityNear.r && n.c === enemyCityNear.c)) {
            if (u.moves > 0) attackCity(u, enemyCityNear);
          }
        }
      } else if (enemyNear && bestDist <= 4) {
        aiMoveToward(u, { r: enemyNear.r, c: enemyNear.c });
        // Try attack
        reachable = getReachable(u);
        let attackable = reachable.find(h => h.enemy && h.enemy === enemyNear);
        if (attackable) combat(u, enemyNear);
      } else {
        // Patrol or explore
        let target = aiFindExploreTarget(u);
        if (target) aiMoveToward(u, target);
      }
    }

    setTimeout(() => endTurn(), 50);
  }

  function aiChooseProduction(pid, city) {
    let p = players[pid];
    let myCities = cities.filter(c => c.owner === pid);
    let myWarriors = units.filter(u => u.owner === pid && u.type === U_WARRIOR).length;
    let myScouts = units.filter(u => u.owner === pid && u.type === U_SCOUT).length;
    let mySettlers = units.filter(u => u.owner === pid && u.type === U_SETTLER).length;

    // Early game: need scouts
    if (myScouts === 0 && turn < 10) return U_SCOUT;

    // Need settlers to expand
    if (myCities.length < 3 && mySettlers === 0 && turn < 25) return U_SETTLER;

    // Military buildup
    if (myWarriors < myCities.length + 1) return U_WARRIOR;

    // Builder if we have Mining
    if (p.techLevel >= 1 && Math.random() < 0.3) return U_BUILDER;

    // More warriors late game
    if (turn > 20) return U_WARRIOR;

    // Mix
    let r = Math.random();
    if (r < 0.4) return U_WARRIOR;
    if (r < 0.6 && myCities.length < 4 && mySettlers === 0) return U_SETTLER;
    if (r < 0.8) return U_SCOUT;
    return U_WARRIOR;
  }

  function aiFindSettleSpot(pid) {
    let best = null, bestScore = -999;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (terrain[r][c] >= T_MOUNTAIN) continue;
        let tooClose = false;
        for (let city of cities) {
          if (hexDist(city.r, city.c, r, c) < 3) { tooClose = true; break; }
        }
        if (tooClose) continue;
        let sc = TERRAIN_FOOD[terrain[r][c]] + TERRAIN_PROD[terrain[r][c]];
        for (let nb of hexNeighbors(r, c)) {
          sc += (TERRAIN_FOOD[terrain[nb.r][nb.c]] + TERRAIN_PROD[terrain[nb.r][nb.c]]) * 0.3;
        }
        if (sc > bestScore) { bestScore = sc; best = { r, c }; }
      }
    }
    return best || { r: 6, c: 7 };
  }

  function aiFindExploreTarget(unit) {
    // Move toward unexplored areas (simple heuristic: move away from own cities)
    let best = null, bestDist = -1;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (terrain[r][c] >= T_MOUNTAIN) continue;
        let d = hexDist(unit.r, unit.c, r, c);
        if (d > 3 && d < 8) {
          let distFromCities = 0;
          for (let city of cities.filter(ci => ci.owner === unit.owner)) {
            distFromCities += hexDist(city.r, city.c, r, c);
          }
          if (distFromCities > bestDist) { bestDist = distFromCities; best = { r, c }; }
        }
      }
    }
    return best;
  }

  function aiMoveToward(unit, target) {
    if (!target || unit.moves <= 0) return;
    let steps = 0;
    while (unit.moves > 0 && steps < 4) {
      steps++;
      let nbs = hexNeighbors(unit.r, unit.c);
      let best = null, bestD = hexDist(unit.r, unit.c, target.r, target.c);
      for (let nb of nbs) {
        if (terrain[nb.r][nb.c] >= T_MOUNTAIN) continue;
        if (units.find(u => u.r === nb.r && u.c === nb.c && u.owner === unit.owner)) continue;
        let d = hexDist(nb.r, nb.c, target.r, target.c);
        let cost = TERRAIN_MOVE[terrain[nb.r][nb.c]];
        if (d < bestD && cost <= unit.moves) {
          // Check for enemy units blocking
          let enemy = units.find(u => u.r === nb.r && u.c === nb.c && u.owner !== unit.owner);
          if (enemy && unit.type === U_WARRIOR) {
            combat(unit, enemy);
            return;
          }
          if (!enemy) { best = nb; bestD = d; }
        }
      }
      if (!best) break;
      let cost = TERRAIN_MOVE[terrain[best.r][best.c]];
      unit.r = best.r;
      unit.c = best.c;
      unit.moves -= cost;
    }
  }

  // ========== SCORE ==========
  function updateScore() {
    for (let i = 0; i < numPlayers; i++) {
      let p = players[i];
      if (!p.alive) { p.score = 0; continue; }
      let myCities = cities.filter(c => c.owner === i);
      let myUnits = units.filter(u => u.owner === i);
      p.score = myCities.length * 10 + (p.techLevel + 1) * 5 + myUnits.length * 2 + myCities.reduce((s, c) => s + c.pop, 0);
    }
    score = players[0].score;
    document.getElementById('score').textContent = score;
    document.getElementById('turnNum').textContent = turn;
  }

  // ========== WIN/LOSS ==========
  function checkWin() {
    // Check if all enemy capitals captured
    let aliveCount = players.filter(p => p.alive).length;
    if (aliveCount <= 1) {
      let winner = players.findIndex(p => p.alive);
      if (winner >= 0) {
        endGame(winner);
      }
    }
  }

  function endGame(winnerOverride) {
    gameState = 'over';
    updateScore();
    let winner = winnerOverride !== undefined ? winnerOverride : -1;
    if (winner < 0) {
      // Highest score wins
      let best = -1, bestScore = -1;
      for (let i = 0; i < numPlayers; i++) {
        if (players[i].score > bestScore) { bestScore = players[i].score; best = i; }
      }
      winner = best;
    }

    let ov = document.getElementById('overlay');
    ov.style.display = 'flex';
    ov.innerHTML = `
      <h2>${winner === 0 ? 'VICTORY!' : P_NAMES[winner] + ' WINS'}</h2>
      <p>Final Scores:</p>
      ${players.map((p, i) => `<p style="color:${P_COLORS[i]}">${P_NAMES[i]}: ${p.score} pts ${!p.alive ? '(eliminated)' : ''}</p>`).join('')}
      <p style="color:#888;margin-top:8px;">Turn ${Math.min(turn, 40)} / 40</p>
      <button class="start-btn" onclick="location.reload()">PLAY AGAIN</button>
    `;
    document.getElementById('endTurnBtn').style.display = 'none';
  }

  // ========== DRAWING ==========
  function draw() {
    X.fillStyle = '#1a1a2e';
    X.fillRect(0, 0, W, H);

    // Draw hex grid
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let { x, y } = hexToPixel(r, c);
        let t = terrain[r][c];

        if (!explored[r][c]) {
          // Completely unknown
          drawHex(x, y, HEX_W, '#0a0a18', '#16213e', 0.5);
          continue;
        }

        let vis = visible[r][c];
        let color = TERRAIN_COLORS[t];
        if (!vis) {
          // Explored but not visible - darken
          color = darken(color, 0.4);
        }

        drawHex(x, y, HEX_W, color, '#16213e', 0.5);

        // Terrain icon
        if (vis || explored[r][c]) {
          X.fillStyle = vis ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)';
          X.font = '9px Courier New';
          X.textAlign = 'center';
          let icon = ['~','^','T','M','W'][t];
          X.fillText(icon, x, y + 12);
        }
      }
    }

    // Highlight reachable hexes
    for (let h of reachable) {
      let { x, y } = hexToPixel(h.r, h.c);
      let col = h.enemy ? 'rgba(255,80,80,0.35)' : 'rgba(204,170,68,0.25)';
      drawHex(x, y, HEX_W, col, h.enemy ? '#f44' : '#ca4', 1.5);
    }

    // Draw cities
    for (let city of cities) {
      if (!visible[city.r][city.c] && !explored[city.r][city.c]) continue;
      let { x, y } = hexToPixel(city.r, city.c);
      let vis = visible[city.r][city.c];
      let alpha = vis ? 1.0 : 0.4;

      // City background
      X.globalAlpha = alpha;
      drawHex(x, y, HEX_W, darken(P_COLORS[city.owner], 0.6), P_COLORS[city.owner], 2);

      // City icon
      X.fillStyle = P_COLORS[city.owner];
      X.font = city.isCapital ? 'bold 14px Courier New' : '12px Courier New';
      X.textAlign = 'center';
      X.fillText(city.isCapital ? '\u2655' : '\u25A0', x, y + 1);

      // City name
      X.font = '7px Courier New';
      X.fillStyle = '#fff';
      X.fillText(city.name, x, y - 11);

      // HP bar
      if (vis) {
        let bw = 16, bh = 2;
        X.fillStyle = '#400';
        X.fillRect(x - bw / 2, y + 6, bw, bh);
        X.fillStyle = '#4f4';
        X.fillRect(x - bw / 2, y + 6, bw * (city.hp / city.hpMax), bh);
      }
      X.globalAlpha = 1.0;
    }

    // Draw units
    for (let u of units) {
      if (!visible[u.r][u.c]) continue;
      let { x, y } = hexToPixel(u.r, u.c);

      // Unit circle
      X.beginPath();
      X.arc(x, y, 7, 0, Math.PI * 2);
      X.fillStyle = P_COLORS[u.owner];
      X.fill();
      X.strokeStyle = u === selectedUnit ? '#fff' : darken(P_COLORS[u.owner], 0.5);
      X.lineWidth = u === selectedUnit ? 2 : 1;
      X.stroke();

      // Unit symbol
      X.fillStyle = '#fff';
      X.font = '9px Courier New';
      X.textAlign = 'center';
      X.fillText(UNIT_SYMBOLS[u.type], x, y + 3);

      // HP indicator
      if (u.hp < u.hpMax) {
        let bw = 10, bh = 2;
        X.fillStyle = '#400';
        X.fillRect(x - bw / 2, y - 10, bw, bh);
        X.fillStyle = '#4f4';
        X.fillRect(x - bw / 2, y - 10, bw * (u.hp / u.hpMax), bh);
      }

      // Movement dots
      if (u.owner === 0 && u.moves > 0) {
        X.fillStyle = '#ca4';
        for (let m = 0; m < Math.min(u.moves, 3); m++) {
          X.beginPath();
          X.arc(x - 5 + m * 5, y + 10, 1.5, 0, Math.PI * 2);
          X.fill();
        }
      }
    }

    // Draw minimap (top-right)
    drawMinimap();

    // Update info panels
    updateInfoPanel();

    // Turn info
    let ti = document.getElementById('turnInfo');
    if (currentPlayer === 0) {
      ti.textContent = 'Your Turn';
      ti.style.color = P_COLORS[0];
    } else {
      ti.textContent = `${P_NAMES[currentPlayer]}'s Turn`;
      ti.style.color = P_COLORS[currentPlayer];
    }
  }

  function drawMinimap() {
    let mx = W - 100, my = 6, mw = 92, mh = 62;
    X.fillStyle = 'rgba(10,10,24,0.85)';
    X.fillRect(mx, my, mw, mh);
    X.strokeStyle = '#ca4';
    X.lineWidth = 1;
    X.strokeRect(mx, my, mw, mh);

    let sx = mw / COLS, sy = mh / ROWS;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!explored[r][c]) continue;
        let t = terrain[r][c];
        X.fillStyle = visible[r][c] ? TERRAIN_COLORS[t] : darken(TERRAIN_COLORS[t], 0.4);
        X.fillRect(mx + c * sx, my + r * sy, sx, sy);
      }
    }

    // Cities on minimap
    for (let city of cities) {
      X.fillStyle = P_COLORS[city.owner];
      X.fillRect(mx + city.c * sx - 1, my + city.r * sy - 1, 3, 3);
    }

    // Units on minimap
    for (let u of units) {
      if (u.owner === 0 || visible[u.r][u.c]) {
        X.fillStyle = P_COLORS[u.owner];
        X.fillRect(mx + u.c * sx, my + u.r * sy, 2, 2);
      }
    }

    X.font = '6px Courier New';
    X.fillStyle = '#ca4';
    X.textAlign = 'left';
    X.fillText('MAP', mx + 2, my + mh - 2);
  }

  function updateInfoPanel() {
    let sel = document.getElementById('selectedInfo');
    let tech = document.getElementById('techInfo');

    // Selected info
    if (selectedUnit && selectedUnit.owner === 0) {
      let u = selectedUnit;
      let html = `<b>${UNIT_NAMES[u.type]}</b> HP: ${u.hp}/${u.hpMax} Moves: ${u.moves}<br>`;
      if (u.type === U_SETTLER) {
        let canFound = !cities.find(c => hexDist(c.r, c.c, u.r, u.c) < 3) &&
          terrain[u.r][u.c] < T_MOUNTAIN;
        html += `<button class="action-btn" ${canFound ? `onclick="doFoundCity()"` : 'disabled'}>Found City</button>`;
      }
      if (u.type === U_BUILDER) {
        let nearCity = cities.find(c => hexDist(c.r, c.c, u.r, u.c) <= 2 && c.owner === 0);
        html += `<button class="action-btn" ${nearCity ? `onclick="doBuild()"` : 'disabled'}>Build Improvement</button>`;
      }
      sel.innerHTML = html;
    } else if (selectedCity && selectedCity.owner === 0) {
      let c = selectedCity;
      let html = `<b>${c.name}</b>${c.isCapital ? ' [CAPITAL]' : ''}<br>`;
      html += `HP: ${c.hp}/${c.hpMax} Pop: ${c.pop} Prod: ${c.prod}+${players[0].prodBonus} Food: ${c.food}<br>`;
      if (c.prodTarget !== null) {
        html += `Building: ${UNIT_NAMES[c.prodTarget]} (${c.prodProgress}/${UNIT_COST[c.prodTarget]})<br>`;
      } else {
        html += 'Produce: ';
        for (let i = 0; i < UNIT_NAMES.length; i++) {
          // Check if Builder is unlocked
          if (i === U_BUILDER && players[0].techLevel < 1) continue;
          html += `<button class="action-btn" onclick="setProd(${i})">${UNIT_NAMES[i]} (${UNIT_COST[i]})</button>`;
        }
      }
      sel.innerHTML = html;
    } else {
      sel.innerHTML = 'Click a unit or city on the map';
    }

    // Tech info
    let p = players[0];
    let html = '';
    for (let i = 0; i < TECHS.length; i++) {
      let t = TECHS[i];
      if (i <= p.techLevel) {
        html += `<span style="color:#4f4">\u2713 ${t.name}</span><br>`;
      } else if (i === p.techLevel + 1) {
        html += `<b style="color:#ca4">\u25B6 ${t.name}</b> ${p.techProgress}/${t.cost}<br>`;
        html += `<span style="color:#888;font-size:0.65rem">${t.desc}</span><br>`;
      } else {
        html += `<span style="color:#555">\u25CB ${t.name}</span><br>`;
      }
    }
    tech.innerHTML = html;
  }

  function darken(hex, factor) {
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    return `rgb(${r},${g},${b})`;
  }

  // ========== INPUT ==========
  C.addEventListener('click', (e) => {
    if (gameState !== 'playing' || currentPlayer !== 0) return;

    let rect = C.getBoundingClientRect();
    let mx = (e.clientX - rect.left) * (W / rect.width);
    let my = (e.clientY - rect.top) * (H / rect.height);

    let hex = pixelToHex(mx, my);
    if (!hex) return;

    // Check if clicking a reachable hex (to move selected unit)
    if (selectedUnit && selectedUnit.owner === 0 && selectedUnit.moves > 0) {
      let dest = reachable.find(h => h.r === hex.r && h.c === hex.c);
      if (dest) {
        if (dest.enemy) {
          combat(selectedUnit, dest.enemy);
        } else {
          // Move unit
          let cost = TERRAIN_MOVE[terrain[hex.r][hex.c]];
          selectedUnit.r = hex.r;
          selectedUnit.c = hex.c;
          selectedUnit.moves = Math.max(0, selectedUnit.moves - cost);

          // Check if moved onto enemy city
          let enemyCity = cities.find(c => c.r === hex.r && c.c === hex.c && c.owner !== 0);
          if (enemyCity && selectedUnit && UNIT_STR[selectedUnit.type] > 0) {
            attackCity(selectedUnit, enemyCity);
          }
        }
        updateVisibility();
        if (selectedUnit && selectedUnit.moves > 0) {
          reachable = getReachable(selectedUnit);
        } else {
          reachable = [];
        }
        updateScore();
        draw();
        return;
      }
    }

    // Check if clicking own unit
    let clickedUnit = units.find(u => u.r === hex.r && u.c === hex.c && u.owner === 0);
    if (clickedUnit) {
      selectedUnit = clickedUnit;
      selectedCity = null;
      reachable = clickedUnit.moves > 0 ? getReachable(clickedUnit) : [];
      draw();
      return;
    }

    // Check if clicking own city
    let clickedCity = cities.find(c => c.r === hex.r && c.c === hex.c && c.owner === 0);
    if (clickedCity) {
      selectedCity = clickedCity;
      selectedUnit = null;
      reachable = [];
      draw();
      return;
    }

    // Deselect
    selectedUnit = null;
    selectedCity = null;
    reachable = [];
    draw();
  });

  // Global functions for buttons
  window.doFoundCity = function() {
    if (selectedUnit && selectedUnit.type === U_SETTLER) {
      foundCity(selectedUnit);
      updateVisibility();
      updateScore();
      draw();
    }
  };

  window.doBuild = function() {
    if (selectedUnit && selectedUnit.type === U_BUILDER) {
      buildImprovement(selectedUnit);
      selectedUnit = null;
      reachable = [];
      updateScore();
      draw();
    }
  };

  window.setProd = function(unitType) {
    if (selectedCity && selectedCity.owner === 0) {
      selectedCity.prodTarget = unitType;
      selectedCity.prodProgress = 0;
      draw();
    }
  };

  document.getElementById('endTurnBtn').addEventListener('click', () => {
    if (gameState === 'playing' && currentPlayer === 0) endTurn();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      if (gameState === 'waiting') init();
      else if (gameState === 'playing' && currentPlayer === 0) endTurn();
    }
    if (e.key === 'Escape') {
      selectedUnit = null;
      selectedCity = null;
      reachable = [];
      draw();
    }
    // Keyboard shortcuts
    if (gameState === 'playing' && currentPlayer === 0) {
      if (e.key === 'f' && selectedUnit && selectedUnit.type === U_SETTLER) doFoundCity();
      if (e.key === 'b' && selectedUnit && selectedUnit.type === U_BUILDER) doBuild();
    }
  });

  function addLog(msg) {
    logLines.unshift(`T${turn}: ${msg}`);
    if (logLines.length > 30) logLines.pop();
    let el = document.getElementById('log');
    if (el) el.innerHTML = logLines.join('<br>');
  }

  // ========== START ==========
  document.getElementById('startBtn').addEventListener('click', init);

  // Initial draw
  function drawTitle() {
    X.fillStyle = '#1a1a2e';
    X.fillRect(0, 0, W, H);
    // Draw decorative hex grid
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let { x, y } = hexToPixel(r, c);
        let alpha = 0.05 + Math.random() * 0.08;
        drawHex(x, y, HEX_W, `rgba(204,170,68,${alpha})`, 'rgba(204,170,68,0.1)', 0.5);
      }
    }
  }
  drawTitle();
  </script>
  <script src="../recorder.js"></script>
</body>
</html>

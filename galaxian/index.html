<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxian</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #84f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136,68,255,0.4); }
    h1 { color: #84f; font-size: 2rem; text-shadow: 0 0 15px rgba(136,68,255,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #84f; }
    canvas {
      border: 2px solid #84f;
      box-shadow: 0 0 20px rgba(136,68,255,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #84f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>GALAXIAN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">GALAXIAN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const PLAYER_W = 32, PLAYER_H = 24;
    const PLAYER_SPEED = 4;
    const PLAYER_Y = H - 50;
    const BULLET_SPEED = 8;
    const ALIEN_W = 28, ALIEN_H = 20;

    // Row types: flagship (top), commander, escorts, drones (bottom rows)
    // Points: flagship=60, commander=40, escort=25, drone=15
    const ROW_DEFS = [
      { type: 'flagship',  count: 4,  color: '#ff4', glow: '#ff4', points: 60 },
      { type: 'commander', count: 8,  color: '#f44', glow: '#f44', points: 40 },
      { type: 'escort',    count: 10, color: '#84f', glow: '#84f', points: 25 },
      { type: 'escort',    count: 10, color: '#4af', glow: '#4af', points: 25 },
      { type: 'drone',     count: 10, color: '#0cf', glow: '#0cf', points: 15 },
      { type: 'drone',     count: 10, color: '#0cf', glow: '#0cf', points: 15 },
    ];

    // Stars
    const NUM_STARS = 80;
    let stars = [];

    // Game state
    let score, best = 0, lives, gameState;
    let player, bullet, aliens, divers, alienBullets, particles;
    let formX, formDir, formSpeed, tick, wave;
    let diveTimer, diveInterval;
    let keys = {};

    // --- Star field ---
    function initStars() {
      stars = [];
      for (let i = 0; i < NUM_STARS; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          speed: 0.3 + Math.random() * 1.2,
          brightness: 0.3 + Math.random() * 0.7,
          size: Math.random() < 0.3 ? 2 : 1
        });
      }
    }

    function updateStars() {
      for (const s of stars) {
        s.y += s.speed;
        if (s.y > H) {
          s.y = 0;
          s.x = Math.random() * W;
        }
      }
    }

    function drawStars() {
      for (const s of stars) {
        const a = Math.round(s.brightness * 255).toString(16).padStart(2, '0');
        ctx.fillStyle = '#ffffff' + a;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }
    }

    // --- Aliens ---
    function makeAlien(type, color, glow, points, row, col, fx, fy) {
      return {
        type, color, glow, points, row, col,
        formX: fx, formY: fy,
        alive: true, diving: false,
        // Dive state
        diveX: 0, diveY: 0, diveVX: 0, diveVY: 0,
        divePhase: 0, // 0=formation, 1=swooping down, 2=looping back
        diveAngle: 0, diveRadius: 0,
        diveCenterX: 0, diveCenterY: 0,
      };
    }

    function spawnFormation() {
      aliens = [];
      const startY = 60;
      const rowGap = ALIEN_H + 8;

      for (let r = 0; r < ROW_DEFS.length; r++) {
        const def = ROW_DEFS[r];
        const totalW = def.count * (ALIEN_W + 6) - 6;
        const sx = (W - totalW) / 2;
        for (let c = 0; c < def.count; c++) {
          aliens.push(makeAlien(
            def.type, def.color, def.glow, def.points,
            r, c,
            sx + c * (ALIEN_W + 6),
            startY + r * rowGap
          ));
        }
      }
    }

    function alienScreenX(a) {
      if (a.diving) return a.diveX;
      return a.formX + formX;
    }

    function alienScreenY(a) {
      if (a.diving) return a.diveY;
      return a.formY;
    }

    // --- Dive bombing ---
    function startDive(a) {
      if (a.diving || !a.alive) return;
      a.diving = true;
      a.divePhase = 1;
      a.diveX = a.formX + formX;
      a.diveY = a.formY;

      // Aim toward the player with a curving path
      const targetX = player.x + PLAYER_W / 2;
      const dx = targetX - (a.diveX + ALIEN_W / 2);
      const speed = 2.5 + wave * 0.15;

      // Swooping: move down with a slight horizontal bias toward player
      a.diveVX = dx * 0.008 + (Math.random() - 0.5) * 1.5;
      a.diveVY = speed;
      a.diveAngle = 0;
    }

    function updateDiver(a) {
      if (a.divePhase === 1) {
        // Swooping down toward player
        a.diveX += a.diveVX;
        a.diveY += a.diveVY;

        // Slightly curve toward player
        const targetX = player.x + PLAYER_W / 2;
        const dx = targetX - (a.diveX + ALIEN_W / 2);
        a.diveVX += dx * 0.002;
        a.diveVX = Math.max(-3, Math.min(3, a.diveVX));

        // Alien shoots while diving (chance per frame)
        if (Math.random() < 0.015) {
          alienBullets.push({
            x: a.diveX + ALIEN_W / 2,
            y: a.diveY + ALIEN_H,
            vx: a.diveVX * 0.3,
            vy: 4
          });
        }

        // Went past bottom -- loop back up from top
        if (a.diveY > H + 20) {
          a.divePhase = 2;
          a.diveY = -30;
          a.diveX = a.formX + formX + (Math.random() - 0.5) * 60;
        }

        // Keep within horizontal bounds
        if (a.diveX < 5) a.diveVX = Math.abs(a.diveVX);
        if (a.diveX + ALIEN_W > W - 5) a.diveVX = -Math.abs(a.diveVX);
      } else if (a.divePhase === 2) {
        // Returning to formation from top
        const targetX = a.formX + formX;
        const targetY = a.formY;
        const dx = targetX - a.diveX;
        const dy = targetY - a.diveY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 4) {
          // Back in formation
          a.diving = false;
          a.divePhase = 0;
        } else {
          const speed = Math.min(3, dist * 0.04);
          a.diveX += (dx / dist) * speed;
          a.diveY += (dy / dist) * speed;
        }
      }
    }

    function triggerDive() {
      const inFormation = aliens.filter(a => a.alive && !a.diving);
      if (inFormation.length === 0) return;

      // Higher rows (flagships, commanders) dive more aggressively
      // Pick a random alien, weighted toward top rows
      const weights = inFormation.map(a => {
        if (a.type === 'flagship') return 4;
        if (a.type === 'commander') return 3;
        if (a.type === 'escort') return 2;
        return 1;
      });
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * totalWeight;
      let chosen = inFormation[0];
      for (let i = 0; i < inFormation.length; i++) {
        r -= weights[i];
        if (r <= 0) { chosen = inFormation[i]; break; }
      }

      startDive(chosen);

      // Flagships bring escorts with them
      if (chosen.type === 'flagship') {
        const escorts = inFormation.filter(a =>
          a.type === 'escort' && !a.diving &&
          Math.abs(a.col - chosen.col * 2.5) < 4
        );
        const toTake = escorts.slice(0, 2);
        for (const e of toTake) {
          setTimeout(() => startDive(e), 150 + Math.random() * 200);
        }
      }
    }

    // --- Particles ---
    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 14; i++) {
        const ang = (Math.PI * 2 / 14) * i + Math.random() * 0.4;
        const spd = 1.5 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 18 + Math.random() * 12,
          maxLife: 30,
          color
        });
      }
    }

    // --- Init / Start / Game Over ---
    function init() {
      score = 0;
      lives = 3;
      wave = 1;
      tick = 0;
      formX = 0;
      formDir = 1;
      formSpeed = 0.4;
      diveTimer = 0;
      diveInterval = 120;
      player = { x: W / 2 - PLAYER_W / 2 };
      bullet = null;
      alienBullets = [];
      particles = [];
      keys = {};

      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GALAXIAN';
      overlayText.textContent = 'Press SPACE to start';

      initStars();
      spawnFormation();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function nextWave() {
      wave++;
      formX = 0;
      formDir = 1;
      formSpeed = 0.4 + wave * 0.08;
      diveInterval = Math.max(40, 120 - wave * 8);
      diveTimer = 0;
      bullet = null;
      alienBullets = [];
      spawnFormation();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press SPACE to restart`;
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      spawnExplosion(player.x + PLAYER_W / 2, PLAYER_Y + PLAYER_H / 2, '#84f');
      if (lives <= 0) {
        gameOver();
        return;
      }
      // Brief invulnerability handled by respawn delay
      player.x = W / 2 - PLAYER_W / 2;
      bullet = null;
      alienBullets = [];
    }

    // --- Game loop ---
    function loop() {
      if (gameState !== 'playing') return;
      tick++;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      updateStars();

      // Player movement
      if (keys['ArrowLeft']) player.x = Math.max(0, player.x - PLAYER_SPEED);
      if (keys['ArrowRight']) player.x = Math.min(W - PLAYER_W, player.x + PLAYER_SPEED);

      // Check all aliens dead
      const liveAliens = aliens.filter(a => a.alive);
      if (liveAliens.length === 0) {
        nextWave();
        return;
      }

      // Formation movement
      const inFormation = liveAliens.filter(a => !a.diving);
      if (inFormation.length > 0) {
        const leftMost = Math.min(...inFormation.map(a => a.formX)) + formX;
        const rightMost = Math.max(...inFormation.map(a => a.formX + ALIEN_W)) + formX;

        if ((formDir === 1 && rightMost >= W - 10) || (formDir === -1 && leftMost <= 10)) {
          formDir *= -1;
        }
        formX += formSpeed * formDir;
      }

      // Dive bombing
      diveTimer++;
      if (diveTimer >= diveInterval) {
        diveTimer = 0;
        triggerDive();
      }

      // Update divers
      for (const a of aliens) {
        if (a.alive && a.diving) {
          updateDiver(a);
        }
      }

      // Player bullet
      if (bullet) {
        bullet.y -= BULLET_SPEED;
        if (bullet.y < -10) bullet = null;
      }

      // Bullet vs aliens
      if (bullet) {
        for (const a of aliens) {
          if (!a.alive) continue;
          const ax = alienScreenX(a);
          const ay = alienScreenY(a);
          if (bullet.x >= ax && bullet.x <= ax + ALIEN_W &&
              bullet.y >= ay && bullet.y <= ay + ALIEN_H) {
            a.alive = false;
            bullet = null;

            // Diving aliens give double points
            const pts = a.diving ? a.points * 2 : a.points;
            score += pts;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
            spawnExplosion(ax + ALIEN_W / 2, ay + ALIEN_H / 2, a.color);
            break;
          }
        }
      }

      // Alien bullets
      for (let i = alienBullets.length - 1; i >= 0; i--) {
        const b = alienBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.y > H || b.x < 0 || b.x > W) {
          alienBullets.splice(i, 1);
          continue;
        }
        // Hit player
        if (b.x >= player.x && b.x <= player.x + PLAYER_W &&
            b.y >= PLAYER_Y && b.y <= PLAYER_Y + PLAYER_H) {
          alienBullets.splice(i, 1);
          loseLife();
          if (gameState === 'over') return;
        }
      }

      // Diving aliens collide with player
      for (const a of aliens) {
        if (!a.alive || !a.diving) continue;
        const ax = alienScreenX(a);
        const ay = alienScreenY(a);
        if (ax < player.x + PLAYER_W && ax + ALIEN_W > player.x &&
            ay < PLAYER_Y + PLAYER_H && ay + ALIEN_H > PLAYER_Y) {
          a.alive = false;
          spawnExplosion(ax + ALIEN_W / 2, ay + ALIEN_H / 2, a.color);
          loseLife();
          if (gameState === 'over') return;
        }
      }

      // Formation aliens shoot occasionally
      if (tick % 50 === 0) {
        const shooters = inFormation.filter(a => a.alive);
        if (shooters.length > 0) {
          const a = shooters[Math.floor(Math.random() * shooters.length)];
          const ax = alienScreenX(a) + ALIEN_W / 2;
          const ay = alienScreenY(a) + ALIEN_H;
          alienBullets.push({ x: ax, y: ay, vx: 0, vy: 3 + wave * 0.2 });
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.97;
        p.vy *= 0.97;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- Drawing ---
    function drawAlien(a) {
      const x = alienScreenX(a);
      const y = alienScreenY(a);

      ctx.shadowColor = a.glow;
      ctx.shadowBlur = 8;

      if (a.type === 'flagship') {
        // Flagship: larger, wing-shaped, yellow
        ctx.fillStyle = a.color;
        ctx.beginPath();
        ctx.moveTo(x + ALIEN_W / 2, y);
        ctx.lineTo(x + ALIEN_W + 4, y + ALIEN_H * 0.6);
        ctx.lineTo(x + ALIEN_W, y + ALIEN_H);
        ctx.lineTo(x, y + ALIEN_H);
        ctx.lineTo(x - 4, y + ALIEN_H * 0.6);
        ctx.closePath();
        ctx.fill();
        // Crown detail
        ctx.fillStyle = '#fa0';
        ctx.fillRect(x + ALIEN_W / 2 - 3, y + 2, 6, 4);
        // Eyes
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(x + 8, y + 10, 3, 3);
        ctx.fillRect(x + ALIEN_W - 11, y + 10, 3, 3);
      } else if (a.type === 'commander') {
        // Commander: red, angular
        ctx.fillStyle = a.color;
        ctx.beginPath();
        ctx.moveTo(x + ALIEN_W / 2, y);
        ctx.lineTo(x + ALIEN_W, y + ALIEN_H * 0.5);
        ctx.lineTo(x + ALIEN_W - 3, y + ALIEN_H);
        ctx.lineTo(x + 3, y + ALIEN_H);
        ctx.lineTo(x, y + ALIEN_H * 0.5);
        ctx.closePath();
        ctx.fill();
        // Wing marks
        ctx.fillStyle = '#d22';
        ctx.fillRect(x + 3, y + ALIEN_H * 0.4, 4, 3);
        ctx.fillRect(x + ALIEN_W - 7, y + ALIEN_H * 0.4, 4, 3);
        // Eyes
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(x + 9, y + 9, 3, 3);
        ctx.fillRect(x + ALIEN_W - 12, y + 9, 3, 3);
      } else if (a.type === 'escort') {
        // Escort: diamond-ish
        ctx.fillStyle = a.color;
        ctx.beginPath();
        ctx.moveTo(x + ALIEN_W / 2, y);
        ctx.lineTo(x + ALIEN_W, y + ALIEN_H / 2);
        ctx.lineTo(x + ALIEN_W / 2, y + ALIEN_H);
        ctx.lineTo(x, y + ALIEN_H / 2);
        ctx.closePath();
        ctx.fill();
        // Core
        ctx.fillStyle = '#1a1a2e';
        ctx.beginPath();
        ctx.arc(x + ALIEN_W / 2, y + ALIEN_H / 2, 3, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Drone: simple rectangle with antennae
        ctx.fillStyle = a.color;
        ctx.fillRect(x + 2, y + 4, ALIEN_W - 4, ALIEN_H - 6);
        ctx.fillRect(x + 6, y, ALIEN_W - 12, ALIEN_H - 2);
        // Antennae
        ctx.fillRect(x + 4, y - 2, 2, 4);
        ctx.fillRect(x + ALIEN_W - 6, y - 2, 2, 4);
        // Eyes
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(x + 8, y + 6, 3, 3);
        ctx.fillRect(x + ALIEN_W - 11, y + 6, 3, 3);
      }

      ctx.shadowBlur = 0;
    }

    function drawPlayer() {
      const x = player.x, y = PLAYER_Y;
      ctx.fillStyle = '#84f';
      ctx.shadowColor = '#84f';
      ctx.shadowBlur = 12;

      // Ship body
      ctx.beginPath();
      ctx.moveTo(x + PLAYER_W / 2, y - 6);
      ctx.lineTo(x + PLAYER_W, y + PLAYER_H);
      ctx.lineTo(x + PLAYER_W - 4, y + PLAYER_H);
      ctx.lineTo(x + PLAYER_W / 2, y + PLAYER_H - 6);
      ctx.lineTo(x + 4, y + PLAYER_H);
      ctx.lineTo(x, y + PLAYER_H);
      ctx.closePath();
      ctx.fill();

      // Cockpit highlight
      ctx.fillStyle = '#b8f';
      ctx.fillRect(x + PLAYER_W / 2 - 2, y + 2, 4, 6);

      // Engine glow
      const flicker = Math.sin(tick * 0.3) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(136,68,255,${flicker})`;
      ctx.fillRect(x + PLAYER_W / 2 - 4, y + PLAYER_H - 2, 8, 4);

      ctx.shadowBlur = 0;
    }

    function drawLivesIndicator() {
      for (let i = 0; i < lives - 1; i++) {
        const lx = 10 + i * 22;
        const ly = H - 20;
        ctx.fillStyle = '#84f';
        ctx.shadowColor = '#84f';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(lx + 7, ly);
        ctx.lineTo(lx + 14, ly + 10);
        ctx.lineTo(lx, ly + 10);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function drawWaveIndicator() {
      ctx.fillStyle = '#84f';
      ctx.shadowColor = '#84f';
      ctx.shadowBlur = 4;
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('WAVE ' + wave, W - 10, H - 10);
      ctx.textAlign = 'left';
      ctx.shadowBlur = 0;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Stars
      drawStars();

      // Aliens
      for (const a of aliens) {
        if (a.alive) drawAlien(a);
      }

      // Player
      if (gameState === 'playing' || gameState === 'waiting') {
        drawPlayer();
      }

      // Player bullet
      if (bullet) {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#84f';
        ctx.shadowBlur = 10;
        ctx.fillRect(bullet.x - 1.5, bullet.y, 3, 10);
        ctx.shadowBlur = 0;
      }

      // Alien bullets
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      for (const b of alienBullets) {
        ctx.fillStyle = '#f66';
        ctx.fillRect(b.x - 1.5, b.y, 3, 8);
      }
      ctx.shadowBlur = 0;

      // Particles
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;

      // Lives indicator
      drawLivesIndicator();

      // Wave indicator
      drawWaveIndicator();
    }

    // --- Shooting ---
    function shoot() {
      if (bullet) return; // One shot at a time
      bullet = { x: player.x + PLAYER_W / 2, y: PLAYER_Y };
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') { start(); }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') { init(); }
        return;
      }

      keys[e.key] = true;
      if (e.key === ' ' && gameState === 'playing') shoot();
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

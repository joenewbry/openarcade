<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tanks</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #af4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 255, 68, 0.4); }
    h1 { color: #af4; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 255, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #af4; }
    canvas {
      border: 2px solid #af4;
      box-shadow: 0 0 20px rgba(170, 255, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #af4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .game-row { display: flex; gap: 20px; align-items: flex-start; }
    .keypad { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 20px; }
    .keypad-row { display: flex; gap: 4px; }
    .kp-key {
      width: 44px; height: 44px;
      background: #16213e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; color: #555;
      transition: background 0.06s, border-color 0.06s, color 0.06s, box-shadow 0.06s;
    }
    .kp-key.active {
      background: rgba(170, 255, 68, 0.15);
      border-color: #af4;
      color: #af4;
      box-shadow: 0 0 12px rgba(170, 255, 68, 0.4);
    }
    .kp-spacer { width: 44px; height: 44px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TANKS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="game-row">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="600" height="400"></canvas>
      <div class="overlay" id="overlay" style="width:600px;height:400px;">
        <h2 id="overlayTitle">TANKS</h2>
        <p id="overlayText">Press SPACE to start</p>
      </div>
    </div>
    <div class="keypad">
      <div class="keypad-row">
        <div class="kp-spacer"></div>
        <div class="kp-key" id="kp-up">&uarr;</div>
        <div class="kp-spacer"></div>
      </div>
      <div class="keypad-row">
        <div class="kp-key" id="kp-left">&larr;</div>
        <div class="kp-key" id="kp-down">&darr;</div>
        <div class="kp-key" id="kp-right">&rarr;</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Constants
    const GRAVITY = 0.15;
    const TANK_W = 30;
    const TANK_H = 16;
    const BARREL_LEN = 22;
    const BARREL_W = 4;
    const MAX_HP = 5;
    const HP_BAR_W = 40;
    const HP_BAR_H = 6;
    const PROJECTILE_R = 3;
    const EXPLOSION_DURATION = 30;
    const CRATER_RADIUS = 20;
    const ANGLE_SPEED = 1.5; // degrees per frame
    const POWER_SPEED = 0.5;
    const MIN_POWER = 5;
    const MAX_POWER = 25;
    const MIN_ANGLE = 10;
    const MAX_ANGLE = 80;
    const CPU_THINK_FRAMES = 40;
    const CPU_FIRE_DELAY = 20;

    // Game state
    let terrain;
    let player, enemy;
    let projectile;
    let wind;
    let turn; // 'player' or 'enemy'
    let turnPhase; // 'aiming', 'firing', 'exploding', 'cpuThink', 'cpuFire', 'roundTransition'
    let explosions;
    let trailPoints;
    let cpuTimer;
    let roundNum;
    let keys = {};

    function generateTerrain() {
      terrain = new Array(W);
      // Base height with multiple sine waves for hilly terrain
      const baseH = H * 0.55;
      const amp1 = 40 + Math.random() * 30;
      const freq1 = 0.008 + Math.random() * 0.006;
      const phase1 = Math.random() * Math.PI * 2;
      const amp2 = 20 + Math.random() * 15;
      const freq2 = 0.02 + Math.random() * 0.01;
      const phase2 = Math.random() * Math.PI * 2;
      const amp3 = 10 + Math.random() * 8;
      const freq3 = 0.05 + Math.random() * 0.03;
      const phase3 = Math.random() * Math.PI * 2;

      for (let x = 0; x < W; x++) {
        terrain[x] = baseH
          + Math.sin(x * freq1 + phase1) * amp1
          + Math.sin(x * freq2 + phase2) * amp2
          + Math.sin(x * freq3 + phase3) * amp3;
      }

      // Ensure edges are above bottom
      for (let x = 0; x < W; x++) {
        terrain[x] = Math.max(H * 0.3, Math.min(H - 20, terrain[x]));
      }
    }

    function getTerrainY(x) {
      const ix = Math.floor(Math.max(0, Math.min(W - 1, x)));
      return terrain[ix];
    }

    function createCrater(cx, cy, radius) {
      for (let x = Math.max(0, Math.floor(cx - radius)); x < Math.min(W, Math.ceil(cx + radius)); x++) {
        const dx = x - cx;
        const dist = Math.abs(dx);
        if (dist < radius) {
          const depth = Math.sqrt(radius * radius - dx * dx) * 0.6;
          // Only deform if crater center is near terrain level
          if (cy >= terrain[x] - radius) {
            terrain[x] = Math.min(H - 5, terrain[x] + depth);
          }
        }
      }
    }

    function makeTank(x, isPlayer) {
      const ty = getTerrainY(x);
      return {
        x: x,
        y: ty,
        hp: MAX_HP,
        angle: isPlayer ? 45 : 45, // degrees from horizontal
        power: 15,
        isPlayer: isPlayer
      };
    }

    function setWind() {
      wind = (Math.random() - 0.5) * 0.12; // wind acceleration
    }

    function initRound() {
      generateTerrain();
      // Place tanks
      const px = 40 + Math.floor(Math.random() * 80);
      const ex = W - 40 - Math.floor(Math.random() * 80);
      player = makeTank(px, true);
      enemy = makeTank(ex, false);
      setWind();
      turn = 'player';
      turnPhase = 'aiming';
      projectile = null;
      explosions = [];
      trailPoints = [];
      cpuTimer = 0;
    }

    function init() {
      score = 0;
      roundNum = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TANKS';
      overlayText.textContent = 'Press SPACE to start';
      initRound();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} — Press SPACE to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function fireProjectile(tank) {
      const dir = tank.isPlayer ? 1 : -1;
      const angleRad = tank.angle * Math.PI / 180;
      const bx = tank.x + Math.cos(angleRad) * BARREL_LEN * dir;
      const by = tank.y - TANK_H - Math.sin(angleRad) * BARREL_LEN;
      projectile = {
        x: bx,
        y: by,
        vx: Math.cos(angleRad) * tank.power * dir,
        vy: -Math.sin(angleRad) * tank.power
      };
      trailPoints = [];
      turnPhase = 'firing';
    }

    function cpuCalculateShot() {
      // CPU aims at player with some inaccuracy
      const dx = player.x - enemy.x;
      const dy = (player.y - TANK_H / 2) - (enemy.y - TANK_H / 2);

      // Try to find a reasonable angle and power
      // Simple heuristic: aim roughly at the player
      let bestAngle = 45;
      let bestPower = 15;
      let bestDist = Infinity;

      // Monte Carlo approach: simulate a few shots and pick the best
      for (let trial = 0; trial < 20; trial++) {
        const testAngle = 20 + Math.random() * 60;
        const testPower = 8 + Math.random() * 17;
        const angleRad = testAngle * Math.PI / 180;
        let sx = enemy.x + Math.cos(angleRad) * BARREL_LEN * -1;
        let sy = enemy.y - TANK_H - Math.sin(angleRad) * BARREL_LEN;
        let svx = Math.cos(angleRad) * testPower * -1;
        let svy = -Math.sin(angleRad) * testPower;

        // Simulate trajectory
        for (let step = 0; step < 300; step++) {
          svx += wind;
          svy += GRAVITY;
          sx += svx;
          sy += svy;

          if (sx < 0 || sx >= W || sy > H + 50) break;
          if (sy >= getTerrainY(sx)) {
            const dist = Math.sqrt((sx - player.x) ** 2 + (sy - player.y) ** 2);
            if (dist < bestDist) {
              bestDist = dist;
              bestAngle = testAngle;
              bestPower = testPower;
            }
            break;
          }
        }
      }

      // Add some randomness based on round (gets more accurate)
      const accuracy = Math.max(0.5, 1 - roundNum * 0.08);
      enemy.angle = bestAngle + (Math.random() - 0.5) * 15 * accuracy;
      enemy.angle = Math.max(MIN_ANGLE, Math.min(MAX_ANGLE, enemy.angle));
      enemy.power = bestPower + (Math.random() - 0.5) * 5 * accuracy;
      enemy.power = Math.max(MIN_POWER, Math.min(MAX_POWER, enemy.power));
    }

    function update() {
      // Handle aiming input for player
      if (turn === 'player' && turnPhase === 'aiming') {
        if (keys['ArrowUp']) {
          player.angle = Math.min(MAX_ANGLE, player.angle + ANGLE_SPEED);
        }
        if (keys['ArrowDown']) {
          player.angle = Math.max(MIN_ANGLE, player.angle - ANGLE_SPEED);
        }
        if (keys['ArrowRight']) {
          player.power = Math.min(MAX_POWER, player.power + POWER_SPEED);
        }
        if (keys['ArrowLeft']) {
          player.power = Math.max(MIN_POWER, player.power - POWER_SPEED);
        }
      }

      // CPU turn logic
      if (turn === 'enemy' && turnPhase === 'cpuThink') {
        cpuTimer++;
        if (cpuTimer >= CPU_THINK_FRAMES) {
          cpuCalculateShot();
          turnPhase = 'cpuFire';
          cpuTimer = 0;
        }
      }
      if (turn === 'enemy' && turnPhase === 'cpuFire') {
        cpuTimer++;
        if (cpuTimer >= CPU_FIRE_DELAY) {
          fireProjectile(enemy);
          cpuTimer = 0;
        }
      }

      // Update projectile
      if (turnPhase === 'firing' && projectile) {
        // Apply wind and gravity
        projectile.vx += wind;
        projectile.vy += GRAVITY;
        projectile.x += projectile.vx;
        projectile.y += projectile.vy;

        // Record trail
        trailPoints.push({ x: projectile.x, y: projectile.y });
        if (trailPoints.length > 200) trailPoints.shift();

        // Check bounds
        if (projectile.x < -20 || projectile.x > W + 20 || projectile.y > H + 50) {
          // Missed everything
          endTurn();
          return;
        }

        // Check terrain collision
        if (projectile.y >= getTerrainY(projectile.x) && projectile.y > 0) {
          impact(projectile.x, projectile.y);
          return;
        }

        // Check hit on player tank
        if (turn === 'enemy') {
          if (Math.abs(projectile.x - player.x) < TANK_W / 2 + PROJECTILE_R &&
              projectile.y >= player.y - TANK_H - 4 &&
              projectile.y <= player.y + 4) {
            impact(projectile.x, projectile.y);
            player.hp--;
            return;
          }
        }

        // Check hit on enemy tank
        if (turn === 'player') {
          if (Math.abs(projectile.x - enemy.x) < TANK_W / 2 + PROJECTILE_R &&
              projectile.y >= enemy.y - TANK_H - 4 &&
              projectile.y <= enemy.y + 4) {
            impact(projectile.x, projectile.y);
            enemy.hp--;
            score += 20;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
            return;
          }
        }
      }

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].frame++;
        // Update particles
        for (const p of explosions[i].particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.life--;
        }
        explosions[i].particles = explosions[i].particles.filter(p => p.life > 0);
        if (explosions[i].frame > EXPLOSION_DURATION) {
          explosions.splice(i, 1);
        }
      }

      // Check if explosion phase is done
      if (turnPhase === 'exploding' && explosions.length === 0) {
        // Check if a tank was destroyed
        if (enemy.hp <= 0) {
          // Player wins round
          score += 50;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
          roundNum++;
          turnPhase = 'roundTransition';
          // Start new round after short delay
          setTimeout(() => {
            if (gameState !== 'playing') return;
            initRound();
          }, 600);
          return;
        }
        if (player.hp <= 0) {
          gameOver();
          return;
        }
        endTurn();
      }
    }

    function impact(ix, iy) {
      projectile = null;
      turnPhase = 'exploding';
      createCrater(ix, iy, CRATER_RADIUS);

      // Update tank positions after terrain deformation
      player.y = getTerrainY(player.x);
      enemy.y = getTerrainY(enemy.x);

      // Create explosion
      const particles = [];
      const count = 20 + Math.floor(Math.random() * 10);
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x: ix,
          y: iy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          life: 15 + Math.floor(Math.random() * 20),
          color: Math.random() < 0.5 ? '#ff4' : (Math.random() < 0.5 ? '#f84' : '#fa0')
        });
      }
      explosions.push({ x: ix, y: iy, frame: 0, particles: particles });
    }

    function endTurn() {
      projectile = null;
      trailPoints = [];
      setWind();
      if (turn === 'player') {
        turn = 'enemy';
        turnPhase = 'cpuThink';
        cpuTimer = 0;
      } else {
        turn = 'player';
        turnPhase = 'aiming';
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Sky gradient (subtle)
      const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.6);
      skyGrad.addColorStop(0, '#0a0a1a');
      skyGrad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, H * 0.6);

      // Draw terrain
      ctx.fillStyle = '#16213e';
      ctx.beginPath();
      ctx.moveTo(0, H);
      for (let x = 0; x < W; x++) {
        ctx.lineTo(x, terrain[x]);
      }
      ctx.lineTo(W, H);
      ctx.closePath();
      ctx.fill();

      // Terrain surface line with glow
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#0f3460';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      for (let x = 0; x < W; x++) {
        if (x === 0) ctx.moveTo(x, terrain[x]);
        else ctx.lineTo(x, terrain[x]);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Draw tanks
      drawTank(player, '#af4', true);
      drawTank(enemy, '#f44', false);

      // Draw HP bars
      drawHPBar(player);
      drawHPBar(enemy);

      // Draw projectile trail
      if (trailPoints.length > 1) {
        ctx.strokeStyle = 'rgba(170, 255, 68, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 5]);
        ctx.beginPath();
        ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
        for (let i = 1; i < trailPoints.length; i++) {
          ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw projectile
      if (projectile) {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#ff4';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, PROJECTILE_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw explosions
      for (const exp of explosions) {
        // Flash circle
        if (exp.frame < 8) {
          const r = exp.frame * 3;
          const alpha = 1 - exp.frame / 8;
          ctx.fillStyle = `rgba(255, 200, 50, ${alpha})`;
          ctx.shadowColor = '#ff4';
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
        // Particles
        for (const p of exp.particles) {
          const alpha = p.life / 35;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = Math.max(0, alpha);
          ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
        }
        ctx.globalAlpha = 1;
      }

      // Draw wind indicator
      drawWindIndicator();

      // Draw aiming info for player
      if (turn === 'player' && turnPhase === 'aiming') {
        drawAimingInfo();
      }

      // Draw turn indicator
      drawTurnIndicator();

      // Draw round number
      ctx.fillStyle = '#555';
      ctx.font = '11px "Courier New", monospace';
      ctx.textAlign = 'right';
      ctx.fillText(`Round ${roundNum + 1}`, W - 10, H - 8);
      ctx.textAlign = 'left';
    }

    function drawTank(tank, color, isPlayer) {
      const tx = tank.x;
      const ty = tank.y;
      const dir = isPlayer ? 1 : -1;

      // Tank body
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      // Main body
      ctx.fillRect(tx - TANK_W / 2, ty - TANK_H, TANK_W, TANK_H);
      // Turret dome
      ctx.beginPath();
      ctx.arc(tx, ty - TANK_H, 8, Math.PI, 0);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Barrel
      const angleRad = tank.angle * Math.PI / 180;
      const bx = tx + Math.cos(angleRad) * BARREL_LEN * dir;
      const by = ty - TANK_H - Math.sin(angleRad) * BARREL_LEN;

      ctx.strokeStyle = color;
      ctx.lineWidth = BARREL_W;
      ctx.lineCap = 'round';
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.moveTo(tx, ty - TANK_H);
      ctx.lineTo(bx, by);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.lineCap = 'butt';

      // Treads
      ctx.fillStyle = color === '#af4' ? '#8c3' : '#c33';
      ctx.fillRect(tx - TANK_W / 2 - 2, ty - 3, TANK_W + 4, 3);
    }

    function drawHPBar(tank) {
      const bx = tank.x - HP_BAR_W / 2;
      const by = tank.y - TANK_H - 22;

      // Background
      ctx.fillStyle = '#333';
      ctx.fillRect(bx, by, HP_BAR_W, HP_BAR_H);

      // HP fill
      const ratio = Math.max(0, tank.hp / MAX_HP);
      const hpColor = ratio > 0.5 ? '#af4' : (ratio > 0.25 ? '#fa0' : '#f44');
      ctx.fillStyle = hpColor;
      ctx.shadowColor = hpColor;
      ctx.shadowBlur = 4;
      ctx.fillRect(bx, by, HP_BAR_W * ratio, HP_BAR_H);
      ctx.shadowBlur = 0;

      // Border
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.strokeRect(bx, by, HP_BAR_W, HP_BAR_H);
    }

    function drawWindIndicator() {
      const cx = W / 2;
      const cy = 20;
      const maxLen = 40;
      const windLen = wind / 0.12 * maxLen; // normalized

      ctx.fillStyle = '#888';
      ctx.font = '11px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('WIND', cx, cy - 5);

      // Arrow shaft
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy + 4);
      ctx.lineTo(cx + windLen, cy + 4);
      ctx.stroke();

      // Arrowhead
      if (Math.abs(windLen) > 3) {
        const dir = windLen > 0 ? 1 : -1;
        const tipX = cx + windLen;
        ctx.fillStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(tipX, cy);
        ctx.lineTo(tipX, cy + 8);
        ctx.lineTo(tipX + dir * 6, cy + 4);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawAimingInfo() {
      const x = 10;
      const y = H - 12;

      ctx.fillStyle = '#af4';
      ctx.font = '12px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`Angle: ${Math.round(player.angle)}°`, x, y - 14);
      ctx.fillText(`Power: ${Math.round(player.power)}`, x, y);

      // Power bar
      const barX = 110;
      const barW = 80;
      const barH = 8;
      const ratio = (player.power - MIN_POWER) / (MAX_POWER - MIN_POWER);
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, y - 8, barW, barH);
      ctx.fillStyle = '#af4';
      ctx.shadowColor = '#af4';
      ctx.shadowBlur = 4;
      ctx.fillRect(barX, y - 8, barW * ratio, barH);
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, y - 8, barW, barH);

      // Aiming guide text
      ctx.fillStyle = '#666';
      ctx.font = '10px "Courier New", monospace';
      ctx.fillText('Up/Dn: angle  L/R: power  Space: fire', x, H - 38);
    }

    function drawTurnIndicator() {
      const label = turn === 'player' ? 'YOUR TURN' : 'ENEMY TURN';
      const color = turn === 'player' ? '#af4' : '#f44';

      ctx.fillStyle = color;
      ctx.font = '13px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.fillText(label, W / 2, H - 8);
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ') {
          init();
        }
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ' && turn === 'player' && turnPhase === 'aiming') {
          fireProjectile(player);
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script>
    const kpMap = {
      ArrowUp: 'kp-up',
      ArrowDown: 'kp-down',
      ArrowLeft: 'kp-left',
      ArrowRight: 'kp-right'
    };
    document.addEventListener('keydown', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.add('active');
    });
    document.addEventListener('keyup', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.remove('active');
    });
  </script>
</body>
</html>

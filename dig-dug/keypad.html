<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dig Dug</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #4af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 255, 0.4); }
    h1 { color: #4af; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4af; }
    canvas {
      border: 2px solid #4af;
      box-shadow: 0 0 20px rgba(68, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .game-row { display: flex; gap: 20px; align-items: flex-start; }
    .keypad { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 20px; }
    .keypad-row { display: flex; gap: 4px; }
    .kp-key {
      width: 44px; height: 44px;
      background: #16213e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; color: #555;
      transition: background 0.06s, border-color 0.06s, color 0.06s, box-shadow 0.06s;
    }
    .kp-key.active {
      background: rgba(68, 170, 255, 0.15);
      border-color: #4af;
      color: #4af;
      box-shadow: 0 0 12px rgba(68, 170, 255, 0.4);
    }
    .kp-spacer { width: 44px; height: 44px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DIG DUG</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="game-row">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="480" height="520"></canvas>
      <div class="overlay" id="overlay" style="width:480px;height:520px;">
        <h2 id="overlayTitle">DIG DUG</h2>
        <p id="overlayText">Press SPACE to start</p>
      </div>
    </div>
    <div class="keypad">
      <div class="keypad-row">
        <div class="kp-spacer"></div>
        <div class="kp-key" id="kp-up">&uarr;</div>
        <div class="kp-spacer"></div>
      </div>
      <div class="keypad-row">
        <div class="kp-key" id="kp-left">&larr;</div>
        <div class="kp-key" id="kp-down">&darr;</div>
        <div class="kp-key" id="kp-right">&rarr;</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid dimensions
    const COLS = 15;
    const ROWS = 16;
    const CELL = 32;       // pixels per cell
    const TOP_ROWS = 2;    // sky rows (not diggable)
    const OFFSET_X = (W - COLS * CELL) / 2;  // center grid
    const OFFSET_Y = H - ROWS * CELL;

    // Depth layer colors (4 layers, darker = deeper)
    const DIRT_COLORS = [
      '#8B6914',  // layer 1 (top, lighter brown)
      '#7A5B0F',  // layer 2
      '#654A0E',  // layer 3
      '#503A0D',  // layer 4 (deepest, darkest)
    ];
    const DIRT_EDGE_COLORS = [
      '#A07828',
      '#8C6618',
      '#755414',
      '#604410',
    ];

    // Score values by depth layer
    const POOKA_SCORES = [200, 300, 400, 500];
    const FYGAR_SCORES = [400, 600, 800, 1000];
    const ROCK_CRUSH_BONUS = 1000;

    let score, best = 0, gameState;
    let level, lives;
    let grid;
    let player;
    let enemies;
    let rocks;
    let pump;
    let keys = {};
    let frameCount;
    let levelCompleteTimer;
    let deathTimer;
    let lastMoveFrame;

    const PLAYER_MOVE_INTERVAL = 5;

    function getDepthLayer(row) {
      if (row < TOP_ROWS) return -1;
      const dirtRow = row - TOP_ROWS;
      const totalDirtRows = ROWS - TOP_ROWS;
      const layerSize = totalDirtRows / 4;
      return Math.min(3, Math.floor(dirtRow / layerSize));
    }

    function getDirtColor(row) {
      const layer = getDepthLayer(row);
      if (layer < 0) return null;
      return DIRT_COLORS[layer];
    }

    function getDirtEdgeColor(row) {
      const layer = getDepthLayer(row);
      if (layer < 0) return null;
      return DIRT_EDGE_COLORS[layer];
    }

    function initGrid() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = r >= TOP_ROWS ? 1 : 0;
        }
      }
      const spawnRow = TOP_ROWS;
      for (let c = 3; c < COLS - 3; c++) {
        grid[spawnRow][c] = 0;
      }
    }

    function createEnemies() {
      enemies = [];
      const numPookas = Math.min(2 + level, 6);
      const numFygars = Math.min(Math.floor(level / 2) + 1, 4);

      for (let i = 0; i < numPookas + numFygars; i++) {
        let row, col, attempts = 0;
        do {
          row = TOP_ROWS + 3 + Math.floor(Math.random() * (ROWS - TOP_ROWS - 4));
          col = 1 + Math.floor(Math.random() * (COLS - 2));
          attempts++;
        } while (attempts < 100 && (
          (Math.abs(row - player.row) < 3 && Math.abs(col - player.col) < 3) ||
          enemies.some(e => Math.abs(e.row - row) < 2 && Math.abs(e.col - col) < 2)
        ));

        grid[row][col] = 0;

        const isPooka = i < numPookas;
        enemies.push({
          row, col,
          x: col * CELL + OFFSET_X,
          y: row * CELL + OFFSET_Y,
          type: isPooka ? 'pooka' : 'fygar',
          dir: Math.random() < 0.5 ? 1 : -1,
          dirY: 0,
          moveTimer: 0,
          moveInterval: Math.max(12, 20 - level * 2),
          inflateLevel: 0,
          deflateTimer: 0,
          alive: true,
          ghost: false,
          ghostTimer: 0,
          ghostTarget: null,
          escaping: false,
          fireTimer: 0,
          fireActive: false,
          fireDir: 1,
          fireLength: 0,
        });
      }
    }

    function createRocks() {
      rocks = [];
      const numRocks = Math.min(2 + Math.floor(level / 2), 5);
      for (let i = 0; i < numRocks; i++) {
        let row, col, attempts = 0;
        do {
          row = TOP_ROWS + 1 + Math.floor(Math.random() * Math.floor((ROWS - TOP_ROWS) / 2));
          col = 1 + Math.floor(Math.random() * (COLS - 2));
          attempts++;
        } while (attempts < 100 && (
          (row === player.row && col === player.col) ||
          enemies.some(e => e.row === row && e.col === col) ||
          rocks.some(r => r.row === row && r.col === col)
        ));

        grid[row][col] = 0;

        rocks.push({
          row, col,
          x: col * CELL + OFFSET_X,
          y: row * CELL + OFFSET_Y,
          falling: false,
          fallSpeed: 0,
          settled: false,
          settleTimer: 0,
          wobbleTimer: 0,
          crushedEnemies: 0,
        });
      }
    }

    function init() {
      score = 0;
      level = 1;
      lives = 3;
      frameCount = 0;
      lastMoveFrame = 0;
      levelCompleteTimer = 0;
      deathTimer = 0;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DIG DUG';
      overlayText.textContent = 'Arrow keys to move, SPACE to pump\nPress any key to start';
      pump = null;
      keys = {};
      initLevel();
      draw();
    }

    function initLevel() {
      initGrid();
      player = {
        row: TOP_ROWS,
        col: Math.floor(COLS / 2),
        x: Math.floor(COLS / 2) * CELL + OFFSET_X,
        y: TOP_ROWS * CELL + OFFSET_Y,
        dir: 0,
        facingX: 1,
        facingY: 0,
        alive: true,
      };
      pump = null;
      frameCount = 0;
      lastMoveFrame = 0;
      levelCompleteTimer = 0;
      deathTimer = 0;
      createEnemies();
      createRocks();
      levelEl.textContent = level;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function tryMove(row, col) {
      if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return false;
      for (const rock of rocks) {
        if (!rock.falling && rock.row === row && rock.col === col) return false;
      }
      return true;
    }

    function movePlayer() {
      if (!player.alive) return;
      if (frameCount - lastMoveFrame < PLAYER_MOVE_INTERVAL) return;

      let moved = false;
      let newRow = player.row;
      let newCol = player.col;

      if (keys['ArrowLeft']) {
        newCol = player.col - 1;
        player.facingX = -1; player.facingY = 0; player.dir = 2;
        moved = true;
      } else if (keys['ArrowRight']) {
        newCol = player.col + 1;
        player.facingX = 1; player.facingY = 0; player.dir = 0;
        moved = true;
      } else if (keys['ArrowUp']) {
        newRow = player.row - 1;
        player.facingX = 0; player.facingY = -1; player.dir = 3;
        moved = true;
      } else if (keys['ArrowDown']) {
        newRow = player.row + 1;
        player.facingX = 0; player.facingY = 1; player.dir = 1;
        moved = true;
      }

      if (moved && tryMove(newRow, newCol)) {
        player.row = newRow;
        player.col = newCol;
        if (newRow >= TOP_ROWS && grid[newRow][newCol] === 1) {
          grid[newRow][newCol] = 0;
        }
        player.x = player.col * CELL + OFFSET_X;
        player.y = player.row * CELL + OFFSET_Y;
        lastMoveFrame = frameCount;

        if (pump && !pump.retracting) {
          pump = null;
        }
      }
    }

    function firePump() {
      if (pump) return;
      pump = {
        startRow: player.row,
        startCol: player.col,
        dx: player.facingX,
        dy: player.facingY,
        length: 0,
        maxLength: 4,
        extending: true,
        retracting: false,
        target: null,
        extendTimer: 0,
      };
    }

    function updatePump() {
      if (!pump) return;

      pump.extendTimer++;
      if (pump.extendTimer < 3) return;
      pump.extendTimer = 0;

      if (pump.extending) {
        pump.length++;
        const tipRow = pump.startRow + pump.dy * pump.length;
        const tipCol = pump.startCol + pump.dx * pump.length;

        if (tipRow < 0 || tipRow >= ROWS || tipCol < 0 || tipCol >= COLS) {
          pump = null;
          return;
        }

        for (const rock of rocks) {
          if (!rock.falling && rock.row === tipRow && rock.col === tipCol) {
            pump = null;
            return;
          }
        }

        for (const enemy of enemies) {
          if (enemy.alive && enemy.inflateLevel < 4 && enemy.row === tipRow && enemy.col === tipCol) {
            pump.target = enemy;
            pump.extending = false;
            enemy.inflateLevel = Math.min(enemy.inflateLevel + 1, 4);
            enemy.deflateTimer = 0;
            return;
          }
        }

        if (pump.length >= pump.maxLength) {
          pump = null;
        }
      }
    }

    function pumpEnemy() {
      if (pump && pump.target && keys[' ']) {
        pump.target.deflateTimer = 0;
        if (frameCount % 15 === 0) {
          pump.target.inflateLevel = Math.min(pump.target.inflateLevel + 1, 4);
        }
        if (pump.target.inflateLevel >= 4) {
          popEnemy(pump.target);
          pump = null;
        }
      }
      if (pump && pump.target && !keys[' ']) {
        pump = null;
      }
    }

    function popEnemy(enemy) {
      enemy.alive = false;
      const layer = getDepthLayer(enemy.row);
      const scores = enemy.type === 'pooka' ? POOKA_SCORES : FYGAR_SCORES;
      const points = scores[Math.max(0, layer)];
      addScore(points);
    }

    function addScore(points) {
      score += points;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function updateEnemies() {
      const aliveEnemies = enemies.filter(e => e.alive);

      if (aliveEnemies.length === 1 && !aliveEnemies[0].escaping) {
        aliveEnemies[0].escaping = true;
      }

      for (const enemy of enemies) {
        if (!enemy.alive) continue;

        if (enemy.inflateLevel > 0) {
          enemy.deflateTimer++;
          if (enemy.deflateTimer > 40) {
            enemy.inflateLevel--;
            enemy.deflateTimer = 0;
          }
          continue;
        }

        enemy.moveTimer++;
        if (enemy.moveTimer < enemy.moveInterval) continue;
        enemy.moveTimer = 0;

        if (enemy.escaping) {
          if (enemy.row > 0) {
            let newRow = enemy.row - 1;
            let newCol = enemy.col;
            if (Math.random() < 0.3) {
              const centerCol = Math.floor(COLS / 2);
              if (enemy.col < centerCol) newCol++;
              else if (enemy.col > centerCol) newCol--;
            }
            newCol = Math.max(0, Math.min(COLS - 1, newCol));
            enemy.row = newRow;
            enemy.col = newCol;
            if (newRow >= TOP_ROWS) grid[newRow][newCol] = 0;
          } else {
            enemy.alive = false;
          }
        } else if (enemy.ghost) {
          enemy.ghostTimer++;
          const dRow = player.row - enemy.row;
          const dCol = player.col - enemy.col;
          if (Math.abs(dRow) > Math.abs(dCol)) {
            enemy.row += Math.sign(dRow);
          } else {
            enemy.col += Math.sign(dCol);
          }
          enemy.row = Math.max(0, Math.min(ROWS - 1, enemy.row));
          enemy.col = Math.max(0, Math.min(COLS - 1, enemy.col));
          if (grid[enemy.row] && grid[enemy.row][enemy.col] === 0) {
            enemy.ghost = false;
            enemy.ghostTimer = 0;
          }
          if (enemy.ghostTimer > 60) {
            enemy.ghost = false;
            enemy.ghostTimer = 0;
          }
        } else {
          let possibleMoves = [];
          const dirs = [
            { dr: 0, dc: 1 },
            { dr: 0, dc: -1 },
            { dr: 1, dc: 0 },
            { dr: -1, dc: 0 },
          ];

          for (const d of dirs) {
            const nr = enemy.row + d.dr;
            const nc = enemy.col + d.dc;
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && grid[nr][nc] === 0) {
              if (!rocks.some(r => !r.falling && r.row === nr && r.col === nc)) {
                possibleMoves.push(d);
              }
            }
          }

          if (possibleMoves.length > 0) {
            let chosen;
            if (Math.random() < 0.4) {
              possibleMoves.sort((a, b) => {
                const distA = Math.abs(enemy.row + a.dr - player.row) + Math.abs(enemy.col + a.dc - player.col);
                const distB = Math.abs(enemy.row + b.dr - player.row) + Math.abs(enemy.col + b.dc - player.col);
                return distA - distB;
              });
              chosen = possibleMoves[0];
            } else {
              chosen = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }

            enemy.row += chosen.dr;
            enemy.col += chosen.dc;
            enemy.dir = chosen.dc !== 0 ? chosen.dc : enemy.dir;
            enemy.dirY = chosen.dr;
          } else {
            if (Math.random() < 0.15) {
              enemy.ghost = true;
              enemy.ghostTimer = 0;
            }
          }

          if (enemy.type === 'fygar' && !enemy.fireActive) {
            enemy.fireTimer++;
            if (enemy.fireTimer > 60 && Math.random() < 0.05) {
              if (enemy.row === player.row) {
                enemy.fireActive = true;
                enemy.fireDir = player.col > enemy.col ? 1 : -1;
                enemy.fireLength = 0;
                enemy.fireTimer = 0;
              }
            }
          }
        }

        enemy.x = enemy.col * CELL + OFFSET_X;
        enemy.y = enemy.row * CELL + OFFSET_Y;

        if (player.alive && enemy.row === player.row && enemy.col === player.col && enemy.inflateLevel === 0) {
          killPlayer();
        }
      }

      for (const enemy of enemies) {
        if (!enemy.alive || enemy.type !== 'fygar') continue;
        if (enemy.fireActive) {
          enemy.fireLength += 0.15;
          if (enemy.fireLength >= 3) {
            enemy.fireActive = false;
            enemy.fireLength = 0;
          }
          if (player.alive) {
            for (let i = 1; i <= Math.floor(enemy.fireLength); i++) {
              const fc = enemy.col + enemy.fireDir * i;
              if (fc >= 0 && fc < COLS && enemy.row === player.row && fc === player.col) {
                killPlayer();
                break;
              }
            }
          }
        }
      }
    }

    function updateRocks() {
      for (const rock of rocks) {
        if (rock.settled) continue;

        if (!rock.falling) {
          const belowRow = rock.row + 1;
          if (belowRow < ROWS && grid[belowRow][rock.col] === 0) {
            if (!rocks.some(r => r !== rock && !r.falling && r.row === belowRow && r.col === rock.col)) {
              rock.wobbleTimer++;
              if (rock.wobbleTimer > 20) {
                rock.falling = true;
                rock.fallSpeed = 0;
                rock.crushedEnemies = 0;
              }
            }
          } else {
            rock.wobbleTimer = 0;
          }
        } else {
          rock.fallSpeed = Math.min(rock.fallSpeed + 0.5, 6);
          rock.y += rock.fallSpeed;
          const newRow = Math.floor((rock.y - OFFSET_Y + CELL / 2) / CELL);

          if (newRow >= TOP_ROWS && newRow < ROWS && grid[newRow]) {
            grid[newRow][rock.col] = 0;
          }

          const nextRow = newRow + 1;
          let shouldStop = false;
          if (nextRow >= ROWS) {
            shouldStop = true;
          } else if (grid[nextRow] && grid[nextRow][rock.col] === 1) {
            shouldStop = true;
          } else {
            if (rocks.some(r => r !== rock && r.settled && r.row === nextRow && r.col === rock.col)) {
              shouldStop = true;
            }
          }

          for (const enemy of enemies) {
            if (enemy.alive && enemy.col === rock.col && Math.abs(enemy.row - newRow) <= 0) {
              enemy.alive = false;
              rock.crushedEnemies++;
              addScore(ROCK_CRUSH_BONUS * rock.crushedEnemies);
            }
          }

          if (player.alive && player.col === rock.col && player.row === newRow) {
            killPlayer();
          }

          if (shouldStop) {
            rock.row = newRow;
            rock.y = rock.row * CELL + OFFSET_Y;
            rock.x = rock.col * CELL + OFFSET_X;
            rock.falling = false;
            rock.settled = true;
          } else {
            rock.row = newRow;
          }
        }
      }
    }

    function killPlayer() {
      if (!player.alive) return;
      player.alive = false;
      pump = null;
      deathTimer = 60;
    }

    function handleDeath() {
      if (!player.alive && deathTimer > 0) {
        deathTimer--;
        if (deathTimer <= 0) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver();
          } else {
            player.alive = true;
            player.row = TOP_ROWS;
            player.col = Math.floor(COLS / 2);
            player.x = player.col * CELL + OFFSET_X;
            player.y = player.row * CELL + OFFSET_Y;
            pump = null;
            for (const enemy of enemies) {
              if (enemy.alive && Math.abs(enemy.row - player.row) < 2 && Math.abs(enemy.col - player.col) < 2) {
                enemy.row = Math.min(ROWS - 2, enemy.row + 3);
                enemy.col = Math.max(1, Math.min(COLS - 2, enemy.col));
                enemy.x = enemy.col * CELL + OFFSET_X;
                enemy.y = enemy.row * CELL + OFFSET_Y;
              }
            }
          }
        }
      }
    }

    function checkLevelComplete() {
      const aliveEnemies = enemies.filter(e => e.alive);
      if (aliveEnemies.length === 0 && player.alive) {
        levelCompleteTimer++;
        if (levelCompleteTimer > 60) {
          level++;
          initLevel();
        }
      }
    }

    function update() {
      frameCount++;

      if (player.alive) {
        movePlayer();
      }

      if (keys[' '] && !pump && player.alive) {
        firePump();
      }
      updatePump();
      pumpEnemy();

      updateEnemies();
      updateRocks();
      handleDeath();
      checkLevelComplete();

      window.gameData = {
        playerRow: player.row,
        playerCol: player.col,
        playerAlive: player.alive,
        enemies: enemies.filter(e => e.alive).map(e => ({
          row: e.row, col: e.col, type: e.type, inflate: e.inflateLevel, ghost: e.ghost
        })),
        level: level,
        lives: lives,
      };
    }

    function drawDirt() {
      for (let r = TOP_ROWS; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] === 1) {
            const x = c * CELL + OFFSET_X;
            const y = r * CELL + OFFSET_Y;
            const color = getDirtColor(r);
            const edgeColor = getDirtEdgeColor(r);

            ctx.fillStyle = color;
            ctx.fillRect(x, y, CELL, CELL);

            ctx.fillStyle = edgeColor;
            if ((r + c) % 3 === 0) {
              ctx.fillRect(x + 4, y + 4, 2, 2);
              ctx.fillRect(x + 20, y + 14, 2, 2);
            }
            if ((r + c) % 4 === 1) {
              ctx.fillRect(x + 12, y + 8, 2, 2);
              ctx.fillRect(x + 26, y + 22, 2, 2);
            }

            ctx.strokeStyle = edgeColor;
            ctx.lineWidth = 1;
            if (c > 0 && grid[r][c - 1] === 0) {
              ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + CELL); ctx.stroke();
            }
            if (c < COLS - 1 && grid[r][c + 1] === 0) {
              ctx.beginPath(); ctx.moveTo(x + CELL, y); ctx.lineTo(x + CELL, y + CELL); ctx.stroke();
            }
            if (r > TOP_ROWS && grid[r - 1][c] === 0) {
              ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + CELL, y); ctx.stroke();
            }
            if (r < ROWS - 1 && grid[r + 1][c] === 0) {
              ctx.beginPath(); ctx.moveTo(x, y + CELL); ctx.lineTo(x + CELL, y + CELL); ctx.stroke();
            }
          }
        }
      }
    }

    function drawSky() {
      const grad = ctx.createLinearGradient(0, OFFSET_Y, 0, OFFSET_Y + TOP_ROWS * CELL);
      grad.addColorStop(0, '#1a2a4e');
      grad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = grad;
      ctx.fillRect(OFFSET_X, OFFSET_Y, COLS * CELL, TOP_ROWS * CELL);
    }

    function drawPlayer() {
      if (!player.alive) {
        if (deathTimer > 0) {
          ctx.save();
          ctx.globalAlpha = deathTimer / 60;
          const cx = player.x + CELL / 2;
          const cy = player.y + CELL / 2;
          ctx.fillStyle = '#4af';
          ctx.shadowColor = '#4af';
          ctx.shadowBlur = 15;
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2 + frameCount * 0.1;
            const dist = (60 - deathTimer) * 0.5;
            ctx.beginPath();
            ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 3, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.shadowBlur = 0;
          ctx.restore();
        }
        return;
      }

      const cx = player.x + CELL / 2;
      const cy = player.y + CELL / 2;

      ctx.save();
      ctx.shadowColor = '#4af';
      ctx.shadowBlur = 10;

      ctx.fillStyle = '#e8e8ff';
      ctx.fillRect(player.x + 8, player.y + 6, 16, 18);

      ctx.fillStyle = '#ffcc88';
      ctx.beginPath();
      ctx.arc(cx, player.y + 6, 7, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#4af';
      ctx.beginPath();
      ctx.arc(cx, player.y + 5, 8, Math.PI, 0);
      ctx.fill();

      ctx.fillStyle = '#222';
      const eyeOffsetX = player.facingX * 2;
      ctx.fillRect(cx - 2 + eyeOffsetX, player.y + 5, 2, 2);
      ctx.fillRect(cx + 1 + eyeOffsetX, player.y + 5, 2, 2);

      ctx.fillStyle = '#4af';
      ctx.fillRect(player.x + 10, player.y + 24, 5, 6);
      ctx.fillRect(player.x + 17, player.y + 24, 5, 6);

      ctx.strokeStyle = '#4af';
      ctx.lineWidth = 2;
      const px = cx + player.facingX * 14;
      const py = cy + player.facingY * 14;
      ctx.beginPath();
      ctx.moveTo(cx + player.facingX * 10, cy + player.facingY * 10);
      ctx.lineTo(px, py);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawPump() {
      if (!pump) return;

      const startX = pump.startCol * CELL + OFFSET_X + CELL / 2;
      const startY = pump.startRow * CELL + OFFSET_Y + CELL / 2;
      const endX = startX + pump.dx * pump.length * CELL;
      const endY = startY + pump.dy * pump.length * CELL;

      ctx.save();
      ctx.strokeStyle = '#4af';
      ctx.shadowColor = '#4af';
      ctx.shadowBlur = 8;
      ctx.lineWidth = 3;
      ctx.setLineDash([4, 4]);
      ctx.lineDashOffset = -frameCount * 2;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(endX, endY, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawEnemy(enemy) {
      if (!enemy.alive) return;

      const cx = enemy.x + CELL / 2;
      const cy = enemy.y + CELL / 2;
      const inflate = enemy.inflateLevel;

      ctx.save();

      if (enemy.ghost) {
        ctx.globalAlpha = 0.5 + 0.2 * Math.sin(frameCount * 0.15);
      }

      if (enemy.type === 'pooka') {
        const radius = 10 + inflate * 3;
        ctx.fillStyle = inflate > 0 ? `hsl(0, 100%, ${60 + inflate * 10}%)` : '#e44';
        ctx.shadowColor = '#e44';
        ctx.shadowBlur = inflate > 0 ? 15 : 8;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();

        if (inflate === 0) {
          ctx.fillStyle = '#fff';
          ctx.fillRect(cx - 6, cy - 4, 5, 5);
          ctx.fillRect(cx + 1, cy - 4, 5, 5);
          ctx.fillStyle = '#222';
          ctx.fillRect(cx - 4 + enemy.dir, cy - 2, 2, 2);
          ctx.fillRect(cx + 2 + enemy.dir, cy - 2, 2, 2);

          ctx.fillStyle = '#c33';
          ctx.fillRect(cx - 6, cy + 8, 4, 3);
          ctx.fillRect(cx + 2, cy + 8, 4, 3);
        }
      } else {
        const radius = 10 + inflate * 3;
        ctx.fillStyle = inflate > 0 ? `hsl(120, 80%, ${50 + inflate * 10}%)` : '#4c4';
        ctx.shadowColor = '#4c4';
        ctx.shadowBlur = inflate > 0 ? 15 : 8;

        ctx.beginPath();
        if (inflate > 0) {
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        } else {
          ctx.fillRect(cx - 10, cy - 8, 20, 16);
          ctx.fillRect(cx + enemy.dir * 6, cy - 4, 8 * enemy.dir, 8);
        }
        ctx.fill();

        if (inflate === 0) {
          ctx.fillStyle = '#fff';
          ctx.fillRect(cx - 4, cy - 6, 4, 4);
          ctx.fillRect(cx + 2, cy - 6, 4, 4);
          ctx.fillStyle = '#222';
          ctx.fillRect(cx - 3 + enemy.dir, cy - 5, 2, 2);
          ctx.fillRect(cx + 3 + enemy.dir, cy - 5, 2, 2);

          ctx.fillStyle = '#3a3';
          ctx.fillRect(cx - enemy.dir * 12, cy - 2, 6, 4);

          ctx.fillStyle = '#5d5';
          ctx.beginPath();
          ctx.moveTo(cx, cy - 8);
          ctx.lineTo(cx - 4, cy - 14);
          ctx.lineTo(cx + 4, cy - 14);
          ctx.closePath();
          ctx.fill();

          if (enemy.fireActive) {
            const fireLen = Math.floor(enemy.fireLength);
            for (let i = 1; i <= fireLen; i++) {
              const fx = (enemy.col + enemy.fireDir * i) * CELL + OFFSET_X;
              const fy = enemy.row * CELL + OFFSET_Y;
              ctx.fillStyle = i === 1 ? '#ff4' : (i === 2 ? '#f80' : '#f44');
              ctx.shadowColor = '#f80';
              ctx.shadowBlur = 12;
              ctx.fillRect(fx + 4, fy + 8, CELL - 8, CELL - 16);
              ctx.fillRect(fx + 2 + Math.sin(frameCount * 0.5) * 3, fy + 4, CELL - 4, 4);
            }
          }
        }

        if (inflate > 0) {
          ctx.fillStyle = '#fff';
          ctx.fillRect(cx - 4, cy - 3, 3, 3);
          ctx.fillRect(cx + 2, cy - 3, 3, 3);
          ctx.fillStyle = '#222';
          ctx.fillRect(cx - 3, cy - 2, 2, 2);
          ctx.fillRect(cx + 3, cy - 2, 2, 2);
        }
      }

      if (enemy.escaping) {
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 6;
        ctx.font = '10px Courier New';
        ctx.fillText('!', cx - 2, cy - 14);
      }

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawRock(rock) {
      const x = rock.x;
      const y = rock.y;

      ctx.save();

      let offsetX = 0;
      if (rock.wobbleTimer > 0 && !rock.falling && !rock.settled) {
        offsetX = Math.sin(rock.wobbleTimer * 0.5) * 2;
      }

      ctx.shadowColor = '#888';
      ctx.shadowBlur = 4;

      ctx.fillStyle = '#778';
      ctx.beginPath();
      ctx.moveTo(x + offsetX + 4, y + 2);
      ctx.lineTo(x + offsetX + CELL - 4, y + 2);
      ctx.lineTo(x + offsetX + CELL - 2, y + CELL / 2);
      ctx.lineTo(x + offsetX + CELL - 6, y + CELL - 2);
      ctx.lineTo(x + offsetX + 6, y + CELL - 2);
      ctx.lineTo(x + offsetX + 2, y + CELL / 2);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#99a';
      ctx.beginPath();
      ctx.moveTo(x + offsetX + 8, y + 4);
      ctx.lineTo(x + offsetX + CELL - 8, y + 4);
      ctx.lineTo(x + offsetX + CELL - 10, y + 12);
      ctx.lineTo(x + offsetX + 10, y + 12);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = '#556';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + offsetX + 12, y + 6);
      ctx.lineTo(x + offsetX + 16, y + 16);
      ctx.lineTo(x + offsetX + 20, y + 12);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawTunnelBackground() {
      for (let r = TOP_ROWS; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] === 0) {
            const x = c * CELL + OFFSET_X;
            const y = r * CELL + OFFSET_Y;
            ctx.fillStyle = '#12121e';
            ctx.fillRect(x, y, CELL, CELL);
          }
        }
      }
    }

    function drawDepthIndicators() {
      ctx.font = '9px Courier New';
      ctx.fillStyle = '#555';
      const totalDirtRows = ROWS - TOP_ROWS;
      const layerSize = totalDirtRows / 4;
      for (let i = 0; i < 4; i++) {
        const row = TOP_ROWS + Math.floor(i * layerSize);
        const y = row * CELL + OFFSET_Y + 10;
        ctx.fillText(`L${i + 1}`, OFFSET_X - 18, y);
      }
    }

    function drawLevelComplete() {
      if (levelCompleteTimer > 0 && enemies.filter(e => e.alive).length === 0) {
        ctx.save();
        ctx.fillStyle = '#4af';
        ctx.shadowColor = '#4af';
        ctx.shadowBlur = 20;
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', W / 2, H / 2);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawSky();
      drawTunnelBackground();
      drawDirt();
      drawDepthIndicators();

      for (const rock of rocks) {
        drawRock(rock);
      }

      for (const enemy of enemies) {
        drawEnemy(enemy);
      }

      drawPlayer();
      drawPump();
      drawLevelComplete();

      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      ctx.strokeRect(OFFSET_X, OFFSET_Y, COLS * CELL, ROWS * CELL);
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script>
    const kpMap = {
      ArrowUp: 'kp-up',
      ArrowDown: 'kp-down',
      ArrowLeft: 'kp-left',
      ArrowRight: 'kp-right'
    };
    document.addEventListener('keydown', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.add('active');
    });
    document.addEventListener('keyup', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.remove('active');
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Columns</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 300px;
    }
    .back { color: #c6f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 102, 255, 0.4); }
    h1 { color: #c6f; font-size: 2rem; text-shadow: 0 0 15px rgba(204, 102, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 300px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #c6f; }
    canvas {
      border: 2px solid #c6f;
      box-shadow: 0 0 20px rgba(204, 102, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c6f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>COLUMNS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="300" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:300px;height:600px;">
      <h2 id="overlayTitle">COLUMNS</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid dimensions
    const COLS = 6;
    const ROWS = 13;
    const CELL = W / COLS;  // 50px per cell

    // Gem colors - 6 distinct bright colors
    const GEM_COLORS = [
      '#f44',  // red
      '#4f4',  // green
      '#44f',  // blue
      '#ff0',  // yellow
      '#f0f',  // magenta
      '#0ff',  // cyan
    ];

    // Glow colors matching gems
    const GEM_GLOW = [
      'rgba(255, 68, 68, 0.6)',
      'rgba(68, 255, 68, 0.6)',
      'rgba(68, 68, 255, 0.6)',
      'rgba(255, 255, 0, 0.6)',
      'rgba(255, 0, 255, 0.6)',
      'rgba(0, 255, 255, 0.6)',
    ];

    let score, best = 0, gameState;
    let board;          // ROWS x COLS grid, null or color index
    let piece;          // { col, row, gems: [top, mid, bot] } - color indices
    let dropTimer;
    let dropInterval;
    let level;
    let gemsCleared;
    let chainCount;
    let animating;      // true during match/clear animation
    let matchedCells;   // Set of "r,c" strings for cells being cleared
    let flashPhase;
    let softDropping;
    const SOFT_DROP_INTERVAL = 50;

    function init() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      score = 0;
      level = 1;
      gemsCleared = 0;
      chainCount = 0;
      dropInterval = 800;
      animating = false;
      matchedCells = new Set();
      flashPhase = 0;
      softDropping = false;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'COLUMNS';
      overlayText.textContent = 'Press SPACE to start';
      piece = null;
      clearTimeout(dropTimer);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      spawnPiece();
      tick();
    }

    function spawnPiece() {
      const col = Math.floor(COLS / 2);
      piece = {
        col: col,
        row: -2,  // start above the visible area
        gems: [
          Math.floor(Math.random() * GEM_COLORS.length),
          Math.floor(Math.random() * GEM_COLORS.length),
          Math.floor(Math.random() * GEM_COLORS.length),
        ]
      };
      // Check if the landing spot is blocked
      if (board[0][col] !== null) {
        gameOver();
      }
    }

    function cycleGems() {
      // Rotate: bottom -> top, top -> middle, middle -> bottom
      const [top, mid, bot] = piece.gems;
      piece.gems = [bot, top, mid];
    }

    function canMove(col, row) {
      // Check if the bottom gem of the column can be at (col, row+2)
      for (let i = 0; i < 3; i++) {
        const r = row + i;
        if (col < 0 || col >= COLS) return false;
        if (r >= ROWS) return false;
        if (r >= 0 && board[r][col] !== null) return false;
      }
      return true;
    }

    function lockPiece() {
      for (let i = 0; i < 3; i++) {
        const r = piece.row + i;
        if (r >= 0 && r < ROWS) {
          board[r][piece.col] = piece.gems[i];
        }
      }
      piece = null;
      chainCount = 0;
      checkMatches();
    }

    function checkMatches() {
      matchedCells = new Set();

      // Check all directions: horizontal, vertical, diagonal-down-right, diagonal-down-left
      const directions = [
        [0, 1],   // horizontal
        [1, 0],   // vertical
        [1, 1],   // diagonal down-right
        [1, -1],  // diagonal down-left
      ];

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] === null) continue;
          const color = board[r][c];

          for (const [dr, dc] of directions) {
            // Count consecutive gems in this direction
            let count = 1;
            let cells = [`${r},${c}`];
            let nr = r + dr, nc = c + dc;
            while (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === color) {
              cells.push(`${nr},${nc}`);
              count++;
              nr += dr;
              nc += dc;
            }
            if (count >= 3) {
              cells.forEach(key => matchedCells.add(key));
            }
          }
        }
      }

      if (matchedCells.size > 0) {
        chainCount++;
        animating = true;
        flashPhase = 0;
        animateMatch();
      } else {
        // No matches - spawn next piece
        animating = false;
        if (gameState === 'playing') {
          spawnPiece();
          tick();
        }
      }
    }

    function animateMatch() {
      flashPhase++;
      draw();

      if (flashPhase <= 14) {
        setTimeout(animateMatch, 40);
      } else {
        // Clear matched gems and award score
        const cleared = matchedCells.size;
        const chainBonus = chainCount > 1 ? chainCount * 2 : 1;
        score += cleared * 10 * chainBonus;
        gemsCleared += cleared;

        // Update level every 30 gems cleared
        const newLevel = Math.floor(gemsCleared / 30) + 1;
        if (newLevel > level) {
          level = newLevel;
          dropInterval = Math.max(100, 800 - (level - 1) * 60);
        }

        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }

        // Remove matched cells
        matchedCells.forEach(key => {
          const [r, c] = key.split(',').map(Number);
          board[r][c] = null;
        });
        matchedCells = new Set();

        // Apply gravity - gems fall down
        applyGravity();

        // Check for chain reactions
        checkMatches();
      }
    }

    function applyGravity() {
      for (let c = 0; c < COLS; c++) {
        // Compact column: move all non-null values to the bottom
        let writeRow = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r][c] !== null) {
            board[writeRow][c] = board[r][c];
            if (writeRow !== r) board[r][c] = null;
            writeRow--;
          }
        }
        // Fill remaining top rows with null
        for (let r = writeRow; r >= 0; r--) {
          board[r][c] = null;
        }
      }
    }

    function tick() {
      clearTimeout(dropTimer);
      if (gameState !== 'playing' || animating || !piece) return;

      // Try to drop the piece one row
      if (canMove(piece.col, piece.row + 1)) {
        piece.row++;
        if (softDropping) {
          score += 1;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
        }
      } else {
        lockPiece();
        draw();
        return;
      }

      draw();
      dropTimer = setTimeout(tick, softDropping ? SOFT_DROP_INTERVAL : dropInterval);
    }

    function hardDrop() {
      if (!piece || animating) return;
      while (canMove(piece.col, piece.row + 1)) {
        piece.row++;
        score += 2;
      }
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      clearTimeout(dropTimer);
      lockPiece();
      draw();
    }

    function gameOver() {
      gameState = 'over';
      clearTimeout(dropTimer);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function drawGem(x, y, colorIdx, size, alpha) {
      if (colorIdx === null) return;
      const cx = x + size / 2;
      const cy = y + size / 2;
      const radius = size * 0.38;
      const a = alpha !== undefined ? alpha : 1;

      // Glow
      ctx.shadowColor = GEM_COLORS[colorIdx];
      ctx.shadowBlur = 10;

      // Draw rounded square gem
      const r = size * 0.12;
      const x1 = x + size * 0.12;
      const y1 = y + size * 0.12;
      const w = size * 0.76;
      const h = size * 0.76;

      ctx.globalAlpha = a;
      ctx.fillStyle = GEM_COLORS[colorIdx];
      ctx.beginPath();
      ctx.moveTo(x1 + r, y1);
      ctx.lineTo(x1 + w - r, y1);
      ctx.arcTo(x1 + w, y1, x1 + w, y1 + r, r);
      ctx.lineTo(x1 + w, y1 + h - r);
      ctx.arcTo(x1 + w, y1 + h, x1 + w - r, y1 + h, r);
      ctx.lineTo(x1 + r, y1 + h);
      ctx.arcTo(x1, y1 + h, x1, y1 + h - r, r);
      ctx.lineTo(x1, y1 + r);
      ctx.arcTo(x1, y1, x1 + r, y1, r);
      ctx.closePath();
      ctx.fill();

      // Inner highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.moveTo(x1 + r, y1);
      ctx.lineTo(x1 + w - r, y1);
      ctx.arcTo(x1 + w, y1, x1 + w, y1 + r, r);
      ctx.lineTo(x1 + w * 0.3, y1 + h * 0.3);
      ctx.lineTo(x1, y1 + r);
      ctx.arcTo(x1, y1, x1 + r, y1, r);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Draw board gems
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] !== null) {
            const key = `${r},${c}`;
            if (matchedCells.has(key) && flashPhase > 0) {
              // Flash effect for matched gems
              const pulse = Math.sin(flashPhase * 0.7) * 0.5 + 0.5;
              drawGem(c * CELL, r * CELL + (H - ROWS * CELL), board[r][c], CELL, 0.3 + pulse * 0.7);
              // White flash overlay
              ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
              ctx.fillRect(c * CELL + 2, r * CELL + (H - ROWS * CELL) + 2, CELL - 4, CELL - 4);
            } else {
              drawGem(c * CELL, r * CELL + (H - ROWS * CELL), board[r][c], CELL);
            }
          }
        }
      }

      // Draw falling piece
      if (piece && !animating) {
        // Ghost piece (preview where it will land)
        let ghostRow = piece.row;
        while (canMove(piece.col, ghostRow + 1)) ghostRow++;
        if (ghostRow !== piece.row) {
          for (let i = 0; i < 3; i++) {
            const gr = ghostRow + i;
            if (gr >= 0 && gr < ROWS) {
              drawGem(piece.col * CELL, gr * CELL + (H - ROWS * CELL), piece.gems[i], CELL, 0.2);
            }
          }
        }

        // Active piece
        for (let i = 0; i < 3; i++) {
          const r = piece.row + i;
          const py = r * CELL + (H - ROWS * CELL);
          if (py >= 0 && r < ROWS) {
            drawGem(piece.col * CELL, py, piece.gems[i], CELL);
          }
        }
      }

      // Draw level indicator
      ctx.fillStyle = '#888';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`LVL ${level}`, W - 6, 16);
      ctx.textAlign = 'left';

      // Chain text
      if (chainCount > 1 && animating) {
        ctx.save();
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#c6f';
        ctx.shadowColor = '#c6f';
        ctx.shadowBlur = 20;
        const scale = 1 + Math.sin(flashPhase * 0.5) * 0.1;
        ctx.translate(W / 2, H / 2);
        ctx.scale(scale, scale);
        ctx.fillText(`${chainCount}x CHAIN!`, 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing' && piece && !animating) {
        switch (e.key) {
          case 'ArrowLeft':
            if (canMove(piece.col - 1, piece.row)) {
              piece.col--;
              draw();
            }
            break;
          case 'ArrowRight':
            if (canMove(piece.col + 1, piece.row)) {
              piece.col++;
              draw();
            }
            break;
          case 'ArrowUp':
            cycleGems();
            draw();
            break;
          case 'ArrowDown':
            if (!softDropping) {
              softDropping = true;
              clearTimeout(dropTimer);
              tick();
            }
            break;
          case ' ':
            hardDrop();
            break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown' && softDropping) {
        softDropping = false;
        clearTimeout(dropTimer);
        dropTimer = setTimeout(tick, dropInterval);
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

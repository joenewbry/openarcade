<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Peggle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #6af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102, 170, 255, 0.5); }
    h1 { color: #6af; font-size: 2rem; text-shadow: 0 0 15px rgba(102, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #6af; }
    canvas {
      border: 2px solid #6af;
      box-shadow: 0 0 20px rgba(102, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PEGGLE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="640"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:640px;">
      <h2 id="overlayTitle">PEGGLE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // Physics constants
    const GRAVITY = 0.15;
    const BALL_RADIUS = 6;
    const PEG_RADIUS = 10;
    const BOUNCE_DAMPING = 0.72;
    const WALL_DAMPING = 0.8;

    // Launcher
    const LAUNCHER_X = W / 2;
    const LAUNCHER_Y = 30;
    const LAUNCHER_LEN = 35;
    const AIM_SPEED = 0.025;
    const SHOOT_SPEED = 8;

    // Bucket
    const BUCKET_W = 60;
    const BUCKET_H = 18;
    const BUCKET_Y = H - 30;
    const BUCKET_SPEED = 1.5;

    // Game state variables
    let launcherAngle;
    let ball;
    let pegs;
    let hitPegs;
    let ballsLeft;
    let bucketX, bucketDir;
    let level;
    let keys = {};
    let feverTimer;
    let feverParticles;
    let particles;
    let clearAnimTimer;
    let shotActive;
    let totalOrange;
    let orangeLeft;
    let showingClearAnim;
    let levelCompleteTimer;
    let lastShotHitPegs;

    // Level layouts
    function generateLevel(lvl) {
      const pegList = [];
      const margin = 40;
      const topMargin = 80;
      const bottomMargin = 100;
      const usableW = W - margin * 2;
      const usableH = H - topMargin - bottomMargin;

      if (lvl === 1) {
        // Diamond pattern
        const rows = 7;
        const cols = 9;
        for (let r = 0; r < rows; r++) {
          const pegsInRow = cols - Math.abs(r - Math.floor(rows / 2));
          const startX = margin + (usableW - (pegsInRow - 1) * (usableW / (cols - 1))) / 2;
          for (let c = 0; c < pegsInRow; c++) {
            const x = startX + c * (usableW / (cols - 1));
            const y = topMargin + (r / (rows - 1)) * usableH;
            pegList.push({ x, y });
          }
        }
      } else if (lvl === 2) {
        // Grid with gaps
        const rows = 8;
        const cols = 10;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if ((r + c) % 3 === 0) continue;
            const x = margin + (c / (cols - 1)) * usableW;
            const y = topMargin + (r / (rows - 1)) * usableH;
            pegList.push({ x, y });
          }
        }
      } else if (lvl === 3) {
        // Circular rings
        const cx = W / 2;
        const cy = topMargin + usableH / 2;
        const radii = [60, 110, 160, 200];
        const counts = [6, 10, 16, 22];
        for (let ri = 0; ri < radii.length; ri++) {
          for (let i = 0; i < counts[ri]; i++) {
            const angle = (i / counts[ri]) * Math.PI * 2 + ri * 0.3;
            const x = cx + Math.cos(angle) * radii[ri];
            const y = cy + Math.sin(angle) * radii[ri];
            if (x > margin && x < W - margin && y > topMargin && y < topMargin + usableH) {
              pegList.push({ x, y });
            }
          }
        }
      } else if (lvl === 4) {
        // V-shape with scatter
        for (let i = 0; i < 12; i++) {
          const t = i / 11;
          pegList.push({ x: margin + t * usableW / 2, y: topMargin + t * usableH });
          pegList.push({ x: W - margin - t * usableW / 2, y: topMargin + t * usableH });
        }
        // Scatter fill
        for (let i = 0; i < 20; i++) {
          const x = margin + Math.random() * usableW;
          const y = topMargin + Math.random() * usableH;
          let tooClose = false;
          for (const p of pegList) {
            if (Math.hypot(p.x - x, p.y - y) < PEG_RADIUS * 3) { tooClose = true; break; }
          }
          if (!tooClose) pegList.push({ x, y });
        }
      } else {
        // Random procedural levels for 5+
        const numPegs = 40 + (lvl - 5) * 5;
        const seed = lvl * 1337;
        let rng = seed;
        function seededRand() { rng = (rng * 16807 + 0) % 2147483647; return rng / 2147483647; }
        for (let i = 0; i < numPegs; i++) {
          let x, y, valid;
          let attempts = 0;
          do {
            x = margin + seededRand() * usableW;
            y = topMargin + seededRand() * usableH;
            valid = true;
            for (const p of pegList) {
              if (Math.hypot(p.x - x, p.y - y) < PEG_RADIUS * 2.8) { valid = false; break; }
            }
            attempts++;
          } while (!valid && attempts < 50);
          if (valid) pegList.push({ x, y });
        }
      }

      // Assign peg types: ~30% orange, ~5% green, rest blue
      const orangeCount = Math.max(8, Math.floor(pegList.length * 0.3));
      const greenCount = Math.max(1, Math.floor(pegList.length * 0.05));

      // Shuffle indices
      const indices = pegList.map((_, i) => i);
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }

      return pegList.map((p, idx) => {
        const shuffledIdx = indices.indexOf(idx);
        let type = 'blue';
        if (shuffledIdx < orangeCount) type = 'orange';
        else if (shuffledIdx < orangeCount + greenCount) type = 'green';
        return { ...p, type, hit: false, radius: PEG_RADIUS, glowTimer: 0 };
      });
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      level = 1;
      ballsLeft = 10;
      launcherAngle = Math.PI / 2;
      ball = null;
      shotActive = false;
      hitPegs = [];
      pegs = generateLevel(level);
      totalOrange = pegs.filter(p => p.type === 'orange').length;
      orangeLeft = totalOrange;
      bucketX = W / 2 - BUCKET_W / 2;
      bucketDir = 1;
      feverTimer = 0;
      feverParticles = [];
      particles = [];
      clearAnimTimer = 0;
      showingClearAnim = false;
      levelCompleteTimer = 0;
      lastShotHitPegs = [];

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PEGGLE';
      overlayText.textContent = 'Left/Right to aim, Space to shoot';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver(win) {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      if (win) {
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = `Score: ${score} - Level ${level} Complete!\nPress any key to play again`;
      } else {
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = `Score: ${score} - Press any key to restart`;
      }
    }

    function shootBall() {
      if (shotActive || showingClearAnim) return;
      const vx = Math.cos(launcherAngle) * SHOOT_SPEED;
      const vy = Math.sin(launcherAngle) * SHOOT_SPEED;
      ball = {
        x: LAUNCHER_X + Math.cos(launcherAngle) * LAUNCHER_LEN,
        y: LAUNCHER_Y + Math.sin(launcherAngle) * LAUNCHER_LEN,
        vx: vx,
        vy: vy,
        active: true
      };
      shotActive = true;
      lastShotHitPegs = [];
      ballsLeft--;
    }

    function resolveCollision(ball, peg) {
      const dx = ball.x - peg.x;
      const dy = ball.y - peg.y;
      const dist = Math.hypot(dx, dy);
      const minDist = BALL_RADIUS + peg.radius;

      if (dist < minDist && dist > 0) {
        // Normalize
        const nx = dx / dist;
        const ny = dy / dist;

        // Separate
        const overlap = minDist - dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        // Reflect velocity
        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * dot * nx;
        ball.vy -= 2 * dot * ny;

        // Damping
        ball.vx *= BOUNCE_DAMPING;
        ball.vy *= BOUNCE_DAMPING;

        return true;
      }
      return false;
    }

    function spawnHitParticles(x, y, color) {
      for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 30 + Math.random() * 20,
          maxLife: 50,
          color,
          size: 2 + Math.random() * 2
        });
      }
    }

    function spawnFeverParticles() {
      const colors = ['#f80', '#ff0', '#f44', '#6af', '#0f0', '#f0f'];
      for (let i = 0; i < 80; i++) {
        feverParticles.push({
          x: Math.random() * W,
          y: H + Math.random() * 50,
          vx: (Math.random() - 0.5) * 4,
          vy: -(3 + Math.random() * 6),
          life: 60 + Math.random() * 60,
          maxLife: 120,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: 2 + Math.random() * 4
        });
      }
    }

    function update() {
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update fever particles
      for (let i = feverParticles.length - 1; i >= 0; i--) {
        const p = feverParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.03;
        p.life--;
        if (p.life <= 0) feverParticles.splice(i, 1);
      }

      if (feverTimer > 0) {
        feverTimer--;
        if (feverTimer === 0 && showingClearAnim) {
          // Fever ended, advance level or end game
          showingClearAnim = false;
          advanceLevel();
        }
        return;
      }

      // Level complete animation
      if (showingClearAnim) return;

      // Clear anim: remove hit pegs one by one after ball falls
      if (clearAnimTimer > 0) {
        clearAnimTimer--;
        if (clearAnimTimer <= 0) {
          finishShot();
        }
        return;
      }

      // Move bucket
      bucketX += BUCKET_SPEED * bucketDir;
      if (bucketX <= 0) { bucketX = 0; bucketDir = 1; }
      if (bucketX >= W - BUCKET_W) { bucketX = W - BUCKET_W; bucketDir = -1; }

      // Aim with keys
      if (keys['ArrowLeft']) launcherAngle -= AIM_SPEED;
      if (keys['ArrowRight']) launcherAngle += AIM_SPEED;
      // Clamp angle to downward arc
      launcherAngle = Math.max(0.15, Math.min(Math.PI - 0.15, launcherAngle));

      if (!ball || !ball.active) return;

      // Move ball (substeps for better collision)
      const substeps = 3;
      for (let s = 0; s < substeps; s++) {
        ball.vy += GRAVITY / substeps;
        ball.x += ball.vx / substeps;
        ball.y += ball.vy / substeps;

        // Wall collisions
        if (ball.x - BALL_RADIUS < 0) {
          ball.x = BALL_RADIUS;
          ball.vx = Math.abs(ball.vx) * WALL_DAMPING;
        }
        if (ball.x + BALL_RADIUS > W) {
          ball.x = W - BALL_RADIUS;
          ball.vx = -Math.abs(ball.vx) * WALL_DAMPING;
        }
        // Ceiling
        if (ball.y - BALL_RADIUS < 0) {
          ball.y = BALL_RADIUS;
          ball.vy = Math.abs(ball.vy) * WALL_DAMPING;
        }

        // Peg collisions
        for (const peg of pegs) {
          if (peg.hit) continue;
          if (resolveCollision(ball, peg)) {
            peg.hit = true;
            peg.glowTimer = 30;
            lastShotHitPegs.push(peg);

            // Score
            let pts = 0;
            if (peg.type === 'orange') {
              pts = 100;
              orangeLeft--;
            } else if (peg.type === 'blue') {
              pts = 10;
            } else if (peg.type === 'green') {
              pts = 50;
              // Green power: extra ball
              ballsLeft++;
            }

            // Multiplier based on hit count this shot
            const hitCount = lastShotHitPegs.length;
            if (hitCount >= 10) pts *= 5;
            else if (hitCount >= 7) pts *= 3;
            else if (hitCount >= 4) pts *= 2;

            score += pts;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }

            const colorMap = { orange: '#f80', blue: '#6af', green: '#0f0' };
            spawnHitParticles(peg.x, peg.y, colorMap[peg.type] || '#fff');
          }
        }
      }

      // Update peg glow timers
      for (const peg of pegs) {
        if (peg.glowTimer > 0) peg.glowTimer--;
      }

      // Ball fell below screen
      if (ball.y - BALL_RADIUS > H) {
        // Check if ball landed in bucket
        if (ball.x > bucketX && ball.x < bucketX + BUCKET_W) {
          // Free ball!
          ballsLeft++;
          spawnHitParticles(ball.x, BUCKET_Y, '#6af');
        }
        ball.active = false;
        // Start clear animation
        clearAnimTimer = 20;
        return;
      }

      // Check bucket collision while ball is near bottom
      if (ball.y + BALL_RADIUS >= BUCKET_Y && ball.y - BALL_RADIUS <= BUCKET_Y + BUCKET_H) {
        if (ball.x > bucketX && ball.x < bucketX + BUCKET_W) {
          // Bounce off bucket top
          if (ball.vy > 0) {
            ball.y = BUCKET_Y - BALL_RADIUS;
            ball.vy = -ball.vy * 0.5;
            // Don't award free ball on bounce - only on fall-through
          }
        }
      }
    }

    function finishShot() {
      // Remove hit pegs with animation
      pegs = pegs.filter(p => !p.hit);
      shotActive = false;
      ball = null;

      // Check if all orange pegs cleared
      orangeLeft = pegs.filter(p => p.type === 'orange').length;

      if (orangeLeft <= 0) {
        // EXTREME FEVER
        feverTimer = 120;
        showingClearAnim = true;
        spawnFeverParticles();
        // Bonus points for remaining balls
        score += ballsLeft * 500;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        return;
      }

      if (ballsLeft <= 0) {
        gameOver(false);
        return;
      }
    }

    function advanceLevel() {
      level++;
      ballsLeft = Math.max(ballsLeft, 10);
      pegs = generateLevel(level);
      totalOrange = pegs.filter(p => p.type === 'orange').length;
      orangeLeft = totalOrange;
      launcherAngle = Math.PI / 2;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Subtle grid
      ctx.strokeStyle = 'rgba(22, 33, 62, 0.5)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y < H; y += 40) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Draw pegs
      for (const peg of pegs) {
        let color, glowColor;
        if (peg.type === 'orange') {
          color = peg.hit ? '#fc6' : '#f80';
          glowColor = '#f80';
        } else if (peg.type === 'green') {
          color = peg.hit ? '#8f8' : '#0f0';
          glowColor = '#0f0';
        } else {
          color = peg.hit ? '#8bf' : '#48e';
          glowColor = '#6af';
        }

        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);

        if (peg.hit) {
          ctx.fillStyle = color;
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 20 + peg.glowTimer;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          // Normal peg
          ctx.fillStyle = color;
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 6;
          ctx.fill();
          ctx.shadowBlur = 0;

          // Inner highlight
          ctx.beginPath();
          ctx.arc(peg.x - 2, peg.y - 2, peg.radius * 0.4, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fill();
        }
      }

      // Draw particles
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw fever particles
      for (const p of feverParticles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Draw bucket
      ctx.fillStyle = '#16213e';
      ctx.strokeStyle = '#6af';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#6af';
      ctx.shadowBlur = 8;
      // Bucket shape
      ctx.beginPath();
      ctx.moveTo(bucketX, BUCKET_Y);
      ctx.lineTo(bucketX + 6, BUCKET_Y + BUCKET_H);
      ctx.lineTo(bucketX + BUCKET_W - 6, BUCKET_Y + BUCKET_H);
      ctx.lineTo(bucketX + BUCKET_W, BUCKET_Y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Draw launcher
      const tipX = LAUNCHER_X + Math.cos(launcherAngle) * LAUNCHER_LEN;
      const tipY = LAUNCHER_Y + Math.sin(launcherAngle) * LAUNCHER_LEN;

      // Launcher base
      ctx.fillStyle = '#6af';
      ctx.shadowColor = '#6af';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(LAUNCHER_X, LAUNCHER_Y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Launcher barrel
      ctx.strokeStyle = '#6af';
      ctx.lineWidth = 5;
      ctx.shadowColor = '#6af';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(LAUNCHER_X, LAUNCHER_Y);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Aiming guide (dotted line)
      if (!shotActive) {
        ctx.setLineDash([4, 6]);
        ctx.strokeStyle = 'rgba(102, 170, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(
          LAUNCHER_X + Math.cos(launcherAngle) * 200,
          LAUNCHER_Y + Math.sin(launcherAngle) * 200
        );
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw ball
      if (ball && ball.active) {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#6af';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Ball trail
        ctx.fillStyle = 'rgba(102, 170, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(ball.x - ball.vx * 0.5, ball.y - ball.vy * 0.5, BALL_RADIUS * 0.7, 0, Math.PI * 2);
        ctx.fill();
      }

      // HUD - info bar at top
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(0, 0, W, 16);

      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#888';
      ctx.fillText(`Balls: ${ballsLeft}`, 8, 12);

      ctx.textAlign = 'center';
      ctx.fillStyle = '#f80';
      ctx.fillText(`Orange: ${orangeLeft}/${totalOrange}`, W / 2, 12);

      ctx.textAlign = 'right';
      ctx.fillStyle = '#888';
      ctx.fillText(`Level ${level}`, W - 8, 12);

      // Fever text
      if (feverTimer > 0) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = 'bold 36px Courier New';
        const feverAlpha = Math.min(1, feverTimer / 30);
        ctx.fillStyle = `rgba(255, 136, 0, ${feverAlpha})`;
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 20;
        ctx.fillText('EXTREME FEVER!', W / 2, H / 2 - 20);
        ctx.font = '18px Courier New';
        ctx.fillStyle = `rgba(255, 255, 0, ${feverAlpha})`;
        ctx.shadowColor = '#ff0';
        ctx.fillText(`+${ballsLeft * 500} BONUS!`, W / 2, H / 2 + 20);
        ctx.restore();
        ctx.shadowBlur = 0;
      }

      // Hit count display during active shot
      if (shotActive && lastShotHitPegs.length > 0) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.font = '14px Courier New';
        let mult = 1;
        const hc = lastShotHitPegs.length;
        if (hc >= 10) mult = 5;
        else if (hc >= 7) mult = 3;
        else if (hc >= 4) mult = 2;
        ctx.fillStyle = mult > 1 ? '#ff0' : '#aaa';
        if (mult > 1) { ctx.shadowColor = '#ff0'; ctx.shadowBlur = 8; }
        ctx.fillText(`${hc} hits${mult > 1 ? ' x' + mult : ''}`, W - 10, 32);
        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ' && !shotActive && !showingClearAnim && ballsLeft > 0) {
          shootBall();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

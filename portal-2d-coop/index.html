<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portal 2D Co-op</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 255, 0.5); }
    h1 { color: #4af; font-size: 1.5rem; text-shadow: 0 0 15px rgba(68, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4af; }
    canvas {
      border: 2px solid #4af;
      box-shadow: 0 0 20px rgba(68, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(68, 170, 255, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .controls-hint {
      width: 600px;
      margin-top: 10px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PORTAL 2D CO-OP</h1>
  </div>
  <div class="score-bar">
    <div>Room: <span id="room">1</span>/5</div>
    <div>Score: <span id="score">0</span></div>
    <div>Time: <span id="timer">0</span>s</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">PORTAL 2D CO-OP</h2>
      <p id="overlayText">Arrows = Move/Jump | Z = Blue Portal | X = Orange Portal</p>
      <p style="color:#4af; margin-top:8px;">Click to Start</p>
    </div>
  </div>
  <div class="controls-hint">Arrows: Move/Jump | Z: Fire Blue Portal | X: Fire Orange Portal | AI ally coordinates automatically</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const roomEl = document.getElementById('room');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'menu';
    let score = 0;
    let currentRoom = 0;
    let roomStartTime = 0;
    let totalTime = 0;
    let elapsed = 0;

    const GRAVITY = 0.45;
    const JUMP_FORCE = -8.5;
    const MOVE_SPEED = 3;
    const TILE = 25;
    const COLS = W / TILE;
    const ROWS = H / TILE;

    const keys = {};
    const justPressed = {};
    window.addEventListener('keydown', e => {
      if (!keys[e.key]) justPressed[e.key] = true;
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','z','x',' '].includes(e.key)) e.preventDefault();
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    class Portal {
      constructor(x, y, nx, ny, color) {
        this.x = x; this.y = y;
        this.nx = nx; this.ny = ny;
        this.color = color;
        this.age = 0;
      }
    }

    class Player {
      constructor(x, y, color, name) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.w = 14; this.h = 22;
        this.color = color;
        this.name = name;
        this.onGround = false;
        this.portalBlue = null;
        this.portalOrange = null;
        this.facingRight = true;
        this.atExit = false;
        this.portalCooldown = 0;
        this.teleportCooldown = 0;
      }
    }

    class Cube {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.w = 20; this.h = 20;
        this.onGround = false;
        this.teleportCooldown = 0;
      }
    }

    class Button {
      constructor(x, y, targetId) {
        this.x = x; this.y = y;
        this.w = 30; this.h = 8;
        this.pressed = false;
        this.targetId = targetId;
      }
    }

    class Door {
      constructor(x, y, id) {
        this.x = x; this.y = y;
        this.w = TILE; this.h = TILE * 2;
        this.open = false;
        this.id = id;
        this.openAmount = 0;
      }
    }

    class Exit {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.w = 30; this.h = 40;
      }
    }

    let player, ai, cubes, buttons, doors, exits, tiles, particles, portalProjectiles;

    function buildRoom(roomNum) {
      tiles = [];
      cubes = [];
      buttons = [];
      doors = [];
      exits = [];
      particles = [];
      portalProjectiles = [];

      for (let r = 0; r < ROWS; r++) {
        tiles[r] = [];
        for (let c = 0; c < COLS; c++) tiles[r][c] = 0;
      }

      function wall(c, r) { if (r >= 0 && r < ROWS && c >= 0 && c < COLS) tiles[r][c] = 1; }
      function pwall(c, r) { if (r >= 0 && r < ROWS && c >= 0 && c < COLS) tiles[r][c] = 2; }
      function fillRow(r, c1, c2, type) { for (let c = c1; c <= c2; c++) { if (type === 2) pwall(c, r); else wall(c, r); } }
      function fillCol(c, r1, r2, type) { for (let r = r1; r <= r2; r++) { if (type === 2) pwall(c, r); else wall(c, r); } }

      // Border
      for (let c = 0; c < COLS; c++) { wall(c, 0); wall(c, ROWS - 1); }
      for (let r = 0; r < ROWS; r++) { wall(0, r); wall(COLS - 1, r); }

      if (roomNum === 0) {
        // Room 1: Intro - cross a gap using portals
        fillRow(13, 1, 9, 1);
        fillRow(13, 14, 22, 1);
        fillCol(9, 3, 12, 2);
        fillCol(14, 3, 12, 2);
        fillCol(1, 3, 12, 2);
        fillRow(1, 2, 22, 2);
        player = new Player(75, 13 * TILE - 14, '#4af', 'You');
        ai = new Player(115, 13 * TILE - 14, '#fa4', 'ATLAS');
        exits.push(new Exit(540, 13 * TILE - 42));
      }
      else if (roomNum === 1) {
        // Room 2: Reach upper platform, button opens door
        fillRow(13, 1, 22, 1);
        fillRow(8, 12, 22, 1);
        fillCol(1, 1, 12, 2);
        fillRow(13, 3, 7, 2);
        fillCol(22, 1, 7, 2);
        fillRow(1, 1, 22, 2);
        doors.push(new Door(18 * TILE, 8 * TILE - TILE * 2 + 2, 'door1'));
        buttons.push(new Button(14 * TILE, 8 * TILE - 10, 'door1'));
        player = new Player(60, 13 * TILE - 14, '#4af', 'You');
        ai = new Player(95, 13 * TILE - 14, '#fa4', 'ATLAS');
        exits.push(new Exit(20 * TILE, 8 * TILE - 42));
      }
      else if (roomNum === 2) {
        // Room 3: Push cube onto button
        fillRow(13, 1, 22, 1);
        fillRow(9, 1, 10, 1);
        fillRow(9, 15, 22, 1);
        fillCol(1, 1, 12, 2);
        fillCol(22, 1, 8, 2);
        fillRow(1, 2, 22, 2);
        fillCol(10, 10, 12, 2);
        fillCol(15, 10, 12, 2);
        cubes.push(new Cube(5 * TILE, 9 * TILE - 12));
        buttons.push(new Button(18 * TILE, 9 * TILE - 10, 'door1'));
        doors.push(new Door(21 * TILE, 9 * TILE - TILE * 2 + 2, 'door1'));
        player = new Player(60, 13 * TILE - 14, '#4af', 'You');
        ai = new Player(95, 13 * TILE - 14, '#fa4', 'ATLAS');
        exits.push(new Exit(22 * TILE - 35, 9 * TILE - 42));
      }
      else if (roomNum === 3) {
        // Room 4: Two buttons, two doors - split coordination
        fillRow(13, 1, 22, 1);
        fillRow(10, 1, 6, 1);
        fillRow(7, 9, 14, 1);
        fillRow(10, 17, 22, 1);
        fillCol(1, 1, 9, 2);
        fillCol(6, 1, 9, 2);
        fillCol(9, 1, 6, 2);
        fillCol(14, 1, 6, 2);
        fillCol(17, 1, 9, 2);
        fillCol(22, 1, 9, 2);
        fillRow(1, 2, 22, 2);
        buttons.push(new Button(3 * TILE, 10 * TILE - 10, 'door1'));
        buttons.push(new Button(19 * TILE, 10 * TILE - 10, 'door2'));
        doors.push(new Door(11 * TILE, 7 * TILE - TILE * 2 + 2, 'door1'));
        doors.push(new Door(12 * TILE, 7 * TILE - TILE * 2 + 2, 'door2'));
        player = new Player(60, 13 * TILE - 14, '#4af', 'You');
        ai = new Player(530, 13 * TILE - 14, '#fa4', 'ATLAS');
        exits.push(new Exit(11.5 * TILE, 7 * TILE - 42));
      }
      else if (roomNum === 4) {
        // Room 5: Final - momentum fling + cube + multi-button
        fillRow(13, 1, 7, 1);
        fillRow(13, 10, 22, 1);
        fillRow(4, 17, 22, 1);
        fillRow(9, 10, 14, 1);
        fillCol(1, 1, 12, 2);
        fillCol(7, 7, 12, 2);
        fillCol(10, 7, 12, 2);
        fillRow(13, 8, 9, 2);
        fillCol(22, 1, 12, 2);
        fillCol(17, 5, 12, 2);
        fillRow(1, 2, 22, 2);
        cubes.push(new Cube(12 * TILE, 9 * TILE - 12));
        buttons.push(new Button(12 * TILE, 13 * TILE - 10, 'door1'));
        buttons.push(new Button(20 * TILE, 4 * TILE - 10, 'door2'));
        doors.push(new Door(15 * TILE, 9 * TILE - TILE * 2 + 2, 'door1'));
        doors.push(new Door(19 * TILE, 4 * TILE - TILE * 2 + 2, 'door2'));
        player = new Player(60, 13 * TILE - 14, '#4af', 'You');
        ai = new Player(95, 13 * TILE - 14, '#fa4', 'ATLAS');
        exits.push(new Exit(21 * TILE, 4 * TILE - 42));
      }

      if (player) {
        player.portalBlue = null;
        player.portalOrange = null;
        player.atExit = false;
        player.teleportCooldown = 0;
      }
      if (ai) {
        ai.portalBlue = null;
        ai.portalOrange = null;
        ai.atExit = false;
        ai.teleportCooldown = 0;
      }
    }

    function getTile(px, py) {
      let c = Math.floor(px / TILE);
      let r = Math.floor(py / TILE);
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return 1;
      return tiles[r][c];
    }

    function isSolid(px, py) {
      let t = getTile(px, py);
      if (t === 1 || t === 2) return true;
      for (let d of doors) {
        if (d.openAmount < 0.8 && px >= d.x && px < d.x + d.w && py >= d.y && py < d.y + d.h * (1 - d.openAmount)) return true;
      }
      return false;
    }

    function isPortalable(px, py) {
      let c = Math.floor(px / TILE);
      let r = Math.floor(py / TILE);
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
      return tiles[r][c] === 2;
    }

    function moveEntity(ent) {
      ent.vy += GRAVITY;
      if (ent.vy > 12) ent.vy = 12;

      let hw = ent.w / 2, hh = ent.h / 2;

      // Horizontal
      let newX = ent.x + ent.vx;
      if (!isSolid(newX - hw, ent.y - hh + 2) && !isSolid(newX + hw - 1, ent.y - hh + 2) &&
          !isSolid(newX - hw, ent.y + hh - 1) && !isSolid(newX + hw - 1, ent.y + hh - 1) &&
          !isSolid(newX - hw, ent.y) && !isSolid(newX + hw - 1, ent.y)) {
        ent.x = newX;
      } else {
        ent.vx = 0;
      }

      // Vertical
      ent.onGround = false;
      let newY = ent.y + ent.vy;
      if (!isSolid(ent.x - hw + 2, newY - hh) && !isSolid(ent.x + hw - 3, newY - hh) &&
          !isSolid(ent.x - hw + 2, newY + hh - 1) && !isSolid(ent.x + hw - 3, newY + hh - 1)) {
        ent.y = newY;
      } else {
        if (ent.vy > 0) ent.onGround = true;
        ent.vy = 0;
      }

      if (ent.teleportCooldown > 0) ent.teleportCooldown--;

      ent.x = Math.max(hw + TILE, Math.min(W - hw - TILE, ent.x));
      ent.y = Math.max(hh + TILE, Math.min(H - hh - TILE, ent.y));
    }

    function firePortal(owner, type) {
      let dir = owner.facingRight ? 1 : -1;
      portalProjectiles.push({
        x: owner.x + dir * 10,
        y: owner.y - 4,
        vx: dir * 12,
        vy: -1.5,
        owner: owner,
        type: type,
        color: type === 'blue' ? '#4af' : '#f84',
        life: 80
      });
    }

    function placePortal(proj) {
      let px = proj.x, py = proj.y;
      let nx = 0, ny = 0;

      // Determine which face of the tile we hit
      let tc = Math.floor(px / TILE), tr = Math.floor(py / TILE);

      // Check from which direction the projectile came
      let prevX = px - proj.vx;
      let prevY = py - proj.vy;
      let prevC = Math.floor(prevX / TILE), prevR = Math.floor(prevY / TILE);

      if (prevC < tc) { nx = -1; px = tc * TILE; }
      else if (prevC > tc) { nx = 1; px = (tc + 1) * TILE; }
      else if (prevR < tr) { ny = -1; py = tr * TILE; }
      else if (prevR > tr) { ny = 1; py = (tr + 1) * TILE; }
      else {
        // Fallback based on velocity
        if (Math.abs(proj.vx) > Math.abs(proj.vy)) {
          nx = proj.vx > 0 ? -1 : 1;
          px = proj.vx > 0 ? tc * TILE : (tc + 1) * TILE;
        } else {
          ny = proj.vy > 0 ? -1 : 1;
          py = proj.vy > 0 ? tr * TILE : (tr + 1) * TILE;
        }
      }

      // Center the portal on the tile face
      if (nx !== 0) py = tr * TILE + TILE / 2;
      if (ny !== 0) px = tc * TILE + TILE / 2;

      let portal = new Portal(px, py, nx, ny, proj.type === 'blue' ? '#4af' : '#f84');
      if (proj.type === 'blue') proj.owner.portalBlue = portal;
      else proj.owner.portalOrange = portal;

      for (let i = 0; i < 10; i++) {
        particles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 5 + nx * 3,
          vy: (Math.random() - 0.5) * 5 + ny * 3,
          life: 20 + Math.random() * 15,
          color: portal.color
        });
      }
    }

    function checkPortalTransport(ent) {
      if (ent.teleportCooldown > 0) return false;

      let allPortalPairs = [];
      if (player.portalBlue && player.portalOrange) {
        allPortalPairs.push([player.portalBlue, player.portalOrange]);
        allPortalPairs.push([player.portalOrange, player.portalBlue]);
      }
      if (ai.portalBlue && ai.portalOrange) {
        allPortalPairs.push([ai.portalBlue, ai.portalOrange]);
        allPortalPairs.push([ai.portalOrange, ai.portalBlue]);
      }

      for (let [enter, exit] of allPortalPairs) {
        let dist = Math.hypot(ent.x - enter.x, ent.y - enter.y);
        if (dist < 16) {
          // Teleport
          ent.x = exit.x + exit.nx * 22;
          ent.y = exit.y + exit.ny * 22;

          // Momentum conservation through portals
          let inSpeed = ent.vx * (-enter.nx) + ent.vy * (-enter.ny);
          if (inSpeed < 0) inSpeed = Math.hypot(ent.vx, ent.vy);
          if (inSpeed < 3) inSpeed = 3;

          // Apply momentum in exit direction
          let tangentVx = ent.vx - (-enter.nx) * (ent.vx * (-enter.nx) + ent.vy * (-enter.ny));
          let tangentVy = ent.vy - (-enter.ny) * (ent.vx * (-enter.nx) + ent.vy * (-enter.ny));

          ent.vx = exit.nx * inSpeed + tangentVx * 0.3;
          ent.vy = exit.ny * inSpeed + tangentVy * 0.3;

          // Boost upward exits
          if (exit.ny < 0 && ent.vy > -5) ent.vy = -Math.max(5, inSpeed * 0.9);

          ent.teleportCooldown = 15;

          // Particles
          for (let p of [enter, exit]) {
            for (let i = 0; i < 8; i++) {
              particles.push({
                x: p.x, y: p.y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 18,
                color: p.color
              });
            }
          }
          return true;
        }
      }
      return false;
    }

    function checkButtons() {
      for (let btn of buttons) {
        btn.pressed = false;
        for (let p of [player, ai]) {
          if (Math.abs(p.x - btn.x - btn.w / 2) < 20 && Math.abs((p.y + p.h / 2) - btn.y) < 16) {
            btn.pressed = true;
          }
        }
        for (let c of cubes) {
          if (Math.abs(c.x - btn.x - btn.w / 2) < 22 && Math.abs((c.y + c.h / 2) - btn.y) < 16) {
            btn.pressed = true;
          }
        }
      }
      for (let d of doors) {
        let shouldOpen = false;
        for (let btn of buttons) {
          if (btn.targetId === d.id && btn.pressed) shouldOpen = true;
        }
        d.open = shouldOpen;
        let target = d.open ? 1 : 0;
        d.openAmount += (target - d.openAmount) * 0.1;
      }
    }

    function checkExit() {
      for (let ex of exits) {
        player.atExit = false;
        ai.atExit = false;
        for (let p of [player, ai]) {
          if (Math.abs(p.x - ex.x - ex.w / 2) < 25 && Math.abs(p.y - ex.y - ex.h / 2) < 30) {
            p.atExit = true;
          }
        }
      }
      if (player.atExit && ai.atExit) {
        completeRoom();
      }
    }

    function completeRoom() {
      let timeBonus = Math.max(0, 60 - elapsed);
      score += 100 + timeBonus;
      scoreEl.textContent = score;
      currentRoom++;
      if (currentRoom >= 5) {
        gameState = 'win';
        showOverlay('ALL ROOMS COMPLETE!', 'Final Score: ' + score + ' | Click to play again');
      } else {
        roomEl.textContent = currentRoom + 1;
        buildRoom(currentRoom);
        roomStartTime = Date.now();
      }
    }

    // AI behavior
    let aiThinkTimer = 0;
    let aiAction = 'follow';
    let aiPortalTimer = 0;
    let aiJumpTimer = 0;

    function updateAI() {
      aiThinkTimer++;
      aiPortalTimer--;
      if (aiJumpTimer > 0) aiJumpTimer--;

      if (aiThinkTimer % 20 === 0) {
        aiAction = decideAIAction();
      }

      let targetX = player.x;
      let targetY = player.y;

      if (aiAction === 'goToButton') {
        for (let btn of buttons) {
          if (!btn.pressed) {
            targetX = btn.x + btn.w / 2;
            targetY = btn.y - 20;
            break;
          }
        }
      } else if (aiAction === 'goToExit') {
        if (exits.length > 0) {
          targetX = exits[0].x + exits[0].w / 2;
          targetY = exits[0].y;
        }
      } else if (aiAction === 'standOnButton') {
        for (let btn of buttons) {
          if (btn.pressed && Math.abs(ai.x - btn.x - btn.w / 2) < 25) {
            targetX = btn.x + btn.w / 2;
            targetY = btn.y - 15;
            break;
          }
          if (!btn.pressed) {
            targetX = btn.x + btn.w / 2;
            targetY = btn.y - 15;
            break;
          }
        }
      } else if (aiAction === 'pushCube') {
        if (cubes.length > 0) {
          let cube = cubes[0];
          // Find target button
          let targetBtn = null;
          for (let btn of buttons) {
            if (!btn.pressed) { targetBtn = btn; break; }
          }
          if (targetBtn) {
            // Position AI to push cube toward button
            let pushDir = cube.x < targetBtn.x + targetBtn.w / 2 ? -1 : 1;
            targetX = cube.x + pushDir * 18;
            targetY = cube.y;
          }
        }
      }

      // Move toward target
      let dx = targetX - ai.x;
      if (Math.abs(dx) > 6) {
        ai.vx += (dx > 0 ? 0.6 : -0.6);
        ai.facingRight = dx > 0;
      } else {
        ai.vx *= 0.7;
      }
      ai.vx *= 0.88;
      if (Math.abs(ai.vx) > MOVE_SPEED) ai.vx = Math.sign(ai.vx) * MOVE_SPEED;

      // Jump logic
      if (ai.onGround && aiJumpTimer <= 0) {
        let needJump = false;
        // Target is above
        if (targetY < ai.y - 35) needJump = true;
        // Obstacle ahead
        if (Math.abs(dx) > 8 && isSolid(ai.x + Math.sign(dx) * 12, ai.y)) needJump = true;
        // Gap ahead
        if (Math.abs(dx) > 8 && !isSolid(ai.x + Math.sign(dx) * 20, ai.y + ai.h / 2 + 5) &&
            isSolid(ai.x, ai.y + ai.h / 2 + 5)) needJump = true;

        if (needJump) {
          ai.vy = JUMP_FORCE;
          aiJumpTimer = 20;
        }
      }

      // AI portal placement
      if (aiPortalTimer <= 0 && aiThinkTimer > 40) {
        if (aiPlacePortals()) {
          aiPortalTimer = 120;
        }
      }
    }

    function decideAIAction() {
      if (player.atExit) return 'goToExit';

      let hasClosedDoor = doors.some(d => d.openAmount < 0.5);
      let hasUnpressedButton = buttons.some(b => !b.pressed);

      // Check if AI is already on a button
      for (let btn of buttons) {
        if (Math.abs(ai.x - btn.x - btn.w / 2) < 25 && Math.abs(ai.y + ai.h / 2 - btn.y) < 16) {
          let doorNeedsIt = doors.some(d => d.id === btn.targetId && d.openAmount < 0.5);
          if (doorNeedsIt) return 'standOnButton';
        }
      }

      if (hasClosedDoor && hasUnpressedButton) {
        // Check if cubes exist and button needs one
        if (cubes.length > 0) {
          let cubeOnAnyButton = false;
          for (let btn of buttons) {
            for (let c of cubes) {
              if (Math.abs(c.x - btn.x - btn.w / 2) < 22) cubeOnAnyButton = true;
            }
          }
          if (!cubeOnAnyButton && currentRoom === 2) return 'pushCube';
        }

        // If player is near a button, AI goes to another one or to exit area
        let playerNearButton = false;
        for (let btn of buttons) {
          if (Math.abs(player.x - btn.x - btn.w / 2) < 50) playerNearButton = true;
        }
        if (playerNearButton) return 'goToExit';
        return 'goToButton';
      }

      // All doors open - head to exit
      if (!hasClosedDoor && exits.length > 0) {
        let exDist = Math.hypot(player.x - exits[0].x, player.y - exits[0].y);
        if (exDist < 100) return 'goToExit';
      }

      return 'follow';
    }

    function aiPlacePortals() {
      let target = null;
      if (aiAction === 'goToButton') {
        for (let btn of buttons) {
          if (!btn.pressed) { target = { x: btn.x + btn.w / 2, y: btn.y - 10 }; break; }
        }
      } else if (aiAction === 'goToExit') {
        if (exits.length > 0) target = { x: exits[0].x + exits[0].w / 2, y: exits[0].y };
      }
      if (!target) return false;

      let dy = target.y - ai.y;
      let dx = target.x - ai.x;
      if (Math.abs(dy) < 40 && Math.abs(dx) < 80) return false;

      let placed1 = false, placed2 = false;

      // Place blue portal near AI
      let searchR = Math.floor(ai.y / TILE);
      let searchC = Math.floor(ai.x / TILE);
      for (let dr = -2; dr <= 2 && !placed1; dr++) {
        for (let dc = -2; dc <= 2 && !placed1; dc++) {
          let r = searchR + dr, c = searchC + dc;
          if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
          if (tiles[r][c] !== 2) continue;
          // Find adjacent air
          if (c > 0 && tiles[r][c - 1] === 0) {
            ai.portalBlue = new Portal(c * TILE, r * TILE + TILE / 2, -1, 0, '#4af');
            placed1 = true;
          } else if (c < COLS - 1 && tiles[r][c + 1] === 0) {
            ai.portalBlue = new Portal((c + 1) * TILE, r * TILE + TILE / 2, 1, 0, '#4af');
            placed1 = true;
          } else if (r > 0 && tiles[r - 1][c] === 0) {
            ai.portalBlue = new Portal(c * TILE + TILE / 2, r * TILE, 0, -1, '#4af');
            placed1 = true;
          } else if (r < ROWS - 1 && tiles[r + 1][c] === 0) {
            ai.portalBlue = new Portal(c * TILE + TILE / 2, (r + 1) * TILE, 0, 1, '#4af');
            placed1 = true;
          }
        }
      }

      // Place orange portal near target
      searchR = Math.floor(target.y / TILE);
      searchC = Math.floor(target.x / TILE);
      for (let dr = -3; dr <= 3 && !placed2; dr++) {
        for (let dc = -3; dc <= 3 && !placed2; dc++) {
          let r = searchR + dr, c = searchC + dc;
          if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
          if (tiles[r][c] !== 2) continue;
          if (c > 0 && tiles[r][c - 1] === 0) {
            ai.portalOrange = new Portal(c * TILE, r * TILE + TILE / 2, -1, 0, '#f84');
            placed2 = true;
          } else if (c < COLS - 1 && tiles[r][c + 1] === 0) {
            ai.portalOrange = new Portal((c + 1) * TILE, r * TILE + TILE / 2, 1, 0, '#f84');
            placed2 = true;
          } else if (r > 0 && tiles[r - 1][c] === 0) {
            ai.portalOrange = new Portal(c * TILE + TILE / 2, r * TILE, 0, -1, '#f84');
            placed2 = true;
          } else if (r < ROWS - 1 && tiles[r + 1][c] === 0) {
            ai.portalOrange = new Portal(c * TILE + TILE / 2, (r + 1) * TILE, 0, 1, '#f84');
            placed2 = true;
          }
        }
      }

      if (placed1 && placed2) {
        // Particles for AI portal placement
        for (let p of [ai.portalBlue, ai.portalOrange]) {
          if (p) {
            for (let i = 0; i < 6; i++) {
              particles.push({
                x: p.x, y: p.y,
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                life: 15, color: p.color
              });
            }
          }
        }
        return true;
      }
      return false;
    }

    function handleInput() {
      player.vx = 0;
      if (keys['ArrowLeft']) { player.vx = -MOVE_SPEED; player.facingRight = false; }
      if (keys['ArrowRight']) { player.vx = MOVE_SPEED; player.facingRight = true; }
      if (keys['ArrowUp'] && player.onGround) {
        player.vy = JUMP_FORCE;
      }
      if (justPressed['z']) {
        firePortal(player, 'blue');
        justPressed['z'] = false;
      }
      if (justPressed['x']) {
        firePortal(player, 'orange');
        justPressed['x'] = false;
      }
    }

    function updateProjectiles() {
      for (let i = portalProjectiles.length - 1; i >= 0; i--) {
        let p = portalProjectiles[i];
        let prevX = p.x, prevY = p.y;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.12;
        p.life--;

        // Trail
        if (p.life % 2 === 0) {
          particles.push({
            x: p.x, y: p.y,
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            life: 10,
            color: p.color
          });
        }

        // Hit check
        let tc = Math.floor(p.x / TILE), tr = Math.floor(p.y / TILE);
        if (tc >= 0 && tc < COLS && tr >= 0 && tr < ROWS && tiles[tr][tc] !== 0) {
          if (tiles[tr][tc] === 2) {
            placePortal(p);
          } else {
            // Hit non-portalable wall - spark particles
            for (let j = 0; j < 4; j++) {
              particles.push({
                x: p.x, y: p.y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 10,
                color: '#888'
              });
            }
          }
          portalProjectiles.splice(i, 1);
          continue;
        }
        if (p.life <= 0 || p.x < 0 || p.x > W || p.y < 0 || p.y > H) {
          portalProjectiles.splice(i, 1);
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function updateCubes() {
      for (let cube of cubes) {
        for (let p of [player, ai]) {
          let dx = cube.x - p.x;
          let dy = cube.y - p.y;
          if (Math.abs(dx) < (cube.w / 2 + p.w / 2 + 4) && Math.abs(dy) < (cube.h / 2 + p.h / 2)) {
            if (Math.abs(dx) > Math.abs(dy) * 0.5) {
              cube.vx += Math.sign(dx) * 0.5;
            }
          }
        }
        cube.vy += GRAVITY;
        cube.vx *= 0.82;
        moveEntity(cube);
        checkPortalTransport(cube);
      }
    }

    function update() {
      if (gameState !== 'playing') return;

      elapsed = Math.floor((Date.now() - roomStartTime) / 1000);
      timerEl.textContent = elapsed;

      handleInput();
      updateAI();
      moveEntity(player);
      moveEntity(ai);
      checkPortalTransport(player);
      checkPortalTransport(ai);
      updateProjectiles();
      updateParticles();
      updateCubes();
      checkButtons();
      checkExit();

      // Clear justPressed
      for (let k in justPressed) justPressed[k] = false;
    }

    // === DRAWING ===

    function drawPortalOval(portal) {
      if (!portal) return;
      ctx.save();
      ctx.translate(portal.x, portal.y);

      let angle = portal.nx !== 0 ? 0 : Math.PI / 2;
      ctx.rotate(angle);

      let pulse = Math.sin(Date.now() / 200) * 0.15 + 0.85;

      // Outer glow
      let grad = ctx.createRadialGradient(0, 0, 5, 0, 0, 22);
      grad.addColorStop(0, portal.color + '66');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, 22, 22, 0, 0, Math.PI * 2);
      ctx.fill();

      // Outer ring
      ctx.beginPath();
      ctx.ellipse(0, 0, 6 * pulse, 17 * pulse, 0, 0, Math.PI * 2);
      ctx.strokeStyle = portal.color;
      ctx.lineWidth = 3;
      ctx.shadowColor = portal.color;
      ctx.shadowBlur = 12;
      ctx.stroke();

      // Fill
      ctx.fillStyle = portal.color + '22';
      ctx.fill();

      // Inner ring
      ctx.beginPath();
      ctx.ellipse(0, 0, 3 * pulse, 12 * pulse, 0, 0, Math.PI * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 5;
      ctx.stroke();

      ctx.restore();
    }

    function drawPlayer(p) {
      ctx.save();
      ctx.translate(Math.round(p.x), Math.round(p.y));

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(-p.w / 2 + 2, p.h / 2 - 2, p.w, 3);

      // Body
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 10;
      // Rounded body
      let bx = -p.w / 2, by = -p.h / 2, bw = p.w, bh = p.h;
      ctx.beginPath();
      ctx.moveTo(bx + 3, by);
      ctx.lineTo(bx + bw - 3, by);
      ctx.quadraticCurveTo(bx + bw, by, bx + bw, by + 3);
      ctx.lineTo(bx + bw, by + bh - 3);
      ctx.quadraticCurveTo(bx + bw, by + bh, bx + bw - 3, by + bh);
      ctx.lineTo(bx + 3, by + bh);
      ctx.quadraticCurveTo(bx, by + bh, bx, by + bh - 3);
      ctx.lineTo(bx, by + 3);
      ctx.quadraticCurveTo(bx, by, bx + 3, by);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Visor
      ctx.fillStyle = '#fff';
      let visorX = p.facingRight ? 1 : -6;
      ctx.fillRect(visorX, -p.h / 2 + 4, 6, 4);
      ctx.fillStyle = p === player ? '#08f' : '#f80';
      ctx.fillRect(visorX + 1, -p.h / 2 + 5, 4, 2);

      // Portal gun
      ctx.fillStyle = '#777';
      let armDir = p.facingRight ? 1 : -1;
      ctx.fillRect(armDir * 5, 1, armDir * 10, 3);
      ctx.fillStyle = '#aaa';
      ctx.fillRect(armDir * 12, -1, armDir * 5, 5);

      // Legs (simple)
      ctx.fillStyle = p.color;
      let legOffset = Math.sin(Date.now() / 100 + (p === ai ? 1 : 0)) * (Math.abs(p.vx) > 0.5 ? 3 : 0);
      ctx.fillRect(-4, p.h / 2 - 1, 3, 4 + legOffset);
      ctx.fillRect(2, p.h / 2 - 1, 3, 4 - legOffset);

      // Name tag
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 5;
      ctx.font = 'bold 9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(p.name, 0, -p.h / 2 - 6);
      ctx.shadowBlur = 0;

      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, W, H);

      // Background grid (subtle)
      ctx.strokeStyle = '#151525';
      ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += TILE) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y < H; y += TILE) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Tiles
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let t = tiles[r][c];
          let x = c * TILE, y = r * TILE;
          if (t === 1) {
            ctx.fillStyle = '#2a2a3a';
            ctx.fillRect(x, y, TILE, TILE);
            ctx.fillStyle = '#333345';
            ctx.fillRect(x + 1, y + 1, TILE - 2, TILE - 2);
            // Surface detail
            ctx.fillStyle = '#3a3a4a';
            ctx.fillRect(x + 3, y + 3, TILE - 6, 1);
            ctx.fillRect(x + 3, y + TILE - 4, TILE - 6, 1);
          } else if (t === 2) {
            ctx.fillStyle = '#222235';
            ctx.fillRect(x, y, TILE, TILE);
            ctx.strokeStyle = '#3a3a55';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 2, y + 2, TILE - 4, TILE - 4);
            // Portalable indicator dots
            ctx.fillStyle = '#3a3a55';
            ctx.fillRect(x + 5, y + 5, 2, 2);
            ctx.fillRect(x + TILE - 7, y + 5, 2, 2);
            ctx.fillRect(x + 5, y + TILE - 7, 2, 2);
            ctx.fillRect(x + TILE - 7, y + TILE - 7, 2, 2);
          }
        }
      }

      // Doors
      for (let d of doors) {
        let h = d.h * (1 - d.openAmount);
        // Frame
        ctx.strokeStyle = '#887744';
        ctx.lineWidth = 2;
        ctx.strokeRect(d.x - 1, d.y - 1, d.w + 2, d.h + 2);
        // Door body
        if (h > 2) {
          let dGrad = ctx.createLinearGradient(d.x, d.y, d.x + d.w, d.y);
          dGrad.addColorStop(0, '#554422');
          dGrad.addColorStop(0.5, '#776633');
          dGrad.addColorStop(1, '#554422');
          ctx.fillStyle = dGrad;
          ctx.fillRect(d.x, d.y, d.w, h);
          // Hazard stripes
          ctx.fillStyle = '#443311';
          for (let s = 0; s < h; s += 8) {
            ctx.fillRect(d.x, d.y + s, d.w, 2);
          }
        }
        // Light indicator
        ctx.fillStyle = d.openAmount > 0.5 ? '#4f4' : '#f44';
        ctx.shadowColor = d.openAmount > 0.5 ? '#4f4' : '#f44';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(d.x + d.w / 2, d.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Buttons
      for (let btn of buttons) {
        // Base plate
        ctx.fillStyle = '#444';
        ctx.fillRect(btn.x - 3, btn.y + btn.h - 3, btn.w + 6, 5);
        // Button
        let bh = btn.pressed ? 2 : btn.h;
        let bColor = btn.pressed ? '#4f4' : '#e44';
        ctx.fillStyle = bColor;
        ctx.shadowColor = bColor;
        ctx.shadowBlur = 8;
        ctx.fillRect(btn.x, btn.y + btn.h - bh, btn.w, bh);
        ctx.shadowBlur = 0;
      }

      // Exits
      for (let ex of exits) {
        let pulse = Math.sin(Date.now() / 250) * 0.3 + 0.7;
        // Glow
        let eGrad = ctx.createRadialGradient(
          ex.x + ex.w / 2, ex.y + ex.h / 2, 5,
          ex.x + ex.w / 2, ex.y + ex.h / 2, 40
        );
        eGrad.addColorStop(0, `rgba(68, 255, 136, ${pulse * 0.2})`);
        eGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = eGrad;
        ctx.fillRect(ex.x - 20, ex.y - 20, ex.w + 40, ex.h + 40);
        // Door shape
        ctx.fillStyle = `rgba(68, 255, 136, ${pulse * 0.15})`;
        ctx.fillRect(ex.x, ex.y, ex.w, ex.h);
        ctx.strokeStyle = `rgba(68, 255, 136, ${pulse})`;
        ctx.shadowColor = '#4f8';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 2;
        ctx.strokeRect(ex.x, ex.y, ex.w, ex.h);
        ctx.shadowBlur = 0;
        // Chevrons
        ctx.strokeStyle = `rgba(68, 255, 136, ${pulse * 0.6})`;
        ctx.lineWidth = 2;
        let cx = ex.x + ex.w / 2, cy = ex.y + ex.h / 2;
        for (let i = -1; i <= 1; i++) {
          ctx.beginPath();
          ctx.moveTo(cx - 6, cy + i * 10 + 3);
          ctx.lineTo(cx, cy + i * 10 - 3);
          ctx.lineTo(cx + 6, cy + i * 10 + 3);
          ctx.stroke();
        }
        // Label
        ctx.fillStyle = '#4f8';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('EXIT', cx, ex.y - 4);
      }

      // Cubes
      for (let cube of cubes) {
        let cx = cube.x - cube.w / 2, cy = cube.y - cube.h / 2;
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(cx + 2, cy + cube.h, cube.w, 3);
        // Body
        let cGrad = ctx.createLinearGradient(cx, cy, cx + cube.w, cy + cube.h);
        cGrad.addColorStop(0, '#777');
        cGrad.addColorStop(1, '#555');
        ctx.fillStyle = cGrad;
        ctx.fillRect(cx, cy, cube.w, cube.h);
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.strokeRect(cx, cy, cube.w, cube.h);
        // Heart (Companion Cube reference)
        ctx.fillStyle = '#f8a';
        ctx.shadowColor = '#f8a';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        let hx = cube.x, hy = cube.y - 1;
        ctx.moveTo(hx, hy + 3);
        ctx.bezierCurveTo(hx, hy, hx - 5, hy, hx - 5, hy + 3);
        ctx.bezierCurveTo(hx - 5, hy + 6, hx, hy + 8, hx, hy + 9);
        ctx.bezierCurveTo(hx, hy + 8, hx + 5, hy + 6, hx + 5, hy + 3);
        ctx.bezierCurveTo(hx + 5, hy, hx, hy, hx, hy + 3);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Portals
      drawPortalOval(player.portalBlue);
      drawPortalOval(player.portalOrange);
      drawPortalOval(ai.portalBlue);
      drawPortalOval(ai.portalOrange);

      // Portal connection lines
      ctx.setLineDash([3, 5]);
      ctx.lineWidth = 1;
      for (let p of [player, ai]) {
        if (p.portalBlue && p.portalOrange) {
          ctx.strokeStyle = p === player ? 'rgba(68,170,255,0.12)' : 'rgba(255,136,68,0.12)';
          ctx.beginPath();
          ctx.moveTo(p.portalBlue.x, p.portalBlue.y);
          ctx.lineTo(p.portalOrange.x, p.portalOrange.y);
          ctx.stroke();
        }
      }
      ctx.setLineDash([]);

      // Portal projectiles
      for (let p of portalProjectiles) {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
        // Core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Particles
      for (let p of particles) {
        let alpha = Math.min(1, p.life / 15);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        let size = 1.5 + (p.life / 20) * 1.5;
        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
      }
      ctx.globalAlpha = 1;

      // Players
      drawPlayer(player);
      drawPlayer(ai);

      // HUD
      ctx.shadowBlur = 0;
      // Portal status
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      // Player portals
      ctx.fillStyle = '#4af';
      ctx.fillText('P1:', 8, H - 8);
      ctx.fillStyle = player.portalBlue ? '#4af' : '#333';
      ctx.fillText('B', 32, H - 8);
      ctx.fillStyle = player.portalOrange ? '#f84' : '#333';
      ctx.fillText('O', 44, H - 8);
      // AI portals
      ctx.fillStyle = '#fa4';
      ctx.fillText('AI:', 65, H - 8);
      ctx.fillStyle = ai.portalBlue ? '#4af' : '#333';
      ctx.fillText('B', 90, H - 8);
      ctx.fillStyle = ai.portalOrange ? '#f84' : '#333';
      ctx.fillText('O', 102, H - 8);

      // Room hint on first room
      if (currentRoom === 0 && elapsed < 8 && gameState === 'playing') {
        let alpha = Math.max(0, 1 - elapsed / 8);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#4af';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Place portals on lighter walls to cross the gap!', W / 2, 30);
        ctx.globalAlpha = 1;
      }

      // Room complete flash
      if (currentRoom > 0 && gameState === 'playing') {
        let timeSinceStart = (Date.now() - roomStartTime) / 1000;
        if (timeSinceStart < 1.5) {
          let alpha = Math.max(0, 1 - timeSinceStart / 1.5);
          ctx.globalAlpha = alpha * 0.6;
          ctx.fillStyle = '#4f8';
          ctx.font = 'bold 20px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('ROOM ' + (currentRoom + 1), W / 2, H / 2);
          ctx.globalAlpha = 1;
        }
      }
    }

    function showOverlay(title, text) {
      overlay.style.display = 'flex';
      overlayTitle.textContent = title;
      overlayText.textContent = text;
    }

    function hideOverlay() {
      overlay.style.display = 'none';
    }

    function startGame() {
      gameState = 'playing';
      score = 0;
      currentRoom = 0;
      totalTime = 0;
      elapsed = 0;
      scoreEl.textContent = '0';
      roomEl.textContent = '1';
      aiThinkTimer = 0;
      aiPortalTimer = 0;
      buildRoom(0);
      roomStartTime = Date.now();
      hideOverlay();
    }

    canvas.parentElement.addEventListener('click', () => {
      if (gameState === 'menu' || gameState === 'win' || gameState === 'gameover') {
        startGame();
      }
    });

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    buildRoom(0);
    showOverlay('PORTAL 2D CO-OP', 'Arrows = Move/Jump | Z = Blue Portal | X = Orange Portal');
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Duel</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #c8a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 136, 170, 0.5); }
    h1 { color: #c8a; font-size: 2rem; text-shadow: 0 0 15px rgba(204, 136, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #c8a; }
    canvas {
      border: 2px solid #c8a;
      box-shadow: 0 0 20px rgba(204, 136, 170, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c8a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SPACE DUEL</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Player: <span id="playerLives">3</span> | AI: <span id="aiLives">3</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">SPACE DUEL</h2>
      <p id="overlayText">Press SPACE to start<br>LEFT/RIGHT: rotate | UP: thrust | SPACE: fire</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const CX = W / 2, CY = H / 2;
    const scoreEl = document.getElementById('score');
    const playerLivesEl = document.getElementById('playerLives');
    const aiLivesEl = document.getElementById('aiLives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Physics constants
    const GRAVITY = 800;          // gravity strength
    const STAR_RADIUS = 18;       // central star kill radius
    const STAR_GLOW = 40;         // visual glow radius
    const TURN_SPEED = 3.5;       // radians per second
    const THRUST = 200;           // acceleration pixels/s^2
    const MAX_SPEED = 250;
    const FRICTION = 0.998;
    const BULLET_SPEED = 350;
    const BULLET_LIFE = 2.5;      // seconds
    const FIRE_COOLDOWN = 0.3;    // seconds between shots
    const SHIP_SIZE = 12;
    const RESPAWN_TIME = 1.5;     // seconds of invincibility
    const TRAIL_LENGTH = 20;
    const MAX_LIVES = 3;
    const ORBIT_RADIUS = 160;     // starting orbit distance

    // Stars background
    const bgStars = [];
    for (let i = 0; i < 120; i++) {
      bgStars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        size: Math.random() * 1.5 + 0.5,
        brightness: Math.random() * 0.5 + 0.3
      });
    }

    let score, best = 0, gameState;
    let player, ai, bullets, particles;
    let roundNum;
    let keys = {};
    let lastTime;

    function createShip(x, y, angle, color, trailColor) {
      return {
        x, y,
        vx: 0, vy: 0,
        angle,
        color,
        trailColor,
        lives: MAX_LIVES,
        fireCooldown: 0,
        invincible: RESPAWN_TIME,
        trail: [],
        alive: true,
        thrusting: false
      };
    }

    function setOrbitalVelocity(ship) {
      // Set velocity for circular orbit around center
      const dx = ship.x - CX;
      const dy = ship.y - CY;
      const dist = Math.hypot(dx, dy);
      const orbitalSpeed = Math.sqrt(GRAVITY / dist) * 0.7;
      // Perpendicular to radial direction (counter-clockwise for player, clockwise for AI)
      const nx = dx / dist;
      const ny = dy / dist;
      if (ship === player) {
        ship.vx = -ny * orbitalSpeed;
        ship.vy = nx * orbitalSpeed;
      } else {
        ship.vx = ny * orbitalSpeed;
        ship.vy = -nx * orbitalSpeed;
      }
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      roundNum = 0;

      player = createShip(CX - ORBIT_RADIUS, CY, 0, '#4cf', 'rgba(68, 204, 255, 0.3)');
      ai = createShip(CX + ORBIT_RADIUS, CY, Math.PI, '#f64', 'rgba(255, 102, 68, 0.3)');
      setOrbitalVelocity(player);
      setOrbitalVelocity(ai);

      bullets = [];
      particles = [];

      playerLivesEl.textContent = player.lives;
      aiLivesEl.textContent = ai.lives;

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SPACE DUEL';
      overlayText.innerHTML = 'Press SPACE to start<br>LEFT/RIGHT: rotate | UP: thrust | SPACE: fire';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05); // cap at 50ms
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Gravity ----
    function applyGravity(obj, dt) {
      const dx = CX - obj.x;
      const dy = CY - obj.y;
      const distSq = dx * dx + dy * dy;
      const dist = Math.sqrt(distSq);
      if (dist < 1) return;
      const force = GRAVITY / distSq;
      obj.vx += (dx / dist) * force * dt;
      obj.vy += (dy / dist) * force * dt;
    }

    // ---- Wrap ----
    function wrap(obj) {
      if (obj.x < 0) obj.x += W;
      if (obj.x > W) obj.x -= W;
      if (obj.y < 0) obj.y += H;
      if (obj.y > H) obj.y -= H;
    }

    // ---- Particles ----
    function spawnParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 120 + 40;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.5 + Math.random() * 0.5,
          maxLife: 1,
          color
        });
      }
    }

    // ---- Fire bullet ----
    function fireBullet(ship) {
      if (ship.fireCooldown > 0 || !ship.alive) return;
      const bx = ship.x + Math.cos(ship.angle) * SHIP_SIZE * 1.2;
      const by = ship.y + Math.sin(ship.angle) * SHIP_SIZE * 1.2;
      bullets.push({
        x: bx, y: by,
        vx: Math.cos(ship.angle) * BULLET_SPEED + ship.vx * 0.3,
        vy: Math.sin(ship.angle) * BULLET_SPEED + ship.vy * 0.3,
        life: BULLET_LIFE,
        owner: ship,
        color: ship.color
      });
      ship.fireCooldown = FIRE_COOLDOWN;
    }

    // ---- AI behavior ----
    function updateAI(dt) {
      if (!ai.alive) return;

      const dx = player.x - ai.x;
      const dy = player.y - ai.y;
      const distToPlayer = Math.hypot(dx, dy);
      const angleToPlayer = Math.atan2(dy, dx);

      // Angle to center (for gravity awareness)
      const dxc = CX - ai.x;
      const dyc = CY - ai.y;
      const distToCenter = Math.hypot(dxc, dyc);

      // Determine target angle: aim at player with some lead
      let targetAngle = angleToPlayer;

      // If too close to the star, prioritize escaping
      if (distToCenter < STAR_RADIUS * 4) {
        // Point away from center
        targetAngle = Math.atan2(-dyc, -dxc);
        ai.thrusting = true;
      } else if (distToPlayer < 80) {
        // Too close to player, flee sideways
        targetAngle = angleToPlayer + Math.PI * 0.6;
        ai.thrusting = true;
      } else {
        // Lead the target slightly
        if (player.alive) {
          const leadTime = distToPlayer / BULLET_SPEED * 0.5;
          const predictX = player.x + player.vx * leadTime;
          const predictY = player.y + player.vy * leadTime;
          targetAngle = Math.atan2(predictY - ai.y, predictX - ai.x);
        }

        // Thrust to maintain orbit distance
        const desiredDist = ORBIT_RADIUS * 1.2;
        ai.thrusting = distToCenter > desiredDist + 30 || distToCenter < desiredDist - 30;
      }

      // Turn toward target angle
      let angleDiff = targetAngle - ai.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

      if (angleDiff > 0.05) ai.angle += TURN_SPEED * dt;
      else if (angleDiff < -0.05) ai.angle -= TURN_SPEED * dt;

      // Thrust
      if (ai.thrusting) {
        ai.vx += Math.cos(ai.angle) * THRUST * dt;
        ai.vy += Math.sin(ai.angle) * THRUST * dt;
      }

      // Fire at player if roughly aimed
      if (player.alive && Math.abs(angleDiff) < 0.3 && distToPlayer < 350) {
        fireBullet(ai);
      }
    }

    // ---- Ship collision with star ----
    function checkStarCollision(ship) {
      const dist = Math.hypot(ship.x - CX, ship.y - CY);
      if (dist < STAR_RADIUS + SHIP_SIZE * 0.5) {
        killShip(ship);
      }
    }

    // ---- Kill ship ----
    function killShip(ship) {
      if (!ship.alive || ship.invincible > 0) return;
      ship.alive = false;
      ship.lives--;
      spawnParticles(ship.x, ship.y, 20, ship.color);

      if (ship === player) {
        playerLivesEl.textContent = ship.lives;
      } else {
        aiLivesEl.textContent = ship.lives;
        score += 100;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
        }
      }

      // Check for game over
      if (player.lives <= 0) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
        return;
      }

      if (ai.lives <= 0) {
        // Player wins the round -- start new round
        roundNum++;
        score += 500;
        scoreEl.textContent = score;
        if (score > best) best = score;
        // Reset AI with full lives
        ai.lives = MAX_LIVES;
        aiLivesEl.textContent = ai.lives;
      }

      // Respawn dead ship
      respawnShip(ship);
    }

    function respawnShip(ship) {
      // Place on opposite side of center from the other ship
      const other = ship === player ? ai : player;
      const angle = Math.atan2(other.y - CY, other.x - CX) + Math.PI;
      ship.x = CX + Math.cos(angle) * ORBIT_RADIUS;
      ship.y = CY + Math.sin(angle) * ORBIT_RADIUS;
      ship.angle = Math.atan2(CY - ship.y, CX - ship.x) + Math.PI / 2;
      ship.vx = 0;
      ship.vy = 0;
      setOrbitalVelocity(ship);
      ship.alive = true;
      ship.invincible = RESPAWN_TIME;
      ship.trail = [];
    }

    // ---- Update ----
    function update(dt) {
      // Player input
      if (keys['ArrowLeft']) player.angle -= TURN_SPEED * dt;
      if (keys['ArrowRight']) player.angle += TURN_SPEED * dt;
      player.thrusting = !!keys['ArrowUp'];

      if (player.thrusting && player.alive) {
        player.vx += Math.cos(player.angle) * THRUST * dt;
        player.vy += Math.sin(player.angle) * THRUST * dt;
      }

      if (keys[' '] && player.alive) {
        fireBullet(player);
      }

      // AI
      updateAI(dt);

      // Gravity and movement for both ships
      [player, ai].forEach(ship => {
        if (!ship.alive) return;

        applyGravity(ship, dt);

        // Clamp speed
        const speed = Math.hypot(ship.vx, ship.vy);
        if (speed > MAX_SPEED) {
          ship.vx = (ship.vx / speed) * MAX_SPEED;
          ship.vy = (ship.vy / speed) * MAX_SPEED;
        }

        // Friction
        ship.vx *= Math.pow(FRICTION, dt * 60);
        ship.vy *= Math.pow(FRICTION, dt * 60);

        ship.x += ship.vx * dt;
        ship.y += ship.vy * dt;
        wrap(ship);

        // Trail
        ship.trail.push({ x: ship.x, y: ship.y });
        if (ship.trail.length > TRAIL_LENGTH) ship.trail.shift();

        // Cooldowns
        if (ship.fireCooldown > 0) ship.fireCooldown -= dt;
        if (ship.invincible > 0) ship.invincible -= dt;

        // Star collision
        checkStarCollision(ship);
      });

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        applyGravity(b, dt);
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        wrap(b);
        b.life -= dt;

        // Star collision
        const distToStar = Math.hypot(b.x - CX, b.y - CY);
        if (distToStar < STAR_RADIUS) {
          spawnParticles(b.x, b.y, 3, b.color);
          bullets.splice(i, 1);
          continue;
        }

        if (b.life <= 0) {
          bullets.splice(i, 1);
          continue;
        }

        // Hit detection against ships
        [player, ai].forEach(ship => {
          if (b.owner === ship || !ship.alive || ship.invincible > 0) return;
          const dist = Math.hypot(b.x - ship.x, b.y - ship.y);
          if (dist < SHIP_SIZE) {
            killShip(ship);
            const idx = bullets.indexOf(b);
            if (idx >= 0) bullets.splice(idx, 1);
          }
        });
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x, playerY: player.y,
        playerAngle: player.angle, playerAlive: player.alive,
        aiX: ai.x, aiY: ai.y,
        aiAngle: ai.angle, aiAlive: ai.alive,
        bulletCount: bullets.length,
        playerLives: player.lives, aiLives: ai.lives
      };
    }

    // ---- Draw ----
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Background stars
      for (const s of bgStars) {
        ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness})`;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      // Central star glow
      const gradient = ctx.createRadialGradient(CX, CY, STAR_RADIUS * 0.3, CX, CY, STAR_GLOW);
      gradient.addColorStop(0, 'rgba(255, 220, 100, 0.9)');
      gradient.addColorStop(0.3, 'rgba(255, 180, 50, 0.6)');
      gradient.addColorStop(0.7, 'rgba(255, 100, 30, 0.2)');
      gradient.addColorStop(1, 'rgba(255, 50, 10, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(CX, CY, STAR_GLOW, 0, Math.PI * 2);
      ctx.fill();

      // Central star core
      ctx.fillStyle = '#ffd060';
      ctx.shadowColor = '#ff8020';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(CX, CY, STAR_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Particles
      for (const p of particles) {
        const alpha = Math.max(0, p.life / p.maxLife);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
      }
      ctx.globalAlpha = 1;

      // Ship trails
      [player, ai].forEach(ship => {
        if (ship.trail.length < 2) return;
        for (let i = 1; i < ship.trail.length; i++) {
          const alpha = (i / ship.trail.length) * 0.5;
          ctx.strokeStyle = ship.trailColor.replace(/[\d.]+\)$/, alpha + ')');
          ctx.lineWidth = 2;
          ctx.beginPath();
          // Only draw segment if points aren't too far apart (avoid wrap lines)
          const dx = ship.trail[i].x - ship.trail[i - 1].x;
          const dy = ship.trail[i].y - ship.trail[i - 1].y;
          if (Math.abs(dx) < W * 0.5 && Math.abs(dy) < H * 0.5) {
            ctx.moveTo(ship.trail[i - 1].x, ship.trail[i - 1].y);
            ctx.lineTo(ship.trail[i].x, ship.trail[i].y);
            ctx.stroke();
          }
        }
      });

      // Ships
      [player, ai].forEach(ship => {
        if (!ship.alive) return;
        // Blink when invincible
        if (ship.invincible > 0 && Math.floor(ship.invincible * 8) % 2 === 0) return;

        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);

        ctx.strokeStyle = ship.color;
        ctx.shadowColor = ship.color;
        ctx.shadowBlur = 12;
        ctx.lineWidth = 2;

        // Ship body (triangle)
        ctx.beginPath();
        ctx.moveTo(SHIP_SIZE, 0);
        ctx.lineTo(-SHIP_SIZE * 0.7, -SHIP_SIZE * 0.65);
        ctx.lineTo(-SHIP_SIZE * 0.3, 0);
        ctx.lineTo(-SHIP_SIZE * 0.7, SHIP_SIZE * 0.65);
        ctx.closePath();
        ctx.stroke();

        // Thrust flame
        if (ship.thrusting) {
          ctx.strokeStyle = '#fa0';
          ctx.shadowColor = '#fa0';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(-SHIP_SIZE * 0.45, -SHIP_SIZE * 0.25);
          ctx.lineTo(-SHIP_SIZE * (0.8 + Math.random() * 0.5), 0);
          ctx.lineTo(-SHIP_SIZE * 0.45, SHIP_SIZE * 0.25);
          ctx.stroke();
        }

        ctx.restore();
      });
      ctx.shadowBlur = 0;

      // Bullets
      for (const b of bullets) {
        ctx.fillStyle = b.color;
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Lives indicators on canvas
      // Player lives (bottom-left)
      for (let i = 0; i < player.lives; i++) {
        ctx.save();
        ctx.translate(20 + i * 22, H - 18);
        ctx.rotate(-Math.PI / 2);
        ctx.strokeStyle = player.color;
        ctx.shadowColor = player.color;
        ctx.shadowBlur = 6;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -4);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 4);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }

      // AI lives (bottom-right)
      for (let i = 0; i < ai.lives; i++) {
        ctx.save();
        ctx.translate(W - 20 - i * 22, H - 18);
        ctx.rotate(-Math.PI / 2);
        ctx.strokeStyle = ai.color;
        ctx.shadowColor = ai.color;
        ctx.shadowBlur = 6;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -4);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 4);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      ctx.shadowBlur = 0;

      // Round indicator
      if (roundNum > 0) {
        ctx.fillStyle = '#c8a';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('ROUND ' + (roundNum + 1), CX, H - 10);
      }
    }

    // ---- Input ----
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Warlords</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #a4e; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 68, 238, 0.5); }
    h1 { color: #a4e; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 68, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a4e; }
    canvas {
      border: 2px solid #a4e;
      box-shadow: 0 0 20px rgba(170, 68, 238, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a4e;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WARLORDS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">WARLORDS</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Castle configuration
    // Each castle sits in a corner with walls along two edges
    // Corner layout:
    //   0 = top-left,  1 = top-right
    //   2 = bottom-left (PLAYER), 3 = bottom-right

    const BRICK_W = 12;
    const BRICK_H = 12;
    const WALL_LAYERS = 3;   // layers of bricks deep
    const WALL_LENGTH = 8;   // bricks along each arm
    const SHIELD_LEN = 40;
    const SHIELD_THICK = 6;
    const BALL_R = 5;
    const BALL_SPEED_BASE = 3.5;
    const CORNER_INSET = 10; // offset from canvas edge

    const CASTLE_COLORS = ['#f44', '#ff0', '#a4e', '#0f0']; // TL=red, TR=yellow, BL=purple(player), BR=green
    const SHIELD_COLORS = ['#f88', '#ff8', '#c8f', '#8f8'];

    let castles, fireballs, eliminationOrder, frameCount;
    let keys = {};

    function createBricks(corner) {
      const bricks = [];

      switch (corner) {
        case 0: { // top-left: horizontal arm along top, vertical arm along left
          for (let layer = 0; layer < WALL_LAYERS; layer++) {
            for (let i = 0; i < WALL_LENGTH; i++) {
              // Horizontal arm (along top edge)
              bricks.push({
                x: CORNER_INSET + i * BRICK_W,
                y: CORNER_INSET + layer * BRICK_H,
                alive: true
              });
            }
            for (let i = 1; i < WALL_LENGTH; i++) {
              // Vertical arm (along left edge)
              bricks.push({
                x: CORNER_INSET + layer * BRICK_W,
                y: CORNER_INSET + i * BRICK_H,
                alive: true
              });
            }
          }
          break;
        }
        case 1: { // top-right: horizontal arm along top, vertical arm along right
          for (let layer = 0; layer < WALL_LAYERS; layer++) {
            for (let i = 0; i < WALL_LENGTH; i++) {
              bricks.push({
                x: W - CORNER_INSET - (i + 1) * BRICK_W,
                y: CORNER_INSET + layer * BRICK_H,
                alive: true
              });
            }
            for (let i = 1; i < WALL_LENGTH; i++) {
              bricks.push({
                x: W - CORNER_INSET - (layer + 1) * BRICK_W,
                y: CORNER_INSET + i * BRICK_H,
                alive: true
              });
            }
          }
          break;
        }
        case 2: { // bottom-left: horizontal arm along bottom, vertical arm along left
          for (let layer = 0; layer < WALL_LAYERS; layer++) {
            for (let i = 0; i < WALL_LENGTH; i++) {
              bricks.push({
                x: CORNER_INSET + i * BRICK_W,
                y: H - CORNER_INSET - (layer + 1) * BRICK_H,
                alive: true
              });
            }
            for (let i = 1; i < WALL_LENGTH; i++) {
              bricks.push({
                x: CORNER_INSET + layer * BRICK_W,
                y: H - CORNER_INSET - (i + 1) * BRICK_H,
                alive: true
              });
            }
          }
          break;
        }
        case 3: { // bottom-right: horizontal arm along bottom, vertical arm along right
          for (let layer = 0; layer < WALL_LAYERS; layer++) {
            for (let i = 0; i < WALL_LENGTH; i++) {
              bricks.push({
                x: W - CORNER_INSET - (i + 1) * BRICK_W,
                y: H - CORNER_INSET - (layer + 1) * BRICK_H,
                alive: true
              });
            }
            for (let i = 1; i < WALL_LENGTH; i++) {
              bricks.push({
                x: W - CORNER_INSET - (layer + 1) * BRICK_W,
                y: H - CORNER_INSET - (i + 1) * BRICK_H,
                alive: true
              });
            }
          }
          break;
        }
      }
      return bricks;
    }

    // Shield position: 0..1 maps along the L-shaped perimeter of a castle
    // 0 = start of horizontal arm, 0.5 = corner, 1 = end of vertical arm
    function getShieldPos(corner, t) {
      const armLen = WALL_LENGTH * BRICK_W;
      const totalPerimeter = armLen * 2;
      const dist = t * totalPerimeter;
      let sx, sy, angle;

      // Offset: how far from the wall the shield floats
      const offset = WALL_LAYERS * BRICK_H + 4;

      switch (corner) {
        case 0: { // top-left
          if (dist <= armLen) {
            // Along horizontal arm (top)
            sx = CORNER_INSET + dist;
            sy = CORNER_INSET + offset;
            angle = 0; // horizontal
          } else {
            // Along vertical arm (left)
            sx = CORNER_INSET + offset;
            sy = CORNER_INSET + (dist - armLen);
            angle = Math.PI / 2; // vertical
          }
          break;
        }
        case 1: { // top-right
          if (dist <= armLen) {
            sx = W - CORNER_INSET - dist;
            sy = CORNER_INSET + offset;
            angle = 0;
          } else {
            sx = W - CORNER_INSET - offset;
            sy = CORNER_INSET + (dist - armLen);
            angle = Math.PI / 2;
          }
          break;
        }
        case 2: { // bottom-left (player)
          if (dist <= armLen) {
            sx = CORNER_INSET + dist;
            sy = H - CORNER_INSET - offset;
            angle = 0;
          } else {
            sx = CORNER_INSET + offset;
            sy = H - CORNER_INSET - (dist - armLen);
            angle = Math.PI / 2;
          }
          break;
        }
        case 3: { // bottom-right
          if (dist <= armLen) {
            sx = W - CORNER_INSET - dist;
            sy = H - CORNER_INSET - offset;
            angle = 0;
          } else {
            sx = W - CORNER_INSET - offset;
            sy = H - CORNER_INSET - (dist - armLen);
            angle = Math.PI / 2;
          }
          break;
        }
      }
      return { x: sx, y: sy, angle };
    }

    function getShieldRect(corner, t) {
      const pos = getShieldPos(corner, t);
      if (pos.angle === 0) {
        // Horizontal shield
        return {
          x: pos.x - SHIELD_LEN / 2,
          y: pos.y - SHIELD_THICK / 2,
          w: SHIELD_LEN,
          h: SHIELD_THICK
        };
      } else {
        // Vertical shield
        return {
          x: pos.x - SHIELD_THICK / 2,
          y: pos.y - SHIELD_LEN / 2,
          w: SHIELD_THICK,
          h: SHIELD_LEN
        };
      }
    }

    function createFireball() {
      // Spawn from center area with random direction
      const angle = Math.random() * Math.PI * 2;
      const speed = BALL_SPEED_BASE + Math.min(frameCount / 3600, 2);
      return {
        x: W / 2 + (Math.random() - 0.5) * 60,
        y: H / 2 + (Math.random() - 0.5) * 60,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        speed: speed
      };
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      frameCount = 0;
      eliminationOrder = [];
      keys = {};

      castles = [];
      for (let i = 0; i < 4; i++) {
        castles.push({
          corner: i,
          alive: true,
          bricks: createBricks(i),
          shieldPos: 0.25, // start at the corner
          color: CASTLE_COLORS[i],
          shieldColor: SHIELD_COLORS[i]
        });
      }

      fireballs = [createFireball()];

      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'WARLORDS';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function reflectBallOffRect(ball, rect) {
      // Determine which side was hit
      const cx = ball.x, cy = ball.y;
      const rx = rect.x, ry = rect.y, rw = rect.w, rh = rect.h;

      const overlapLeft = (cx + BALL_R) - rx;
      const overlapRight = (rx + rw) - (cx - BALL_R);
      const overlapTop = (cy + BALL_R) - ry;
      const overlapBottom = (ry + rh) - (cy - BALL_R);

      const minX = Math.min(overlapLeft, overlapRight);
      const minY = Math.min(overlapTop, overlapBottom);

      if (minX < minY) {
        ball.vx = -ball.vx;
      } else {
        ball.vy = -ball.vy;
      }

      // Add slight randomness to prevent infinite loops
      ball.vx += (Math.random() - 0.5) * 0.3;
      ball.vy += (Math.random() - 0.5) * 0.3;

      // Normalize speed
      const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      ball.vx = (ball.vx / currentSpeed) * ball.speed;
      ball.vy = (ball.vy / currentSpeed) * ball.speed;
    }

    function ballHitsRect(ball, rx, ry, rw, rh) {
      return ball.x + BALL_R > rx && ball.x - BALL_R < rx + rw &&
             ball.y + BALL_R > ry && ball.y - BALL_R < ry + rh;
    }

    function updateAI(castle) {
      if (!castle.alive) return;

      // Find the nearest fireball and move shield toward it
      let nearestBall = null;
      let nearestDist = Infinity;

      for (const ball of fireballs) {
        const dx = ball.x - getCastleCenter(castle.corner).x;
        const dy = ball.y - getCastleCenter(castle.corner).y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestBall = ball;
        }
      }

      if (!nearestBall) return;

      // Find the shield t value that would best intercept the ball
      let bestT = castle.shieldPos;
      let bestDist = Infinity;

      // Sample positions along the perimeter to find where the ball is closest
      for (let sample = 0; sample <= 20; sample++) {
        const t = sample / 20;
        const pos = getShieldPos(castle.corner, t);
        const dx = nearestBall.x - pos.x;
        const dy = nearestBall.y - pos.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < bestDist) {
          bestDist = d;
          bestT = t;
        }
      }

      // Move toward the best position with some reaction speed
      const aiSpeed = 0.012 + Math.random() * 0.005;
      const diff = bestT - castle.shieldPos;
      if (Math.abs(diff) > aiSpeed) {
        castle.shieldPos += Math.sign(diff) * aiSpeed;
      } else {
        castle.shieldPos = bestT;
      }
      castle.shieldPos = Math.max(0.05, Math.min(0.95, castle.shieldPos));
    }

    function getCastleCenter(corner) {
      switch (corner) {
        case 0: return { x: CORNER_INSET, y: CORNER_INSET };
        case 1: return { x: W - CORNER_INSET, y: CORNER_INSET };
        case 2: return { x: CORNER_INSET, y: H - CORNER_INSET };
        case 3: return { x: W - CORNER_INSET, y: H - CORNER_INSET };
      }
    }

    function update() {
      frameCount++;

      // Player shield movement (castle index 2 = bottom-left)
      const playerCastle = castles[2];
      if (playerCastle.alive) {
        const shieldSpeed = 0.018;
        if (keys['ArrowLeft'] || keys['ArrowUp']) {
          playerCastle.shieldPos -= shieldSpeed;
        }
        if (keys['ArrowRight'] || keys['ArrowDown']) {
          playerCastle.shieldPos += shieldSpeed;
        }
        playerCastle.shieldPos = Math.max(0.05, Math.min(0.95, playerCastle.shieldPos));
      }

      // AI shields
      for (let i = 0; i < 4; i++) {
        if (i === 2) continue; // skip player
        updateAI(castles[i]);
      }

      // Spawn additional fireballs over time (based on frame count, not resettable timer)
      if (frameCount > 600 && fireballs.length < 2) {
        fireballs.push(createFireball());
      }
      if (frameCount > 1500 && fireballs.length < 3) {
        fireballs.push(createFireball());
      }

      // Update fireballs
      for (let fi = fireballs.length - 1; fi >= 0; fi--) {
        const ball = fireballs[fi];

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Gradually increase speed
        ball.speed = BALL_SPEED_BASE + Math.min(frameCount / 1800, 3);
        const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (Math.abs(currentSpeed - ball.speed) > 0.5) {
          ball.vx = (ball.vx / currentSpeed) * ball.speed;
          ball.vy = (ball.vy / currentSpeed) * ball.speed;
        }

        // Wall bounces
        if (ball.x - BALL_R <= 0) { ball.x = BALL_R; ball.vx = Math.abs(ball.vx); }
        if (ball.x + BALL_R >= W) { ball.x = W - BALL_R; ball.vx = -Math.abs(ball.vx); }
        if (ball.y - BALL_R <= 0) { ball.y = BALL_R; ball.vy = Math.abs(ball.vy); }
        if (ball.y + BALL_R >= H) { ball.y = H - BALL_R; ball.vy = -Math.abs(ball.vy); }

        // Shield collisions
        for (const castle of castles) {
          if (!castle.alive) continue;
          const sr = getShieldRect(castle.corner, castle.shieldPos);
          if (ballHitsRect(ball, sr.x, sr.y, sr.w, sr.h)) {
            reflectBallOffRect(ball, sr);
            // Push ball out of shield
            ball.x += ball.vx * 2;
            ball.y += ball.vy * 2;
          }
        }

        // Brick collisions
        for (const castle of castles) {
          if (!castle.alive) continue;
          for (const brick of castle.bricks) {
            if (!brick.alive) continue;
            if (ballHitsRect(ball, brick.x, brick.y, BRICK_W, BRICK_H)) {
              brick.alive = false;
              reflectBallOffRect(ball, { x: brick.x, y: brick.y, w: BRICK_W, h: BRICK_H });
              break;
            }
          }

          // Check if castle is destroyed
          const aliveCount = castle.bricks.filter(b => b.alive).length;
          if (aliveCount === 0 && castle.alive) {
            castle.alive = false;
            eliminationOrder.push(castle.corner);
            // Player scores for each AI eliminated
            if (castle.corner !== 2) {
              score += 100;
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }
            }
          }
        }
      }

      // Check game end conditions
      const aliveCastles = castles.filter(c => c.alive);

      // Player eliminated
      if (!castles[2].alive) {
        gameOver();
        return;
      }

      // Player is last one standing - victory!
      if (aliveCastles.length === 1 && aliveCastles[0].corner === 2) {
        score += 200; // bonus for winning
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = `Score: ${score} -- Press any key to restart`;
        return;
      }
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw center lines (subtle grid)
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(W / 2, 0);
      ctx.lineTo(W / 2, H);
      ctx.moveTo(0, H / 2);
      ctx.lineTo(W, H / 2);
      ctx.stroke();

      // Draw diagonal lines from corners (arena feel)
      ctx.strokeStyle = '#0f1a2e';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(W, H);
      ctx.moveTo(W, 0);
      ctx.lineTo(0, H);
      ctx.stroke();

      // Draw castles
      for (const castle of castles) {
        // Bricks
        for (const brick of castle.bricks) {
          if (!brick.alive) continue;
          ctx.fillStyle = castle.color;
          ctx.shadowColor = castle.color;
          ctx.shadowBlur = 4;
          ctx.fillRect(brick.x + 1, brick.y + 1, BRICK_W - 2, BRICK_H - 2);
        }
        ctx.shadowBlur = 0;

        // Shield
        if (castle.alive) {
          const sr = getShieldRect(castle.corner, castle.shieldPos);
          ctx.fillStyle = castle.shieldColor;
          ctx.shadowColor = castle.shieldColor;
          ctx.shadowBlur = 12;
          ctx.fillRect(sr.x, sr.y, sr.w, sr.h);
          ctx.shadowBlur = 0;
        }

        // Draw castle core (inner corner marker)
        if (castle.alive) {
          const center = getCastleCenter(castle.corner);
          ctx.fillStyle = castle.color;
          ctx.shadowColor = castle.color;
          ctx.shadowBlur = 8;
          ctx.fillRect(center.x - 4, center.y - 4, 8, 8);
          ctx.shadowBlur = 0;
        } else {
          // Dead castle: draw an X
          const center = getCastleCenter(castle.corner);
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(center.x - 8, center.y - 8);
          ctx.lineTo(center.x + 8, center.y + 8);
          ctx.moveTo(center.x + 8, center.y - 8);
          ctx.lineTo(center.x - 8, center.y + 8);
          ctx.stroke();
        }
      }

      // Draw fireballs
      for (const ball of fireballs) {
        // Outer glow
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
        ctx.fill();

        // Inner bright core
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw corner labels
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      for (let i = 0; i < 4; i++) {
        if (!castles[i].alive) continue;
        const center = getCastleCenter(i);
        const label = i === 2 ? 'YOU' : 'AI';
        ctx.fillStyle = castles[i].color;
        const labelOffsetX = (i === 0 || i === 2) ? 30 : -30;
        const labelOffsetY = (i === 0 || i === 1) ? 30 : -20;
        ctx.fillText(label, center.x + labelOffsetX, center.y + labelOffsetY);
      }

      // Status indicators (top center)
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';
      let statusX = W / 2 - 60;
      for (let i = 0; i < 4; i++) {
        const c = castles[i];
        ctx.fillStyle = c.alive ? c.color : '#333';
        const name = i === 2 ? 'P' : `${i + 1}`;
        ctx.fillText(name, statusX + i * 40, H / 2 - 4);
        // Small health bar
        const totalBricks = c.bricks.length;
        const aliveBricks = c.bricks.filter(b => b.alive).length;
        const healthPct = aliveBricks / totalBricks;
        ctx.fillStyle = '#16213e';
        ctx.fillRect(statusX + i * 40 - 15, H / 2 + 2, 30, 4);
        ctx.fillStyle = c.alive ? c.color : '#333';
        ctx.fillRect(statusX + i * 40 - 15, H / 2 + 2, 30 * healthPct, 4);
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

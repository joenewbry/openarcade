<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super Mario</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 512px;
    }
    .back { color: #f42; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 34, 0.5); }
    h1 { color: #f42; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 68, 34, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 512px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f42; }
    canvas {
      border: 2px solid #f42;
      box-shadow: 0 0 20px rgba(255, 68, 34, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f42;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SUPER MARIO</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="levelDisp">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="512" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:512px;height:400px;">
      <h2 id="overlayTitle">SUPER MARIO</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const levelDispEl = document.getElementById('levelDisp');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const TILE = 32;
    const GRAVITY = 0.6;
    const PLAYER_SPEED = 3.5;
    const PLAYER_RUN_SPEED = 5;
    const JUMP_FORCE = -11;
    const JUMP_HOLD_FORCE = -0.4;
    const JUMP_HOLD_FRAMES = 12;
    const MAX_FALL = 10;
    const COIN_SCORE = 100;
    const STOMP_SCORE = 200;
    const BLOCK_COIN_SCORE = 50;
    const FLAG_SCORE = 1000;
    const LEVEL_CLEAR_BONUS = 500;

    // --- Game state ---
    let score, best = 0, gameState;
    let lives, level;
    let player, camera;
    let tiles, coins, enemies, questionBlocks, particles, flagObj;
    let keys = {};
    let jumpHoldTimer;
    let levelWidth;
    let levelComplete;
    let levelCompleteTimer;

    // --- Level Generation ---
    // Tile types: 0=air, 1=ground, 2=brick, 3=question(active), 4=question(used), 5=pipe-left, 6=pipe-right, 7=pipe-top-left, 8=pipe-top-right
    function generateLevel(lvl) {
      const cols = 100 + lvl * 20;
      levelWidth = cols * TILE;
      const rows = Math.ceil(H / TILE); // 13 rows for 400px
      tiles = Array.from({ length: rows }, () => Array(cols).fill(0));
      coins = [];
      enemies = [];
      questionBlocks = [];
      particles = [];

      // Ground: rows 11 and 12 (bottom two rows)
      const groundRow1 = rows - 2; // row 11
      const groundRow2 = rows - 1; // row 12
      for (let c = 0; c < cols; c++) {
        tiles[groundRow1][c] = 1;
        tiles[groundRow2][c] = 1;
      }

      // Add gaps in ground (more with higher levels)
      const numGaps = 2 + lvl;
      for (let g = 0; g < numGaps; g++) {
        const gapStart = 15 + Math.floor(Math.random() * (cols - 30));
        const gapLen = 2 + Math.floor(Math.random() * 2);
        for (let c = gapStart; c < gapStart + gapLen && c < cols; c++) {
          tiles[groundRow1][c] = 0;
          tiles[groundRow2][c] = 0;
        }
      }

      // Platforms (brick and question blocks)
      const numPlatforms = 8 + lvl * 3;
      for (let i = 0; i < numPlatforms; i++) {
        const px = 8 + Math.floor(Math.random() * (cols - 16));
        const py = 4 + Math.floor(Math.random() * 5); // rows 4-8
        const plen = 2 + Math.floor(Math.random() * 5);
        for (let c = px; c < px + plen && c < cols; c++) {
          if (Math.random() < 0.25) {
            tiles[py][c] = 3; // question block
            questionBlocks.push({ col: c, row: py, active: true, animTimer: 0 });
          } else {
            tiles[py][c] = 2; // brick
          }
        }
      }

      // Pipes
      const numPipes = 3 + lvl;
      for (let i = 0; i < numPipes; i++) {
        const px = 12 + Math.floor(Math.random() * (cols - 20));
        const pipeH = 2 + Math.floor(Math.random() * 2);
        const baseRow = groundRow1 - 1;
        // Make sure ground exists under pipe
        if (tiles[groundRow1][px] === 0 || tiles[groundRow1][px + 1] === 0) continue;
        for (let r = baseRow; r > baseRow - pipeH; r--) {
          if (r < 0) continue;
          if (r === baseRow - pipeH + 1) {
            tiles[r][px] = 7;     // pipe top left
            tiles[r][px + 1] = 8; // pipe top right
          } else {
            tiles[r][px] = 5;     // pipe body left
            tiles[r][px + 1] = 6; // pipe body right
          }
        }
      }

      // Coins (floating)
      const numCoins = 10 + lvl * 5;
      for (let i = 0; i < numCoins; i++) {
        const cx = 5 + Math.floor(Math.random() * (cols - 10));
        const cy = 2 + Math.floor(Math.random() * 7);
        // Only place if air
        if (tiles[cy][cx] === 0) {
          coins.push({ x: cx * TILE + TILE / 2, y: cy * TILE + TILE / 2, collected: false, sparkle: Math.random() * Math.PI * 2 });
        }
      }

      // Enemies
      const numEnemies = 4 + lvl * 2;
      for (let i = 0; i < numEnemies; i++) {
        const ex = 10 + Math.floor(Math.random() * (cols - 15));
        // Place on ground
        if (tiles[groundRow1][ex] === 1) {
          enemies.push({
            x: ex * TILE,
            y: (groundRow1 - 1) * TILE,
            w: TILE,
            h: TILE,
            vx: (Math.random() < 0.5 ? -1 : 1) * (1 + lvl * 0.2),
            alive: true,
            type: Math.random() < 0.3 + lvl * 0.05 ? 'shell' : 'goomba',
            squishTimer: 0
          });
        }
      }

      // Flag at end
      flagObj = {
        x: (cols - 5) * TILE,
        y: 2 * TILE,
        height: (groundRow1 - 2) * TILE,
        reached: false
      };
    }

    function initPlayer() {
      player = {
        x: 3 * TILE,
        y: 9 * TILE,
        w: 24,
        h: 30,
        vx: 0,
        vy: 0,
        onGround: false,
        facing: 1, // 1=right, -1=left
        walkFrame: 0,
        walkTimer: 0,
        invincible: 0,
        dead: false
      };
      camera = { x: 0 };
      jumpHoldTimer = 0;
      levelComplete = false;
      levelCompleteTimer = 0;
    }

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelDispEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SUPER MARIO';
      overlayText.textContent = 'Press SPACE to start';
      generateLevel(level);
      initPlayer();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      } else {
        // Respawn
        player.dead = false;
        player.invincible = 90; // 1.5 seconds at 60fps
        initPlayer();
        player.invincible = 90;
      }
    }

    function nextLevel() {
      level++;
      levelDispEl.textContent = level;
      score += LEVEL_CLEAR_BONUS * level;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      generateLevel(level);
      initPlayer();
    }

    // --- Collision helpers ---
    function tileAt(px, py) {
      const col = Math.floor(px / TILE);
      const row = Math.floor(py / TILE);
      const rows = tiles.length;
      const cols = tiles[0].length;
      if (row < 0 || row >= rows || col < 0 || col >= cols) return 0;
      return tiles[row][col];
    }

    function isSolid(t) {
      return t === 1 || t === 2 || t === 3 || t === 4 || t === 5 || t === 6 || t === 7 || t === 8;
    }

    function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // --- Physics & Update ---
    function update() {
      if (player.dead) return;
      if (levelComplete) {
        levelCompleteTimer++;
        // Animate player walking to flag
        player.x += 2;
        player.walkTimer++;
        if (player.walkTimer > 6) { player.walkTimer = 0; player.walkFrame = (player.walkFrame + 1) % 3; }
        if (levelCompleteTimer > 90) {
          nextLevel();
        }
        return;
      }

      // Invincibility timer
      if (player.invincible > 0) player.invincible--;

      // Horizontal movement
      const running = keys['Shift'];
      const speed = running ? PLAYER_RUN_SPEED : PLAYER_SPEED;
      if (keys['ArrowLeft'] || keys['a']) {
        player.vx = -speed;
        player.facing = -1;
      } else if (keys['ArrowRight'] || keys['d']) {
        player.vx = speed;
        player.facing = 1;
      } else {
        player.vx *= 0.7;
        if (Math.abs(player.vx) < 0.3) player.vx = 0;
      }

      // Jump
      if ((keys[' '] || keys['ArrowUp'] || keys['w']) && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
        jumpHoldTimer = JUMP_HOLD_FRAMES;
      }
      // Variable jump height
      if ((keys[' '] || keys['ArrowUp'] || keys['w']) && jumpHoldTimer > 0) {
        player.vy += JUMP_HOLD_FORCE;
        jumpHoldTimer--;
      }
      if (!(keys[' '] || keys['ArrowUp'] || keys['w'])) {
        jumpHoldTimer = 0;
      }

      // Gravity
      player.vy += GRAVITY;
      if (player.vy > MAX_FALL) player.vy = MAX_FALL;

      // Walk animation
      if (Math.abs(player.vx) > 0.5 && player.onGround) {
        player.walkTimer++;
        if (player.walkTimer > 6) {
          player.walkTimer = 0;
          player.walkFrame = (player.walkFrame + 1) % 3;
        }
      } else if (player.onGround) {
        player.walkFrame = 0;
      }

      // Move X
      player.x += player.vx;
      resolveCollisionX();

      // Move Y
      player.y += player.vy;
      resolveCollisionY();

      // Clamp to level bounds
      if (player.x < 0) player.x = 0;
      if (player.x > levelWidth - player.w) player.x = levelWidth - player.w;

      // Fall into pit
      if (player.y > H + TILE) {
        player.dead = true;
        loseLife();
        return;
      }

      // Camera follows player
      camera.x = player.x - W / 3;
      if (camera.x < 0) camera.x = 0;
      if (camera.x > levelWidth - W) camera.x = levelWidth - W;

      // Coin collection
      for (let i = 0; i < coins.length; i++) {
        const c = coins[i];
        if (c.collected) continue;
        const dx = (player.x + player.w / 2) - c.x;
        const dy = (player.y + player.h / 2) - c.y;
        if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
          c.collected = true;
          score += COIN_SCORE;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          // Sparkle particle
          for (let p = 0; p < 5; p++) {
            particles.push({
              x: c.x, y: c.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 1) * 3,
              life: 20 + Math.random() * 10,
              color: '#ff0'
            });
          }
        }
      }

      // Enemy interaction
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        if (!e.alive) {
          if (e.squishTimer > 0) e.squishTimer--;
          continue;
        }

        // Move enemy
        e.x += e.vx;

        // Enemy-tile collision (simple ground check and wall bounce)
        const eFoot = e.y + e.h;
        const eCenter = e.x + e.w / 2;
        const belowTile = tileAt(eCenter, eFoot + 1);
        if (!isSolid(belowTile)) {
          // On edge, turn around
          e.vx = -e.vx;
        }
        const sideTile = tileAt(e.vx > 0 ? e.x + e.w : e.x - 1, e.y + e.h / 2);
        if (isSolid(sideTile)) {
          e.vx = -e.vx;
        }

        // Player collision
        if (player.invincible > 0) continue;
        if (rectCollide(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          // Check if stomping (player falling onto enemy from above)
          if (player.vy > 0 && player.y + player.h - e.y < player.h * 0.5) {
            // Stomp!
            e.alive = false;
            e.squishTimer = 20;
            player.vy = JUMP_FORCE * 0.6;
            score += STOMP_SCORE;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            // Particles
            for (let p = 0; p < 6; p++) {
              particles.push({
                x: e.x + e.w / 2, y: e.y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 1) * 4,
                life: 15 + Math.random() * 10,
                color: '#f42'
              });
            }
          } else {
            // Damaged by enemy
            player.dead = true;
            loseLife();
            return;
          }
        }
      }

      // Question block hit (from below)
      for (let i = 0; i < questionBlocks.length; i++) {
        const qb = questionBlocks[i];
        if (!qb.active) continue;
        const bx = qb.col * TILE;
        const by = qb.row * TILE;
        // Player head hits bottom of block
        if (player.vy < 0 &&
            rectCollide(player.x, player.y, player.w, 4, bx, by + TILE - 4, TILE, 4)) {
          qb.active = false;
          qb.animTimer = 10;
          tiles[qb.row][qb.col] = 4; // used question block
          score += BLOCK_COIN_SCORE;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          // Coin pop out particle
          for (let p = 0; p < 4; p++) {
            particles.push({
              x: bx + TILE / 2, y: by,
              vx: (Math.random() - 0.5) * 2,
              vy: -3 - Math.random() * 2,
              life: 25 + Math.random() * 10,
              color: '#ff0'
            });
          }
        }
      }

      // Brick breaking (from below)
      {
        const headX = player.x + player.w / 2;
        const headY = player.y - 1;
        const col = Math.floor(headX / TILE);
        const row = Math.floor(headY / TILE);
        if (row >= 0 && row < tiles.length && col >= 0 && col < tiles[0].length) {
          if (tiles[row][col] === 2 && player.vy < 0) {
            tiles[row][col] = 0;
            // Brick debris particles
            for (let p = 0; p < 6; p++) {
              particles.push({
                x: col * TILE + TILE / 2,
                y: row * TILE + TILE / 2,
                vx: (Math.random() - 0.5) * 6,
                vy: -2 - Math.random() * 4,
                life: 20 + Math.random() * 15,
                color: '#c84'
              });
            }
            score += 10;
            scoreEl.textContent = score;
          }
        }
      }

      // Flag/goal check
      if (!flagObj.reached && player.x + player.w > flagObj.x && player.x < flagObj.x + TILE) {
        flagObj.reached = true;
        levelComplete = true;
        levelCompleteTimer = 0;
        score += FLAG_SCORE;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Question block animation
      for (let i = 0; i < questionBlocks.length; i++) {
        if (questionBlocks[i].animTimer > 0) questionBlocks[i].animTimer--;
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerVX: player.vx,
        playerVY: player.vy,
        onGround: player.onGround,
        cameraX: camera.x,
        level: level,
        lives: lives,
        enemyCount: enemies.filter(e => e.alive).length,
        coinCount: coins.filter(c => !c.collected).length
      };
    }

    function resolveCollisionX() {
      const left = Math.floor(player.x / TILE);
      const right = Math.floor((player.x + player.w - 1) / TILE);
      const top = Math.floor(player.y / TILE);
      const bottom = Math.floor((player.y + player.h - 1) / TILE);

      for (let r = top; r <= bottom; r++) {
        for (let c = left; c <= right; c++) {
          if (isSolid(tileAt(c * TILE, r * TILE))) {
            // Push out horizontally
            if (player.vx > 0) {
              player.x = c * TILE - player.w;
            } else if (player.vx < 0) {
              player.x = (c + 1) * TILE;
            }
            player.vx = 0;
          }
        }
      }
    }

    function resolveCollisionY() {
      const left = Math.floor(player.x / TILE);
      const right = Math.floor((player.x + player.w - 1) / TILE);
      const top = Math.floor(player.y / TILE);
      const bottom = Math.floor((player.y + player.h - 1) / TILE);

      player.onGround = false;

      for (let r = top; r <= bottom; r++) {
        for (let c = left; c <= right; c++) {
          if (isSolid(tileAt(c * TILE, r * TILE))) {
            if (player.vy > 0) {
              // Landing on top
              player.y = r * TILE - player.h;
              player.vy = 0;
              player.onGround = true;
            } else if (player.vy < 0) {
              // Hitting from below
              player.y = (r + 1) * TILE;
              player.vy = 0;
            }
          }
        }
      }
    }

    // --- Drawing ---
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      const cx = camera ? camera.x : 0;

      // Background stars
      ctx.fillStyle = '#2a2a4e';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 50) % (levelWidth * 0.5)) - cx * 0.3;
        const sy = (i * 97 + 30) % (H * 0.6);
        if (sx > -5 && sx < W + 5) {
          ctx.fillRect(sx, sy, 2, 2);
        }
      }

      // Draw tiles
      const startCol = Math.max(0, Math.floor(cx / TILE) - 1);
      const endCol = Math.min(tiles[0].length, Math.ceil((cx + W) / TILE) + 1);

      for (let r = 0; r < tiles.length; r++) {
        for (let c = startCol; c < endCol; c++) {
          const t = tiles[r][c];
          if (t === 0) continue;
          const tx = c * TILE - cx;
          const ty = r * TILE;
          drawTile(tx, ty, t, r, c);
        }
      }

      // Draw coins
      const time = Date.now() / 1000;
      for (let i = 0; i < coins.length; i++) {
        const c = coins[i];
        if (c.collected) continue;
        const sx = c.x - cx;
        const sy = c.y;
        if (sx < -20 || sx > W + 20) continue;
        drawCoin(sx, sy, time + c.sparkle);
      }

      // Draw flag
      if (flagObj) {
        const fx = flagObj.x - cx;
        // Pole
        ctx.fillStyle = '#aaa';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 4;
        ctx.fillRect(fx + TILE / 2 - 2, flagObj.y, 4, flagObj.height);
        ctx.shadowBlur = 0;
        // Flag triangle
        ctx.fillStyle = '#f42';
        ctx.shadowColor = '#f42';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(fx + TILE / 2 + 2, flagObj.y + 5);
        ctx.lineTo(fx + TILE / 2 + 22, flagObj.y + 18);
        ctx.lineTo(fx + TILE / 2 + 2, flagObj.y + 30);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        // Ball on top
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(fx + TILE / 2, flagObj.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Draw enemies
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        const ex = e.x - cx;
        if (ex < -TILE || ex > W + TILE) continue;
        if (e.alive) {
          drawEnemy(ex, e.y, e.type, time);
        } else if (e.squishTimer > 0) {
          // Squished enemy
          ctx.fillStyle = '#666';
          ctx.fillRect(ex + 4, e.y + e.h - 8, e.w - 8, 8);
        }
      }

      // Draw player
      if (player && !player.dead) {
        if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) {
          // Blink when invincible -- skip draw on even frames
        } else {
          drawPlayer(player.x - cx, player.y);
        }
      }

      // Draw particles
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const px = p.x - cx;
        if (px < -10 || px > W + 10) continue;
        const alpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, alpha);
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(px - 2, p.y - 2, 4, 4);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      // Question block animation (bounce)
      for (let i = 0; i < questionBlocks.length; i++) {
        const qb = questionBlocks[i];
        if (qb.animTimer > 0) {
          const bx = qb.col * TILE - cx;
          const by = qb.row * TILE - Math.sin(qb.animTimer / 10 * Math.PI) * 8;
          ctx.fillStyle = '#ff0';
          ctx.globalAlpha = qb.animTimer / 10;
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(bx + TILE / 2, by - 10, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
      }

      // Level complete text
      if (levelComplete) {
        ctx.fillStyle = '#f42';
        ctx.shadowColor = '#f42';
        ctx.shadowBlur = 20;
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL CLEAR!', W / 2, H / 2 - 20);
        ctx.font = '18px Courier New';
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.fillText(`+${FLAG_SCORE + LEVEL_CLEAR_BONUS * level} pts`, W / 2, H / 2 + 15);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
      }

      // Lives display (hearts) on canvas
      ctx.fillStyle = '#f42';
      ctx.shadowColor = '#f42';
      ctx.shadowBlur = 6;
      for (let i = 0; i < lives; i++) {
        drawHeart(10 + i * 22, 8, 8);
      }
      ctx.shadowBlur = 0;
    }

    function drawHeart(x, y, s) {
      ctx.beginPath();
      ctx.moveTo(x, y + s * 0.3);
      ctx.bezierCurveTo(x, y, x + s * 0.5, y, x + s * 0.5, y + s * 0.3);
      ctx.bezierCurveTo(x + s * 0.5, y, x + s, y, x + s, y + s * 0.3);
      ctx.bezierCurveTo(x + s, y + s * 0.6, x + s * 0.5, y + s * 0.9, x + s * 0.5, y + s);
      ctx.bezierCurveTo(x + s * 0.5, y + s * 0.9, x, y + s * 0.6, x, y + s * 0.3);
      ctx.fill();
    }

    function drawTile(x, y, type, row, col) {
      switch (type) {
        case 1: // Ground
          ctx.fillStyle = '#3a5a2a';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = '#2a4a1a';
          ctx.fillRect(x, y, TILE, 4);
          // Top grass highlight
          if (row > 0 && !isSolid(tiles[row - 1][col])) {
            ctx.fillStyle = '#5a8a3a';
            ctx.fillRect(x, y, TILE, 5);
          }
          // Grid line
          ctx.strokeStyle = '#2a4a1a';
          ctx.strokeRect(x, y, TILE, TILE);
          break;
        case 2: // Brick
          ctx.fillStyle = '#a44';
          ctx.fillRect(x, y, TILE, TILE);
          ctx.strokeStyle = '#722';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 0.5, y + 0.5, TILE - 1, TILE - 1);
          // Brick pattern
          ctx.strokeStyle = '#622';
          ctx.beginPath();
          ctx.moveTo(x + TILE / 2, y);
          ctx.lineTo(x + TILE / 2, y + TILE / 2);
          ctx.moveTo(x, y + TILE / 2);
          ctx.lineTo(x + TILE, y + TILE / 2);
          ctx.moveTo(x + TILE / 4, y + TILE / 2);
          ctx.lineTo(x + TILE / 4, y + TILE);
          ctx.moveTo(x + TILE * 3 / 4, y + TILE / 2);
          ctx.lineTo(x + TILE * 3 / 4, y + TILE);
          ctx.stroke();
          break;
        case 3: // Question block (active)
          ctx.fillStyle = '#d90';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 8;
          ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#a70';
          ctx.strokeRect(x + 2, y + 2, TILE - 4, TILE - 4);
          // Question mark
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 18px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('?', x + TILE / 2, y + TILE / 2);
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';
          break;
        case 4: // Question block (used)
          ctx.fillStyle = '#554';
          ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
          ctx.strokeStyle = '#443';
          ctx.strokeRect(x + 2, y + 2, TILE - 4, TILE - 4);
          break;
        case 5: // Pipe body left
        case 7: // Pipe top left
          ctx.fillStyle = '#0a6';
          ctx.shadowColor = '#0f8';
          ctx.shadowBlur = 4;
          ctx.fillRect(x, y, TILE, TILE);
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#0c8';
          ctx.fillRect(x, y, 6, TILE);
          if (type === 7) {
            ctx.fillStyle = '#0e9';
            ctx.fillRect(x - 4, y, TILE + 4, 6);
          }
          break;
        case 6: // Pipe body right
        case 8: // Pipe top right
          ctx.fillStyle = '#0a6';
          ctx.shadowColor = '#0f8';
          ctx.shadowBlur = 4;
          ctx.fillRect(x, y, TILE, TILE);
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#086';
          ctx.fillRect(x + TILE - 6, y, 6, TILE);
          if (type === 8) {
            ctx.fillStyle = '#0e9';
            ctx.fillRect(x, y, TILE + 4, 6);
          }
          break;
      }
    }

    function drawCoin(x, y, t) {
      const wobble = Math.sin(t * 3) * 0.3 + 0.7;
      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.ellipse(x, y, 8 * wobble, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Inner shine
      ctx.fillStyle = '#fa0';
      ctx.beginPath();
      ctx.ellipse(x, y, 4 * wobble, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Sparkle
      const sparkle = Math.sin(t * 5);
      if (sparkle > 0.7) {
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = (sparkle - 0.7) / 0.3;
        ctx.fillRect(x - 1, y - 12, 2, 6);
        ctx.fillRect(x + 8, y - 1, 6, 2);
        ctx.fillRect(x - 14, y - 1, 6, 2);
        ctx.fillRect(x - 1, y + 8, 2, 6);
        ctx.globalAlpha = 1;
      }
    }

    function drawEnemy(x, y, type, t) {
      if (type === 'goomba') {
        // Body
        ctx.fillStyle = '#a64';
        ctx.shadowColor = '#c86';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.ellipse(x + TILE / 2, y + TILE * 0.6, TILE * 0.45, TILE * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        // Feet (animated)
        const footOff = Math.sin(t * 6) * 3;
        ctx.fillStyle = '#742';
        ctx.fillRect(x + 4, y + TILE - 8, 10, 8);
        ctx.fillRect(x + TILE - 14, y + TILE - 8, 10, 8);
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(x + 8, y + TILE * 0.35, 6, 6);
        ctx.fillRect(x + TILE - 14, y + TILE * 0.35, 6, 6);
        ctx.fillStyle = '#000';
        ctx.fillRect(x + 10, y + TILE * 0.38, 3, 4);
        ctx.fillRect(x + TILE - 12, y + TILE * 0.38, 3, 4);
        // Angry eyebrows
        ctx.strokeStyle = '#520';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 7, y + TILE * 0.32);
        ctx.lineTo(x + 15, y + TILE * 0.3);
        ctx.moveTo(x + TILE - 7, y + TILE * 0.32);
        ctx.lineTo(x + TILE - 15, y + TILE * 0.3);
        ctx.stroke();
        ctx.lineWidth = 1;
      } else {
        // Shell enemy (koopa-like)
        // Shell
        ctx.fillStyle = '#0a0';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.ellipse(x + TILE / 2, y + TILE * 0.6, TILE * 0.42, TILE * 0.35, 0, 0, Math.PI);
        ctx.fill();
        ctx.fillStyle = '#0c0';
        ctx.beginPath();
        ctx.ellipse(x + TILE / 2, y + TILE * 0.55, TILE * 0.42, TILE * 0.3, 0, Math.PI, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        // Head
        ctx.fillStyle = '#8d4';
        ctx.beginPath();
        ctx.arc(x + TILE / 2, y + TILE * 0.25, 8, 0, Math.PI * 2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(x + TILE / 2 - 5, y + TILE * 0.2, 4, 4);
        ctx.fillRect(x + TILE / 2 + 1, y + TILE * 0.2, 4, 4);
        ctx.fillStyle = '#000';
        ctx.fillRect(x + TILE / 2 - 4, y + TILE * 0.22, 2, 3);
        ctx.fillRect(x + TILE / 2 + 2, y + TILE * 0.22, 2, 3);
        // Feet
        ctx.fillStyle = '#a80';
        ctx.fillRect(x + 4, y + TILE - 6, 8, 6);
        ctx.fillRect(x + TILE - 12, y + TILE - 6, 8, 6);
      }
    }

    function drawPlayer(x, y) {
      const f = player.facing;
      const cx = x + player.w / 2;

      // Body
      ctx.fillStyle = '#f42';
      ctx.shadowColor = '#f42';
      ctx.shadowBlur = 8;
      ctx.fillRect(x + 4, y + 10, player.w - 8, player.h - 16);
      ctx.shadowBlur = 0;

      // Overalls
      ctx.fillStyle = '#44f';
      ctx.fillRect(x + 4, y + 18, player.w - 8, player.h - 22);

      // Head
      ctx.fillStyle = '#fca';
      ctx.beginPath();
      ctx.arc(cx, y + 8, 9, 0, Math.PI * 2);
      ctx.fill();

      // Hat
      ctx.fillStyle = '#f42';
      ctx.fillRect(cx - 10, y - 2, 20, 7);
      ctx.fillRect(cx - 6 + f * 3, y - 4, 12, 6);

      // Eyes
      ctx.fillStyle = '#000';
      ctx.fillRect(cx + f * 3, y + 5, 3, 3);

      // Mustache
      ctx.fillStyle = '#520';
      ctx.fillRect(cx + f * 1 - 3, y + 10, 8, 2);

      // Legs (animated)
      ctx.fillStyle = '#44f';
      if (!player.onGround) {
        // Jumping pose
        ctx.fillRect(x + 2, y + player.h - 8, 8, 8);
        ctx.fillRect(x + player.w - 10, y + player.h - 8, 8, 8);
      } else if (Math.abs(player.vx) > 0.5) {
        // Walking
        const legOff = player.walkFrame === 1 ? 2 : (player.walkFrame === 2 ? -2 : 0);
        ctx.fillRect(x + 2 + legOff, y + player.h - 8, 8, 8);
        ctx.fillRect(x + player.w - 10 - legOff, y + player.h - 8, 8, 8);
      } else {
        ctx.fillRect(x + 2, y + player.h - 6, 8, 6);
        ctx.fillRect(x + player.w - 10, y + player.h - 6, 8, 6);
      }

      // Shoes
      ctx.fillStyle = '#840';
      if (!player.onGround) {
        ctx.fillRect(x, y + player.h - 4, 10, 4);
        ctx.fillRect(x + player.w - 10, y + player.h - 4, 10, 4);
      } else {
        ctx.fillRect(x, y + player.h - 4, 10, 4);
        ctx.fillRect(x + player.w - 10, y + player.h - 4, 10, 4);
      }
    }

    // --- Game Loop ---
    let lastTime = 0;
    let accumulator = 0;
    const STEP = 1000 / 60;

    function loop(timestamp) {
      if (gameState !== 'playing') return;

      if (!lastTime) lastTime = timestamp;
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      accumulator += dt;

      // Fixed timestep for consistent physics
      while (accumulator >= STEP) {
        update();
        accumulator -= STEP;
        if (gameState !== 'playing') break;
      }

      draw();
      requestAnimationFrame(loop);
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Warzone Diplomacy</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 10px;
      width: 600px;
    }
    .back { color: #c44; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(204, 68, 68, 0.4); }
    h1 { color: #c44; font-size: 1.6rem; text-shadow: 0 0 15px rgba(204, 68, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #c44; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.8rem;
      color: #888;
    }
    canvas {
      border: 2px solid #c44;
      box-shadow: 0 0 20px rgba(204, 68, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c44;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.9);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(204, 68, 68, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-bottom: 6px; }
    .overlay .subtitle { font-size: 0.85rem; color: #777; }
    .controls {
      width: 600px;
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .controls button {
      background: #2a2a4e;
      color: #c44;
      border: 1px solid #c44;
      padding: 6px 14px;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      cursor: pointer;
      border-radius: 3px;
    }
    .controls button:hover { background: #3a3a5e; box-shadow: 0 0 8px rgba(204, 68, 68, 0.3); }
    .controls button:disabled { opacity: 0.4; cursor: default; }
    .controls button.active { background: #c44; color: #1a1a2e; }
    .log {
      width: 600px;
      margin-top: 8px;
      max-height: 80px;
      overflow-y: auto;
      font-size: 0.75rem;
      color: #888;
      background: #12122a;
      border: 1px solid #333;
      padding: 6px;
      border-radius: 3px;
    }
    .log div { margin-bottom: 2px; }
    .log .attack { color: #e66; }
    .log .reinforce { color: #6c6; }
    .log .diplomacy { color: #6af; }
    .log .betray { color: #f80; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WARZONE DIPLOMACY</h1>
  </div>
  <div class="score-bar">
    <div>Territories: <span id="score">0</span>/24</div>
    <div>Turn: <span id="turnNum">0</span></div>
    <div>Reinforcements: <span id="reinforcements">0</span></div>
  </div>
  <div class="info-bar">
    <div id="phaseInfo">Phase: Planning</div>
    <div id="allianceInfo">Alliances: None</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">WARZONE DIPLOMACY</h2>
      <p id="overlayText">Risk-like conquest with alliances & betrayal</p>
      <p class="subtitle">Click anywhere to start</p>
    </div>
  </div>
  <div class="controls">
    <button id="btnAttack" onclick="setMode('attack')">Attack</button>
    <button id="btnReinforce" onclick="setMode('reinforce')">Reinforce</button>
    <button id="btnSubmit" onclick="submitOrders()">Submit Orders</button>
    <button id="btnUndo" onclick="undoOrder()">Undo</button>
    <span id="modeLabel" style="color:#888;font-size:0.8rem;margin-left:8px;">Mode: --</span>
  </div>
  <div class="log" id="log"></div>

  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const turnNumEl = document.getElementById('turnNum');
    const reinforcementsEl = document.getElementById('reinforcements');
    const phaseInfoEl = document.getElementById('phaseInfo');
    const allianceInfoEl = document.getElementById('allianceInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const logEl = document.getElementById('log');
    const modeLabelEl = document.getElementById('modeLabel');

    document.addEventListener('keydown', (e) => {
      if ([' '].includes(e.key)) e.preventDefault();
    });

    /* ==================== GAME STATE ==================== */
    let gameState = 'menu';
    let score = 0;

    const PLAYER_COLORS = ['#4488ff','#e55','#3b3','#d4d','#fa0'];
    const PLAYER_NAMES = ['You','General Krov','Marshal Vex','Duchess Nara','Warlord Zhin'];
    const AI_PERSONALITIES = [null,'aggressive','defensive','diplomatic','opportunist'];
    const CONTINENT_COLORS = ['#443322','#223344','#224422','#442244','#444422'];
    const CONTINENT_NAMES = ['Nordheim','Oceania','Verdania','Shadowlands','Aurelia'];
    const CONTINENT_BONUSES = [3,2,3,2,4];
    const WIN_THRESHOLD = 0.75;

    let territories = [];
    let adjacency = {};
    let players = [];
    let turnNumber = 0;
    let currentOrders = [];
    let orderMode = null;
    let selectedTerritory = null;
    let hoveredTerritory = null;
    let alliances = {};
    let betrayals = {};
    let animQueue = [];
    let animating = false;

    /* ==================== MAP GENERATION ==================== */
    function buildMap(){
      const tdata = [
        // Continent 0: Nordheim (top-left) - 5 territories
        {id:0,name:'Frostpeak',cx:75,cy:60,cont:0},
        {id:1,name:'Icehold',cx:150,cy:45,cont:0},
        {id:2,name:'Snowgate',cx:115,cy:120,cont:0},
        {id:3,name:'Rimwall',cx:55,cy:145,cont:0},
        {id:4,name:'Glacius',cx:185,cy:110,cont:0},
        // Continent 1: Oceania (top-right) - 4 territories
        {id:5,name:'Tidecrest',cx:420,cy:50,cont:1},
        {id:6,name:'Seaholm',cx:500,cy:70,cont:1},
        {id:7,name:'Coralport',cx:470,cy:140,cont:1},
        {id:8,name:'Stormisle',cx:545,cy:130,cont:1},
        // Continent 2: Verdania (center) - 6 territories
        {id:9,name:'Greenhollow',cx:250,cy:180,cont:2},
        {id:10,name:'Mossbridge',cx:320,cy:160,cont:2},
        {id:11,name:'Thornfield',cx:280,cy:245,cont:2},
        {id:12,name:'Rootheim',cx:355,cy:230,cont:2},
        {id:13,name:'Leafward',cx:240,cy:310,cont:2},
        {id:14,name:'Ivyspire',cx:390,cy:300,cont:2},
        // Continent 3: Shadowlands (bottom-left) - 4 territories
        {id:15,name:'Duskreach',cx:70,cy:310,cont:3},
        {id:16,name:'Voidfen',cx:140,cy:360,cont:3},
        {id:17,name:'Ashdale',cx:65,cy:420,cont:3},
        {id:18,name:'Grimhollow',cx:155,cy:440,cont:3},
        // Continent 4: Aurelia (bottom-right) - 5 territories
        {id:19,name:'Goldcrest',cx:430,cy:360,cont:4},
        {id:20,name:'Sunspire',cx:510,cy:340,cont:4},
        {id:21,name:'Dawnkeep',cx:460,cy:430,cont:4},
        {id:22,name:'Radiantfort',cx:540,cy:420,cont:4},
        {id:23,name:'Heliogarde',cx:490,cy:470,cont:4}
      ];

      const adj = {
        0:[1,2,3], 1:[0,2,4,5], 2:[0,1,3,4], 3:[0,2,15], 4:[1,2,9,10],
        5:[1,6,7,10], 6:[5,7,8], 7:[5,6,8,12], 8:[6,7,20],
        9:[4,10,11,13], 10:[4,5,9,12], 11:[9,12,13,14], 12:[7,10,11,14],
        13:[9,11,15,16], 14:[11,12,19],
        15:[3,13,16,17], 16:[13,15,17,18], 17:[15,16,18], 18:[16,17,21],
        19:[14,20,21], 20:[8,19,22], 21:[18,19,22,23], 22:[20,21,23], 23:[21,22]
      };

      territories = tdata.map(t => ({
        ...t, owner:-1, armies:0,
        polyPoints: generateTerritoryPoly(t.cx, t.cy)
      }));
      adjacency = adj;
    }

    function generateTerritoryPoly(cx, cy){
      const pts = [];
      const n = 6 + Math.floor(Math.random()*3);
      const baseR = 32 + Math.random()*8;
      for(let i=0;i<n;i++){
        const a = (Math.PI*2*i)/n + (Math.random()-0.5)*0.4;
        const r = baseR + (Math.random()-0.5)*12;
        pts.push({x: cx+Math.cos(a)*r, y: cy+Math.sin(a)*r});
      }
      return pts;
    }

    /* ==================== INITIALIZATION ==================== */
    function initGame(){
      buildMap();
      turnNumber = 1;
      currentOrders = [];
      orderMode = null;
      selectedTerritory = null;
      alliances = {};
      betrayals = {};
      animQueue = [];
      animating = false;
      logEl.innerHTML = '';

      players = PLAYER_NAMES.map((name,i) => ({
        id:i, name, alive:true,
        personality: AI_PERSONALITIES[i],
        territories: [],
        reinforcements: 0,
        pendingOrders: [],
        trustScores: [50,50,50,50,50],
        aggressionMemory: [0,0,0,0,0]
      }));

      // Distribute territories
      const shuffled = [...Array(24).keys()];
      for(let i=shuffled.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]];
      }
      for(let i=0;i<5;i++){
        const startTerrs = shuffled.slice(i*4, i*4+4);
        startTerrs.forEach(tid => {
          territories[tid].owner = i;
          territories[tid].armies = 2 + Math.floor(Math.random()*2);
        });
      }
      for(let i=20;i<24;i++){
        const p = Math.floor(Math.random()*5);
        territories[shuffled[i]].owner = p;
        territories[shuffled[i]].armies = 1;
      }

      updatePlayerTerritories();
      calculateReinforcements(0);
      updateUI();
      gameState = 'planning';
      logMsg('The war begins. Assign your orders and submit.','diplomacy');
    }

    function updatePlayerTerritories(){
      players.forEach(p => {
        p.territories = territories.filter(t => t.owner===p.id).map(t=>t.id);
        p.alive = p.territories.length > 0;
      });
    }

    /* ==================== REINFORCEMENTS ==================== */
    function calculateReinforcements(playerId){
      const p = players[playerId];
      let r = Math.max(3, Math.floor(p.territories.length/3));
      for(let c=0;c<5;c++){
        const contTerrs = territories.filter(t=>t.cont===c);
        if(contTerrs.every(t=>t.owner===playerId)){
          r += CONTINENT_BONUSES[c];
        }
      }
      p.reinforcements = r;
      return r;
    }

    /* ==================== ORDER SYSTEM ==================== */
    function setMode(mode){
      if(gameState!=='planning') return;
      orderMode = mode;
      selectedTerritory = null;
      document.getElementById('btnAttack').classList.toggle('active', mode==='attack');
      document.getElementById('btnReinforce').classList.toggle('active', mode==='reinforce');
      modeLabelEl.textContent = mode==='attack'
        ? 'Mode: Attack (click source, then target)'
        : 'Mode: Reinforce (click your territory)';
      draw();
    }

    function undoOrder(){
      if(currentOrders.length > 0){
        const removed = currentOrders.pop();
        if(removed.type==='reinforce'){
          players[0].reinforcements += removed.amount;
        }
        logMsg('Undid: '+removed.type+' order','reinforce');
        updateUI();
        draw();
      }
    }

    function handleTerritoryClick(tid){
      if(gameState!=='planning' || animating) return;
      const t = territories[tid];

      if(orderMode==='reinforce'){
        if(t.owner!==0) return;
        if(players[0].reinforcements<=0){
          logMsg('No reinforcements remaining!','attack');
          return;
        }
        currentOrders.push({type:'reinforce',target:tid,amount:1});
        players[0].reinforcements -= 1;
        logMsg('+1 army to '+t.name,'reinforce');
        updateUI();
        draw();
      } else if(orderMode==='attack'){
        if(selectedTerritory===null){
          if(t.owner!==0){logMsg('Select your own territory first','attack');return;}
          if(t.armies<2){logMsg('Need at least 2 armies to attack','attack');return;}
          selectedTerritory = tid;
          modeLabelEl.textContent = 'Attack from '+t.name+' -> click enemy neighbor';
          draw();
        } else {
          if(t.owner===0){selectedTerritory=null;draw();return;}
          if(!adjacency[selectedTerritory].includes(tid)){
            logMsg('Target must be adjacent!','attack');
            selectedTerritory=null;draw();return;
          }
          const src = territories[selectedTerritory];
          const attackArmies = Math.min(src.armies-1, 3);
          currentOrders.push({type:'attack',from:selectedTerritory,to:tid,armies:attackArmies});
          logMsg('Attack: '+src.name+' ('+attackArmies+') -> '+t.name,'attack');
          selectedTerritory=null;
          draw();
        }
      }
    }

    /* ==================== ORDER RESOLUTION ==================== */
    function submitOrders(){
      if(gameState!=='planning' || animating) return;

      // Auto-spend remaining reinforcements
      while(players[0].reinforcements > 0){
        const owned = players[0].territories;
        if(owned.length===0) break;
        // Place on border territories preferentially
        const borders = owned.filter(tid => adjacency[tid].some(nid => territories[nid].owner!==0));
        const pool = borders.length > 0 ? borders : owned;
        const tid = pool[Math.floor(Math.random()*pool.length)];
        currentOrders.push({type:'reinforce',target:tid,amount:1});
        players[0].reinforcements--;
      }

      players[0].pendingOrders = [...currentOrders];
      currentOrders = [];

      for(let i=1;i<5;i++){
        if(!players[i].alive) continue;
        calculateReinforcements(i);
        players[i].pendingOrders = generateAIOrders(i);
      }

      processAllianceDiplomacy();

      gameState = 'resolving';
      phaseInfoEl.textContent = 'Phase: Resolving...';
      resolveAllOrders();
    }

    function resolveAllOrders(){
      // 1. Apply reinforcements
      for(let i=0;i<5;i++){
        if(!players[i].alive) continue;
        players[i].pendingOrders.filter(o=>o.type==='reinforce').forEach(o=>{
          if(territories[o.target].owner===i){
            territories[o.target].armies += o.amount;
          }
        });
      }

      // 2. Collect attacks
      const allAttacks = [];
      for(let i=0;i<5;i++){
        if(!players[i].alive) continue;
        players[i].pendingOrders.filter(o=>o.type==='attack').forEach(o=>{
          if(territories[o.from].owner===i && territories[o.from].armies>=2){
            allAttacks.push({...o, player:i});
          }
        });
      }

      // Shuffle for fairness
      for(let i=allAttacks.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [allAttacks[i],allAttacks[j]]=[allAttacks[j],allAttacks[i]];
      }

      animQueue = allAttacks;
      animating = true;
      resolveNextAttack();
    }

    function resolveNextAttack(){
      if(animQueue.length===0){
        animating=false;
        endTurn();
        return;
      }

      const atk = animQueue.shift();
      const src = territories[atk.from];
      const dst = territories[atk.to];

      if(src.owner!==atk.player || src.armies<2){
        resolveNextAttack();
        return;
      }

      const defOwner = dst.owner;
      const allianceKey = [Math.min(atk.player,defOwner),Math.max(atk.player,defOwner)].join('-');
      if(alliances[allianceKey]){
        delete alliances[allianceKey];
        betrayals[allianceKey] = turnNumber;
        logMsg('BETRAYAL! '+PLAYER_NAMES[atk.player]+' broke alliance with '+PLAYER_NAMES[defOwner]+'!','betray');
        players.forEach(p=>{
          if(p.id!==atk.player){
            p.trustScores[atk.player] = Math.max(0, p.trustScores[atk.player]-30);
          }
        });
      }

      if(defOwner>=0 && defOwner<5){
        players[defOwner].aggressionMemory[atk.player] += 1;
      }

      const attackArmies = Math.min(src.armies-1, atk.armies);
      const defendArmies = Math.min(dst.armies, 2);

      const atkDice = rollDice(attackArmies).sort((a,b)=>b-a);
      const defDice = rollDice(defendArmies).sort((a,b)=>b-a);
      let atkLoss=0, defLoss=0;

      for(let i=0;i<Math.min(atkDice.length,defDice.length);i++){
        if(atkDice[i]>defDice[i]) defLoss++;
        else atkLoss++;
      }

      src.armies -= atkLoss;
      dst.armies -= defLoss;

      const atkName = PLAYER_NAMES[atk.player];
      const defName = defOwner>=0 ? PLAYER_NAMES[defOwner] : 'Neutral';

      if(dst.armies<=0){
        dst.owner = atk.player;
        const moveIn = Math.min(src.armies-1, attackArmies);
        dst.armies = Math.max(1, moveIn);
        src.armies = Math.max(1, src.armies - moveIn);
        logMsg(atkName+' captured '+dst.name+' from '+defName+'! ['+atkDice+'] vs ['+defDice+']','attack');
      } else {
        logMsg(atkName+' attacked '+dst.name+' ('+defName+'): lost '+atkLoss+', killed '+defLoss+' ['+atkDice+'] vs ['+defDice+']','attack');
      }

      updatePlayerTerritories();
      updateUI();
      draw();
      setTimeout(resolveNextAttack, 350);
    }

    function rollDice(n){
      const dice=[];
      for(let i=0;i<n;i++) dice.push(Math.floor(Math.random()*6)+1);
      return dice;
    }

    function endTurn(){
      // Decay alliances
      for(const key of Object.keys(alliances)){
        alliances[key]--;
        if(alliances[key]<=0){
          delete alliances[key];
          const [a,b]=key.split('-').map(Number);
          logMsg('Alliance expired: '+PLAYER_NAMES[a]+' & '+PLAYER_NAMES[b],'diplomacy');
        }
      }

      updatePlayerTerritories();

      // Check win/loss
      const alivePlayers = players.filter(p=>p.alive);
      const playerTerrs = players[0].territories.length;

      if(!players[0].alive){
        gameState='gameover';
        score=playerTerrs;
        scoreEl.textContent=score;
        overlayTitle.textContent='DEFEAT';
        overlayText.textContent='Eliminated on turn '+turnNumber+'. Score: '+score;
        overlay.style.display='flex';
        overlay.style.pointerEvents='auto';
        overlay.onclick=()=>{overlay.style.display='none';overlay.style.pointerEvents='none';initGame();draw();};
        return;
      }

      if(playerTerrs >= Math.ceil(24*WIN_THRESHOLD)){
        gameState='gameover';
        score=playerTerrs+turnNumber*2;
        scoreEl.textContent=score;
        overlayTitle.textContent='TOTAL VICTORY!';
        overlayText.textContent='Dominated '+playerTerrs+'/24 territories in '+turnNumber+' turns! Score: '+score;
        overlay.style.display='flex';
        overlay.style.pointerEvents='auto';
        overlay.onclick=()=>{overlay.style.display='none';overlay.style.pointerEvents='none';initGame();draw();};
        return;
      }

      if(alivePlayers.length===1 && alivePlayers[0].id===0){
        gameState='gameover';
        score=playerTerrs+turnNumber*2;
        scoreEl.textContent=score;
        overlayTitle.textContent='LAST ONE STANDING!';
        overlayText.textContent='All enemies eliminated in '+turnNumber+' turns! Score: '+score;
        overlay.style.display='flex';
        overlay.style.pointerEvents='auto';
        overlay.onclick=()=>{overlay.style.display='none';overlay.style.pointerEvents='none';initGame();draw();};
        return;
      }

      turnNumber++;
      calculateReinforcements(0);
      gameState='planning';
      orderMode=null;
      selectedTerritory=null;
      document.getElementById('btnAttack').classList.remove('active');
      document.getElementById('btnReinforce').classList.remove('active');
      modeLabelEl.textContent='Mode: --';
      updateUI();
      draw();
      logMsg('--- Turn '+turnNumber+' --- You have '+players[0].reinforcements+' reinforcements.','diplomacy');
    }

    /* ==================== AI SYSTEM ==================== */
    function generateAIOrders(pid){
      const p = players[pid];
      const orders = [];
      let reinforcements = p.reinforcements;
      const personality = p.personality;
      const owned = p.territories;

      const borderTerrs = owned.filter(tid =>
        adjacency[tid].some(nid => territories[nid].owner!==pid)
      );
      const innerTerrs = owned.filter(tid =>
        adjacency[tid].every(nid => territories[nid].owner===pid)
      );

      /* --- Reinforcement strategy --- */
      if(personality==='aggressive'){
        const targets = borderTerrs.slice().sort((a,b)=>{
          const enemyA = adjacency[a].filter(n=>territories[n].owner!==pid);
          const enemyB = adjacency[b].filter(n=>territories[n].owner!==pid);
          const aMin = enemyA.length>0 ? Math.min(...enemyA.map(n=>territories[n].armies)) : 99;
          const bMin = enemyB.length>0 ? Math.min(...enemyB.map(n=>territories[n].armies)) : 99;
          return aMin-bMin;
        });
        let i=0;
        while(reinforcements>0 && targets.length>0){
          orders.push({type:'reinforce',target:targets[i%targets.length],amount:1});
          reinforcements--; i++;
        }
      } else if(personality==='defensive'){
        const weakBorders = borderTerrs.slice().sort((a,b)=>territories[a].armies-territories[b].armies);
        let i=0;
        while(reinforcements>0){
          const target = weakBorders.length>0 ? weakBorders[i%weakBorders.length] : owned[i%owned.length];
          orders.push({type:'reinforce',target,amount:1});
          reinforcements--; i++;
        }
      } else if(personality==='diplomatic'){
        let i=0;
        while(reinforcements>0){
          const target = borderTerrs.length>0 ? borderTerrs[i%borderTerrs.length] : owned[i%owned.length];
          orders.push({type:'reinforce',target,amount:1});
          reinforcements--; i++;
        }
      } else {
        // Opportunist: pile onto strongest border territory
        const sorted = borderTerrs.slice().sort((a,b)=>territories[b].armies-territories[a].armies);
        const best = sorted.length>0 ? sorted[0] : owned[0];
        while(reinforcements>0){
          orders.push({type:'reinforce',target:best,amount:1});
          reinforcements--;
        }
      }

      /* --- Attack strategy --- */
      const allyIds = getAllies(pid);

      for(const tid of borderTerrs){
        const src = territories[tid];
        if(src.armies<2) continue;

        const enemyNeighbors = adjacency[tid]
          .filter(nid => territories[nid].owner!==pid)
          .map(nid => territories[nid]);

        let targets = enemyNeighbors;
        if(personality!=='opportunist'){
          targets = targets.filter(t => !allyIds.includes(t.owner));
        } else {
          targets = targets.filter(t => {
            if(allyIds.includes(t.owner)){
              return src.armies > t.armies*2.5 && Math.random()<0.2;
            }
            return true;
          });
        }

        if(targets.length===0) continue;

        let target;
        if(personality==='aggressive'){
          target = targets.sort((a,b)=>a.armies-b.armies)[0];
          if(src.armies > target.armies){
            orders.push({type:'attack',from:tid,to:target.id,armies:Math.min(src.armies-1,3)});
          }
        } else if(personality==='defensive'){
          target = targets.sort((a,b)=>a.armies-b.armies)[0];
          if(src.armies >= target.armies*2){
            orders.push({type:'attack',from:tid,to:target.id,armies:Math.min(src.armies-1,3)});
          }
        } else if(personality==='diplomatic'){
          const byTrust = targets.sort((a,b)=>p.trustScores[a.owner]-p.trustScores[b.owner]);
          target = byTrust[0];
          if(src.armies > target.armies*1.3){
            orders.push({type:'attack',from:tid,to:target.id,armies:Math.min(src.armies-1,3)});
          }
        } else {
          target = targets.sort((a,b)=>(a.armies/src.armies)-(b.armies/src.armies))[0];
          if(src.armies > target.armies*1.1){
            orders.push({type:'attack',from:tid,to:target.id,armies:Math.min(src.armies-1,3)});
          }
        }
      }

      // Limit attacks by personality
      const atkOrders = orders.filter(o=>o.type==='attack');
      let maxAttacks;
      if(personality==='aggressive') maxAttacks=4;
      else if(personality==='defensive') maxAttacks=1;
      else if(personality==='diplomatic') maxAttacks=2;
      else maxAttacks=3;

      if(atkOrders.length > maxAttacks){
        const removed = atkOrders.slice(maxAttacks);
        removed.forEach(r=>{
          const idx=orders.indexOf(r);
          if(idx>=0) orders.splice(idx,1);
        });
      }

      return orders;
    }

    function getAllies(pid){
      const allies=[];
      for(const key of Object.keys(alliances)){
        const [a,b]=key.split('-').map(Number);
        if(a===pid) allies.push(b);
        if(b===pid) allies.push(a);
      }
      return allies;
    }

    function processAllianceDiplomacy(){
      // AI-to-AI alliances
      for(let i=1;i<5;i++){
        if(!players[i].alive) continue;
        const p=players[i];
        const personality=p.personality;

        for(let j=i+1;j<5;j++){
          if(!players[j].alive) continue;
          const q=players[j];
          const key=i+'-'+j;
          if(alliances[key]) continue;
          if(betrayals[key] && turnNumber-betrayals[key]<5) continue;

          let willAlly=false;

          const dominant=players.reduce((best,pl)=>pl.territories.length>best.territories.length?pl:best, players[0]);
          const dominantThreat = dominant.territories.length > 8;

          if(personality==='diplomatic' || q.personality==='diplomatic'){
            if(p.trustScores[j]>30 && q.trustScores[i]>30) willAlly=true;
          }
          if(dominantThreat && dominant.id!==i && dominant.id!==j){
            if(Math.random()<0.5) willAlly=true;
          }
          if(personality==='defensive' && p.territories.length<4){
            if(Math.random()<0.4) willAlly=true;
          }

          if(willAlly){
            alliances[key] = 3+Math.floor(Math.random()*3);
            logMsg('Alliance formed: '+PLAYER_NAMES[i]+' & '+PLAYER_NAMES[j]+'!','diplomacy');
            p.trustScores[j]=Math.min(100,p.trustScores[j]+15);
            q.trustScores[i]=Math.min(100,q.trustScores[i]+15);
          }
        }

        // AI-to-human alliances
        const hKey='0-'+i;
        if(!alliances[hKey]){
          if(betrayals[hKey] && turnNumber-betrayals[hKey]<5) continue;
          let willAllyHuman=false;

          if(personality==='diplomatic' && p.trustScores[0]>40) willAllyHuman=Math.random()<0.3;
          if(p.territories.length<3 && Math.random()<0.3) willAllyHuman=true;

          const dominant=players.reduce((best,pl)=>pl.territories.length>best.territories.length?pl:best, players[0]);
          if(dominant.id!==0 && dominant.id!==i && dominant.territories.length>8 && Math.random()<0.4){
            willAllyHuman=true;
          }

          if(willAllyHuman){
            alliances[hKey]=3+Math.floor(Math.random()*3);
            logMsg(PLAYER_NAMES[i]+' proposes alliance with you! ('+alliances[hKey]+' turns)','diplomacy');
            p.trustScores[0]=Math.min(100,p.trustScores[0]+10);
          }
        }
      }
    }

    /* ==================== UI ==================== */
    function updateUI(){
      const pt=players[0].territories.length;
      score=pt;
      scoreEl.textContent=pt;
      turnNumEl.textContent=turnNumber;
      reinforcementsEl.textContent=players[0].reinforcements;

      const allyNames=getAllies(0).map(id=>PLAYER_NAMES[id]);
      allianceInfoEl.textContent=allyNames.length>0?'Allies: '+allyNames.join(', '):'Alliances: None';

      phaseInfoEl.textContent=gameState==='planning'
        ?'Phase: Planning ('+currentOrders.length+' orders)'
        :gameState==='resolving'?'Phase: Resolving...':'Phase: --';

      document.getElementById('btnAttack').disabled=gameState!=='planning';
      document.getElementById('btnReinforce').disabled=gameState!=='planning';
      document.getElementById('btnSubmit').disabled=gameState!=='planning';
      document.getElementById('btnUndo').disabled=gameState!=='planning'||currentOrders.length===0;
    }

    function logMsg(msg,cls){
      const div=document.createElement('div');
      div.className=cls||'';
      div.textContent=msg;
      logEl.appendChild(div);
      logEl.scrollTop=logEl.scrollHeight;
    }

    /* ==================== DRAWING ==================== */
    function draw(){
      ctx.fillStyle='#1a1a2e';
      ctx.fillRect(0,0,W,H);

      drawContinentRegions();

      // Adjacency lines
      ctx.strokeStyle='rgba(255,255,255,0.08)';
      ctx.lineWidth=1;
      for(const [tid,neighbors] of Object.entries(adjacency)){
        const t=territories[tid];
        for(const nid of neighbors){
          if(nid>parseInt(tid)){
            const n=territories[nid];
            ctx.beginPath();
            ctx.moveTo(t.cx,t.cy);
            ctx.lineTo(n.cx,n.cy);
            ctx.stroke();
          }
        }
      }

      // Territories
      for(const t of territories) drawTerritory(t);

      // Attack order arrows
      for(const o of currentOrders){
        if(o.type==='attack'){
          const src=territories[o.from];
          const dst=territories[o.to];
          drawArrow(src.cx,src.cy,dst.cx,dst.cy,'#ff6');
        }
      }

      // Selected territory highlight
      if(selectedTerritory!==null){
        const st=territories[selectedTerritory];
        ctx.strokeStyle='#fff';
        ctx.lineWidth=3;
        ctx.setLineDash([4,4]);
        drawPoly(st.polyPoints);
        ctx.stroke();
        ctx.setLineDash([]);

        adjacency[selectedTerritory].forEach(nid=>{
          if(territories[nid].owner!==0){
            const nt=territories[nid];
            ctx.strokeStyle='rgba(255,100,100,0.5)';
            ctx.lineWidth=2;
            ctx.setLineDash([3,3]);
            drawPoly(nt.polyPoints);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        });
      }

      // Tooltip
      if(hoveredTerritory!==null) drawTooltip(territories[hoveredTerritory]);

      // Legend
      drawLegend();
    }

    function drawContinentRegions(){
      for(let c=0;c<5;c++){
        const contTerrs=territories.filter(t=>t.cont===c);
        if(contTerrs.length===0) continue;

        const minX=Math.min(...contTerrs.map(t=>t.cx))-45;
        const maxX=Math.max(...contTerrs.map(t=>t.cx))+45;
        const minY=Math.min(...contTerrs.map(t=>t.cy))-45;
        const maxY=Math.max(...contTerrs.map(t=>t.cy))+45;

        ctx.fillStyle=CONTINENT_COLORS[c]+'30';
        ctx.beginPath();
        const rx=(maxX-minX)/2;
        const ry=(maxY-minY)/2;
        ctx.ellipse(minX+rx, minY+ry, rx+10, ry+10, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle='rgba(255,255,255,0.15)';
        ctx.font='10px Courier New';
        ctx.textAlign='center';
        ctx.fillText(CONTINENT_NAMES[c]+' (+'+CONTINENT_BONUSES[c]+')', minX+rx, maxY+12);
      }
    }

    function drawTerritory(t){
      const isAllyOwned = getAllies(0).includes(t.owner);
      const isOwned = t.owner===0;

      let color;
      if(t.owner>=0 && t.owner<5) color=PLAYER_COLORS[t.owner];
      else color='#555';

      ctx.fillStyle=color+'80';
      drawPoly(t.polyPoints);
      ctx.fill();

      ctx.strokeStyle=color;
      ctx.lineWidth=isOwned?2.5:1.5;
      if(isAllyOwned){
        ctx.setLineDash([3,3]);
        ctx.strokeStyle='#6af';
      }
      drawPoly(t.polyPoints);
      ctx.stroke();
      ctx.setLineDash([]);

      if(isOwned){
        ctx.shadowColor=PLAYER_COLORS[0];
        ctx.shadowBlur=8;
        ctx.strokeStyle=PLAYER_COLORS[0]+'60';
        ctx.lineWidth=1;
        drawPoly(t.polyPoints);
        ctx.stroke();
        ctx.shadowBlur=0;
      }

      // Army count circle
      const r=t.armies>9?12:10;
      ctx.fillStyle='#1a1a2e';
      ctx.beginPath();
      ctx.arc(t.cx,t.cy,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle=color;
      ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.arc(t.cx,t.cy,r,0,Math.PI*2);
      ctx.stroke();

      ctx.fillStyle='#fff';
      ctx.font='bold 11px Courier New';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(t.armies,t.cx,t.cy);

      // Reinforcement indicators
      const reinforced=currentOrders.filter(o=>o.type==='reinforce'&&o.target===t.id);
      if(reinforced.length>0){
        const total=reinforced.reduce((s,o)=>s+o.amount,0);
        ctx.fillStyle='#6f6';
        ctx.font='bold 10px Courier New';
        ctx.fillText('+'+total, t.cx+14, t.cy-10);
      }
    }

    function drawPoly(points){
      ctx.beginPath();
      ctx.moveTo(points[0].x,points[0].y);
      for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x,points[i].y);
      ctx.closePath();
    }

    function drawArrow(x1,y1,x2,y2,color){
      const angle=Math.atan2(y2-y1,x2-x1);
      const len=Math.sqrt((x2-x1)**2+(y2-y1)**2);
      const mx=x1+Math.cos(angle)*(len-20);
      const my=y1+Math.sin(angle)*(len-20);

      ctx.strokeStyle=color;
      ctx.lineWidth=2;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(mx,my);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.moveTo(mx+Math.cos(angle)*8, my+Math.sin(angle)*8);
      ctx.lineTo(mx+Math.cos(angle+2.5)*8, my+Math.sin(angle+2.5)*8);
      ctx.lineTo(mx+Math.cos(angle-2.5)*8, my+Math.sin(angle-2.5)*8);
      ctx.closePath();
      ctx.fill();
    }

    function drawTooltip(t){
      const ownerName = t.owner>=0 ? PLAYER_NAMES[t.owner] : 'Neutral';
      const contName = CONTINENT_NAMES[t.cont];
      const lines = [t.name, 'Owner: '+ownerName, 'Armies: '+t.armies, 'Continent: '+contName];

      let tx=t.cx+30, ty=t.cy-30;
      if(tx+140>W) tx=t.cx-170;
      if(ty<10) ty=10;
      if(ty+60>H) ty=H-65;

      ctx.fillStyle='rgba(10,10,30,0.92)';
      ctx.strokeStyle='#c44';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.roundRect(tx,ty,140,58,4);
      ctx.fill();
      ctx.stroke();

      ctx.font='10px Courier New';
      ctx.textAlign='left';
      ctx.textBaseline='top';
      lines.forEach((line,i)=>{
        ctx.fillStyle=i===0?'#c44':'#ccc';
        ctx.fillText(line,tx+6,ty+5+i*13);
      });
    }

    function drawLegend(){
      const lx=10, ly=H-82;
      ctx.fillStyle='rgba(10,10,30,0.85)';
      ctx.strokeStyle='#333';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.roundRect(lx,ly,145,78,4);
      ctx.fill();
      ctx.stroke();

      ctx.font='9px Courier New';
      ctx.textAlign='left';
      ctx.textBaseline='top';

      for(let i=0;i<5;i++){
        const p=players[i];
        const y=ly+4+i*14;
        ctx.fillStyle=p.alive?PLAYER_COLORS[i]:'#444';
        ctx.beginPath();
        ctx.arc(lx+8,y+5,4,0,Math.PI*2);
        ctx.fill();

        let pType='';
        if(i>0 && p.personality) pType=' ['+p.personality.substring(0,3)+']';
        const label=p.name.substring(0,12)+' '+p.territories.length+'t'+pType;
        ctx.fillStyle=p.alive?'#ccc':'#555';
        ctx.fillText(label, lx+16, y);

        if(!p.alive){
          ctx.fillStyle='#a44';
          ctx.fillText('X', lx+135, y);
        }
      }
    }

    /* ==================== INPUT ==================== */
    function getTerritoryAt(mx,my){
      for(const t of territories){
        if(pointInPoly(mx,my,t.polyPoints)) return t.id;
      }
      let closest=-1, minDist=35;
      for(const t of territories){
        const d=Math.sqrt((mx-t.cx)**2+(my-t.cy)**2);
        if(d<minDist){minDist=d;closest=t.id;}
      }
      return closest;
    }

    function pointInPoly(x,y,poly){
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const xi=poly[i].x,yi=poly[i].y;
        const xj=poly[j].x,yj=poly[j].y;
        if((yi>y)!==(yj>y) && x<(xj-xi)*(y-yi)/(yj-yi)+xi){
          inside=!inside;
        }
      }
      return inside;
    }

    canvas.addEventListener('click',(e)=>{
      const rect=canvas.getBoundingClientRect();
      const mx=(e.clientX-rect.left)*(W/rect.width);
      const my=(e.clientY-rect.top)*(H/rect.height);

      if(gameState==='menu'){
        overlay.style.display='none';
        overlay.style.pointerEvents='none';
        initGame();
        draw();
        return;
      }

      const tid=getTerritoryAt(mx,my);
      if(tid>=0) handleTerritoryClick(tid);
    });

    canvas.addEventListener('mousemove',(e)=>{
      const rect=canvas.getBoundingClientRect();
      const mx=(e.clientX-rect.left)*(W/rect.width);
      const my=(e.clientY-rect.top)*(H/rect.height);
      const tid=getTerritoryAt(mx,my);
      if(tid!==hoveredTerritory){
        hoveredTerritory=tid;
        if(gameState!=='menu') draw();
      }
    });

    canvas.addEventListener('mouseleave',()=>{
      hoveredTerritory=null;
      if(gameState!=='menu') draw();
    });

    /* ==================== GAME LOOP ==================== */
    function gameLoop(){
      if(gameState==='menu') drawMenuScreen();
      requestAnimationFrame(gameLoop);
    }

    function drawMenuScreen(){
      ctx.fillStyle='#1a1a2e';
      ctx.fillRect(0,0,W,H);

      const t=Date.now()/1000;
      for(let i=0;i<30;i++){
        const x=(Math.sin(t*0.3+i*1.7)*0.5+0.5)*W;
        const y=(Math.cos(t*0.2+i*2.3)*0.5+0.5)*H;
        const r=2+Math.sin(t+i)*1.5;
        ctx.fillStyle='rgba(204,68,68,'+(0.15+Math.sin(t+i)*0.1)+')';
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }

      for(let i=0;i<8;i++){
        const cx=80+i*65;
        const cy=200+Math.sin(t+i)*30;
        ctx.strokeStyle='rgba(204,68,68,'+(0.1+Math.sin(t*0.5+i)*0.05)+')';
        ctx.lineWidth=1;
        ctx.beginPath();
        for(let j=0;j<6;j++){
          const a=(Math.PI*2*j)/6;
          const px=cx+Math.cos(a)*25;
          const py=cy+Math.sin(a)*25;
          j===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }

    // Start
    overlay.addEventListener('click',()=>{
      if(gameState==='menu'){
        overlay.style.display='none';
        overlay.style.pointerEvents='none';
        initGame();
        draw();
      }
    });

    gameLoop();

    // Recorder
    if(typeof GameRecorder!=='undefined'){
      try{window._recorder=new GameRecorder(canvas);}catch(e){}
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower of Hanoi</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #8da; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 221, 170, 0.4); }
    h1 { color: #8da; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 221, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8da; }
    canvas {
      border: 2px solid #8da;
      box-shadow: 0 0 20px rgba(136, 221, 170, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8da;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; white-space: pre-line; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TOWER OF HANOI</h1>
  </div>
  <div class="score-bar">
    <div>Moves: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">TOWER OF HANOI</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const THEME = '#8da';
    const THEME_RGB = [136, 221, 170];

    // Disk colors - neon palette
    const DISK_COLORS = [
      '#f44', '#f80', '#ff0', '#0f0', '#0ff', '#48f', '#a4f', '#f08'
    ];

    // Peg geometry
    const PEG_WIDTH = 6;
    const BASE_Y = H - 50;
    const PEG_HEIGHT = 220;
    const PEG_TOP = BASE_Y - PEG_HEIGHT;
    const PEG_SPACING = W / 3;
    const PEG_X = [PEG_SPACING / 2, PEG_SPACING * 1.5, PEG_SPACING * 2.5];

    // Disk geometry
    const MAX_DISK_WIDTH = 120;
    const MIN_DISK_WIDTH = 30;
    const DISK_HEIGHT = 24;
    const DISK_GAP = 2;

    let score, best = 0, gameState;
    let pegs; // pegs[0], pegs[1], pegs[2] - arrays of disk sizes (bottom to top)
    let numDisks;
    let level;
    let selectedPeg; // index of peg from which a disk is picked up, or -1
    let heldDisk; // size of currently held disk, or -1
    let cursorPeg; // which peg the cursor is on (for keyboard nav)
    let invalidFlash; // {peg, timer} for flash animation
    let optimalMoves;
    let moveHistory;

    function init() {
      level = 1;
      numDisks = 3;
      best = best || 0;
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'TOWER OF HANOI';
      overlayText.textContent = 'Press SPACE to start\n3 disks - Arrow keys or 1/2/3';
      resetPuzzle();
      draw();
    }

    function resetPuzzle() {
      pegs = [[], [], []];
      for (let i = numDisks; i >= 1; i--) {
        pegs[0].push(i);
      }
      selectedPeg = -1;
      heldDisk = -1;
      cursorPeg = 0;
      invalidFlash = null;
      optimalMoves = Math.pow(2, numDisks) - 1;
      moveHistory = [];
      score = 0;
      scoreEl.textContent = '0';
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      resetPuzzle();
      draw();
    }

    function levelComplete() {
      // Score: higher is better. 1000 for optimal, decreasing for extra moves.
      const efficiency = optimalMoves / score;
      const levelScore = Math.max(10, Math.round(1000 * efficiency));

      if (levelScore > best) {
        best = levelScore;
        bestEl.textContent = best;
      }

      // Show completion overlay briefly, then advance
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LEVEL COMPLETE!';
      const rating = score === optimalMoves ? 'PERFECT!' :
                     score <= optimalMoves * 1.5 ? 'Great!' : 'Solved!';
      overlayText.textContent = `${rating} ${score} moves (optimal: ${optimalMoves})\nScore: ${levelScore} - Press SPACE for Level ${level + 1}`;
    }

    function advanceLevel() {
      level++;
      numDisks = Math.min(numDisks + 1, 8);
      resetPuzzle();
      gameState = 'playing';
      overlay.style.display = 'none';
      draw();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} - Press any key to restart`;
    }

    function getDiskWidth(size) {
      // size 1 = smallest, numDisks = largest
      const range = MAX_DISK_WIDTH - MIN_DISK_WIDTH;
      return MIN_DISK_WIDTH + (size - 1) / Math.max(1, numDisks - 1) * range;
    }

    function getDiskColor(size) {
      return DISK_COLORS[(size - 1) % DISK_COLORS.length];
    }

    function tryPickUp(pegIndex) {
      if (pegs[pegIndex].length === 0) {
        flashInvalid(pegIndex);
        return;
      }
      selectedPeg = pegIndex;
      heldDisk = pegs[pegIndex][pegs[pegIndex].length - 1];
      cursorPeg = pegIndex;
      draw();
    }

    function tryPlace(pegIndex) {
      if (selectedPeg === pegIndex) {
        // Put it back down
        selectedPeg = -1;
        heldDisk = -1;
        draw();
        return;
      }

      const topDisk = pegs[pegIndex].length > 0 ? pegs[pegIndex][pegs[pegIndex].length - 1] : Infinity;

      if (heldDisk > topDisk) {
        // Invalid move - can't place larger on smaller
        flashInvalid(pegIndex);
        return;
      }

      // Valid move
      pegs[selectedPeg].pop();
      pegs[pegIndex].push(heldDisk);
      score++;
      scoreEl.textContent = score;
      moveHistory.push({ from: selectedPeg, to: pegIndex });

      selectedPeg = -1;
      heldDisk = -1;
      cursorPeg = pegIndex;

      draw();

      // Check win: all disks on peg 2 (rightmost)
      if (pegs[2].length === numDisks) {
        levelComplete();
      }
    }

    function flashInvalid(pegIndex) {
      invalidFlash = { peg: pegIndex, timer: 20 };
      animateFlash();
    }

    function animateFlash() {
      if (!invalidFlash || invalidFlash.timer <= 0) {
        invalidFlash = null;
        draw();
        return;
      }
      invalidFlash.timer--;
      draw();
      requestAnimationFrame(animateFlash);
    }

    function handlePegAction(pegIndex) {
      if (gameState !== 'playing') return;

      if (heldDisk === -1) {
        tryPickUp(pegIndex);
      } else {
        tryPlace(pegIndex);
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw info bar at top
      ctx.fillStyle = '#888';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`Level ${level}  |  Disks: ${numDisks}  |  Optimal: ${optimalMoves} moves`, W / 2, 22);

      // Draw base
      ctx.fillStyle = '#0f3460';
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      const baseWidth = W - 40;
      const baseHeight = 8;
      ctx.fillRect((W - baseWidth) / 2, BASE_Y, baseWidth, baseHeight);
      ctx.shadowBlur = 0;

      // Draw pegs
      for (let i = 0; i < 3; i++) {
        const px = PEG_X[i];

        // Peg label
        ctx.fillStyle = cursorPeg === i && gameState === 'playing' ? THEME : '#555';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText((i + 1).toString(), px, BASE_Y + 28);

        // Peg pole
        const isFlashing = invalidFlash && invalidFlash.peg === i;
        const flashAlpha = isFlashing ? Math.sin(invalidFlash.timer * 0.8) * 0.5 + 0.5 : 0;

        if (isFlashing) {
          ctx.fillStyle = `rgba(255, 68, 68, ${0.3 + flashAlpha * 0.7})`;
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 15;
        } else if (cursorPeg === i && gameState === 'playing') {
          ctx.fillStyle = '#2a4a3e';
          ctx.shadowColor = THEME;
          ctx.shadowBlur = 8;
        } else {
          ctx.fillStyle = '#16213e';
          ctx.shadowBlur = 0;
        }

        ctx.fillRect(px - PEG_WIDTH / 2, PEG_TOP, PEG_WIDTH, PEG_HEIGHT);
        ctx.shadowBlur = 0;

        // Draw peg top cap
        ctx.fillStyle = cursorPeg === i && gameState === 'playing' ? THEME : '#0f3460';
        ctx.beginPath();
        ctx.arc(px, PEG_TOP, PEG_WIDTH / 2 + 2, 0, Math.PI * 2);
        ctx.fill();

        // Draw disks on this peg
        for (let j = 0; j < pegs[i].length; j++) {
          const diskSize = pegs[i][j];
          // Skip the held disk (top of selected peg)
          if (selectedPeg === i && j === pegs[i].length - 1) continue;

          const diskW = getDiskWidth(diskSize);
          const diskY = BASE_Y - (j + 1) * (DISK_HEIGHT + DISK_GAP);
          const diskX = px - diskW / 2;
          const color = getDiskColor(diskSize);

          drawDisk(diskX, diskY, diskW, DISK_HEIGHT, color);
        }
      }

      // Draw held disk floating above cursor peg
      if (heldDisk !== -1) {
        const px = PEG_X[cursorPeg];
        const diskW = getDiskWidth(heldDisk);
        const diskY = PEG_TOP - DISK_HEIGHT - 15;
        const diskX = px - diskW / 2;
        const color = getDiskColor(heldDisk);

        // Draw with extra glow
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        drawDisk(diskX, diskY, diskW, DISK_HEIGHT, color);
        ctx.shadowBlur = 0;

        // Draw down arrow indicator
        ctx.fillStyle = THEME;
        ctx.beginPath();
        ctx.moveTo(px, PEG_TOP - 4);
        ctx.lineTo(px - 6, PEG_TOP - 12);
        ctx.lineTo(px + 6, PEG_TOP - 12);
        ctx.closePath();
        ctx.fill();
      }

      // Draw instructions at bottom
      if (gameState === 'playing') {
        ctx.fillStyle = '#555';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        if (heldDisk === -1) {
          ctx.fillText('Press 1/2/3 or Arrow+Space to pick up a disk', W / 2, H - 12);
        } else {
          ctx.fillText('Press 1/2/3 or Arrow+Space to place the disk', W / 2, H - 12);
        }
      }
    }

    function drawDisk(x, y, w, h, color) {
      const radius = h / 2;

      // Neon glow
      ctx.shadowColor = color;
      ctx.shadowBlur = 12;

      // Main disk body with rounded corners
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.roundRect(x, y, w, h, radius);
      ctx.fill();

      // Highlight on top
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 2, w - 4, h / 2 - 2, [radius - 2, radius - 2, 0, 0]);
      ctx.fill();

      // Inner darker line for depth
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.beginPath();
      ctx.roundRect(x + 2, y + h / 2, w - 4, h / 2 - 2, [0, 0, radius - 2, radius - 2]);
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    // Mouse click handler
    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;

      // Determine which peg was clicked
      const pegIndex = x < PEG_SPACING ? 0 : x < PEG_SPACING * 2 ? 1 : 2;
      cursorPeg = pegIndex;
      handlePegAction(pegIndex);
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', '1', '2', '3'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ' || e.key === 'Enter') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        if (e.key === ' ' || e.key === 'Enter') {
          // Check if it was a level complete (advance) or game over (restart)
          if (overlayTitle.textContent === 'LEVEL COMPLETE!') {
            advanceLevel();
          } else {
            init();
          }
        } else {
          // Any other key
          if (overlayTitle.textContent === 'LEVEL COMPLETE!') {
            advanceLevel();
          } else {
            init();
          }
        }
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case '1':
            cursorPeg = 0;
            handlePegAction(0);
            break;
          case '2':
            cursorPeg = 1;
            handlePegAction(1);
            break;
          case '3':
            cursorPeg = 2;
            handlePegAction(2);
            break;
          case 'ArrowLeft':
            cursorPeg = Math.max(0, cursorPeg - 1);
            draw();
            break;
          case 'ArrowRight':
            cursorPeg = Math.min(2, cursorPeg + 1);
            draw();
            break;
          case ' ':
          case 'Enter':
            handlePegAction(cursorPeg);
            break;
          case 'u':
          case 'z':
            // Undo last move
            undoMove();
            break;
        }
      }
    });

    function undoMove() {
      if (moveHistory.length === 0) return;
      const lastMove = moveHistory.pop();
      const disk = pegs[lastMove.to].pop();
      pegs[lastMove.from].push(disk);
      score--;
      scoreEl.textContent = score;
      selectedPeg = -1;
      heldDisk = -1;
      draw();
    }

    // Expose game data for potential ML extraction
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        pegs: pegs.map(p => [...p]),
        numDisks,
        level,
        moves: score,
        optimalMoves,
        heldDisk,
        selectedPeg,
        cursorPeg
      };
    }

    // Wrap draw to also update gameData
    const _origDraw = draw;
    draw = function() {
      _origDraw();
      updateGameData();
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

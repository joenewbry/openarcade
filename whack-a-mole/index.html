<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whack-a-Mole</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #fc8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 204, 136, 0.4); }
    h1 { color: #fc8; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 204, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fc8; }
    canvas {
      border: 2px solid #fc8;
      box-shadow: 0 0 20px rgba(255, 204, 136, 0.2);
      display: block;
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="none" stroke="%23fc8" stroke-width="2"/><line x1="16" y1="8" x2="16" y2="24" stroke="%23fc8" stroke-width="2"/><line x1="8" y1="16" x2="24" y2="16" stroke="%23fc8" stroke-width="2"/></svg>') 16 16, crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fc8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WHACK-A-MOLE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">WHACK-A-MOLE</h2>
      <p id="overlayText">Click or press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Game globals (recorder contract)
    let score, best = 0, gameState;

    // Game constants
    const GRID_COLS = 3;
    const GRID_ROWS = 3;
    const HOLE_RX = 50;       // hole ellipse x radius
    const HOLE_RY = 20;       // hole ellipse y radius
    const MOLE_RADIUS = 30;   // mole head radius
    const GAME_DURATION = 60; // seconds

    // Grid layout
    const GRID_OFFSET_X = 80;
    const GRID_OFFSET_Y = 100;
    const CELL_W = (W - GRID_OFFSET_X * 2) / GRID_COLS;
    const CELL_H = (H - GRID_OFFSET_Y - 40) / GRID_ROWS;

    // Mole types
    const MOLE_NORMAL = 'normal';
    const MOLE_GOLDEN = 'golden';
    const MOLE_BOMB = 'bomb';

    // Mole state
    let holes = [];       // array of hole objects
    let timeLeft;         // seconds remaining
    let timerInterval;    // setInterval for countdown
    let effects = [];     // visual effects (whack text, stars)
    let missEffects = []; // miss click effects
    let lives;

    // Difficulty scaling
    let popInterval;      // ms between mole pops
    let popDuration;      // ms a mole stays up
    let popTimer;         // setTimeout for next pop
    let maxMolesUp;       // max simultaneous moles

    function getHoleCenter(row, col) {
      return {
        x: GRID_OFFSET_X + col * CELL_W + CELL_W / 2,
        y: GRID_OFFSET_Y + row * CELL_H + CELL_H / 2 + 30
      };
    }

    function init() {
      score = 0;
      lives = 3;
      timeLeft = GAME_DURATION;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'WHACK-A-MOLE';
      overlayText.textContent = 'Click or press SPACE to start';
      effects = [];
      missEffects = [];

      // Initialize holes
      holes = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const center = getHoleCenter(r, c);
          holes.push({
            row: r,
            col: c,
            cx: center.x,
            cy: center.y,
            moleUp: false,
            moleType: MOLE_NORMAL,
            moleTimer: null,
            popProgress: 0,   // 0 = hidden, 1 = fully up
            popDirection: 0,  // 1 = rising, -1 = sinking, 0 = idle
            whacked: false
          });
        }
      }

      // Reset difficulty
      popInterval = 1200;
      popDuration = 1800;
      maxMolesUp = 2;

      clearInterval(timerInterval);
      clearTimeout(popTimer);

      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';

      // Start countdown timer
      timerInterval = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          gameOver();
        }
        // Increase difficulty as time progresses
        const elapsed = GAME_DURATION - timeLeft;
        if (elapsed < 15) {
          popInterval = 1200;
          popDuration = 1800;
          maxMolesUp = 2;
        } else if (elapsed < 30) {
          popInterval = 900;
          popDuration = 1400;
          maxMolesUp = 3;
        } else if (elapsed < 45) {
          popInterval = 650;
          popDuration = 1100;
          maxMolesUp = 4;
        } else {
          popInterval = 450;
          popDuration = 800;
          maxMolesUp = 5;
        }
      }, 1000);

      // Start popping moles
      schedulePop();
      requestAnimationFrame(loop);
    }

    function schedulePop() {
      if (gameState !== 'playing') return;
      const jitter = popInterval * 0.4;
      const delay = popInterval + (Math.random() * jitter * 2 - jitter);
      popTimer = setTimeout(() => {
        popMole();
        schedulePop();
      }, Math.max(200, delay));
    }

    function popMole() {
      if (gameState !== 'playing') return;

      // Count current moles up
      const molesUp = holes.filter(h => h.moleUp && !h.whacked).length;
      if (molesUp >= maxMolesUp) return;

      // Find available holes (not currently showing a mole)
      const available = holes.filter(h => !h.moleUp && h.popProgress === 0);
      if (available.length === 0) return;

      const hole = available[Math.floor(Math.random() * available.length)];

      // Determine mole type
      const rand = Math.random();
      if (rand < 0.05) {
        hole.moleType = MOLE_GOLDEN;
      } else if (rand < 0.18) {
        hole.moleType = MOLE_BOMB;
      } else {
        hole.moleType = MOLE_NORMAL;
      }

      hole.moleUp = true;
      hole.whacked = false;
      hole.popDirection = 1;   // start rising

      // Schedule this mole to go back down
      const duration = popDuration + (Math.random() * 400 - 200);
      hole.moleTimer = setTimeout(() => {
        if (hole.moleUp && !hole.whacked) {
          hole.popDirection = -1; // start sinking
        }
      }, duration);
    }

    function gameOver() {
      gameState = 'over';
      clearInterval(timerInterval);
      clearTimeout(popTimer);

      // Clear all mole timers
      holes.forEach(h => {
        clearTimeout(h.moleTimer);
        h.moleUp = false;
        h.popProgress = 0;
        h.popDirection = 0;
      });

      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Click or press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Animate mole pop progress
      const popSpeed = 0.08;
      holes.forEach(h => {
        if (h.popDirection === 1) {
          h.popProgress = Math.min(1, h.popProgress + popSpeed);
          if (h.popProgress >= 1) h.popDirection = 0; // fully up, wait
        } else if (h.popDirection === -1) {
          h.popProgress = Math.max(0, h.popProgress - popSpeed);
          if (h.popProgress <= 0) {
            h.popDirection = 0;
            h.moleUp = false;
            h.whacked = false;
          }
        }
      });

      // Update effects
      for (let i = effects.length - 1; i >= 0; i--) {
        effects[i].life -= 0.02;
        effects[i].y -= 0.8;
        if (effects[i].life <= 0) effects.splice(i, 1);
      }
      for (let i = missEffects.length - 1; i >= 0; i--) {
        missEffects[i].life -= 0.03;
        if (missEffects[i].life <= 0) missEffects.splice(i, 1);
      }

      // Update gameData for ML
      window.gameData = {
        score: score,
        timeLeft: timeLeft,
        lives: lives,
        holes: holes.map(h => ({
          row: h.row, col: h.col,
          moleUp: h.moleUp, moleType: h.moleType,
          whacked: h.whacked, popProgress: h.popProgress
        }))
      };
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grass/ground area
      const groundGrad = ctx.createLinearGradient(0, 60, 0, H);
      groundGrad.addColorStop(0, '#1a2a1e');
      groundGrad.addColorStop(1, '#0f1a12');
      ctx.fillStyle = groundGrad;
      ctx.beginPath();
      ctx.roundRect(20, 60, W - 40, H - 80, 16);
      ctx.fill();

      // Draw grid lines (subtle)
      ctx.strokeStyle = '#1a3a1e';
      ctx.lineWidth = 1;
      for (let c = 1; c < GRID_COLS; c++) {
        const x = GRID_OFFSET_X + c * CELL_W;
        ctx.beginPath();
        ctx.moveTo(x, 70);
        ctx.lineTo(x, H - 30);
        ctx.stroke();
      }
      for (let r = 1; r < GRID_ROWS; r++) {
        const y = GRID_OFFSET_Y + r * CELL_H;
        ctx.beginPath();
        ctx.moveTo(30, y);
        ctx.lineTo(W - 30, y);
        ctx.stroke();
      }

      // Draw holes and moles
      holes.forEach(h => {
        drawHoleAndMole(h);
      });

      // Draw effects
      effects.forEach(e => {
        ctx.save();
        ctx.globalAlpha = e.life;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        if (e.type === 'whack') {
          ctx.fillStyle = '#fc8';
          ctx.shadowColor = '#fc8';
          ctx.shadowBlur = 10;
          ctx.fillText('WHACK!', e.x, e.y);
        } else if (e.type === 'golden') {
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 10;
          ctx.fillText('+50!', e.x, e.y);
        } else if (e.type === 'bomb') {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 10;
          ctx.fillText('OUCH! -20', e.x, e.y);
        }
        ctx.shadowBlur = 0;

        // Draw star particles
        if (e.stars) {
          e.stars.forEach(s => {
            const sx = e.x + s.dx * (1 - e.life) * 3;
            const sy = e.y + s.dy * (1 - e.life) * 3;
            ctx.fillStyle = s.color;
            ctx.shadowColor = s.color;
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(sx, sy, s.size * e.life, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        ctx.shadowBlur = 0;
        ctx.restore();
      });

      // Draw miss effects (red X)
      missEffects.forEach(e => {
        ctx.save();
        ctx.globalAlpha = e.life * 0.6;
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 6;
        const s = 12;
        ctx.beginPath();
        ctx.moveTo(e.x - s, e.y - s);
        ctx.lineTo(e.x + s, e.y + s);
        ctx.moveTo(e.x + s, e.y - s);
        ctx.lineTo(e.x - s, e.y + s);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();
      });

      // Draw HUD (timer and lives)
      drawHUD();
    }

    function drawHoleAndMole(h) {
      const cx = h.cx;
      const cy = h.cy;

      // Draw dirt mound behind hole
      ctx.fillStyle = '#2a1a0a';
      ctx.beginPath();
      ctx.ellipse(cx, cy + 8, HOLE_RX + 8, HOLE_RY + 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Draw mole (behind the hole front)
      if (h.popProgress > 0) {
        const moleRise = h.popProgress * (MOLE_RADIUS * 2 + 10);
        const moleY = cy - moleRise + MOLE_RADIUS;

        ctx.save();
        // Clip to only show mole above the hole
        ctx.beginPath();
        ctx.rect(cx - HOLE_RX - 5, 0, (HOLE_RX + 5) * 2, cy - 2);
        ctx.clip();

        // Mole body color based on type
        let bodyColor, glowColor;
        if (h.moleType === MOLE_GOLDEN) {
          bodyColor = '#ffd700';
          glowColor = '#ffd700';
        } else if (h.moleType === MOLE_BOMB) {
          bodyColor = '#c03030';
          glowColor = '#f44';
        } else {
          bodyColor = '#8B6914';
          glowColor = '#a07820';
        }

        // Mole body (oval)
        ctx.fillStyle = bodyColor;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = h.moleType === MOLE_GOLDEN ? 16 : (h.moleType === MOLE_BOMB ? 12 : 4);
        ctx.beginPath();
        ctx.ellipse(cx, moleY, MOLE_RADIUS, MOLE_RADIUS * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Lighter belly
        const bellyColor = h.moleType === MOLE_GOLDEN ? '#ffe44d' :
                           h.moleType === MOLE_BOMB ? '#e05050' : '#c89830';
        ctx.fillStyle = bellyColor;
        ctx.beginPath();
        ctx.ellipse(cx, moleY + 6, MOLE_RADIUS * 0.6, MOLE_RADIUS * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        if (h.whacked) {
          // X eyes when whacked
          ctx.strokeStyle = '#111';
          ctx.lineWidth = 2;
          const eyeSize = 4;
          // Left eye X
          ctx.beginPath();
          ctx.moveTo(cx - 10 - eyeSize, moleY - 8 - eyeSize);
          ctx.lineTo(cx - 10 + eyeSize, moleY - 8 + eyeSize);
          ctx.moveTo(cx - 10 + eyeSize, moleY - 8 - eyeSize);
          ctx.lineTo(cx - 10 - eyeSize, moleY - 8 + eyeSize);
          ctx.stroke();
          // Right eye X
          ctx.beginPath();
          ctx.moveTo(cx + 10 - eyeSize, moleY - 8 - eyeSize);
          ctx.lineTo(cx + 10 + eyeSize, moleY - 8 + eyeSize);
          ctx.moveTo(cx + 10 + eyeSize, moleY - 8 - eyeSize);
          ctx.lineTo(cx + 10 - eyeSize, moleY - 8 + eyeSize);
          ctx.stroke();
        } else {
          // Normal eyes
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(cx - 10, moleY - 8, 6, 0, Math.PI * 2);
          ctx.arc(cx + 10, moleY - 8, 6, 0, Math.PI * 2);
          ctx.fill();
          // Pupils
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(cx - 10, moleY - 7, 3, 0, Math.PI * 2);
          ctx.arc(cx + 10, moleY - 7, 3, 0, Math.PI * 2);
          ctx.fill();

          if (h.moleType === MOLE_BOMB) {
            // Angry eyebrows for bomb
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 16, moleY - 16);
            ctx.lineTo(cx - 6, moleY - 13);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + 16, moleY - 16);
            ctx.lineTo(cx + 6, moleY - 13);
            ctx.stroke();
          }
        }

        // Nose
        ctx.fillStyle = h.moleType === MOLE_BOMB ? '#300' : '#d4783a';
        ctx.beginPath();
        ctx.arc(cx, moleY - 1, 4, 0, Math.PI * 2);
        ctx.fill();

        // Golden mole sparkle
        if (h.moleType === MOLE_GOLDEN && !h.whacked) {
          const sparkTime = Date.now() * 0.005;
          for (let i = 0; i < 3; i++) {
            const angle = sparkTime + i * (Math.PI * 2 / 3);
            const sx = cx + Math.cos(angle) * 22;
            const sy = moleY - 8 + Math.sin(angle) * 16;
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 8;
            drawStar(sx, sy, 3, 0.5);
            ctx.shadowBlur = 0;
          }
        }

        // Bomb mole fuse
        if (h.moleType === MOLE_BOMB && !h.whacked) {
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cx, moleY - MOLE_RADIUS * 1.1);
          ctx.quadraticCurveTo(cx + 8, moleY - MOLE_RADIUS * 1.4, cx + 4, moleY - MOLE_RADIUS * 1.6);
          ctx.stroke();
          // Fuse spark
          const sparkFlicker = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
          ctx.fillStyle = `rgba(255, ${Math.floor(150 * sparkFlicker)}, 0, ${sparkFlicker})`;
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(cx + 4, moleY - MOLE_RADIUS * 1.6, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        ctx.restore();
      }

      // Draw hole (front half - covers bottom of mole)
      ctx.fillStyle = '#0a0a0a';
      ctx.beginPath();
      ctx.ellipse(cx, cy, HOLE_RX, HOLE_RY, 0, 0, Math.PI * 2);
      ctx.fill();

      // Hole rim
      ctx.strokeStyle = '#3a2a10';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(cx, cy, HOLE_RX, HOLE_RY, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Hole highlight (top arc)
      ctx.strokeStyle = '#5a3a18';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(cx, cy - 2, HOLE_RX - 4, HOLE_RY - 3, 0, Math.PI, Math.PI * 2);
      ctx.stroke();
    }

    function drawStar(x, y, size, innerRatio) {
      const spikes = 4;
      const outerR = size;
      const innerR = size * innerRatio;
      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
        const sx = x + Math.cos(angle) * r;
        const sy = y + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
      ctx.fill();
    }

    function drawHUD() {
      // Timer bar background
      ctx.fillStyle = '#16213e';
      ctx.beginPath();
      ctx.roundRect(30, 20, W - 60, 26, 6);
      ctx.fill();

      // Timer bar fill
      const timerFrac = Math.max(0, timeLeft / GAME_DURATION);
      let barColor;
      if (timerFrac > 0.5) barColor = '#fc8';
      else if (timerFrac > 0.2) barColor = '#f80';
      else barColor = '#f44';

      ctx.fillStyle = barColor;
      ctx.shadowColor = barColor;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.roundRect(32, 22, (W - 64) * timerFrac, 22, 5);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Timer text
      ctx.fillStyle = '#e0e0e0';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${timeLeft}s`, W / 2, 33);

      // Lives display
      ctx.textAlign = 'left';
      ctx.font = '14px Courier New';
      ctx.fillStyle = '#fc8';
      let livesText = '';
      for (let i = 0; i < lives; i++) livesText += '\u2665 ';
      ctx.fillText(livesText.trim(), 35, H - 18);

      // Score on canvas too (for frame captures)
      ctx.textAlign = 'right';
      ctx.fillStyle = '#fc8';
      ctx.shadowColor = '#fc8';
      ctx.shadowBlur = 6;
      ctx.font = 'bold 16px Courier New';
      ctx.fillText(`Score: ${score}`, W - 35, H - 18);
      ctx.shadowBlur = 0;
    }

    function whackMole(hole) {
      if (hole.whacked || !hole.moleUp) return;

      hole.whacked = true;
      clearTimeout(hole.moleTimer);

      if (hole.moleType === MOLE_BOMB) {
        // Penalty for hitting bomb
        score = Math.max(0, score - 20);
        lives--;
        scoreEl.textContent = score;
        addEffect(hole.cx, hole.cy - 40, 'bomb');

        if (lives <= 0) {
          gameOver();
          return;
        }
      } else if (hole.moleType === MOLE_GOLDEN) {
        score += 50;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        addEffect(hole.cx, hole.cy - 40, 'golden');
      } else {
        score += 10;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        addEffect(hole.cx, hole.cy - 40, 'whack');
      }

      // Mole sinks after being whacked (short delay then sink)
      setTimeout(() => {
        hole.popDirection = -1;
      }, 200);
    }

    function addEffect(x, y, type) {
      const stars = [];
      const starCount = type === 'golden' ? 10 : (type === 'bomb' ? 6 : 5);
      for (let i = 0; i < starCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 15 + Math.random() * 25;
        let color;
        if (type === 'golden') color = Math.random() > 0.5 ? '#ffd700' : '#fff';
        else if (type === 'bomb') color = Math.random() > 0.5 ? '#f44' : '#f80';
        else color = Math.random() > 0.5 ? '#fc8' : '#fff';
        stars.push({
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          size: 2 + Math.random() * 3,
          color: color
        });
      }
      effects.push({ x, y, type, life: 1.0, stars });
    }

    // Mouse click handler
    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      let hitSomething = false;

      holes.forEach(h => {
        if (!h.moleUp || h.whacked || h.popProgress < 0.3) return;

        // Check if click is on the mole
        const moleRise = h.popProgress * (MOLE_RADIUS * 2 + 10);
        const moleY = h.cy - moleRise + MOLE_RADIUS;
        const dx = mx - h.cx;
        const dy = my - moleY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < MOLE_RADIUS + 10) {
          whackMole(h);
          hitSomething = true;
        }
      });

      if (!hitSomething) {
        // Miss effect
        missEffects.push({ x: mx, y: my, life: 1.0 });
      }
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

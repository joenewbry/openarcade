<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battleship Evolved</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #4af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 255, 0.5); }
    h1 { color: #4af; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4af; }
    canvas {
      border: 2px solid #4af;
      box-shadow: 0 0 20px rgba(68, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BATTLESHIP EVOLVED</h1>
  </div>
  <div class="score-bar">
    <div>Hits: <span id="score">0</span> | Ships: <span id="playerShips">5</span></div>
    <div>AI Hits: <span id="aiScore">0</span> | Ships: <span id="aiShips">5</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">BATTLESHIP EVOLVED</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const playerShipsEl = document.getElementById('playerShips');
    const aiShipsEl = document.getElementById('aiShips');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const GRID_SIZE = 10;
    const CELL = 20;
    const GRID_PX = GRID_SIZE * CELL; // 200px
    const LABEL_W = 14; // width for row labels
    const LABEL_H = 14; // height for column labels
    const GRID_TOTAL_W = LABEL_W + GRID_PX; // total width including labels
    const GRID_TOTAL_H = LABEL_H + GRID_PX;

    // Layout positions
    const HEADER_H = 36; // status text area at top of canvas
    const GAP = 500 - 2 * GRID_TOTAL_W; // gap between grids
    const LEFT_GRID_X = Math.floor((500 - 2 * GRID_TOTAL_W - 20) / 2); // margin
    const RIGHT_GRID_X = LEFT_GRID_X + GRID_TOTAL_W + 20;
    const GRID_Y = HEADER_H + 8;

    // Ship definitions
    const SHIP_DEFS = [
      { name: 'Carrier',    size: 5, color: '#4af' },
      { name: 'Battleship', size: 4, color: '#48d' },
      { name: 'Cruiser',    size: 3, color: '#3ae' },
      { name: 'Submarine',  size: 3, color: '#2ad' },
      { name: 'Destroyer',  size: 2, color: '#5bf' }
    ];

    // Cell states
    const EMPTY = 0;
    const SHIP = 1;
    const HIT = 2;
    const MISS = 3;
    const SUNK = 4;

    let gameState; // 'waiting', 'playing', 'over'
    let score;

    // Player data
    let playerGrid;      // 10x10 grid of cell states
    let playerShips;     // array of placed ship objects
    let playerShipsSunk;

    // AI data
    let aiGrid;          // 10x10 grid of cell states
    let aiShips;         // array of placed ship objects
    let aiShipsSunk;

    // Placement state
    let placingIndex;    // which ship we're placing (0-4)
    let placingHoriz;    // true = horizontal
    let hoverR, hoverC;  // current hover cell on player grid
    let hoverValid;      // is current hover position valid

    // AI targeting state
    let aiHits;          // grid tracking AI's shots at player: 0=unknown, HIT, MISS
    let aiTargetStack;   // cells to try next (hunt/target)
    let aiFirstHit;      // first hit in current target chain
    let aiHitChain;      // list of hits in current targeting sequence
    let aiMode;          // 'hunt' or 'target'

    // Battle state
    let playerTotalShots;
    let aiTotalShots;
    let playerHits;
    let aiHitsCount;
    let statusText;
    let animating;
    let lastAiShotR, lastAiShotC, lastAiResult;

    // Hover on AI grid
    let aimR, aimC;

    // Explosions
    let explosions;

    // Internal phase tracking (gameState stays 'playing' for recorder)
    let phase; // 'placing', 'playerTurn', 'aiTurn'

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    function createGrid() {
      const g = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        g[r] = [];
        for (let c = 0; c < GRID_SIZE; c++) {
          g[r][c] = EMPTY;
        }
      }
      return g;
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      playerShipsEl.textContent = '5';
      aiShipsEl.textContent = '5';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BATTLESHIP EVOLVED';
      overlayText.textContent = 'Click to Start';

      playerGrid = createGrid();
      aiGrid = createGrid();
      playerShips = [];
      aiShips = [];
      playerShipsSunk = 0;
      aiShipsSunk = 0;

      placingIndex = 0;
      placingHoriz = true;
      hoverR = -1; hoverC = -1;
      hoverValid = false;

      aiHits = createGrid();
      aiTargetStack = [];
      aiFirstHit = null;
      aiHitChain = [];
      aiMode = 'hunt';

      playerTotalShots = 0;
      aiTotalShots = 0;
      playerHits = 0;
      aiHitsCount = 0;
      statusText = '';
      animating = false;
      lastAiShotR = -1; lastAiShotC = -1; lastAiResult = '';
      aimR = -1; aimC = -1;
      explosions = [];

      draw();
    }

    function startPlacement() {
      gameState = 'playing';
      phase = 'placing';
      overlay.style.display = 'none';
      placingIndex = 0;
      placingHoriz = true;
      statusText = 'Place ' + SHIP_DEFS[0].name + ' (' + SHIP_DEFS[0].size + ') - R to rotate';
      draw();
    }

    // Ship placement validation
    function canPlaceShip(grid, r, c, size, horiz) {
      for (let i = 0; i < size; i++) {
        const cr = horiz ? r : r + i;
        const cc = horiz ? c + i : c;
        if (cr < 0 || cr >= GRID_SIZE || cc < 0 || cc >= GRID_SIZE) return false;
        if (grid[cr][cc] !== EMPTY) return false;
      }
      return true;
    }

    function placeShip(grid, ships, r, c, size, horiz, defIndex) {
      const cells = [];
      for (let i = 0; i < size; i++) {
        const cr = horiz ? r : r + i;
        const cc = horiz ? c + i : c;
        grid[cr][cc] = SHIP;
        cells.push({ r: cr, c: cc });
      }
      ships.push({ defIndex, cells, sunk: false });
    }

    function placeAIShips() {
      for (let i = 0; i < SHIP_DEFS.length; i++) {
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 1000) {
          const horiz = Math.random() < 0.5;
          const r = Math.floor(Math.random() * GRID_SIZE);
          const c = Math.floor(Math.random() * GRID_SIZE);
          if (canPlaceShip(aiGrid, r, c, SHIP_DEFS[i].size, horiz)) {
            placeShip(aiGrid, aiShips, r, c, SHIP_DEFS[i].size, horiz, i);
            placed = true;
          }
          attempts++;
        }
      }
    }

    // Get grid cell from mouse position
    function getGridCell(mx, my, gridX, gridY) {
      const x = mx - gridX - LABEL_W;
      const y = my - gridY - LABEL_H;
      if (x < 0 || y < 0 || x >= GRID_PX || y >= GRID_PX) return null;
      return { r: Math.floor(y / CELL), c: Math.floor(x / CELL) };
    }

    // Check if a ship is sunk
    function checkShipSunk(grid, ship) {
      return ship.cells.every(cell => grid[cell.r][cell.c] === HIT || grid[cell.r][cell.c] === SUNK);
    }

    function markShipSunk(grid, ship) {
      ship.sunk = true;
      ship.cells.forEach(cell => {
        grid[cell.r][cell.c] = SUNK;
      });
    }

    // Player fires at AI grid
    function playerFire(r, c) {
      if (aiGrid[r][c] === HIT || aiGrid[r][c] === MISS || aiGrid[r][c] === SUNK) return false;

      playerTotalShots++;
      if (aiGrid[r][c] === SHIP) {
        aiGrid[r][c] = HIT;
        playerHits++;
        score = playerHits;
        scoreEl.textContent = score;

        // Check if any ship sunk
        for (const ship of aiShips) {
          if (!ship.sunk && checkShipSunk(aiGrid, ship)) {
            markShipSunk(aiGrid, ship);
            aiShipsSunk++;
            aiShipsEl.textContent = 5 - aiShipsSunk;
            addExplosion(RIGHT_GRID_X + LABEL_W + c * CELL + CELL / 2,
                         GRID_Y + LABEL_H + r * CELL + CELL / 2, true);
            statusText = 'You sank the ' + SHIP_DEFS[ship.defIndex].name + '!';
            if (aiShipsSunk >= 5) {
              gameOver(true);
              return true;
            }
            return true;
          }
        }
        addExplosion(RIGHT_GRID_X + LABEL_W + c * CELL + CELL / 2,
                     GRID_Y + LABEL_H + r * CELL + CELL / 2, false);
        statusText = 'HIT!';
      } else {
        aiGrid[r][c] = MISS;
        statusText = 'Miss...';
      }
      return true;
    }

    // AI probability-based targeting
    function computeProbabilityMap() {
      const prob = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        prob[r] = [];
        for (let c = 0; c < GRID_SIZE; c++) {
          prob[r][c] = 0;
        }
      }

      // For each remaining (unsunk) ship, count how many valid placements include each cell
      for (const ship of playerShips) {
        if (ship.sunk) continue;
        const size = SHIP_DEFS[ship.defIndex].size;

        // Try horizontal
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c <= GRID_SIZE - size; c++) {
            let valid = true;
            let hasHit = false;
            for (let i = 0; i < size; i++) {
              const state = aiHits[r][c + i];
              if (state === MISS || state === SUNK) { valid = false; break; }
              if (state === HIT) hasHit = true;
            }
            if (valid) {
              // Weight higher if placement includes a known hit
              const weight = hasHit ? 20 : 1;
              for (let i = 0; i < size; i++) {
                if (aiHits[r][c + i] === 0) {
                  prob[r][c + i] += weight;
                }
              }
            }
          }
        }

        // Try vertical
        for (let r = 0; r <= GRID_SIZE - size; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            let valid = true;
            let hasHit = false;
            for (let i = 0; i < size; i++) {
              const state = aiHits[r + i][c];
              if (state === MISS || state === SUNK) { valid = false; break; }
              if (state === HIT) hasHit = true;
            }
            if (valid) {
              const weight = hasHit ? 20 : 1;
              for (let i = 0; i < size; i++) {
                if (aiHits[r + i][c] === 0) {
                  prob[r + i][c] += weight;
                }
              }
            }
          }
        }
      }

      // Checkerboard bonus in hunt mode (ships of length >= 2 always cross a checkerboard)
      if (aiMode === 'hunt') {
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            if ((r + c) % 2 === 0 && prob[r][c] > 0) {
              prob[r][c] += 2;
            }
          }
        }
      }

      return prob;
    }

    function aiFire() {
      let r, c;

      if (aiMode === 'target' && aiTargetStack.length > 0) {
        // Target mode: try cells from target stack
        let found = false;
        while (aiTargetStack.length > 0 && !found) {
          const target = aiTargetStack.pop();
          if (target.r >= 0 && target.r < GRID_SIZE &&
              target.c >= 0 && target.c < GRID_SIZE &&
              aiHits[target.r][target.c] === 0) {
            r = target.r;
            c = target.c;
            found = true;
          }
        }
        if (!found) {
          // Fall back to hunt
          aiMode = 'hunt';
          aiTargetStack = [];
          aiHitChain = [];
        }
      }

      if (aiMode === 'hunt' || r === undefined) {
        // Hunt mode: use probability map
        const prob = computeProbabilityMap();
        let maxProb = -1;
        const candidates = [];
        for (let rr = 0; rr < GRID_SIZE; rr++) {
          for (let cc = 0; cc < GRID_SIZE; cc++) {
            if (aiHits[rr][cc] !== 0) continue;
            if (prob[rr][cc] > maxProb) {
              maxProb = prob[rr][cc];
              candidates.length = 0;
              candidates.push({ r: rr, c: cc });
            } else if (prob[rr][cc] === maxProb) {
              candidates.push({ r: rr, c: cc });
            }
          }
        }
        if (candidates.length === 0) return; // shouldn't happen
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        r = pick.r;
        c = pick.c;
      }

      aiTotalShots++;
      lastAiShotR = r;
      lastAiShotC = c;

      if (playerGrid[r][c] === SHIP) {
        playerGrid[r][c] = HIT;
        aiHits[r][c] = HIT;
        aiHitsCount++;
        aiScoreEl.textContent = aiHitsCount;

        // Add to hit chain
        aiHitChain.push({ r, c });
        if (aiMode === 'hunt') {
          aiFirstHit = { r, c };
          aiMode = 'target';
          aiHitChain = [{ r, c }];
        }

        // Check sunk
        let sunkShip = null;
        for (const ship of playerShips) {
          if (!ship.sunk && checkShipSunk(playerGrid, ship)) {
            markShipSunk(playerGrid, ship);
            ship.cells.forEach(cell => { aiHits[cell.r][cell.c] = SUNK; });
            playerShipsSunk++;
            playerShipsEl.textContent = 5 - playerShipsSunk;
            sunkShip = ship;
            break;
          }
        }

        if (sunkShip) {
          addExplosion(LEFT_GRID_X + LABEL_W + c * CELL + CELL / 2,
                       GRID_Y + LABEL_H + r * CELL + CELL / 2, true);
          lastAiResult = 'sunk';

          // Clear target state - go back to hunt
          aiTargetStack = [];
          aiHitChain = [];
          aiFirstHit = null;

          // Check if any unsunk hits remain (from a different ship)
          let hasUnsunkHit = false;
          for (let rr = 0; rr < GRID_SIZE; rr++) {
            for (let cc = 0; cc < GRID_SIZE; cc++) {
              if (aiHits[rr][cc] === HIT) {
                hasUnsunkHit = true;
                aiFirstHit = { r: rr, c: cc };
                aiHitChain = [{ r: rr, c: cc }];
                break;
              }
            }
            if (hasUnsunkHit) break;
          }

          if (hasUnsunkHit) {
            aiMode = 'target';
            buildTargetStack();
          } else {
            aiMode = 'hunt';
          }

          if (playerShipsSunk >= 5) {
            gameOver(false);
            return;
          }
        } else {
          lastAiResult = 'hit';
          addExplosion(LEFT_GRID_X + LABEL_W + c * CELL + CELL / 2,
                       GRID_Y + LABEL_H + r * CELL + CELL / 2, false);
          // Build target stack based on hit chain direction
          buildTargetStack();
        }
      } else {
        playerGrid[r][c] = MISS;
        aiHits[r][c] = MISS;
        lastAiResult = 'miss';

        // If in target mode and stack is empty, check for remaining hits
        if (aiMode === 'target' && aiTargetStack.length === 0) {
          // Try reversing direction or fall back to hunt
          if (aiHitChain.length > 0) {
            buildTargetStack();
            if (aiTargetStack.length === 0) {
              aiMode = 'hunt';
              aiHitChain = [];
              aiFirstHit = null;
            }
          } else {
            aiMode = 'hunt';
          }
        }
      }
    }

    function buildTargetStack() {
      aiTargetStack = [];
      if (aiHitChain.length === 1) {
        // Try all 4 adjacent cells
        const h = aiHitChain[0];
        const dirs = [
          { r: h.r - 1, c: h.c },
          { r: h.r + 1, c: h.c },
          { r: h.r, c: h.c - 1 },
          { r: h.r, c: h.c + 1 }
        ];
        // Shuffle for variety
        for (let i = dirs.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }
        for (const d of dirs) {
          if (d.r >= 0 && d.r < GRID_SIZE && d.c >= 0 && d.c < GRID_SIZE && aiHits[d.r][d.c] === 0) {
            aiTargetStack.push(d);
          }
        }
      } else if (aiHitChain.length >= 2) {
        // Determine direction (horizontal or vertical)
        const isHoriz = aiHitChain[0].r === aiHitChain[1].r;
        if (isHoriz) {
          const row = aiHitChain[0].r;
          let minC = GRID_SIZE, maxC = -1;
          for (const h of aiHitChain) {
            if (h.c < minC) minC = h.c;
            if (h.c > maxC) maxC = h.c;
          }
          // Extend in both directions along the row
          if (minC - 1 >= 0 && aiHits[row][minC - 1] === 0) {
            aiTargetStack.push({ r: row, c: minC - 1 });
          }
          if (maxC + 1 < GRID_SIZE && aiHits[row][maxC + 1] === 0) {
            aiTargetStack.push({ r: row, c: maxC + 1 });
          }
        } else {
          const col = aiHitChain[0].c;
          let minR = GRID_SIZE, maxR = -1;
          for (const h of aiHitChain) {
            if (h.r < minR) minR = h.r;
            if (h.r > maxR) maxR = h.r;
          }
          if (minR - 1 >= 0 && aiHits[minR - 1][col] === 0) {
            aiTargetStack.push({ r: minR - 1, c: col });
          }
          if (maxR + 1 < GRID_SIZE && aiHits[maxR + 1][col] === 0) {
            aiTargetStack.push({ r: maxR + 1, c: col });
          }
        }

        // If no valid extensions, try perpendicular from first hit
        if (aiTargetStack.length === 0 && aiFirstHit) {
          aiHitChain = [aiFirstHit];
          buildTargetStack();
        }
      }
    }

    function addExplosion(x, y, big) {
      explosions.push({
        x, y,
        radius: big ? 20 : 12,
        maxRadius: big ? 30 : 18,
        alpha: 1,
        big
      });
    }

    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.radius += 0.8;
        e.alpha -= 0.03;
        if (e.alpha <= 0) {
          explosions.splice(i, 1);
        }
      }
    }

    function gameOver(playerWon) {
      gameState = 'over';
      overlay.style.display = 'flex';
      if (playerWon) {
        const efficiency = Math.max(0, Math.round((playerHits / playerTotalShots) * 100));
        score = playerHits * 10 + efficiency;
        scoreEl.textContent = playerHits;
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = 'Hits: ' + playerHits + '/' + playerTotalShots + ' shots (' + efficiency + '% accuracy) - Click to play again';
      } else {
        overlayTitle.textContent = 'DEFEAT';
        overlayText.textContent = 'AI sank your fleet in ' + aiTotalShots + ' shots - Click to play again';
      }
      draw();
    }

    // Mouse handlers
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (phase === 'placing') {
        const cell = getGridCell(mx, my, LEFT_GRID_X, GRID_Y);
        if (cell) {
          hoverR = cell.r;
          hoverC = cell.c;
          hoverValid = canPlaceShip(playerGrid, cell.r, cell.c, SHIP_DEFS[placingIndex].size, placingHoriz);
        } else {
          hoverR = -1; hoverC = -1;
          hoverValid = false;
        }
        draw();
      } else if (phase === 'playerTurn') {
        const cell = getGridCell(mx, my, RIGHT_GRID_X, GRID_Y);
        if (cell && aiGrid[cell.r][cell.c] !== HIT && aiGrid[cell.r][cell.c] !== MISS && aiGrid[cell.r][cell.c] !== SUNK) {
          aimR = cell.r;
          aimC = cell.c;
        } else {
          aimR = -1; aimC = -1;
        }
        draw();
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;

      if (gameState === 'waiting') {
        startPlacement();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (phase === 'placing') {
        const cell = getGridCell(mx, my, LEFT_GRID_X, GRID_Y);
        if (cell && canPlaceShip(playerGrid, cell.r, cell.c, SHIP_DEFS[placingIndex].size, placingHoriz)) {
          placeShip(playerGrid, playerShips, cell.r, cell.c, SHIP_DEFS[placingIndex].size, placingHoriz, placingIndex);
          placingIndex++;
          if (placingIndex >= SHIP_DEFS.length) {
            // All ships placed, start battle
            placeAIShips();
            phase = 'playerTurn';
            statusText = 'YOUR TURN - Fire at the enemy grid!';
          } else {
            statusText = 'Place ' + SHIP_DEFS[placingIndex].name + ' (' + SHIP_DEFS[placingIndex].size + ') - R to rotate';
          }
          draw();
        }
        return;
      }

      if (phase === 'playerTurn') {
        const cell = getGridCell(mx, my, RIGHT_GRID_X, GRID_Y);
        if (cell) {
          const fired = playerFire(cell.r, cell.c);
          if (fired && gameState !== 'over') {
            // AI turn after short delay
            phase = 'aiTurn';
            statusText = 'AI TARGETING...';
            draw();
            setTimeout(() => {
              if (gameState !== 'over') {
                aiFire();
                if (gameState !== 'over') {
                  phase = 'playerTurn';
                  if (lastAiResult === 'sunk') {
                    statusText = 'AI sank your ship! YOUR TURN';
                  } else if (lastAiResult === 'hit') {
                    statusText = 'AI hit! YOUR TURN';
                  } else {
                    statusText = 'AI missed. YOUR TURN';
                  }
                }
                draw();
              }
            }, 600);
          }
          draw();
        }
        return;
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        if (phase === 'placing') {
          placingHoriz = !placingHoriz;
          if (hoverR >= 0 && hoverC >= 0) {
            hoverValid = canPlaceShip(playerGrid, hoverR, hoverC, SHIP_DEFS[placingIndex].size, placingHoriz);
          }
          draw();
        }
      }

      if (gameState === 'waiting') {
        startPlacement();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    // Drawing functions
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawStatus();
      drawGrid(LEFT_GRID_X, GRID_Y, playerGrid, true, 'YOUR FLEET');
      drawGrid(RIGHT_GRID_X, GRID_Y, aiGrid, false, 'ENEMY WATERS');

      if (phase === 'placing') {
        drawPlacementPreview();
      }

      if (phase === 'playerTurn' && aimR >= 0 && aimC >= 0) {
        drawAimHighlight();
      }

      drawExplosions();

      // Draw legend at bottom
      drawLegend();
    }

    function drawStatus() {
      ctx.fillStyle = '#4af';
      ctx.shadowColor = '#4af';
      ctx.shadowBlur = 6;
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(statusText, W / 2, HEADER_H / 2);
      ctx.shadowBlur = 0;
    }

    function drawGrid(gx, gy, grid, isPlayer, label) {
      // Grid title
      ctx.fillStyle = '#4af';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(label, gx + GRID_TOTAL_W / 2, gy - 2);

      const cellStartX = gx + LABEL_W;
      const cellStartY = gy + LABEL_H;

      // Column labels (A-J)
      ctx.fillStyle = '#667';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let c = 0; c < GRID_SIZE; c++) {
        ctx.fillText(String.fromCharCode(65 + c), cellStartX + c * CELL + CELL / 2, gy + LABEL_H / 2);
      }

      // Row labels (1-10)
      ctx.textAlign = 'right';
      for (let r = 0; r < GRID_SIZE; r++) {
        ctx.fillText(String(r + 1), gx + LABEL_W - 2, cellStartY + r * CELL + CELL / 2);
      }

      // Draw cells
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const x = cellStartX + c * CELL;
          const y = cellStartY + r * CELL;
          const state = grid[r][c];

          // Background
          if (state === SUNK) {
            ctx.fillStyle = 'rgba(255, 68, 68, 0.25)';
          } else if (state === HIT) {
            ctx.fillStyle = 'rgba(255, 68, 68, 0.12)';
          } else if (state === SHIP && isPlayer) {
            ctx.fillStyle = 'rgba(68, 170, 255, 0.25)';
          } else {
            ctx.fillStyle = '#1a2a3e';
          }
          ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);

          // Ship body on player grid
          if (isPlayer && (state === SHIP || state === HIT || state === SUNK)) {
            if (state === SHIP) {
              ctx.fillStyle = 'rgba(68, 170, 255, 0.5)';
              ctx.fillRect(x + 2, y + 2, CELL - 4, CELL - 4);
              // Subtle glow
              ctx.shadowColor = '#4af';
              ctx.shadowBlur = 4;
              ctx.strokeStyle = '#4af';
              ctx.lineWidth = 1;
              ctx.strokeRect(x + 2, y + 2, CELL - 4, CELL - 4);
              ctx.shadowBlur = 0;
            }
          }

          // Hit marker
          if (state === HIT) {
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.moveTo(x + 4, y + 4);
            ctx.lineTo(x + CELL - 4, y + CELL - 4);
            ctx.moveTo(x + CELL - 4, y + 4);
            ctx.lineTo(x + 4, y + CELL - 4);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Sunk marker
          if (state === SUNK) {
            ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
            ctx.fillRect(x + 2, y + 2, CELL - 4, CELL - 4);
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 6;
            ctx.strokeRect(x + 2, y + 2, CELL - 4, CELL - 4);
            // X mark
            ctx.beginPath();
            ctx.moveTo(x + 5, y + 5);
            ctx.lineTo(x + CELL - 5, y + CELL - 5);
            ctx.moveTo(x + CELL - 5, y + 5);
            ctx.lineTo(x + 5, y + CELL - 5);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Miss marker
          if (state === MISS) {
            ctx.fillStyle = '#556';
            ctx.shadowColor = '#556';
            ctx.shadowBlur = 2;
            ctx.beginPath();
            ctx.arc(x + CELL / 2, y + CELL / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
      }

      // Grid border
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      for (let r = 0; r <= GRID_SIZE; r++) {
        ctx.beginPath();
        ctx.moveTo(cellStartX, cellStartY + r * CELL);
        ctx.lineTo(cellStartX + GRID_PX, cellStartY + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= GRID_SIZE; c++) {
        ctx.beginPath();
        ctx.moveTo(cellStartX + c * CELL, cellStartY);
        ctx.lineTo(cellStartX + c * CELL, cellStartY + GRID_PX);
        ctx.stroke();
      }

      // Outer border glow
      ctx.strokeStyle = 'rgba(68, 170, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(cellStartX - 0.5, cellStartY - 0.5, GRID_PX + 1, GRID_PX + 1);
    }

    function drawPlacementPreview() {
      if (hoverR < 0 || hoverC < 0) return;
      const ship = SHIP_DEFS[placingIndex];
      const cellStartX = LEFT_GRID_X + LABEL_W;
      const cellStartY = GRID_Y + LABEL_H;

      for (let i = 0; i < ship.size; i++) {
        const cr = placingHoriz ? hoverR : hoverR + i;
        const cc = placingHoriz ? hoverC + i : hoverC;
        if (cr < 0 || cr >= GRID_SIZE || cc < 0 || cc >= GRID_SIZE) continue;

        const x = cellStartX + cc * CELL;
        const y = cellStartY + cr * CELL;

        if (hoverValid) {
          ctx.fillStyle = 'rgba(68, 255, 68, 0.35)';
          ctx.strokeStyle = '#4f4';
        } else {
          ctx.fillStyle = 'rgba(255, 68, 68, 0.35)';
          ctx.strokeStyle = '#f44';
        }
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
      }
    }

    function drawAimHighlight() {
      const cellStartX = RIGHT_GRID_X + LABEL_W;
      const cellStartY = GRID_Y + LABEL_H;
      const x = cellStartX + aimC * CELL;
      const y = cellStartY + aimR * CELL;

      ctx.strokeStyle = '#4af';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#4af';
      ctx.shadowBlur = 8;
      ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
      ctx.shadowBlur = 0;

      // Crosshair
      ctx.strokeStyle = 'rgba(68, 170, 255, 0.5)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      // Vertical line through entire column
      ctx.beginPath();
      ctx.moveTo(x + CELL / 2, cellStartY);
      ctx.lineTo(x + CELL / 2, cellStartY + GRID_PX);
      ctx.stroke();
      // Horizontal line through entire row
      ctx.beginPath();
      ctx.moveTo(cellStartX, y + CELL / 2);
      ctx.lineTo(cellStartX + GRID_PX, y + CELL / 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawExplosions() {
      for (const e of explosions) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        if (e.big) {
          ctx.fillStyle = 'rgba(255, 100, 50, ' + (e.alpha * 0.6) + ')';
        } else {
          ctx.fillStyle = 'rgba(255, 68, 68, ' + (e.alpha * 0.5) + ')';
        }
        ctx.fill();

        // Inner ring
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 100, ' + (e.alpha * 0.7) + ')';
        ctx.fill();
      }
    }

    function drawLegend() {
      const ly = GRID_Y + GRID_TOTAL_H + 12;
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      if (phase === 'placing') {
        // Show ship list with checkmarks
        let tx = 20;
        for (let i = 0; i < SHIP_DEFS.length; i++) {
          const placed = i < placingIndex;
          const current = i === placingIndex;
          ctx.fillStyle = placed ? '#4f4' : (current ? '#4af' : '#445');
          const prefix = placed ? '\u2713 ' : (current ? '> ' : '  ');
          const text = prefix + SHIP_DEFS[i].name + '(' + SHIP_DEFS[i].size + ')';
          ctx.fillText(text, tx, ly);
          tx += ctx.measureText(text).width + 10;
        }

        // Rotation hint
        ctx.fillStyle = '#667';
        ctx.textAlign = 'right';
        ctx.fillText(placingHoriz ? '[R] Horizontal' : '[R] Vertical', W - 20, ly);
      } else if (phase === 'playerTurn' || phase === 'aiTurn') {
        // Show remaining ships for both sides
        ctx.fillStyle = '#4af';
        ctx.fillText('Your ships: ' + (5 - playerShipsSunk) + '/5', 20, ly);
        ctx.fillText('Enemy ships: ' + (5 - aiShipsSunk) + '/5', 20, ly + 14);

        ctx.textAlign = 'right';
        ctx.fillStyle = '#667';
        ctx.fillText('Shots: ' + playerTotalShots + ' | Accuracy: ' +
          (playerTotalShots > 0 ? Math.round(playerHits / playerTotalShots * 100) : 0) + '%', W - 20, ly);
        ctx.fillText('AI Shots: ' + aiTotalShots, W - 20, ly + 14);
      }
    }

    // Animation loop
    function gameLoop() {
      updateExplosions();
      if (explosions.length > 0) {
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battle Royale 2D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f64; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 68, 0.4); }
    h1 { color: #f64; font-size: 1.8rem; text-shadow: 0 0 15px rgba(255, 102, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #f64; }
    canvas {
      border: 2px solid #f64;
      box-shadow: 0 0 20px rgba(255, 102, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f64;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,102,68,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .start-hint { color: #f64; margin-top: 16px; font-size: 1.1rem; }
    .controls-info {
      width: 600px;
      margin-top: 12px;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BATTLE ROYALE 2D</h1>
  </div>
  <div class="score-bar">
    <div>Kills: <span id="killCount">0</span></div>
    <div>Alive: <span id="aliveCount">8</span>/8</div>
    <div>Score: <span id="score">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">BATTLE ROYALE 2D</h2>
      <p id="overlayMsg">8 players. 1 survivor. Shrinking zone.</p>
      <p class="start-hint" id="overlayHint">Click to Drop In</p>
    </div>
  </div>
  <div class="controls-info">WASD=Move | Mouse=Aim | Click=Shoot | E=Pickup | R=Reload | Tab=Inventory</div>

<script>
// ---- GLOBALS ----
let gameState = 'menu'; // menu, playing, gameover
let score = 0;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayMsg = document.getElementById('overlayMsg');
const overlayHint = document.getElementById('overlayHint');

// ---- CONSTANTS ----
const CW = 600, CH = 600;
const MAP_W = 3000, MAP_H = 3000;
const TILE = 40;
const PLAYER_R = 10;
const WEAPON_DEFS = {
  Pistol:  { damage: 15, fireRate: 400, range: 280, spread: 0.08, magSize: 12, reloadTime: 1200, speed: 14, color: '#aaa', auto: false },
  Shotgun: { damage: 8, fireRate: 800, range: 180, spread: 0.25, magSize: 6, reloadTime: 1800, speed: 10, pellets: 5, color: '#fa0', auto: false },
  Rifle:   { damage: 20, fireRate: 150, range: 400, spread: 0.05, magSize: 30, reloadTime: 2000, speed: 16, color: '#4af', auto: true },
  Sniper:  { damage: 70, fireRate: 1200, range: 700, spread: 0.01, magSize: 5, reloadTime: 2500, speed: 22, color: '#f4a', auto: false }
};
const WEAPON_TIERS = ['Pistol', 'Shotgun', 'Rifle', 'Sniper'];

// ---- ZONE ----
let zone = { x: MAP_W / 2, y: MAP_H / 2, r: 1600 };
let zoneTarget = { x: MAP_W / 2, y: MAP_H / 2, r: 1600 };
let zoneShrinkStart = 0;
let zoneShrinkDur = 15000;
let zonePhase = 0;
const ZONE_INTERVAL = 30000;
const ZONE_DAMAGE = 2;
let lastZoneTick = 0;
let nextZoneTime = 0;
let zoneFrom = { x: MAP_W / 2, y: MAP_H / 2, r: 1600 };

// ---- MAP GENERATION ----
let buildings = [];
let lootItems = [];
let trees = [];
let walls = [];

function generateMap() {
  buildings = [];
  lootItems = [];
  trees = [];
  walls = [];

  // Generate buildings (clusters)
  const BUILDING_CLUSTERS = 14;
  for (let c = 0; c < BUILDING_CLUSTERS; c++) {
    const cx = 300 + Math.random() * (MAP_W - 600);
    const cy = 300 + Math.random() * (MAP_H - 600);
    const count = 2 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
      const bw = 80 + Math.random() * 80;
      const bh = 60 + Math.random() * 80;
      const bx = cx + (Math.random() - 0.5) * 250;
      const by = cy + (Math.random() - 0.5) * 250;
      buildings.push({ x: bx, y: by, w: bw, h: bh, color: `hsl(${20+Math.random()*20}, ${15+Math.random()*15}%, ${22+Math.random()*10}%)` });
      // Walls for collision
      walls.push({ x: bx, y: by, w: bw, h: 6 }); // top
      walls.push({ x: bx, y: by + bh - 6, w: bw, h: 6 }); // bottom
      walls.push({ x: bx, y: by, w: 6, h: bh }); // left
      walls.push({ x: bx + bw - 6, y: by, w: 6, h: bh }); // right

      // Loot inside buildings
      const lootCount = 1 + Math.floor(Math.random() * 3);
      for (let l = 0; l < lootCount; l++) {
        const lx = bx + 15 + Math.random() * (bw - 30);
        const ly = by + 15 + Math.random() * (bh - 30);
        spawnLoot(lx, ly);
      }
    }
  }

  // Scatter some loot outside
  for (let i = 0; i < 40; i++) {
    spawnLoot(200 + Math.random() * (MAP_W - 400), 200 + Math.random() * (MAP_H - 400));
  }

  // Trees
  for (let i = 0; i < 200; i++) {
    trees.push({
      x: 100 + Math.random() * (MAP_W - 200),
      y: 100 + Math.random() * (MAP_H - 200),
      r: 12 + Math.random() * 10,
      shade: `hsl(${120 + Math.random()*40}, ${40+Math.random()*30}%, ${18+Math.random()*12}%)`
    });
  }
}

function spawnLoot(x, y) {
  const r = Math.random();
  if (r < 0.30) {
    // Weapon
    const wr = Math.random();
    let type;
    if (wr < 0.35) type = 'Pistol';
    else if (wr < 0.60) type = 'Shotgun';
    else if (wr < 0.85) type = 'Rifle';
    else type = 'Sniper';
    lootItems.push({ x, y, kind: 'weapon', weaponType: type, ammo: WEAPON_DEFS[type].magSize * 2 });
  } else if (r < 0.55) {
    lootItems.push({ x, y, kind: 'health', amount: 25 + Math.floor(Math.random() * 26) });
  } else if (r < 0.75) {
    lootItems.push({ x, y, kind: 'armor', amount: 25 + Math.floor(Math.random() * 26) });
  } else {
    // Ammo
    const types = WEAPON_TIERS;
    const type = types[Math.floor(Math.random() * types.length)];
    lootItems.push({ x, y, kind: 'ammo', weaponType: type, amount: WEAPON_DEFS[type].magSize + Math.floor(Math.random() * WEAPON_DEFS[type].magSize) });
  }
}

// ---- PLAYER / AI ----
let players = [];
let bullets = [];
let killFeed = [];
let camera = { x: 0, y: 0 };
let keys = {};
let mouse = { x: CW / 2, y: CH / 2, down: false };
let showInventory = false;
let gameTime = 0;
let lastTime = 0;

const PLAYER_NAMES = ['You', 'Alpha', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Ghost'];
const PLAYER_COLORS = ['#f64', '#e44', '#4ae', '#4e4', '#ea4', '#e4e', '#4ee', '#aaa'];

function createPlayer(index, x, y) {
  return {
    id: index,
    name: PLAYER_NAMES[index],
    color: PLAYER_COLORS[index],
    x, y,
    vx: 0, vy: 0,
    speed: 2.5,
    hp: 100,
    maxHp: 100,
    armor: 0,
    maxArmor: 100,
    alive: true,
    angle: 0,
    weapons: [null, null],
    activeWeapon: 0,
    ammo: { Pistol: 0, Shotgun: 0, Rifle: 0, Sniper: 0 },
    lastFire: 0,
    reloading: false,
    reloadStart: 0,
    kills: 0,
    placement: 8,
    // AI fields
    isAI: index !== 0,
    aiTarget: null,
    aiState: 'loot', // loot, move_zone, fight, flee
    aiStateTimer: 0,
    aiMoveTarget: null,
    aiLastShot: 0,
    aiScanTimer: 0,
    aiPickupCooldown: 0,
    aiStrafeDist: 0,
    aiStrafeDir: 1,
    flashTimer: 0
  };
}

function initGame() {
  players = [];
  bullets = [];
  killFeed = [];
  lootItems = [];
  showInventory = false;
  gameTime = 0;
  zonePhase = 0;
  zone = { x: MAP_W / 2, y: MAP_H / 2, r: 1600 };
  zoneTarget = { x: MAP_W / 2, y: MAP_H / 2, r: 1600 };
  zoneFrom = { ...zone };
  nextZoneTime = ZONE_INTERVAL;
  lastZoneTick = 0;
  score = 0;

  generateMap();

  // Spawn 8 players in a ring around center
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
    const dist = 600 + Math.random() * 400;
    const px = MAP_W / 2 + Math.cos(angle) * dist;
    const py = MAP_H / 2 + Math.sin(angle) * dist;
    const p = createPlayer(i, px, py);
    // Give everyone a pistol to start
    p.weapons[0] = { type: 'Pistol', mag: WEAPON_DEFS.Pistol.magSize, ammo: WEAPON_DEFS.Pistol.magSize * 2 };
    players.push(p);
  }
}

// ---- INPUT ----
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === 'Tab') { e.preventDefault(); showInventory = !showInventory; }
  if (e.key.toLowerCase() === 'e' && gameState === 'playing') tryPickup();
  if (e.key.toLowerCase() === 'r' && gameState === 'playing') startReload(players[0]);
  if (e.key === '1') players[0].activeWeapon = 0;
  if (e.key === '2') players[0].activeWeapon = 1;
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', e => {
  if (gameState === 'menu') { startGame(); return; }
  if (gameState === 'gameover') { gameState = 'menu'; showOverlay(); return; }
  mouse.down = true;
});
canvas.addEventListener('mouseup', () => { mouse.down = false; });
canvas.addEventListener('contextmenu', e => e.preventDefault());

function showOverlay() {
  overlay.style.display = 'flex';
  overlay.style.pointerEvents = 'auto';
}
function hideOverlay() {
  overlay.style.display = 'none';
  overlay.style.pointerEvents = 'none';
}

function startGame() {
  initGame();
  gameState = 'playing';
  hideOverlay();
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

// ---- PICKUP ----
function tryPickup() {
  const p = players[0];
  if (!p.alive) return;
  let bestDist = 40;
  let bestIdx = -1;
  for (let i = 0; i < lootItems.length; i++) {
    const l = lootItems[i];
    const d = dist(p.x, p.y, l.x, l.y);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  if (bestIdx >= 0) doPickup(p, bestIdx);
}

function doPickup(p, idx) {
  const l = lootItems[idx];
  if (l.kind === 'weapon') {
    // Try to equip in empty slot, else replace active
    let slot = p.weapons[0] === null ? 0 : (p.weapons[1] === null ? 1 : p.activeWeapon);
    // Drop current weapon if replacing
    if (p.weapons[slot] !== null) {
      const old = p.weapons[slot];
      lootItems.push({ x: p.x + (Math.random()-0.5)*20, y: p.y + (Math.random()-0.5)*20, kind: 'weapon', weaponType: old.type, ammo: old.ammo });
    }
    p.weapons[slot] = { type: l.weaponType, mag: WEAPON_DEFS[l.weaponType].magSize, ammo: l.ammo };
    p.activeWeapon = slot;
    p.reloading = false;
  } else if (l.kind === 'health') {
    p.hp = Math.min(p.maxHp, p.hp + l.amount);
  } else if (l.kind === 'armor') {
    p.armor = Math.min(p.maxArmor, p.armor + l.amount);
  } else if (l.kind === 'ammo') {
    // Add to matching weapon's reserve
    for (let w of p.weapons) {
      if (w && w.type === l.weaponType) w.ammo += l.amount;
    }
  }
  lootItems.splice(idx, 1);
}

// ---- SHOOTING ----
function shoot(p) {
  const w = p.weapons[p.activeWeapon];
  if (!w) return;
  const def = WEAPON_DEFS[w.type];
  if (p.reloading) return;
  if (performance.now() - p.lastFire < def.fireRate) return;
  if (w.mag <= 0) { startReload(p); return; }

  w.mag--;
  p.lastFire = performance.now();

  const pellets = def.pellets || 1;
  for (let i = 0; i < pellets; i++) {
    const spread = (Math.random() - 0.5) * def.spread * 2;
    const angle = p.angle + spread;
    bullets.push({
      x: p.x + Math.cos(p.angle) * 14,
      y: p.y + Math.sin(p.angle) * 14,
      vx: Math.cos(angle) * def.speed,
      vy: Math.sin(angle) * def.speed,
      owner: p.id,
      damage: def.damage,
      range: def.range,
      dist: 0,
      color: def.color
    });
  }
}

function startReload(p) {
  const w = p.weapons[p.activeWeapon];
  if (!w || p.reloading) return;
  const def = WEAPON_DEFS[w.type];
  if (w.mag >= def.magSize) return;
  if (w.ammo <= 0) return;
  p.reloading = true;
  p.reloadStart = performance.now();
}

function checkReload(p) {
  if (!p.reloading) return;
  const w = p.weapons[p.activeWeapon];
  if (!w) { p.reloading = false; return; }
  const def = WEAPON_DEFS[w.type];
  if (performance.now() - p.reloadStart >= def.reloadTime) {
    const need = def.magSize - w.mag;
    const take = Math.min(need, w.ammo);
    w.mag += take;
    w.ammo -= take;
    p.reloading = false;
  }
}

// ---- COLLISION ----
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
  const nearX = Math.max(rx, Math.min(cx, rx + rw));
  const nearY = Math.max(ry, Math.min(cy, ry + rh));
  return dist(cx, cy, nearX, nearY) < cr;
}

function resolveWallCollision(p) {
  for (const w of walls) {
    if (circleRectCollide(p.x, p.y, PLAYER_R, w.x, w.y, w.w, w.h)) {
      // Push out
      const nearX = Math.max(w.x, Math.min(p.x, w.x + w.w));
      const nearY = Math.max(w.y, Math.min(p.y, w.y + w.h));
      const dx = p.x - nearX;
      const dy = p.y - nearY;
      const d = Math.hypot(dx, dy);
      if (d > 0) {
        const push = PLAYER_R - d + 1;
        p.x += (dx / d) * push;
        p.y += (dy / d) * push;
      }
    }
  }
  // Map bounds
  p.x = Math.max(PLAYER_R, Math.min(MAP_W - PLAYER_R, p.x));
  p.y = Math.max(PLAYER_R, Math.min(MAP_H - PLAYER_R, p.y));
}

// ---- AI ----
function updateAI(p, dt) {
  if (!p.alive || !p.isAI) return;

  checkReload(p);

  const now = performance.now();
  p.aiStateTimer -= dt;
  p.aiScanTimer -= dt;
  p.aiPickupCooldown -= dt;

  // Determine distance to zone center / safe area
  const distToZone = dist(p.x, p.y, zone.x, zone.y);
  const inZone = distToZone < zone.r - 50;
  const zoneUrgent = distToZone > zone.r - 30;

  // Scan for enemies
  let nearestEnemy = null;
  let nearestDist = Infinity;
  for (const other of players) {
    if (other.id === p.id || !other.alive) continue;
    const d = dist(p.x, p.y, other.x, other.y);
    if (d < nearestDist) { nearestDist = d; nearestEnemy = other; }
  }

  // State transitions
  if (zoneUrgent) {
    p.aiState = 'move_zone';
  } else if (nearestEnemy && nearestDist < 300 && p.hp > 30) {
    p.aiState = 'fight';
    p.aiTarget = nearestEnemy;
  } else if (nearestEnemy && nearestDist < 200 && p.hp <= 30) {
    p.aiState = 'flee';
  } else if (p.aiStateTimer <= 0) {
    p.aiState = 'loot';
    p.aiStateTimer = 2000 + Math.random() * 3000;
  }

  // Execute state
  let moveX = 0, moveY = 0;
  let wantShoot = false;

  if (p.aiState === 'move_zone') {
    // Move toward safe zone center
    const tx = zone.x + (Math.random() - 0.5) * zone.r * 0.5;
    const ty = zone.y + (Math.random() - 0.5) * zone.r * 0.5;
    const a = Math.atan2(zone.y - p.y, zone.x - p.x);
    moveX = Math.cos(a);
    moveY = Math.sin(a);
    // Still shoot at nearby enemies while moving
    if (nearestEnemy && nearestDist < 250) {
      p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
      wantShoot = true;
    } else {
      p.angle = a;
    }
  } else if (p.aiState === 'fight') {
    const target = p.aiTarget;
    if (target && target.alive) {
      p.angle = Math.atan2(target.y - p.y, target.x - p.x);
      // Get to good range
      const w = p.weapons[p.activeWeapon];
      const idealRange = w ? WEAPON_DEFS[w.type].range * 0.6 : 150;
      const targetDist = dist(p.x, p.y, target.x, target.y);

      // Strafe
      p.aiStrafeDist += dt;
      if (p.aiStrafeDist > 800 + Math.random() * 600) {
        p.aiStrafeDist = 0;
        p.aiStrafeDir *= -1;
      }
      const perpA = p.angle + Math.PI / 2 * p.aiStrafeDir;

      if (targetDist > idealRange + 30) {
        moveX = Math.cos(p.angle) * 0.7 + Math.cos(perpA) * 0.3;
        moveY = Math.sin(p.angle) * 0.7 + Math.sin(perpA) * 0.3;
      } else if (targetDist < idealRange - 30) {
        moveX = -Math.cos(p.angle) * 0.5 + Math.cos(perpA) * 0.5;
        moveY = -Math.sin(p.angle) * 0.5 + Math.sin(perpA) * 0.5;
      } else {
        moveX = Math.cos(perpA);
        moveY = Math.sin(perpA);
      }
      wantShoot = true;
    } else {
      p.aiState = 'loot';
    }
  } else if (p.aiState === 'flee') {
    if (nearestEnemy) {
      const a = Math.atan2(p.y - nearestEnemy.y, p.x - nearestEnemy.x);
      moveX = Math.cos(a);
      moveY = Math.sin(a);
      p.angle = a + Math.PI; // face enemy while fleeing
    }
  } else if (p.aiState === 'loot') {
    // Find nearest loot
    let bestLoot = null;
    let bestLootDist = 300;
    for (let i = 0; i < lootItems.length; i++) {
      const l = lootItems[i];
      const d = dist(p.x, p.y, l.x, l.y);
      if (d < bestLootDist) {
        // Prioritize weapons if we need one, health if low
        let priority = d;
        if (l.kind === 'weapon' && (!p.weapons[0] || !p.weapons[1])) priority *= 0.5;
        if (l.kind === 'weapon') {
          const curBest = getBestWeaponTier(p);
          const lootTier = WEAPON_TIERS.indexOf(l.weaponType);
          if (lootTier > curBest) priority *= 0.3;
        }
        if (l.kind === 'health' && p.hp < 70) priority *= 0.4;
        if (l.kind === 'armor' && p.armor < 50) priority *= 0.5;
        if (priority < bestLootDist) {
          bestLootDist = priority;
          bestLoot = i;
        }
      }
    }

    if (bestLoot !== null) {
      const l = lootItems[bestLoot];
      const a = Math.atan2(l.y - p.y, l.x - p.x);
      moveX = Math.cos(a);
      moveY = Math.sin(a);
      p.angle = a;
      // Pickup if close
      if (dist(p.x, p.y, l.x, l.y) < 30 && p.aiPickupCooldown <= 0) {
        aiDoPickup(p, bestLoot);
        p.aiPickupCooldown = 300;
      }
    } else {
      // Wander toward zone center
      if (!p.aiMoveTarget || dist(p.x, p.y, p.aiMoveTarget.x, p.aiMoveTarget.y) < 50) {
        p.aiMoveTarget = {
          x: zone.x + (Math.random() - 0.5) * zone.r * 0.8,
          y: zone.y + (Math.random() - 0.5) * zone.r * 0.8
        };
      }
      const a = Math.atan2(p.aiMoveTarget.y - p.y, p.aiMoveTarget.x - p.x);
      moveX = Math.cos(a);
      moveY = Math.sin(a);
      p.angle = a;
    }

    // Opportunistic shooting
    if (nearestEnemy && nearestDist < 200) {
      p.angle = Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x);
      wantShoot = true;
    }
  }

  // Select best weapon for combat
  if (wantShoot || p.aiState === 'fight') {
    selectBestWeapon(p, nearestDist);
  }

  // Movement
  const ml = Math.hypot(moveX, moveY);
  if (ml > 0) {
    p.x += (moveX / ml) * p.speed;
    p.y += (moveY / ml) * p.speed;
  }
  resolveWallCollision(p);

  // Shooting with some inaccuracy delay
  if (wantShoot) {
    const w = p.weapons[p.activeWeapon];
    if (w && w.mag <= 0 && !p.reloading) startReload(p);
    if (w && !p.reloading && now - p.lastFire > WEAPON_DEFS[w.type].fireRate + 50 + Math.random() * 100) {
      // Add AI inaccuracy
      p.angle += (Math.random() - 0.5) * 0.12;
      shoot(p);
    }
  }
}

function getBestWeaponTier(p) {
  let best = -1;
  for (const w of p.weapons) {
    if (w) best = Math.max(best, WEAPON_TIERS.indexOf(w.type));
  }
  return best;
}

function selectBestWeapon(p, targetDist) {
  let bestSlot = p.activeWeapon;
  let bestScore = -1;
  for (let i = 0; i < 2; i++) {
    const w = p.weapons[i];
    if (!w) continue;
    const def = WEAPON_DEFS[w.type];
    let s = WEAPON_TIERS.indexOf(w.type);
    if (targetDist < def.range) s += 2;
    if (w.mag > 0) s += 1;
    if (s > bestScore) { bestScore = s; bestSlot = i; }
  }
  if (bestSlot !== p.activeWeapon) {
    p.activeWeapon = bestSlot;
    p.reloading = false;
  }
}

function aiDoPickup(p, idx) {
  const l = lootItems[idx];
  if (l.kind === 'weapon') {
    const lootTier = WEAPON_TIERS.indexOf(l.weaponType);
    // Find worst weapon slot to replace
    let worstSlot = 0;
    let worstTier = 99;
    for (let i = 0; i < 2; i++) {
      if (!p.weapons[i]) { worstSlot = i; worstTier = -1; break; }
      const t = WEAPON_TIERS.indexOf(p.weapons[i].type);
      if (t < worstTier) { worstTier = t; worstSlot = i; }
    }
    if (lootTier > worstTier || p.weapons[worstSlot] === null) {
      if (p.weapons[worstSlot]) {
        const old = p.weapons[worstSlot];
        lootItems.push({ x: p.x + (Math.random()-0.5)*20, y: p.y + (Math.random()-0.5)*20, kind: 'weapon', weaponType: old.type, ammo: old.ammo });
      }
      p.weapons[worstSlot] = { type: l.weaponType, mag: WEAPON_DEFS[l.weaponType].magSize, ammo: l.ammo };
      lootItems.splice(idx, 1);
    }
  } else {
    doPickup(p, idx);
  }
}

// ---- GAME LOOP ----
function gameLoop(ts) {
  if (gameState !== 'playing') return;
  const dt = Math.min(ts - lastTime, 50);
  lastTime = ts;
  gameTime += dt;

  update(dt, ts);
  render();

  requestAnimationFrame(gameLoop);
}

function update(dt, ts) {
  const player = players[0];

  // ---- Zone logic ----
  if (gameTime >= nextZoneTime && zonePhase < 7) {
    zonePhase++;
    zoneFrom = { x: zone.x, y: zone.y, r: zone.r };
    const shrinkFactor = 0.6;
    const newR = Math.max(80, zone.r * shrinkFactor);
    const maxOff = (zone.r - newR) * 0.4;
    zoneTarget = {
      x: zone.x + (Math.random() - 0.5) * maxOff,
      y: zone.y + (Math.random() - 0.5) * maxOff,
      r: newR
    };
    // Clamp zone to map
    zoneTarget.x = Math.max(zoneTarget.r, Math.min(MAP_W - zoneTarget.r, zoneTarget.x));
    zoneTarget.y = Math.max(zoneTarget.r, Math.min(MAP_H - zoneTarget.r, zoneTarget.y));
    zoneShrinkStart = gameTime;
    zoneShrinkDur = 12000 + zonePhase * 1000;
    nextZoneTime = gameTime + ZONE_INTERVAL;
    addKillFeed('', 'Zone shrinking!', '#f64');
  }

  // Interpolate zone
  if (gameTime < zoneShrinkStart + zoneShrinkDur && zoneShrinkStart > 0) {
    const t = (gameTime - zoneShrinkStart) / zoneShrinkDur;
    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    zone.x = zoneFrom.x + (zoneTarget.x - zoneFrom.x) * ease;
    zone.y = zoneFrom.y + (zoneTarget.y - zoneFrom.y) * ease;
    zone.r = zoneFrom.r + (zoneTarget.r - zoneFrom.r) * ease;
  } else if (zoneShrinkStart > 0) {
    zone.x = zoneTarget.x;
    zone.y = zoneTarget.y;
    zone.r = zoneTarget.r;
  }

  // Zone damage
  if (gameTime - lastZoneTick > 500) {
    lastZoneTick = gameTime;
    for (const p of players) {
      if (!p.alive) continue;
      if (dist(p.x, p.y, zone.x, zone.y) > zone.r) {
        const dmgMult = 1 + zonePhase * 0.5;
        takeDamage(p, ZONE_DAMAGE * dmgMult, -1);
      }
    }
  }

  // ---- Player input ----
  if (player.alive) {
    let mx = 0, my = 0;
    if (keys['w'] || keys['arrowup']) my -= 1;
    if (keys['s'] || keys['arrowdown']) my += 1;
    if (keys['a'] || keys['arrowleft']) mx -= 1;
    if (keys['d'] || keys['arrowright']) mx += 1;
    const ml = Math.hypot(mx, my);
    if (ml > 0) {
      player.x += (mx / ml) * player.speed;
      player.y += (my / ml) * player.speed;
    }
    resolveWallCollision(player);

    // Aim
    const worldMouseX = mouse.x + camera.x;
    const worldMouseY = mouse.y + camera.y;
    player.angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);

    // Shoot
    const w = player.weapons[player.activeWeapon];
    if (mouse.down && w) {
      if (WEAPON_DEFS[w.type].auto) {
        shoot(player);
      } else if (!player._mouseWasDown) {
        shoot(player);
      }
    }
    player._mouseWasDown = mouse.down;

    checkReload(player);
  }

  // ---- AI ----
  for (const p of players) {
    if (p.isAI) updateAI(p, dt);
  }

  // ---- Bullets ----
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx;
    b.y += b.vy;
    b.dist += Math.hypot(b.vx, b.vy);

    // Out of range or map
    if (b.dist > b.range || b.x < 0 || b.x > MAP_W || b.y < 0 || b.y > MAP_H) {
      bullets.splice(i, 1);
      continue;
    }

    // Wall collision
    let hitWall = false;
    for (const w of walls) {
      if (b.x >= w.x && b.x <= w.x + w.w && b.y >= w.y && b.y <= w.y + w.h) {
        hitWall = true; break;
      }
    }
    if (hitWall) { bullets.splice(i, 1); continue; }

    // Player collision
    for (const p of players) {
      if (!p.alive || p.id === b.owner) continue;
      if (dist(b.x, b.y, p.x, p.y) < PLAYER_R + 3) {
        takeDamage(p, b.damage, b.owner);
        p.flashTimer = 150;
        bullets.splice(i, 1);
        break;
      }
    }
  }

  // Flash timers
  for (const p of players) {
    if (p.flashTimer > 0) p.flashTimer -= dt;
  }

  // ---- Camera ----
  if (player.alive) {
    camera.x = player.x - CW / 2;
    camera.y = player.y - CH / 2;
  }

  // Update UI
  const alive = players.filter(p => p.alive).length;
  document.getElementById('killCount').textContent = player.kills;
  document.getElementById('aliveCount').textContent = alive;
  document.getElementById('score').textContent = score;

  // Check win/loss
  if (alive <= 1 || !player.alive) {
    endGame();
  }
}

function takeDamage(p, damage, attackerId) {
  // Armor absorbs 50%
  if (p.armor > 0) {
    const absorbed = Math.min(p.armor, damage * 0.5);
    p.armor -= absorbed;
    damage -= absorbed;
  }
  p.hp -= damage;
  if (p.hp <= 0) {
    p.hp = 0;
    p.alive = false;
    const alive = players.filter(pl => pl.alive).length;
    p.placement = alive + 1;

    // Drop loot
    for (const w of p.weapons) {
      if (w) lootItems.push({ x: p.x + (Math.random()-0.5)*30, y: p.y + (Math.random()-0.5)*30, kind: 'weapon', weaponType: w.type, ammo: w.ammo });
    }
    if (p.armor > 10) lootItems.push({ x: p.x, y: p.y, kind: 'armor', amount: Math.floor(p.armor) });

    if (attackerId >= 0) {
      const attacker = players[attackerId];
      attacker.kills++;
      if (attackerId === 0) score += 100;
      addKillFeed(attacker.name, p.name, attacker.color);
    } else {
      addKillFeed('Zone', p.name, '#f64');
    }
  }
}

function addKillFeed(killer, victim, color) {
  killFeed.unshift({ killer, victim, color, time: gameTime });
  if (killFeed.length > 6) killFeed.pop();
}

function endGame() {
  gameState = 'gameover';
  const player = players[0];
  const placement = player.alive ? 1 : player.placement;
  // Score: kills * 100 + placement bonus
  const placementBonus = Math.max(0, (8 - placement) * 50);
  score = player.kills * 100 + placementBonus;

  overlayTitle.textContent = placement === 1 ? 'VICTORY ROYALE!' : `#${placement} / 8`;
  overlayMsg.innerHTML = `Kills: ${player.kills} | Score: ${score}`;
  overlayHint.textContent = 'Click to Play Again';
  showOverlay();
}

// ---- RENDER ----
function render() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, CW, CH);

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  // Ground
  ctx.fillStyle = '#141428';
  ctx.fillRect(0, 0, MAP_W, MAP_H);

  // Grid
  ctx.strokeStyle = '#1e1e3a';
  ctx.lineWidth = 1;
  const gx0 = Math.floor(camera.x / TILE) * TILE;
  const gy0 = Math.floor(camera.y / TILE) * TILE;
  for (let x = gx0; x < camera.x + CW + TILE; x += TILE) {
    ctx.beginPath(); ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + CH); ctx.stroke();
  }
  for (let y = gy0; y < camera.y + CH + TILE; y += TILE) {
    ctx.beginPath(); ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + CW, y); ctx.stroke();
  }

  // Zone (outside = red tint)
  // Draw the danger zone as a huge rect with circle cutout
  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, MAP_W, MAP_H);
  ctx.arc(zone.x, zone.y, zone.r, 0, Math.PI * 2, true);
  ctx.fillStyle = 'rgba(255, 50, 30, 0.15)';
  ctx.fill();
  ctx.restore();

  // Zone border
  ctx.beginPath();
  ctx.arc(zone.x, zone.y, zone.r, 0, Math.PI * 2);
  ctx.strokeStyle = '#f64';
  ctx.lineWidth = 3;
  ctx.setLineDash([10, 8]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Next zone indicator
  if (zoneTarget.r < zone.r - 5) {
    ctx.beginPath();
    ctx.arc(zoneTarget.x, zoneTarget.y, zoneTarget.r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6, 6]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Trees (behind players)
  for (const t of trees) {
    if (!inView(t.x, t.y, t.r + 10)) continue;
    ctx.beginPath();
    ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
    ctx.fillStyle = t.shade;
    ctx.fill();
    ctx.strokeStyle = '#0a2a0a';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Buildings
  for (const b of buildings) {
    if (!inView(b.x + b.w/2, b.y + b.h/2, Math.max(b.w, b.h))) continue;
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(b.x, b.y, b.w, b.h);
    // Door opening (gap in wall)
    ctx.fillStyle = '#222';
    ctx.fillRect(b.x + b.w/2 - 8, b.y + b.h - 6, 16, 6);
  }

  // Loot
  for (const l of lootItems) {
    if (!inView(l.x, l.y, 20)) continue;
    ctx.save();
    ctx.translate(l.x, l.y);
    const pulse = 0.8 + Math.sin(gameTime / 300 + l.x) * 0.2;
    if (l.kind === 'weapon') {
      ctx.fillStyle = WEAPON_DEFS[l.weaponType].color;
      ctx.shadowColor = WEAPON_DEFS[l.weaponType].color;
      ctx.shadowBlur = 8 * pulse;
      ctx.fillRect(-8, -4, 16, 8);
      ctx.shadowBlur = 0;
    } else if (l.kind === 'health') {
      ctx.fillStyle = '#4f4';
      ctx.shadowColor = '#4f4';
      ctx.shadowBlur = 8 * pulse;
      ctx.beginPath();
      ctx.moveTo(-5, -2); ctx.lineTo(5, -2); ctx.lineTo(5, 2); ctx.lineTo(-5, 2); ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-2, -5); ctx.lineTo(2, -5); ctx.lineTo(2, 5); ctx.lineTo(-2, 5); ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (l.kind === 'armor') {
      ctx.fillStyle = '#48f';
      ctx.shadowColor = '#48f';
      ctx.shadowBlur = 8 * pulse;
      ctx.beginPath();
      ctx.arc(0, 0, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#aaf';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 6, -Math.PI*0.8, Math.PI*0.8);
      ctx.stroke();
    } else if (l.kind === 'ammo') {
      ctx.fillStyle = '#fa0';
      ctx.shadowColor = '#fa0';
      ctx.shadowBlur = 6 * pulse;
      ctx.fillRect(-4, -3, 8, 6);
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  // Bullets
  for (const b of bullets) {
    if (!inView(b.x, b.y, 5)) continue;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = b.color;
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Trail
    ctx.beginPath();
    ctx.moveTo(b.x, b.y);
    ctx.lineTo(b.x - b.vx * 2, b.y - b.vy * 2);
    ctx.strokeStyle = b.color;
    ctx.globalAlpha = 0.4;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Players
  for (const p of players) {
    if (!p.alive) continue;
    if (!inView(p.x, p.y, 40)) continue;
    drawPlayer(p);
  }

  // Dead player markers
  for (const p of players) {
    if (p.alive) continue;
    if (!inView(p.x, p.y, 15)) continue;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = 0.4;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(6, -6); ctx.lineTo(-6, 6); ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Pickup hint for player
  if (players[0].alive) {
    for (const l of lootItems) {
      if (dist(players[0].x, players[0].y, l.x, l.y) < 40) {
        let label = l.kind === 'weapon' ? l.weaponType : l.kind;
        if (l.kind === 'health') label = `Health +${l.amount}`;
        if (l.kind === 'armor') label = `Armor +${l.amount}`;
        if (l.kind === 'ammo') label = `${l.weaponType} Ammo +${l.amount}`;
        ctx.fillStyle = '#fff';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`[E] ${label}`, l.x, l.y - 14);
        break;
      }
    }
  }

  ctx.restore();

  // ---- HUD ----
  drawHUD();
  drawMinimap();
  drawKillFeed();
  if (showInventory) drawInventory();
}

function drawPlayer(p) {
  ctx.save();
  ctx.translate(p.x, p.y);

  // Hit flash
  if (p.flashTimer > 0) {
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 15;
  }

  // Body
  ctx.beginPath();
  ctx.arc(0, 0, PLAYER_R, 0, Math.PI * 2);
  ctx.fillStyle = p.color;
  ctx.fill();
  ctx.strokeStyle = p.id === 0 ? '#fff' : '#333';
  ctx.lineWidth = p.id === 0 ? 2 : 1;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Weapon direction
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(Math.cos(p.angle) * 8, Math.sin(p.angle) * 8);
  ctx.lineTo(Math.cos(p.angle) * 18, Math.sin(p.angle) * 18);
  ctx.stroke();

  // Armor indicator ring
  if (p.armor > 0) {
    ctx.beginPath();
    ctx.arc(0, 0, PLAYER_R + 3, 0, Math.PI * 2 * (p.armor / p.maxArmor));
    ctx.strokeStyle = '#48f';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Name + HP bar above
  ctx.font = '9px Courier New';
  ctx.textAlign = 'center';
  ctx.fillStyle = p.color;
  ctx.fillText(p.name, 0, -20);

  // HP bar
  const bw = 24;
  ctx.fillStyle = '#333';
  ctx.fillRect(-bw/2, -16, bw, 3);
  const hpPct = p.hp / p.maxHp;
  ctx.fillStyle = hpPct > 0.5 ? '#4f4' : (hpPct > 0.25 ? '#fa0' : '#f44');
  ctx.fillRect(-bw/2, -16, bw * hpPct, 3);

  ctx.restore();
}

function inView(x, y, pad) {
  return x > camera.x - pad && x < camera.x + CW + pad && y > camera.y - pad && y < camera.y + CH + pad;
}

function drawHUD() {
  const p = players[0];
  const hw = 200, hh = 60;
  const hx = CW / 2 - hw / 2, hy = CH - hh - 10;

  // Background
  ctx.fillStyle = 'rgba(10,10,30,0.85)';
  ctx.strokeStyle = '#f64';
  ctx.lineWidth = 1;
  roundRect(ctx, hx, hy, hw, hh, 6);
  ctx.fill();
  ctx.stroke();

  // Health bar
  ctx.fillStyle = '#333';
  ctx.fillRect(hx + 10, hy + 8, 120, 10);
  const hpPct = p.hp / p.maxHp;
  ctx.fillStyle = hpPct > 0.5 ? '#4f4' : (hpPct > 0.25 ? '#fa0' : '#f44');
  ctx.fillRect(hx + 10, hy + 8, 120 * hpPct, 10);
  ctx.font = '9px Courier New';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'left';
  ctx.fillText(`HP ${Math.ceil(p.hp)}`, hx + 135, hy + 17);

  // Armor bar
  ctx.fillStyle = '#333';
  ctx.fillRect(hx + 10, hy + 22, 120, 8);
  if (p.armor > 0) {
    ctx.fillStyle = '#48f';
    ctx.fillRect(hx + 10, hy + 22, 120 * (p.armor / p.maxArmor), 8);
  }
  ctx.fillStyle = '#8af';
  ctx.fillText(`AR ${Math.ceil(p.armor)}`, hx + 135, hy + 30);

  // Weapon info
  const w = p.weapons[p.activeWeapon];
  if (w) {
    const def = WEAPON_DEFS[w.type];
    ctx.fillStyle = def.color;
    ctx.font = 'bold 11px Courier New';
    ctx.fillText(w.type, hx + 10, hy + 46);
    ctx.fillStyle = '#fff';
    ctx.font = '10px Courier New';
    const reloadTxt = p.reloading ? ' [R]' : '';
    ctx.fillText(`${w.mag}/${def.magSize}  +${w.ammo}${reloadTxt}`, hx + 80, hy + 46);
  } else {
    ctx.fillStyle = '#666';
    ctx.font = '10px Courier New';
    ctx.fillText('No weapon', hx + 10, hy + 46);
  }

  // Weapon slots
  for (let i = 0; i < 2; i++) {
    const sx = hx - 45, sy = hy + i * 26;
    ctx.fillStyle = i === p.activeWeapon ? 'rgba(255,102,68,0.3)' : 'rgba(10,10,30,0.7)';
    ctx.strokeStyle = i === p.activeWeapon ? '#f64' : '#444';
    ctx.lineWidth = 1;
    roundRect(ctx, sx, sy, 38, 22, 3);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#aaa';
    ctx.font = '8px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(p.weapons[i] ? p.weapons[i].type.substring(0, 4) : '---', sx + 19, sy + 15);
    ctx.textAlign = 'left';
  }

  // Reload bar
  if (p.reloading) {
    const wc = p.weapons[p.activeWeapon];
    if (wc) {
      const def = WEAPON_DEFS[wc.type];
      const pct = (performance.now() - p.reloadStart) / def.reloadTime;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(CW/2 - 40, CH/2 + 25, 80, 6);
      ctx.fillStyle = '#fa0';
      ctx.fillRect(CW/2 - 40, CH/2 + 25, 80 * Math.min(1, pct), 6);
      ctx.fillStyle = '#fff';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Reloading...', CW/2, CH/2 + 22);
      ctx.textAlign = 'left';
    }
  }

  // Crosshair
  if (p.alive) {
    const cx = mouse.x, cy = mouse.y;
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx - 4, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 4, cy); ctx.lineTo(cx + 10, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy - 4); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy + 4); ctx.lineTo(cx, cy + 10); ctx.stroke();
  }

  // Zone timer
  const timeToShrink = Math.max(0, nextZoneTime - gameTime);
  if (timeToShrink > 0 && zonePhase < 7) {
    ctx.fillStyle = 'rgba(10,10,30,0.8)';
    ctx.fillRect(CW/2 - 50, 8, 100, 20);
    ctx.strokeStyle = '#f64';
    ctx.lineWidth = 1;
    ctx.strokeRect(CW/2 - 50, 8, 100, 20);
    ctx.fillStyle = '#f64';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`Zone ${zonePhase+1}: ${Math.ceil(timeToShrink/1000)}s`, CW/2, 22);
    ctx.textAlign = 'left';
  }
}

function drawMinimap() {
  const mw = 120, mh = 120;
  const mx = CW - mw - 10, my = 10;
  const scale = mw / MAP_W;

  ctx.fillStyle = 'rgba(10,10,30,0.85)';
  ctx.strokeStyle = '#f64';
  ctx.lineWidth = 1;
  ctx.fillRect(mx, my, mw, mh);
  ctx.strokeRect(mx, my, mw, mh);

  // Buildings on minimap
  ctx.fillStyle = 'rgba(100,100,120,0.5)';
  for (const b of buildings) {
    ctx.fillRect(mx + b.x * scale, my + b.y * scale, Math.max(1, b.w * scale), Math.max(1, b.h * scale));
  }

  // Zone circle
  ctx.beginPath();
  ctx.arc(mx + zone.x * scale, my + zone.y * scale, zone.r * scale, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,102,68,0.7)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Target zone
  if (zoneTarget.r < zone.r - 5) {
    ctx.beginPath();
    ctx.arc(mx + zoneTarget.x * scale, my + zoneTarget.y * scale, zoneTarget.r * scale, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Players
  for (const p of players) {
    if (!p.alive) continue;
    ctx.fillStyle = p.color;
    const px = mx + p.x * scale;
    const py = my + p.y * scale;
    if (p.id === 0) {
      // Player arrow
      ctx.fillRect(px - 2.5, py - 2.5, 5, 5);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(px - 2.5, py - 2.5, 5, 5);
    } else {
      ctx.beginPath();
      ctx.arc(px, py, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Camera view box
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(mx + camera.x * scale, my + camera.y * scale, CW * scale, CH * scale);
}

function drawKillFeed() {
  const now = gameTime;
  let y = 40;
  ctx.textAlign = 'left';
  for (let i = 0; i < killFeed.length; i++) {
    const kf = killFeed[i];
    const age = now - kf.time;
    if (age > 6000) continue;
    const alpha = age > 4000 ? 1 - (age - 4000) / 2000 : 1;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(10,10,30,0.7)';
    ctx.fillRect(10, y, 180, 18);
    ctx.font = '10px Courier New';
    ctx.fillStyle = kf.color;
    if (kf.killer) {
      ctx.fillText(`${kf.killer}`, 14, y + 13);
      ctx.fillStyle = '#888';
      ctx.fillText(' > ', 14 + ctx.measureText(kf.killer).width, y + 13);
      ctx.fillStyle = '#ccc';
      ctx.fillText(kf.victim, 14 + ctx.measureText(kf.killer + ' > ').width, y + 13);
    } else {
      ctx.fillText(kf.victim, 14, y + 13);
    }
    y += 20;
  }
  ctx.globalAlpha = 1;
}

function drawInventory() {
  const p = players[0];
  const iw = 220, ih = 200;
  const ix = CW/2 - iw/2, iy = CW/2 - ih/2;

  ctx.fillStyle = 'rgba(10,10,30,0.92)';
  ctx.strokeStyle = '#f64';
  ctx.lineWidth = 2;
  roundRect(ctx, ix, iy, iw, ih, 8);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#f64';
  ctx.font = 'bold 14px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('INVENTORY', ix + iw/2, iy + 24);

  ctx.textAlign = 'left';
  ctx.font = '11px Courier New';
  let y = iy + 45;

  // Weapons
  for (let i = 0; i < 2; i++) {
    const w = p.weapons[i];
    ctx.fillStyle = i === p.activeWeapon ? '#f64' : '#888';
    ctx.fillText(`Slot ${i+1}: `, ix + 16, y);
    if (w) {
      ctx.fillStyle = WEAPON_DEFS[w.type].color;
      ctx.fillText(`${w.type}`, ix + 70, y);
      ctx.fillStyle = '#aaa';
      ctx.fillText(`${w.mag}/${WEAPON_DEFS[w.type].magSize} +${w.ammo}`, ix + 140, y);
    } else {
      ctx.fillStyle = '#555';
      ctx.fillText('Empty', ix + 70, y);
    }
    y += 20;
  }

  y += 10;
  ctx.fillStyle = '#4f4';
  ctx.fillText(`Health:  ${Math.ceil(p.hp)} / ${p.maxHp}`, ix + 16, y);
  y += 18;
  ctx.fillStyle = '#48f';
  ctx.fillText(`Armor:   ${Math.ceil(p.armor)} / ${p.maxArmor}`, ix + 16, y);
  y += 26;

  ctx.fillStyle = '#888';
  ctx.font = '9px Courier New';
  ctx.fillText(`Kills: ${p.kills}`, ix + 16, y);
  y += 14;
  ctx.fillText(`Alive: ${players.filter(q => q.alive).length} / 8`, ix + 16, y);
  y += 14;
  ctx.fillText(`Zone Phase: ${zonePhase}`, ix + 16, y);

  ctx.textAlign = 'left';
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ---- EXPOSE GAME DATA ----
window.gameData = {};
function updateGameData() {
  window.gameData = {
    gameState,
    score,
    kills: players[0] ? players[0].kills : 0,
    alive: players.filter(p => p.alive).length,
    zonePhase,
    placement: players[0] ? players[0].placement : 0
  };
}

// ---- INIT ----
showOverlay();
// Keep game data updated
setInterval(updateGameData, 500);
</script>
<script src="../recorder.js?v=2"></script>
</body>
</html>

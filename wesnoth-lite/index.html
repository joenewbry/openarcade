<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battle for Wesnoth Lite</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #6bf; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102, 187, 255, 0.4); }
    h1 { color: #6bf; font-size: 1.6rem; text-shadow: 0 0 15px rgba(102, 187, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #6bf; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.8rem;
      color: #888;
    }
    .info-bar .day { color: #fa4; }
    .info-bar .night { color: #88f; }
    canvas {
      border: 2px solid #6bf;
      box-shadow: 0 0 20px rgba(102, 187, 255, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6bf;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(102, 187, 255, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .highlight { color: #6bf; font-size: 1.1rem; }
    .help-bar {
      width: 600px;
      margin-top: 8px;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BATTLE FOR WESNOTH LITE</h1>
  </div>
  <div class="score-bar">
    <div>Gold: <span id="gold">0</span> | Score: <span id="score">0</span></div>
    <div>Turn: <span id="turn">1</span></div>
    <div>AI Gold: <span id="aiGold">0</span> | AI Score: <span id="aiScore">0</span></div>
  </div>
  <div class="info-bar">
    <div id="cycleInfo">Dawn</div>
    <div id="phaseInfo">Your Turn - Select a unit or castle to recruit</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">BATTLE FOR WESNOTH LITE</h2>
      <p id="overlayText">Hex tactics with recruitment, terrain & day/night</p>
      <p class="highlight" style="margin-top:12px;">Click to start</p>
    </div>
  </div>
  <div class="help-bar" id="helpBar">Click unit to select | Click hex to move/attack | Click castle to recruit | End Turn: spacebar or button below</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const goldEl = document.getElementById('gold');
    const scoreEl = document.getElementById('score');
    const turnEl = document.getElementById('turn');
    const aiGoldEl = document.getElementById('aiGold');
    const aiScoreEl = document.getElementById('aiScore');
    const cycleInfoEl = document.getElementById('cycleInfo');
    const phaseInfoEl = document.getElementById('phaseInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const helpBar = document.getElementById('helpBar');

    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });

    let gameState = 'start'; // start, playing, gameover
    let score = 0;
    let aiScoreVal = 0;

    // ===== HEX GRID CONSTANTS =====
    const COLS = 12, ROWS = 10;
    const HEX_SIZE = 22;
    const HEX_W = HEX_SIZE * Math.sqrt(3);
    const HEX_H = HEX_SIZE * 2;
    const GRID_OFFSET_X = 28;
    const GRID_OFFSET_Y = 22;

    // ===== TERRAIN =====
    const T_GRASS = 0, T_FOREST = 1, T_HILLS = 2, T_WATER = 3, T_VILLAGE = 4, T_CASTLE = 5;
    const TERRAIN_NAMES = ['Grass','Forest','Hills','Water','Village','Castle'];
    const TERRAIN_DEF = [0, 20, 30, 0, 10, 20]; // defense bonus %
    const TERRAIN_COST = [1, 2, 2, 99, 1, 1]; // movement cost
    const TERRAIN_COLORS = ['#4a7a3a','#2d5a1e','#8a7a5a','#2a4a8a','#aa8844','#888888'];

    // ===== UNIT TYPES =====
    const U_SWORDSMAN = 0, U_ARCHER = 1, U_CAVALRY = 2, U_MAGE = 3, U_LEADER = 4;
    const UNIT_DATA = [
      { name:'Swordsman', hp:38, atk:9, atkCount:2, def:4, move:4, range:1, cost:14, align:'lawful', sym:'S', color:'#ddd' },
      { name:'Archer',    hp:30, atk:6, atkCount:3, def:3, move:5, range:2, cost:15, align:'neutral', sym:'A', color:'#8f8' },
      { name:'Cavalry',   hp:34, atk:8, atkCount:2, def:3, move:7, range:1, cost:18, align:'lawful', sym:'C', color:'#ff8' },
      { name:'Mage',      hp:24, atk:7, atkCount:2, def:2, move:5, range:2, cost:16, align:'chaotic', sym:'M', color:'#f8f' },
      { name:'Leader',    hp:42, atk:8, atkCount:3, def:5, move:5, range:1, cost:0,  align:'lawful', sym:'L', color:'#fff' }
    ];

    // ===== GAME STATE =====
    let terrain = [];
    let units = [];
    let turnNumber = 1;
    let playerGold = 100, aiGold = 100;
    let playerIncome = 2, aiIncome = 2;
    let selectedUnit = null;
    let moveHighlights = [];
    let attackHighlights = [];
    let recruitMode = false;
    let recruitHex = null;
    let phase = 'player'; // player, ai
    let animating = false;
    let floatingTexts = [];
    let dayNight = 'day'; // day, night, dawn, dusk

    // ===== HEX MATH =====
    function hexToPixel(c, r) {
      const x = GRID_OFFSET_X + c * HEX_W + (r % 2 === 1 ? HEX_W / 2 : 0);
      const y = GRID_OFFSET_Y + r * HEX_H * 0.75;
      return { x, y };
    }

    function pixelToHex(px, py) {
      let best = null, bestDist = Infinity;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const { x, y } = hexToPixel(c, r);
          const d = Math.hypot(px - x, py - y);
          if (d < bestDist) { bestDist = d; best = { c, r }; }
        }
      }
      return bestDist < HEX_SIZE * 1.1 ? best : null;
    }

    function hexDistance(c1, r1, c2, r2) {
      const ax = c1 - (r1 - (r1 & 1)) / 2;
      const az = r1;
      const ay = -ax - az;
      const bx = c2 - (r2 - (r2 & 1)) / 2;
      const bz = r2;
      const by = -bx - bz;
      return Math.max(Math.abs(ax - bx), Math.abs(ay - by), Math.abs(az - bz));
    }

    function hexNeighbors(c, r) {
      const neighbors = [];
      const dirs = r % 2 === 0
        ? [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1]]
        : [[-1,0],[1,0],[0,-1],[0,1],[1,-1],[1,1]];
      for (const [dc, dr] of dirs) {
        const nc = c + dc, nr = r + dr;
        if (nc >= 0 && nc < COLS && nr >= 0 && nr < ROWS) neighbors.push({ c: nc, r: nr });
      }
      return neighbors;
    }

    // ===== MAP GENERATION =====
    function generateMap() {
      terrain = [];
      for (let r = 0; r < ROWS; r++) {
        terrain[r] = [];
        for (let c = 0; c < COLS; c++) {
          const rnd = Math.random();
          if (rnd < 0.12) terrain[r][c] = T_FOREST;
          else if (rnd < 0.20) terrain[r][c] = T_HILLS;
          else if (rnd < 0.26) terrain[r][c] = T_WATER;
          else if (rnd < 0.32) terrain[r][c] = T_VILLAGE;
          else terrain[r][c] = T_GRASS;
        }
      }
      // Player castle area (bottom-left)
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const rr = 8 + dr, cc = 1 + dc;
          if (rr >= 0 && rr < ROWS && cc >= 0 && cc < COLS) terrain[rr][cc] = T_CASTLE;
        }
      }
      terrain[8][1] = T_CASTLE; // center
      // AI castle area (top-right)
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const rr = 1 + dr, cc = 10 + dc;
          if (rr >= 0 && rr < ROWS && cc >= 0 && cc < COLS) terrain[rr][cc] = T_CASTLE;
        }
      }
      terrain[1][10] = T_CASTLE;
      // Ensure path (no water near castles)
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (terrain[r][c] === T_WATER) {
            if (hexDistance(c, r, 1, 8) <= 3 || hexDistance(c, r, 10, 1) <= 3) {
              terrain[r][c] = T_GRASS;
            }
          }
        }
      }
      // Place some guaranteed villages in middle
      const midVillages = [[4,4],[7,5],[5,6],[8,3],[3,7]];
      for (const [c,r] of midVillages) {
        if (terrain[r][c] !== T_CASTLE) terrain[r][c] = T_VILLAGE;
      }
    }

    // ===== UNIT MANAGEMENT =====
    function createUnit(type, owner, c, r) {
      const d = UNIT_DATA[type];
      return {
        type, owner, c, r,
        hp: d.hp, maxHp: d.hp,
        moved: false, attacked: false
      };
    }

    function unitAt(c, r) {
      return units.find(u => u.c === c && u.r === r && u.hp > 0);
    }

    function getReachable(unit) {
      const d = UNIT_DATA[unit.type];
      const maxMove = d.move;
      const visited = {};
      const queue = [{ c: unit.c, r: unit.r, cost: 0 }];
      visited[`${unit.c},${unit.r}`] = 0;
      const results = [];
      while (queue.length > 0) {
        const cur = queue.shift();
        if (cur.cost > 0) {
          const occ = unitAt(cur.c, cur.r);
          if (!occ) results.push({ c: cur.c, r: cur.r, cost: cur.cost });
        }
        if (cur.cost >= maxMove) continue;
        for (const nb of hexNeighbors(cur.c, cur.r)) {
          const t = terrain[nb.r][nb.c];
          const moveCost = TERRAIN_COST[t];
          if (moveCost >= 99) continue;
          const newCost = cur.cost + moveCost;
          if (newCost > maxMove) continue;
          const key = `${nb.c},${nb.r}`;
          if (visited[key] !== undefined && visited[key] <= newCost) continue;
          const occ = unitAt(nb.c, nb.r);
          if (occ && occ.owner !== unit.owner) continue; // can't move through enemies
          visited[key] = newCost;
          queue.push({ c: nb.c, r: nb.r, cost: newCost });
        }
      }
      return results;
    }

    function getAttackTargets(unit) {
      const d = UNIT_DATA[unit.type];
      const range = d.range;
      const targets = [];
      for (const other of units) {
        if (other.hp <= 0 || other.owner === unit.owner) continue;
        if (hexDistance(unit.c, unit.r, other.c, other.r) <= range) {
          targets.push(other);
        }
      }
      return targets;
    }

    // ===== COMBAT =====
    function getDayNightMod(align) {
      if (align === 'lawful') return dayNight === 'day' ? 1.25 : dayNight === 'night' ? 0.75 : 1;
      if (align === 'chaotic') return dayNight === 'night' ? 1.25 : dayNight === 'day' ? 0.75 : 1;
      return 1;
    }

    function resolveCombat(attacker, defender) {
      const ad = UNIT_DATA[attacker.type];
      const dd = UNIT_DATA[defender.type];
      const defTerrain = terrain[defender.r][defender.c];
      const atkTerrain = terrain[attacker.r][attacker.c];
      const defBonus = TERRAIN_DEF[defTerrain] / 100;
      const atkBonus = TERRAIN_DEF[atkTerrain] / 100;

      const atkMod = getDayNightMod(ad.align);
      const defMod = getDayNightMod(dd.align);

      let totalDmgToDefender = 0, totalDmgToAttacker = 0;
      const messages = [];

      // Attacker strikes
      for (let i = 0; i < ad.atkCount; i++) {
        if (defender.hp <= 0) break;
        let dmg = Math.round(ad.atk * atkMod * (1 - defBonus));
        dmg = Math.max(1, dmg + Math.floor(Math.random() * 3) - 1);
        defender.hp -= dmg;
        totalDmgToDefender += dmg;
      }

      // Defender retaliates (if alive and in range)
      if (defender.hp > 0) {
        const retRange = dd.range;
        const dist = hexDistance(attacker.c, attacker.r, defender.c, defender.r);
        if (dist <= retRange) {
          for (let i = 0; i < dd.atkCount; i++) {
            if (attacker.hp <= 0) break;
            let dmg = Math.round(dd.atk * defMod * (1 - atkBonus));
            dmg = Math.max(1, dmg + Math.floor(Math.random() * 3) - 1);
            attacker.hp -= dmg;
            totalDmgToAttacker += dmg;
          }
        }
      }

      // Floating damage text
      const dp = hexToPixel(defender.c, defender.r);
      floatingTexts.push({ x: dp.x, y: dp.y - 10, text: `-${totalDmgToDefender}`, color: '#f44', life: 60 });
      if (totalDmgToAttacker > 0) {
        const ap = hexToPixel(attacker.c, attacker.r);
        floatingTexts.push({ x: ap.x, y: ap.y - 10, text: `-${totalDmgToAttacker}`, color: '#f44', life: 60 });
      }

      // Remove dead units
      if (defender.hp <= 0) {
        if (defender.owner === 1) { score += 5; } else { aiScoreVal += 5; }
      }
      if (attacker.hp <= 0) {
        if (attacker.owner === 1) { score += 5; } else { aiScoreVal += 5; }
      }

      return { dmgToDefender: totalDmgToDefender, dmgToAttacker: totalDmgToAttacker };
    }

    // ===== VILLAGE / INCOME =====
    function countVillages(owner) {
      let count = 0;
      for (const u of units) {
        if (u.hp > 0 && u.owner === owner && terrain[u.r][u.c] === T_VILLAGE) count++;
      }
      return count;
    }

    function getVillageOwner(c, r) {
      // Track which villages each player controls
      const u = unitAt(c, r);
      return u ? u.owner : -1;
    }

    let villageOwnership = {}; // "c,r" -> owner

    function updateVillageOwnership() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (terrain[r][c] === T_VILLAGE) {
            const u = unitAt(c, r);
            if (u) villageOwnership[`${c},${r}`] = u.owner;
          }
        }
      }
    }

    function countOwnedVillages(owner) {
      let count = 0;
      for (const key in villageOwnership) {
        if (villageOwnership[key] === owner) count++;
      }
      return count;
    }

    // ===== DAY/NIGHT CYCLE =====
    function updateDayNight() {
      const phase = turnNumber % 6;
      if (phase === 1 || phase === 2) { dayNight = 'day'; }
      else if (phase === 3) { dayNight = 'dusk'; }
      else if (phase === 4 || phase === 5) { dayNight = 'night'; }
      else { dayNight = 'dawn'; }
    }

    // ===== RECRUITMENT =====
    function canRecruit(owner, c, r) {
      if (terrain[r][c] !== T_CASTLE) return false;
      if (unitAt(c, r)) return false;
      // Must be adjacent to own leader or another castle with own unit
      const hasLeader = units.some(u => u.hp > 0 && u.owner === owner && u.type === U_LEADER
        && terrain[u.r][u.c] === T_CASTLE);
      return hasLeader;
    }

    function getRecruitHexes(owner) {
      const hexes = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (canRecruit(owner, c, r)) hexes.push({ c, r });
        }
      }
      return hexes;
    }

    function recruitUnit(type, owner, c, r) {
      const cost = UNIT_DATA[type].cost;
      if (owner === 0) {
        if (playerGold < cost) return false;
        playerGold -= cost;
      } else {
        if (aiGold < cost) return false;
        aiGold -= cost;
      }
      const u = createUnit(type, owner, c, r);
      u.moved = true;
      u.attacked = true;
      units.push(u);
      return true;
    }

    // ===== TURN MANAGEMENT =====
    function startPlayerTurn() {
      phase = 'player';
      playerGold += 2 + countOwnedVillages(0);
      playerIncome = 2 + countOwnedVillages(0);
      for (const u of units) {
        if (u.owner === 0 && u.hp > 0) {
          u.moved = false;
          u.attacked = false;
          // Heal on village
          if (terrain[u.r][u.c] === T_VILLAGE || terrain[u.r][u.c] === T_CASTLE) {
            u.hp = Math.min(u.maxHp, u.hp + 4);
          }
        }
      }
      selectedUnit = null;
      moveHighlights = [];
      attackHighlights = [];
      recruitMode = false;
      updateDayNight();
      updateUI();
      phaseInfoEl.textContent = 'Your Turn - Select a unit or castle to recruit';
      render();
    }

    function endPlayerTurn() {
      if (animating) return;
      selectedUnit = null;
      moveHighlights = [];
      attackHighlights = [];
      recruitMode = false;
      updateVillageOwnership();
      score += countOwnedVillages(0);
      phase = 'ai';
      phaseInfoEl.textContent = 'AI is thinking...';
      render();
      setTimeout(doAITurn, 400);
    }

    function doAITurn() {
      aiGold += 2 + countOwnedVillages(1);
      aiIncome = 2 + countOwnedVillages(1);
      for (const u of units) {
        if (u.owner === 1 && u.hp > 0) {
          u.moved = false;
          u.attacked = false;
          if (terrain[u.r][u.c] === T_VILLAGE || terrain[u.r][u.c] === T_CASTLE) {
            u.hp = Math.min(u.maxHp, u.hp + 4);
          }
        }
      }

      // AI Recruitment
      aiRecruit();

      // AI Move & Attack
      aiMoveAndAttack();

      updateVillageOwnership();
      aiScoreVal += countOwnedVillages(1);

      // Remove dead
      units = units.filter(u => u.hp > 0);

      // Check win condition
      if (!units.some(u => u.owner === 1 && u.type === U_LEADER && u.hp > 0)) {
        gameState = 'gameover';
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = `You defeated the enemy leader! Score: ${score}`;
        overlay.querySelector('.highlight').textContent = 'Click to play again';
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
        updateUI();
        render();
        return;
      }
      if (!units.some(u => u.owner === 0 && u.type === U_LEADER && u.hp > 0)) {
        gameState = 'gameover';
        overlayTitle.textContent = 'DEFEAT';
        overlayText.textContent = `Your leader has fallen! Score: ${score}`;
        overlay.querySelector('.highlight').textContent = 'Click to play again';
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
        updateUI();
        render();
        return;
      }

      turnNumber++;
      updateDayNight();
      startPlayerTurn();
    }

    // ===== AI =====
    function aiRecruit() {
      const recruitHexes = getRecruitHexes(1);
      if (recruitHexes.length === 0) return;

      // Evaluate what to recruit based on army composition and needs
      const aiUnits = units.filter(u => u.owner === 1 && u.hp > 0 && u.type !== U_LEADER);
      const swords = aiUnits.filter(u => u.type === U_SWORDSMAN).length;
      const archers = aiUnits.filter(u => u.type === U_ARCHER).length;
      const cavs = aiUnits.filter(u => u.type === U_CAVALRY).length;
      const mages = aiUnits.filter(u => u.type === U_MAGE).length;
      const total = aiUnits.length;

      let tries = 3;
      while (tries > 0 && recruitHexes.length > 0) {
        tries--;
        // Pick type: balanced army with situational awareness
        let type;
        if (total < 2 || swords < 1) type = U_SWORDSMAN;
        else if (archers < 1) type = U_ARCHER;
        else if (dayNight === 'night' && mages < 2) type = U_MAGE;
        else if (cavs < 2) type = U_CAVALRY;
        else {
          const r = Math.random();
          if (r < 0.35) type = U_SWORDSMAN;
          else if (r < 0.55) type = U_ARCHER;
          else if (r < 0.75) type = U_CAVALRY;
          else type = U_MAGE;
        }

        if (aiGold < UNIT_DATA[type].cost) break;

        const hex = recruitHexes.shift();
        if (hex && !unitAt(hex.c, hex.r)) {
          recruitUnit(type, 1, hex.c, hex.r);
        }
      }
    }

    function aiMoveAndAttack() {
      const aiUnitList = units.filter(u => u.owner === 1 && u.hp > 0 && u.type !== U_LEADER);
      // Sort: units closer to enemies first
      const playerLeader = units.find(u => u.owner === 0 && u.type === U_LEADER && u.hp > 0);

      for (const unit of aiUnitList) {
        if (unit.hp <= 0 || unit.moved) continue;
        aiActUnit(unit, playerLeader);
      }

      // Move leader cautiously
      const aiLeader = units.find(u => u.owner === 1 && u.type === U_LEADER && u.hp > 0);
      if (aiLeader && !aiLeader.moved) {
        aiActLeader(aiLeader);
      }

      units = units.filter(u => u.hp > 0);
    }

    function aiActUnit(unit, playerLeader) {
      const reachable = getReachable(unit);
      let bestScore = -Infinity;
      let bestMove = null;
      let bestTarget = null;

      for (const dest of [{ c: unit.c, r: unit.r }, ...reachable]) {
        // Temporarily move
        const origC = unit.c, origR = unit.r;
        unit.c = dest.c; unit.r = dest.r;

        // Evaluate this position
        let posScore = 0;

        // Terrain defense bonus
        posScore += TERRAIN_DEF[terrain[dest.r][dest.c]] * 0.5;

        // Village capture bonus
        if (terrain[dest.r][dest.c] === T_VILLAGE && villageOwnership[`${dest.c},${dest.r}`] !== 1) {
          posScore += 25;
        }

        // Attack evaluation
        const targets = getAttackTargets(unit);
        let bestAttackScore = 0;
        let attackTarget = null;
        for (const t of targets) {
          let atkScore = 0;
          const td = UNIT_DATA[t.type];
          // Prefer killing blows
          const estimatedDmg = UNIT_DATA[unit.type].atk * UNIT_DATA[unit.type].atkCount * getDayNightMod(UNIT_DATA[unit.type].align) * (1 - TERRAIN_DEF[terrain[t.r][t.c]] / 100);
          if (t.hp <= estimatedDmg) atkScore += 50; // killing blow
          atkScore += estimatedDmg * 0.5;
          // Prefer leader
          if (t.type === U_LEADER) atkScore += 60;
          // Prefer wounded
          atkScore += (1 - t.hp / td.hp) * 20;
          if (atkScore > bestAttackScore) {
            bestAttackScore = atkScore;
            attackTarget = t;
          }
        }
        posScore += bestAttackScore;

        // Advance toward player (distance heuristic)
        if (playerLeader) {
          const dist = hexDistance(dest.c, dest.r, playerLeader.c, playerLeader.r);
          posScore += (15 - dist) * 2;
        }

        // Avoid bunching
        const nearbyAllies = units.filter(u => u.owner === 1 && u.hp > 0 && u !== unit && hexDistance(u.c, u.r, dest.c, dest.r) <= 1).length;
        if (nearbyAllies > 2) posScore -= 10;

        unit.c = origC; unit.r = origR;

        if (posScore > bestScore) {
          bestScore = posScore;
          bestMove = dest;
          bestTarget = attackTarget;
        }
      }

      if (bestMove && (bestMove.c !== unit.c || bestMove.r !== unit.r)) {
        unit.c = bestMove.c;
        unit.r = bestMove.r;
      }
      unit.moved = true;

      if (bestTarget && bestTarget.hp > 0) {
        resolveCombat(unit, bestTarget);
        unit.attacked = true;
      }
    }

    function aiActLeader(leader) {
      // Leader stays near castle but might move to adjacent village
      const reachable = getReachable(leader);
      let bestScore = -Infinity;
      let bestMove = { c: leader.c, r: leader.r };

      for (const dest of [{ c: leader.c, r: leader.r }, ...reachable]) {
        let s = 0;
        // Prefer staying in castle
        if (terrain[dest.r][dest.c] === T_CASTLE) s += 30;
        // Some defense
        s += TERRAIN_DEF[terrain[dest.r][dest.c]];
        // Avoid enemies
        const nearEnemies = units.filter(u => u.owner === 0 && u.hp > 0 && hexDistance(u.c, u.r, dest.c, dest.r) <= 2).length;
        s -= nearEnemies * 15;
        if (s > bestScore) { bestScore = s; bestMove = dest; }
      }

      if (bestMove.c !== leader.c || bestMove.r !== leader.r) {
        leader.c = bestMove.c;
        leader.r = bestMove.r;
      }
      leader.moved = true;

      // Leader attacks if opportunity
      const targets = getAttackTargets(leader);
      if (targets.length > 0) {
        // Pick weakest
        targets.sort((a, b) => a.hp - b.hp);
        resolveCombat(leader, targets[0]);
        leader.attacked = true;
      }
    }

    // ===== DRAWING =====
    function drawHex(cx, cy, size, fill, stroke) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        const x = cx + size * Math.cos(angle);
        const y = cy + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      if (fill) { ctx.fillStyle = fill; ctx.fill(); }
      if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 1; ctx.stroke(); }
    }

    function getTerrainFill(t, c, r) {
      // Night tint
      const base = TERRAIN_COLORS[t];
      if (dayNight === 'night') return darkenColor(base, 0.6);
      if (dayNight === 'dusk' || dayNight === 'dawn') return darkenColor(base, 0.8);
      return base;
    }

    function darkenColor(hex, factor) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgb(${Math.floor(r * factor)},${Math.floor(g * factor)},${Math.floor(b * factor)})`;
    }

    function render() {
      // Background
      ctx.fillStyle = dayNight === 'night' ? '#0a0a1e' : dayNight === 'dusk' || dayNight === 'dawn' ? '#121228' : '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const { x, y } = hexToPixel(c, r);
          const t = terrain[r][c];
          const fill = getTerrainFill(t, c, r);
          const stroke = '#333';
          drawHex(x, y, HEX_SIZE - 1, fill, stroke);

          // Village flag
          if (t === T_VILLAGE) {
            const owner = villageOwnership[`${c},${r}`];
            ctx.fillStyle = owner === 0 ? '#4af' : owner === 1 ? '#f64' : '#aa8';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('\u2302', x, y - 8); // house symbol
          }

          // Terrain icon hints
          if (t === T_FOREST) {
            ctx.fillStyle = dayNight === 'night' ? '#1a3a0e' : '#2a5a1e';
            ctx.font = '12px serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u2663', x, y - 6); // club/tree
          }
          if (t === T_HILLS) {
            ctx.fillStyle = '#6a5a3a';
            ctx.font = '10px serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u25B2', x, y - 7);
          }
          if (t === T_WATER) {
            ctx.fillStyle = '#4a6aaa';
            ctx.font = '10px serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u2248', x, y - 4);
          }
          if (t === T_CASTLE) {
            ctx.fillStyle = '#aaa';
            ctx.font = '9px serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u2656', x, y - 7); // rook
          }
        }
      }

      // Move highlights
      for (const h of moveHighlights) {
        const { x, y } = hexToPixel(h.c, h.r);
        drawHex(x, y, HEX_SIZE - 2, 'rgba(100,180,255,0.25)', '#6bf');
      }

      // Attack highlights
      for (const h of attackHighlights) {
        const { x, y } = hexToPixel(h.c, h.r);
        drawHex(x, y, HEX_SIZE - 2, 'rgba(255,80,80,0.3)', '#f44');
      }

      // Recruit highlights
      if (recruitMode) {
        const rHexes = getRecruitHexes(0);
        for (const h of rHexes) {
          const { x, y } = hexToPixel(h.c, h.r);
          drawHex(x, y, HEX_SIZE - 2, 'rgba(255,200,50,0.25)', '#fa4');
        }
      }

      // Draw units
      for (const unit of units) {
        if (unit.hp <= 0) continue;
        const { x, y } = hexToPixel(unit.c, unit.r);
        const d = UNIT_DATA[unit.type];

        // Unit circle
        const isSelected = selectedUnit === unit;
        const playerColor = unit.owner === 0 ? '#4af' : '#f64';
        ctx.beginPath();
        ctx.arc(x, y + 2, 9, 0, Math.PI * 2);
        ctx.fillStyle = playerColor;
        ctx.globalAlpha = isSelected ? 1 : 0.8;
        ctx.fill();
        ctx.globalAlpha = 1;
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Unit symbol
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(d.sym, x, y + 2);

        // HP bar
        const hpPct = unit.hp / unit.maxHp;
        const barW = 16, barH = 3;
        ctx.fillStyle = '#333';
        ctx.fillRect(x - barW / 2, y + 12, barW, barH);
        ctx.fillStyle = hpPct > 0.5 ? '#4c4' : hpPct > 0.25 ? '#cc4' : '#c44';
        ctx.fillRect(x - barW / 2, y + 12, barW * hpPct, barH);

        // Dimmed if moved
        if (unit.moved && unit.owner === 0 && phase === 'player') {
          ctx.beginPath();
          ctx.arc(x, y + 2, 9, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.35)';
          ctx.fill();
        }
      }

      // Floating texts
      for (const ft of floatingTexts) {
        ctx.fillStyle = ft.color;
        ctx.globalAlpha = ft.life / 60;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1;
        ft.y -= 0.5;
        ft.life--;
      }
      floatingTexts = floatingTexts.filter(f => f.life > 0);

      // Recruit menu
      if (recruitMode) {
        drawRecruitMenu();
      }

      // Tooltip for selected unit
      if (selectedUnit && selectedUnit.hp > 0 && !recruitMode) {
        drawUnitInfo(selectedUnit);
      }

      // Day/night indicator
      const dnIcon = dayNight === 'day' ? '\u2600' : dayNight === 'night' ? '\u263E' : '\u263C';
      ctx.fillStyle = dayNight === 'day' ? '#fa4' : dayNight === 'night' ? '#88f' : '#ca8';
      ctx.font = '16px serif';
      ctx.textAlign = 'right';
      ctx.fillText(dnIcon + ' ' + dayNight.charAt(0).toUpperCase() + dayNight.slice(1), W - 10, H - 10);

      // End Turn button
      if (phase === 'player' && gameState === 'playing') {
        ctx.fillStyle = '#334';
        ctx.strokeStyle = '#6bf';
        ctx.lineWidth = 1.5;
        const bx = W - 90, by = H - 35, bw = 80, bh = 24;
        ctx.fillRect(bx, by, bw, bh);
        ctx.strokeRect(bx, by, bw, bh);
        ctx.fillStyle = '#6bf';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('END TURN', bx + bw / 2, by + bh / 2);
      }
    }

    function drawRecruitMenu() {
      const mx = 150, my = 140, mw = 300, mh = 200;
      ctx.fillStyle = 'rgba(20,20,40,0.95)';
      ctx.strokeStyle = '#6bf';
      ctx.lineWidth = 2;
      ctx.fillRect(mx, my, mw, mh);
      ctx.strokeRect(mx, my, mw, mh);

      ctx.fillStyle = '#6bf';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('RECRUIT (Gold: ' + playerGold + ')', mx + mw / 2, my + 22);

      const types = [U_SWORDSMAN, U_ARCHER, U_CAVALRY, U_MAGE];
      for (let i = 0; i < types.length; i++) {
        const d = UNIT_DATA[types[i]];
        const ry = my + 42 + i * 38;
        const canAfford = playerGold >= d.cost;

        ctx.fillStyle = canAfford ? '#223' : '#1a1a2e';
        ctx.strokeStyle = canAfford ? '#6bf' : '#444';
        ctx.lineWidth = 1;
        ctx.fillRect(mx + 15, ry, mw - 30, 32);
        ctx.strokeRect(mx + 15, ry, mw - 30, 32);

        ctx.fillStyle = canAfford ? d.color : '#555';
        ctx.font = '12px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`[${d.sym}] ${d.name}`, mx + 25, ry + 14);
        ctx.textAlign = 'right';
        ctx.fillText(`HP:${d.hp} ATK:${d.atk}x${d.atkCount} MV:${d.move} $${d.cost}`, mx + mw - 25, ry + 14);

        ctx.fillStyle = '#888';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(`Range:${d.range} Def:${d.def} ${d.align}`, mx + 25, ry + 26);
      }

      ctx.fillStyle = '#666';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('Click unit to recruit | ESC to cancel', mx + mw / 2, my + mh - 10);
    }

    function drawUnitInfo(unit) {
      const d = UNIT_DATA[unit.type];
      const infoW = 180, infoH = 65;
      const ix = 5, iy = H - infoH - 5;
      ctx.fillStyle = 'rgba(20,20,40,0.9)';
      ctx.strokeStyle = unit.owner === 0 ? '#4af' : '#f64';
      ctx.lineWidth = 1;
      ctx.fillRect(ix, iy, infoW, infoH);
      ctx.strokeRect(ix, iy, infoW, infoH);

      ctx.fillStyle = unit.owner === 0 ? '#4af' : '#f64';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`${d.name} (${unit.owner === 0 ? 'You' : 'AI'})`, ix + 8, iy + 14);

      ctx.fillStyle = '#ddd';
      ctx.font = '10px Courier New';
      ctx.fillText(`HP: ${unit.hp}/${unit.maxHp}  ATK: ${d.atk}x${d.atkCount}`, ix + 8, iy + 28);
      ctx.fillText(`DEF: ${d.def}  MV: ${d.move}  Range: ${d.range}`, ix + 8, iy + 40);

      const tName = TERRAIN_NAMES[terrain[unit.r][unit.c]];
      const tDef = TERRAIN_DEF[terrain[unit.r][unit.c]];
      ctx.fillStyle = '#888';
      ctx.fillText(`Terrain: ${tName} (+${tDef}% def)`, ix + 8, iy + 54);
    }

    // ===== INPUT =====
    canvas.addEventListener('click', e => {
      if (gameState === 'start') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        return;
      }
      if (gameState === 'gameover') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        return;
      }
      if (phase !== 'player' || animating) return;

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      // End turn button
      const bx = W - 90, by = H - 35, bw = 80, bh = 24;
      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
        endPlayerTurn();
        return;
      }

      // Recruit menu click
      if (recruitMode) {
        handleRecruitClick(mx, my);
        return;
      }

      const hex = pixelToHex(mx, my);
      if (!hex) return;

      // If we have a selected unit and click a move highlight
      if (selectedUnit && !selectedUnit.moved) {
        const moveTarget = moveHighlights.find(h => h.c === hex.c && h.r === hex.r);
        if (moveTarget) {
          selectedUnit.c = hex.c;
          selectedUnit.r = hex.r;
          selectedUnit.moved = true;
          // Check attacks from new position
          const targets = getAttackTargets(selectedUnit);
          if (targets.length > 0 && !selectedUnit.attacked) {
            moveHighlights = [];
            attackHighlights = targets.map(t => ({ c: t.c, r: t.r }));
            phaseInfoEl.textContent = 'Select target to attack';
            render();
            return;
          }
          selectedUnit = null;
          moveHighlights = [];
          attackHighlights = [];
          updateVillageOwnership();
          phaseInfoEl.textContent = 'Your Turn - Select a unit';
          render();
          return;
        }
      }

      // Attack target click
      if (selectedUnit && attackHighlights.length > 0 && !selectedUnit.attacked) {
        const atkTarget = attackHighlights.find(h => h.c === hex.c && h.r === hex.r);
        if (atkTarget) {
          const defender = unitAt(hex.c, hex.r);
          if (defender && defender.owner !== 0) {
            resolveCombat(selectedUnit, defender);
            selectedUnit.attacked = true;
            units = units.filter(u => u.hp > 0);
            selectedUnit = units.includes(selectedUnit) ? selectedUnit : null;
            moveHighlights = [];
            attackHighlights = [];
            checkWinCondition();
            phaseInfoEl.textContent = 'Your Turn - Select a unit';
            render();
            return;
          }
        }
      }

      // Click on own unit to select
      const clickedUnit = unitAt(hex.c, hex.r);
      if (clickedUnit && clickedUnit.owner === 0 && clickedUnit.hp > 0) {
        selectedUnit = clickedUnit;
        if (!clickedUnit.moved) {
          moveHighlights = getReachable(clickedUnit);
          // Also show attack from current position
          const targets = getAttackTargets(clickedUnit);
          attackHighlights = (!clickedUnit.attacked && targets.length > 0) ? targets.map(t => ({ c: t.c, r: t.r })) : [];
        } else if (!clickedUnit.attacked) {
          moveHighlights = [];
          const targets = getAttackTargets(clickedUnit);
          attackHighlights = targets.map(t => ({ c: t.c, r: t.r }));
        } else {
          moveHighlights = [];
          attackHighlights = [];
        }
        phaseInfoEl.textContent = `Selected: ${UNIT_DATA[clickedUnit.type].name} (${clickedUnit.hp}/${clickedUnit.maxHp} HP)`;
        render();
        return;
      }

      // Click on castle hex to recruit
      if (terrain[hex.r][hex.c] === T_CASTLE && !unitAt(hex.c, hex.r)) {
        const rHexes = getRecruitHexes(0);
        if (rHexes.some(h => h.c === hex.c && h.r === hex.r)) {
          recruitMode = true;
          recruitHex = hex;
          selectedUnit = null;
          moveHighlights = [];
          attackHighlights = [];
          phaseInfoEl.textContent = 'Choose a unit to recruit';
          render();
          return;
        }
      }

      // Click on enemy unit to show info
      if (clickedUnit && clickedUnit.owner === 1) {
        selectedUnit = clickedUnit;
        moveHighlights = [];
        attackHighlights = [];
        phaseInfoEl.textContent = `Enemy: ${UNIT_DATA[clickedUnit.type].name} (${clickedUnit.hp}/${clickedUnit.maxHp} HP)`;
        render();
        return;
      }

      // Deselect
      selectedUnit = null;
      moveHighlights = [];
      attackHighlights = [];
      phaseInfoEl.textContent = 'Your Turn - Select a unit or castle to recruit';
      render();
    });

    function handleRecruitClick(mx, my) {
      const menuX = 150, menuY = 140;
      const types = [U_SWORDSMAN, U_ARCHER, U_CAVALRY, U_MAGE];

      for (let i = 0; i < types.length; i++) {
        const ry = menuY + 42 + i * 38;
        if (mx >= menuX + 15 && mx <= menuX + 285 && my >= ry && my <= ry + 32) {
          const d = UNIT_DATA[types[i]];
          if (playerGold >= d.cost && recruitHex) {
            recruitUnit(types[i], 0, recruitHex.c, recruitHex.r);
            recruitMode = false;
            recruitHex = null;
            phaseInfoEl.textContent = 'Recruited ' + d.name + '!';
            render();
          }
          return;
        }
      }

      // Click outside menu cancels
      if (mx < 150 || mx > 450 || my < 140 || my > 340) {
        recruitMode = false;
        recruitHex = null;
        phaseInfoEl.textContent = 'Your Turn - Select a unit';
        render();
      }
    }

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        recruitMode = false;
        recruitHex = null;
        selectedUnit = null;
        moveHighlights = [];
        attackHighlights = [];
        phaseInfoEl.textContent = 'Your Turn - Select a unit';
        render();
      }
      if (e.key === ' ' && gameState === 'playing' && phase === 'player') {
        endPlayerTurn();
      }
    });

    function checkWinCondition() {
      if (!units.some(u => u.owner === 1 && u.type === U_LEADER && u.hp > 0)) {
        gameState = 'gameover';
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = `You defeated the enemy leader! Score: ${score}`;
        overlay.querySelector('.highlight').textContent = 'Click to play again';
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
      }
      if (!units.some(u => u.owner === 0 && u.type === U_LEADER && u.hp > 0)) {
        gameState = 'gameover';
        overlayTitle.textContent = 'DEFEAT';
        overlayText.textContent = `Your leader has fallen! Score: ${score}`;
        overlay.querySelector('.highlight').textContent = 'Click to play again';
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
      }
    }

    // ===== UI UPDATE =====
    function updateUI() {
      goldEl.textContent = playerGold;
      scoreEl.textContent = score;
      turnEl.textContent = turnNumber;
      aiGoldEl.textContent = aiGold;
      aiScoreEl.textContent = aiScoreVal;

      const dnClass = (dayNight === 'night') ? 'night' : 'day';
      cycleInfoEl.className = dnClass;
      cycleInfoEl.textContent = `${dayNight.charAt(0).toUpperCase() + dayNight.slice(1)} | Income: ${2 + countOwnedVillages(0)}/turn | Villages: ${countOwnedVillages(0)}`;
    }

    // ===== INIT =====
    function initGame() {
      generateMap();
      units = [];
      turnNumber = 1;
      playerGold = 100;
      aiGold = 100;
      score = 0;
      aiScoreVal = 0;
      selectedUnit = null;
      moveHighlights = [];
      attackHighlights = [];
      recruitMode = false;
      villageOwnership = {};
      floatingTexts = [];
      dayNight = 'day';

      // Place leaders
      units.push(createUnit(U_LEADER, 0, 1, 8));
      units.push(createUnit(U_LEADER, 1, 10, 1));

      // Starting units
      units.push(createUnit(U_SWORDSMAN, 0, 2, 8));
      units.push(createUnit(U_ARCHER, 0, 0, 8));
      units.push(createUnit(U_SWORDSMAN, 1, 9, 1));
      units.push(createUnit(U_ARCHER, 1, 11, 1));

      updateVillageOwnership();
      updateDayNight();
      updateUI();
      startPlayerTurn();
    }

    // ===== GAME LOOP =====
    function gameLoop() {
      if (gameState === 'playing') {
        render();
        updateUI();
      }
      requestAnimationFrame(gameLoop);
    }

    // Start
    gameLoop();
    render(); // initial draw behind overlay

    // ===== EXPOSE GAME DATA =====
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState,
        score,
        turnNumber,
        phase,
        dayNight,
        playerGold,
        aiGold,
        unitCount: units.filter(u => u.hp > 0).length
      };
    }
    setInterval(updateGameData, 500);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

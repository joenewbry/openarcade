<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Klotski</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #f8c; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 204, 0.4); }
    h1 { color: #f8c; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 204, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f8c; }
    canvas {
      border: 2px solid #f8c;
      box-shadow: 0 0 20px rgba(255, 136, 204, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f8c;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>KLOTSKI</h1>
  </div>
  <div class="score-bar">
    <div>Moves: <span id="score">0</span></div>
    <div>Best: <span id="best">-</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:500px;">
      <h2 id="overlayTitle">KLOTSKI</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid: 4 columns x 5 rows
    const COLS = 4, ROWS = 5;
    const PAD = 20;                        // padding around the grid
    const GAP = 4;                         // gap between cells
    const CELL = (W - 2 * PAD - (COLS - 1) * GAP) / COLS; // cell size
    const GRID_X = PAD;
    const GRID_Y = PAD;
    const GRID_W = COLS * CELL + (COLS - 1) * GAP;
    const GRID_H = ROWS * CELL + (ROWS - 1) * GAP;

    // Exit zone: bottom center, 2 cells wide
    const EXIT_COL = 1;
    const EXIT_ROW = ROWS; // just below the grid

    // Block colors (neon palette)
    const COLORS = {
      king:  { fill: '#f44', glow: '#f44', label: 'CAO' },   // 2x2 red - the main piece
      vert:  { fill: '#4af', glow: '#4af', label: '' },       // 1x2 blue
      horiz: { fill: '#4f4', glow: '#4f4', label: '' },       // 2x1 green
      small: { fill: '#fa0', glow: '#fa0', label: '' },       // 1x1 orange
    };

    // Puzzle configurations
    // Each block: { type, col, row, w, h }
    // Grid is 4 wide x 5 tall (20 cells). Each puzzle uses 18 cells, leaving 2 empty.
    // Block 0 is ALWAYS the king (2x2). Win = king at col=1, row=3.
    // Verified: each layout sums to 18 cells with no overlaps.
    const PUZZLES = [
      { // Level 1: "Heng Dao Li Ma" (横刀立马) - classic, ~81 moves optimal
        // Empties: (0,4) and (3,4)
        name: 'Heng Dao Li Ma',
        blocks: [
          { type: 'king',  col: 1, row: 0, w: 2, h: 2 }, // 4
          { type: 'vert',  col: 0, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 0, w: 1, h: 2 }, // 2
          { type: 'horiz', col: 1, row: 2, w: 2, h: 1 }, // 2
          { type: 'vert',  col: 0, row: 2, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 2, w: 1, h: 2 }, // 2
          { type: 'small', col: 1, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 4, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 4, w: 1, h: 1 }, // 1 = 18
        ]
      },
      { // Level 2: Empties: (1,4) and (2,4)
        name: 'Guard the Pass',
        blocks: [
          { type: 'king',  col: 1, row: 0, w: 2, h: 2 }, // 4
          { type: 'vert',  col: 0, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 0, row: 2, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 2, w: 1, h: 2 }, // 2
          { type: 'horiz', col: 1, row: 2, w: 2, h: 1 }, // 2
          { type: 'small', col: 0, row: 4, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 3, row: 4, w: 1, h: 1 }, // 1 = 18
        ]
      },
      { // Level 3: Empties: (0,4) and (3,4)
        name: 'Soldiers at the Gate',
        blocks: [
          { type: 'king',  col: 1, row: 0, w: 2, h: 2 }, // 4
          { type: 'vert',  col: 0, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 0, w: 1, h: 2 }, // 2
          { type: 'horiz', col: 1, row: 2, w: 2, h: 1 }, // 2
          { type: 'small', col: 0, row: 2, w: 1, h: 1 }, // 1
          { type: 'small', col: 3, row: 2, w: 1, h: 1 }, // 1
          { type: 'small', col: 0, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 3, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 4, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 4, w: 1, h: 1 }, // 1 = 18
        ]
      },
      { // Level 4: Empties: (1,4) and (2,4)
        name: 'Near the End',
        blocks: [
          { type: 'king',  col: 1, row: 0, w: 2, h: 2 }, // 4
          { type: 'vert',  col: 0, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 0, w: 1, h: 2 }, // 2
          { type: 'horiz', col: 0, row: 2, w: 2, h: 1 }, // 2
          { type: 'horiz', col: 2, row: 2, w: 2, h: 1 }, // 2
          { type: 'vert',  col: 0, row: 3, w: 1, h: 2 }, // 2
          { type: 'small', col: 1, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 3, w: 1, h: 1 }, // 1
          { type: 'vert',  col: 3, row: 3, w: 1, h: 2 }, // 2 = 18
        ]
      },
      { // Level 5: Empties: (0,4) and (3,4)
        name: 'Four Generals',
        blocks: [
          { type: 'king',  col: 1, row: 0, w: 2, h: 2 }, // 4
          { type: 'vert',  col: 0, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 0, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 0, row: 2, w: 1, h: 2 }, // 2
          { type: 'vert',  col: 3, row: 2, w: 1, h: 2 }, // 2
          { type: 'small', col: 1, row: 2, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 2, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 3, w: 1, h: 1 }, // 1
          { type: 'small', col: 1, row: 4, w: 1, h: 1 }, // 1
          { type: 'small', col: 2, row: 4, w: 1, h: 1 }, // 1 = 18
        ]
      },
    ];

    let score, best = null, gameState;
    let blocks, selectedIdx, currentLevel;
    let celebrateTimer, celebrateParticles;
    let dragStartCol, dragStartRow, isDragging;

    // Grid occupancy: grid[row][col] = block index or -1
    let grid;

    function buildGrid() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = -1;
        }
      }
      blocks.forEach((b, i) => {
        for (let dr = 0; dr < b.h; dr++) {
          for (let dc = 0; dc < b.w; dc++) {
            grid[b.row + dr][b.col + dc] = i;
          }
        }
      });
    }

    function cellToPixel(col, row) {
      return {
        x: GRID_X + col * (CELL + GAP),
        y: GRID_Y + row * (CELL + GAP)
      };
    }

    function pixelToCell(px, py) {
      const col = Math.floor((px - GRID_X) / (CELL + GAP));
      const row = Math.floor((py - GRID_Y) / (CELL + GAP));
      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return null;
      return { col, row };
    }

    function canMove(blockIdx, dc, dr) {
      const b = blocks[blockIdx];
      const newCol = b.col + dc;
      const newRow = b.row + dr;
      // Bounds check
      if (newCol < 0 || newCol + b.w > COLS) return false;
      if (newRow < 0 || newRow + b.h > ROWS) return false;
      // Check if target cells are free (or occupied by this block itself)
      for (let r = 0; r < b.h; r++) {
        for (let c = 0; c < b.w; c++) {
          const tr = newRow + r;
          const tc = newCol + c;
          if (grid[tr][tc] !== -1 && grid[tr][tc] !== blockIdx) return false;
        }
      }
      return true;
    }

    function moveBlock(blockIdx, dc, dr) {
      const b = blocks[blockIdx];
      // Clear old position
      for (let r = 0; r < b.h; r++) {
        for (let c = 0; c < b.w; c++) {
          grid[b.row + r][b.col + c] = -1;
        }
      }
      b.col += dc;
      b.row += dr;
      // Set new position
      for (let r = 0; r < b.h; r++) {
        for (let c = 0; c < b.w; c++) {
          grid[b.row + r][b.col + c] = blockIdx;
        }
      }
      score++;
      scoreEl.textContent = score;
    }

    function checkWin() {
      // The king (block 0) must be at col=1, row=3 (so it exits bottom center)
      const king = blocks[0];
      return king.col === 1 && king.row === 3;
    }

    function initLevel(levelIdx) {
      currentLevel = levelIdx % PUZZLES.length;
      const puzzle = PUZZLES[currentLevel];
      blocks = puzzle.blocks.map(b => ({ ...b }));
      selectedIdx = -1;
      isDragging = false;
      buildGrid();
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      celebrateTimer = 0;
      celebrateParticles = [];
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'KLOTSKI';
      overlayText.textContent = 'Press SPACE to start';
      if (currentLevel === undefined) currentLevel = 0;
      initLevel(currentLevel);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (best === null || score < best) {
        best = score;
        bestEl.textContent = best;
      }
      // Start celebration
      celebrateTimer = 180; // 3 seconds at 60fps
      celebrateParticles = [];
      for (let i = 0; i < 60; i++) {
        celebrateParticles.push({
          x: W / 2,
          y: H / 2,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10 - 3,
          life: 60 + Math.random() * 120,
          color: ['#f8c', '#f44', '#4af', '#4f4', '#fa0', '#ff0'][Math.floor(Math.random() * 6)],
          size: 3 + Math.random() * 5
        });
      }
    }

    function showGameOver() {
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PUZZLE SOLVED!';
      const nextLvl = (currentLevel + 1) % PUZZLES.length;
      overlayText.textContent = `Solved in ${score} moves! Press SPACE for next puzzle`;
    }

    function loop() {
      if (gameState === 'over') {
        // Animate celebration
        if (celebrateTimer > 0) {
          celebrateTimer--;
          draw();
          drawCelebration();
          requestAnimationFrame(loop);
          if (celebrateTimer === 0) {
            showGameOver();
          }
        }
        return;
      }
      if (gameState !== 'playing') return;
      draw();
      requestAnimationFrame(loop);
    }

    function drawCelebration() {
      celebrateParticles.forEach(p => {
        if (p.life <= 0) return;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        const alpha = Math.min(1, p.life / 30);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // "SOLVED!" text
      ctx.fillStyle = '#f8c';
      ctx.shadowColor = '#f8c';
      ctx.shadowBlur = 20;
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('SOLVED!', W / 2, H / 2);
      ctx.shadowBlur = 0;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid background
      ctx.fillStyle = '#16213e';
      ctx.fillRect(GRID_X - 2, GRID_Y - 2, GRID_W + 4, GRID_H + 4);

      // Draw grid cells
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const pos = cellToPixel(c, r);
          ctx.fillStyle = '#111828';
          ctx.fillRect(pos.x, pos.y, CELL, CELL);
        }
      }

      // Draw exit indicator at bottom center
      const exitLeft = cellToPixel(1, ROWS - 1);
      const exitRight = cellToPixel(2, ROWS - 1);
      const exitY = exitLeft.y + CELL;

      // Exit arrows
      ctx.fillStyle = '#f8c';
      ctx.shadowColor = '#f8c';
      ctx.shadowBlur = 8;
      ctx.font = 'bold 18px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('\u25BC EXIT \u25BC', GRID_X + GRID_W / 2, exitY + 8);
      ctx.shadowBlur = 0;

      // Exit gate markers
      ctx.strokeStyle = '#f8c';
      ctx.shadowColor = '#f8c';
      ctx.shadowBlur = 6;
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(exitLeft.x, exitY + 2);
      ctx.lineTo(exitRight.x + CELL, exitY + 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.shadowBlur = 0;

      // Draw blocks
      blocks.forEach((b, i) => {
        const pos = cellToPixel(b.col, b.row);
        const bw = b.w * CELL + (b.w - 1) * GAP;
        const bh = b.h * CELL + (b.h - 1) * GAP;
        const colorInfo = COLORS[b.type];
        const isSelected = (i === selectedIdx);

        // Block shadow/glow
        if (isSelected) {
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = 20;
        } else {
          ctx.shadowColor = colorInfo.glow;
          ctx.shadowBlur = 8;
        }

        // Block body
        ctx.fillStyle = colorInfo.fill;
        const r = 6;
        ctx.beginPath();
        ctx.moveTo(pos.x + r, pos.y);
        ctx.lineTo(pos.x + bw - r, pos.y);
        ctx.quadraticCurveTo(pos.x + bw, pos.y, pos.x + bw, pos.y + r);
        ctx.lineTo(pos.x + bw, pos.y + bh - r);
        ctx.quadraticCurveTo(pos.x + bw, pos.y + bh, pos.x + bw - r, pos.y + bh);
        ctx.lineTo(pos.x + r, pos.y + bh);
        ctx.quadraticCurveTo(pos.x, pos.y + bh, pos.x, pos.y + bh - r);
        ctx.lineTo(pos.x, pos.y + r);
        ctx.quadraticCurveTo(pos.x, pos.y, pos.x + r, pos.y);
        ctx.closePath();
        ctx.fill();

        // Inner highlight
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(pos.x + 3, pos.y + 3, bw - 6, bh / 3);

        // Selection border
        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#fff';
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.moveTo(pos.x + r, pos.y);
          ctx.lineTo(pos.x + bw - r, pos.y);
          ctx.quadraticCurveTo(pos.x + bw, pos.y, pos.x + bw, pos.y + r);
          ctx.lineTo(pos.x + bw, pos.y + bh - r);
          ctx.quadraticCurveTo(pos.x + bw, pos.y + bh, pos.x + bw - r, pos.y + bh);
          ctx.lineTo(pos.x + r, pos.y + bh);
          ctx.quadraticCurveTo(pos.x, pos.y + bh, pos.x, pos.y + bh - r);
          ctx.lineTo(pos.x, pos.y + r);
          ctx.quadraticCurveTo(pos.x, pos.y, pos.x + r, pos.y);
          ctx.closePath();
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // Label for king block
        if (b.type === 'king') {
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 8;
          ctx.font = 'bold 22px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('CAO', pos.x + bw / 2, pos.y + bh / 2 - 12);
          ctx.fillText('CAO', pos.x + bw / 2, pos.y + bh / 2 + 12);
          ctx.shadowBlur = 0;
        }
      });

      // HUD: level info
      const infoY = GRID_Y + GRID_H + 40;
      ctx.fillStyle = '#888';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(`Level ${currentLevel + 1}: ${PUZZLES[currentLevel].name}`, W / 2, infoY);

      if (gameState === 'playing') {
        ctx.fillStyle = '#555';
        ctx.font = '12px Courier New';
        ctx.fillText('Click a block, then use arrow keys to slide', W / 2, infoY + 22);
        ctx.fillText('Or click and drag blocks to move them', W / 2, infoY + 38);
      }
    }

    function getBlockAtPixel(px, py) {
      const cell = pixelToCell(px, py);
      if (!cell) return -1;
      return grid[cell.row][cell.col];
    }

    // Mouse/touch handling
    let mouseDownX, mouseDownY, mouseDownBlockIdx;

    canvas.addEventListener('mousedown', (e) => {
      if (gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const idx = getBlockAtPixel(mx, my);
      if (idx >= 0) {
        selectedIdx = idx;
        mouseDownX = mx;
        mouseDownY = my;
        mouseDownBlockIdx = idx;
        isDragging = true;
        const cell = pixelToCell(mx, my);
        if (cell) {
          dragStartCol = cell.col;
          dragStartRow = cell.row;
        }
        draw();
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging || gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const dx = mx - mouseDownX;
      const dy = my - mouseDownY;
      const threshold = CELL * 0.4;

      if (Math.abs(dx) > threshold || Math.abs(dy) > threshold) {
        let dc = 0, dr = 0;
        if (Math.abs(dx) > Math.abs(dy)) {
          dc = dx > 0 ? 1 : -1;
        } else {
          dr = dy > 0 ? 1 : -1;
        }
        if (canMove(mouseDownBlockIdx, dc, dr)) {
          moveBlock(mouseDownBlockIdx, dc, dr);
          mouseDownX = mx;
          mouseDownY = my;
          if (checkWin()) {
            gameOver();
            loop();
            return;
          }
          draw();
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        if (celebrateTimer > 0) return; // wait for celebration
        currentLevel = (currentLevel + 1) % PUZZLES.length;
        init();
        start();
        return;
      }

      if (gameState === 'playing') {
        // Tab or click to cycle selection
        if (e.key === 'Tab') {
          e.preventDefault();
          selectedIdx = (selectedIdx + 1) % blocks.length;
          draw();
          return;
        }

        if (selectedIdx < 0) return;

        let dc = 0, dr = 0;
        if (e.key === 'ArrowLeft') dc = -1;
        else if (e.key === 'ArrowRight') dc = 1;
        else if (e.key === 'ArrowUp') dr = -1;
        else if (e.key === 'ArrowDown') dr = 1;
        else return;

        if (canMove(selectedIdx, dc, dr)) {
          moveBlock(selectedIdx, dc, dr);
          if (checkWin()) {
            gameOver();
            loop();
            return;
          }
          draw();
        }
      }
    });

    // Expose game data for ML
    window.gameData = {
      get blocks() { return blocks; },
      get grid() { return grid; },
      get selectedIdx() { return selectedIdx; },
      get level() { return currentLevel; }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

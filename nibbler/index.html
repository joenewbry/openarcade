<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nibbler</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #4f6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 255, 102, 0.4); }
    h1 { color: #4f6; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 255, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4f6; }
    canvas {
      border: 2px solid #4f6;
      box-shadow: 0 0 20px rgba(68, 255, 102, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4f6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>NIBBLER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">NIBBLER</h2>
      <p id="overlayText">Press any arrow key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const CELL = 20;
    const COLS = W / CELL;  // 25
    const ROWS = H / CELL;  // 25

    // Maze layouts: 1 = wall, 0 = open
    // Each maze is a 25x25 grid. Border walls are always present.
    function createMaze(level) {
      const m = [];
      for (let r = 0; r < ROWS; r++) {
        m[r] = [];
        for (let c = 0; c < COLS; c++) {
          // Border walls
          m[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
        }
      }
      const idx = (level - 1) % mazePatterns.length;
      const pattern = mazePatterns[idx];
      for (const [r, c] of pattern) {
        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
          m[r][c] = 1;
        }
      }
      return m;
    }

    // Helper to generate wall segments
    function hWall(r, c1, c2) {
      const out = [];
      for (let c = c1; c <= c2; c++) out.push([r, c]);
      return out;
    }
    function vWall(c, r1, r2) {
      const out = [];
      for (let r = r1; r <= r2; r++) out.push([r, c]);
      return out;
    }

    const mazePatterns = [
      // Level 1: Simple cross corridors
      [
        ...hWall(6, 4, 10), ...hWall(6, 14, 20),
        ...hWall(18, 4, 10), ...hWall(18, 14, 20),
        ...vWall(6, 4, 10), ...vWall(6, 14, 20),
        ...vWall(18, 4, 10), ...vWall(18, 14, 20),
        ...hWall(12, 8, 11), ...hWall(12, 13, 16),
      ],
      // Level 2: Rooms with doorways
      [
        ...hWall(5, 2, 7), ...hWall(5, 9, 15), ...hWall(5, 17, 22),
        ...hWall(12, 3, 6), ...hWall(12, 8, 11), ...hWall(12, 13, 16), ...hWall(12, 18, 21),
        ...hWall(19, 2, 7), ...hWall(19, 9, 15), ...hWall(19, 17, 22),
        ...vWall(8, 2, 4), ...vWall(8, 6, 11), ...vWall(8, 13, 18), ...vWall(8, 20, 23),
        ...vWall(16, 2, 4), ...vWall(16, 6, 11), ...vWall(16, 13, 18), ...vWall(16, 20, 23),
      ],
      // Level 3: Zigzag corridors
      [
        ...hWall(4, 1, 8), ...vWall(8, 4, 8),
        ...hWall(8, 8, 16), ...vWall(16, 4, 8),
        ...hWall(4, 16, 23),
        ...hWall(12, 3, 10), ...hWall(12, 14, 21),
        ...vWall(3, 12, 16), ...hWall(16, 3, 10),
        ...vWall(10, 16, 20), ...hWall(20, 10, 21),
        ...vWall(21, 12, 20),
        ...vWall(12, 6, 10), ...vWall(12, 14, 18),
      ],
      // Level 4: Spiral with gaps for navigation
      [
        ...hWall(3, 2, 11), ...hWall(3, 13, 22),    // gap at col 12
        ...vWall(22, 3, 11), ...vWall(22, 13, 21),   // gap at row 12
        ...hWall(21, 4, 11), ...hWall(21, 13, 22),   // gap at col 12
        ...vWall(4, 5, 11), ...vWall(4, 13, 21),     // gap at row 12
        ...hWall(5, 4, 11), ...hWall(5, 13, 20),     // gap at col 12
        ...vWall(20, 5, 11), ...vWall(20, 13, 19),   // gap at row 12
        ...hWall(19, 6, 11), ...hWall(19, 13, 20),   // gap at col 12
        ...vWall(6, 7, 11), ...vWall(6, 13, 19),     // gap at row 12
        ...hWall(7, 6, 11), ...hWall(7, 13, 18),     // gap at col 12
        ...vWall(18, 7, 11), ...vWall(18, 13, 17),   // gap at row 12
        ...hWall(17, 8, 11), ...hWall(17, 13, 18),   // gap at col 12
        ...vWall(8, 9, 11), ...vWall(8, 13, 17),     // gap at row 12
        ...hWall(9, 8, 11), ...hWall(9, 13, 16),     // gap at col 12
      ],
      // Level 5: Dense maze with many corridors
      [
        ...vWall(4, 2, 6), ...vWall(4, 10, 14), ...vWall(4, 18, 22),
        ...vWall(8, 4, 8), ...vWall(8, 12, 16), ...vWall(8, 20, 23),
        ...vWall(12, 1, 5), ...vWall(12, 7, 11), ...vWall(12, 13, 17), ...vWall(12, 19, 23),
        ...vWall(16, 2, 6), ...vWall(16, 8, 12), ...vWall(16, 16, 20),
        ...vWall(20, 4, 8), ...vWall(20, 10, 14), ...vWall(20, 18, 22),
        ...hWall(8, 1, 3), ...hWall(8, 9, 11), ...hWall(8, 13, 15), ...hWall(8, 21, 23),
        ...hWall(16, 1, 3), ...hWall(16, 5, 7), ...hWall(16, 17, 19), ...hWall(16, 21, 23),
      ],
      // Level 6: Open arena with pillars
      [
        ...hWall(6, 6, 8), ...hWall(6, 16, 18),
        ...hWall(18, 6, 8), ...hWall(18, 16, 18),
        ...vWall(6, 6, 8), ...vWall(6, 16, 18),
        ...vWall(18, 6, 8), ...vWall(18, 16, 18),
        ...hWall(12, 10, 14),
        ...vWall(12, 10, 14),
        ...hWall(4, 10, 14), ...hWall(20, 10, 14),
        ...vWall(4, 4, 6), ...vWall(20, 4, 6),
        ...vWall(4, 18, 20), ...vWall(20, 18, 20),
      ],
      // Level 7: Corridors with dead-end traps
      [
        ...hWall(4, 2, 11), ...hWall(4, 13, 22),
        ...hWall(8, 4, 9), ...hWall(8, 15, 20),
        ...hWall(12, 2, 5), ...hWall(12, 7, 11), ...hWall(12, 13, 17), ...hWall(12, 19, 22),
        ...hWall(16, 4, 9), ...hWall(16, 15, 20),
        ...hWall(20, 2, 11), ...hWall(20, 13, 22),
        ...vWall(11, 4, 7), ...vWall(13, 4, 7),
        ...vWall(11, 13, 16), ...vWall(13, 13, 16),
        ...vWall(11, 17, 20), ...vWall(13, 17, 20),
      ],
      // Level 8: Tight winding maze
      [
        ...hWall(3, 2, 5), ...vWall(5, 3, 7), ...hWall(7, 2, 5),
        ...hWall(3, 7, 11), ...vWall(11, 3, 7), ...hWall(7, 7, 11),
        ...hWall(3, 13, 17), ...vWall(13, 3, 7), ...hWall(7, 13, 17),
        ...hWall(3, 19, 22), ...vWall(19, 3, 7), ...hWall(7, 19, 22),
        ...hWall(10, 2, 5), ...vWall(5, 10, 14), ...hWall(14, 2, 5),
        ...hWall(10, 7, 11), ...vWall(11, 10, 14), ...hWall(14, 7, 11),
        ...hWall(10, 13, 17), ...vWall(13, 10, 14), ...hWall(14, 13, 17),
        ...hWall(10, 19, 22), ...vWall(19, 10, 14), ...hWall(14, 19, 22),
        ...hWall(17, 2, 5), ...vWall(5, 17, 21), ...hWall(21, 2, 5),
        ...hWall(17, 7, 11), ...vWall(11, 17, 21), ...hWall(21, 7, 11),
        ...hWall(17, 13, 17), ...vWall(13, 17, 21), ...hWall(17, 13, 17),
        ...hWall(17, 19, 22), ...vWall(19, 17, 21), ...hWall(21, 19, 22),
      ],
    ];

    // Game state variables
    let score, best = 0, gameState;
    let snake, dir, nextDir, maze, foods;
    let level, lives, timeLeft, tickTimer, timerInterval;
    let foodEaten, totalFoodInLevel;
    let baseInterval, currentInterval;
    let levelTransition, levelTransitionTimer;
    let animFrame;
    let pulsePhase = 0;

    // Starting positions per level (must be open cells)
    function getStartPos(maze) {
      // Find a good starting position near center
      const centerR = Math.floor(ROWS / 2);
      const centerC = Math.floor(COLS / 2);
      // Search outward from center for open space
      for (let d = 0; d < 12; d++) {
        for (let dr = -d; dr <= d; dr++) {
          for (let dc = -d; dc <= d; dc++) {
            const r = centerR + dr;
            const c = centerC + dc;
            if (r >= 1 && r < ROWS - 1 && c >= 2 && c < COLS - 2 &&
                maze[r][c] === 0 && maze[r][c + 1] === 0 && maze[r][c - 1] === 0) {
              return { r, c };
            }
          }
        }
      }
      return { r: 2, c: 2 };
    }

    function placeFood(maze, snake, count) {
      const openCells = [];
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (maze[r][c] === 0 && !snake.some(s => s.r === r && s.c === c)) {
            openCells.push({ r, c });
          }
        }
      }
      // Shuffle and pick
      for (let i = openCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [openCells[i], openCells[j]] = [openCells[j], openCells[i]];
      }
      return openCells.slice(0, Math.min(count, openCells.length));
    }

    function getFoodCount(level) {
      return 8 + Math.min(level * 2, 16);
    }

    function getTimeForLevel(level) {
      // Seconds allowed per level: starts generous, gets tighter
      return Math.max(30, 60 - (level - 1) * 4);
    }

    function getSpeed(level) {
      // Tick interval in ms: gets faster each level
      return Math.max(80, 160 - (level - 1) * 10);
    }

    function init() {
      score = 0;
      level = 1;
      lives = 3;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      levelTransition = false;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'NIBBLER';
      overlayText.textContent = 'Press any arrow key to start';
      clearTimeout(tickTimer);
      clearInterval(timerInterval);
      cancelAnimationFrame(animFrame);
      setupLevel();
      drawFrame();
    }

    function setupLevel() {
      maze = createMaze(level);
      const startPos = getStartPos(maze);
      snake = [
        { r: startPos.r, c: startPos.c },
        { r: startPos.r, c: startPos.c - 1 },
        { r: startPos.r, c: startPos.c - 2 },
      ];
      dir = { r: 0, c: 1 };
      nextDir = { r: 0, c: 1 };
      totalFoodInLevel = getFoodCount(level);
      foods = placeFood(maze, snake, totalFoodInLevel);
      foodEaten = 0;
      timeLeft = getTimeForLevel(level);
      currentInterval = getSpeed(level);
      levelTransition = false;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startTimer();
      tick();
      renderLoop();
    }

    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (gameState !== 'playing' || levelTransition) return;
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          die();
        }
      }, 1000);
    }

    function tick() {
      clearTimeout(tickTimer);
      if (gameState !== 'playing' || levelTransition) return;
      update();
      if (gameState === 'playing') {
        tickTimer = setTimeout(tick, currentInterval);
      }
    }

    function update() {
      dir = { ...nextDir };
      const head = { r: snake[0].r + dir.r, c: snake[0].c + dir.c };

      // Check wall collision
      if (head.r < 0 || head.r >= ROWS || head.c < 0 || head.c >= COLS || maze[head.r][head.c] === 1) {
        die();
        return;
      }

      // Check self collision (skip the tail tip since it will move)
      for (let i = 0; i < snake.length - 1; i++) {
        if (snake[i].r === head.r && snake[i].c === head.c) {
          die();
          return;
        }
      }

      snake.unshift(head);

      // Check food
      const foodIdx = foods.findIndex(f => f.r === head.r && f.c === head.c);
      if (foodIdx >= 0) {
        foods.splice(foodIdx, 1);
        foodEaten++;
        const points = 10 * level;
        score += points;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }

        // Check level complete
        if (foods.length === 0) {
          completeLevel();
          return;
        }
      } else {
        snake.pop();
      }
    }

    function completeLevel() {
      clearTimeout(tickTimer);
      levelTransition = true;

      // Time bonus
      const timeBonus = timeLeft * level * 2;
      score += timeBonus;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Show level complete briefly
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LEVEL ' + level + ' COMPLETE!';
      overlayText.textContent = 'Time bonus: +' + timeBonus + ' | Next level...';

      setTimeout(() => {
        level++;
        setupLevel();
        overlay.style.display = 'none';
        levelTransition = false;
        startTimer();
        tick();
      }, 2000);
    }

    function die() {
      lives--;
      clearTimeout(tickTimer);

      if (lives <= 0) {
        gameOver();
      } else {
        // Reset position but keep level and score
        levelTransition = true;
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'CRASHED!';
        overlayText.textContent = lives + ' lives left... Get ready!';

        setTimeout(() => {
          const startPos = getStartPos(maze);
          snake = [
            { r: startPos.r, c: startPos.c },
            { r: startPos.r, c: startPos.c - 1 },
            { r: startPos.r, c: startPos.c - 2 },
          ];
          dir = { r: 0, c: 1 };
          nextDir = { r: 0, c: 1 };
          overlay.style.display = 'none';
          levelTransition = false;
          tick();
        }, 1500);
      }
    }

    function gameOver() {
      gameState = 'over';
      clearTimeout(tickTimer);
      clearInterval(timerInterval);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = 'Score: ' + score + ' | Level ' + level + ' \u2014 Press any key to restart';
    }

    function renderLoop() {
      if (gameState === 'waiting') return;
      pulsePhase += 0.05;
      drawFrame();
      if (gameState !== 'waiting') {
        animFrame = requestAnimationFrame(renderLoop);
      }
    }

    function drawFrame() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid lines (subtle)
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Draw maze walls
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (maze[r][c] === 1) {
            // Solid wall block
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(c * CELL, r * CELL, CELL, CELL);
            // Inner highlight
            ctx.fillStyle = '#16213e';
            ctx.fillRect(c * CELL + 2, r * CELL + 2, CELL - 4, CELL - 4);
            // Border glow
            ctx.strokeStyle = '#1a4a7a';
            ctx.lineWidth = 1;
            ctx.strokeRect(c * CELL + 0.5, r * CELL + 0.5, CELL - 1, CELL - 1);
          }
        }
      }

      // Draw food with pulsing glow
      const pulse = 0.5 + 0.5 * Math.sin(pulsePhase * 2);
      const glowSize = 6 + pulse * 8;
      foods.forEach(f => {
        const cx = f.c * CELL + CELL / 2;
        const cy = f.r * CELL + CELL / 2;
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = glowSize;
        ctx.beginPath();
        ctx.arc(cx, cy, CELL / 2 - 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Draw snake
      snake.forEach((seg, i) => {
        const x = seg.c * CELL;
        const y = seg.r * CELL;
        if (i === 0) {
          // Head - distinct look
          ctx.fillStyle = '#4f6';
          ctx.shadowColor = '#4f6';
          ctx.shadowBlur = 14;
          ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
          ctx.shadowBlur = 0;

          // Eyes
          const eyeOffset = 5;
          const eyeR = 2.5;
          let ex1, ey1, ex2, ey2;
          if (dir.c === 1) { // right
            ex1 = x + CELL - eyeOffset; ey1 = y + eyeOffset;
            ex2 = x + CELL - eyeOffset; ey2 = y + CELL - eyeOffset;
          } else if (dir.c === -1) { // left
            ex1 = x + eyeOffset; ey1 = y + eyeOffset;
            ex2 = x + eyeOffset; ey2 = y + CELL - eyeOffset;
          } else if (dir.r === -1) { // up
            ex1 = x + eyeOffset; ey1 = y + eyeOffset;
            ex2 = x + CELL - eyeOffset; ey2 = y + eyeOffset;
          } else { // down
            ex1 = x + eyeOffset; ey1 = y + CELL - eyeOffset;
            ex2 = x + CELL - eyeOffset; ey2 = y + CELL - eyeOffset;
          }
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(ex1, ey1, eyeR, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2, ey2, eyeR, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#111';
          ctx.beginPath(); ctx.arc(ex1, ey1, 1.2, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc(ex2, ey2, 1.2, 0, Math.PI * 2); ctx.fill();
        } else {
          // Body - fade from bright to dim
          const t = i / snake.length;
          const r = Math.round(68 * (1 - t * 0.4));
          const g = Math.round(255 * (1 - t * 0.5));
          const b = Math.round(102 * (1 - t * 0.4));
          ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
          ctx.shadowColor = '#4f6';
          ctx.shadowBlur = 3;
          ctx.fillRect(x + 2, y + 2, CELL - 4, CELL - 4);
          ctx.shadowBlur = 0;
        }
      });

      // HUD: Level, Lives, Time - drawn on canvas for ML visibility
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(0, 0, W, 18);

      ctx.font = '12px Courier New';
      ctx.fillStyle = '#4f6';
      ctx.shadowColor = '#4f6';
      ctx.shadowBlur = 4;
      ctx.textAlign = 'left';
      ctx.fillText('LVL ' + level, 6, 13);
      ctx.textAlign = 'center';
      const livesStr = '\u2764'.repeat(lives);
      ctx.fillStyle = '#f44';
      ctx.fillText(livesStr, W / 2, 13);
      ctx.fillStyle = timeLeft <= 10 ? '#f44' : '#4f6';
      ctx.textAlign = 'right';
      ctx.fillText('TIME ' + timeLeft, W - 6, 13);
      ctx.textAlign = 'left';

      // Food counter
      ctx.fillStyle = '#ff0';
      ctx.fillText(foods.length + ' left', W / 2 + 40, 13);
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      const arrows = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
      if (arrows.includes(e.key) || e.key === ' ') e.preventDefault();

      if (gameState === 'waiting' && arrows.includes(e.key)) {
        const dirs = {
          ArrowUp: { r: -1, c: 0 }, ArrowDown: { r: 1, c: 0 },
          ArrowLeft: { r: 0, c: -1 }, ArrowRight: { r: 0, c: 1 }
        };
        if (dirs[e.key]) {
          nextDir = dirs[e.key];
          dir = dirs[e.key];
        }
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing' && !levelTransition) {
        const dirs = {
          ArrowUp: { r: -1, c: 0 }, ArrowDown: { r: 1, c: 0 },
          ArrowLeft: { r: 0, c: -1 }, ArrowRight: { r: 0, c: 1 }
        };
        const d = dirs[e.key];
        if (d && (d.r + dir.r !== 0 || d.c + dir.c !== 0)) {
          nextDir = d;
        }
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

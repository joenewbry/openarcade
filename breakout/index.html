<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f80; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 0, 0.5); }
    h1 { color: #f80; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f80; }
    canvas {
      border: 2px solid #f80;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f80;
      text-align: center;
      pointer-events: none;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BREAKOUT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">BREAKOUT</h2>
      <p id="overlayText">Press LEFT/RIGHT or SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const W = canvas.width;
    const H = canvas.height;

    // Paddle
    const PADDLE_W = 80;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 40;
    const PADDLE_SPEED = 7;

    // Ball
    const BALL_R = 6;
    const BASE_BALL_SPEED = 4;

    // Bricks
    const BRICK_ROWS = 8;
    const BRICK_COLS = 10;
    const BRICK_W = (W - 20) / BRICK_COLS;
    const BRICK_H = 18;
    const BRICK_TOP = 60;
    const BRICK_PAD = 2;

    const ROW_COLORS = ['#f44', '#f80', '#ff0', '#0f0', '#0ff', '#08f', '#88f', '#f0f'];

    let paddleX, ballX, ballY, ballVX, ballVY, ballSpeed;
    let bricks, score, lives, level, gameState;
    let keys = {};

    function initBricks() {
      bricks = [];
      for (let r = 0; r < BRICK_ROWS; r++) {
        bricks[r] = [];
        for (let c = 0; c < BRICK_COLS; c++) {
          bricks[r][c] = { alive: true };
        }
      }
    }

    function init() {
      paddleX = W / 2 - PADDLE_W / 2;
      score = 0;
      lives = 3;
      level = 1;
      ballSpeed = BASE_BALL_SPEED;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      initBricks();
      resetBall();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BREAKOUT';
      overlayText.textContent = 'Press LEFT/RIGHT or SPACE to start';
      draw();
    }

    function resetBall() {
      ballX = W / 2;
      ballY = PADDLE_Y - BALL_R - 2;
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
      ballVX = Math.cos(angle) * ballSpeed;
      ballVY = Math.sin(angle) * ballSpeed;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Move paddle
      if (keys['ArrowLeft']) paddleX -= PADDLE_SPEED;
      if (keys['ArrowRight']) paddleX += PADDLE_SPEED;
      paddleX = Math.max(0, Math.min(W - PADDLE_W, paddleX));

      // Move ball
      ballX += ballVX;
      ballY += ballVY;

      // Wall collisions
      if (ballX - BALL_R <= 0) { ballX = BALL_R; ballVX = Math.abs(ballVX); }
      if (ballX + BALL_R >= W) { ballX = W - BALL_R; ballVX = -Math.abs(ballVX); }
      if (ballY - BALL_R <= 0) { ballY = BALL_R; ballVY = Math.abs(ballVY); }

      // Paddle collision
      if (ballVY > 0 && ballY + BALL_R >= PADDLE_Y && ballY + BALL_R <= PADDLE_Y + PADDLE_H + 4 &&
          ballX >= paddleX && ballX <= paddleX + PADDLE_W) {
        ballY = PADDLE_Y - BALL_R;
        // Angle based on hit position
        const hit = (ballX - paddleX) / PADDLE_W; // 0 to 1
        const angle = -Math.PI * (0.15 + 0.7 * (1 - hit)); // -165 to -27 degrees
        const speed = Math.sqrt(ballVX * ballVX + ballVY * ballVY);
        ballVX = Math.cos(angle) * speed;
        ballVY = Math.sin(angle) * speed;
      }

      // Ball falls below
      if (ballY - BALL_R > H) {
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          gameState = 'over';
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'GAME OVER';
          overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
          return;
        }
        resetBall();
      }

      // Brick collisions
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (!bricks[r][c].alive) continue;
          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;

          if (ballX + BALL_R > bx && ballX - BALL_R < bx + bw &&
              ballY + BALL_R > by && ballY - BALL_R < by + bh) {
            bricks[r][c].alive = false;
            score += 10 + (BRICK_ROWS - r) * 5;
            scoreEl.textContent = score;

            // Determine bounce direction
            const overlapLeft = (ballX + BALL_R) - bx;
            const overlapRight = (bx + bw) - (ballX - BALL_R);
            const overlapTop = (ballY + BALL_R) - by;
            const overlapBottom = (by + bh) - (ballY - BALL_R);
            const minOverlapX = Math.min(overlapLeft, overlapRight);
            const minOverlapY = Math.min(overlapTop, overlapBottom);

            if (minOverlapX < minOverlapY) {
              ballVX = -ballVX;
            } else {
              ballVY = -ballVY;
            }

            // Speed up slightly
            const currentSpeed = Math.sqrt(ballVX * ballVX + ballVY * ballVY);
            const newSpeed = currentSpeed + 0.02;
            ballVX = (ballVX / currentSpeed) * newSpeed;
            ballVY = (ballVY / currentSpeed) * newSpeed;
            break;
          }
        }
      }

      // Check level clear
      let allClear = true;
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (bricks[r][c].alive) { allClear = false; break; }
        }
        if (!allClear) break;
      }
      if (allClear) {
        level++;
        levelEl.textContent = level;
        ballSpeed = BASE_BALL_SPEED + level * 0.5;
        initBricks();
        resetBall();
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Bricks
      for (let r = 0; r < BRICK_ROWS; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          if (!bricks[r][c].alive) continue;
          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;
          ctx.fillStyle = ROW_COLORS[r];
          ctx.shadowColor = ROW_COLORS[r];
          ctx.shadowBlur = 6;
          ctx.fillRect(bx, by, bw, bh);
        }
      }
      ctx.shadowBlur = 0;

      // Paddle
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 12;
      ctx.fillRect(paddleX, PADDLE_Y, PADDLE_W, PADDLE_H);
      ctx.shadowBlur = 0;

      // Ball
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(ballX, ballY, BALL_R, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Lives indicator
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(W - 20 - i * 18, H - 15, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over' && e.key === ' ') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breakout</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f80; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 0, 0.5); }
    h1 { color: #f80; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f80; }
    canvas {
      border: 2px solid #f80;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f80;
      text-align: center;
      pointer-events: none;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BREAKOUT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">BREAKOUT</h2>
      <p id="overlayText">Press LEFT/RIGHT or SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const W = canvas.width;
    const H = canvas.height;

    const PADDLE_W = 80;
    const PADDLE_H = 12;
    const PADDLE_Y = H - 40;
    const PADDLE_SPEED = 7;

    const BALL_R = 6;
    const BASE_BALL_SPEED = 4;

    const BRICK_COLS = 10;
    const BRICK_W = (W - 20) / BRICK_COLS;
    const BRICK_H = 18;
    const BRICK_TOP = 60;
    const BRICK_PAD = 2;

    // Row colors (up to 8 rows)
    const ROW_COLORS = ['#f44', '#f80', '#ff0', '#0f0', '#0ff', '#08f', '#88f', '#f0f'];
    const INDESTRUCTIBLE_COLOR = '#888';

    // Level layouts: 0=no brick, 1=normal, 2=indestructible
    const LEVEL_LAYOUTS = [
      // Level 1: Simple fill (6 rows)
      [[1,1,1,1,1,1,1,1,1,1],
       [1,1,1,1,1,1,1,1,1,1],
       [1,1,1,1,1,1,1,1,1,1],
       [1,1,1,1,1,1,1,1,1,1],
       [1,1,1,1,1,1,1,1,1,1],
       [1,1,1,1,1,1,1,1,1,1]],
      // Level 2: Checkerboard gaps (8 rows)
      [[1,1,1,1,1,1,1,1,1,1],
       [1,0,1,0,1,0,1,0,1,0],
       [1,1,1,1,1,1,1,1,1,1],
       [0,1,0,1,0,1,0,1,0,1],
       [1,1,1,1,1,1,1,1,1,1],
       [1,0,1,0,1,0,1,0,1,0],
       [1,1,1,1,1,1,1,1,1,1],
       [0,1,0,1,0,1,0,1,0,1]],
      // Level 3: Pyramid (8 rows)
      [[0,0,0,0,1,1,0,0,0,0],
       [0,0,0,1,1,1,1,0,0,0],
       [0,0,1,1,1,1,1,1,0,0],
       [0,1,1,1,1,1,1,1,1,0],
       [1,1,1,1,1,1,1,1,1,1],
       [0,1,1,1,1,1,1,1,1,0],
       [0,0,1,1,1,1,1,1,0,0],
       [0,0,0,1,1,1,1,0,0,0]],
      // Level 4: Diamond frame (8 rows)
      [[1,1,1,1,1,1,1,1,1,1],
       [1,0,0,0,0,0,0,0,0,1],
       [1,0,1,1,1,1,1,1,0,1],
       [1,0,1,0,0,0,0,1,0,1],
       [1,0,1,0,0,0,0,1,0,1],
       [1,0,1,1,1,1,1,1,0,1],
       [1,0,0,0,0,0,0,0,0,1],
       [1,1,1,1,1,1,1,1,1,1]],
      // Level 5: Fortress with indestructible walls
      [[2,2,2,2,2,2,2,2,2,2],
       [2,1,1,1,1,1,1,1,1,2],
       [2,1,1,0,0,0,0,1,1,2],
       [2,1,0,1,1,1,1,0,1,2],
       [2,1,0,1,1,1,1,0,1,2],
       [2,1,1,0,0,0,0,1,1,2],
       [2,1,1,1,1,1,1,1,1,2],
       [2,2,2,2,2,2,2,2,2,2]],
    ];

    let paddleX, ballX, ballY, ballVX, ballVY, ballSpeed;
    let bricks, score, lives, level, gameState;
    let keys = {};
    let particles = [];
    let ballTrail = [];

    function getLayout() {
      return LEVEL_LAYOUTS[Math.min(level - 1, LEVEL_LAYOUTS.length - 1)];
    }

    function initBricks() {
      const layout = getLayout();
      bricks = [];
      for (let r = 0; r < layout.length; r++) {
        bricks[r] = [];
        for (let c = 0; c < BRICK_COLS; c++) {
          const val = layout[r][c];
          if (val === 0) {
            bricks[r][c] = null;
          } else if (val === 2) {
            bricks[r][c] = { alive: true, indestructible: true };
          } else {
            bricks[r][c] = { alive: true, indestructible: false };
          }
        }
      }
    }

    function init() {
      paddleX = W / 2 - PADDLE_W / 2;
      score = 0;
      lives = 3;
      level = 1;
      ballSpeed = BASE_BALL_SPEED;
      particles = [];
      ballTrail = [];
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      initBricks();
      resetBall();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BREAKOUT';
      overlayText.textContent = 'Press LEFT/RIGHT or SPACE to start';
      draw();
    }

    function resetBall() {
      ballX = W / 2;
      ballY = PADDLE_Y - BALL_R - 2;
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
      ballVX = Math.cos(angle) * ballSpeed;
      ballVY = Math.sin(angle) * ballSpeed;
      ballTrail = [];
    }

    function spawnBrickParticles(bx, by, bw, bh, color) {
      for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x: bx + bw / 2, y: by + bh / 2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 1,
          color: Math.random() > 0.4 ? color : '#fff',
          life: 20 + Math.random() * 10, maxLife: 30,
          size: 2 + Math.random() * 3
        });
      }
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      if (keys['ArrowLeft']) paddleX -= PADDLE_SPEED;
      if (keys['ArrowRight']) paddleX += PADDLE_SPEED;
      paddleX = Math.max(0, Math.min(W - PADDLE_W, paddleX));

      // Ball trail
      ballTrail.push({ x: ballX, y: ballY });
      if (ballTrail.length > 3) ballTrail.shift();

      ballX += ballVX;
      ballY += ballVY;

      // Wall collisions
      if (ballX - BALL_R <= 0) { ballX = BALL_R; ballVX = Math.abs(ballVX); }
      if (ballX + BALL_R >= W) { ballX = W - BALL_R; ballVX = -Math.abs(ballVX); }
      if (ballY - BALL_R <= 0) { ballY = BALL_R; ballVY = Math.abs(ballVY); }

      // Paddle collision
      if (ballVY > 0 && ballY + BALL_R >= PADDLE_Y && ballY + BALL_R <= PADDLE_Y + PADDLE_H + 4 &&
          ballX >= paddleX && ballX <= paddleX + PADDLE_W) {
        ballY = PADDLE_Y - BALL_R;
        const hit = (ballX - paddleX) / PADDLE_W;
        const angle = -Math.PI * (0.15 + 0.7 * (1 - hit));
        const speed = Math.sqrt(ballVX * ballVX + ballVY * ballVY);
        ballVX = Math.cos(angle) * speed;
        ballVY = Math.sin(angle) * speed;
      }

      // Ball falls below
      if (ballY - BALL_R > H) {
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          gameState = 'over';
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'GAME OVER';
          overlayText.textContent = `Score: ${score} -- Press SPACE to restart`;
          return;
        }
        resetBall();
      }

      // Brick collisions
      for (let r = 0; r < bricks.length; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const brick = bricks[r][c];
          if (!brick || !brick.alive) continue;
          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;

          if (ballX + BALL_R > bx && ballX - BALL_R < bx + bw &&
              ballY + BALL_R > by && ballY - BALL_R < by + bh) {

            if (!brick.indestructible) {
              brick.alive = false;
              const color = ROW_COLORS[r % ROW_COLORS.length];
              score += 10 + (bricks.length - r) * 5;
              scoreEl.textContent = score;
              spawnBrickParticles(bx, by, bw, bh, color);
            }

            // Bounce regardless of indestructible
            const overlapLeft = (ballX + BALL_R) - bx;
            const overlapRight = (bx + bw) - (ballX - BALL_R);
            const overlapTop = (ballY + BALL_R) - by;
            const overlapBottom = (by + bh) - (ballY - BALL_R);
            const minOverlapX = Math.min(overlapLeft, overlapRight);
            const minOverlapY = Math.min(overlapTop, overlapBottom);
            if (minOverlapX < minOverlapY) {
              ballVX = -ballVX;
            } else {
              ballVY = -ballVY;
            }

            if (!brick.indestructible) {
              const currentSpeed = Math.sqrt(ballVX * ballVX + ballVY * ballVY);
              const newSpeed = currentSpeed + 0.02;
              ballVX = (ballVX / currentSpeed) * newSpeed;
              ballVY = (ballVY / currentSpeed) * newSpeed;
            }
            break;
          }
        }
      }

      // Check level clear (only non-indestructible bricks matter)
      const allClear = bricks.every(row => row.every(b => !b || !b.alive || b.indestructible));
      if (allClear) {
        level++;
        levelEl.textContent = level;
        // Extra life every 3 levels
        if ((level - 1) % 3 === 0) {
          lives = Math.min(6, lives + 1);
          livesEl.textContent = lives;
        }
        ballSpeed = BASE_BALL_SPEED + (level - 1) * 0.3;
        particles = [];
        initBricks();
        resetBall();
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.08;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function drawBrick(bx, by, bw, bh, color, indestructible) {
      // Main fill
      ctx.fillStyle = indestructible ? INDESTRUCTIBLE_COLOR : color;
      if (!indestructible) {
        ctx.shadowColor = color;
        ctx.shadowBlur = 4;
      }
      ctx.fillRect(bx, by, bw, bh);
      ctx.shadowBlur = 0;

      // Top-left highlight
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillRect(bx, by, bw, 3);
      ctx.fillRect(bx, by, 3, bh);

      // Bottom-right shadow
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(bx, by + bh - 3, bw, 3);
      ctx.fillRect(bx + bw - 3, by, 3, bh);

      // Candy shine (specular in upper-left third)
      if (!indestructible) {
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(bx + 2, by + 2, bw * 0.35, bh * 0.45);
      }
    }

    function draw() {
      // Background with slight gradient
      const bg = ctx.createLinearGradient(0, 0, 0, H);
      bg.addColorStop(0, '#04040a');
      bg.addColorStop(1, '#0a0818');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, W, H);

      // Bricks
      for (let r = 0; r < bricks.length; r++) {
        for (let c = 0; c < BRICK_COLS; c++) {
          const brick = bricks[r][c];
          if (!brick || !brick.alive) continue;
          const bx = 10 + c * BRICK_W + BRICK_PAD;
          const by = BRICK_TOP + r * BRICK_H + BRICK_PAD;
          const bw = BRICK_W - BRICK_PAD * 2;
          const bh = BRICK_H - BRICK_PAD * 2;
          const color = ROW_COLORS[r % ROW_COLORS.length];
          drawBrick(bx, by, bw, bh, color, brick.indestructible);
        }
      }

      // Ball trail
      ballTrail.forEach((t, i) => {
        const alpha = (i + 1) / (ballTrail.length + 1) * 0.35;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(t.x, t.y, BALL_R * 0.8, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Paddle
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 12;
      ctx.fillRect(paddleX, PADDLE_Y, PADDLE_W, PADDLE_H);
      // Paddle top highlight
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillRect(paddleX, PADDLE_Y, PADDLE_W, 2);
      ctx.shadowBlur = 0;

      // Ball
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(ballX, ballY, BALL_R, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;

      // Lives indicator
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(W - 20 - i * 18, H - 15, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Scanline overlay (Retro CRT effect, 10% opacity)
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      for (let y = 0; y < H; y += 2) {
        ctx.fillRect(0, y, W, 1);
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over' && e.key === ' ') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

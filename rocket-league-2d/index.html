<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rocket League 2D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f60; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 0, 0.5); }
    h1 { color: #f60; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 102, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f60; }
    canvas {
      border: 2px solid #f60;
      box-shadow: 0 0 20px rgba(255, 102, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f60;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ROCKET LEAGUE 2D</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="matchInfo" style="color:#aaa;">3:00 | First to 5</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">ROCKET LEAGUE 2D</h2>
      <p id="overlayText">&larr; &rarr; Drive &nbsp; &uarr; Jump &nbsp; Space Boost<br><br>Score goals with car soccer!<br><br>Press any key to start</p>
    </div>
  </div>
  <script src="../recorder.js"></script>
  <script>
  'use strict';
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 600, H = 400;
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const matchInfo = document.getElementById('matchInfo');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayText = document.getElementById('overlayText');

  const THEME = '#f60';

  // === GAME STATE ===
  let gameState = 'start';
  let score = 0;
  let aiScore = 0;
  let timer = 0;
  let goalTimer = 0;
  let goalMessage = '';
  let kickoffTimer = 0;

  // === CONSTANTS ===
  const GRAVITY = 0.4;
  const ARENA_L = 12;
  const ARENA_R = W - 12;
  const ARENA_T = 30;
  const ARENA_B = H - 12;
  const ARENA_W = ARENA_R - ARENA_L;
  const ARENA_H = ARENA_B - ARENA_T;
  const GOAL_H = 100;
  const GOAL_W = 12;
  const GOAL_TOP = ARENA_B - GOAL_H;
  const BALL_R = 13;
  const WIN_SCORE = 5;
  const MATCH_SECS = 180;
  const MAX_BOOST = 100;

  // Car
  const CAR_W = 38;
  const CAR_H = 18;
  const DRIVE_FORCE = 0.45;
  const AIR_TORQUE = 0.07;
  const JUMP_VEL = -7.5;
  const DOUBLE_JUMP_VEL = -6;
  const BOOST_FORCE = 0.55;
  const BOOST_RATE = 1.0;
  const MAX_SPEED = 8;
  const MAX_BOOST_SPEED = 12;
  const GROUND_FRIC = 0.94;
  const AIR_FRIC = 0.997;

  // === INPUT ===
  const keys = {};
  const justPressed = {};
  document.addEventListener('keydown', e => {
    if (!keys[e.code]) justPressed[e.code] = true;
    keys[e.code] = true;
    if (gameState === 'start') { startMatch(); e.preventDefault(); }
    else if (gameState === 'gameOver') { resetAll(); e.preventDefault(); }
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  // === OBJECTS ===
  let ball, player, aiCar, particles, ballTrail, boostPads;

  function makeCar(x, facingRight, isAI) {
    return {
      x, y: ARENA_B - CAR_H/2,
      vx: 0, vy: 0,
      angle: 0,
      angVel: 0,
      grounded: false,
      onWallL: false, onWallR: false, onCeiling: false,
      boost: 40,
      jumps: 2,
      facingRight,
      isAI,
      color: isAI ? '#4af' : '#f60',
      darkColor: isAI ? '#2a7ab5' : '#b34700',
      flameTimer: 0,
      lastHitBall: 0
    };
  }

  function initBoostPads() {
    boostPads = [];
    const positions = [
      [80, ARENA_B], [200, ARENA_B], [300, ARENA_B], [400, ARENA_B], [520, ARENA_B],
      [ARENA_L, 250], [ARENA_R, 250],
      [150, ARENA_T], [300, ARENA_T], [450, ARENA_T]
    ];
    for (const [px, py] of positions) {
      boostPads.push({ x: px, y: py, active: true, respawn: 0, big: (px===300 && py===ARENA_B) });
    }
  }

  function resetPositions() {
    ball = { x: W/2, y: ARENA_B - 80, vx: 0, vy: 0 };
    player = makeCar(170, true, false);
    aiCar = makeCar(430, false, true);
    ballTrail = [];
    kickoffTimer = 60;
  }

  function resetAll() {
    score = 0; aiScore = 0;
    scoreEl.textContent = '0';
    bestEl.textContent = '0';
    timer = MATCH_SECS * 60;
    initBoostPads();
    resetPositions();
    particles = [];
    gameState = 'start';
    overlay.style.display = 'flex';
    overlayTitle.textContent = 'ROCKET LEAGUE 2D';
    overlayText.innerHTML = '&larr; &rarr; Drive &nbsp; &uarr; Jump &nbsp; Space Boost<br><br>Score goals with car soccer!<br><br>Press any key to start';
  }

  function startMatch() {
    gameState = 'playing';
    timer = MATCH_SECS * 60;
    score = 0; aiScore = 0;
    scoreEl.textContent = '0';
    bestEl.textContent = '0';
    initBoostPads();
    resetPositions();
    particles = [];
    overlay.style.display = 'none';
    if (typeof startRecording === 'function') startRecording();
  }

  // === PARTICLES ===
  function spawn(x, y, color, n, spd) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = (Math.random() * 2 + 0.5) * (spd || 1);
      particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 25+Math.random()*20, max: 45, color, sz: Math.random()*3+1 });
    }
  }

  // === CAR PHYSICS ===
  function getCarCorners(c) {
    const hw = CAR_W/2, hh = CAR_H/2;
    const cos = Math.cos(c.angle), sin = Math.sin(c.angle);
    return [
      { x: c.x + cos*hw - sin*(-hh), y: c.y + sin*hw + cos*(-hh) },
      { x: c.x + cos*hw - sin*hh,    y: c.y + sin*hw + cos*hh },
      { x: c.x + cos*(-hw) - sin*hh, y: c.y + sin*(-hw) + cos*hh },
      { x: c.x + cos*(-hw) - sin*(-hh), y: c.y + sin*(-hw) + cos*(-hh) }
    ];
  }

  function updateCar(c, inputLR, inputJump, inputBoost) {
    const wasGrounded = c.grounded;
    c.grounded = false; c.onWallL = false; c.onWallR = false; c.onCeiling = false;

    // Check surface contacts
    if (c.y + CAR_H/2 >= ARENA_B - 1) c.grounded = true;
    if (c.y - CAR_H/2 <= ARENA_T + 1) c.onCeiling = true;
    if (c.x - CAR_W/2 <= ARENA_L + 1) c.onWallL = true;
    if (c.x + CAR_W/2 >= ARENA_R - 1) c.onWallR = true;
    const onSurface = c.grounded || c.onWallL || c.onWallR || c.onCeiling;

    // Reset jumps on ground
    if (c.grounded && !wasGrounded) c.jumps = 2;
    if (c.onWallL || c.onWallR || c.onCeiling) c.jumps = Math.max(c.jumps, 1);

    if (c.grounded) {
      // Ground: angle auto-levels, drive left/right
      c.angle *= 0.8; // level out
      c.angVel *= 0.5;

      if (inputLR !== 0) {
        c.vx += inputLR * DRIVE_FORCE;
        c.facingRight = inputLR > 0;
      }
      c.vx *= GROUND_FRIC;
      if (Math.abs(c.vy) < 1) c.vy = 0;

    } else {
      // Air: left/right = rotate car
      if (inputLR !== 0) {
        c.angVel += inputLR * AIR_TORQUE;
      }
      c.vx *= AIR_FRIC;
      c.vy *= AIR_FRIC;
    }

    // Wall driving
    if (c.onWallL && !c.grounded) {
      c.vy *= 0.92;
      if (inputLR !== 0) c.vy += inputLR * DRIVE_FORCE * -0.5;
      c.angle = Math.PI/2 * 0.2 + c.angle * 0.8;
    }
    if (c.onWallR && !c.grounded) {
      c.vy *= 0.92;
      if (inputLR !== 0) c.vy += inputLR * DRIVE_FORCE * 0.5;
      c.angle = -Math.PI/2 * 0.2 + c.angle * 0.8;
    }
    if (c.onCeiling && !c.grounded) {
      c.vx *= GROUND_FRIC;
      if (inputLR !== 0) c.vx += inputLR * DRIVE_FORCE;
      c.angle = Math.PI * 0.2 + c.angle * 0.8;
    }

    // Jump
    if (inputJump && c.jumps > 0) {
      if (c.grounded) {
        c.vy = JUMP_VEL;
        c.jumps--;
        spawn(c.x, c.y + CAR_H/2, '#fff', 6, 1.5);
      } else if (c.onWallL) {
        c.vx = 6; c.vy = -5; c.jumps--;
        spawn(c.x - CAR_W/2, c.y, '#fff', 6, 1.5);
      } else if (c.onWallR) {
        c.vx = -6; c.vy = -5; c.jumps--;
        spawn(c.x + CAR_W/2, c.y, '#fff', 6, 1.5);
      } else if (c.onCeiling) {
        c.vy = 5; c.jumps--;
        spawn(c.x, c.y - CAR_H/2, '#fff', 6, 1.5);
      } else if (c.jumps >= 1) {
        // Double jump / air dodge
        c.vy = DOUBLE_JUMP_VEL;
        c.jumps--;
        spawn(c.x, c.y + CAR_H/2, '#aaf', 4, 1);
      }
    }

    // Boost
    c.flameTimer = Math.max(0, c.flameTimer - 1);
    if (inputBoost && c.boost > 0) {
      const bx = Math.cos(c.angle) * (c.facingRight ? 1 : -1);
      const by = Math.sin(c.angle);
      c.vx += bx * BOOST_FORCE;
      c.vy += by * BOOST_FORCE;
      c.boost -= BOOST_RATE;
      if (c.boost < 0) c.boost = 0;
      c.flameTimer = 6;
      if (Math.random() < 0.6) {
        spawn(c.x - bx * CAR_W/2, c.y - by * CAR_W/2, c.isAI ? '#4af' : '#f60', 1, 2);
      }
    }

    // Gravity
    c.vy += GRAVITY;

    // Angular damping
    c.angVel *= 0.9;
    c.angle += c.angVel;

    // Apply velocity
    c.x += c.vx;
    c.y += c.vy;

    // Speed limit
    const spd = Math.hypot(c.vx, c.vy);
    const limit = inputBoost ? MAX_BOOST_SPEED : MAX_SPEED;
    if (spd > limit) { c.vx *= limit/spd; c.vy *= limit/spd; }

    // Arena constraints
    if (c.y + CAR_H/2 > ARENA_B) { c.y = ARENA_B - CAR_H/2; c.vy = Math.min(0, c.vy * -0.1); }
    if (c.y - CAR_H/2 < ARENA_T) { c.y = ARENA_T + CAR_H/2; c.vy = Math.max(0, c.vy * -0.1); }

    // Side walls - but not goal openings
    const inGoalZone = c.y + CAR_H/2 > GOAL_TOP && c.y - CAR_H/2 < ARENA_B;
    if (c.x - CAR_W/2 < ARENA_L) {
      if (!inGoalZone) {
        c.x = ARENA_L + CAR_W/2; c.vx = Math.max(0, c.vx * -0.2);
      } else {
        // Prevent going too deep into goal
        if (c.x - CAR_W/2 < ARENA_L - GOAL_W) {
          c.x = ARENA_L - GOAL_W + CAR_W/2; c.vx = Math.max(0, c.vx * -0.2);
        }
      }
    }
    if (c.x + CAR_W/2 > ARENA_R) {
      if (!inGoalZone) {
        c.x = ARENA_R - CAR_W/2; c.vx = Math.min(0, c.vx * -0.2);
      } else {
        if (c.x + CAR_W/2 > ARENA_R + GOAL_W) {
          c.x = ARENA_R + GOAL_W - CAR_W/2; c.vx = Math.min(0, c.vx * -0.2);
        }
      }
    }
  }

  // === BALL PHYSICS ===
  function updateBall() {
    if (kickoffTimer > 0) { kickoffTimer--; return null; }

    ball.vy += GRAVITY;
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Friction
    ball.vx *= 0.999;
    ball.vy *= 0.999;

    // Speed cap
    const spd = Math.hypot(ball.vx, ball.vy);
    if (spd > 14) { ball.vx *= 14/spd; ball.vy *= 14/spd; }

    // Trail
    if (spd > 1.5) {
      ballTrail.push({ x: ball.x, y: ball.y, life: 12 });
      if (ballTrail.length > 25) ballTrail.shift();
    }

    // Ceiling
    if (ball.y - BALL_R < ARENA_T) {
      ball.y = ARENA_T + BALL_R;
      ball.vy = Math.abs(ball.vy) * 0.7;
    }
    // Floor
    if (ball.y + BALL_R > ARENA_B) {
      ball.y = ARENA_B - BALL_R;
      ball.vy = -Math.abs(ball.vy) * 0.7;
      ball.vx *= 0.97;
      if (Math.abs(ball.vy) < 0.5) ball.vy = 0;
    }

    // Left wall / goal
    if (ball.x - BALL_R < ARENA_L) {
      if (ball.y > GOAL_TOP + BALL_R && ball.y < ARENA_B - BALL_R) {
        // In goal opening
        if (ball.x < ARENA_L - GOAL_W - BALL_R) return 'ai_goal';
        // Goal back wall
        if (ball.x - BALL_R < ARENA_L - GOAL_W) {
          ball.x = ARENA_L - GOAL_W + BALL_R;
          ball.vx = Math.abs(ball.vx) * 0.5;
        }
        // Goal top/bottom
        if (ball.y - BALL_R < GOAL_TOP) { ball.y = GOAL_TOP + BALL_R; ball.vy = Math.abs(ball.vy) * 0.6; }
      } else {
        ball.x = ARENA_L + BALL_R;
        ball.vx = Math.abs(ball.vx) * 0.7;
      }
    }
    // Right wall / goal
    if (ball.x + BALL_R > ARENA_R) {
      if (ball.y > GOAL_TOP + BALL_R && ball.y < ARENA_B - BALL_R) {
        if (ball.x > ARENA_R + GOAL_W + BALL_R) return 'player_goal';
        if (ball.x + BALL_R > ARENA_R + GOAL_W) {
          ball.x = ARENA_R + GOAL_W - BALL_R;
          ball.vx = -Math.abs(ball.vx) * 0.5;
        }
        if (ball.y - BALL_R < GOAL_TOP) { ball.y = GOAL_TOP + BALL_R; ball.vy = Math.abs(ball.vy) * 0.6; }
      } else {
        ball.x = ARENA_R - BALL_R;
        ball.vx = -Math.abs(ball.vx) * 0.7;
      }
    }

    // Goal post collisions (circles at corners of goals)
    const postR = 5;
    const posts = [
      { x: ARENA_L, y: GOAL_TOP }, { x: ARENA_R, y: GOAL_TOP }
    ];
    for (const p of posts) {
      const dx = ball.x - p.x, dy = ball.y - p.y;
      const d = Math.hypot(dx, dy);
      if (d < BALL_R + postR) {
        const nx = dx/d, ny = dy/d;
        ball.x = p.x + nx * (BALL_R + postR);
        ball.y = p.y + ny * (BALL_R + postR);
        const dot = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * dot * nx * 0.7;
        ball.vy -= 2 * dot * ny * 0.7;
        spawn(p.x, p.y, '#ff0', 6, 1.5);
      }
    }
    return null;
  }

  // === CAR-BALL COLLISION ===
  function carBallHit(c) {
    // OBB vs circle
    const dx = ball.x - c.x, dy = ball.y - c.y;
    const cos = Math.cos(-c.angle), sin = Math.sin(-c.angle);
    const lx = dx*cos - dy*sin, ly = dx*sin + dy*cos;
    const hw = CAR_W/2 + 2, hh = CAR_H/2 + 2;
    const cx = Math.max(-hw, Math.min(hw, lx));
    const cy = Math.max(-hh, Math.min(hh, ly));
    const dlx = lx - cx, dly = ly - cy;
    const d = Math.hypot(dlx, dly);
    if (d >= BALL_R) return;

    // Collision normal in world space
    const cos2 = Math.cos(c.angle), sin2 = Math.sin(c.angle);
    let nx, ny;
    if (d < 0.01) {
      const dd = Math.hypot(dx, dy) || 1;
      nx = dx/dd; ny = dy/dd;
    } else {
      const lnx = dlx/d, lny = dly/d;
      nx = lnx*cos2 - lny*sin2;
      ny = lnx*sin2 + lny*cos2;
    }

    // Separate
    ball.x += nx * (BALL_R - d + 1);
    ball.y += ny * (BALL_R - d + 1);

    // Impulse
    const rvx = ball.vx - c.vx, rvy = ball.vy - c.vy;
    const rDot = rvx * nx + rvy * ny;
    if (rDot > 0) return;

    const e = 0.82;
    const imp = -(1 + e) * rDot / (1 + 0.5);
    ball.vx += imp * nx;
    ball.vy += imp * ny;
    c.vx -= imp * 0.3 * nx;
    c.vy -= imp * 0.3 * ny;

    const hitSpd = Math.hypot(rvx, rvy);
    spawn(ball.x - nx*BALL_R, ball.y - ny*BALL_R, hitSpd > 6 ? '#ff0' : '#fff', Math.min(12, Math.floor(hitSpd*2)), hitSpd*0.3);
    c.lastHitBall = 10;
  }

  // === CAR-CAR COLLISION ===
  function carCar() {
    const dx = aiCar.x - player.x, dy = aiCar.y - player.y;
    const d = Math.hypot(dx, dy);
    const minD = CAR_W * 0.6;
    if (d < minD && d > 0) {
      const nx = dx/d, ny = dy/d;
      const ov = minD - d;
      player.x -= nx * ov * 0.5; player.y -= ny * ov * 0.5;
      aiCar.x += nx * ov * 0.5; aiCar.y += ny * ov * 0.5;
      const rv = (player.vx - aiCar.vx) * nx + (player.vy - aiCar.vy) * ny;
      if (rv > 0) {
        player.vx -= rv * nx * 0.4; player.vy -= rv * ny * 0.4;
        aiCar.vx += rv * nx * 0.4; aiCar.vy += rv * ny * 0.4;
      }
      spawn((player.x+aiCar.x)/2, (player.y+aiCar.y)/2, '#fff', 4, 1);
    }
  }

  // === BOOST PADS ===
  function checkPads(c) {
    for (const p of boostPads) {
      if (!p.active) continue;
      if (Math.hypot(c.x - p.x, c.y - p.y) < CAR_W/2 + 10) {
        c.boost = Math.min(MAX_BOOST, c.boost + (p.big ? 40 : 20));
        p.active = false;
        p.respawn = p.big ? 360 : 240;
        spawn(p.x, p.y, '#ff0', 6, 1.5);
      }
    }
  }

  // === AI ===
  function aiThink() {
    let lr = 0, jump = false, boost = false;

    const myGoalX = ARENA_R; // AI defends right
    const theirGoalX = ARENA_L;

    // Predict ball
    const predT = 25;
    let pbx = ball.x + ball.vx * predT;
    let pby = ball.y + ball.vy * predT + 0.5 * GRAVITY * predT * predT;
    pbx = Math.max(ARENA_L, Math.min(ARENA_R, pbx));
    pby = Math.max(ARENA_T, Math.min(ARENA_B, pby));

    const distBall = Math.hypot(aiCar.x - ball.x, aiCar.y - ball.y);
    const ballSpeed = Math.hypot(ball.vx, ball.vy);
    const ballToGoal = ball.vx > 0.5 && ball.x > W * 0.35;
    const ballDangerous = ball.x > W * 0.55 && ball.vx > 0;
    const ballOnMySide = ball.x > W / 2;

    let targetX, targetY;
    let urgency = 0;

    // === STATE MACHINE ===
    if (ballDangerous && ball.x > W * 0.65) {
      // EMERGENCY DEFENSE: rush to ball
      targetX = ball.x;
      targetY = ball.y;
      urgency = 3;
    } else if (ballOnMySide && ballToGoal) {
      // ACTIVE DEFENSE: intercept
      targetX = Math.max(ball.x, pbx);
      targetY = pby;
      urgency = 2;
    } else if (!ballOnMySide) {
      // ATTACK: approach from behind ball (between ball and our goal), push toward their goal
      targetX = ball.x + 35;
      targetY = ball.y;
      urgency = 1;

      // If we're already behind ball, charge
      if (aiCar.x > ball.x + 20) {
        targetX = ball.x;
        targetY = ball.y;
        urgency = 2;
      }
    } else {
      // NEUTRAL: position between ball and goal
      targetX = Math.max(ball.x + 30, ARENA_R - 100);
      targetY = (ball.y + (GOAL_TOP + ARENA_B)/2) / 2;
      urgency = 1;
    }

    // Navigate to target on ground
    const dxT = targetX - aiCar.x;
    const dyT = targetY - aiCar.y;

    if (aiCar.grounded) {
      // Drive toward target
      if (dxT > 15) lr = 1;
      else if (dxT < -15) lr = -1;
      else lr = dxT > 0 ? 0.5 : -0.5;

      // Jump if ball is above us and we're close horizontally
      if (ball.y < aiCar.y - 30 && Math.abs(ball.x - aiCar.x) < 80 && distBall < 120) {
        jump = true;
      }

      // Jump for aerial interception
      if (ball.y < ARENA_B - 100 && distBall < 150 && urgency >= 2) {
        jump = true;
      }
    } else {
      // In air: rotate toward ball/target
      const angleToTarget = Math.atan2(dyT, dxT);
      let diff = angleToTarget - aiCar.angle;
      while (diff > Math.PI) diff -= Math.PI*2;
      while (diff < -Math.PI) diff += Math.PI*2;
      if (diff > 0.2) lr = 1;
      else if (diff < -0.2) lr = -1;

      // Air dodge / double jump toward ball
      if (distBall < 80 && aiCar.jumps > 0 && ball.y < aiCar.y) {
        jump = true;
      }
    }

    // Boost management
    if (urgency >= 3 && aiCar.boost > 5) boost = true;
    else if (urgency >= 2 && aiCar.boost > 20 && distBall > 80) boost = true;
    else if (urgency >= 1 && aiCar.boost > 50 && distBall > 200) boost = true;
    // Aerial boost
    if (!aiCar.grounded && distBall < 150 && aiCar.boost > 10) boost = true;

    // Update facing direction
    if (lr > 0) aiCar.facingRight = true;
    else if (lr < 0) aiCar.facingRight = false;

    updateCar(aiCar, lr, jump, boost);
  }

  // === GOAL HANDLING ===
  function handleGoal(who) {
    if (who === 'player_goal') {
      score++;
      scoreEl.textContent = score;
      goalMessage = 'GOAL!';
      spawn(ARENA_R + GOAL_W/2, (GOAL_TOP+ARENA_B)/2, '#f60', 40, 3);
    } else {
      aiScore++;
      bestEl.textContent = aiScore;
      goalMessage = 'AI SCORES!';
      spawn(ARENA_L - GOAL_W/2, (GOAL_TOP+ARENA_B)/2, '#4af', 40, 3);
    }
    goalTimer = 120;
    gameState = 'goalScored';
    if (score >= WIN_SCORE || aiScore >= WIN_SCORE) goalTimer = 150;
  }

  function endMatch() {
    gameState = 'gameOver';
    overlay.style.display = 'flex';
    overlayTitle.textContent = score > aiScore ? 'YOU WIN!' : (aiScore > score ? 'AI WINS!' : 'DRAW!');
    overlayText.innerHTML = `Final Score: ${score} - ${aiScore}<br><br>Press any key to play again`;
    if (typeof stopRecording === 'function') stopRecording();
  }

  // === MAIN UPDATE ===
  function update() {
    if (gameState === 'goalScored') {
      goalTimer--;
      // Particles still update
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
      if (goalTimer <= 0) {
        if (score >= WIN_SCORE || aiScore >= WIN_SCORE) { endMatch(); return; }
        resetPositions();
        gameState = 'playing';
      }
      return;
    }
    if (gameState !== 'playing') return;

    // Timer
    timer--;
    const secs = Math.max(0, Math.ceil(timer / 60));
    matchInfo.textContent = `${Math.floor(secs/60)}:${(secs%60).toString().padStart(2,'0')} | First to ${WIN_SCORE}`;
    if (timer <= 0) { endMatch(); return; }

    // Player input
    const pLR = keys['ArrowRight'] ? 1 : (keys['ArrowLeft'] ? -1 : 0);
    const pJump = !!justPressed['ArrowUp'];
    const pBoost = !!keys['Space'];
    if (pLR > 0) player.facingRight = true;
    else if (pLR < 0) player.facingRight = false;

    updateCar(player, pLR, pJump, pBoost);
    aiThink();

    // Ball
    const goalResult = updateBall();
    if (goalResult) { handleGoal(goalResult); return; }

    // Collisions
    carBallHit(player);
    carBallHit(aiCar);
    carCar();

    // Boost pads
    checkPads(player);
    checkPads(aiCar);
    for (const p of boostPads) {
      if (!p.active) { p.respawn--; if (p.respawn <= 0) p.active = true; }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.life--;
      if (p.life <= 0) particles.splice(i, 1);
    }
    // Trail fade
    for (let i = ballTrail.length - 1; i >= 0; i--) {
      ballTrail[i].life--;
      if (ballTrail[i].life <= 0) ballTrail.splice(i, 1);
    }

    // Decay hit timers
    player.lastHitBall = Math.max(0, player.lastHitBall - 1);
    aiCar.lastHitBall = Math.max(0, aiCar.lastHitBall - 1);

    // Clear justPressed
    for (const k in justPressed) justPressed[k] = false;
  }

  // === RENDERING ===
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // Background
    ctx.fillStyle = '#0a0a18';
    ctx.fillRect(0, 0, W, H);

    // Arena field
    ctx.fillStyle = '#0e0e20';
    ctx.fillRect(ARENA_L, ARENA_T, ARENA_W, ARENA_H);

    // Grid lines (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.025)';
    ctx.lineWidth = 1;
    for (let x = ARENA_L; x <= ARENA_R; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, ARENA_T); ctx.lineTo(x, ARENA_B); ctx.stroke();
    }
    for (let y = ARENA_T; y <= ARENA_B; y += 40) {
      ctx.beginPath(); ctx.moveTo(ARENA_L, y); ctx.lineTo(ARENA_R, y); ctx.stroke();
    }

    // Center line
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.moveTo(W/2, ARENA_T); ctx.lineTo(W/2, ARENA_B); ctx.stroke();
    ctx.setLineDash([]);

    // Center circle
    ctx.beginPath(); ctx.arc(W/2, (ARENA_T+ARENA_B)/2, 45, 0, Math.PI*2); ctx.stroke();

    // === GOALS ===
    // Left goal (player defends)
    drawGoal(ARENA_L, -1, '#f60');
    // Right goal (AI defends)
    drawGoal(ARENA_R, 1, '#4af');

    // Goal posts (bright dots)
    ctx.fillStyle = '#ff0';
    ctx.shadowBlur = 6; ctx.shadowColor = '#ff0';
    ctx.beginPath(); ctx.arc(ARENA_L, GOAL_TOP, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ARENA_R, GOAL_TOP, 4, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    // Arena border
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    // Top wall
    ctx.beginPath(); ctx.moveTo(ARENA_L, ARENA_T); ctx.lineTo(ARENA_R, ARENA_T); ctx.stroke();
    // Bottom wall
    ctx.beginPath(); ctx.moveTo(ARENA_L, ARENA_B); ctx.lineTo(ARENA_R, ARENA_B); ctx.stroke();
    // Left wall (excluding goal)
    ctx.beginPath(); ctx.moveTo(ARENA_L, ARENA_T); ctx.lineTo(ARENA_L, GOAL_TOP); ctx.stroke();
    // Right wall (excluding goal)
    ctx.beginPath(); ctx.moveTo(ARENA_R, ARENA_T); ctx.lineTo(ARENA_R, GOAL_TOP); ctx.stroke();

    // Boost pads
    for (const p of boostPads) {
      if (!p.active) {
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#555';
        ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      } else {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Math.PI/4 + Date.now()*0.002);
        const sz = p.big ? 8 : 5;
        ctx.shadowBlur = 8; ctx.shadowColor = p.big ? '#f80' : '#ff0';
        ctx.fillStyle = p.big ? '#f80' : '#ffa500';
        ctx.fillRect(-sz, -sz, sz*2, sz*2);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    // Ball trail
    for (const t of ballTrail) {
      const a = t.life / 12;
      ctx.fillStyle = `rgba(255,255,255,${a * 0.15})`;
      ctx.beginPath(); ctx.arc(t.x, t.y, BALL_R * a * 0.6, 0, Math.PI*2); ctx.fill();
    }

    // Ball
    drawBall();

    // Cars
    drawCar(player);
    drawCar(aiCar);

    // Boost meters
    drawBoostMeter(15, ARENA_B + 9, player.boost, '#f60', 'P1 BOOST');
    drawBoostMeter(W - 115, ARENA_B + 9, aiCar.boost, '#4af', 'AI BOOST');

    // Particles
    for (const p of particles) {
      ctx.globalAlpha = p.life / p.max;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.sz/2, p.y - p.sz/2, p.sz, p.sz);
    }
    ctx.globalAlpha = 1;

    // Goal message
    if (gameState === 'goalScored' && goalTimer > 0) {
      ctx.save();
      const pulse = 1 + Math.sin(goalTimer * 0.15) * 0.08;
      ctx.font = `bold 40px "Courier New"`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = goalMessage.includes('AI') ? '#4af' : '#f60';
      ctx.shadowBlur = 25;
      ctx.shadowColor = ctx.fillStyle;
      ctx.setTransform(pulse, 0, 0, pulse, W/2, H/2 - 20);
      ctx.fillText(goalMessage, 0, 0);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.font = '16px "Courier New"';
      ctx.fillStyle = '#aaa';
      ctx.shadowBlur = 0;
      ctx.fillText(`${score} - ${aiScore}`, W/2, H/2 + 20);
      ctx.restore();
    }

    // Kickoff countdown
    if (kickoffTimer > 30) {
      ctx.font = 'bold 30px "Courier New"';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
      ctx.fillText(Math.ceil((kickoffTimer-30)/30).toString(), W/2, H/2 - 30);
      ctx.shadowBlur = 0;
    } else if (kickoffTimer > 0) {
      ctx.font = 'bold 24px "Courier New"';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#f60';
      ctx.shadowBlur = 15; ctx.shadowColor = '#f60';
      ctx.fillText('GO!', W/2, H/2 - 30);
      ctx.shadowBlur = 0;
    }
  }

  function drawGoal(x, dir, color) {
    // Goal net area
    ctx.fillStyle = color.replace(')', ',0.08)').replace('rgb', 'rgba').replace('#', '');
    // Convert hex to rgba
    const r = parseInt(color.slice(1,2),16)*17, g = parseInt(color.slice(2,3),16)*17, b = parseInt(color.slice(3,4),16)*17;
    ctx.fillStyle = `rgba(${r},${g},${b},0.1)`;
    const gx = dir < 0 ? x - GOAL_W : x;
    ctx.fillRect(gx, GOAL_TOP, GOAL_W, GOAL_H);

    // Net lines
    ctx.strokeStyle = `rgba(${r},${g},${b},0.25)`;
    ctx.lineWidth = 1;
    for (let ny = GOAL_TOP; ny <= ARENA_B; ny += 12) {
      ctx.beginPath(); ctx.moveTo(gx, ny); ctx.lineTo(gx + GOAL_W * (dir < 0 ? -1 : 1) * 0 + GOAL_W, ny); ctx.stroke();
    }

    // Goal frame
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x, GOAL_TOP);
    ctx.lineTo(x + dir * GOAL_W, GOAL_TOP);
    ctx.lineTo(x + dir * GOAL_W, ARENA_B);
    ctx.lineTo(x, ARENA_B);
    ctx.stroke();
  }

  function drawBall() {
    const spd = Math.hypot(ball.vx, ball.vy);
    ctx.save();
    ctx.translate(ball.x, ball.y);

    // Glow
    ctx.shadowBlur = 6 + spd * 2;
    ctx.shadowColor = spd > 6 ? '#f60' : spd > 3 ? '#fa0' : '#fff';

    // Ball body
    ctx.fillStyle = '#eee';
    ctx.beginPath(); ctx.arc(0, 0, BALL_R, 0, Math.PI*2); ctx.fill();

    ctx.shadowBlur = 0;

    // Soccer pattern
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(0, 0, BALL_R, 0, Math.PI*2); ctx.stroke();

    const rot = Math.atan2(ball.vy, ball.vx + 0.01);
    for (let i = 0; i < 5; i++) {
      const a = rot + i * Math.PI * 2 / 5;
      ctx.fillStyle = '#777';
      ctx.beginPath();
      ctx.arc(Math.cos(a) * BALL_R * 0.55, Math.sin(a) * BALL_R * 0.55, 2.5, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawCar(c) {
    ctx.save();
    ctx.translate(c.x, c.y);

    // Flip rendering if facing left
    const flip = c.facingRight ? 1 : -1;
    ctx.scale(flip, 1);
    ctx.rotate(c.angle * flip);

    const hw = CAR_W/2, hh = CAR_H/2;

    // Boost flame
    if (c.flameTimer > 0) {
      const fLen = c.flameTimer * 3 + Math.random() * 10;
      const grad = ctx.createLinearGradient(-hw - fLen, 0, -hw, 0);
      grad.addColorStop(0, 'transparent');
      grad.addColorStop(0.4, c.isAI ? 'rgba(68,170,255,0.7)' : 'rgba(255,80,0,0.7)');
      grad.addColorStop(1, 'rgba(255,255,0,0.9)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(-hw, -hh*0.4);
      ctx.lineTo(-hw - fLen, 0);
      ctx.lineTo(-hw, hh*0.4);
      ctx.fill();
    }

    // Car shadow
    ctx.shadowBlur = 6;
    ctx.shadowColor = c.color;

    // Car body
    ctx.fillStyle = c.color;
    ctx.beginPath();
    ctx.moveTo(-hw + 3, -hh);
    ctx.lineTo(hw - 2, -hh);
    ctx.lineTo(hw + 5, -3);    // front nose point
    ctx.lineTo(hw + 5, 3);
    ctx.lineTo(hw - 2, hh);
    ctx.lineTo(-hw + 3, hh);
    ctx.lineTo(-hw, hh - 3);
    ctx.lineTo(-hw, -hh + 3);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;

    // Cabin / darker stripe
    ctx.fillStyle = c.darkColor;
    ctx.fillRect(-4, -hh, 14, hh * 0.7);

    // Windshield
    ctx.fillStyle = 'rgba(120,180,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(6, -hh + 1);
    ctx.lineTo(12, -hh + 1);
    ctx.lineTo(10, -4);
    ctx.lineTo(4, -4);
    ctx.fill();

    // Headlight
    ctx.fillStyle = '#ff0';
    ctx.shadowBlur = 4; ctx.shadowColor = '#ff0';
    ctx.fillRect(hw + 2, -4, 3, 3);
    ctx.shadowBlur = 0;

    // Taillight
    ctx.fillStyle = '#f00';
    ctx.fillRect(-hw, -3, 2, 6);

    // Wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(hw - 10, hh - 2, 10, 5);
    ctx.fillRect(-hw + 2, hh - 2, 10, 5);
    // Wheel highlights
    ctx.fillStyle = '#444';
    ctx.fillRect(hw - 9, hh - 1, 8, 3);
    ctx.fillRect(-hw + 3, hh - 1, 8, 3);

    // Label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 7px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(c.isAI ? 'AI' : 'P1', 0, 3);

    ctx.restore();
  }

  function drawBoostMeter(x, y, amount, color, label) {
    const w = 100, h = 4;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(x, y, w, h);
    const fill = w * (amount / MAX_BOOST);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, fill, h);
    // Glow on boost bar
    if (amount > 50) {
      ctx.shadowBlur = 4; ctx.shadowColor = color;
      ctx.fillRect(x, y, fill, h);
      ctx.shadowBlur = 0;
    }
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = '#666';
    ctx.font = '7px "Courier New"';
    ctx.textAlign = 'left';
    ctx.fillText(label, x, y - 2);
  }

  // === GAME LOOP ===
  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  resetAll();
  loop();
  </script>
</body>
</html>

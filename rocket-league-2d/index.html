<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rocket League 2D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f60; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 0, 0.5); }
    h1 { color: #f60; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 102, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f60; }
    canvas {
      border: 2px solid #f60;
      box-shadow: 0 0 20px rgba(255, 102, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f60;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ROCKET LEAGUE 2D</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="matchInfo" style="color:#aaa;">3:00 | First to 5</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">ROCKET LEAGUE 2D</h2>
      <p id="overlayText">Arrow keys: drive/rotate | Up: jump | Space: boost<br><br>Press any key to start</p>
    </div>
  </div>
  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const matchInfo = document.getElementById('matchInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Theme
    const THEME = '#f60';
    const THEME_RGB = '255, 102, 0';

    // Game states
    let gameState = 'start'; // start, playing, goalScored, gameOver
    let score = 0;
    let aiScore = 0;

    // Physics
    const GRAVITY = 0.35;
    const FPS = 60;
    const DT = 1;

    // Arena dimensions
    const WALL_THICK = 10;
    const ARENA_LEFT = WALL_THICK;
    const ARENA_RIGHT = W - WALL_THICK;
    const ARENA_TOP = WALL_THICK;
    const ARENA_BOTTOM = H - WALL_THICK;
    const GOAL_WIDTH = 8;
    const GOAL_HEIGHT = 90;
    const GOAL_TOP = ARENA_BOTTOM - GOAL_HEIGHT;

    // Ball
    const BALL_R = 14;
    const BALL_BOUNCE = 0.7;
    const BALL_FRICTION = 0.998;
    const BALL_MAX_VEL = 12;

    // Car dimensions
    const CAR_W = 40;
    const CAR_H = 20;
    const CAR_MASS = 2;
    const BALL_MASS = 1;

    // Car physics
    const DRIVE_ACCEL = 0.3;
    const BRAKE_DECEL = 0.15;
    const CAR_FRICTION = 0.97;
    const CAR_AIR_FRICTION = 0.995;
    const ROTATE_SPEED = 0.06;
    const JUMP_FORCE = 7;
    const BOOST_ACCEL = 0.6;
    const MAX_BOOST = 100;
    const BOOST_COST = 0.8;
    const BOOST_REGEN = 0;

    // Boost pads
    const BOOST_PAD_SIZE = 12;
    const BOOST_PAD_AMOUNT = 25;
    const BOOST_PAD_RESPAWN = 300; // frames

    // Timer
    const MATCH_TIME = 180; // seconds
    const WIN_SCORE = 5;

    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (gameState === 'start') {
        startMatch();
        e.preventDefault();
      } else if (gameState === 'gameOver') {
        resetAll();
        e.preventDefault();
      }
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    // Boost pads locations
    let boostPads = [];
    function initBoostPads() {
      boostPads = [
        { x: 100, y: ARENA_BOTTOM - BOOST_PAD_SIZE, timer: 0 },
        { x: 200, y: ARENA_BOTTOM - BOOST_PAD_SIZE, timer: 0 },
        { x: 300, y: ARENA_BOTTOM - BOOST_PAD_SIZE, timer: 0 },
        { x: 400, y: ARENA_BOTTOM - BOOST_PAD_SIZE, timer: 0 },
        { x: 500, y: ARENA_BOTTOM - BOOST_PAD_SIZE, timer: 0 },
        // Wall pads
        { x: ARENA_LEFT + BOOST_PAD_SIZE, y: 200, timer: 0 },
        { x: ARENA_RIGHT - BOOST_PAD_SIZE, y: 200, timer: 0 },
        // Ceiling pads
        { x: 200, y: ARENA_TOP + BOOST_PAD_SIZE, timer: 0 },
        { x: 400, y: ARENA_TOP + BOOST_PAD_SIZE, timer: 0 },
      ];
    }

    // Particles
    let particles = [];
    function spawnParticles(x, y, color, count, speedMult) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 2 + 1) * (speedMult || 1);
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 30 + Math.random() * 20,
          maxLife: 50,
          color,
          size: Math.random() * 3 + 1
        });
      }
    }

    // Ball trail
    let ballTrail = [];

    // Game objects
    let ball, player, ai, timer, goalTimer, goalMessage;

    function createCar(x, y, isAI) {
      return {
        x, y,
        vx: 0, vy: 0,
        angle: isAI ? Math.PI : 0, // AI faces left
        angularVel: 0,
        onGround: false,
        onWall: false,
        onCeiling: false,
        boost: 60,
        isAI,
        jumpCooldown: 0,
        color: isAI ? '#4af' : '#f60',
        wheelAngle: 0,
        boostFlame: 0
      };
    }

    function resetPositions() {
      ball = {
        x: W / 2, y: H / 2,
        vx: 0, vy: 0,
        r: BALL_R
      };
      player = createCar(150, ARENA_BOTTOM - CAR_H / 2 - 2, false);
      ai = createCar(450, ARENA_BOTTOM - CAR_H / 2 - 2, true);
      ballTrail = [];
      goalTimer = 0;
    }

    function resetAll() {
      score = 0;
      aiScore = 0;
      timer = MATCH_TIME * FPS;
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      initBoostPads();
      resetPositions();
      particles = [];
      gameState = 'start';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ROCKET LEAGUE 2D';
      overlayText.innerHTML = 'Arrow keys: drive/rotate | Up: jump | Space: boost<br><br>Press any key to start';
    }

    function startMatch() {
      gameState = 'playing';
      timer = MATCH_TIME * FPS;
      score = 0;
      aiScore = 0;
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      initBoostPads();
      resetPositions();
      particles = [];
      overlay.style.display = 'none';
      if (typeof startRecording === 'function') startRecording();
    }

    // Car physics
    function updateCar(car, inputLeft, inputRight, inputUp, inputDrive, inputBoost) {
      if (car.jumpCooldown > 0) car.jumpCooldown--;

      // Determine surface contact
      car.onGround = false;
      car.onWall = false;
      car.onCeiling = false;

      const halfW = CAR_W / 2;
      const halfH = CAR_H / 2;
      // Check corners of the car against arena walls
      const cos = Math.cos(car.angle);
      const sin = Math.sin(car.angle);

      // Bottom of car touches ground
      if (car.y + halfH >= ARENA_BOTTOM - 1) {
        car.onGround = true;
      }
      // Top touches ceiling
      if (car.y - halfH <= ARENA_TOP + 1) {
        car.onCeiling = true;
      }
      // Left wall
      if (car.x - halfW <= ARENA_LEFT + 1) {
        car.onWall = true;
      }
      // Right wall
      if (car.x + halfW >= ARENA_RIGHT - 1) {
        car.onWall = true;
      }

      const onSurface = car.onGround || car.onWall || car.onCeiling;

      // Rotation
      if (inputLeft) car.angularVel -= ROTATE_SPEED;
      if (inputRight) car.angularVel += ROTATE_SPEED;
      car.angularVel *= 0.85;
      car.angle += car.angularVel;

      // Drive along car's forward direction
      const forwardX = Math.cos(car.angle);
      const forwardY = Math.sin(car.angle);

      if (onSurface) {
        if (inputDrive > 0) {
          car.vx += forwardX * DRIVE_ACCEL * inputDrive;
          car.vy += forwardY * DRIVE_ACCEL * inputDrive;
        } else if (inputDrive < 0) {
          car.vx -= forwardX * DRIVE_ACCEL * 0.5;
          car.vy -= forwardY * DRIVE_ACCEL * 0.5;
        }
        // Surface friction
        car.vx *= CAR_FRICTION;
        car.vy *= CAR_FRICTION;
      } else {
        // Air control (reduced)
        if (inputDrive > 0) {
          car.vx += forwardX * DRIVE_ACCEL * 0.3;
          car.vy += forwardY * DRIVE_ACCEL * 0.3;
        }
        car.vx *= CAR_AIR_FRICTION;
        car.vy *= CAR_AIR_FRICTION;
      }

      // Boost
      car.boostFlame = Math.max(0, car.boostFlame - 2);
      if (inputBoost && car.boost > 0) {
        car.vx += forwardX * BOOST_ACCEL;
        car.vy += forwardY * BOOST_ACCEL;
        car.boost -= BOOST_COST;
        if (car.boost < 0) car.boost = 0;
        car.boostFlame = 10;
        // Boost particles
        if (Math.random() < 0.5) {
          spawnParticles(
            car.x - forwardX * halfW,
            car.y - forwardY * halfW,
            car.isAI ? '#4af' : '#f60',
            2, 1.5
          );
        }
      }

      // Jump
      if (inputUp && onSurface && car.jumpCooldown <= 0) {
        if (car.onGround) {
          car.vy = -JUMP_FORCE;
        } else if (car.onCeiling) {
          car.vy = JUMP_FORCE;
        } else if (car.onWall) {
          if (car.x < W / 2) {
            car.vx = JUMP_FORCE * 0.7;
          } else {
            car.vx = -JUMP_FORCE * 0.7;
          }
          car.vy = -JUMP_FORCE * 0.5;
        }
        car.jumpCooldown = 15;
      }

      // Gravity (always)
      car.vy += GRAVITY;

      // Apply velocity
      car.x += car.vx;
      car.y += car.vy;

      // Wall collisions
      // Ground
      if (car.y + halfH > ARENA_BOTTOM) {
        car.y = ARENA_BOTTOM - halfH;
        car.vy *= -0.2;
        if (Math.abs(car.vy) < 0.5) car.vy = 0;
        // Auto-align on ground
        const targetAngle = 0;
        car.angle += (targetAngle - car.angle) * 0.15;
      }
      // Ceiling
      if (car.y - halfH < ARENA_TOP) {
        car.y = ARENA_TOP + halfH;
        car.vy *= -0.2;
        if (Math.abs(car.vy) < 0.5) car.vy = 0;
        const targetAngle = Math.PI;
        let diff = targetAngle - car.angle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        car.angle += diff * 0.15;
      }
      // Left wall (but not in goal area)
      if (car.x - halfW < ARENA_LEFT) {
        if (car.y < GOAL_TOP || car.y > ARENA_BOTTOM) {
          car.x = ARENA_LEFT + halfW;
          car.vx *= -0.3;
        } else {
          // In goal area, push back gently
          car.x = ARENA_LEFT + halfW + GOAL_WIDTH;
          car.vx *= -0.3;
        }
      }
      // Right wall (but not in goal area)
      if (car.x + halfW > ARENA_RIGHT) {
        if (car.y < GOAL_TOP || car.y > ARENA_BOTTOM) {
          car.x = ARENA_RIGHT - halfW;
          car.vx *= -0.3;
        } else {
          car.x = ARENA_RIGHT - halfW - GOAL_WIDTH;
          car.vx *= -0.3;
        }
      }

      // Wall sticking (drive on walls)
      if (car.x - halfW <= ARENA_LEFT + 2 && car.vy < 0) {
        // Sticking to left wall - reduce gravity
        car.vy *= 0.9;
      }
      if (car.x + halfW >= ARENA_RIGHT - 2 && car.vy < 0) {
        car.vy *= 0.9;
      }

      // Speed limit
      const speed = Math.sqrt(car.vx * car.vx + car.vy * car.vy);
      const maxSpeed = inputBoost ? 10 : 7;
      if (speed > maxSpeed) {
        car.vx = (car.vx / speed) * maxSpeed;
        car.vy = (car.vy / speed) * maxSpeed;
      }

      // Wheel spin animation
      car.wheelAngle += speed * 0.1 * (car.vx > 0 ? 1 : -1);
    }

    // Ball physics
    function updateBall() {
      ball.vy += GRAVITY;
      ball.vx *= BALL_FRICTION;
      ball.vy *= BALL_FRICTION;

      ball.x += ball.vx;
      ball.y += ball.vy;

      // Ball trail
      ballTrail.push({ x: ball.x, y: ball.y, life: 15 });
      if (ballTrail.length > 20) ballTrail.shift();

      // Speed cap
      const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      if (speed > BALL_MAX_VEL) {
        ball.vx = (ball.vx / speed) * BALL_MAX_VEL;
        ball.vy = (ball.vy / speed) * BALL_MAX_VEL;
      }

      // Wall bounce
      // Ceiling
      if (ball.y - ball.r < ARENA_TOP) {
        ball.y = ARENA_TOP + ball.r;
        ball.vy = Math.abs(ball.vy) * BALL_BOUNCE;
      }
      // Ground
      if (ball.y + ball.r > ARENA_BOTTOM) {
        ball.y = ARENA_BOTTOM - ball.r;
        ball.vy = -Math.abs(ball.vy) * BALL_BOUNCE;
        ball.vx *= 0.98; // ground friction
      }

      // Left wall / Left goal check
      if (ball.x - ball.r < ARENA_LEFT) {
        if (ball.y > GOAL_TOP && ball.y < ARENA_BOTTOM) {
          // GOAL for AI! Ball went into left goal
          if (ball.x < ARENA_LEFT - 20) {
            return 'ai_goal';
          }
        } else {
          ball.x = ARENA_LEFT + ball.r;
          ball.vx = Math.abs(ball.vx) * BALL_BOUNCE;
        }
      }

      // Right wall / Right goal check
      if (ball.x + ball.r > ARENA_RIGHT) {
        if (ball.y > GOAL_TOP && ball.y < ARENA_BOTTOM) {
          // GOAL for Player!
          if (ball.x > ARENA_RIGHT + 20) {
            return 'player_goal';
          }
        } else {
          ball.x = ARENA_RIGHT - ball.r;
          ball.vx = -Math.abs(ball.vx) * BALL_BOUNCE;
        }
      }

      // Goal post collision (4 posts)
      const posts = [
        { x: ARENA_LEFT, y: GOAL_TOP },       // left top post
        { x: ARENA_LEFT, y: ARENA_BOTTOM },   // left bottom post
        { x: ARENA_RIGHT, y: GOAL_TOP },      // right top post
        { x: ARENA_RIGHT, y: ARENA_BOTTOM },  // right bottom post
      ];
      for (const post of posts) {
        const dx = ball.x - post.x;
        const dy = ball.y - post.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < ball.r + 4) {
          const nx = dx / dist;
          const ny = dy / dist;
          ball.x = post.x + nx * (ball.r + 4);
          ball.y = post.y + ny * (ball.r + 4);
          const dot = ball.vx * nx + ball.vy * ny;
          ball.vx -= 2 * dot * nx * BALL_BOUNCE;
          ball.vy -= 2 * dot * ny * BALL_BOUNCE;
          spawnParticles(post.x, post.y, '#ff0', 5, 1);
        }
      }

      return null;
    }

    // Car-Ball collision
    function carBallCollision(car) {
      // Use oriented bounding box vs circle
      const dx = ball.x - car.x;
      const dy = ball.y - car.y;
      const cos = Math.cos(-car.angle);
      const sin = Math.sin(-car.angle);
      // Rotate ball into car's local space
      const localX = dx * cos - dy * sin;
      const localY = dx * sin + dy * cos;

      const halfW = CAR_W / 2 + 2;
      const halfH = CAR_H / 2 + 2;

      // Find closest point on car rect to ball center (in local space)
      const closestX = Math.max(-halfW, Math.min(halfW, localX));
      const closestY = Math.max(-halfH, Math.min(halfH, localY));

      const distX = localX - closestX;
      const distY = localY - closestY;
      const dist = Math.sqrt(distX * distX + distY * distY);

      if (dist < ball.r) {
        // Collision!
        // Convert collision normal back to world space
        const cos2 = Math.cos(car.angle);
        const sin2 = Math.sin(car.angle);
        let nx, ny;
        if (dist === 0) {
          nx = dx / (Math.sqrt(dx*dx+dy*dy) || 1);
          ny = dy / (Math.sqrt(dx*dx+dy*dy) || 1);
        } else {
          const lnx = distX / dist;
          const lny = distY / dist;
          nx = lnx * cos2 - lny * sin2;
          ny = lnx * sin2 + lny * cos2;
        }

        // Separate ball from car
        const overlap = ball.r - dist;
        ball.x += nx * (overlap + 1);
        ball.y += ny * (overlap + 1);

        // Relative velocity
        const relVx = ball.vx - car.vx;
        const relVy = ball.vy - car.vy;
        const relDot = relVx * nx + relVy * ny;

        if (relDot < 0) {
          // Impulse based collision
          const restitution = 0.85;
          const impulseMag = -(1 + restitution) * relDot / (1/BALL_MASS + 1/CAR_MASS);

          ball.vx += (impulseMag / BALL_MASS) * nx;
          ball.vy += (impulseMag / BALL_MASS) * ny;
          car.vx -= (impulseMag / CAR_MASS) * nx * 0.3;
          car.vy -= (impulseMag / CAR_MASS) * ny * 0.3;

          // Hit particles
          const hitSpeed = Math.sqrt(relVx*relVx + relVy*relVy);
          const pCount = Math.min(15, Math.floor(hitSpeed * 2));
          spawnParticles(ball.x - nx * ball.r, ball.y - ny * ball.r,
            hitSpeed > 5 ? '#ff0' : '#fff', pCount, hitSpeed * 0.3);
        }
      }
    }

    // Car-Car collision
    function carCarCollision() {
      const dx = ai.x - player.x;
      const dy = ai.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = CAR_W * 0.7;

      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;

        player.x -= nx * overlap * 0.5;
        player.y -= ny * overlap * 0.5;
        ai.x += nx * overlap * 0.5;
        ai.y += ny * overlap * 0.5;

        // Exchange some velocity
        const relVx = player.vx - ai.vx;
        const relVy = player.vy - ai.vy;
        const relDot = relVx * nx + relVy * ny;

        if (relDot > 0) {
          player.vx -= relDot * nx * 0.4;
          player.vy -= relDot * ny * 0.4;
          ai.vx += relDot * nx * 0.4;
          ai.vy += relDot * ny * 0.4;
          spawnParticles((player.x + ai.x)/2, (player.y + ai.y)/2, '#fff', 6, 1);
        }
      }
    }

    // Boost pad pickup
    function checkBoostPads(car) {
      for (const pad of boostPads) {
        if (pad.timer > 0) continue;
        const dx = car.x - pad.x;
        const dy = car.y - pad.y;
        if (Math.sqrt(dx*dx + dy*dy) < CAR_W/2 + BOOST_PAD_SIZE) {
          car.boost = Math.min(MAX_BOOST, car.boost + BOOST_PAD_AMOUNT);
          pad.timer = BOOST_PAD_RESPAWN;
          spawnParticles(pad.x, pad.y, '#ff0', 8, 1.5);
        }
      }
    }

    // AI brain
    function updateAI() {
      let inputLeft = false, inputRight = false, inputUp = false;
      let inputDrive = 0, inputBoost = false;

      const aiGoalX = ARENA_RIGHT; // AI defends right goal
      const playerGoalX = ARENA_LEFT; // AI attacks left goal

      // Predict ball position
      let predBallX = ball.x + ball.vx * 20;
      let predBallY = ball.y + ball.vy * 20 + 0.5 * GRAVITY * 400;
      predBallY = Math.max(ARENA_TOP, Math.min(ARENA_BOTTOM, predBallY));
      predBallX = Math.max(ARENA_LEFT, Math.min(ARENA_RIGHT, predBallX));

      const distToBall = Math.sqrt((ai.x - ball.x)**2 + (ai.y - ball.y)**2);
      const ballHeadingToGoal = ball.vx > 1 && ball.x > W * 0.4;
      const ballInDanger = ball.x > W * 0.6 && ball.vx > 0;
      const ballOnAISide = ball.x > W / 2;

      let targetX, targetY;
      let shouldBoost = false;
      let shouldJump = false;

      // State: Defend if ball heading toward AI goal
      if (ballInDanger || (ballOnAISide && ballHeadingToGoal)) {
        // Position between ball and goal
        targetX = Math.max(ball.x + 30, ARENA_RIGHT - 80);
        targetY = predBallY;
        shouldBoost = ball.vx > 3 || distToBall > 150;

        // If ball is very close and heading to goal, rush to intercept
        if (ball.x > W * 0.7 && ball.vx > 0) {
          targetX = ball.x;
          targetY = ball.y;
          shouldBoost = true;
        }
      }
      // State: Attack - go for ball and push toward player's goal
      else {
        // Position behind ball (relative to target goal)
        targetX = ball.x + 40; // come from the right
        targetY = ball.y;

        // If aligned, go straight for ball
        if (ai.x > ball.x + 20) {
          targetX = ball.x;
          targetY = ball.y;
          shouldBoost = distToBall > 100;
        }

        // Try aerial if ball is high
        if (ball.y < H * 0.5 && distToBall < 200) {
          shouldJump = ai.onGround;
          shouldBoost = true;
        }
      }

      // If ball is above, consider jumping
      if (ball.y < ai.y - 40 && distToBall < 120) {
        shouldJump = ai.onGround;
      }

      // Navigate to target
      const dxTarget = targetX - ai.x;
      const dyTarget = targetY - ai.y;
      const angleToTarget = Math.atan2(dyTarget, dxTarget);

      // Determine facing direction
      let angleDiff = angleToTarget - ai.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

      // Steer toward target
      if (angleDiff > 0.15) inputRight = true;
      else if (angleDiff < -0.15) inputLeft = true;

      // Drive forward if roughly facing target
      if (Math.abs(angleDiff) < Math.PI * 0.6) {
        inputDrive = 1;
      } else if (Math.abs(angleDiff) > Math.PI * 0.7) {
        inputDrive = -0.5;
      }

      // Boost management
      if (shouldBoost && ai.boost > 15) {
        inputBoost = true;
      }

      // Jump logic
      if (shouldJump && ai.jumpCooldown <= 0) {
        inputUp = true;
      }

      // Idle behavior: if on ground and ball far, face toward ball
      if (ai.onGround && distToBall > 250) {
        const toBallAngle = Math.atan2(ball.y - ai.y, ball.x - ai.x);
        let diff = toBallAngle - ai.angle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        if (diff > 0.1) inputRight = true;
        else if (diff < -0.1) inputLeft = true;
        inputDrive = 1;
        inputBoost = ai.boost > 50 && distToBall > 300;
      }

      // Wall recovery: if stuck on wall/ceiling, try to get back to ground
      if (!ai.onGround && ai.y < H * 0.3) {
        // Try to orient downward
        const downAngle = Math.PI / 2;
        let diff = downAngle - ai.angle;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        if (diff > 0.1) inputRight = true;
        else if (diff < -0.1) inputLeft = true;
      }

      updateCar(ai, inputLeft, inputRight, inputUp, inputDrive, inputBoost);
    }

    // Goal scored
    function handleGoal(who) {
      if (who === 'player_goal') {
        score++;
        scoreEl.textContent = score;
        goalMessage = 'GOAL! YOU SCORE!';
        spawnParticles(ARENA_RIGHT, (GOAL_TOP + ARENA_BOTTOM)/2, '#f60', 30, 3);
      } else {
        aiScore++;
        bestEl.textContent = aiScore;
        goalMessage = 'AI SCORES!';
        spawnParticles(ARENA_LEFT, (GOAL_TOP + ARENA_BOTTOM)/2, '#4af', 30, 3);
      }
      goalTimer = 120; // 2 seconds pause
      gameState = 'goalScored';

      // Check win
      if (score >= WIN_SCORE || aiScore >= WIN_SCORE) {
        goalTimer = 180;
      }
    }

    // Particles update
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
      // Ball trail fade
      for (let i = ballTrail.length - 1; i >= 0; i--) {
        ballTrail[i].life--;
        if (ballTrail[i].life <= 0) ballTrail.splice(i, 1);
      }
    }

    // Main update
    function update() {
      if (gameState !== 'playing' && gameState !== 'goalScored') return;

      if (gameState === 'goalScored') {
        goalTimer--;
        updateParticles();
        if (goalTimer <= 0) {
          if (score >= WIN_SCORE || aiScore >= WIN_SCORE) {
            endMatch();
            return;
          }
          resetPositions();
          gameState = 'playing';
        }
        return;
      }

      // Timer
      timer--;
      const secs = Math.max(0, Math.ceil(timer / FPS));
      const mins = Math.floor(secs / 60);
      const secStr = (secs % 60).toString().padStart(2, '0');
      matchInfo.textContent = `${mins}:${secStr} | First to ${WIN_SCORE}`;

      if (timer <= 0) {
        endMatch();
        return;
      }

      // Player input
      const pLeft = keys['ArrowLeft'];
      const pRight = keys['ArrowRight'];
      const pUp = keys['ArrowUp'];
      const pDrive = keys['ArrowRight'] ? 1 : (keys['ArrowLeft'] ? -1 : 0);
      const pBoost = keys['Space'];

      // Actually: left/right = rotate, up = jump, drive is separate
      // Let's use: Left/Right = steer, Up = jump, Right also drives forward
      // Better mapping: ArrowRight = drive forward + rotate right, ArrowLeft = rotate left + reverse
      // Most intuitive for side-view: Left/Right = drive left/right, Up = jump, Space = boost

      // Reconsider: side-view car soccer like Rocket League Sideswipe
      // Left/Right arrows = move left/right, Up = jump, Space = boost in facing direction
      // Let's make it work: car faces direction of movement, left/right drive
      updateCar(player,
        keys['ArrowLeft'],   // rotate left
        keys['ArrowRight'],  // rotate right
        keys['ArrowUp'],     // jump
        keys['ArrowRight'] ? 1 : (keys['ArrowLeft'] ? -1 : 0), // drive
        keys['Space']        // boost
      );

      // AI
      updateAI();

      // Ball
      const goalResult = updateBall();
      if (goalResult) {
        handleGoal(goalResult);
        return;
      }

      // Collisions
      carBallCollision(player);
      carBallCollision(ai);
      carCarCollision();

      // Boost pads
      checkBoostPads(player);
      checkBoostPads(ai);
      for (const pad of boostPads) {
        if (pad.timer > 0) pad.timer--;
      }

      // Particles
      updateParticles();
    }

    function endMatch() {
      gameState = 'gameOver';
      overlay.style.display = 'flex';
      if (score > aiScore) {
        overlayTitle.textContent = 'YOU WIN!';
      } else if (aiScore > score) {
        overlayTitle.textContent = 'AI WINS!';
      } else {
        overlayTitle.textContent = 'DRAW!';
      }
      overlayText.innerHTML = `Final: ${score} - ${aiScore}<br><br>Press any key to play again`;
      if (typeof stopRecording === 'function') stopRecording();
    }

    // RENDERING
    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Arena background
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, W, H);

      // Arena field (darker green-ish tint)
      ctx.fillStyle = '#121225';
      ctx.fillRect(ARENA_LEFT, ARENA_TOP, ARENA_RIGHT - ARENA_LEFT, ARENA_BOTTOM - ARENA_TOP);

      // Field markings
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      // Center line
      ctx.beginPath();
      ctx.moveTo(W/2, ARENA_TOP);
      ctx.lineTo(W/2, ARENA_BOTTOM);
      ctx.stroke();
      // Center circle
      ctx.beginPath();
      ctx.arc(W/2, (ARENA_TOP + ARENA_BOTTOM)/2, 50, 0, Math.PI * 2);
      ctx.stroke();

      // Goals
      // Left goal (player defends)
      ctx.fillStyle = 'rgba(255, 102, 0, 0.15)';
      ctx.fillRect(ARENA_LEFT - GOAL_WIDTH - 2, GOAL_TOP, GOAL_WIDTH + 2, GOAL_HEIGHT);
      ctx.strokeStyle = '#f60';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(ARENA_LEFT, GOAL_TOP);
      ctx.lineTo(ARENA_LEFT - GOAL_WIDTH, GOAL_TOP);
      ctx.lineTo(ARENA_LEFT - GOAL_WIDTH, ARENA_BOTTOM);
      ctx.lineTo(ARENA_LEFT, ARENA_BOTTOM);
      ctx.stroke();

      // Right goal (AI defends)
      ctx.fillStyle = 'rgba(68, 170, 255, 0.15)';
      ctx.fillRect(ARENA_RIGHT, GOAL_TOP, GOAL_WIDTH + 2, GOAL_HEIGHT);
      ctx.strokeStyle = '#4af';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(ARENA_RIGHT, GOAL_TOP);
      ctx.lineTo(ARENA_RIGHT + GOAL_WIDTH, GOAL_TOP);
      ctx.lineTo(ARENA_RIGHT + GOAL_WIDTH, ARENA_BOTTOM);
      ctx.lineTo(ARENA_RIGHT, ARENA_BOTTOM);
      ctx.stroke();

      // Arena walls
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      // Top wall
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, WALL_THICK);
      ctx.fillRect(0, ARENA_BOTTOM, W, WALL_THICK);
      ctx.fillRect(0, 0, WALL_THICK, H);
      ctx.fillRect(W - WALL_THICK, 0, WALL_THICK, H);

      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.strokeRect(ARENA_LEFT, ARENA_TOP, ARENA_RIGHT - ARENA_LEFT, ARENA_BOTTOM - ARENA_TOP);

      // Boost pads
      for (const pad of boostPads) {
        if (pad.timer > 0) {
          // Respawning - faded
          ctx.fillStyle = 'rgba(255, 200, 0, 0.15)';
          ctx.beginPath();
          ctx.arc(pad.x, pad.y, BOOST_PAD_SIZE * 0.5, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Active pad - glowing diamond
          ctx.save();
          ctx.translate(pad.x, pad.y);
          ctx.rotate(Math.PI / 4);
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#ff0';
          ctx.fillStyle = '#ffa500';
          ctx.fillRect(-BOOST_PAD_SIZE/2, -BOOST_PAD_SIZE/2, BOOST_PAD_SIZE, BOOST_PAD_SIZE);
          ctx.strokeStyle = '#ff0';
          ctx.lineWidth = 1;
          ctx.strokeRect(-BOOST_PAD_SIZE/2, -BOOST_PAD_SIZE/2, BOOST_PAD_SIZE, BOOST_PAD_SIZE);
          ctx.restore();
          ctx.shadowBlur = 0;
        }
      }

      // Ball trail
      for (const t of ballTrail) {
        const alpha = t.life / 15;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.2})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, BALL_R * alpha * 0.7, 0, Math.PI * 2);
        ctx.fill();
      }

      // Ball
      const ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      ctx.save();
      ctx.shadowBlur = 5 + ballSpeed * 2;
      ctx.shadowColor = ballSpeed > 5 ? '#f60' : '#fff';
      // Ball body
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.fill();
      // Ball pentagon pattern
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
      ctx.stroke();
      // Ball segments (soccer ball look)
      const ballAngle = Math.atan2(ball.vy, ball.vx) * 0.5;
      for (let i = 0; i < 5; i++) {
        const a = ballAngle + (i / 5) * Math.PI * 2;
        const px = ball.x + Math.cos(a) * BALL_R * 0.6;
        const py = ball.y + Math.sin(a) * BALL_R * 0.6;
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      ctx.shadowBlur = 0;

      // Draw cars
      drawCar(player);
      drawCar(ai);

      // Boost meters
      drawBoostMeter(20, H - 6, player.boost, '#f60');
      drawBoostMeter(W - 120, H - 6, ai.boost, '#4af');

      // Particles
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
      }
      ctx.globalAlpha = 1;

      // Goal scored message
      if (gameState === 'goalScored' && goalTimer > 0) {
        ctx.save();
        ctx.fillStyle = goalMessage.includes('YOU') ? '#f60' : '#4af';
        ctx.font = 'bold 36px "Courier New"';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 20;
        ctx.shadowColor = ctx.fillStyle;
        const pulse = 1 + Math.sin(goalTimer * 0.15) * 0.1;
        ctx.setTransform(pulse, 0, 0, pulse, W/2, H/2);
        ctx.fillText(goalMessage, 0, 0);
        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    function drawCar(car) {
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.angle);

      const halfW = CAR_W / 2;
      const halfH = CAR_H / 2;

      // Boost flame
      if (car.boostFlame > 0) {
        const flameLen = car.boostFlame * 2 + Math.random() * 8;
        const gradient = ctx.createLinearGradient(-halfW - flameLen, 0, -halfW, 0);
        gradient.addColorStop(0, 'rgba(255,100,0,0)');
        gradient.addColorStop(0.3, car.isAI ? 'rgba(68,170,255,0.8)' : 'rgba(255,100,0,0.8)');
        gradient.addColorStop(1, '#ff0');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(-halfW, -halfH * 0.5);
        ctx.lineTo(-halfW - flameLen, 0);
        ctx.lineTo(-halfW, halfH * 0.5);
        ctx.closePath();
        ctx.fill();
      }

      // Car body shadow
      ctx.shadowBlur = 8;
      ctx.shadowColor = car.color;

      // Car body
      ctx.fillStyle = car.color;
      ctx.beginPath();
      // Rounded car shape
      const r = 4;
      ctx.moveTo(-halfW + r, -halfH);
      ctx.lineTo(halfW - r, -halfH);
      ctx.quadraticCurveTo(halfW, -halfH, halfW, -halfH + r);
      // Front slope (nose)
      ctx.lineTo(halfW + 4, -2);
      ctx.lineTo(halfW + 4, 2);
      ctx.lineTo(halfW, halfH - r);
      ctx.quadraticCurveTo(halfW, halfH, halfW - r, halfH);
      ctx.lineTo(-halfW + r, halfH);
      ctx.quadraticCurveTo(-halfW, halfH, -halfW, halfH - r);
      ctx.lineTo(-halfW, -halfH + r);
      ctx.quadraticCurveTo(-halfW, -halfH, -halfW + r, -halfH);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Car roof / windshield
      ctx.fillStyle = car.isAI ? '#2a7ab5' : '#b34700';
      ctx.fillRect(-5, -halfH, 15, halfH * 0.8);

      // Windshield
      ctx.fillStyle = 'rgba(150,200,255,0.4)';
      ctx.beginPath();
      ctx.moveTo(5, -halfH + 1);
      ctx.lineTo(12, -halfH + 1);
      ctx.lineTo(10, -3);
      ctx.lineTo(3, -3);
      ctx.closePath();
      ctx.fill();

      // Wheels
      ctx.fillStyle = '#222';
      // Front wheel
      ctx.save();
      ctx.translate(halfW - 8, halfH);
      ctx.fillRect(-4, -2, 8, 5);
      ctx.fillStyle = '#555';
      ctx.fillRect(-3, -1, 6, 3);
      ctx.restore();
      // Rear wheel
      ctx.save();
      ctx.translate(-halfW + 8, halfH);
      ctx.fillRect(-4, -2, 8, 5);
      ctx.fillStyle = '#555';
      ctx.fillRect(-3, -1, 6, 3);
      ctx.restore();

      // Number/team indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 8px "Courier New"';
      ctx.textAlign = 'center';
      ctx.fillText(car.isAI ? 'AI' : 'P1', 0, 3);

      ctx.restore();
    }

    function drawBoostMeter(x, y, amount, color) {
      const w = 100;
      const h = 4;
      ctx.fillStyle = '#222';
      ctx.fillRect(x, y - h, w, h);
      ctx.fillStyle = color;
      ctx.fillRect(x, y - h, w * (amount / MAX_BOOST), h);
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y - h, w, h);

      ctx.fillStyle = '#888';
      ctx.font = '8px "Courier New"';
      ctx.textAlign = 'left';
      ctx.fillText('BOOST', x, y - h - 2);
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Initialize
    resetAll();
    gameLoop();
  </script>
</body>
</html>

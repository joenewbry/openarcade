<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Restaurant Tycoon PvP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #e64; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 102, 68, 0.5); }
    h1 { color: #e64; font-size: 1.4rem; text-shadow: 0 0 15px rgba(238, 102, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #e64; }
    canvas {
      border: 2px solid #e64;
      box-shadow: 0 0 20px rgba(238, 102, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e64;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(238, 102, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; max-width: 420px; line-height: 1.5; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>RESTAURANT TYCOON PvP</h1>
  </div>
  <div class="score-bar">
    <div>Profit: $<span id="score">0</span></div>
    <div>Best: $<span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">RESTAURANT TYCOON PvP</h2>
      <p id="overlayText">Compete against AI restaurants on the same street.<br>Set menus, hire staff, upgrade, and outprice the competition!<br><br>Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('restaurantTycoonBest') || '0');
    bestEl.textContent = bestScore.toLocaleString();

    const THEME = '#e64';
    const THEME_RGB = '238,102,68';
    const BG = '#1a1a2e';
    const PANEL = '#12122a';
    const DARK = '#0e0e22';

    // Menu items with base costs and appeal
    const MENU_ITEMS = [
      { name: 'Burger', icon: '\u{1F354}', baseCost: 4, baseAppeal: 7, color: '#c84' },
      { name: 'Pizza',  icon: '\u{1F355}', baseCost: 5, baseAppeal: 8, color: '#e93' },
      { name: 'Sushi',  icon: '\u{1F363}', baseCost: 7, baseAppeal: 6, color: '#f69' },
      { name: 'Salad',  icon: '\u{1F957}', baseCost: 3, baseAppeal: 5, color: '#6b4' }
    ];

    const STAFF_TYPES = [
      { role: 'Chef',    icon: '\u{1F468}\u200D\u{1F373}', cost: 200, desc: '+Quality' },
      { role: 'Waiter',  icon: '\u{1F9D1}\u200D\u{1F37D}', cost: 120, desc: '+Speed' },
      { role: 'Cleaner', icon: '\u{1F9F9}', cost: 80, desc: '+Hygiene' }
    ];

    const UPGRADES = [
      { name: 'Better Oven',  icon: '\u{1F525}', cost: 500, effect: 'quality', bonus: 0.15, desc: '+15% Quality' },
      { name: 'Nice Decor',   icon: '\u{1F3A8}', cost: 400, effect: 'appeal', bonus: 0.12, desc: '+12% Appeal' },
      { name: 'Advertising',  icon: '\u{1F4E2}', cost: 350, effect: 'customers', bonus: 0.2, desc: '+20% Customers' },
      { name: 'AC System',    icon: '\u2744\uFE0F', cost: 300, effect: 'reviews', bonus: 0.1, desc: '+10% Reviews' }
    ];

    const EVENTS = [
      { name: 'Food Critic Visit!', icon: '\u{1F4F0}', apply: (r) => { r.eventBonus = r.quality > 0.7 ? 0.3 : -0.2; return r.quality > 0.7 ? 'Great review! +30% customers' : 'Bad review! -20% customers'; }},
      { name: 'Health Inspection!', icon: '\u{1F3E5}', apply: (r) => { let hyg = r.hygiene; r.eventBonus = hyg > 0.6 ? 0.1 : -0.4; if(hyg < 0.3){ r.cash -= 200; return 'Failed! -$200 fine, -40% customers'; } return hyg > 0.6 ? 'Passed! +10% customers' : '-40% customers'; }},
      { name: 'Delivery Shortage!', icon: '\u{1F69A}', apply: (r) => { let lostItem = Math.floor(Math.random()*4); if(r.menu[lostItem].active){ r.menu[lostItem].shortage = true; return r.menu[lostItem].name+' unavailable today!'; } return 'No impact (item not on menu)'; }},
      { name: 'Festival Weekend!', icon: '\u{1F389}', apply: (r) => { r.eventBonus = 0.4; return '+40% customers for everyone!'; }},
      { name: 'Rainy Day', icon: '\u{1F327}\uFE0F', apply: (r) => { r.eventBonus = -0.15; return '-15% foot traffic'; }},
      { name: 'Celebrity Spotted!', icon: '\u2B50', apply: (r) => { if(r.quality > 0.75){ r.eventBonus = 0.5; return 'Celebrity loves your food! +50% customers'; } r.eventBonus = 0; return 'Celebrity went elsewhere'; }}
    ];

    const RESTAURANT_COLORS = ['#e64', '#4ae', '#4c6', '#ea4'];
    const RESTAURANT_NAMES = ['Your Place', 'Chez Bot', 'AI Diner', 'RoboEats'];

    const MAX_ROUNDS = 15;
    const NUM_PLAYERS = 4;
    const BASE_CUSTOMERS = 30;

    let restaurants = [];
    let currentRound = 0;
    let phase = 'menu'; // menu, staff, upgrade, simulate, results
    let selectedTab = 0;
    let buttons = [];
    let scrollY = 0;
    let roundResults = null;
    let eventLog = [];
    let animFrame = 0;
    let customerAnims = [];

    function createRestaurant(index, isHuman) {
      return {
        name: RESTAURANT_NAMES[index],
        color: RESTAURANT_COLORS[index],
        isHuman: isHuman,
        cash: 2000,
        totalProfit: 0,
        menu: MENU_ITEMS.map((m, i) => ({
          name: m.name, icon: m.icon, baseCost: m.baseCost, baseAppeal: m.baseAppeal,
          color: m.color, price: m.baseCost + 3, active: i < 2, shortage: false
        })),
        staff: { chefs: 1, waiters: 1, cleaners: 1 },
        upgrades: [false, false, false, false],
        quality: 0.5,
        speed: 0.5,
        hygiene: 0.5,
        reviews: 3.0,
        eventBonus: 0,
        roundHistory: [],
        customersToday: 0,
        revenueToday: 0,
        costsToday: 0
      };
    }

    function calcStats(r) {
      let qualityBase = 0.3 + r.staff.chefs * 0.15;
      let speedBase = 0.3 + r.staff.waiters * 0.15;
      let hygieneBase = 0.3 + r.staff.cleaners * 0.2;
      if (r.upgrades[0]) qualityBase += UPGRADES[0].bonus;
      if (r.upgrades[3]) hygieneBase += UPGRADES[3].bonus;
      r.quality = Math.min(1, qualityBase);
      r.speed = Math.min(1, speedBase);
      r.hygiene = Math.min(1, hygieneBase);
    }

    function calcAppeal(r) {
      let activeItems = r.menu.filter(m => m.active && !m.shortage);
      if (activeItems.length === 0) return 0;
      let avgPrice = activeItems.reduce((s, m) => s + m.price, 0) / activeItems.length;
      let avgBaseCost = activeItems.reduce((s, m) => s + m.baseCost, 0) / activeItems.length;
      let priceRatio = avgBaseCost / avgPrice; // lower price = higher ratio = more appeal
      let variety = activeItems.length / 4;
      let qualBonus = r.quality * 0.3;
      let decorBonus = r.upgrades[1] ? UPGRADES[1].bonus : 0;
      let reviewBonus = (r.reviews - 2.5) * 0.1;
      return Math.max(0, priceRatio * 0.3 + variety * 0.2 + qualBonus + decorBonus + reviewBonus + 0.15);
    }

    function simulateRound() {
      let totalCustomers = BASE_CUSTOMERS + currentRound * 3;
      let appeals = restaurants.map(r => {
        calcStats(r);
        let a = calcAppeal(r);
        let adBonus = r.upgrades[2] ? UPGRADES[2].bonus : 0;
        let evBonus = r.eventBonus;
        return Math.max(0.05, a * (1 + adBonus) * (1 + evBonus));
      });
      let totalAppeal = appeals.reduce((s, v) => s + v, 0);

      restaurants.forEach((r, i) => {
        let share = appeals[i] / totalAppeal;
        let customers = Math.round(totalCustomers * share);
        r.customersToday = customers;

        // Revenue from customers
        let activeItems = r.menu.filter(m => m.active && !m.shortage);
        let revenue = 0;
        if (activeItems.length > 0) {
          // Each customer buys 1 random active item
          for (let c = 0; c < customers; c++) {
            let item = activeItems[Math.floor(Math.random() * activeItems.length)];
            revenue += item.price;
          }
        }
        // Speed affects how many we can actually serve
        let serveRate = Math.min(1, 0.5 + r.speed * 0.6);
        let maxServe = Math.floor(customers * serveRate);
        if (customers > maxServe) {
          revenue = revenue * (maxServe / customers);
          r.customersToday = maxServe;
        }
        r.revenueToday = Math.round(revenue);

        // Costs: staff salaries + food cost
        let staffCost = r.staff.chefs * STAFF_TYPES[0].cost + r.staff.waiters * STAFF_TYPES[1].cost + r.staff.cleaners * STAFF_TYPES[2].cost;
        let foodCost = 0;
        if (activeItems.length > 0) {
          foodCost = r.customersToday * (activeItems.reduce((s, m) => s + m.baseCost, 0) / activeItems.length);
        }
        r.costsToday = Math.round(staffCost + foodCost);

        let profit = r.revenueToday - r.costsToday;
        r.cash += profit;
        r.totalProfit += profit;

        // Update reviews
        let satisfaction = (r.quality * 0.4 + r.speed * 0.2 + r.hygiene * 0.3 + (appeals[i] > 0.3 ? 0.1 : 0)) * 5;
        r.reviews = r.reviews * 0.7 + satisfaction * 0.3;
        r.reviews = Math.max(1, Math.min(5, r.reviews));

        r.roundHistory.push({ round: currentRound, revenue: r.revenueToday, costs: r.costsToday, profit, customers: r.customersToday, reviews: r.reviews });

        // Reset shortage
        r.menu.forEach(m => m.shortage = false);
        r.eventBonus = 0;
      });

      // Generate customer animations
      customerAnims = [];
      restaurants.forEach((r, i) => {
        for (let c = 0; c < Math.min(r.customersToday, 8); c++) {
          customerAnims.push({
            targetX: 75 + i * 140,
            startX: 75 + i * 140 + (Math.random() - 0.5) * 100,
            y: 115 + Math.random() * 15,
            delay: c * 8,
            frame: 0
          });
        }
      });
    }

    function aiDecide(r, roundNum) {
      // AI pricing strategy: experiment and optimize
      let avgCompPrice = 0, count = 0;
      restaurants.forEach(other => {
        if (other === r) return;
        other.menu.forEach(m => { if (m.active) { avgCompPrice += m.price; count++; } });
      });
      avgCompPrice = count > 0 ? avgCompPrice / count : 8;

      r.menu.forEach((item, idx) => {
        // Activate items based on round progression
        if (roundNum > 3 && idx === 2 && !item.active && r.cash > 500) item.active = true;
        if (roundNum > 6 && idx === 3 && !item.active && r.cash > 800) item.active = true;

        if (item.active) {
          // Price around competition with some noise
          let targetPrice = item.baseCost + 2 + Math.random() * 3;
          // Undercut if reviews are low
          if (r.reviews < 3) targetPrice -= 1;
          // Premium if quality is high
          if (r.quality > 0.7) targetPrice += 1;
          // Respond to competition
          if (targetPrice > avgCompPrice + 2) targetPrice -= 1;
          item.price = Math.max(item.baseCost + 1, Math.round(targetPrice));
        }
      });

      // Staffing: hire based on needs and budget
      if (r.cash > 600) {
        if (r.quality < 0.6 && r.staff.chefs < 4) { r.staff.chefs++; r.cash -= 100; }
        if (r.speed < 0.5 && r.staff.waiters < 4) { r.staff.waiters++; r.cash -= 80; }
        if (r.hygiene < 0.5 && r.staff.cleaners < 4) { r.staff.cleaners++; r.cash -= 60; }
      }
      // Fire staff if losing money
      if (r.cash < 300 && r.roundHistory.length > 0) {
        let last = r.roundHistory[r.roundHistory.length - 1];
        if (last && last.profit < 0) {
          if (r.staff.waiters > 1) r.staff.waiters--;
          else if (r.staff.cleaners > 1) r.staff.cleaners--;
        }
      }

      // Buy upgrades strategically
      UPGRADES.forEach((up, i) => {
        if (!r.upgrades[i] && r.cash > up.cost + 400) {
          // Prioritize based on weakness
          let buy = false;
          if (i === 0 && r.quality < 0.6) buy = true;
          if (i === 1 && r.reviews < 3.5) buy = true;
          if (i === 2 && roundNum > 4) buy = true;
          if (i === 3 && r.hygiene < 0.5) buy = true;
          if (roundNum > 8 && Math.random() < 0.4) buy = true;
          if (buy) { r.upgrades[i] = true; r.cash -= up.cost; }
        }
      });
    }

    function startGame() {
      restaurants = [];
      for (let i = 0; i < NUM_PLAYERS; i++) {
        restaurants.push(createRestaurant(i, i === 0));
      }
      currentRound = 1;
      phase = 'menu';
      selectedTab = 0;
      eventLog = [];
      customerAnims = [];
      roundResults = null;
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'playing';
      overlay.style.display = 'none';
    }

    function endGame() {
      gameState = 'gameover';
      let playerProfit = restaurants[0].totalProfit;
      score = playerProfit;
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('restaurantTycoonBest', bestScore.toString());
        bestEl.textContent = bestScore.toLocaleString();
      }
      let rankings = restaurants.slice().sort((a, b) => b.totalProfit - a.totalProfit);
      let rank = rankings.findIndex(r => r.isHuman) + 1;
      let rankStr = ['1st', '2nd', '3rd', '4th'][rank - 1];
      overlayTitle.textContent = rank === 1 ? 'YOU WON!' : 'GAME OVER';
      let txt = `You finished ${rankStr} place!\nTotal Profit: $${playerProfit.toLocaleString()}\n\n`;
      rankings.forEach((r, i) => {
        txt += `${i + 1}. ${r.name}: $${r.totalProfit.toLocaleString()}\n`;
      });
      txt += '\nClick to Play Again';
      overlayText.innerHTML = txt.replace(/\n/g, '<br>');
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
    }

    function advancePhase() {
      if (phase === 'menu') {
        phase = 'staff';
      } else if (phase === 'staff') {
        phase = 'upgrade';
      } else if (phase === 'upgrade') {
        // AI makes decisions
        restaurants.forEach(r => { if (!r.isHuman) aiDecide(r, currentRound); });
        // Random event
        eventLog = [];
        if (Math.random() < 0.45 || currentRound === 7 || currentRound === 13) {
          let ev = EVENTS[Math.floor(Math.random() * EVENTS.length)];
          restaurants.forEach(r => {
            let msg = ev.apply(r);
            if (r.isHuman) eventLog.push(ev.icon + ' ' + ev.name + ' ' + msg);
          });
        }
        simulateRound();
        phase = 'results';
        animFrame = 0;
      } else if (phase === 'results') {
        currentRound++;
        if (currentRound > MAX_ROUNDS) {
          endGame();
          return;
        }
        phase = 'menu';
      }
    }

    // Button system
    function addButton(x, y, w, h, label, action, color, small) {
      buttons.push({ x, y, w, h, label, action, color: color || THEME, small: small || false });
    }

    function drawButton(b) {
      ctx.fillStyle = b.color || THEME;
      ctx.globalAlpha = 0.85;
      roundRect(b.x, b.y, b.w, b.h, 4);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = b.color || THEME;
      ctx.lineWidth = 1;
      roundRect(b.x, b.y, b.w, b.h, 4);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = (b.small ? '10' : '11') + 'px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2);
    }

    function roundRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    // Draw street view (top area)
    function drawStreetView() {
      // Sky
      let grad = ctx.createLinearGradient(0, 0, 0, 135);
      grad.addColorStop(0, '#1a1a3e');
      grad.addColorStop(1, '#2a2a4e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, 135);

      // Road
      ctx.fillStyle = '#2a2a3e';
      ctx.fillRect(0, 120, W, 15);
      ctx.strokeStyle = '#444';
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(0, 127);
      ctx.lineTo(W, 127);
      ctx.stroke();
      ctx.setLineDash([]);

      // Buildings
      restaurants.forEach((r, i) => {
        let bx = 20 + i * 145;
        let bw = 130;
        let bh = 70 + (r.upgrades[1] ? 10 : 0);
        let by = 120 - bh;

        // Building
        ctx.fillStyle = DARK;
        ctx.strokeStyle = r.color;
        ctx.lineWidth = 2;
        roundRect(bx, by, bw, bh, 3);
        ctx.fill();
        roundRect(bx, by, bw, bh, 3);
        ctx.stroke();

        // Sign glow
        ctx.shadowColor = r.color;
        ctx.shadowBlur = 8;
        ctx.fillStyle = r.color;
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(r.name, bx + bw / 2, by + 14);
        ctx.shadowBlur = 0;

        // Windows
        ctx.fillStyle = '#fa8';
        ctx.globalAlpha = 0.3 + (r.customersToday > 0 ? 0.4 : 0);
        for (let wx = 0; wx < 3; wx++) {
          ctx.fillRect(bx + 12 + wx * 38, by + 22, 25, 18);
        }
        ctx.globalAlpha = 1;

        // Stars
        ctx.fillStyle = '#fd4';
        ctx.font = '8px Courier New';
        let stars = Math.round(r.reviews);
        ctx.textAlign = 'center';
        ctx.fillText('\u2605'.repeat(stars) + '\u2606'.repeat(5 - stars), bx + bw / 2, by + bh - 8);

        // Door
        ctx.fillStyle = r.color;
        ctx.globalAlpha = 0.6;
        ctx.fillRect(bx + bw / 2 - 8, by + bh - 22, 16, 22);
        ctx.globalAlpha = 1;
      });

      // Customer animations
      if (phase === 'results') {
        customerAnims.forEach(ca => {
          ca.frame++;
          if (ca.frame < ca.delay) return;
          let progress = Math.min(1, (ca.frame - ca.delay) / 30);
          let cx = ca.startX + (ca.targetX - ca.startX) * progress;
          let cy = ca.y + Math.sin(progress * Math.PI) * -15;
          ctx.fillStyle = '#ddd';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.globalAlpha = progress < 0.9 ? 1 : (1 - progress) * 10;
          ctx.fillText('\u{1F6B6}', cx, cy);
          ctx.globalAlpha = 1;
        });
      }

      // Round indicator
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('Round ' + currentRound + '/' + MAX_ROUNDS, W - 10, 12);
    }

    function drawMenuPhase() {
      let r = restaurants[0];
      let py = 140;

      ctx.fillStyle = PANEL;
      roundRect(5, py, W - 10, H - py - 5, 5);
      ctx.fill();

      // Phase title
      ctx.fillStyle = THEME;
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('\u{1F37D} SET YOUR MENU & PRICES', 15, py + 20);
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.fillText('Cash: $' + r.cash.toLocaleString(), 400, py + 20);

      r.menu.forEach((item, i) => {
        let iy = py + 38 + i * 58;
        let active = item.active;

        // Item bg
        ctx.fillStyle = active ? '#1a1a3e' : '#111128';
        roundRect(15, iy, W - 30, 50, 4);
        ctx.fill();
        ctx.strokeStyle = active ? item.color : '#333';
        ctx.lineWidth = 1;
        roundRect(15, iy, W - 30, 50, 4);
        ctx.stroke();

        // Icon and name
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = active ? '#fff' : '#555';
        ctx.fillText(item.icon, 25, iy + 22);
        ctx.font = 'bold 12px Courier New';
        ctx.fillText(item.name, 55, iy + 18);

        ctx.font = '10px Courier New';
        ctx.fillStyle = '#888';
        ctx.fillText('Cost: $' + item.baseCost + '  Appeal: ' + '\u2605'.repeat(Math.ceil(item.baseAppeal / 2)), 55, iy + 34);

        if (active) {
          // Price display
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('$' + item.price, 430, iy + 25);

          let margin = item.price - item.baseCost;
          ctx.font = '9px Courier New';
          ctx.fillStyle = margin > 0 ? '#4c6' : '#e44';
          ctx.fillText('margin: $' + margin, 430, iy + 40);

          // Price buttons
          addButton(370, iy + 10, 24, 24, '-', () => { if (item.price > item.baseCost + 1) item.price--; }, '#c44', true);
          addButton(465, iy + 10, 24, 24, '+', () => { item.price++; }, '#4c4', true);

          // Toggle off
          addButton(510, iy + 10, 55, 24, 'Remove', () => { item.active = false; }, '#844', true);
        } else {
          // Toggle on
          addButton(440, iy + 12, 80, 26, 'Add Item', () => { item.active = true; }, '#486', true);
        }
      });

      addButton(W / 2 - 60, H - 40, 120, 30, 'NEXT \u25B6', () => advancePhase(), THEME);
    }

    function drawStaffPhase() {
      let r = restaurants[0];
      let py = 140;

      ctx.fillStyle = PANEL;
      roundRect(5, py, W - 10, H - py - 5, 5);
      ctx.fill();

      ctx.fillStyle = THEME;
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('\u{1F465} MANAGE STAFF', 15, py + 20);
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.fillText('Cash: $' + r.cash.toLocaleString(), 400, py + 20);

      calcStats(r);

      STAFF_TYPES.forEach((st, i) => {
        let iy = py + 38 + i * 72;
        let count = i === 0 ? r.staff.chefs : i === 1 ? r.staff.waiters : r.staff.cleaners;
        let stat = i === 0 ? r.quality : i === 1 ? r.speed : r.hygiene;
        let statName = i === 0 ? 'Quality' : i === 1 ? 'Speed' : 'Hygiene';

        ctx.fillStyle = '#1a1a3e';
        roundRect(15, iy, W - 30, 62, 4);
        ctx.fill();
        ctx.strokeStyle = '#335';
        ctx.lineWidth = 1;
        roundRect(15, iy, W - 30, 62, 4);
        ctx.stroke();

        // Info
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#fff';
        ctx.fillText(st.icon, 25, iy + 22);

        ctx.font = 'bold 12px Courier New';
        ctx.fillText(st.role + ' x' + count, 60, iy + 18);
        ctx.font = '10px Courier New';
        ctx.fillStyle = '#888';
        ctx.fillText(st.desc + ' | Salary: $' + st.cost + '/round each', 60, iy + 34);

        // Stat bar
        ctx.fillStyle = '#0a0a1e';
        ctx.fillRect(60, iy + 42, 200, 10);
        let barColor = stat > 0.7 ? '#4c6' : stat > 0.4 ? '#ea4' : '#e44';
        ctx.fillStyle = barColor;
        ctx.fillRect(60, iy + 42, 200 * stat, 10);
        ctx.fillStyle = '#fff';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(statName + ': ' + Math.round(stat * 100) + '%', 270, iy + 51);

        // Hire/Fire
        let staffKey = i === 0 ? 'chefs' : i === 1 ? 'waiters' : 'cleaners';
        addButton(430, iy + 8, 50, 22, 'Hire', () => { if (r.cash >= st.cost) { r.staff[staffKey]++; r.cash -= Math.round(st.cost * 0.5); } }, '#486', true);
        addButton(490, iy + 8, 50, 22, 'Fire', () => { if (r.staff[staffKey] > 0) r.staff[staffKey]--; }, '#844', true);
        ctx.fillStyle = '#aaa';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Total: $' + (count * st.cost) + '/rd', 460, iy + 52);
      });

      addButton(W / 2 - 60, H - 40, 120, 30, 'NEXT \u25B6', () => advancePhase(), THEME);
    }

    function drawUpgradePhase() {
      let r = restaurants[0];
      let py = 140;

      ctx.fillStyle = PANEL;
      roundRect(5, py, W - 10, H - py - 5, 5);
      ctx.fill();

      ctx.fillStyle = THEME;
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('\u{1F527} BUY UPGRADES', 15, py + 20);
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.fillText('Cash: $' + r.cash.toLocaleString(), 400, py + 20);

      UPGRADES.forEach((up, i) => {
        let iy = py + 38 + i * 58;
        let owned = r.upgrades[i];

        ctx.fillStyle = owned ? '#1a2a1a' : '#1a1a3e';
        roundRect(15, iy, W - 30, 50, 4);
        ctx.fill();
        ctx.strokeStyle = owned ? '#4c6' : '#335';
        ctx.lineWidth = 1;
        roundRect(15, iy, W - 30, 50, 4);
        ctx.stroke();

        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#fff';
        ctx.fillText(up.icon, 25, iy + 22);

        ctx.font = 'bold 12px Courier New';
        ctx.fillText(up.name, 55, iy + 18);
        ctx.font = '10px Courier New';
        ctx.fillStyle = '#888';
        ctx.fillText(up.desc, 55, iy + 34);

        if (owned) {
          ctx.fillStyle = '#4c6';
          ctx.font = 'bold 11px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('\u2713 OWNED', 480, iy + 25);
        } else {
          let canBuy = r.cash >= up.cost;
          addButton(430, iy + 10, 100, 28, '$' + up.cost, () => {
            if (r.cash >= up.cost) { r.upgrades[i] = true; r.cash -= up.cost; }
          }, canBuy ? '#486' : '#444', false);
        }
      });

      addButton(W / 2 - 60, H - 40, 120, 30, 'SIMULATE \u25B6', () => advancePhase(), '#e84');
    }

    function drawResultsPhase() {
      animFrame++;
      let py = 140;

      ctx.fillStyle = PANEL;
      roundRect(5, py, W - 10, H - py - 5, 5);
      ctx.fill();

      ctx.fillStyle = THEME;
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('\u{1F4CA} ROUND ' + currentRound + ' RESULTS', 15, py + 20);

      // Event log
      if (eventLog.length > 0) {
        ctx.fillStyle = '#fd4';
        ctx.font = '10px Courier New';
        eventLog.forEach((e, i) => {
          ctx.fillText(e, 15, py + 38 + i * 14);
        });
      }

      let ey = py + 38 + eventLog.length * 14 + 5;

      // Results table header
      ctx.fillStyle = '#666';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Restaurant', 20, ey + 10);
      ctx.textAlign = 'center';
      ctx.fillText('Cust', 220, ey + 10);
      ctx.fillText('Revenue', 290, ey + 10);
      ctx.fillText('Costs', 370, ey + 10);
      ctx.fillText('Profit', 450, ey + 10);
      ctx.fillText('Rating', 540, ey + 10);

      // Sort by profit for this round
      let sorted = restaurants.slice().sort((a, b) => (b.revenueToday - b.costsToday) - (a.revenueToday - a.costsToday));

      sorted.forEach((r, i) => {
        let ry = ey + 22 + i * 36;
        let profit = r.revenueToday - r.costsToday;
        let isPlayer = r.isHuman;

        ctx.fillStyle = isPlayer ? '#1a1a3e' : '#111128';
        roundRect(10, ry - 4, W - 20, 30, 3);
        ctx.fill();
        if (isPlayer) {
          ctx.strokeStyle = THEME;
          ctx.lineWidth = 1;
          roundRect(10, ry - 4, W - 20, 30, 3);
          ctx.stroke();
        }

        ctx.fillStyle = r.color;
        ctx.font = 'bold 11px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText((isPlayer ? '\u25B6 ' : '  ') + r.name, 20, ry + 12);

        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ddd';
        ctx.fillText(r.customersToday.toString(), 220, ry + 12);
        ctx.fillStyle = '#4c6';
        ctx.fillText('$' + r.revenueToday, 290, ry + 12);
        ctx.fillStyle = '#e88';
        ctx.fillText('$' + r.costsToday, 370, ry + 12);
        ctx.fillStyle = profit >= 0 ? '#4c6' : '#e44';
        ctx.font = 'bold 11px Courier New';
        ctx.fillText((profit >= 0 ? '+' : '') + '$' + profit, 450, ry + 12);

        ctx.fillStyle = '#fd4';
        ctx.font = '10px Courier New';
        ctx.fillText(r.reviews.toFixed(1) + '\u2605', 540, ry + 12);
      });

      // Total standings
      let sy = ey + 22 + NUM_PLAYERS * 36 + 10;
      ctx.fillStyle = '#666';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('STANDINGS (Total Profit):', 20, sy);

      let ranked = restaurants.slice().sort((a, b) => b.totalProfit - a.totalProfit);
      ranked.forEach((r, i) => {
        ctx.fillStyle = r.isHuman ? THEME : r.color;
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText((i + 1) + '. ' + r.name + ': $' + r.totalProfit.toLocaleString() + '  (Cash: $' + r.cash.toLocaleString() + ')', 20, sy + 14 + i * 14);
      });

      let btnLabel = currentRound >= MAX_ROUNDS ? 'FINISH' : 'NEXT ROUND \u25B6';
      addButton(W / 2 - 70, H - 40, 140, 30, btnLabel, () => advancePhase(), THEME);
    }

    function draw() {
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      buttons = [];

      if (gameState !== 'playing') {
        // Draw idle street view
        drawStreetView();
        return;
      }

      drawStreetView();

      // Phase tabs
      let tabs = ['Menu', 'Staff', 'Upgrades', 'Results'];
      let phaseIdx = phase === 'menu' ? 0 : phase === 'staff' ? 1 : phase === 'upgrade' ? 2 : 3;
      tabs.forEach((t, i) => {
        let tx = 10 + i * 100;
        ctx.fillStyle = i === phaseIdx ? THEME : '#333';
        ctx.globalAlpha = i <= phaseIdx ? 1 : 0.4;
        roundRect(tx, 132, 90, 14, 2);
        ctx.fill();
        ctx.fillStyle = i === phaseIdx ? '#fff' : '#aaa';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(t, tx + 45, 142);
        ctx.globalAlpha = 1;
      });

      if (phase === 'menu') drawMenuPhase();
      else if (phase === 'staff') drawStaffPhase();
      else if (phase === 'upgrade') drawUpgradePhase();
      else if (phase === 'results') drawResultsPhase();

      // Draw buttons
      buttons.forEach(b => drawButton(b));

      // Update score
      score = restaurants[0].totalProfit;
      scoreEl.textContent = score.toLocaleString();
    }

    // Mouse handling
    canvas.addEventListener('click', (e) => {
      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      let my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'gameover') {
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        startGame();
        return;
      }

      // Check buttons
      for (let b of buttons) {
        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
          b.action();
          return;
        }
      }
    });

    // Hover cursor
    canvas.addEventListener('mousemove', (e) => {
      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      let my = (e.clientY - rect.top) * (H / rect.height);
      let over = false;
      for (let b of buttons) {
        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
          over = true;
          break;
        }
      }
      canvas.style.cursor = over ? 'pointer' : 'default';
    });

    function gameLoop() {
      draw();
      requestAnimationFrame(gameLoop);
    }

    overlay.style.display = 'flex';
    overlay.style.pointerEvents = 'auto';

    // Click on overlay to start
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'gameover') {
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        startGame();
      }
    });

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

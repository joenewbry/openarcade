<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Curling Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #4cf; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 204, 255, 0.5); }
    h1 { color: #4cf; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 204, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4cf; }
    canvas {
      border: 2px solid #4cf;
      box-shadow: 0 0 20px rgba(68, 204, 255, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4cf;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CURLING SIMULATOR</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="endInfo" style="color:#4cf;font-size:0.9rem;">End 1/8</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">CURLING SIMULATOR</h2>
      <p id="overlayText">Click to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 400, H = 600;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const endInfoEl = document.getElementById('endInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const THEME = '#4cf';

    // Sheet geometry
    const SHEET_L = 30;
    const SHEET_R = W - 30;
    const SHEET_T = 20;
    const SHEET_B = H - 20;
    const SHEET_W = SHEET_R - SHEET_L;
    const SHEET_CX = W / 2;

    // House center (target area near top of sheet)
    const HOUSE_Y = 100;
    const BUTTON_R = 6;
    const RING1_R = 22;  // 4-foot
    const RING2_R = 44;  // 8-foot
    const RING3_R = 66;  // 12-foot

    // Hog lines and other lines
    const HOG_LINE_FAR = HOUSE_Y + RING3_R + 30;   // far hog line
    const HOG_LINE_NEAR = H - 100;                   // near hog line
    const HACK_Y = H - 50;                            // delivery point
    const TEE_LINE_Y = HOUSE_Y;                       // tee line
    const BACK_LINE_Y = HOUSE_Y - RING3_R - 10;      // back line

    // Stone properties
    const STONE_R = 11;
    const FRICTION = 0.992;
    const CURL_FACTOR = 0.012;
    const MIN_SPEED = 0.08;
    const MAX_STONES_PER_TEAM = 8;
    const MAX_ENDS = 8;

    // State
    let gameState = 'waiting';
    let score = 0;
    let cpuScore = 0;
    let currentEnd = 1;
    let stonesThrown = 0;  // 0-15, alternating
    let stones = [];       // all stones on the sheet
    let activeStone = null;
    let phase = 'aim';     // aim, power, sliding, sweeping, scoring, aiTurn
    let aimAngle = -Math.PI / 2;
    let powerLevel = 0;
    let powerDir = 1;
    let sweeping = false;
    let mouseDown = false;
    let mouseX = W / 2, mouseY = H / 2;
    let curlDir = 1;       // 1 = clockwise, -1 = counter-clockwise
    let turnMessage = '';
    let turnMessageTimer = 0;
    let scoringDisplay = null;
    let endScores = [];     // [{player: x, cpu: y}, ...]
    let hammerTeam = 'cpu'; // who has last stone advantage
    let animFrame = 0;
    let aiThinking = false;
    let aiThinkTimer = 0;

    function isPlayerTurn() {
      // Alternating throws. If player has hammer, player throws last (even indices: cpu first)
      // If cpu has hammer, cpu throws last (even indices: player first)
      if (hammerTeam === 'player') {
        return stonesThrown % 2 === 1; // cpu throws first (0,2,4...), player second (1,3,5...)
      } else {
        return stonesThrown % 2 === 0; // player throws first (0,2,4...), cpu second (1,3,5...)
      }
    }

    function currentTeam() {
      return isPlayerTurn() ? 'player' : 'cpu';
    }

    function init() {
      score = 0;
      cpuScore = 0;
      currentEnd = 1;
      endScores = [];
      hammerTeam = 'cpu';
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      startEnd();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'CURLING SIMULATOR';
      overlayText.textContent = 'Click to start';
      draw();
    }

    function startEnd() {
      stones = [];
      stonesThrown = 0;
      activeStone = null;
      phase = 'aim';
      sweeping = false;
      scoringDisplay = null;
      updateEndInfo();
      startTurn();
    }

    function updateEndInfo() {
      endInfoEl.textContent = `End ${currentEnd}/${MAX_ENDS}`;
    }

    function startTurn() {
      if (stonesThrown >= MAX_STONES_PER_TEAM * 2) {
        // End is over, score it
        scoreEnd();
        return;
      }
      if (isPlayerTurn()) {
        phase = 'aim';
        aimAngle = -Math.PI / 2;
        powerLevel = 0;
        powerDir = 1;
        curlDir = 1;
        turnMessage = 'Your throw - Click to aim';
        turnMessageTimer = 120;
      } else {
        phase = 'aiTurn';
        aiThinking = true;
        aiThinkTimer = 60;
        turnMessage = 'CPU thinking...';
        turnMessageTimer = 90;
      }
    }

    function createStone(team, x, y, vx, vy, curl) {
      return {
        team: team,
        x: x, y: y,
        vx: vx, vy: vy,
        curl: curl || 0,
        active: true,
        settled: false
      };
    }

    function throwStone(team, angle, power, curl) {
      const speed = power * 6.5 + 1.5;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const stone = createStone(team, SHEET_CX, HACK_Y, vx, vy, curl);
      stones.push(stone);
      activeStone = stone;
      phase = 'sliding';
      sweeping = false;
      stonesThrown++;
    }

    // Physics
    function updatePhysics() {
      let anyMoving = false;

      for (let s of stones) {
        if (!s.active) continue;
        const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
        if (speed < MIN_SPEED) {
          s.vx = 0;
          s.vy = 0;
          s.settled = true;
          continue;
        }
        anyMoving = true;

        // Apply friction
        let fric = FRICTION;
        if (s === activeStone && sweeping) {
          fric = 0.996; // sweeping reduces friction
        }
        s.vx *= fric;
        s.vy *= fric;

        // Apply curl (stones curve as they slow down)
        if (speed > 0.3 && speed < 4) {
          const curlAmount = CURL_FACTOR * s.curl * (1 - speed / 6);
          s.vx += curlAmount;
        }

        s.x += s.vx;
        s.y += s.vy;

        // Wall collisions (sides of sheet)
        if (s.x - STONE_R < SHEET_L) {
          s.x = SHEET_L + STONE_R;
          s.vx = Math.abs(s.vx) * 0.5;
        }
        if (s.x + STONE_R > SHEET_R) {
          s.x = SHEET_R - STONE_R;
          s.vx = -Math.abs(s.vx) * 0.5;
        }

        // Back line - stone is out if it passes behind the house
        if (s.y < BACK_LINE_Y) {
          s.active = false;
          continue;
        }

        // Stone must cross far hog line or it's removed (only for the thrown stone, not collided stones)
        // We'll check this when it settles
      }

      // Stone-stone collisions
      for (let i = 0; i < stones.length; i++) {
        if (!stones[i].active) continue;
        const si = stones[i];
        const spi = Math.sqrt(si.vx * si.vx + si.vy * si.vy);
        if (spi < MIN_SPEED && si.settled) continue;

        for (let j = i + 1; j < stones.length; j++) {
          if (!stones[j].active) continue;
          const sj = stones[j];

          const dx = sj.x - si.x;
          const dy = sj.y - si.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = STONE_R * 2;

          if (dist < minDist && dist > 0) {
            // Collision response
            const nx = dx / dist;
            const ny = dy / dist;

            // Separate
            const overlap = minDist - dist;
            si.x -= nx * overlap * 0.5;
            si.y -= ny * overlap * 0.5;
            sj.x += nx * overlap * 0.5;
            sj.y += ny * overlap * 0.5;

            // Elastic collision (equal mass)
            const dvx = si.vx - sj.vx;
            const dvy = si.vy - sj.vy;
            const dvDotN = dvx * nx + dvy * ny;

            if (dvDotN > 0) {
              const restitution = 0.85;
              si.vx -= dvDotN * nx * restitution;
              si.vy -= dvDotN * ny * restitution;
              sj.vx += dvDotN * nx * restitution;
              sj.vy += dvDotN * ny * restitution;
              si.settled = false;
              sj.settled = false;
            }
          }
        }
      }

      // Remove stones that went past bottom (shouldn't happen much but safety)
      for (let s of stones) {
        if (s.y > SHEET_B + 50) s.active = false;
      }

      return anyMoving;
    }

    // Scoring logic
    function distToButton(stone) {
      const dx = stone.x - SHEET_CX;
      const dy = stone.y - HOUSE_Y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function scoreEnd() {
      phase = 'scoring';

      // Only stones in play (active) and in the house count
      const playerStones = stones.filter(s => s.active && s.team === 'player');
      const cpuStones = stones.filter(s => s.active && s.team === 'cpu');

      // Find closest stone to button for each team
      let closestPlayer = Infinity;
      let closestCpu = Infinity;

      for (let s of playerStones) closestPlayer = Math.min(closestPlayer, distToButton(s));
      for (let s of cpuStones) closestCpu = Math.min(closestCpu, distToButton(s));

      let endPlayerScore = 0;
      let endCpuScore = 0;

      if (closestPlayer < closestCpu) {
        // Player scores - count all player stones closer than closest CPU stone and within house
        for (let s of playerStones) {
          if (distToButton(s) < closestCpu && distToButton(s) <= RING3_R + STONE_R) {
            endPlayerScore++;
          }
        }
        if (endPlayerScore > 0) hammerTeam = 'cpu'; // non-scoring team gets hammer
      } else if (closestCpu < closestPlayer) {
        // CPU scores
        for (let s of cpuStones) {
          if (distToButton(s) < closestPlayer && distToButton(s) <= RING3_R + STONE_R) {
            endCpuScore++;
          }
        }
        if (endCpuScore > 0) hammerTeam = 'player';
      }
      // If tied or no stones: blank end, hammer doesn't change

      score += endPlayerScore;
      cpuScore += endCpuScore;
      scoreEl.textContent = score;
      bestEl.textContent = cpuScore;

      endScores.push({ player: endPlayerScore, cpu: endCpuScore });

      scoringDisplay = {
        playerScore: endPlayerScore,
        cpuScore: endCpuScore,
        timer: 180
      };
    }

    function advanceEnd() {
      currentEnd++;
      if (currentEnd > MAX_ENDS) {
        gameOver();
        return;
      }
      startEnd();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      if (score > cpuScore) {
        overlayTitle.textContent = 'YOU WIN!';
      } else if (cpuScore > score) {
        overlayTitle.textContent = 'CPU WINS';
      } else {
        overlayTitle.textContent = 'DRAW';
      }
      overlayText.textContent = `${score} - ${cpuScore} | Click to play again`;
    }

    // AI Logic
    function aiTakeTurn() {
      const cpuStones = stones.filter(s => s.active && s.team === 'cpu');
      const playerStones = stones.filter(s => s.active && s.team === 'player');
      const stonesLeft = MAX_STONES_PER_TEAM - Math.floor(stonesThrown / 2) - (isPlayerTurn() ? 0 : 0);

      let targetX = SHEET_CX;
      let targetY = HOUSE_Y;
      let power = 0.55;
      let curl = (Math.random() > 0.5 ? 1 : -1) * 0.8;

      // Strategy selection
      const closestPlayerDist = playerStones.length > 0
        ? Math.min(...playerStones.map(s => distToButton(s)))
        : Infinity;
      const closestCpuDist = cpuStones.length > 0
        ? Math.min(...cpuStones.map(s => distToButton(s)))
        : Infinity;

      const strategy = Math.random();

      if (playerStones.length > 0 && closestPlayerDist < RING2_R && strategy < 0.4) {
        // Takeout: aim at the closest player stone
        let target = null;
        let bestD = Infinity;
        for (let s of playerStones) {
          const d = distToButton(s);
          if (d < bestD) { bestD = d; target = s; }
        }
        if (target) {
          targetX = target.x + (Math.random() - 0.5) * 4;
          targetY = target.y;
          power = 0.7 + Math.random() * 0.15;
        }
      } else if (cpuStones.length === 0 || (closestCpuDist > RING2_R && strategy < 0.7)) {
        // Draw to the button
        targetX = SHEET_CX + (Math.random() - 0.5) * RING1_R;
        targetY = HOUSE_Y + (Math.random() - 0.5) * RING1_R;
        power = 0.45 + Math.random() * 0.15;
      } else if (strategy < 0.8 && stonesThrown < 8) {
        // Guard: place stone in front of house
        targetX = SHEET_CX + (Math.random() - 0.5) * 40;
        targetY = HOG_LINE_FAR - 20 - Math.random() * 30;
        power = 0.38 + Math.random() * 0.1;
      } else {
        // Freeze: place stone next to existing CPU stone near button
        if (cpuStones.length > 0) {
          const best = cpuStones.reduce((a, b) => distToButton(a) < distToButton(b) ? a : b);
          targetX = best.x + (Math.random() > 0.5 ? 1 : -1) * STONE_R * 2.2;
          targetY = best.y + (Math.random() - 0.5) * STONE_R;
          power = 0.48 + Math.random() * 0.12;
        } else {
          targetX = SHEET_CX + (Math.random() - 0.5) * 20;
          targetY = HOUSE_Y;
          power = 0.5 + Math.random() * 0.1;
        }
      }

      // Calculate angle from hack to target
      const dx = targetX - SHEET_CX;
      const dy = targetY - HACK_Y;
      let angle = Math.atan2(dy, dx);

      // Add some imperfection
      angle += (Math.random() - 0.5) * 0.06;
      power += (Math.random() - 0.5) * 0.05;
      power = Math.max(0.3, Math.min(0.9, power));

      throwStone('cpu', angle, power, curl);

      // AI sometimes sweeps its own stone
      if (Math.random() > 0.4) {
        sweeping = true;
        setTimeout(() => { sweeping = false; }, 1500 + Math.random() * 1000);
      }
    }

    // Main update
    function update() {
      animFrame++;

      if (turnMessageTimer > 0) turnMessageTimer--;

      if (phase === 'scoring' && scoringDisplay) {
        scoringDisplay.timer--;
        if (scoringDisplay.timer <= 0) {
          advanceEnd();
        }
        return;
      }

      if (phase === 'aiTurn') {
        if (aiThinkTimer > 0) {
          aiThinkTimer--;
          return;
        }
        if (aiThinking) {
          aiThinking = false;
          aiTakeTurn();
        }
      }

      if (phase === 'power') {
        powerLevel += powerDir * 0.018;
        if (powerLevel >= 1) { powerLevel = 1; powerDir = -1; }
        if (powerLevel <= 0) { powerLevel = 0; powerDir = 1; }
      }

      if (phase === 'sliding') {
        const moving = updatePhysics();
        if (!moving) {
          // Check if active stone crossed the hog line
          if (activeStone && activeStone.active && activeStone.y > HOG_LINE_FAR) {
            // Didn't reach the hog line - remove it (hogged)
            activeStone.active = false;
            turnMessage = 'Hogged! Stone removed';
            turnMessageTimer = 90;
          }

          activeStone = null;
          sweeping = false;

          // Small delay before next turn
          setTimeout(() => {
            if (gameState === 'playing') startTurn();
          }, 500);
          phase = 'waiting';
        }
      }
    }

    // Drawing
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawSheet();
      drawStones();
      drawUI();

      if (scoringDisplay) {
        drawScoringOverlay();
      }
    }

    function drawSheet() {
      // Ice surface
      ctx.fillStyle = '#d0e8f0';
      ctx.fillRect(SHEET_L, SHEET_T, SHEET_W, SHEET_B - SHEET_T);

      // Subtle pebble texture
      ctx.fillStyle = 'rgba(200, 220, 230, 0.3)';
      for (let i = 0; i < 80; i++) {
        const px = SHEET_L + Math.sin(i * 137.508) * SHEET_W / 2 + SHEET_W / 2;
        const py = SHEET_T + ((i * 73.13) % (SHEET_B - SHEET_T));
        ctx.beginPath();
        ctx.arc(px, py, 1, 0, Math.PI * 2);
        ctx.fill();
      }

      // House rings (12-foot, 8-foot, 4-foot, button)
      // 12-foot ring - blue
      ctx.fillStyle = '#3377cc';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, RING3_R, 0, Math.PI * 2);
      ctx.fill();

      // White ring between 12 and 8
      ctx.fillStyle = '#e8f0f4';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, RING2_R, 0, Math.PI * 2);
      ctx.fill();

      // 8-foot ring - red
      ctx.fillStyle = '#cc3333';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, RING2_R - 2, 0, Math.PI * 2);
      ctx.fill();

      // White ring between 8 and 4
      ctx.fillStyle = '#e8f0f4';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, RING1_R, 0, Math.PI * 2);
      ctx.fill();

      // 4-foot ring - blue
      ctx.fillStyle = '#3377cc';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, RING1_R - 2, 0, Math.PI * 2);
      ctx.fill();

      // Button (center)
      ctx.fillStyle = '#e8f0f4';
      ctx.beginPath();
      ctx.arc(SHEET_CX, HOUSE_Y, BUTTON_R, 0, Math.PI * 2);
      ctx.fill();

      // Ring outlines
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 1;
      for (let r of [RING3_R, RING2_R, RING1_R, BUTTON_R]) {
        ctx.beginPath();
        ctx.arc(SHEET_CX, HOUSE_Y, r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Tee line (horizontal through button)
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(SHEET_L, TEE_LINE_Y);
      ctx.lineTo(SHEET_R, TEE_LINE_Y);
      ctx.stroke();

      // Center line (vertical)
      ctx.beginPath();
      ctx.moveTo(SHEET_CX, SHEET_T);
      ctx.lineTo(SHEET_CX, SHEET_B);
      ctx.stroke();

      // Back line
      ctx.strokeStyle = 'rgba(200, 0, 0, 0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(SHEET_L, BACK_LINE_Y);
      ctx.lineTo(SHEET_R, BACK_LINE_Y);
      ctx.stroke();

      // Hog lines
      ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(SHEET_L, HOG_LINE_FAR);
      ctx.lineTo(SHEET_R, HOG_LINE_FAR);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(SHEET_L, HOG_LINE_NEAR);
      ctx.lineTo(SHEET_R, HOG_LINE_NEAR);
      ctx.stroke();

      // Labels
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.font = '9px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.fillText('HOG', SHEET_L + 2, HOG_LINE_FAR - 3);
      ctx.fillText('HOG', SHEET_L + 2, HOG_LINE_NEAR - 3);
      ctx.fillText('BACK', SHEET_L + 2, BACK_LINE_Y - 3);

      // Hack (delivery foot-hold)
      ctx.fillStyle = '#555';
      ctx.fillRect(SHEET_CX - 10, HACK_Y - 3, 20, 6);
      ctx.fillStyle = '#888';
      ctx.fillRect(SHEET_CX - 8, HACK_Y - 2, 16, 4);

      // Sheet border
      ctx.strokeStyle = '#4cf';
      ctx.lineWidth = 1;
      ctx.strokeRect(SHEET_L, SHEET_T, SHEET_W, SHEET_B - SHEET_T);
    }

    function drawStones() {
      for (let s of stones) {
        if (!s.active) continue;
        drawStone(s.x, s.y, s.team, s === activeStone && phase === 'sliding');
      }
    }

    function drawStone(x, y, team, isActive) {
      const color = team === 'player' ? '#dd3333' : '#ddcc22';
      const darkColor = team === 'player' ? '#aa1111' : '#aa9900';
      const lightColor = team === 'player' ? '#ff6666' : '#ffee66';

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.arc(x + 1, y + 1, STONE_R, 0, Math.PI * 2);
      ctx.fill();

      // Main stone body
      ctx.fillStyle = color;
      if (isActive) {
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;
      }
      ctx.beginPath();
      ctx.arc(x, y, STONE_R, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Outer ring (handle)
      ctx.strokeStyle = darkColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R - 1, 0, Math.PI * 2);
      ctx.stroke();

      // Handle on top
      ctx.fillStyle = darkColor;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R * 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Highlight
      ctx.fillStyle = lightColor;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(x - 2, y - 2, STONE_R * 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawUI() {
      // Turn message
      if (turnMessageTimer > 0) {
        const alpha = Math.min(1, turnMessageTimer / 30);
        ctx.fillStyle = `rgba(68, 204, 255, ${alpha})`;
        ctx.font = 'bold 14px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#4cf';
        ctx.shadowBlur = 10;
        ctx.fillText(turnMessage, W / 2, H - 30);
        ctx.shadowBlur = 0;
      }

      // Stone count indicators
      const playerThrown = stones.filter(s => s.team === 'player').length;
      const cpuThrown = stones.filter(s => s.team === 'cpu').length;
      drawStoneCount(5, H - 18, 'player', playerThrown);
      drawStoneCount(W - 100, H - 18, 'cpu', cpuThrown);

      // Aim indicator
      if (phase === 'aim') {
        const aimLen = 100;

        // Draw aim line from hack
        ctx.strokeStyle = 'rgba(68, 204, 255, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(SHEET_CX, HACK_Y);
        const endX = SHEET_CX + Math.cos(aimAngle) * aimLen;
        const endY = HACK_Y + Math.sin(aimAngle) * aimLen;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw target crosshair
        ctx.strokeStyle = '#4cf';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(endX, endY, 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(endX - 12, endY);
        ctx.lineTo(endX + 12, endY);
        ctx.moveTo(endX, endY - 12);
        ctx.lineTo(endX, endY + 12);
        ctx.stroke();

        // Curl indicator
        ctx.fillStyle = '#4cf';
        ctx.font = '11px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(curlDir > 0 ? 'Curl: >>>' : 'Curl: <<<', W / 2, HACK_Y + 20);
        ctx.fillText('Right-click: flip curl', W / 2, HACK_Y + 33);

        // Draw stone at hack
        drawStone(SHEET_CX, HACK_Y, 'player', false);
      }

      // Power meter
      if (phase === 'power') {
        const meterX = SHEET_R + 8;
        const meterY = 80;
        const meterH = 400;
        const meterW = 16;

        // Background
        ctx.fillStyle = 'rgba(30, 30, 50, 0.9)';
        ctx.fillRect(meterX - 2, meterY - 2, meterW + 4, meterH + 4);

        // Meter fill
        const fillH = meterH * powerLevel;
        const gradient = ctx.createLinearGradient(meterX, meterY + meterH, meterX, meterY);
        gradient.addColorStop(0, '#2a6');
        gradient.addColorStop(0.5, '#cc2');
        gradient.addColorStop(1, '#c22');
        ctx.fillStyle = gradient;
        ctx.fillRect(meterX, meterY + meterH - fillH, meterW, fillH);

        // Border
        ctx.strokeStyle = '#4cf';
        ctx.lineWidth = 1;
        ctx.strokeRect(meterX, meterY, meterW, meterH);

        // Power indicator
        const indY = meterY + meterH - fillH;
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.fillRect(meterX - 4, indY - 2, meterW + 8, 4);
        ctx.shadowBlur = 0;

        // Labels
        ctx.fillStyle = '#4cf';
        ctx.font = '10px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PWR', meterX + meterW / 2, meterY - 8);
        ctx.fillText(Math.round(powerLevel * 100) + '%', meterX + meterW / 2, meterY + meterH + 14);

        // Draw stone at hack with aim line
        ctx.strokeStyle = 'rgba(68, 204, 255, 0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(SHEET_CX, HACK_Y);
        ctx.lineTo(SHEET_CX + Math.cos(aimAngle) * 80, HACK_Y + Math.sin(aimAngle) * 80);
        ctx.stroke();
        ctx.setLineDash([]);
        drawStone(SHEET_CX, HACK_Y, 'player', false);
      }

      // Sweeping indicator
      if (phase === 'sliding' && activeStone && activeStone.team === 'player') {
        const canSweep = true;
        ctx.fillStyle = sweeping ? 'rgba(68, 255, 100, 0.9)' : 'rgba(68, 204, 255, 0.7)';
        ctx.font = 'bold 13px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = sweeping ? '#4f8' : '#4cf';
        ctx.shadowBlur = 10;
        ctx.fillText(sweeping ? 'SWEEPING!' : 'Hold mouse to SWEEP', W / 2, H - 8);
        ctx.shadowBlur = 0;

        // Sweep broom indicators near stone
        if (sweeping) {
          const bx = activeStone.x + Math.sin(animFrame * 0.3) * 14;
          const by = activeStone.y;
          ctx.strokeStyle = 'rgba(68, 255, 100, 0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(bx - 6, by - 8);
          ctx.lineTo(bx + 6, by + 8);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(bx + 6, by - 8);
          ctx.lineTo(bx - 6, by + 8);
          ctx.stroke();
        }
      }

      // End scoreboard (bottom area when not aiming)
      if (endScores.length > 0 && phase !== 'aim' && phase !== 'power') {
        drawEndScoreboard();
      }
    }

    function drawStoneCount(x, y, team, thrown) {
      const max = MAX_STONES_PER_TEAM;
      const color = team === 'player' ? '#dd3333' : '#ddcc22';
      ctx.fillStyle = 'rgba(200,200,200,0.5)';
      ctx.font = '9px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.fillText(team === 'player' ? 'YOU' : 'CPU', x, y - 4);
      for (let i = 0; i < max; i++) {
        ctx.fillStyle = i < thrown ? 'rgba(80,80,80,0.4)' : color;
        ctx.beginPath();
        ctx.arc(x + 4 + i * 11, y + 6, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawEndScoreboard() {
      const sbX = 5;
      const sbY = 3;
      ctx.fillStyle = 'rgba(26, 26, 46, 0.85)';
      ctx.fillRect(sbX, sbY, W - 10, 16);

      ctx.font = '9px "Courier New", monospace';
      ctx.textAlign = 'center';

      let xOff = sbX + 25;
      ctx.fillStyle = '#888';
      ctx.fillText('END', xOff, sbY + 11);
      xOff += 20;

      for (let i = 0; i < endScores.length; i++) {
        const es = endScores[i];
        if (es.player > 0) {
          ctx.fillStyle = '#dd3333';
          ctx.fillText(es.player, xOff, sbY + 11);
        } else if (es.cpu > 0) {
          ctx.fillStyle = '#ddcc22';
          ctx.fillText(es.cpu, xOff, sbY + 11);
        } else {
          ctx.fillStyle = '#555';
          ctx.fillText('0', xOff, sbY + 11);
        }
        xOff += 22;
      }
    }

    function drawScoringOverlay() {
      if (!scoringDisplay) return;
      const alpha = Math.min(1, scoringDisplay.timer / 30);

      ctx.fillStyle = `rgba(26, 26, 46, ${alpha * 0.7})`;
      ctx.fillRect(0, H / 2 - 60, W, 120);

      ctx.textAlign = 'center';
      ctx.shadowColor = '#4cf';
      ctx.shadowBlur = 15;

      ctx.font = 'bold 20px "Courier New", monospace';
      ctx.fillStyle = `rgba(68, 204, 255, ${alpha})`;
      ctx.fillText(`End ${currentEnd} Complete`, W / 2, H / 2 - 30);

      if (scoringDisplay.playerScore > 0) {
        ctx.fillStyle = `rgba(221, 51, 51, ${alpha})`;
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.fillText(`You score ${scoringDisplay.playerScore}!`, W / 2, H / 2 + 5);
      } else if (scoringDisplay.cpuScore > 0) {
        ctx.fillStyle = `rgba(221, 204, 34, ${alpha})`;
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.fillText(`CPU scores ${scoringDisplay.cpuScore}!`, W / 2, H / 2 + 5);
      } else {
        ctx.fillStyle = `rgba(150, 150, 150, ${alpha})`;
        ctx.font = 'bold 18px "Courier New", monospace';
        ctx.fillText('Blank end - no score', W / 2, H / 2 + 5);
      }

      ctx.fillStyle = `rgba(68, 204, 255, ${alpha * 0.7})`;
      ctx.font = '14px "Courier New", monospace';
      ctx.fillText(`Total: You ${score} - CPU ${cpuScore}`, W / 2, H / 2 + 35);

      ctx.shadowBlur = 0;
    }

    // Input handling
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);

      if (phase === 'aim' && isPlayerTurn()) {
        // Update aim angle based on mouse position relative to hack
        const dx = mouseX - SHEET_CX;
        const dy = mouseY - HACK_Y;
        aimAngle = Math.atan2(dy, dx);
        // Restrict angle to upper half
        if (aimAngle > -0.1) aimAngle = -0.1;
        if (aimAngle < -Math.PI + 0.1) aimAngle = -Math.PI + 0.1;
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;

      if (phase === 'sliding' && activeStone && activeStone.team === 'player') {
        sweeping = true;
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      mouseDown = false;
      sweeping = false;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        startTurn();
        requestAnimationFrame(loop);
        return;
      }

      if (gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.style.display = 'none';
        startTurn();
        requestAnimationFrame(loop);
        return;
      }

      if (phase === 'aim' && isPlayerTurn()) {
        phase = 'power';
        powerLevel = 0;
        powerDir = 1;
        turnMessage = 'Click to set power';
        turnMessageTimer = 120;
        return;
      }

      if (phase === 'power' && isPlayerTurn()) {
        throwStone('player', aimAngle, powerLevel, curlDir);
        turnMessage = 'Hold mouse to sweep!';
        turnMessageTimer = 120;
        return;
      }
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (phase === 'aim') {
        curlDir *= -1;
      }
    });

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        startTurn();
        requestAnimationFrame(loop);
        return;
      }
      if (gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.style.display = 'none';
        startTurn();
        requestAnimationFrame(loop);
        return;
      }
    });

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

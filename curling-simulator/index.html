<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Curling Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #4cf; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 204, 255, 0.5); }
    h1 { color: #4cf; font-size: 1.5rem; text-shadow: 0 0 15px rgba(68, 204, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4cf; }
    canvas {
      border: 2px solid #4cf;
      box-shadow: 0 0 20px rgba(68, 204, 255, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4cf;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CURLING SIMULATOR</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="endInfo" style="color:#4cf;font-size:0.9rem;">End 1/8</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">CURLING SIMULATOR</h2>
      <p id="overlayText">Click to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 400, H = 600;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const endInfoEl = document.getElementById('endInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const THEME = '#4cf';

    // ---- Sheet geometry ----
    const SHEET_L = 40;
    const SHEET_R = W - 40;
    const SHEET_T = 15;
    const SHEET_B = H - 15;
    const SHEET_W = SHEET_R - SHEET_L;
    const CX = W / 2;

    // House (target) positioned in the upper portion of the sheet
    const HOUSE_Y = 105;
    const BUTTON_R = 5;
    const RING1_R = 20;   // 4-foot
    const RING2_R = 40;   // 8-foot
    const RING3_R = 60;   // 12-foot

    // Key lines
    const BACK_LINE = HOUSE_Y - RING3_R - 8;
    const TEE_LINE = HOUSE_Y;
    const HOG_FAR = HOUSE_Y + RING3_R + 30;
    const HOG_NEAR = H - 90;
    const HACK_Y = H - 45;

    // Stone
    const STONE_R = 10;
    const FRICTION = 0.9925;
    const SWEEP_FRICTION = 0.9965;
    const CURL_STRENGTH = 0.008;
    const MIN_SPEED = 0.06;
    const MAX_STONES = 8;
    const MAX_ENDS = 8;

    // ---- Game state ----
    let gameState = 'waiting';
    let score = 0;
    let cpuScore = 0;
    let currentEnd = 1;
    let stonesThrown = 0;
    let stones = [];
    let activeStone = null;
    let phase = 'idle';
    let aimAngle = -Math.PI / 2;
    let powerLevel = 0;
    let powerDir = 1;
    let sweeping = false;
    let mouseDown = false;
    let mouseX = CX, mouseY = H / 2;
    let curlDir = 1;
    let hammerTeam = 'cpu';
    let endScores = [];
    let animFrame = 0;
    let aiThinkTimer = 0;
    let msg = '';
    let msgTimer = 0;
    let scoringDisplay = null;
    let turnDelay = 0;
    let particles = [];

    function isPlayerTurn() {
      // Team with hammer throws last. Non-hammer team throws on even stone counts.
      if (hammerTeam === 'player') {
        return stonesThrown % 2 === 1;
      } else {
        return stonesThrown % 2 === 0;
      }
    }

    function teamOf(index) {
      if (hammerTeam === 'player') {
        return index % 2 === 1 ? 'player' : 'cpu';
      } else {
        return index % 2 === 0 ? 'player' : 'cpu';
      }
    }

    function init() {
      score = 0;
      cpuScore = 0;
      currentEnd = 1;
      endScores = [];
      hammerTeam = 'cpu';
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      startEnd();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'CURLING SIMULATOR';
      overlayText.textContent = 'Click to start';
      draw();
    }

    function startEnd() {
      stones = [];
      stonesThrown = 0;
      activeStone = null;
      phase = 'idle';
      sweeping = false;
      scoringDisplay = null;
      particles = [];
      updateEndInfo();
      beginTurn();
    }

    function updateEndInfo() {
      endInfoEl.textContent = `End ${currentEnd}/${MAX_ENDS}`;
    }

    function showMsg(text, duration) {
      msg = text;
      msgTimer = duration || 120;
    }

    function beginTurn() {
      if (stonesThrown >= MAX_STONES * 2) {
        scoreEnd();
        return;
      }
      if (isPlayerTurn()) {
        phase = 'aim';
        aimAngle = -Math.PI / 2;
        powerLevel = 0;
        powerDir = 1;
        curlDir = 1;
        showMsg('Click to set aim direction', 150);
      } else {
        phase = 'aiThink';
        aiThinkTimer = 45 + Math.random() * 30 | 0;
        showMsg('CPU is thinking...', 90);
      }
    }

    function launchStone(team, angle, power, curl) {
      const speed = 1.5 + power * 5.5;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const s = {
        team, x: CX, y: HACK_Y,
        vx, vy, curl: curl || 0,
        active: true
      };
      stones.push(s);
      activeStone = s;
      phase = 'sliding';
      sweeping = false;
      stonesThrown++;
      // Collision spark
      spawnParticles(CX, HACK_Y, '#fff', 3);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const sp = 0.5 + Math.random() * 1.5;
        particles.push({
          x, y,
          vx: Math.cos(a) * sp,
          vy: Math.sin(a) * sp,
          life: 20 + Math.random() * 20,
          color
        });
      }
    }

    // ---- Physics ----
    function updatePhysics() {
      let anyMoving = false;

      for (let s of stones) {
        if (!s.active) continue;
        const speed = Math.hypot(s.vx, s.vy);
        if (speed < MIN_SPEED) {
          s.vx = 0;
          s.vy = 0;
          continue;
        }
        anyMoving = true;

        // Friction
        let f = (s === activeStone && sweeping) ? SWEEP_FRICTION : FRICTION;
        s.vx *= f;
        s.vy *= f;

        // Curl: stone curves more as it slows down
        if (speed > 0.2 && speed < 3.5) {
          const curlAmt = CURL_STRENGTH * s.curl * (1 - speed / 5);
          s.vx += curlAmt;
        }

        s.x += s.vx;
        s.y += s.vy;

        // Side walls
        if (s.x - STONE_R < SHEET_L) {
          s.x = SHEET_L + STONE_R;
          s.vx = Math.abs(s.vx) * 0.4;
        }
        if (s.x + STONE_R > SHEET_R) {
          s.x = SHEET_R - STONE_R;
          s.vx = -Math.abs(s.vx) * 0.4;
        }

        // Back line: stone is removed
        if (s.y - STONE_R < BACK_LINE) {
          s.active = false;
          spawnParticles(s.x, s.y, s.team === 'player' ? '#f66' : '#ff6', 5);
          continue;
        }
        // Past bottom: remove
        if (s.y > SHEET_B + 30) {
          s.active = false;
          continue;
        }
      }

      // Stone-stone collisions
      for (let i = 0; i < stones.length; i++) {
        if (!stones[i].active || Math.hypot(stones[i].vx, stones[i].vy) < 0.001 &&
            i !== stones.indexOf(activeStone)) {
          // Still check if something is moving into it
        }
        const a = stones[i];
        if (!a.active) continue;
        for (let j = i + 1; j < stones.length; j++) {
          const b = stones[j];
          if (!b.active) continue;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.hypot(dx, dy);
          const minD = STONE_R * 2;

          if (dist < minD && dist > 0.1) {
            const nx = dx / dist;
            const ny = dy / dist;
            const overlap = minD - dist;
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;

            const dvx = a.vx - b.vx;
            const dvy = a.vy - b.vy;
            const dvn = dvx * nx + dvy * ny;

            if (dvn > 0) {
              const rest = 0.82;
              a.vx -= dvn * nx * rest;
              a.vy -= dvn * ny * rest;
              b.vx += dvn * nx * rest;
              b.vy += dvn * ny * rest;
              // Collision effect
              const mx = (a.x + b.x) / 2;
              const my = (a.y + b.y) / 2;
              spawnParticles(mx, my, '#fff', 4);
            }
          }
        }
      }

      return anyMoving;
    }

    // ---- Scoring ----
    function distToButton(s) {
      return Math.hypot(s.x - CX, s.y - HOUSE_Y);
    }

    function scoreEnd() {
      phase = 'scoring';
      const pStones = stones.filter(s => s.active && s.team === 'player');
      const cStones = stones.filter(s => s.active && s.team === 'cpu');

      let closestP = Infinity, closestC = Infinity;
      for (let s of pStones) closestP = Math.min(closestP, distToButton(s));
      for (let s of cStones) closestC = Math.min(closestC, distToButton(s));

      let ep = 0, ec = 0;
      const houseLimit = RING3_R + STONE_R;

      if (closestP < closestC) {
        for (let s of pStones) {
          if (distToButton(s) < closestC && distToButton(s) <= houseLimit) ep++;
        }
        if (ep > 0) hammerTeam = 'cpu';
      } else if (closestC < closestP) {
        for (let s of cStones) {
          if (distToButton(s) < closestP && distToButton(s) <= houseLimit) ec++;
        }
        if (ec > 0) hammerTeam = 'player';
      }
      // blank end: hammer stays

      score += ep;
      cpuScore += ec;
      scoreEl.textContent = score;
      bestEl.textContent = cpuScore;
      endScores.push({ player: ep, cpu: ec });

      scoringDisplay = { playerScore: ep, cpuScore: ec, timer: 200 };
    }

    function advanceEnd() {
      currentEnd++;
      if (currentEnd > MAX_ENDS) {
        gameOver();
        return;
      }
      startEnd();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      if (score > cpuScore) {
        overlayTitle.textContent = 'YOU WIN!';
      } else if (cpuScore > score) {
        overlayTitle.textContent = 'CPU WINS';
      } else {
        overlayTitle.textContent = 'DRAW';
      }
      overlayText.textContent = `${score} - ${cpuScore} | Click to play again`;
    }

    // ---- AI ----
    function aiTurn() {
      const cpuS = stones.filter(s => s.active && s.team === 'cpu');
      const plS = stones.filter(s => s.active && s.team === 'player');
      const stonesRemaining = MAX_STONES * 2 - stonesThrown;

      let closestPD = Infinity, closestCD = Infinity;
      let closestPS = null, closestCS = null;
      for (let s of plS) { const d = distToButton(s); if (d < closestPD) { closestPD = d; closestPS = s; } }
      for (let s of cpuS) { const d = distToButton(s); if (d < closestCD) { closestCD = d; closestCS = s; } }

      let targetX = CX, targetY = HOUSE_Y;
      let power = 0.5;
      let curl = (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random() * 0.5);

      // Decide strategy
      const r = Math.random();

      if (closestPS && closestPD < RING2_R && closestPD < closestCD && r < 0.55) {
        // TAKEOUT: hit the closest player stone
        targetX = closestPS.x + (Math.random() - 0.5) * 3;
        targetY = closestPS.y;
        power = 0.65 + Math.random() * 0.2;
      } else if (cpuS.length === 0 || closestCD > RING2_R) {
        if (r < 0.7 || stonesRemaining <= 4) {
          // DRAW TO BUTTON: place near center
          targetX = CX + (Math.random() - 0.5) * RING1_R * 1.5;
          targetY = HOUSE_Y + (Math.random() - 0.5) * RING1_R;
          power = 0.42 + Math.random() * 0.14;
        } else {
          // GUARD: place in front of house
          targetX = CX + (Math.random() - 0.5) * 30;
          targetY = HOG_FAR + 10 + Math.random() * 25;
          power = 0.34 + Math.random() * 0.08;
        }
      } else if (closestCS && closestCD < RING1_R && r < 0.5) {
        // FREEZE: place next to our best stone
        const side = Math.random() > 0.5 ? 1 : -1;
        targetX = closestCS.x + side * STONE_R * 2.3;
        targetY = closestCS.y + (Math.random() - 0.5) * STONE_R;
        power = 0.44 + Math.random() * 0.1;
      } else if (closestPS && closestPD < RING3_R && r < 0.7) {
        // TAKEOUT
        targetX = closestPS.x + (Math.random() - 0.5) * 3;
        targetY = closestPS.y;
        power = 0.62 + Math.random() * 0.18;
      } else {
        // DRAW
        targetX = CX + (Math.random() - 0.5) * RING2_R;
        targetY = HOUSE_Y + (Math.random() - 0.5) * RING1_R * 1.5;
        power = 0.43 + Math.random() * 0.13;
      }

      // Calculate angle from hack to target
      const dx = targetX - CX;
      const dy = targetY - HACK_Y;
      let angle = Math.atan2(dy, dx);

      // AI imperfection
      angle += (Math.random() - 0.5) * 0.04;
      power += (Math.random() - 0.5) * 0.04;
      power = Math.max(0.25, Math.min(0.92, power));

      launchStone('cpu', angle, power, curl);

      // AI sweeping
      if (power < 0.6 && Math.random() > 0.35) {
        sweeping = true;
        const sweepDur = 1200 + Math.random() * 1500;
        setTimeout(() => { if (activeStone && activeStone.team === 'cpu') sweeping = false; }, sweepDur);
      }
    }

    // ---- Update ----
    function update() {
      animFrame++;

      if (msgTimer > 0) msgTimer--;

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      if (phase === 'scoring' && scoringDisplay) {
        scoringDisplay.timer--;
        if (scoringDisplay.timer <= 0) advanceEnd();
        return;
      }

      if (turnDelay > 0) {
        turnDelay--;
        return;
      }

      if (phase === 'aiThink') {
        aiThinkTimer--;
        if (aiThinkTimer <= 0) aiTurn();
        return;
      }

      if (phase === 'power') {
        powerLevel += powerDir * 0.015;
        if (powerLevel >= 1) { powerLevel = 1; powerDir = -1; }
        if (powerLevel <= 0) { powerLevel = 0; powerDir = 1; }
      }

      if (phase === 'sliding') {
        const moving = updatePhysics();
        if (!moving) {
          // Check hog line: thrown stone must reach far hog line
          if (activeStone && activeStone.active && activeStone.y > HOG_FAR) {
            activeStone.active = false;
            spawnParticles(activeStone.x, activeStone.y, '#888', 5);
            showMsg('Hogged! Removed.', 90);
          }
          activeStone = null;
          sweeping = false;
          phase = 'idle';
          turnDelay = 30;
          setTimeout(() => {
            if (gameState === 'playing' && phase === 'idle') beginTurn();
          }, 600);
        }
      }
    }

    // ---- Drawing ----
    function draw() {
      // Dark background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawSheet();
      drawStones();
      drawUI();

      if (scoringDisplay) drawScoringOverlay();
    }

    function drawSheet() {
      // Ice surface with gradient
      const iceGrad = ctx.createLinearGradient(SHEET_L, SHEET_T, SHEET_R, SHEET_B);
      iceGrad.addColorStop(0, '#c8dce6');
      iceGrad.addColorStop(0.5, '#d4e8f0');
      iceGrad.addColorStop(1, '#c0d4de');
      ctx.fillStyle = iceGrad;
      ctx.fillRect(SHEET_L, SHEET_T, SHEET_W, SHEET_B - SHEET_T);

      // Pebble texture (subtle dots)
      ctx.fillStyle = 'rgba(180, 200, 210, 0.4)';
      for (let i = 0; i < 120; i++) {
        const px = SHEET_L + ((i * 137.508 + 50) % SHEET_W);
        const py = SHEET_T + ((i * 73.13 + 20) % (SHEET_B - SHEET_T));
        ctx.beginPath();
        ctx.arc(px, py, 0.8, 0, Math.PI * 2);
        ctx.fill();
      }

      // ---- House rings ----
      // 12-foot (outer) - blue
      ctx.fillStyle = '#2266bb';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, RING3_R, 0, Math.PI * 2);
      ctx.fill();

      // White band
      ctx.fillStyle = '#e0ecf2';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, RING2_R + 4, 0, Math.PI * 2);
      ctx.fill();

      // 8-foot - red
      ctx.fillStyle = '#cc2222';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, RING2_R, 0, Math.PI * 2);
      ctx.fill();

      // White band inner
      ctx.fillStyle = '#e0ecf2';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, RING1_R + 3, 0, Math.PI * 2);
      ctx.fill();

      // 4-foot - blue
      ctx.fillStyle = '#2266bb';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, RING1_R, 0, Math.PI * 2);
      ctx.fill();

      // Button (center) - white
      ctx.fillStyle = '#e0ecf2';
      ctx.beginPath();
      ctx.arc(CX, HOUSE_Y, BUTTON_R, 0, Math.PI * 2);
      ctx.fill();

      // Ring outlines
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 0.5;
      [RING3_R, RING2_R + 4, RING2_R, RING1_R + 3, RING1_R, BUTTON_R].forEach(r => {
        ctx.beginPath();
        ctx.arc(CX, HOUSE_Y, r, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Center line (vertical)
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(CX, BACK_LINE - 5);
      ctx.lineTo(CX, SHEET_B);
      ctx.stroke();

      // Tee line (horizontal through button)
      ctx.beginPath();
      ctx.moveTo(SHEET_L, TEE_LINE);
      ctx.lineTo(SHEET_R, TEE_LINE);
      ctx.stroke();

      // Back line
      ctx.strokeStyle = 'rgba(180, 30, 30, 0.5)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(SHEET_L, BACK_LINE);
      ctx.lineTo(SHEET_R, BACK_LINE);
      ctx.stroke();

      // Hog lines
      ctx.strokeStyle = 'rgba(180, 30, 30, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(SHEET_L, HOG_FAR);
      ctx.lineTo(SHEET_R, HOG_FAR);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(SHEET_L, HOG_NEAR);
      ctx.lineTo(SHEET_R, HOG_NEAR);
      ctx.stroke();

      // Line labels
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.font = '8px "Courier New"';
      ctx.textAlign = 'right';
      ctx.fillText('BACK', SHEET_R - 2, BACK_LINE - 2);
      ctx.fillText('HOG', SHEET_R - 2, HOG_FAR - 2);
      ctx.fillText('HOG', SHEET_R - 2, HOG_NEAR - 2);

      // Hack
      ctx.fillStyle = '#444';
      ctx.fillRect(CX - 12, HACK_Y - 4, 24, 8);
      ctx.fillStyle = '#666';
      ctx.fillRect(CX - 10, HACK_Y - 3, 20, 6);
      ctx.fillStyle = '#555';
      ctx.fillRect(CX - 2, HACK_Y - 5, 4, 10);

      // Sheet border with neon glow
      ctx.strokeStyle = 'rgba(68, 204, 255, 0.3)';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#4cf';
      ctx.shadowBlur = 8;
      ctx.strokeRect(SHEET_L - 1, SHEET_T - 1, SHEET_W + 2, SHEET_B - SHEET_T + 2);
      ctx.shadowBlur = 0;
    }

    function drawStones() {
      // Sort so active stone draws on top
      const sorted = [...stones].filter(s => s.active);
      if (activeStone) {
        const idx = sorted.indexOf(activeStone);
        if (idx >= 0) {
          sorted.splice(idx, 1);
          sorted.push(activeStone);
        }
      }
      for (let s of sorted) {
        drawStone(s.x, s.y, s.team, s === activeStone && phase === 'sliding');
      }
    }

    function drawStone(x, y, team, glow) {
      const isRed = team === 'player';
      const main = isRed ? '#cc2222' : '#ccaa11';
      const dark = isRed ? '#991111' : '#998800';
      const light = isRed ? '#ff5555' : '#ffdd44';

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.arc(x + 1.5, y + 1.5, STONE_R + 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Glow for active stone
      if (glow) {
        ctx.shadowColor = main;
        ctx.shadowBlur = 15;
      }

      // Body
      ctx.fillStyle = main;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Edge ring
      ctx.strokeStyle = dark;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R - 0.5, 0, Math.PI * 2);
      ctx.stroke();

      // Handle (top of stone)
      ctx.fillStyle = dark;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R * 0.45, 0, Math.PI * 2);
      ctx.fill();

      // Handle highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(x, y, STONE_R * 0.45, -Math.PI * 0.8, -Math.PI * 0.2);
      ctx.stroke();

      // Specular highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(x - 2.5, y - 2.5, STONE_R * 0.25, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawUI() {
      // ---- Aim phase ----
      if (phase === 'aim' && isPlayerTurn()) {
        // Aim line
        const aimLen = 120;
        const ex = CX + Math.cos(aimAngle) * aimLen;
        const ey = HACK_Y + Math.sin(aimAngle) * aimLen;

        // Dotted aim line
        ctx.strokeStyle = 'rgba(68, 204, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(CX, HACK_Y);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);

        // Crosshair at end
        ctx.strokeStyle = 'rgba(68, 204, 255, 0.7)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(ex, ey, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ex - 14, ey); ctx.lineTo(ex + 14, ey);
        ctx.moveTo(ex, ey - 14); ctx.lineTo(ex, ey + 14);
        ctx.stroke();

        // Stone preview at hack
        drawStone(CX, HACK_Y, 'player', false);

        // Curl direction
        ctx.fillStyle = '#4cf';
        ctx.font = '11px "Courier New"';
        ctx.textAlign = 'center';
        ctx.fillText('Curl: ' + (curlDir > 0 ? '>>>' : '<<<'), CX, HACK_Y + 25);
        ctx.fillStyle = 'rgba(150,150,150,0.7)';
        ctx.font = '9px "Courier New"';
        ctx.fillText('Right-click to flip curl', CX, HACK_Y + 37);
      }

      // ---- Power phase ----
      if (phase === 'power') {
        // Power meter on right side
        const mx = SHEET_R + 10;
        const my = 60;
        const mh = 420;
        const mw = 14;

        // Background
        ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
        ctx.fillRect(mx - 3, my - 3, mw + 6, mh + 6);

        // Gradient fill
        const fillH = mh * powerLevel;
        const grad = ctx.createLinearGradient(mx, my + mh, mx, my);
        grad.addColorStop(0, '#22aa66');
        grad.addColorStop(0.4, '#cccc22');
        grad.addColorStop(0.7, '#cc6622');
        grad.addColorStop(1, '#cc2222');
        ctx.fillStyle = grad;
        ctx.fillRect(mx, my + mh - fillH, mw, fillH);

        // Zone labels
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '7px "Courier New"';
        ctx.textAlign = 'left';
        ctx.fillText('MAX', mx + mw + 3, my + 8);
        ctx.fillText('MED', mx + mw + 3, my + mh * 0.5);
        ctx.fillText('LOW', mx + mw + 3, my + mh - 5);

        // Border
        ctx.strokeStyle = '#4cf';
        ctx.lineWidth = 1;
        ctx.strokeRect(mx, my, mw, mh);

        // Indicator bar
        const iy = my + mh - fillH;
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.fillRect(mx - 5, iy - 2, mw + 10, 4);
        ctx.shadowBlur = 0;

        // Power percentage
        ctx.fillStyle = '#4cf';
        ctx.font = 'bold 12px "Courier New"';
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(powerLevel * 100) + '%', mx + mw / 2, my + mh + 18);
        ctx.fillText('PWR', mx + mw / 2, my - 10);

        // Still show aim line faintly
        ctx.strokeStyle = 'rgba(68, 204, 255, 0.25)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(CX, HACK_Y);
        ctx.lineTo(CX + Math.cos(aimAngle) * 80, HACK_Y + Math.sin(aimAngle) * 80);
        ctx.stroke();
        ctx.setLineDash([]);

        drawStone(CX, HACK_Y, 'player', false);
      }

      // ---- Sweep indicator ----
      if (phase === 'sliding' && activeStone && activeStone.active) {
        if (activeStone.team === 'player') {
          const sweepText = sweeping ? '*** SWEEPING! ***' : 'Hold mouse to SWEEP';
          ctx.fillStyle = sweeping ? 'rgba(68, 255, 120, 0.9)' : 'rgba(68, 204, 255, 0.7)';
          ctx.font = 'bold 12px "Courier New"';
          ctx.textAlign = 'center';
          ctx.shadowColor = sweeping ? '#4f8' : '#4cf';
          ctx.shadowBlur = 10;
          ctx.fillText(sweepText, CX, SHEET_B + 10);
          ctx.shadowBlur = 0;

          // Broom animation near stone when sweeping
          if (sweeping && activeStone.active) {
            const boff = Math.sin(animFrame * 0.4) * 12;
            const bx = activeStone.x + boff;
            const by = activeStone.y + 2;
            ctx.strokeStyle = 'rgba(68, 255, 120, 0.5)';
            ctx.lineWidth = 2;
            for (let bi = -1; bi <= 1; bi += 2) {
              ctx.beginPath();
              ctx.moveTo(bx + bi * 5, by - 6);
              ctx.lineTo(bx - bi * 5, by + 6);
              ctx.stroke();
            }
          }
        } else {
          // CPU sweeping indicator
          if (sweeping) {
            ctx.fillStyle = 'rgba(221, 204, 34, 0.6)';
            ctx.font = '11px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('CPU sweeping...', CX, SHEET_B + 10);
          }
        }
      }

      // ---- Turn message ----
      if (msgTimer > 0 && phase !== 'sliding') {
        const alpha = Math.min(1, msgTimer / 40);
        ctx.fillStyle = `rgba(68, 204, 255, ${alpha})`;
        ctx.font = 'bold 12px "Courier New"';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#4cf';
        ctx.shadowBlur = 8;
        ctx.fillText(msg, CX, SHEET_B + 10);
        ctx.shadowBlur = 0;
      }

      // ---- Stone count ----
      drawStoneCount(5, H - 12, 'player');
      drawStoneCount(W - 100, H - 12, 'cpu');

      // ---- End scoreboard ----
      if (endScores.length > 0) {
        drawScoreboard();
      }

      // ---- Particles ----
      for (let p of particles) {
        const a = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, a);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.5 * a, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Distance indicators for stones in/near house
      if (phase !== 'aim' && phase !== 'power') {
        const activeStones = stones.filter(s => s.active);
        for (let s of activeStones) {
          const d = distToButton(s);
          if (d <= RING3_R + STONE_R * 2) {
            // Small distance label
            ctx.fillStyle = s.team === 'player' ? 'rgba(255,100,100,0.6)' : 'rgba(255,220,50,0.6)';
            ctx.font = '7px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText(d.toFixed(0), s.x, s.y - STONE_R - 3);
          }
        }
      }
    }

    function drawStoneCount(x, y, team) {
      const thrown = stones.filter(s => s.team === team).length;
      const color = team === 'player' ? '#cc2222' : '#ccaa11';
      ctx.fillStyle = 'rgba(200,200,200,0.4)';
      ctx.font = '8px "Courier New"';
      ctx.textAlign = 'left';
      ctx.fillText(team === 'player' ? 'YOU' : 'CPU', x, y - 3);
      for (let i = 0; i < MAX_STONES; i++) {
        ctx.fillStyle = i < thrown ? 'rgba(60,60,60,0.3)' : color;
        ctx.beginPath();
        ctx.arc(x + 4 + i * 10, y + 5, 3.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawScoreboard() {
      const sbW = Math.min(W - 10, 30 + endScores.length * 28 + 60);
      const sbX = (W - sbW) / 2;
      const sbY = 1;
      const sbH = 13;

      ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
      ctx.fillRect(sbX, sbY, sbW, sbH);
      ctx.strokeStyle = 'rgba(68, 204, 255, 0.2)';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(sbX, sbY, sbW, sbH);

      ctx.font = '8px "Courier New"';
      ctx.textAlign = 'center';

      let xp = sbX + 16;
      ctx.fillStyle = '#888';
      ctx.fillText('END', xp, sbY + 9);
      xp += 18;

      for (let i = 0; i < endScores.length; i++) {
        const es = endScores[i];
        if (es.player > 0) {
          ctx.fillStyle = '#ff5555';
        } else if (es.cpu > 0) {
          ctx.fillStyle = '#ffdd44';
        } else {
          ctx.fillStyle = '#555';
        }
        ctx.fillText(es.player > 0 ? es.player : es.cpu > 0 ? es.cpu : '-', xp, sbY + 9);
        xp += 22;
      }

      // Total
      ctx.fillStyle = '#4cf';
      ctx.fillText(`${score}-${cpuScore}`, xp + 8, sbY + 9);
    }

    function drawScoringOverlay() {
      if (!scoringDisplay) return;
      const a = Math.min(1, scoringDisplay.timer / 40);

      ctx.fillStyle = `rgba(26, 26, 46, ${a * 0.75})`;
      ctx.fillRect(0, H / 2 - 65, W, 130);

      ctx.textAlign = 'center';

      // End number
      ctx.font = 'bold 18px "Courier New"';
      ctx.fillStyle = `rgba(68, 204, 255, ${a})`;
      ctx.shadowColor = '#4cf';
      ctx.shadowBlur = 12;
      ctx.fillText(`End ${currentEnd} Complete`, CX, H / 2 - 35);
      ctx.shadowBlur = 0;

      // Score result
      if (scoringDisplay.playerScore > 0) {
        ctx.fillStyle = `rgba(221, 51, 51, ${a})`;
        ctx.font = 'bold 22px "Courier New"';
        ctx.shadowColor = '#d33';
        ctx.shadowBlur = 10;
        ctx.fillText(`You score ${scoringDisplay.playerScore}!`, CX, H / 2);
      } else if (scoringDisplay.cpuScore > 0) {
        ctx.fillStyle = `rgba(221, 187, 34, ${a})`;
        ctx.font = 'bold 22px "Courier New"';
        ctx.shadowColor = '#db2';
        ctx.shadowBlur = 10;
        ctx.fillText(`CPU scores ${scoringDisplay.cpuScore}!`, CX, H / 2);
      } else {
        ctx.fillStyle = `rgba(150, 150, 150, ${a})`;
        ctx.font = 'bold 16px "Courier New"';
        ctx.fillText('Blank end', CX, H / 2);
      }
      ctx.shadowBlur = 0;

      // Total
      ctx.fillStyle = `rgba(68, 204, 255, ${a * 0.8})`;
      ctx.font = '14px "Courier New"';
      ctx.fillText(`Total: You ${score} - CPU ${cpuScore}`, CX, H / 2 + 30);

      // Hammer info
      ctx.fillStyle = `rgba(150, 150, 150, ${a * 0.6})`;
      ctx.font = '10px "Courier New"';
      ctx.fillText(`Hammer: ${hammerTeam === 'player' ? 'You' : 'CPU'}`, CX, H / 2 + 50);
    }

    // ---- Input ----
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);

      if (phase === 'aim' && isPlayerTurn()) {
        const dx = mouseX - CX;
        const dy = mouseY - HACK_Y;
        aimAngle = Math.atan2(dy, dx);
        // Restrict to upward angles
        if (aimAngle > -0.08) aimAngle = -0.08;
        if (aimAngle < -Math.PI + 0.08) aimAngle = -Math.PI + 0.08;
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      mouseDown = true;
      if (phase === 'sliding' && activeStone && activeStone.team === 'player') {
        sweeping = true;
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      mouseDown = false;
      if (sweeping && activeStone && activeStone.team === 'player') {
        sweeping = false;
      }
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        beginTurn();
        requestAnimationFrame(loop);
        return;
      }

      if (gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.style.display = 'none';
        beginTurn();
        requestAnimationFrame(loop);
        return;
      }

      if (phase === 'aim' && isPlayerTurn()) {
        phase = 'power';
        powerLevel = 0;
        powerDir = 1;
        showMsg('Click to set power', 150);
        return;
      }

      if (phase === 'power' && isPlayerTurn()) {
        launchStone('player', aimAngle, powerLevel, curlDir);
        showMsg('Hold mouse to sweep!', 120);
        return;
      }
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (phase === 'aim') curlDir *= -1;
    });

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        beginTurn();
        requestAnimationFrame(loop);
      } else if (gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.style.display = 'none';
        beginTurn();
        requestAnimationFrame(loop);
      }
    });

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

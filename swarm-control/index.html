<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swarm Control</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #8f0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 255, 0, 0.4); }
    h1 { color: #8f0; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 255, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8f0; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
      color: #888;
    }
    canvas {
      border: 2px solid #8f0;
      box-shadow: 0 0 20px rgba(136, 255, 0, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8f0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(136,255,0,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
    .overlay .sub { font-size: 0.85rem; color: #666; margin-top: 12px; }
    .controls-hint {
      width: 600px;
      margin-top: 10px;
      font-size: 0.75rem;
      color: #555;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SWARM CONTROL</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="playerUnits">50</span> units | Kills: <span id="score">0</span></div>
    <div><span id="timer" style="color:#aaa;">3:00</span></div>
    <div>AI: <span id="aiUnits">50</span> units | Kills: <span id="aiScore">0</span></div>
  </div>
  <div class="info-bar">
    <div id="playerNodes">Nodes: 0</div>
    <div id="status">Click to start</div>
    <div id="aiNodes">Nodes: 0</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">SWARM CONTROL</h2>
      <p id="overlayText">Direct your swarm. Destroy the enemy hive.</p>
      <p class="sub">Click anywhere to start</p>
      <p class="sub">Click = move swarm | Drag = split swarm | Scroll = zoom</p>
    </div>
  </div>
  <div class="controls-hint">CLICK to direct swarm | DRAG to split swarm toward point | SCROLL to zoom | Capture nodes for reinforcements</div>

  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const playerUnitsEl = document.getElementById('playerUnits');
    const aiUnitsEl = document.getElementById('aiUnits');
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const timerEl = document.getElementById('timer');
    const playerNodesEl = document.getElementById('playerNodes');
    const aiNodesEl = document.getElementById('aiNodes');
    const statusEl = document.getElementById('status');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'idle';
    let score = 0;

    // Zoom / camera
    let zoomLevel = 1;
    const WORLD_W = 900, WORLD_H = 600;
    let camX = (WORLD_W - W) / 2, camY = (WORLD_H - H) / 2;

    // Game clock
    const MATCH_DURATION = 180;
    let timeLeft = MATCH_DURATION;
    let lastTimeTick = 0;

    // Drag state
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragEndX = 0, dragEndY = 0;
    const DRAG_THRESHOLD = 15;

    // Entities
    let playerUnits = [];
    let aiUnitsArr = [];
    let resourceNodes = [];
    let playerHive = null;
    let aiHive = null;
    let particles = [];
    let playerKills = 0;
    let aiKills = 0;

    // Constants
    const NODE_SPAWN_INTERVAL = 120;
    const UNIT_SPEED = 1.6;
    const ATTACK_RANGE = 18;
    const ATTACK_DAMAGE = 0.35;
    const BOID_SEP = 8;
    const BOID_ALI = 25;
    const BOID_COH = 35;
    const MAX_UNITS = 150;

    // AI
    let aiTarget = null;
    let aiSplitTarget = null;
    let aiSplitRatio = 0;
    let aiDecisionTimer = 0;
    const AI_INTERVAL = 90;

    // Hive spawn (units trickle from hive)
    let playerHiveSpawn = 0;
    let aiHiveSpawn = 0;
    const HIVE_SPAWN_INTERVAL = 200;

    function createUnit(x, y, team) {
      return {
        x: x + (Math.random() - 0.5) * 20,
        y: y + (Math.random() - 0.5) * 20,
        vx: 0, vy: 0,
        team: team,
        hp: 1,
        targetX: x,
        targetY: y,
        assigned: 'main'
      };
    }

    function createHive(x, y, team) {
      return { x, y, team, hp: 200, maxHp: 200, radius: 18 };
    }

    function createResourceNode(x, y) {
      return {
        x, y,
        owner: 'neutral',
        captureProgress: 0,
        radius: 12,
        spawnTimer: 0
      };
    }

    function initGame() {
      playerUnits = [];
      aiUnitsArr = [];
      resourceNodes = [];
      particles = [];
      playerKills = 0;
      aiKills = 0;
      timeLeft = MATCH_DURATION;
      lastTimeTick = performance.now();
      zoomLevel = 1;
      camX = 0;
      camY = (WORLD_H - H) / 2;
      playerHiveSpawn = 0;
      aiHiveSpawn = 0;

      playerHive = createHive(80, WORLD_H / 2, 'player');
      aiHive = createHive(WORLD_W - 80, WORLD_H / 2, 'ai');

      for (let i = 0; i < 50; i++) {
        playerUnits.push(createUnit(playerHive.x, playerHive.y, 'player'));
        aiUnitsArr.push(createUnit(aiHive.x, aiHive.y, 'ai'));
      }

      const nodePositions = [
        { x: WORLD_W * 0.3, y: WORLD_H * 0.18 },
        { x: WORLD_W * 0.5, y: WORLD_H * 0.12 },
        { x: WORLD_W * 0.7, y: WORLD_H * 0.18 },
        { x: WORLD_W * 0.22, y: WORLD_H * 0.5 },
        { x: WORLD_W * 0.5, y: WORLD_H * 0.5 },
        { x: WORLD_W * 0.78, y: WORLD_H * 0.5 },
        { x: WORLD_W * 0.3, y: WORLD_H * 0.82 },
        { x: WORLD_W * 0.5, y: WORLD_H * 0.88 },
        { x: WORLD_W * 0.7, y: WORLD_H * 0.82 },
      ];
      for (const p of nodePositions) {
        resourceNodes.push(createResourceNode(p.x, p.y));
      }

      for (const u of playerUnits) { u.targetX = playerHive.x + 40; u.targetY = playerHive.y; }
      for (const u of aiUnitsArr) { u.targetX = aiHive.x - 40; u.targetY = aiHive.y; }

      aiTarget = { x: aiHive.x, y: aiHive.y };
      aiSplitTarget = null;
      aiSplitRatio = 0;
      aiDecisionTimer = 0;
    }

    function screenToWorld(sx, sy) {
      return {
        x: sx / zoomLevel + camX,
        y: sy / zoomLevel + camY
      };
    }

    // ===================== BOIDS + MOVEMENT =====================

    function updateUnits(units, enemies, enemyHive) {
      // Build spatial grid for performance
      const cellSize = 40;
      const gridW = Math.ceil(WORLD_W / cellSize);
      const gridH = Math.ceil(WORLD_H / cellSize);
      const grid = new Array(gridW * gridH);
      for (let i = 0; i < grid.length; i++) grid[i] = [];

      for (let i = 0; i < units.length; i++) {
        const u = units[i];
        const gx = Math.floor(u.x / cellSize);
        const gy = Math.floor(u.y / cellSize);
        if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
          grid[gy * gridW + gx].push(i);
        }
      }

      // Enemy grid
      const eGrid = new Array(gridW * gridH);
      for (let i = 0; i < eGrid.length; i++) eGrid[i] = [];
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        const gx = Math.floor(e.x / cellSize);
        const gy = Math.floor(e.y / cellSize);
        if (gx >= 0 && gx < gridW && gy >= 0 && gy < gridH) {
          eGrid[gy * gridW + gx].push(i);
        }
      }

      for (let i = 0; i < units.length; i++) {
        const u = units[i];
        if (u.hp <= 0) continue;

        let sepX = 0, sepY = 0;
        let aliX = 0, aliY = 0, aliCount = 0;
        let cohX = 0, cohY = 0, cohCount = 0;

        const gx = Math.floor(u.x / cellSize);
        const gy = Math.floor(u.y / cellSize);

        // Check neighboring cells
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = gx + dx, ny = gy + dy;
            if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
            const cell = grid[ny * gridW + nx];
            for (const j of cell) {
              if (i === j) continue;
              const o = units[j];
              const ddx = u.x - o.x, ddy = u.y - o.y;
              const dist2 = ddx * ddx + ddy * ddy;

              if (dist2 < BOID_SEP * BOID_SEP && dist2 > 0.01) {
                const dist = Math.sqrt(dist2);
                sepX += ddx / dist / dist * 2;
                sepY += ddy / dist / dist * 2;
              }
              if (dist2 < BOID_ALI * BOID_ALI) {
                aliX += o.vx; aliY += o.vy;
                aliCount++;
              }
              if (dist2 < BOID_COH * BOID_COH) {
                cohX += o.x; cohY += o.y;
                cohCount++;
              }
            }
          }
        }

        let fx = 0, fy = 0;

        // Separation
        fx += sepX * 1.5;
        fy += sepY * 1.5;

        // Alignment
        if (aliCount > 0) {
          fx += (aliX / aliCount) * 0.1;
          fy += (aliY / aliCount) * 0.1;
        }

        // Cohesion
        if (cohCount > 0) {
          fx += (cohX / cohCount - u.x) * 0.005;
          fy += (cohY / cohCount - u.y) * 0.005;
        }

        // Move toward target
        const tdx = u.targetX - u.x, tdy = u.targetY - u.y;
        const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
        if (tDist > 5) {
          fx += (tdx / tDist) * 0.8;
          fy += (tdy / tDist) * 0.8;
        }

        // Attack nearest enemy (using grid)
        let nearestEnemy = null;
        let nearestDist = ATTACK_RANGE;
        for (let dy2 = -1; dy2 <= 1; dy2++) {
          for (let dx2 = -1; dx2 <= 1; dx2++) {
            const nx = gx + dx2, ny = gy + dy2;
            if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH) continue;
            const cell = eGrid[ny * gridW + nx];
            for (const j of cell) {
              const e = enemies[j];
              if (e.hp <= 0) continue;
              const edx = e.x - u.x, edy = e.y - u.y;
              const eDist = Math.sqrt(edx * edx + edy * edy);
              if (eDist < nearestDist) {
                nearestDist = eDist;
                nearestEnemy = e;
              }
            }
          }
        }

        if (nearestEnemy) {
          nearestEnemy.hp -= ATTACK_DAMAGE;
          if (nearestEnemy.hp <= 0) {
            spawnParticle(nearestEnemy.x, nearestEnemy.y, u.team === 'player' ? '#8f0' : '#f44');
          }
          const edx = nearestEnemy.x - u.x, edy = nearestEnemy.y - u.y;
          const ed = Math.sqrt(edx * edx + edy * edy);
          if (ed > 0.1) { fx += (edx / ed) * 0.3; fy += (edy / ed) * 0.3; }
        }

        // Attack enemy hive
        if (enemyHive && enemyHive.hp > 0) {
          const hdx = enemyHive.x - u.x, hdy = enemyHive.y - u.y;
          const hDist = Math.sqrt(hdx * hdx + hdy * hdy);
          if (hDist < enemyHive.radius + 12) {
            enemyHive.hp -= 0.15;
            if (hDist > 2) { fx += (hdx / hDist) * 0.5; fy += (hdy / hDist) * 0.5; }
          }
        }

        // World boundaries
        if (u.x < 10) fx += 1;
        if (u.x > WORLD_W - 10) fx -= 1;
        if (u.y < 10) fy += 1;
        if (u.y > WORLD_H - 10) fy -= 1;

        // Apply
        u.vx = u.vx * 0.85 + fx * 0.15;
        u.vy = u.vy * 0.85 + fy * 0.15;

        const speed = Math.sqrt(u.vx * u.vx + u.vy * u.vy);
        if (speed > UNIT_SPEED) {
          u.vx = (u.vx / speed) * UNIT_SPEED;
          u.vy = (u.vy / speed) * UNIT_SPEED;
        }

        u.x += u.vx;
        u.y += u.vy;
        u.x = Math.max(2, Math.min(WORLD_W - 2, u.x));
        u.y = Math.max(2, Math.min(WORLD_H - 2, u.y));
      }

      // Remove dead
      for (let i = units.length - 1; i >= 0; i--) {
        if (units[i].hp <= 0) units.splice(i, 1);
      }
    }

    // ===================== RESOURCE NODES =====================

    function updateNodes() {
      for (const node of resourceNodes) {
        let playerNear = 0, aiNear = 0;
        const capRange2 = 35 * 35;

        for (const u of playerUnits) {
          const dx = u.x - node.x, dy = u.y - node.y;
          if (dx * dx + dy * dy < capRange2) playerNear++;
        }
        for (const u of aiUnitsArr) {
          const dx = u.x - node.x, dy = u.y - node.y;
          if (dx * dx + dy * dy < capRange2) aiNear++;
        }

        const capSpeed = 0.008;
        if (playerNear > aiNear && playerNear > 0) {
          node.captureProgress -= capSpeed * (playerNear - aiNear);
          if (node.captureProgress < -1) node.captureProgress = -1;
          if (node.captureProgress <= -0.99) node.owner = 'player';
          else if (node.owner === 'ai' && node.captureProgress < 0.5) node.owner = 'neutral';
        } else if (aiNear > playerNear && aiNear > 0) {
          node.captureProgress += capSpeed * (aiNear - playerNear);
          if (node.captureProgress > 1) node.captureProgress = 1;
          if (node.captureProgress >= 0.99) node.owner = 'ai';
          else if (node.owner === 'player' && node.captureProgress > -0.5) node.owner = 'neutral';
        } else {
          node.captureProgress *= 0.998;
        }

        if (node.owner !== 'neutral') {
          node.spawnTimer++;
          if (node.spawnTimer >= NODE_SPAWN_INTERVAL) {
            node.spawnTimer = 0;
            if (node.owner === 'player' && playerUnits.length < MAX_UNITS) {
              const u = createUnit(node.x, node.y, 'player');
              if (playerUnits.length > 0) {
                u.targetX = playerUnits[0].targetX;
                u.targetY = playerUnits[0].targetY;
              }
              playerUnits.push(u);
            } else if (node.owner === 'ai' && aiUnitsArr.length < MAX_UNITS) {
              const u = createUnit(node.x, node.y, 'ai');
              u.targetX = aiTarget ? aiTarget.x : aiHive.x;
              u.targetY = aiTarget ? aiTarget.y : aiHive.y;
              aiUnitsArr.push(u);
            }
          }
        }
      }
    }

    // ===================== AI (Potential Fields) =====================

    function distToCenter(units, x, y) {
      if (units.length === 0) return 9999;
      let cx = 0, cy = 0;
      for (const u of units) { cx += u.x; cy += u.y; }
      cx /= units.length; cy /= units.length;
      return Math.sqrt((cx - x) * (cx - x) + (cy - y) * (cy - y));
    }

    function updateAI() {
      aiDecisionTimer++;
      if (aiDecisionTimer < AI_INTERVAL) return;
      aiDecisionTimer = 0;

      const myCount = aiUnitsArr.length;
      const enemyCount = playerUnits.length;

      // Player swarm center
      let pcx = playerHive.x, pcy = playerHive.y;
      if (playerUnits.length > 0) {
        pcx = 0; pcy = 0;
        for (const u of playerUnits) { pcx += u.x; pcy += u.y; }
        pcx /= playerUnits.length; pcy /= playerUnits.length;
      }

      const myNodes = resourceNodes.filter(n => n.owner === 'ai').length;
      const enemyNodes = resourceNodes.filter(n => n.owner === 'player').length;
      const targetableNodes = resourceNodes.filter(n => n.owner !== 'ai');

      // Score candidates using potential fields
      let bestTarget = { x: aiHive.x, y: aiHive.y };
      let bestScore = -Infinity;

      // Candidate: attack player hive
      {
        const d = distToCenter(aiUnitsArr, playerHive.x, playerHive.y);
        let s = 0;
        s += (myCount > enemyCount * 1.2) ? 55 : 5;
        s += (playerHive.hp < 100) ? 40 : 0;
        s += (myCount > 80) ? 20 : 0;
        s -= d * 0.025;
        s += (timeLeft < 60) ? 30 : 0; // rush late game
        if (s > bestScore) { bestScore = s; bestTarget = { x: playerHive.x, y: playerHive.y }; }
      }

      // Candidate: defend own hive
      {
        const enemyDist = distToCenter(playerUnits, aiHive.x, aiHive.y);
        if (enemyDist < 150) {
          const s = 90 - enemyDist * 0.4;
          if (s > bestScore) { bestScore = s; bestTarget = { x: aiHive.x, y: aiHive.y }; }
        }
      }

      // Candidate: intercept player swarm
      {
        const d = distToCenter(aiUnitsArr, pcx, pcy);
        let s = (myCount > enemyCount * 1.1) ? 35 : 10;
        s -= d * 0.03;
        if (enemyCount > myCount * 0.8) s += 15; // engage if roughly equal
        if (s > bestScore) { bestScore = s; bestTarget = { x: pcx, y: pcy }; }
      }

      // Candidate: resource nodes
      for (const node of targetableNodes) {
        const d = distToCenter(aiUnitsArr, node.x, node.y);
        const pDist = distToCenter(playerUnits, node.x, node.y);
        let s = 25;
        s -= d * 0.04;
        s += pDist * 0.015;
        if (node.owner === 'player') s += 20;
        if (myNodes < 3) s += 18;
        if (myNodes === 0) s += 25;
        if (s > bestScore) { bestScore = s; bestTarget = { x: node.x, y: node.y }; }
      }

      aiTarget = bestTarget;

      // Split decision
      aiSplitTarget = null;
      aiSplitRatio = 0;

      if (myCount > 35) {
        let secondBest = null;
        let secondScore = -Infinity;

        for (const node of targetableNodes) {
          const d = distToCenter(aiUnitsArr, node.x, node.y);
          let s = 18 - d * 0.035;
          if (node.owner === 'player') s += 15;
          const dToMain = Math.sqrt((node.x - aiTarget.x) ** 2 + (node.y - aiTarget.y) ** 2);
          if (dToMain > 80 && s > secondScore) {
            secondScore = s;
            secondBest = { x: node.x, y: node.y };
          }
        }

        if (secondBest && myCount > 45) {
          aiSplitTarget = secondBest;
          aiSplitRatio = Math.min(0.35, 0.2 + (myCount - 45) * 0.005);
        }
      }

      // Assign targets
      if (aiSplitTarget && aiSplitRatio > 0) {
        const splitCount = Math.floor(aiUnitsArr.length * aiSplitRatio);
        const sorted = [...aiUnitsArr].sort((a, b) => {
          const da = (a.x - aiSplitTarget.x) ** 2 + (a.y - aiSplitTarget.y) ** 2;
          const db = (b.x - aiSplitTarget.x) ** 2 + (b.y - aiSplitTarget.y) ** 2;
          return da - db;
        });
        for (let i = 0; i < sorted.length; i++) {
          if (i < splitCount) {
            sorted[i].targetX = aiSplitTarget.x;
            sorted[i].targetY = aiSplitTarget.y;
            sorted[i].assigned = 'split';
          } else {
            sorted[i].targetX = aiTarget.x;
            sorted[i].targetY = aiTarget.y;
            sorted[i].assigned = 'main';
          }
        }
      } else {
        for (const u of aiUnitsArr) {
          u.targetX = aiTarget.x;
          u.targetY = aiTarget.y;
          u.assigned = 'main';
        }
      }
    }

    // ===================== PARTICLES =====================

    function spawnParticle(x, y, color) {
      for (let i = 0; i < 4; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 20 + Math.random() * 10,
          color
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // ===================== RENDERING =====================

    function drawWorld() {
      ctx.save();
      ctx.scale(zoomLevel, zoomLevel);
      ctx.translate(-camX, -camY);

      // Grid
      ctx.strokeStyle = 'rgba(136,255,0,0.035)';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= WORLD_W; x += 30) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_H); ctx.stroke();
      }
      for (let y = 0; y <= WORLD_H; y += 30) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_W, y); ctx.stroke();
      }

      // World border
      ctx.strokeStyle = 'rgba(136,255,0,0.15)';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, WORLD_W, WORLD_H);

      // Resource nodes
      for (const node of resourceNodes) drawNode(node);

      // Hives
      drawHive(playerHive, '#4af', 'YOU');
      drawHive(aiHive, '#f44', 'AI');

      // Units
      drawUnits(playerUnits, '#4af', '#29f');
      drawUnits(aiUnitsArr, '#f44', '#f66');

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
      }
      ctx.globalAlpha = 1;

      // Drag line
      if (isDragging && gameState === 'playing') {
        const s = screenToWorld(dragStartX, dragStartY);
        const e = screenToWorld(dragEndX, dragEndY);
        ctx.strokeStyle = 'rgba(68,170,255,0.5)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(e.x, e.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Split indicator circle
        ctx.beginPath();
        ctx.arc(e.x, e.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(68,170,255,0.4)';
        ctx.fill();

        // Show "SPLIT" label
        ctx.fillStyle = '#4af';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('SPLIT', e.x, e.y - 10);
      }

      ctx.restore();

      drawMinimap();
    }

    function drawNode(node) {
      const pulse = Math.sin(performance.now() * 0.003) * 0.15 + 0.85;
      let ringColor, fillColor, iconColor;

      if (node.owner === 'player') {
        ringColor = `rgba(68,170,255,${0.5 * pulse})`;
        fillColor = 'rgba(68,170,255,0.2)';
        iconColor = '#4af';
      } else if (node.owner === 'ai') {
        ringColor = `rgba(255,68,68,${0.5 * pulse})`;
        fillColor = 'rgba(255,68,68,0.2)';
        iconColor = '#f44';
      } else {
        ringColor = `rgba(136,255,0,${0.3 * pulse})`;
        fillColor = 'rgba(136,255,0,0.1)';
        iconColor = '#8f0';
      }

      // Ring
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.radius + 4, 0, Math.PI * 2);
      ctx.strokeStyle = ringColor;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Fill
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
      ctx.fillStyle = fillColor;
      ctx.fill();

      // Capture bar
      if (Math.abs(node.captureProgress) > 0.01) {
        const bw = 20;
        ctx.fillStyle = '#222';
        ctx.fillRect(node.x - bw / 2, node.y + node.radius + 4, bw, 3);
        if (node.captureProgress < 0) {
          ctx.fillStyle = '#4af';
          ctx.fillRect(node.x - bw / 2, node.y + node.radius + 4, bw * (-node.captureProgress), 3);
        } else {
          ctx.fillStyle = '#f44';
          ctx.fillRect(node.x - bw / 2, node.y + node.radius + 4, bw * node.captureProgress, 3);
        }
      }

      // Diamond icon
      ctx.strokeStyle = iconColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(node.x, node.y - 5);
      ctx.lineTo(node.x + 5, node.y);
      ctx.lineTo(node.x, node.y + 5);
      ctx.lineTo(node.x - 5, node.y);
      ctx.closePath();
      ctx.stroke();
    }

    function drawHive(hive, color, label) {
      if (hive.hp <= 0) {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(hive.x, hive.y, hive.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = '#444';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('DESTROYED', hive.x, hive.y + 3);
        return;
      }

      const pulse = Math.sin(performance.now() * 0.002) * 3;

      // Glow
      const grad = ctx.createRadialGradient(hive.x, hive.y, 0, hive.x, hive.y, hive.radius + 14 + pulse);
      if (color === '#4af') {
        grad.addColorStop(0, 'rgba(68,170,255,0.15)');
      } else {
        grad.addColorStop(0, 'rgba(255,68,68,0.15)');
      }
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.beginPath();
      ctx.arc(hive.x, hive.y, hive.radius + 14 + pulse, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();

      // Hex body
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = hive.x + Math.cos(angle) * hive.radius;
        const py = hive.y + Math.sin(angle) * hive.radius;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = color === '#4af' ? 'rgba(68,170,255,0.15)' : 'rgba(255,68,68,0.15)';
      ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Inner hex
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = hive.x + Math.cos(angle) * (hive.radius * 0.5);
        const py = hive.y + Math.sin(angle) * (hive.radius * 0.5);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      ctx.stroke();
      ctx.globalAlpha = 1;

      // HP bar
      const hpPct = hive.hp / hive.maxHp;
      const bw = 30;
      ctx.fillStyle = '#222';
      ctx.fillRect(hive.x - bw / 2, hive.y - hive.radius - 12, bw, 4);
      ctx.fillStyle = hpPct > 0.5 ? color : (hpPct > 0.25 ? '#fa0' : '#f33');
      ctx.fillRect(hive.x - bw / 2, hive.y - hive.radius - 12, bw * hpPct, 4);

      // Label
      ctx.fillStyle = color;
      ctx.font = 'bold 8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(label, hive.x, hive.y + 3);
    }

    function drawUnits(units, color, trailColor) {
      if (units.length === 0) return;

      // Trails
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = trailColor;
      for (const u of units) {
        const speed = u.vx * u.vx + u.vy * u.vy;
        if (speed > 0.25) {
          ctx.fillRect(u.x - u.vx * 2 - 0.5, u.y - u.vy * 2 - 0.5, 1, 1);
        }
      }
      ctx.globalAlpha = 1;

      // Dots
      ctx.fillStyle = color;
      for (const u of units) {
        ctx.fillRect(u.x - 1.5, u.y - 1.5, 3, 3);
      }

      // Swarm center ring
      let cx = 0, cy = 0;
      for (const u of units) { cx += u.x; cy += u.y; }
      cx /= units.length; cy /= units.length;

      ctx.beginPath();
      ctx.arc(cx, cy, 8, 0, Math.PI * 2);
      ctx.strokeStyle = color;
      ctx.lineWidth = 0.7;
      ctx.globalAlpha = 0.25;
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Count label at center
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.4;
      ctx.font = '7px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(units.length, cx, cy - 11);
      ctx.globalAlpha = 1;
    }

    function drawMinimap() {
      const mmW = 100, mmH = 67;
      const mmX = W - mmW - 8, mmY = H - mmH - 8;
      const sx = mmW / WORLD_W, sy = mmH / WORLD_H;

      ctx.fillStyle = 'rgba(10,10,20,0.85)';
      ctx.fillRect(mmX, mmY, mmW, mmH);
      ctx.strokeStyle = 'rgba(136,255,0,0.25)';
      ctx.lineWidth = 1;
      ctx.strokeRect(mmX, mmY, mmW, mmH);

      // Nodes
      for (const node of resourceNodes) {
        ctx.fillStyle = node.owner === 'player' ? '#4af' : node.owner === 'ai' ? '#f44' : '#8f0';
        ctx.globalAlpha = 0.7;
        ctx.fillRect(mmX + node.x * sx - 1, mmY + node.y * sy - 1, 3, 3);
      }
      ctx.globalAlpha = 1;

      // Hives
      if (playerHive.hp > 0) {
        ctx.fillStyle = '#4af';
        ctx.fillRect(mmX + playerHive.x * sx - 2, mmY + playerHive.y * sy - 2, 5, 5);
      }
      if (aiHive.hp > 0) {
        ctx.fillStyle = '#f44';
        ctx.fillRect(mmX + aiHive.x * sx - 2, mmY + aiHive.y * sy - 2, 5, 5);
      }

      // Units (sampled)
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#4af';
      for (let i = 0; i < playerUnits.length; i += 4) {
        ctx.fillRect(mmX + playerUnits[i].x * sx, mmY + playerUnits[i].y * sy, 1, 1);
      }
      ctx.fillStyle = '#f44';
      for (let i = 0; i < aiUnitsArr.length; i += 4) {
        ctx.fillRect(mmX + aiUnitsArr[i].x * sx, mmY + aiUnitsArr[i].y * sy, 1, 1);
      }
      ctx.globalAlpha = 1;

      // Viewport
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 0.7;
      ctx.strokeRect(
        mmX + camX * sx,
        mmY + camY * sy,
        (W / zoomLevel) * sx,
        (H / zoomLevel) * sy
      );
    }

    // ===================== GAME LOOP =====================

    function update() {
      if (gameState !== 'playing') return;

      // Timer
      const now = performance.now();
      if (now - lastTimeTick >= 1000) {
        lastTimeTick = now;
        timeLeft--;
        if (timeLeft <= 0) { endGame('time'); return; }
      }

      const pBefore = playerUnits.length;
      const aBefore = aiUnitsArr.length;

      updateUnits(playerUnits, aiUnitsArr, aiHive);
      updateUnits(aiUnitsArr, playerUnits, playerHive);

      aiKills += Math.max(0, pBefore - playerUnits.length);
      playerKills += Math.max(0, aBefore - aiUnitsArr.length);
      score = playerKills;

      updateNodes();
      updateAI();
      updateParticles();

      // Hive spawning (slow trickle)
      if (playerHive.hp > 0 && playerUnits.length < MAX_UNITS) {
        playerHiveSpawn++;
        if (playerHiveSpawn >= HIVE_SPAWN_INTERVAL) {
          playerHiveSpawn = 0;
          const u = createUnit(playerHive.x, playerHive.y, 'player');
          if (playerUnits.length > 0) {
            u.targetX = playerUnits[0].targetX;
            u.targetY = playerUnits[0].targetY;
          }
          playerUnits.push(u);
        }
      }
      if (aiHive.hp > 0 && aiUnitsArr.length < MAX_UNITS) {
        aiHiveSpawn++;
        if (aiHiveSpawn >= HIVE_SPAWN_INTERVAL) {
          aiHiveSpawn = 0;
          const u = createUnit(aiHive.x, aiHive.y, 'ai');
          u.targetX = aiTarget ? aiTarget.x : aiHive.x;
          u.targetY = aiTarget ? aiTarget.y : aiHive.y;
          aiUnitsArr.push(u);
        }
      }

      // Win conditions
      if (aiHive.hp <= 0) { endGame('player_hive'); return; }
      if (playerHive.hp <= 0) { endGame('ai_hive'); return; }
      if (playerUnits.length === 0 && playerHive.hp <= 0) { endGame('player_eliminated'); return; }
      if (aiUnitsArr.length === 0 && aiHive.hp <= 0) { endGame('ai_eliminated'); return; }

      // Camera follows player swarm
      if (playerUnits.length > 0) {
        let cx = 0, cy = 0;
        for (const u of playerUnits) { cx += u.x; cy += u.y; }
        cx /= playerUnits.length; cy /= playerUnits.length;
        const viewW = W / zoomLevel, viewH = H / zoomLevel;
        camX += (cx - viewW / 2 - camX) * 0.04;
        camY += (cy - viewH / 2 - camY) * 0.04;
      }

      // Clamp camera
      const viewW = W / zoomLevel, viewH = H / zoomLevel;
      camX = Math.max(0, Math.min(WORLD_W - viewW, camX));
      camY = Math.max(0, Math.min(WORLD_H - viewH, camY));

      // Update HUD
      playerUnitsEl.textContent = playerUnits.length;
      aiUnitsEl.textContent = aiUnitsArr.length;
      scoreEl.textContent = playerKills;
      aiScoreEl.textContent = aiKills;
      const mins = Math.floor(timeLeft / 60);
      const secs = timeLeft % 60;
      timerEl.textContent = mins + ':' + String(secs).padStart(2, '0');
      timerEl.style.color = timeLeft <= 30 ? '#f44' : '#aaa';

      const pN = resourceNodes.filter(n => n.owner === 'player').length;
      const aN = resourceNodes.filter(n => n.owner === 'ai').length;
      playerNodesEl.textContent = 'Nodes: ' + pN;
      aiNodesEl.textContent = 'Nodes: ' + aN;

      if (timeLeft <= 30) statusEl.textContent = 'FINAL SECONDS!';
      else if (playerUnits.length > aiUnitsArr.length * 1.5) statusEl.textContent = 'ADVANTAGE!';
      else if (aiUnitsArr.length > playerUnits.length * 1.5) statusEl.textContent = 'OUTNUMBERED!';
      else statusEl.textContent = 'Battle raging...';
    }

    function endGame(reason) {
      gameState = 'gameover';
      overlay.style.display = 'flex';

      let title, text;
      if (reason === 'player_hive') {
        title = 'VICTORY!';
        text = 'Enemy hive destroyed! Kills: ' + playerKills;
      } else if (reason === 'ai_hive') {
        title = 'DEFEAT';
        text = 'Your hive was destroyed. Kills: ' + playerKills;
      } else if (reason === 'ai_eliminated') {
        title = 'VICTORY!';
        text = 'Enemy swarm wiped out! Kills: ' + playerKills;
      } else if (reason === 'player_eliminated') {
        title = 'DEFEAT';
        text = 'Your swarm was wiped out. Kills: ' + playerKills;
      } else {
        // time
        if (playerKills > aiKills) {
          title = 'VICTORY!';
          text = 'Time up! You: ' + playerKills + ' kills vs AI: ' + aiKills + ' kills';
        } else if (aiKills > playerKills) {
          title = 'DEFEAT';
          text = 'Time up! You: ' + playerKills + ' kills vs AI: ' + aiKills + ' kills';
        } else {
          title = 'DRAW';
          text = 'Time up! Both scored ' + playerKills + ' kills';
        }
      }

      overlayTitle.textContent = title;
      overlayText.textContent = text;
      const subs = overlay.querySelectorAll('.sub');
      if (subs[0]) subs[0].textContent = 'Click to play again';
      if (subs[1]) subs[1].textContent = '';
      score = playerKills;
    }

    function render() {
      ctx.fillStyle = '#0a0a14';
      ctx.fillRect(0, 0, W, H);
      drawWorld();
    }

    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    // ===================== INPUT =====================

    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'idle' || gameState === 'gameover') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      dragStartX = (e.clientX - rect.left) * (W / rect.width);
      dragStartY = (e.clientY - rect.top) * (H / rect.height);
      dragEndX = dragStartX;
      dragEndY = dragStartY;
      isDragging = true;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      dragEndX = (e.clientX - rect.left) * (W / rect.width);
      dragEndY = (e.clientY - rect.top) * (H / rect.height);
    });

    canvas.addEventListener('mouseup', (e) => {
      if (gameState !== 'playing') return;
      if (!isDragging) return;
      isDragging = false;

      const rect = canvas.getBoundingClientRect();
      const endX = (e.clientX - rect.left) * (W / rect.width);
      const endY = (e.clientY - rect.top) * (H / rect.height);

      const dx = endX - dragStartX;
      const dy = endY - dragStartY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < DRAG_THRESHOLD) {
        // Click: move entire swarm
        const world = screenToWorld(endX, endY);
        for (const u of playerUnits) {
          u.targetX = world.x;
          u.targetY = world.y;
        }
      } else {
        // Drag: split swarm
        const endWorld = screenToWorld(endX, endY);
        const startWorld = screenToWorld(dragStartX, dragStartY);

        // Units closer to drag start move to drag end; rest stay
        const sorted = [...playerUnits].sort((a, b) => {
          const da = (a.x - startWorld.x) ** 2 + (a.y - startWorld.y) ** 2;
          const db = (b.x - startWorld.x) ** 2 + (b.y - startWorld.y) ** 2;
          return da - db;
        });

        const splitCount = Math.max(1, Math.floor(sorted.length * 0.5));
        for (let i = 0; i < splitCount; i++) {
          sorted[i].targetX = endWorld.x;
          sorted[i].targetY = endWorld.y;
        }
      }
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldZoom = zoomLevel;

      if (e.deltaY < 0) zoomLevel = Math.min(2.0, zoomLevel + 0.1);
      else zoomLevel = Math.max(0.5, zoomLevel - 0.1);

      // Zoom toward mouse
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      const worldX = mx / oldZoom + camX;
      const worldY = my / oldZoom + camY;
      camX = worldX - mx / zoomLevel;
      camY = worldY - my / zoomLevel;

      const viewW = W / zoomLevel, viewH = H / zoomLevel;
      camX = Math.max(0, Math.min(WORLD_W - viewW, camX));
      camY = Math.max(0, Math.min(WORLD_H - viewH, camY));
    }, { passive: false });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
        e.preventDefault();
      }
    });

    // ===================== INIT =====================

    initGame();
    gameLoop();

    // Recorder
    if (typeof GameRecorder !== 'undefined') {
      try { const rec = new GameRecorder('swarm-control', { fps: 2 }); rec.start(); } catch(e) {}
    }
  </script>
</body>
</html>

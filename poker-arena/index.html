<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Poker Arena</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #c9a84c; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(201, 168, 76, 0.5); }
    h1 { color: #c9a84c; font-size: 2rem; text-shadow: 0 0 15px rgba(201, 168, 76, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #c9a84c; }
    canvas {
      border: 2px solid #c9a84c;
      box-shadow: 0 0 20px rgba(201, 168, 76, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #c9a84c;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>POKER ARENA</h1>
  </div>
  <div class="score-bar">
    <div>Chips: $<span id="score">1000</span></div>
    <div>Best: $<span id="best">1000</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">POKER ARENA</h2>
      <p id="overlayText">Click to Play</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 1000, gameState;

    // Theme
    const GOLD = '#c9a84c';
    const GOLD_DIM = '#8a7030';
    const FELT = '#1b5e20';
    const FELT_DARK = '#0d3b12';
    const CARD_WHITE = '#f5f0e8';
    const CARD_BACK = '#2244aa';

    // Suits
    const SUITS = ['hearts','diamonds','clubs','spades'];
    const SUIT_SYMBOLS = {hearts:'\u2665', diamonds:'\u2666', clubs:'\u2663', spades:'\u2660'};
    const SUIT_COLORS = {hearts:'#d42', diamonds:'#d42', clubs:'#222', spades:'#222'};
    const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    const RANK_VALUES = {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14};

    // Card dimensions
    const CW = 40, CH = 56;

    // AI personalities
    const PERSONALITIES = [
      {name:'Ace', style:'tight-aggressive', color:'#e55', foldThresh:0.45, raiseThresh:0.7, bluffRate:0.08, aggressionMult:1.4},
      {name:'Blaze', style:'loose-aggressive', color:'#e93', foldThresh:0.25, raiseThresh:0.5, bluffRate:0.2, aggressionMult:1.8},
      {name:'Chill', style:'tight-passive', color:'#5ae', foldThresh:0.5, raiseThresh:0.85, bluffRate:0.03, aggressionMult:0.6},
      {name:'Dice', style:'loose-passive', color:'#9c5', foldThresh:0.3, raiseThresh:0.8, bluffRate:0.05, aggressionMult:0.7},
      {name:'Echo', style:'bluffer', color:'#c6e', foldThresh:0.35, raiseThresh:0.55, bluffRate:0.35, aggressionMult:1.5},
    ];

    // Game state
    let deck, communityCards, pot;
    let players, dealerIdx, currentPlayerIdx, humanIdx;
    let phase; // 'preflop','flop','turn','river','showdown'
    let currentBet, minRaise;
    let smallBlind, bigBlind;
    let actionButtons, raiseSlider;
    let animTimer;
    let handNumber;
    let revealedHands;
    let winnerMessage;
    let winnerDisplayTimer;
    let messageLog;
    let actedThisRound;
    let bettingRoundStarter;
    let waitingForHuman;

    function createDeck() {
      let d = [];
      for (let s of SUITS) for (let r of RANKS) d.push({suit:s, rank:r, value:RANK_VALUES[r]});
      return shuffle(d);
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Hand evaluation
    function evaluateHand(holeCards, community) {
      let all = holeCards.concat(community);
      if (all.length < 5) return {rank:0, name:'Incomplete', kickers:[]};
      let bestHand = null;
      let combos = getCombinations(all, 5);
      for (let combo of combos) {
        let ev = evaluate5(combo);
        if (!bestHand || compareHands(ev, bestHand) > 0) bestHand = ev;
      }
      return bestHand;
    }

    function getCombinations(arr, k) {
      if (k === 0) return [[]];
      if (arr.length === 0) return [];
      let result = [];
      let first = arr[0];
      let rest = arr.slice(1);
      let withFirst = getCombinations(rest, k - 1);
      for (let c of withFirst) result.push([first, ...c]);
      let withoutFirst = getCombinations(rest, k);
      for (let c of withoutFirst) result.push(c);
      return result;
    }

    function evaluate5(cards) {
      let values = cards.map(c => c.value).sort((a, b) => b - a);
      let suits = cards.map(c => c.suit);
      let isFlush = suits.every(s => s === suits[0]);
      let isStraight = false;
      let straightHigh = values[0];
      let uniqVals = [...new Set(values)].sort((a, b) => b - a);
      if (uniqVals.length === 5) {
        if (uniqVals[0] - uniqVals[4] === 4) {
          isStraight = true;
          straightHigh = uniqVals[0];
        }
        if (uniqVals[0] === 14 && uniqVals[1] === 5 && uniqVals[2] === 4 && uniqVals[3] === 3 && uniqVals[4] === 2) {
          isStraight = true;
          straightHigh = 5;
        }
      }
      let counts = {};
      for (let v of values) counts[v] = (counts[v] || 0) + 1;
      let groups = Object.entries(counts).map(([v, c]) => ({value: parseInt(v), count: c}));
      groups.sort((a, b) => b.count - a.count || b.value - a.value);

      if (isFlush && isStraight && straightHigh === 14) return {rank: 9, name:'Royal Flush', kickers:[14]};
      if (isFlush && isStraight) return {rank: 8, name:'Straight Flush', kickers:[straightHigh]};
      if (groups[0].count === 4) return {rank: 7, name:'Four of a Kind', kickers:[groups[0].value, groups[1].value]};
      if (groups[0].count === 3 && groups[1].count === 2) return {rank: 6, name:'Full House', kickers:[groups[0].value, groups[1].value]};
      if (isFlush) return {rank: 5, name:'Flush', kickers: values};
      if (isStraight) return {rank: 4, name:'Straight', kickers:[straightHigh]};
      if (groups[0].count === 3) return {rank: 3, name:'Three of a Kind', kickers:[groups[0].value, ...groups.slice(1).map(g=>g.value)]};
      if (groups[0].count === 2 && groups[1].count === 2) {
        let pairs = [groups[0].value, groups[1].value].sort((a,b)=>b-a);
        return {rank: 2, name:'Two Pair', kickers:[...pairs, groups[2].value]};
      }
      if (groups[0].count === 2) return {rank: 1, name:'Pair', kickers:[groups[0].value, ...groups.slice(1).map(g=>g.value)]};
      return {rank: 0, name:'High Card', kickers: values};
    }

    function compareHands(a, b) {
      if (a.rank !== b.rank) return a.rank - b.rank;
      for (let i = 0; i < Math.min(a.kickers.length, b.kickers.length); i++) {
        if (a.kickers[i] !== b.kickers[i]) return a.kickers[i] - b.kickers[i];
      }
      return 0;
    }

    function estimateHandStrength(holeCards, community) {
      if (community.length === 0) {
        let v1 = holeCards[0].value, v2 = holeCards[1].value;
        let suited = holeCards[0].suit === holeCards[1].suit;
        let pair = v1 === v2;
        let high = Math.max(v1, v2), low = Math.min(v1, v2);
        let strength = (high + low) / 28;
        if (pair) strength += 0.3;
        if (suited) strength += 0.06;
        if (high - low <= 2 && !pair) strength += 0.04;
        if (high >= 12) strength += 0.08;
        if (high === 14) strength += 0.05;
        return Math.min(1, Math.max(0, strength));
      }
      let hand = evaluateHand(holeCards, community);
      let base = hand.rank / 9;
      let kickerBonus = (hand.kickers[0] || 0) / 14 * 0.08;
      return Math.min(1, base + kickerBonus + 0.15);
    }

    function getPlayerPosition(idx, total) {
      if (idx === humanIdx) {
        return {x: W / 2, y: H - 70};
      }
      let otherIdx = 0;
      let otherCount = total - 1;
      for (let i = 0; i < total; i++) {
        if (i === humanIdx) continue;
        if (i === idx) break;
        otherIdx++;
      }
      let angle = Math.PI + (Math.PI * (otherIdx + 1)) / (otherCount + 1);
      let cx = W / 2, cy = H / 2 - 15;
      let rx = 230, ry = 135;
      return {
        x: cx + rx * Math.cos(angle),
        y: cy + ry * Math.sin(angle)
      };
    }

    function init() {
      score = 1000;
      scoreEl.textContent = '1000';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'POKER ARENA';
      overlayText.textContent = 'Click to Play';
      handNumber = 0;
      messageLog = [];
      drawWaiting();
    }

    function drawWaiting() {
      ctx.fillStyle = '#0d1520';
      ctx.fillRect(0, 0, W, H);
      drawTable();
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      humanIdx = 0;
      players = [{
        name: 'You', chips: 1000, holeCards: [], folded: false, allIn: false,
        currentBet: 0, isHuman: true, personality: null, color: GOLD, seatIdx: 0
      }];
      let perms = shuffle([...PERSONALITIES]);
      for (let i = 0; i < 4; i++) {
        players.push({
          name: perms[i].name, chips: 1000, holeCards: [], folded: false, allIn: false,
          currentBet: 0, isHuman: false, personality: perms[i], color: perms[i].color, seatIdx: i + 1
        });
      }
      dealerIdx = Math.floor(Math.random() * players.length);
      smallBlind = 10;
      bigBlind = 20;
      handNumber = 0;
      startNewHand();
    }

    function startNewHand() {
      if (animTimer) { clearTimeout(animTimer); animTimer = null; }
      handNumber++;
      if (handNumber > 1 && (handNumber - 1) % 8 === 0) {
        smallBlind = Math.min(smallBlind * 2, 200);
        bigBlind = smallBlind * 2;
      }
      players = players.filter(p => p.chips > 0);
      let humanAlive = players.find(p => p.isHuman);
      if (!humanAlive) { endGame(false); return; }
      if (players.length === 1) { endGame(true); return; }

      deck = createDeck();
      communityCards = [];
      pot = 0;
      currentBet = 0;
      minRaise = bigBlind;
      revealedHands = false;
      winnerMessage = '';
      winnerDisplayTimer = 0;
      messageLog = [];
      actedThisRound = new Set();
      waitingForHuman = false;
      actionButtons = [];

      for (let p of players) {
        p.holeCards = [];
        p.folded = false;
        p.allIn = false;
        p.currentBet = 0;
      }

      dealerIdx = (dealerIdx + 1) % players.length;
      for (let i = 0; i < 2; i++) {
        for (let p of players) p.holeCards.push(deck.pop());
      }

      let sbIdx = (dealerIdx + 1) % players.length;
      let bbIdx = (dealerIdx + 2) % players.length;
      postBlind(players[sbIdx], smallBlind);
      postBlind(players[bbIdx], bigBlind);
      currentBet = bigBlind;

      phase = 'preflop';
      currentPlayerIdx = (bbIdx + 1) % players.length;
      bettingRoundStarter = currentPlayerIdx;

      updateScore();
      processCurrentPlayer();
    }

    function postBlind(player, amount) {
      let actual = Math.min(amount, player.chips);
      player.chips -= actual;
      player.currentBet = actual;
      pot += actual;
      if (player.chips === 0) player.allIn = true;
    }

    function getActivePlayers() { return players.filter(p => !p.folded); }
    function getActiveCanAct() { return players.filter(p => !p.folded && !p.allIn); }

    function processCurrentPlayer() {
      if (gameState !== 'playing') return;
      // Skip folded/all-in
      let loops = 0;
      while (loops < players.length && (players[currentPlayerIdx].folded || players[currentPlayerIdx].allIn)) {
        currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
        loops++;
      }
      if (loops >= players.length) { advancePhase(); return; }

      // Check if only one non-folded
      let nonFolded = getActivePlayers();
      if (nonFolded.length <= 1) {
        if (nonFolded.length === 1) awardPot([nonFolded[0]]);
        winnerMessage = (nonFolded.length === 1 ? nonFolded[0].name : '???') + ' wins $' + pot;
        winnerDisplayTimer = Date.now();
        draw();
        animTimer = setTimeout(() => startNewHand(), 2500);
        return;
      }

      // Check if betting round is over
      let canAct = getActiveCanAct();
      let allMatched = canAct.every(p => p.currentBet === currentBet);
      if (allMatched && actedThisRound.size > 0 && canAct.every(p => actedThisRound.has(players.indexOf(p)))) {
        advancePhase();
        return;
      }

      if (players[currentPlayerIdx].isHuman) {
        waitingForHuman = true;
        setupActionButtons();
        draw();
      } else {
        waitingForHuman = false;
        actionButtons = [];
        draw();
        animTimer = setTimeout(() => doAIAction(), 500 + Math.random() * 700);
      }
    }

    function setupActionButtons() {
      let human = players[humanIdx];
      if (!human || human.folded || human.allIn) { actionButtons = []; return; }
      let toCall = currentBet - human.currentBet;
      actionButtons = [];

      actionButtons.push({label:'FOLD', x:65, y:H-18, w:70, h:28, action:'fold'});
      if (toCall <= 0) {
        actionButtons.push({label:'CHECK', x:155, y:H-18, w:70, h:28, action:'check'});
      } else {
        let callAmt = Math.min(toCall, human.chips);
        actionButtons.push({label:'CALL $'+callAmt, x:160, y:H-18, w:90, h:28, action:'call'});
      }
      if (human.chips > toCall) {
        actionButtons.push({label:'RAISE', x:270, y:H-18, w:70, h:28, action:'raise'});
        actionButtons.push({label:'ALL IN', x:360, y:H-18, w:80, h:28, action:'allin'});
      }
      raiseSlider = {
        x: 430, y: H - 30, w: 140, h: 20,
        min: Math.max(currentBet + minRaise, bigBlind),
        max: human.chips + human.currentBet,
        value: Math.max(currentBet + minRaise, bigBlind)
      };
      if (raiseSlider.min > raiseSlider.max) raiseSlider.min = raiseSlider.max;
      if (raiseSlider.value > raiseSlider.max) raiseSlider.value = raiseSlider.max;
    }

    function playerAction(action, amount) {
      let player = players[currentPlayerIdx];
      if (!player || player.folded || player.allIn) { nextPlayer(); return; }

      switch(action) {
        case 'fold':
          player.folded = true;
          addLog(player.name + ' folds');
          break;
        case 'check':
          addLog(player.name + ' checks');
          break;
        case 'call': {
          let toCall = Math.min(currentBet - player.currentBet, player.chips);
          player.chips -= toCall;
          player.currentBet += toCall;
          pot += toCall;
          if (player.chips === 0) player.allIn = true;
          addLog(player.name + ' calls $' + toCall);
          break;
        }
        case 'raise': {
          let raiseTotal = amount || (raiseSlider ? raiseSlider.value : currentBet + minRaise);
          raiseTotal = Math.max(raiseTotal, currentBet + minRaise);
          raiseTotal = Math.min(raiseTotal, player.chips + player.currentBet);
          let cost = raiseTotal - player.currentBet;
          cost = Math.min(cost, player.chips);
          player.chips -= cost;
          player.currentBet += cost;
          pot += cost;
          minRaise = Math.max(minRaise, player.currentBet - currentBet);
          currentBet = player.currentBet;
          if (player.chips === 0) player.allIn = true;
          // Reset acted set since there's a new raise
          actedThisRound = new Set();
          addLog(player.name + ' raises to $' + currentBet);
          break;
        }
        case 'allin': {
          let allInAmt = player.chips;
          player.currentBet += allInAmt;
          pot += allInAmt;
          player.chips = 0;
          player.allIn = true;
          if (player.currentBet > currentBet) {
            minRaise = Math.max(minRaise, player.currentBet - currentBet);
            currentBet = player.currentBet;
            actedThisRound = new Set();
          }
          addLog(player.name + ' ALL IN ($' + player.currentBet + ')');
          break;
        }
      }

      actedThisRound.add(currentPlayerIdx);
      waitingForHuman = false;
      actionButtons = [];
      updateScore();
      nextPlayer();
    }

    function nextPlayer() {
      currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
      processCurrentPlayer();
    }

    function advancePhase() {
      actedThisRound = new Set();
      for (let p of players) p.currentBet = 0;
      currentBet = 0;
      minRaise = bigBlind;

      let canAct = getActiveCanAct();
      let nonFolded = getActivePlayers();

      switch(phase) {
        case 'preflop':
          phase = 'flop';
          communityCards.push(deck.pop(), deck.pop(), deck.pop());
          break;
        case 'flop':
          phase = 'turn';
          communityCards.push(deck.pop());
          break;
        case 'turn':
          phase = 'river';
          communityCards.push(deck.pop());
          break;
        case 'river':
          phase = 'showdown';
          doShowdown();
          return;
      }

      if (canAct.length <= 1) {
        // All but one are all-in or folded, keep dealing
        draw();
        animTimer = setTimeout(() => advancePhase(), 700);
        return;
      }

      // First to act post-flop: first active player after dealer
      currentPlayerIdx = (dealerIdx + 1) % players.length;
      draw();
      processCurrentPlayer();
    }

    function doShowdown() {
      revealedHands = true;
      let nonFolded = getActivePlayers();
      let results = nonFolded.map(p => ({
        player: p,
        hand: evaluateHand(p.holeCards, communityCards)
      }));
      results.sort((a, b) => compareHands(b.hand, a.hand));
      let winners = [results[0]];
      for (let i = 1; i < results.length; i++) {
        if (compareHands(results[i].hand, results[0].hand) === 0) winners.push(results[i]);
        else break;
      }
      let winnerPlayers = winners.map(w => w.player);
      awardPot(winnerPlayers);
      let winNames = winnerPlayers.map(w => w.name).join(' & ');
      winnerMessage = winNames + ' wins with ' + winners[0].hand.name + '!';
      winnerDisplayTimer = Date.now();
      updateScore();
      draw();
      animTimer = setTimeout(() => startNewHand(), 3500);
    }

    function awardPot(winners) {
      let share = Math.floor(pot / winners.length);
      let remainder = pot - share * winners.length;
      for (let i = 0; i < winners.length; i++) {
        winners[i].chips += share + (i === 0 ? remainder : 0);
      }
    }

    function doAIAction() {
      if (gameState !== 'playing') return;
      let player = players[currentPlayerIdx];
      if (!player || player.folded || player.allIn || player.isHuman) { nextPlayer(); return; }

      let p = player.personality;
      let strength = estimateHandStrength(player.holeCards, communityCards);
      let toCall = currentBet - player.currentBet;

      let adjustedStrength = strength;
      if (Math.random() < p.bluffRate) {
        adjustedStrength = 0.65 + Math.random() * 0.35;
      }

      if (toCall > 0) {
        if (adjustedStrength < p.foldThresh && toCall > bigBlind * 2) {
          playerAction('fold');
        } else if (adjustedStrength > p.raiseThresh && player.chips > toCall * 2) {
          let raiseMult = 2 + Math.floor(adjustedStrength * 3 * p.aggressionMult);
          let raiseAmt = Math.min(currentBet * raiseMult, player.chips + player.currentBet);
          raiseAmt = Math.max(raiseAmt, currentBet + minRaise);
          if (raiseAmt >= player.chips + player.currentBet) {
            playerAction('allin');
          } else {
            playerAction('raise', raiseAmt);
          }
        } else if (adjustedStrength >= p.foldThresh - 0.1 || toCall <= bigBlind) {
          playerAction('call');
        } else {
          playerAction('fold');
        }
      } else {
        if (adjustedStrength > p.raiseThresh) {
          let raiseAmt = bigBlind * (2 + Math.floor(adjustedStrength * 4 * p.aggressionMult));
          raiseAmt = Math.max(raiseAmt, currentBet + minRaise);
          raiseAmt = Math.min(raiseAmt, player.chips + player.currentBet);
          if (raiseAmt >= player.chips) {
            playerAction('allin');
          } else {
            playerAction('raise', raiseAmt);
          }
        } else {
          playerAction('check');
        }
      }
    }

    function addLog(msg) {
      messageLog.unshift(msg);
      if (messageLog.length > 4) messageLog.pop();
    }

    function updateScore() {
      let human = players.find(p => p.isHuman);
      if (human) {
        score = human.chips;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
      }
    }

    function endGame(won) {
      if (animTimer) { clearTimeout(animTimer); animTimer = null; }
      gameState = 'over';
      overlay.style.display = 'flex';
      if (won) {
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = 'Final chips: $' + score + ' -- Click to play again';
      } else {
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = 'Score: $' + score + ' -- Click to play again';
      }
    }

    // === DRAWING ===
    function draw() {
      ctx.fillStyle = '#0d1520';
      ctx.fillRect(0, 0, W, H);
      drawTable();
      if (gameState !== 'playing' && gameState !== 'over') return;
      if (!players || players.length === 0) return;

      drawCommunityCards();
      drawPot();
      for (let i = 0; i < players.length; i++) drawPlayer(i);
      if (waitingForHuman && phase !== 'showdown') drawActionButtons();
      drawMessageLog();
      if (winnerMessage && winnerDisplayTimer) drawWinnerBanner();
      drawPhaseIndicator();

      ctx.fillStyle = '#556';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Hand #' + handNumber + '  Blinds $' + smallBlind + '/$' + bigBlind, 8, 14);
    }

    function drawTable() {
      let cx = W / 2, cy = H / 2 - 15;
      let rx = 255, ry = 148;

      ctx.save();
      // Outer rim
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx + 8, ry + 8, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#2a1a08';
      ctx.shadowColor = 'rgba(201,168,76,0.15)';
      ctx.shadowBlur = 25;
      ctx.fill();
      ctx.restore();

      // Wood rim
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx + 5, ry + 5, 0, 0, Math.PI * 2);
      let rimGrad = ctx.createRadialGradient(cx, cy - 40, 30, cx, cy, rx + 5);
      rimGrad.addColorStop(0, '#5a3a18');
      rimGrad.addColorStop(1, '#3a2008');
      ctx.fillStyle = rimGrad;
      ctx.fill();
      ctx.restore();

      // Felt
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      let grad = ctx.createRadialGradient(cx, cy - 30, 20, cx, cy, rx);
      grad.addColorStop(0, '#2d8a2d');
      grad.addColorStop(0.7, '#1b6e1b');
      grad.addColorStop(1, '#145a14');
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.restore();

      // Felt texture lines
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      ctx.clip();
      ctx.strokeStyle = 'rgba(0,0,0,0.04)';
      ctx.lineWidth = 1;
      for (let i = -ry; i < ry; i += 6) {
        ctx.beginPath();
        ctx.moveTo(cx - rx, cy + i);
        ctx.lineTo(cx + rx, cy + i);
        ctx.stroke();
      }
      ctx.restore();

      // Gold trim
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx + 1, ry + 1, 0, 0, Math.PI * 2);
      ctx.strokeStyle = GOLD_DIM;
      ctx.lineWidth = 1.5;
      ctx.shadowColor = GOLD;
      ctx.shadowBlur = 6;
      ctx.stroke();
      ctx.restore();
    }

    function drawCard(x, y, card, faceUp, small) {
      let w = small ? 30 : CW;
      let h = small ? 42 : CH;
      ctx.save();
      if (faceUp) {
        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetY = 2;
        ctx.fillStyle = CARD_WHITE;
        roundRect(x, y, w, h, 3, true, false);
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        // Thin border
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 0.5;
        roundRect(x, y, w, h, 3, false, true);

        let color = SUIT_COLORS[card.suit];
        let sym = SUIT_SYMBOLS[card.suit];

        // Top-left rank
        ctx.fillStyle = color;
        ctx.font = 'bold ' + (small ? '10' : '12') + 'px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(card.rank, x + 2, y + (small ? 11 : 13));

        // Top-left mini suit
        ctx.font = (small ? '8' : '10') + 'px serif';
        ctx.fillText(sym, x + 2, y + (small ? 19 : 22));

        // Center suit large
        ctx.font = (small ? '16' : '22') + 'px serif';
        ctx.textAlign = 'center';
        ctx.fillText(sym, x + w/2, y + h/2 + (small ? 6 : 8));

        // Bottom-right rank (upside down appearance)
        ctx.font = (small ? '9' : '10') + 'px Courier New';
        ctx.textAlign = 'right';
        ctx.fillText(card.rank, x + w - 2, y + h - (small ? 3 : 4));
      } else {
        // Card back
        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.shadowBlur = 4;
        ctx.fillStyle = '#1a3a8a';
        roundRect(x, y, w, h, 3, true, false);
        ctx.shadowBlur = 0;

        // Inner border
        ctx.strokeStyle = '#2a4aaa';
        ctx.lineWidth = 1;
        let m = small ? 2 : 3;
        roundRect(x + m, y + m, w - m*2, h - m*2, 2, false, true);

        // Cross-hatch pattern
        ctx.strokeStyle = 'rgba(100,140,220,0.3)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        for (let i = 0; i < w + h; i += (small ? 4 : 5)) {
          ctx.moveTo(x + m + i, y + m);
          ctx.lineTo(x + m, y + m + i);
          ctx.moveTo(x + w - m - i, y + m);
          ctx.lineTo(x + w - m, y + m + i);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    function roundRect(x, y, w, h, r, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawCommunityCards() {
      let startX = W/2 - (5 * (CW + 6)) / 2 + 3;
      let y = H/2 - CH/2 - 15;
      for (let i = 0; i < 5; i++) {
        let x = startX + i * (CW + 6);
        if (i < communityCards.length) {
          drawCard(x, y, communityCards[i], true, false);
        } else {
          ctx.strokeStyle = 'rgba(201, 168, 76, 0.12)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          roundRect(x, y, CW, CH, 3, false, true);
          ctx.setLineDash([]);
        }
      }
    }

    function drawPot() {
      if (pot <= 0) return;
      ctx.save();
      ctx.font = 'bold 15px Courier New';
      ctx.textAlign = 'center';
      ctx.fillStyle = GOLD;
      ctx.shadowColor = GOLD;
      ctx.shadowBlur = 10;
      ctx.fillText('POT: $' + pot, W/2, H/2 + 55);
      ctx.restore();
    }

    function drawPlayer(idx) {
      let p = players[idx];
      let pos = getPlayerPosition(idx, players.length);
      let isCurrentTurn = (idx === currentPlayerIdx && phase !== 'showdown');
      let isHuman = p.isHuman;
      let badgeR = isHuman ? 22 : 18;

      ctx.save();

      // Turn indicator glow
      if (isCurrentTurn && !p.folded) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, badgeR + 5, 0, Math.PI * 2);
        ctx.strokeStyle = GOLD;
        ctx.lineWidth = 2;
        ctx.shadowColor = GOLD;
        ctx.shadowBlur = 14;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Badge
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, badgeR, 0, Math.PI * 2);
      let bgColor = p.folded ? '#222' : (isHuman ? '#1a3050' : '#261540');
      ctx.fillStyle = bgColor;
      ctx.fill();
      ctx.strokeStyle = p.folded ? '#444' : (p.color || '#888');
      ctx.lineWidth = 2;
      ctx.stroke();

      // Initial
      ctx.font = 'bold ' + (isHuman ? '18' : '14') + 'px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = p.folded ? '#555' : (p.color || '#ddd');
      ctx.fillText(p.name[0], pos.x, pos.y);
      ctx.textBaseline = 'alphabetic';

      // Name below badge
      ctx.font = (isHuman ? '11' : '10') + 'px Courier New';
      ctx.fillStyle = p.folded ? '#444' : '#bbb';
      ctx.fillText(p.name, pos.x, pos.y + badgeR + 12);

      // Chips below name
      ctx.font = 'bold 10px Courier New';
      ctx.fillStyle = p.folded ? '#333' : GOLD;
      ctx.fillText('$' + p.chips, pos.x, pos.y + badgeR + 24);

      // Style label for AI
      if (!isHuman && p.personality && !p.folded) {
        ctx.font = '8px Courier New';
        ctx.fillStyle = '#556';
        ctx.fillText(p.personality.style, pos.x, pos.y + badgeR + 34);
      }

      // Dealer chip
      if (idx === dealerIdx) {
        let dx = pos.x + badgeR + 6;
        let dy = pos.y - badgeR + 2;
        ctx.beginPath();
        ctx.arc(dx, dy, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#f5f0d0';
        ctx.fill();
        ctx.strokeStyle = '#aa9040';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.font = 'bold 9px Courier New';
        ctx.fillStyle = '#333';
        ctx.fillText('D', dx, dy + 3);
      }

      // Current bet indicator
      if (p.currentBet > 0 && !p.folded) {
        let cx = W/2, cy = H/2 - 15;
        let dx = cx - pos.x, dy = cy - pos.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let bx = pos.x + (dist > 0 ? dx * 0.4 : 0);
        let by = pos.y + (dist > 0 ? dy * 0.4 : 0);

        // Chip stack
        ctx.beginPath();
        ctx.arc(bx, by, 10, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(220,180,60,0.2)';
        ctx.fill();
        ctx.font = 'bold 9px Courier New';
        ctx.fillStyle = '#fb4';
        ctx.fillText('$' + p.currentBet, bx, by + 3);
      }

      // Folded text
      if (p.folded) {
        ctx.font = '9px Courier New';
        ctx.fillStyle = '#555';
        ctx.fillText('FOLDED', pos.x, pos.y + badgeR + 34);
      }

      // All-in badge
      if (p.allIn && !p.folded) {
        ctx.font = 'bold 9px Courier New';
        ctx.fillStyle = '#f64';
        ctx.shadowColor = '#f64';
        ctx.shadowBlur = 6;
        ctx.fillText('ALL IN', pos.x, pos.y + badgeR + 34);
        ctx.shadowBlur = 0;
      }

      ctx.restore();

      // Draw hole cards
      if (!p.folded && p.holeCards.length >= 2) {
        let showCards = isHuman || revealedHands;
        if (isHuman) {
          let cx1 = pos.x - CW - 2;
          let cy1 = pos.y - CH - 28;
          drawCard(cx1, cy1, p.holeCards[0], showCards, false);
          drawCard(cx1 + CW + 4, cy1, p.holeCards[1], showCards, false);

          // Show current hand strength for human
          if (showCards && communityCards.length >= 3) {
            let hand = evaluateHand(p.holeCards, communityCards);
            ctx.save();
            ctx.font = 'bold 10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fd6';
            ctx.shadowColor = '#fd6';
            ctx.shadowBlur = 4;
            ctx.fillText(hand.name, pos.x, pos.y - CH - 33);
            ctx.restore();
          }
        } else {
          let cx1 = pos.x - 32;
          let cy1 = pos.y - badgeR - 50;
          drawCard(cx1, cy1, p.holeCards[0], showCards, true);
          drawCard(cx1 + 34, cy1, p.holeCards[1], showCards, true);

          if (showCards && revealedHands && communityCards.length >= 3) {
            let hand = evaluateHand(p.holeCards, communityCards);
            ctx.save();
            ctx.font = '9px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fd6';
            ctx.fillText(hand.name, pos.x, cy1 - 5);
            ctx.restore();
          }
        }
      }
    }

    function drawActionButtons() {
      if (!actionButtons || actionButtons.length === 0) return;

      // Button bar background
      ctx.fillStyle = 'rgba(13, 21, 32, 0.92)';
      ctx.fillRect(0, H - 38, W, 38);
      ctx.strokeStyle = GOLD_DIM;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, H - 38);
      ctx.lineTo(W, H - 38);
      ctx.stroke();

      for (let btn of actionButtons) {
        let bx = btn.x - btn.w/2;
        let by = btn.y - btn.h/2;
        ctx.save();

        // Button bg
        let isRed = btn.action === 'fold';
        let isGreen = btn.action === 'check' || btn.action === 'call';
        let btnColor = isRed ? '#4a1a1a' : (isGreen ? '#1a3a1a' : '#1a2040');
        let borderColor = isRed ? '#c44' : (isGreen ? '#4c4' : GOLD);

        ctx.fillStyle = btnColor;
        ctx.shadowColor = borderColor;
        ctx.shadowBlur = 6;
        roundRect(bx, by, btn.w, btn.h, 4, true, false);
        ctx.shadowBlur = 0;
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 1.5;
        roundRect(bx, by, btn.w, btn.h, 4, false, true);

        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = borderColor;
        ctx.fillText(btn.label, btn.x, btn.y + 4);
        ctx.restore();
      }

      // Raise slider
      if (raiseSlider && raiseSlider.max > raiseSlider.min) {
        let s = raiseSlider;
        let sliderY = s.y + s.h / 2;

        // Track bg
        ctx.fillStyle = '#222';
        roundRect(s.x, s.y + 5, s.w, s.h - 10, 4, true, false);

        // Filled portion
        let pct = Math.max(0, Math.min(1, (s.value - s.min) / (s.max - s.min)));
        if (pct > 0) {
          ctx.fillStyle = GOLD_DIM;
          roundRect(s.x, s.y + 5, Math.max(8, s.w * pct), s.h - 10, 4, true, false);
        }

        // Handle
        let hx = s.x + s.w * pct;
        ctx.beginPath();
        ctx.arc(hx, sliderY, 7, 0, Math.PI * 2);
        ctx.fillStyle = GOLD;
        ctx.shadowColor = GOLD;
        ctx.shadowBlur = 5;
        ctx.fill();
        ctx.shadowBlur = 0;

        // Value label
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#eee';
        ctx.fillText('$' + s.value, s.x + s.w / 2, s.y);
      }
    }

    function drawMessageLog() {
      if (!messageLog) return;
      ctx.save();
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      let baseY = waitingForHuman ? H - 50 : H - 20;
      for (let i = 0; i < messageLog.length; i++) {
        let alpha = Math.max(0.2, 0.9 - i * 0.25);
        ctx.fillStyle = 'rgba(200, 200, 200, ' + alpha + ')';
        ctx.fillText(messageLog[i], 10, baseY - i * 13);
      }
      ctx.restore();
    }

    function drawWinnerBanner() {
      ctx.save();
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';

      // Pulsing glow
      let elapsed = Date.now() - winnerDisplayTimer;
      let pulse = 0.6 + 0.4 * Math.sin(elapsed / 200);

      ctx.fillStyle = GOLD;
      ctx.shadowColor = GOLD;
      ctx.shadowBlur = 12 * pulse;
      ctx.fillText(winnerMessage, W/2, H/2 + 72);
      ctx.restore();
    }

    function drawPhaseIndicator() {
      if (!phase) return;
      let labels = {preflop:'PRE-FLOP', flop:'FLOP', turn:'TURN', river:'RIVER', showdown:'SHOWDOWN'};
      ctx.save();
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      ctx.fillStyle = '#667';
      ctx.fillText(labels[phase] || '', W - 10, 14);
      ctx.restore();
    }

    // === INPUT ===
    let isDraggingSlider = false;

    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;
      if (!waitingForHuman) return;
      if (phase === 'showdown') return;

      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      let my = (e.clientY - rect.top) * (H / rect.height);

      // Check slider first
      if (raiseSlider && raiseSlider.max > raiseSlider.min) {
        let s = raiseSlider;
        if (mx >= s.x - 10 && mx <= s.x + s.w + 10 && my >= s.y - 10 && my <= s.y + s.h + 10) {
          isDraggingSlider = true;
          updateSliderVal(mx);
          draw();
          return;
        }
      }

      // Check buttons
      if (actionButtons) {
        for (let btn of actionButtons) {
          let bx = btn.x - btn.w/2;
          let by = btn.y - btn.h/2;
          if (mx >= bx && mx <= bx + btn.w && my >= by && my <= by + btn.h) {
            if (btn.action === 'raise') {
              playerAction('raise', raiseSlider ? raiseSlider.value : null);
            } else {
              playerAction(btn.action);
            }
            return;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDraggingSlider) return;
      let rect = canvas.getBoundingClientRect();
      let mx = (e.clientX - rect.left) * (W / rect.width);
      updateSliderVal(mx);
      draw();
    });

    canvas.addEventListener('mouseup', () => { isDraggingSlider = false; });
    canvas.addEventListener('mouseleave', () => { isDraggingSlider = false; });

    function updateSliderVal(mx) {
      if (!raiseSlider) return;
      let s = raiseSlider;
      let pct = Math.max(0, Math.min(1, (mx - s.x) / s.w));
      let rawVal = s.min + pct * (s.max - s.min);
      s.value = Math.max(s.min, Math.min(s.max, Math.round(rawVal / bigBlind) * bigBlind));
      if (s.value < s.min) s.value = s.min;
    }

    // Overlay click
    overlay.style.cursor = 'pointer';
    overlay.style.pointerEvents = 'auto';
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting') startGame();
      else if (gameState === 'over') init();
    });

    // Keyboard fallback
    document.addEventListener('keydown', (e) => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
    });

    // Render loop
    function renderLoop() {
      if (gameState === 'playing') draw();
      requestAnimationFrame(renderLoop);
    }

    init();
    renderLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Creep TD Versus</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
      width: 800px;
    }
    .back { color: #0f8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
    h1 { color: #0f8; font-size: 1.5rem; text-shadow: 0 0 15px rgba(0, 255, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 800px;
      margin-bottom: 6px;
      font-size: 1rem;
    }
    .score-bar span { color: #0f8; }
    canvas {
      border: 2px solid #0f8;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #0f8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.92);
    }
    .overlay h2 {
      font-size: 2rem;
      margin-bottom: 12px;
      text-shadow: 0 0 25px rgba(0,255,136,0.7);
    }
    .overlay p { font-size: 1rem; color: #aaa; max-width: 500px; line-height: 1.6; }
    .overlay.hidden { display: none; }
    .shop-bar {
      display: flex;
      gap: 4px;
      margin-top: 6px;
      width: 800px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .shop-btn {
      background: #16213e;
      border: 1px solid #0f8;
      color: #0f8;
      font-family: 'Courier New', monospace;
      font-size: 0.7rem;
      padding: 4px 7px;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }
    .shop-btn:hover { background: #1a3a5e; box-shadow: 0 0 8px rgba(0,255,136,0.3); }
    .shop-btn.active { background: #0f8; color: #1a1a2e; font-weight: bold; }
    .shop-btn.send { border-color: #f55; color: #f55; }
    .shop-btn.send:hover { background: #3a1616; box-shadow: 0 0 8px rgba(255,68,68,0.3); }
    .shop-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .divider { color: #333; align-self: center; font-size: 1rem; margin: 0 2px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CREEP TD VERSUS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="800" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:800px;height:500px;">
      <h2 id="overlayTitle">CREEP TD VERSUS</h2>
      <p id="overlayText">Build mazes with towers to defend your base.<br>Send creeps to overwhelm the AI opponent.<br><br>Click to Start</p>
    </div>
  </div>
  <div class="shop-bar" id="shopBar">
    <button class="shop-btn" id="btnBasic" onclick="selectTower('basic')">[1] Basic $10</button>
    <button class="shop-btn" id="btnSniper" onclick="selectTower('sniper')">[2] Sniper $25</button>
    <button class="shop-btn" id="btnSplash" onclick="selectTower('splash')">[3] Splash $30</button>
    <button class="shop-btn" id="btnSlow" onclick="selectTower('slow')">[4] Slow $15</button>
    <span class="divider">|</span>
    <button class="shop-btn send" id="btnCreepBasic" onclick="sendCreep('basic')">[Q] Send Basic $8</button>
    <button class="shop-btn send" id="btnCreepFast" onclick="sendCreep('fast')">[W] Send Fast $12</button>
    <button class="shop-btn send" id="btnCreepTank" onclick="sendCreep('tank')">[E] Send Tank $20</button>
    <button class="shop-btn send" id="btnCreepSwarm" onclick="sendCreep('swarm')">[R] Send Swarm $15</button>
    <span class="divider">|</span>
    <button class="shop-btn" id="btnSell" onclick="selectTower('sell')" style="border-color:#fa0;color:#fa0;">[S] Sell</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 800, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('creepTdVersusBest') || '0');
    bestEl.textContent = bestScore;

    // Grid constants
    const COLS = 12, ROWS = 14;
    const CELL = 26;
    const FIELD_W = COLS * CELL; // 312
    const FIELD_H = ROWS * CELL; // 364
    const GAP = W - FIELD_W * 2; // 176
    const MARGIN_Y = (H - FIELD_H) / 2; // 68
    const P1_OX = 0;
    const P1_OY = Math.floor(MARGIN_Y);
    const P2_OX = FIELD_W + GAP;
    const P2_OY = P1_OY;

    // Entry at top-left, exit at bottom-right
    const ENTRY_COL = 0, ENTRY_ROW = 0;
    const EXIT_COL = COLS - 1, EXIT_ROW = ROWS - 1;

    // Tower definitions
    const TOWER_DEFS = {
      basic:  { cost: 10, range: 2.8, damage: 10, rate: 25, color: '#0f8', name: 'Basic', sellback: 5, key: '1' },
      sniper: { cost: 25, range: 5.5, damage: 35, rate: 55, color: '#4af', name: 'Sniper', sellback: 12, key: '2' },
      splash: { cost: 30, range: 2.5, damage: 14, rate: 40, color: '#f80', name: 'Splash', splashRadius: 1.8, sellback: 15, key: '3' },
      slow:   { cost: 15, range: 2.5, damage: 4,  rate: 20, color: '#a4f', name: 'Slow', slowFactor: 0.35, slowDuration: 100, sellback: 7, key: '4' }
    };

    // Creep definitions
    const CREEP_DEFS = {
      basic: { cost: 8,  hp: 70,  speed: 1.0, reward: 3, color: '#e55', name: 'Basic', count: 1, radius: 5 },
      fast:  { cost: 12, hp: 40,  speed: 2.2, reward: 4, color: '#ff0', name: 'Fast',  count: 1, radius: 4 },
      tank:  { cost: 20, hp: 200, speed: 0.55, reward: 8, color: '#f80', name: 'Tank',  count: 1, radius: 7 },
      swarm: { cost: 15, hp: 30,  speed: 1.3, reward: 1, color: '#f4f', name: 'Swarm', count: 5, radius: 3 }
    };

    let selectedTower = null;
    let mouseX = -999, mouseY = -999;
    let players = [];
    let gameTime = 0;
    let particles = [];
    let projectiles = [];
    let floatingTexts = [];

    // ---- BFS Pathfinding ----
    function findPath(grid, sr, sc, er, ec) {
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const parent = Array.from({length: ROWS}, () => Array(COLS).fill(null));
      const queue = [[sr, sc]];
      visited[sr][sc] = true;
      const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
      while (queue.length > 0) {
        const [r, c] = queue.shift();
        if (r === er && c === ec) {
          const path = [];
          let cur = [er, ec];
          while (cur) { path.unshift(cur); cur = parent[cur[0]][cur[1]]; }
          return path;
        }
        for (const [dr, dc] of dirs) {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !visited[nr][nc] && !grid[nr][nc]) {
            visited[nr][nc] = true;
            parent[nr][nc] = [r, c];
            queue.push([nr, nc]);
          }
        }
      }
      return null;
    }

    function createPlayer(isAI) {
      const grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      return {
        isAI,
        grid,
        towers: [],
        creeps: [],
        lives: 20,
        gold: 50,
        path: findPath(grid, ENTRY_ROW, ENTRY_COL, EXIT_ROW, EXIT_COL),
        creepsKilled: 0,
        incomeTimer: 0
      };
    }

    function init() {
      players = [createPlayer(false), createPlayer(true)];
      score = 0;
      gameTime = 0;
      particles = [];
      projectiles = [];
      floatingTexts = [];
      selectedTower = null;
      updateButtons();
      scoreEl.textContent = '0';
    }

    function startGame() {
      if (gameState === 'waiting' || gameState === 'over') {
        init();
        gameState = 'playing';
        overlay.classList.add('hidden');
      }
    }

    // ---- Input ----
    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting' || gameState === 'over') { startGame(); return; }
      if (gameState !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX - rect.left) * (W / rect.width);
      const sy = (e.clientY - rect.top) * (H / rect.height);

      const p = players[0];
      const gx = sx - P1_OX, gy = sy - P1_OY;
      const col = Math.floor(gx / CELL);
      const row = Math.floor(gy / CELL);
      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

      if (selectedTower === 'sell') {
        const ti = p.towers.findIndex(t => t.col === col && t.row === row);
        if (ti >= 0) {
          const t = p.towers[ti];
          const refund = TOWER_DEFS[t.type].sellback;
          p.gold += refund;
          p.grid[row][col] = 0;
          p.towers.splice(ti, 1);
          p.path = findPath(p.grid, ENTRY_ROW, ENTRY_COL, EXIT_ROW, EXIT_COL);
          for (const cr of p.creeps) repathCreep(cr, p);
          addFloatingText('+$' + refund, P1_OX + col * CELL + CELL/2, P1_OY + row * CELL, '#fa0');
          updateButtons();
        }
        return;
      }

      if (!selectedTower || !TOWER_DEFS[selectedTower]) return;
      const def = TOWER_DEFS[selectedTower];
      if (p.gold < def.cost) return;
      if ((row === ENTRY_ROW && col === ENTRY_COL) || (row === EXIT_ROW && col === EXIT_COL)) return;
      if (p.grid[row][col]) return;

      p.grid[row][col] = 1;
      const newPath = findPath(p.grid, ENTRY_ROW, ENTRY_COL, EXIT_ROW, EXIT_COL);
      if (!newPath) { p.grid[row][col] = 0; return; }

      p.gold -= def.cost;
      p.towers.push({ type: selectedTower, row, col, cooldown: 0 });
      p.path = newPath;
      for (const cr of p.creeps) repathCreep(cr, p);
      addFloatingText('-$' + def.cost, P1_OX + col * CELL + CELL/2, P1_OY + row * CELL, '#0f8');
      updateButtons();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);
    });

    canvas.addEventListener('mouseleave', () => { mouseX = -999; mouseY = -999; });
    canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); selectedTower = null; updateButtons(); });

    document.addEventListener('keydown', (e) => {
      if (gameState === 'waiting' || gameState === 'over') { startGame(); return; }
      if (gameState !== 'playing') return;
      const key = e.key.toLowerCase();
      if (key === '1') selectTower('basic');
      else if (key === '2') selectTower('sniper');
      else if (key === '3') selectTower('splash');
      else if (key === '4') selectTower('slow');
      else if (key === 'q') sendCreep('basic');
      else if (key === 'w') sendCreep('fast');
      else if (key === 'e') sendCreep('tank');
      else if (key === 'r') sendCreep('swarm');
      else if (key === 's') selectTower('sell');
      else if (key === 'escape') { selectedTower = null; updateButtons(); }
    });

    function selectTower(type) {
      if (gameState !== 'playing') return;
      selectedTower = (selectedTower === type) ? null : type;
      updateButtons();
    }

    function sendCreep(type) {
      if (gameState !== 'playing') return;
      const p = players[0];
      const def = CREEP_DEFS[type];
      if (p.gold < def.cost) return;
      p.gold -= def.cost;
      spawnCreeps(players[1], type);
      addFloatingText('SEND ' + def.name.toUpperCase(), W/2, H/2 - 10, '#f55');
      updateButtons();
    }

    function spawnCreeps(targetPlayer, type) {
      const def = CREEP_DEFS[type];
      for (let i = 0; i < def.count; i++) {
        const creep = {
          type,
          hp: def.hp,
          maxHp: def.hp,
          speed: def.speed,
          baseSpeed: def.speed,
          color: def.color,
          reward: def.reward,
          radius: def.radius,
          pathIndex: 0,
          x: ENTRY_COL * CELL + CELL / 2,
          y: ENTRY_ROW * CELL + CELL / 2,
          slowTimer: 0,
          spawnDelay: i * 18
        };
        if (targetPlayer.path) creep.path = targetPlayer.path.slice();
        targetPlayer.creeps.push(creep);
      }
    }

    function repathCreep(creep, player) {
      if (!player.path) return;
      const curCol = Math.round((creep.x - CELL/2) / CELL);
      const curRow = Math.round((creep.y - CELL/2) / CELL);
      const cc = Math.max(0, Math.min(COLS-1, curCol));
      const cr = Math.max(0, Math.min(ROWS-1, curRow));
      // If creep is on a tower, try adjacent cells
      if (player.grid[cr][cc]) {
        const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
        for (const [dr, dc] of dirs) {
          const nr = cr + dr, nc = cc + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !player.grid[nr][nc]) {
            const np = findPath(player.grid, nr, nc, EXIT_ROW, EXIT_COL);
            if (np) { creep.path = np; creep.pathIndex = 0; return; }
          }
        }
      } else {
        const np = findPath(player.grid, cr, cc, EXIT_ROW, EXIT_COL);
        if (np) { creep.path = np; creep.pathIndex = 0; }
      }
    }

    function addFloatingText(text, x, y, color) {
      floatingTexts.push({ text, x, y, color, life: 50 });
    }

    function updateButtons() {
      if (gameState !== 'playing') return;
      const p = players[0];
      document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('active'));
      if (selectedTower) {
        const btnId = selectedTower === 'sell' ? 'btnSell' :
          'btn' + selectedTower.charAt(0).toUpperCase() + selectedTower.slice(1);
        const el = document.getElementById(btnId);
        if (el) el.classList.add('active');
      }
      document.getElementById('btnBasic').disabled = p.gold < 10;
      document.getElementById('btnSniper').disabled = p.gold < 25;
      document.getElementById('btnSplash').disabled = p.gold < 30;
      document.getElementById('btnSlow').disabled = p.gold < 15;
      document.getElementById('btnCreepBasic').disabled = p.gold < 8;
      document.getElementById('btnCreepFast').disabled = p.gold < 12;
      document.getElementById('btnCreepTank').disabled = p.gold < 20;
      document.getElementById('btnCreepSwarm').disabled = p.gold < 15;
    }

    // ---- AI ----
    function aiTick() {
      const ai = players[1];
      const human = players[0];

      // Passive income every 3 seconds
      if (gameTime % 180 === 0) {
        ai.gold += 5;
        players[0].gold += 5;
        updateButtons();
      }

      // AI acts every ~60-100 frames
      if (gameTime % 70 !== 0) return;

      const towerCount = ai.towers.length;
      // Early game: focus on building. Later: mix sending.
      const buildWeight = towerCount < 6 ? 0.8 : towerCount < 15 ? 0.55 : 0.35;

      if (Math.random() < buildWeight && ai.gold >= 10) {
        aiPlaceTower(ai);
      } else if (ai.gold >= 8) {
        aiSendCreep(ai, human);
      }
    }

    function aiPlaceTower(ai) {
      if (!ai.path || ai.path.length < 3) return;

      // Score candidate positions: prefer spots that extend the path length
      const candidates = [];
      const dirs = [[0,1],[1,0],[0,-1],[-1,0]];
      const pathSet = new Set(ai.path.map(p => p[0] * COLS + p[1]));

      for (const [pr, pc] of ai.path) {
        for (const [dr, dc] of dirs) {
          const nr = pr + dr, nc = pc + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && !ai.grid[nr][nc]) {
            if (!(nr === ENTRY_ROW && nc === ENTRY_COL) && !(nr === EXIT_ROW && nc === EXIT_COL)) {
              if (!pathSet.has(nr * COLS + nc)) continue; // prefer blocking path cells
              candidates.push([nr, nc]);
            }
          }
        }
      }

      // Also add cells directly on the path (to force longer mazes)
      for (let i = 1; i < ai.path.length - 1; i++) {
        const [pr, pc] = ai.path[i];
        if (!ai.grid[pr][pc]) {
          candidates.push([pr, pc]);
        }
      }

      // Deduplicate
      const seen = new Set();
      const unique = [];
      for (const [r, c] of candidates) {
        const key = r * COLS + c;
        if (!seen.has(key)) { seen.add(key); unique.push([r, c]); }
      }

      // Shuffle
      for (let i = unique.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [unique[i], unique[j]] = [unique[j], unique[i]];
      }

      // Choose tower type
      let towerType = 'basic';
      const r = Math.random();
      if (ai.gold >= 30 && r < 0.25) towerType = 'splash';
      else if (ai.gold >= 25 && r < 0.45) towerType = 'sniper';
      else if (ai.gold >= 15 && r < 0.6) towerType = 'slow';

      if (ai.gold < TOWER_DEFS[towerType].cost) towerType = 'basic';
      if (ai.gold < 10) return;

      for (const [r, c] of unique) {
        ai.grid[r][c] = 1;
        const newPath = findPath(ai.grid, ENTRY_ROW, ENTRY_COL, EXIT_ROW, EXIT_COL);
        if (newPath && newPath.length >= ai.path.length) {
          // Prefer placements that make path longer
          ai.gold -= TOWER_DEFS[towerType].cost;
          ai.towers.push({ type: towerType, row: r, col: c, cooldown: 0 });
          ai.path = newPath;
          for (const cr of ai.creeps) repathCreep(cr, ai);
          return;
        }
        ai.grid[r][c] = 0;
      }

      // Fallback: any valid placement
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (ai.grid[r][c]) continue;
          if ((r === ENTRY_ROW && c === ENTRY_COL) || (r === EXIT_ROW && c === EXIT_COL)) continue;
          ai.grid[r][c] = 1;
          const np = findPath(ai.grid, ENTRY_ROW, ENTRY_COL, EXIT_ROW, EXIT_COL);
          if (np) {
            ai.gold -= TOWER_DEFS[towerType].cost;
            ai.towers.push({ type: towerType, row: r, col: c, cooldown: 0 });
            ai.path = np;
            for (const cr of ai.creeps) repathCreep(cr, ai);
            return;
          }
          ai.grid[r][c] = 0;
        }
      }
    }

    function aiSendCreep(ai, human) {
      const options = [];
      if (ai.gold >= 8) options.push('basic');
      if (ai.gold >= 12) options.push('fast');
      if (ai.gold >= 20) options.push('tank');
      if (ai.gold >= 15) options.push('swarm');
      if (options.length === 0) return;

      // Slightly smarter: if human has few towers, send fast; if many, send tanks
      const humanTowers = human.towers.length;
      let type;
      if (humanTowers < 5 && options.includes('fast')) type = 'fast';
      else if (humanTowers > 12 && options.includes('tank')) type = 'tank';
      else type = options[Math.floor(Math.random() * options.length)];

      ai.gold -= CREEP_DEFS[type].cost;
      spawnCreeps(human, type);
    }

    // ---- Update ----
    function updateCreeps(player, playerIndex) {
      for (let i = player.creeps.length - 1; i >= 0; i--) {
        const c = player.creeps[i];
        if (c.spawnDelay > 0) { c.spawnDelay--; continue; }

        if (c.slowTimer > 0) {
          c.slowTimer--;
          if (c.slowTimer <= 0) c.speed = c.baseSpeed;
        }

        if (!c.path || c.pathIndex >= c.path.length) {
          // Reached exit - lose a life
          player.lives = Math.max(0, player.lives - 1);
          const ox = playerIndex === 0 ? P1_OX : P2_OX;
          for (let k = 0; k < 10; k++) {
            particles.push({
              x: EXIT_COL * CELL + CELL/2 + ox,
              y: EXIT_ROW * CELL + CELL/2 + P1_OY,
              vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
              life: 35, color: '#f44', size: 3
            });
          }
          addFloatingText('-1 LIFE', ox + EXIT_COL * CELL + CELL/2, P1_OY + EXIT_ROW * CELL, '#f44');
          player.creeps.splice(i, 1);
          continue;
        }

        // Move
        const [tr, tc] = c.path[c.pathIndex];
        const tx = tc * CELL + CELL / 2;
        const ty = tr * CELL + CELL / 2;
        const dx = tx - c.x, dy = ty - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const moveSpeed = c.speed * 1.8;
        if (dist < moveSpeed) {
          c.x = tx; c.y = ty; c.pathIndex++;
        } else {
          c.x += (dx / dist) * moveSpeed;
          c.y += (dy / dist) * moveSpeed;
        }

        // Death check
        if (c.hp <= 0) {
          player.gold += c.reward;
          player.creepsKilled++;
          if (playerIndex === 0) {
            score += c.reward;
            scoreEl.textContent = score;
          }
          const ox = playerIndex === 0 ? P1_OX : P2_OX;
          for (let k = 0; k < 8; k++) {
            particles.push({
              x: c.x + ox, y: c.y + P1_OY,
              vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4,
              life: 28, color: c.color, size: 2
            });
          }
          addFloatingText('+$' + c.reward, c.x + ox, c.y + P1_OY - 8, '#fd0');
          player.creeps.splice(i, 1);
        }
      }
    }

    function updateTowers(player, playerIndex) {
      for (const t of player.towers) {
        if (t.cooldown > 0) { t.cooldown--; continue; }
        const def = TOWER_DEFS[t.type];
        const tx = t.col * CELL + CELL / 2;
        const ty = t.row * CELL + CELL / 2;
        const rangePx = def.range * CELL;

        let target = null;
        let bestProgress = -1;
        for (const c of player.creeps) {
          if (c.spawnDelay > 0 || c.hp <= 0) continue;
          const dx = c.x - tx, dy = c.y - ty;
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d <= rangePx) {
            const progress = c.pathIndex;
            if (progress > bestProgress) { bestProgress = progress; target = c; }
          }
        }

        if (target) {
          t.cooldown = def.rate;
          const ox = playerIndex === 0 ? P1_OX : P2_OX;

          projectiles.push({
            sx: tx + ox, sy: ty + P1_OY,
            ex: target.x + ox, ey: target.y + P1_OY,
            color: def.color, life: 6
          });

          if (def.splashRadius) {
            const sr = def.splashRadius * CELL;
            for (const c of player.creeps) {
              if (c.spawnDelay > 0) continue;
              const dx = c.x - target.x, dy = c.y - target.y;
              if (Math.sqrt(dx*dx+dy*dy) <= sr) c.hp -= def.damage;
            }
            // Splash visual
            particles.push({
              x: target.x + ox, y: target.y + P1_OY,
              vx: 0, vy: 0, life: 12, color: def.color + '60', size: sr, isRing: true
            });
          } else {
            target.hp -= def.damage;
          }

          if (def.slowFactor && target.slowTimer <= 0) {
            target.speed = target.baseSpeed * def.slowFactor;
            target.slowTimer = def.slowDuration;
          }
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (!p.isRing) { p.x += p.vx; p.y += p.vy; p.vy += 0.05; }
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
      for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].life--;
        if (projectiles[i].life <= 0) projectiles.splice(i, 1);
      }
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].y -= 0.8;
        floatingTexts[i].life--;
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
      }
    }

    // ---- Drawing ----
    function drawField(player, ox, oy, label, isHuman) {
      const accent = isHuman ? '#0f8' : '#b4f';
      const accentDim = isHuman ? 'rgba(0,255,136,' : 'rgba(180,80,255,';
      const bgColor = isHuman ? '#0c1420' : '#140c1c';

      // Field background
      ctx.fillStyle = bgColor;
      ctx.fillRect(ox, oy, FIELD_W, FIELD_H);

      // Grid
      ctx.strokeStyle = accentDim + '0.06)';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath(); ctx.moveTo(ox, oy + r * CELL); ctx.lineTo(ox + FIELD_W, oy + r * CELL); ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath(); ctx.moveTo(ox + c * CELL, oy); ctx.lineTo(ox + c * CELL, oy + FIELD_H); ctx.stroke();
      }

      // Path glow
      if (player.path && player.path.length > 1) {
        ctx.strokeStyle = accentDim + '0.1)';
        ctx.lineWidth = CELL * 0.7;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(ox + player.path[0][1] * CELL + CELL/2, oy + player.path[0][0] * CELL + CELL/2);
        for (let i = 1; i < player.path.length; i++) {
          ctx.lineTo(ox + player.path[i][1] * CELL + CELL/2, oy + player.path[i][0] * CELL + CELL/2);
        }
        ctx.stroke();
        ctx.lineWidth = 1; ctx.lineCap = 'butt';
      }

      // Entry marker
      ctx.fillStyle = '#0f8';
      ctx.shadowColor = '#0f8'; ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(ox + ENTRY_COL * CELL + CELL/2, oy + ENTRY_ROW * CELL + CELL/2, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000'; ctx.shadowBlur = 0;
      ctx.font = 'bold 8px Courier New'; ctx.textAlign = 'center';
      ctx.fillText('IN', ox + ENTRY_COL * CELL + CELL/2, oy + ENTRY_ROW * CELL + CELL/2 + 3);

      // Exit marker
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44'; ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(ox + EXIT_COL * CELL + CELL/2, oy + EXIT_ROW * CELL + CELL/2, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000'; ctx.shadowBlur = 0;
      ctx.fillText('OUT', ox + EXIT_COL * CELL + CELL/2, oy + EXIT_ROW * CELL + CELL/2 + 3);

      // Towers
      for (const t of player.towers) {
        const def = TOWER_DEFS[t.type];
        const cx = ox + t.col * CELL + CELL/2;
        const cy = oy + t.row * CELL + CELL/2;

        ctx.fillStyle = def.color;
        ctx.shadowColor = def.color; ctx.shadowBlur = 5;
        if (t.type === 'basic') {
          ctx.fillRect(cx - 7, cy - 7, 14, 14);
        } else if (t.type === 'sniper') {
          ctx.beginPath();
          ctx.moveTo(cx, cy - 9); ctx.lineTo(cx + 8, cy + 6); ctx.lineTo(cx - 8, cy + 6);
          ctx.closePath(); ctx.fill();
        } else if (t.type === 'splash') {
          ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI * 2); ctx.fill();
        } else if (t.type === 'slow') {
          ctx.beginPath();
          ctx.moveTo(cx, cy - 9); ctx.lineTo(cx + 9, cy); ctx.lineTo(cx, cy + 9); ctx.lineTo(cx - 9, cy);
          ctx.closePath(); ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Firing flash
        if (t.cooldown > TOWER_DEFS[t.type].rate - 4) {
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill();
        }
      }

      // Placement preview for human
      if (isHuman && selectedTower && selectedTower !== 'sell' && TOWER_DEFS[selectedTower]) {
        const gx = mouseX - ox, gy = mouseY - oy;
        const hc = Math.floor(gx / CELL), hr = Math.floor(gy / CELL);
        if (hc >= 0 && hc < COLS && hr >= 0 && hr < ROWS) {
          const def = TOWER_DEFS[selectedTower];
          const canPlace = !player.grid[hr][hc] &&
            !(hr === ENTRY_ROW && hc === ENTRY_COL) && !(hr === EXIT_ROW && hc === EXIT_COL) &&
            player.gold >= def.cost;

          // Range circle
          ctx.strokeStyle = canPlace ? def.color + '30' : 'rgba(255,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(ox + hc * CELL + CELL/2, oy + hr * CELL + CELL/2, def.range * CELL, 0, Math.PI*2);
          ctx.stroke();

          // Cell highlight
          ctx.fillStyle = canPlace ? 'rgba(0,255,136,0.15)' : 'rgba(255,0,0,0.15)';
          ctx.fillRect(ox + hc * CELL + 1, oy + hr * CELL + 1, CELL - 2, CELL - 2);

          // Ghost tower
          if (canPlace) {
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = def.color;
            const gcx = ox + hc * CELL + CELL/2, gcy = oy + hr * CELL + CELL/2;
            if (selectedTower === 'basic') ctx.fillRect(gcx-7, gcy-7, 14, 14);
            else if (selectedTower === 'sniper') {
              ctx.beginPath(); ctx.moveTo(gcx, gcy-9); ctx.lineTo(gcx+8, gcy+6); ctx.lineTo(gcx-8, gcy+6); ctx.closePath(); ctx.fill();
            } else if (selectedTower === 'splash') {
              ctx.beginPath(); ctx.arc(gcx, gcy, 8, 0, Math.PI*2); ctx.fill();
            } else if (selectedTower === 'slow') {
              ctx.beginPath(); ctx.moveTo(gcx, gcy-9); ctx.lineTo(gcx+9, gcy); ctx.lineTo(gcx, gcy+9); ctx.lineTo(gcx-9, gcy); ctx.closePath(); ctx.fill();
            }
            ctx.globalAlpha = 1;
          }
        }
      }

      // Sell mode highlight
      if (isHuman && selectedTower === 'sell') {
        const gx = mouseX - ox, gy = mouseY - oy;
        const hc = Math.floor(gx / CELL), hr = Math.floor(gy / CELL);
        if (hc >= 0 && hc < COLS && hr >= 0 && hr < ROWS) {
          const hasTower = player.towers.some(t => t.col === hc && t.row === hr);
          if (hasTower) {
            ctx.fillStyle = 'rgba(255,170,0,0.25)';
            ctx.fillRect(ox + hc * CELL, oy + hr * CELL, CELL, CELL);
            ctx.strokeStyle = '#fa0';
            ctx.lineWidth = 2;
            ctx.strokeRect(ox + hc * CELL + 1, oy + hr * CELL + 1, CELL - 2, CELL - 2);
          }
        }
      }

      // Tower info on hover (no tool selected)
      if (isHuman && !selectedTower) {
        const gx = mouseX - ox, gy = mouseY - oy;
        const hc = Math.floor(gx / CELL), hr = Math.floor(gy / CELL);
        if (hc >= 0 && hc < COLS && hr >= 0 && hr < ROWS) {
          const t = player.towers.find(t => t.col === hc && t.row === hr);
          if (t) {
            const def = TOWER_DEFS[t.type];
            ctx.strokeStyle = def.color + '40';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.arc(ox + hc * CELL + CELL/2, oy + hr * CELL + CELL/2, def.range * CELL, 0, Math.PI*2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Tooltip
            const ttx = ox + hc * CELL + CELL + 4;
            const tty = Math.min(oy + hr * CELL, oy + FIELD_H - 46);
            ctx.fillStyle = 'rgba(10,10,30,0.9)';
            ctx.strokeStyle = def.color + '80';
            ctx.lineWidth = 1;
            const ttw = 95, tth = 42;
            const finalTtx = ttx + ttw > ox + FIELD_W ? ox + hc * CELL - ttw - 4 : ttx;
            ctx.fillRect(finalTtx, tty, ttw, tth);
            ctx.strokeRect(finalTtx, tty, ttw, tth);
            ctx.fillStyle = def.color;
            ctx.font = 'bold 9px Courier New'; ctx.textAlign = 'left';
            ctx.fillText(def.name + ' Tower', finalTtx + 4, tty + 12);
            ctx.fillStyle = '#aaa'; ctx.font = '8px Courier New';
            ctx.fillText('DMG:' + def.damage + ' RNG:' + def.range.toFixed(1), finalTtx + 4, tty + 24);
            ctx.fillText('Sell: $' + def.sellback, finalTtx + 4, tty + 36);
          }
        }
      }

      // Creeps
      for (const c of player.creeps) {
        if (c.spawnDelay > 0) continue;
        const cx = ox + c.x, cy = oy + c.y;

        // Slow aura
        if (c.slowTimer > 0) {
          ctx.strokeStyle = 'rgba(170,68,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.arc(cx, cy, c.radius + 4, 0, Math.PI * 2); ctx.stroke();
        }

        // Body
        ctx.fillStyle = c.color;
        ctx.shadowColor = c.color; ctx.shadowBlur = 4;
        ctx.beginPath(); ctx.arc(cx, cy, c.radius, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        // Health bar
        const barW = c.radius * 2 + 6;
        const hpPct = Math.max(0, c.hp / c.maxHp);
        ctx.fillStyle = '#200';
        ctx.fillRect(cx - barW/2, cy - c.radius - 7, barW, 3);
        ctx.fillStyle = hpPct > 0.6 ? '#0f8' : hpPct > 0.3 ? '#ff0' : '#f44';
        ctx.fillRect(cx - barW/2, cy - c.radius - 7, barW * hpPct, 3);
      }

      // Field border
      ctx.strokeStyle = accent;
      ctx.lineWidth = 1.5;
      ctx.shadowColor = accent; ctx.shadowBlur = 6;
      ctx.strokeRect(ox, oy, FIELD_W, FIELD_H);
      ctx.shadowBlur = 0;

      // Label
      ctx.fillStyle = accent;
      ctx.shadowColor = accent; ctx.shadowBlur = 8;
      ctx.font = 'bold 11px Courier New'; ctx.textAlign = 'center';
      ctx.fillText(label, ox + FIELD_W/2, oy - 26);
      ctx.shadowBlur = 0;

      // Stats below label
      const livesColor = player.lives > 10 ? '#0f8' : player.lives > 5 ? '#ff0' : '#f44';
      ctx.font = '10px Courier New';

      ctx.fillStyle = livesColor; ctx.textAlign = 'left';
      ctx.fillText('\u2665 ' + player.lives, ox + 2, oy - 8);

      ctx.fillStyle = '#fd0'; ctx.textAlign = 'right';
      ctx.fillText('$' + player.gold, ox + FIELD_W - 2, oy - 8);

      ctx.fillStyle = '#777'; ctx.textAlign = 'center';
      ctx.fillText('Kills:' + player.creepsKilled, ox + FIELD_W/2, oy - 8);
    }

    function drawCenterPanel() {
      const cx = FIELD_W + GAP/2;
      const cy = P1_OY + FIELD_H/2;

      // VS
      ctx.fillStyle = '#333';
      ctx.font = 'bold 20px Courier New'; ctx.textAlign = 'center';
      ctx.fillText('VS', cx, cy - 20);

      // Timer
      const secs = Math.floor(gameTime / 60);
      const m = Math.floor(secs / 60);
      const s = secs % 60;
      ctx.fillStyle = '#555'; ctx.font = '11px Courier New';
      ctx.fillText((m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s, cx, cy);

      // Wave countdown
      const nextWave = 600 - (gameTime % 600);
      const nextSec = Math.ceil(nextWave / 60);
      ctx.fillStyle = nextSec <= 5 ? '#f44' : '#444';
      ctx.font = '9px Courier New';
      ctx.fillText('Auto wave', cx, cy + 20);
      ctx.fillText('in ' + nextSec + 's', cx, cy + 32);

      // Path length comparison
      const p1len = players[0].path ? players[0].path.length : 0;
      const p2len = players[1].path ? players[1].path.length : 0;
      ctx.font = '8px Courier New';
      ctx.fillStyle = '#0f8'; ctx.fillText('Path:' + p1len, cx, cy + 56);
      ctx.fillStyle = '#b4f'; ctx.fillText('Path:' + p2len, cx, cy + 68);

      // Decorative line
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, P1_OY + 10);
      ctx.lineTo(cx, P1_OY + FIELD_H - 10);
      ctx.stroke();
    }

    function drawProjectiles() {
      for (const p of projectiles) {
        const t = p.life / 6;
        ctx.globalAlpha = t;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = p.color; ctx.shadowBlur = 4;
        const mx = p.sx + (p.ex - p.sx) * (1 - t);
        const my = p.sy + (p.ey - p.sy) * (1 - t);
        ctx.beginPath(); ctx.moveTo(mx, my); ctx.lineTo(p.ex, p.ey); ctx.stroke();
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life / 35);
        if (p.isRing) {
          ctx.strokeStyle = p.color;
          ctx.lineWidth = 2;
          const scale = 1 - p.life / 12;
          ctx.beginPath(); ctx.arc(p.x, p.y, p.size * scale, 0, Math.PI * 2); ctx.stroke();
        } else {
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawFloatingTexts() {
      for (const ft of floatingTexts) {
        ctx.globalAlpha = Math.min(1, ft.life / 20);
        ctx.fillStyle = ft.color;
        ctx.shadowColor = ft.color; ctx.shadowBlur = 4;
        ctx.font = 'bold 10px Courier New'; ctx.textAlign = 'center';
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      // Bottom instructions
      ctx.fillStyle = '#333';
      ctx.font = '8px Courier New'; ctx.textAlign = 'center';
      ctx.fillText('1-4: Towers  |  Q/W/E/R: Send Creeps  |  S: Sell  |  Right-click: Cancel  |  ESC: Deselect', W/2, H - 4);
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawField(players[0], P1_OX, P1_OY, 'YOUR FIELD', true);
      drawField(players[1], P2_OX, P2_OY, 'AI FIELD', false);
      drawCenterPanel();
      drawProjectiles();
      drawParticles();
      drawFloatingTexts();
      drawHUD();
    }

    function endGame(winner) {
      gameState = 'over';
      score += Math.floor(gameTime / 60);
      scoreEl.textContent = score;
      if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = bestScore;
        localStorage.setItem('creepTdVersusBest', String(bestScore));
      }
      overlayTitle.textContent = winner === 0 ? 'VICTORY!' : 'DEFEATED';
      overlayTitle.style.textShadow = winner === 0
        ? '0 0 25px rgba(0,255,136,0.8)' : '0 0 25px rgba(255,68,68,0.8)';
      overlay.style.color = winner === 0 ? '#0f8' : '#f44';
      const timeStr = Math.floor(gameTime/3600) + ':' + String(Math.floor((gameTime/60)%60)).padStart(2,'0');
      overlayText.innerHTML = 'Score: ' + score + ' | Time: ' + timeStr +
        '<br>Kills: ' + players[0].creepsKilled +
        '<br><br>Click to play again';
      overlay.classList.remove('hidden');
    }

    function update() {
      if (gameState !== 'playing') return;
      gameTime++;

      aiTick();

      // Auto-waves every 10 seconds
      if (gameTime > 0 && gameTime % 600 === 0) {
        const waveNum = Math.floor(gameTime / 600);
        // Escalating waves
        if (waveNum <= 3) {
          spawnCreeps(players[0], 'basic');
          spawnCreeps(players[1], 'basic');
        } else if (waveNum <= 6) {
          spawnCreeps(players[0], 'fast');
          spawnCreeps(players[1], 'fast');
        } else if (waveNum <= 9) {
          spawnCreeps(players[0], 'tank');
          spawnCreeps(players[1], 'tank');
        } else {
          // Late game: mixed waves
          spawnCreeps(players[0], 'swarm');
          spawnCreeps(players[1], 'swarm');
          spawnCreeps(players[0], 'tank');
          spawnCreeps(players[1], 'tank');
        }
        addFloatingText('WAVE ' + waveNum, W/2, P1_OY + 20, '#ff0');
      }

      updateTowers(players[0], 0);
      updateTowers(players[1], 1);
      updateCreeps(players[0], 0);
      updateCreeps(players[1], 1);
      updateParticles();

      if (gameTime % 30 === 0) updateButtons();

      if (players[0].lives <= 0) endGame(1);
      else if (players[1].lives <= 0) endGame(0);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

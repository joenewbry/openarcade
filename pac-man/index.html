<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pac-Man</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 460px;
    }
    .back { color: #fd0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 221, 0, 0.4); }
    h1 { color: #fd0; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 221, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 460px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fd0; }
    canvas {
      border: 2px solid #fd0;
      box-shadow: 0 0 20px rgba(255, 221, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fd0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PAC-MAN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="460" height="520"></canvas>
    <div class="overlay" id="overlay" style="width:460px;height:520px;">
      <h2 id="overlayTitle">PAC-MAN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- MAZE DEFINITION ---
    // 0 = path (dot), 1 = wall, 2 = empty (no dot), 3 = power pellet, 4 = ghost house
    const COLS = 23;
    const ROWS = 22;
    const TILE = 20;

    // Classic-inspired maze layout (23 wide x 26 tall)
    const MAZE_TEMPLATE = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1],
      [1,3,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,3,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1],
      [1,1,1,1,1,0,1,1,1,1,2,1,2,1,1,1,1,0,1,1,1,1,1],
      [2,2,2,2,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,2,2,2,2],
      [1,1,1,1,1,0,1,2,1,1,1,4,1,1,1,2,1,0,1,1,1,1,1],
      [2,2,2,2,2,0,2,2,1,4,4,4,4,4,1,2,2,0,2,2,2,2,2],
      [1,1,1,1,1,0,1,2,1,4,4,4,4,4,1,2,1,0,1,1,1,1,1],
      [2,2,2,2,1,0,1,2,1,1,1,1,1,1,1,2,1,0,1,2,2,2,2],
      [1,1,1,1,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1],
      [1,3,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,3,1],
      [1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1],
      [1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1],
      [1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    let maze;
    let totalDots;
    let dotsEaten;

    // --- PAC-MAN ---
    let pacman;
    const PAC_SPEED = 2;

    // --- GHOSTS ---
    let ghosts;
    const GHOST_SPEED = 1.6;
    const GHOST_COLORS = ['#f44', '#f8b', '#0ff', '#f80']; // red, pink, cyan, orange
    const GHOST_NAMES = ['blinky', 'pinky', 'inky', 'clyde'];
    const FRIGHTENED_COLOR = '#44f';
    const FRIGHTENED_FLASH = '#fff';
    let frightenedTimer;
    let frightenedDuration;
    let ghostEatCombo;

    // --- GAME STATE ---
    let score, best = 0, gameState;
    let lives;
    let level;
    let mouthAngle;
    let mouthDir;
    let pelletPulse;
    let lastTime;
    let keys = {};
    let scorePopups = [];

    // Pac-Man start position (tile coords)
    const PAC_START_COL = 11;
    const PAC_START_ROW = 16;

    // Ghost start positions (tile coords, inside ghost house)
    const GHOST_STARTS = [
      { col: 11, row: 9 },   // blinky - starts above house
      { col: 10, row: 10 },  // pinky
      { col: 11, row: 10 },  // inky
      { col: 12, row: 10 },  // clyde
    ];

    // Scatter targets (corners)
    const SCATTER_TARGETS = [
      { col: COLS - 2, row: 1 },   // blinky -> top-right
      { col: 1, row: 1 },          // pinky -> top-left
      { col: COLS - 2, row: ROWS - 2 }, // inky -> bottom-right
      { col: 1, row: ROWS - 2 },   // clyde -> bottom-left
    ];

    function deepCopyMaze() {
      return MAZE_TEMPLATE.map(row => [...row]);
    }

    function countDots(m) {
      let count = 0;
      for (let r = 0; r < m.length; r++) {
        for (let c = 0; c < m[r].length; c++) {
          if (m[r][c] === 0 || m[r][c] === 3) count++;
        }
      }
      return count;
    }

    function tileToPixel(col, row) {
      return { x: col * TILE + TILE / 2, y: row * TILE + TILE / 2 };
    }

    function pixelToTile(x, y) {
      return { col: Math.floor(x / TILE), row: Math.floor(y / TILE) };
    }

    function isWall(col, row) {
      if (row < 0 || row >= maze.length) return true;
      // Tunnel wrapping
      if (col < 0 || col >= COLS) return false;
      return maze[row][col] === 1;
    }

    function isGhostHouse(col, row) {
      if (row < 0 || row >= maze.length || col < 0 || col >= COLS) return false;
      return MAZE_TEMPLATE[row][col] === 4;
    }

    function canMove(col, row, isGhost) {
      if (row < 0 || row >= maze.length) return false;
      // Tunnel
      if (col < 0 || col >= COLS) return true;
      const tile = maze[row][col];
      if (tile === 1) return false;
      if (tile === 4 && !isGhost) return false;
      return true;
    }

    function wrapCol(col) {
      if (col < 0) return COLS - 1;
      if (col >= COLS) return 0;
      return col;
    }

    function createPacman() {
      const pos = tileToPixel(PAC_START_COL, PAC_START_ROW);
      return {
        x: pos.x,
        y: pos.y,
        dir: { x: 0, y: 0 },
        nextDir: { x: -1, y: 0 },
        col: PAC_START_COL,
        row: PAC_START_ROW,
        moving: false,
      };
    }

    function createGhost(index) {
      const start = GHOST_STARTS[index];
      const pos = tileToPixel(start.col, start.row);
      return {
        x: pos.x,
        y: pos.y,
        col: start.col,
        row: start.row,
        dir: { x: 0, y: -1 },
        color: GHOST_COLORS[index],
        name: GHOST_NAMES[index],
        index: index,
        mode: index === 0 ? 'scatter' : 'house', // blinky starts outside
        houseTimer: index * 120, // stagger exits
        frightened: false,
        eaten: false,
        speed: GHOST_SPEED,
      };
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      lives = 3;
      level = 1;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PAC-MAN';
      overlayText.textContent = 'Press SPACE to start';
      resetLevel();
      draw();
    }

    function resetLevel() {
      maze = deepCopyMaze();
      totalDots = countDots(maze);
      dotsEaten = 0;
      pacman = createPacman();
      ghosts = [createGhost(0), createGhost(1), createGhost(2), createGhost(3)];
      frightenedTimer = 0;
      frightenedDuration = Math.max(3000, 8000 - (level - 1) * 1000);
      ghostEatCombo = 0;
      mouthAngle = 0;
      mouthDir = 1;
      pelletPulse = 0;
      lastTime = 0;
      modeTimer = 0;
      modePhase = 0;
      scorePopups = [];
    }

    function resetAfterDeath() {
      pacman = createPacman();
      ghosts = [createGhost(0), createGhost(1), createGhost(2), createGhost(3)];
      frightenedTimer = 0;
      ghostEatCombo = 0;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // --- MOVEMENT ---
    function alignedToTile(entity) {
      const center = tileToPixel(entity.col, entity.row);
      return Math.abs(entity.x - center.x) < 1.5 && Math.abs(entity.y - center.y) < 1.5;
    }

    function snapToTile(entity) {
      const center = tileToPixel(entity.col, entity.row);
      entity.x = center.x;
      entity.y = center.y;
    }

    function updatePacman() {
      // Check if we can turn at current tile
      if (alignedToTile(pacman)) {
        snapToTile(pacman);
        const tile = pixelToTile(pacman.x, pacman.y);
        pacman.col = tile.col;
        pacman.row = tile.row;

        // Try next direction first
        const nextCol = wrapCol(pacman.col + pacman.nextDir.x);
        const nextRow = pacman.row + pacman.nextDir.y;
        if (canMove(nextCol, nextRow, false)) {
          pacman.dir = { ...pacman.nextDir };
          pacman.moving = true;
        } else {
          // Try continuing in current direction
          const contCol = wrapCol(pacman.col + pacman.dir.x);
          const contRow = pacman.row + pacman.dir.y;
          if (!canMove(contCol, contRow, false)) {
            pacman.moving = false;
          }
        }

        // Eat dot
        if (pacman.row >= 0 && pacman.row < maze.length && pacman.col >= 0 && pacman.col < COLS) {
          const tile = maze[pacman.row][pacman.col];
          if (tile === 0) {
            maze[pacman.row][pacman.col] = 2;
            score += 10;
            dotsEaten++;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            scorePopups.push({ x: pacman.x, y: pacman.y - 8, text: '+10', timer: 35, color: '#ffcc80' });
          } else if (tile === 3) {
            maze[pacman.row][pacman.col] = 2;
            score += 50;
            dotsEaten++;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            activateFrightened();
            scorePopups.push({ x: pacman.x, y: pacman.y - 8, text: '+50', timer: 45, color: '#ff0' });
          }
        }

        // Check level complete
        if (dotsEaten >= totalDots) {
          level++;
          resetLevel();
          return;
        }
      }

      if (pacman.moving) {
        pacman.x += pacman.dir.x * PAC_SPEED;
        pacman.y += pacman.dir.y * PAC_SPEED;

        // Tunnel wrapping
        if (pacman.x < -TILE / 2) {
          pacman.x = COLS * TILE + TILE / 2;
        } else if (pacman.x > COLS * TILE + TILE / 2) {
          pacman.x = -TILE / 2;
        }

        // Update tile position
        const t = pixelToTile(pacman.x, pacman.y);
        if (t.col >= 0 && t.col < COLS) {
          pacman.col = t.col;
        }
        pacman.row = t.row;
      }
    }

    function activateFrightened() {
      frightenedTimer = frightenedDuration;
      ghostEatCombo = 0;
      for (const ghost of ghosts) {
        if (ghost.mode !== 'house' && !ghost.eaten) {
          ghost.frightened = true;
          // Reverse direction
          ghost.dir = { x: -ghost.dir.x, y: -ghost.dir.y };
        }
      }
    }

    function getGhostTarget(ghost) {
      if (ghost.frightened) {
        // Random direction at intersections
        return { col: Math.floor(Math.random() * COLS), row: Math.floor(Math.random() * maze.length) };
      }
      if (ghost.eaten) {
        // Return to ghost house
        return { col: 11, row: 10 };
      }
      if (ghost.mode === 'scatter') {
        return SCATTER_TARGETS[ghost.index];
      }
      // Chase mode - different AI for each ghost
      switch (ghost.index) {
        case 0: // Blinky - directly targets pac-man
          return { col: pacman.col, row: pacman.row };
        case 1: // Pinky - targets 4 tiles ahead of pac-man
          return {
            col: Math.max(0, Math.min(COLS - 1, pacman.col + pacman.dir.x * 4)),
            row: Math.max(0, Math.min(maze.length - 1, pacman.row + pacman.dir.y * 4)),
          };
        case 2: // Inky - uses blinky's position to calculate target
          const blinky = ghosts[0];
          const aheadCol = pacman.col + pacman.dir.x * 2;
          const aheadRow = pacman.row + pacman.dir.y * 2;
          return {
            col: Math.max(0, Math.min(COLS - 1, aheadCol + (aheadCol - blinky.col))),
            row: Math.max(0, Math.min(maze.length - 1, aheadRow + (aheadRow - blinky.row))),
          };
        case 3: // Clyde - chases when far, scatters when close
          const dist = Math.abs(ghost.col - pacman.col) + Math.abs(ghost.row - pacman.row);
          if (dist > 8) {
            return { col: pacman.col, row: pacman.row };
          }
          return SCATTER_TARGETS[ghost.index];
        default:
          return { col: pacman.col, row: pacman.row };
      }
    }

    function distSq(c1, r1, c2, r2) {
      return (c1 - c2) * (c1 - c2) + (r1 - r2) * (r1 - r2);
    }

    function updateGhost(ghost, dt) {
      const speedMul = ghost.eaten ? 2.5 : (ghost.frightened ? 0.6 : 1.0);
      const spd = ghost.speed * speedMul * (1 + (level - 1) * 0.08);

      // Ghost house logic
      if (ghost.mode === 'house') {
        ghost.houseTimer -= 1;
        if (ghost.houseTimer <= 0) {
          // Move to exit position
          ghost.mode = 'scatter';
          const exitPos = tileToPixel(11, 8);
          ghost.x = exitPos.x;
          ghost.y = exitPos.y;
          ghost.col = 11;
          ghost.row = 8;
          ghost.dir = { x: -1, y: 0 };
        } else {
          // Bob up and down inside house
          ghost.y += Math.sin(ghost.houseTimer * 0.1) * 0.5;
          return;
        }
      }

      // Eaten ghost returning to house
      if (ghost.eaten) {
        if (ghost.col === 11 && ghost.row === 10 && alignedToTile(ghost)) {
          ghost.eaten = false;
          ghost.frightened = false;
          ghost.mode = 'scatter';
          const pos = tileToPixel(11, 8);
          ghost.x = pos.x;
          ghost.y = pos.y;
          ghost.col = 11;
          ghost.row = 8;
          return;
        }
      }

      if (alignedToTile(ghost)) {
        snapToTile(ghost);
        const t = pixelToTile(ghost.x, ghost.y);
        ghost.col = wrapCol(t.col);
        ghost.row = t.row;

        // Choose next direction
        const target = getGhostTarget(ghost);
        const directions = [
          { x: 0, y: -1 }, // up
          { x: -1, y: 0 }, // left
          { x: 0, y: 1 },  // down
          { x: 1, y: 0 },  // right
        ];

        let bestDir = ghost.dir;
        let bestDist = Infinity;
        const reverse = { x: -ghost.dir.x, y: -ghost.dir.y };

        for (const d of directions) {
          // Cannot reverse direction (unless frightened reversal already done)
          if (d.x === reverse.x && d.y === reverse.y) continue;
          const nextCol = wrapCol(ghost.col + d.x);
          const nextRow = ghost.row + d.y;
          if (!canMove(nextCol, nextRow, true)) continue;
          // Ghosts should not re-enter ghost house unless eaten
          if (!ghost.eaten && isGhostHouse(nextCol, nextRow)) continue;
          const dist = distSq(nextCol, nextRow, target.col, target.row);
          if (dist < bestDist) {
            bestDist = dist;
            bestDir = d;
          }
        }
        ghost.dir = bestDir;
      }

      ghost.x += ghost.dir.x * spd;
      ghost.y += ghost.dir.y * spd;

      // Tunnel wrapping
      if (ghost.x < -TILE / 2) {
        ghost.x = COLS * TILE + TILE / 2;
      } else if (ghost.x > COLS * TILE + TILE / 2) {
        ghost.x = -TILE / 2;
      }

      const t2 = pixelToTile(ghost.x, ghost.y);
      if (t2.col >= 0 && t2.col < COLS) {
        ghost.col = t2.col;
      }
      ghost.row = t2.row;
    }

    // --- MODE SWITCHING ---
    let modeTimer = 0;
    let modePhase = 0;
    const MODE_DURATIONS = [7000, 20000, 7000, 20000, 5000, 20000, 5000]; // scatter/chase alternating

    function updateModes(dt) {
      if (frightenedTimer > 0) {
        frightenedTimer -= dt;
        if (frightenedTimer <= 0) {
          frightenedTimer = 0;
          for (const ghost of ghosts) {
            ghost.frightened = false;
          }
        }
        return;
      }

      modeTimer += dt;
      if (modePhase < MODE_DURATIONS.length && modeTimer >= MODE_DURATIONS[modePhase]) {
        modeTimer = 0;
        modePhase++;
        const newMode = (modePhase % 2 === 0) ? 'scatter' : 'chase';
        for (const ghost of ghosts) {
          if (ghost.mode !== 'house' && !ghost.eaten) {
            ghost.mode = newMode;
            // Reverse direction on mode switch
            ghost.dir = { x: -ghost.dir.x, y: -ghost.dir.y };
          }
        }
      }
    }

    // --- COLLISION ---
    function checkCollisions() {
      for (const ghost of ghosts) {
        if (ghost.mode === 'house') continue;
        const dx = pacman.x - ghost.x;
        const dy = pacman.y - ghost.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < TILE * 0.8) {
          if (ghost.frightened && !ghost.eaten) {
            // Eat ghost
            ghost.eaten = true;
            ghost.frightened = false;
            ghostEatCombo++;
            const bonus = 200 * Math.pow(2, ghostEatCombo - 1);
            score += bonus;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
          } else if (!ghost.eaten) {
            // Pac-Man dies
            lives--;
            if (lives <= 0) {
              gameOver();
            } else {
              resetAfterDeath();
            }
            return;
          }
        }
      }
    }

    // --- UPDATE ---
    function update(dt) {
      // Mouth animation
      mouthAngle += mouthDir * 0.12;
      if (mouthAngle > 0.9) mouthDir = -1;
      if (mouthAngle < 0.05) mouthDir = 1;

      // Power pellet pulse
      pelletPulse += 0.05;

      updatePacman();
      // Decay score popups
      for (let i = scorePopups.length - 1; i >= 0; i--) {
        scorePopups[i].y -= 0.5;
        scorePopups[i].timer--;
        if (scorePopups[i].timer <= 0) scorePopups.splice(i, 1);
      }
      updateModes(dt);
      for (const ghost of ghosts) {
        updateGhost(ghost, dt);
      }
      checkCollisions();

      // Update game data for ML
      window.gameData = {
        pacX: pacman.col,
        pacY: pacman.row,
        pacDir: pacman.dir,
        ghosts: ghosts.map(g => ({ x: g.col, y: g.row, frightened: g.frightened, eaten: g.eaten, mode: g.mode })),
        lives: lives,
        level: level,
        dotsLeft: totalDots - dotsEaten,
      };
    }

    // --- DRAWING ---
    function drawMaze() {
      for (let r = 0; r < maze.length; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = c * TILE;
          const y = r * TILE;
          const tile = maze[r][c];
          if (tile === 1) {
            // Wall
            ctx.fillStyle = '#1a237e';
            ctx.fillRect(x, y, TILE, TILE);
            // Wall borders for depth
            ctx.strokeStyle = '#3949ab';
            ctx.lineWidth = 1;
            // Only draw borders on sides adjacent to non-wall
            const top = r > 0 && maze[r-1][c] !== 1;
            const bot = r < maze.length - 1 && maze[r+1][c] !== 1;
            const left = c > 0 && maze[r][c-1] !== 1;
            const right = c < COLS - 1 && maze[r][c+1] !== 1;
            ctx.beginPath();
            if (top) { ctx.moveTo(x, y + 0.5); ctx.lineTo(x + TILE, y + 0.5); }
            if (bot) { ctx.moveTo(x, y + TILE - 0.5); ctx.lineTo(x + TILE, y + TILE - 0.5); }
            if (left) { ctx.moveTo(x + 0.5, y); ctx.lineTo(x + 0.5, y + TILE); }
            if (right) { ctx.moveTo(x + TILE - 0.5, y); ctx.lineTo(x + TILE - 0.5, y + TILE); }
            ctx.stroke();
          } else if (tile === 0) {
            // Dot
            ctx.fillStyle = '#ffcc80';
            ctx.beginPath();
            ctx.arc(x + TILE / 2, y + TILE / 2, 2.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (tile === 3) {
            // Power pellet (pulsing)
            const pulseSize = 5 + Math.sin(pelletPulse) * 2;
            ctx.fillStyle = '#ffcc80';
            ctx.shadowColor = '#ffcc80';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(x + TILE / 2, y + TILE / 2, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
          // tile 2 = empty, tile 4 = ghost house (draw nothing or subtle)
          if (tile === 4) {
            ctx.fillStyle = '#0d1333';
            ctx.fillRect(x, y, TILE, TILE);
          }
        }
      }

      // Ghost house gate
      ctx.fillStyle = '#f8b';
      ctx.fillRect(10 * TILE, 9 * TILE - 1, 3 * TILE, 2);
    }

    function drawPacman() {
      const angle = pacman.moving ? mouthAngle : 0.25;
      let rotation = 0;
      if (pacman.dir.x === 1) rotation = 0;
      else if (pacman.dir.x === -1) rotation = Math.PI;
      else if (pacman.dir.y === -1) rotation = -Math.PI / 2;
      else if (pacman.dir.y === 1) rotation = Math.PI / 2;

      ctx.save();
      ctx.translate(pacman.x, pacman.y);
      ctx.rotate(rotation);

      ctx.fillStyle = '#fd0';
      ctx.shadowColor = '#fd0';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(0, 0, TILE / 2 - 1, angle, Math.PI * 2 - angle);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.restore();
    }

    function drawGhost(ghost) {
      const x = ghost.x;
      const y = ghost.y;
      const r = TILE / 2 - 1;

      let color;
      if (ghost.eaten) {
        // Just draw eyes
        drawGhostEyes(x, y, ghost.dir);
        return;
      } else if (ghost.frightened) {
        // Flash when time is running out
        if (frightenedTimer < 2000 && Math.floor(frightenedTimer / 200) % 2 === 0) {
          color = FRIGHTENED_FLASH;
        } else {
          color = FRIGHTENED_COLOR;
        }
      } else {
        color = ghost.color;
      }

      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;

      // Ghost body - rounded top
      ctx.beginPath();
      ctx.arc(x, y - 2, r, Math.PI, 0);
      ctx.lineTo(x + r, y + r - 2);
      // Wavy bottom
      const waves = 3;
      const waveW = (r * 2) / waves;
      for (let i = 0; i < waves; i++) {
        const wx = x + r - i * waveW;
        ctx.quadraticCurveTo(wx - waveW / 4, y + r + 3, wx - waveW / 2, y + r - 2);
        ctx.quadraticCurveTo(wx - waveW * 3 / 4, y + r - 7, wx - waveW, y + r - 2);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Eyes
      if (!ghost.frightened) {
        drawGhostEyes(x, y, ghost.dir);
      } else {
        // Frightened face
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x - 3, y - 3, 2, 0, Math.PI * 2);
        ctx.arc(x + 3, y - 3, 2, 0, Math.PI * 2);
        ctx.fill();
        // Wavy mouth
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - 5, y + 3);
        for (let i = 0; i < 5; i++) {
          ctx.lineTo(x - 5 + i * 2.5, y + (i % 2 === 0 ? 3 : 5));
        }
        ctx.stroke();
      }
    }

    function drawGhostEyes(x, y, dir) {
      // White of eye
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x - 3.5, y - 3, 3.5, 4.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 3.5, y - 3, 3.5, 4.5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Pupil
      const px = dir.x * 2;
      const py = dir.y * 2;
      ctx.fillStyle = '#00c';
      ctx.beginPath();
      ctx.arc(x - 3.5 + px, y - 3 + py, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 3.5 + px, y - 3 + py, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawLives() {
      for (let i = 0; i < lives - 1; i++) {
        const lx = 20 + i * 22;
        const ly = maze.length * TILE + (H - maze.length * TILE) / 2;
        ctx.fillStyle = '#fd0';
        ctx.beginPath();
        ctx.arc(lx, ly, 7, 0.25, Math.PI * 2 - 0.25);
        ctx.lineTo(lx, ly);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawLevel() {
      ctx.fillStyle = '#aaa';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('Level ' + level, W - 10, maze.length * TILE + (H - maze.length * TILE) / 2 + 4);
      ctx.textAlign = 'left';
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, W, H);

      drawMaze();
      drawPacman();
      for (const ghost of ghosts) {
        drawGhost(ghost);
      }
      drawLives();
      drawLevel();

      // Score popups
      ctx.font = 'bold 11px "Courier New"';
      ctx.textAlign = 'center';
      for (const sp of scorePopups) {
        const alpha = sp.timer / 45;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = sp.color;
        ctx.shadowColor = sp.color;
        ctx.shadowBlur = 6;
        ctx.fillText(sp.text, sp.x, sp.y);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.textAlign = 'left';
    }

    // --- INPUT ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowLeft':  pacman.nextDir = { x: -1, y: 0 }; break;
          case 'ArrowRight': pacman.nextDir = { x: 1, y: 0 }; break;
          case 'ArrowUp':    pacman.nextDir = { x: 0, y: -1 }; break;
          case 'ArrowDown':  pacman.nextDir = { x: 0, y: 1 }; break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Auction House</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #fa0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 170, 0, 0.5); }
    h1 { color: #fa0; font-size: 1.8rem; text-shadow: 0 0 15px rgba(255, 170, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fa0; }
    canvas {
      border: 2px solid #fa0;
      box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fa0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>AUCTION HOUSE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">$0</span></div>
    <div>Best: <span id="best">$0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">AUCTION HOUSE</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('auctionHouseBest') || '0');
    bestEl.textContent = '$' + bestScore;

    const GOLD = '#fa0';
    const GOLD_GLOW = 'rgba(255,170,0,';
    const BG = '#1a1a2e';
    const PANEL = '#16213e';
    const PANEL_LIGHT = '#1e2d4a';

    const CATEGORIES = [
      { name: 'Fine Art', icon: 'art', baseValue: [800, 2500], color: '#e44' },
      { name: 'Antiques', icon: 'antique', baseValue: [500, 2000], color: '#c96' },
      { name: 'Jewelry', icon: 'jewel', baseValue: [1000, 3500], color: '#4cf' },
      { name: 'Rare Books', icon: 'book', baseValue: [300, 1500], color: '#8b6' },
      { name: 'Vintage Wine', icon: 'wine', baseValue: [400, 1800], color: '#b46' },
      { name: 'Sculptures', icon: 'sculpture', baseValue: [600, 2200], color: '#c8f' },
      { name: 'Timepieces', icon: 'watch', baseValue: [700, 3000], color: '#6cf' },
      { name: 'Maps & Charts', icon: 'map', baseValue: [200, 1200], color: '#da6' },
      { name: 'Coins & Medals', icon: 'coin', baseValue: [300, 1600], color: '#fd4' },
      { name: 'Instruments', icon: 'music', baseValue: [500, 2400], color: '#f86' }
    ];

    const ITEM_NAMES = {
      art: ['Sunset Over Venice','Portrait of a Lady','Abstract Harmony','Mountain Dusk','The Blue Garden','Starlit Harbor','Golden Meadow','Crimson Still Life'],
      antique: ['Victorian Desk','Ming Dynasty Vase','Georgian Mirror','Edwardian Tea Set','Art Deco Lamp','Louis XV Chair','Bronze Candelabra','Ivory Chess Set'],
      jewel: ['Ruby Necklace','Sapphire Ring','Emerald Brooch','Diamond Tiara','Pearl Earrings','Opal Pendant','Topaz Bracelet','Amethyst Crown'],
      book: ['First Ed. Dickens','Illuminated MS','Shakespeare Folio','Gutenberg Leaf','Ancient Atlas','Signed Hemingway','Medieval Psalter','Darwin Origin 1st'],
      wine: ['1945 Mouton','1961 Petrus','1982 Lafite','1990 Romanee-Conti','2000 Margaux','1947 Cheval Blanc','1959 Haut-Brion','1975 Yquem'],
      sculpture: ['Bronze Apollo','Marble Venus','Jade Dragon','Onyx Panther','Crystal Swan','Iron Wolf','Gilt Angel','Ceramic Lion'],
      watch: ['1950s Rolex Sub','Patek 2499','Breguet Tourbillon','AP Royal Oak','Omega Speedmaster','Cartier Tank','Vacheron Patrimony','IWC Portuguese'],
      map: ['16th C. World Map','Celestial Chart','Nautical Atlas','Silk Road Map','Colonial Territory','Ptolemy Print','Treasure Map 1650','Ottoman Map'],
      coin: ['Roman Aureus','Doubloon 1715','Double Eagle 1933','Byzantine Solidus','Athenian Owl','Flowing Hair Dollar','Guinea 1663','Florentine Florin'],
      music: ['Stradivarius','1959 Les Paul','Steinway Grand','Martin D-45','Selmer Mark VI','Amati Cello','Bosendorfer Imp.','Gibson Mandolin']
    };

    const AI_PROFILES = [
      { name: 'Baron Von Rich', strategy: 'aggressive', color: '#e55', riskTol: 1.3, bluffChance: 0.1 },
      { name: 'Lady Prudence', strategy: 'conservative', color: '#5b5', riskTol: 0.7, bluffChance: 0.05 },
      { name: 'The Collector', strategy: 'value-hunter', color: '#58f', riskTol: 1.0, bluffChance: 0.02 },
      { name: 'Sly Fox', strategy: 'bluffer', color: '#f8f', riskTol: 0.9, bluffChance: 0.35 },
      { name: 'Old Money', strategy: 'steady', color: '#cc8', riskTol: 0.85, bluffChance: 0.08 }
    ];

    // Game state
    let players = [];
    let currentItem = null;
    let currentBid = 0;
    let currentBidder = -1; // who placed the current highest bid
    let round = 0;
    let totalRounds = 12;
    let auctionPhase = 'idle'; // 'showing','bidding','sold','results'
    let animTimer = 0;
    let bidButtons = [];
    let messageLog = [];
    let soldAnim = 0;
    let allItems = [];
    let sparkles = [];
    let hoverBtn = -1;
    let showItemTimer = 0;
    let bidIncrement = 100;
    let playerBidAmount = 0;
    let quickBidButtons = [];
    let gaveled = false;
    let gavelTimer = 0;
    let gavelCount = 0;

    // Turn-based bidding: track who has responded to the current bid
    // When someone bids, everyone else needs to respond (bid or pass)
    let respondedToBid = new Set(); // players who have responded to current highest bid
    let waitingForHuman = false;
    let aiActionTimer = 0; // delay before next AI acts
    let nextAiIdx = -1; // which AI acts next

    function rand(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }

    function generateItems() {
      allItems = [];
      const usedNames = new Set();
      for (let i = 0; i < totalRounds; i++) {
        const cat = CATEGORIES[rand(0, CATEGORIES.length - 1)];
        const names = ITEM_NAMES[cat.icon];
        let name;
        do { name = names[rand(0, names.length - 1)]; } while (usedNames.has(name));
        usedNames.add(name);
        const baseVal = rand(cat.baseValue[0], cat.baseValue[1]);
        const variance = 0.6 + Math.random() * 1.2;
        const trueValue = Math.round(baseVal * variance / 10) * 10;
        const estLow = Math.round(baseVal * 0.5 / 50) * 50;
        const estHigh = Math.round(baseVal * 1.6 / 50) * 50;
        allItems.push({
          name, category: cat, trueValue, estLow, estHigh,
          startBid: Math.max(50, Math.round(estLow * 0.4 / 50) * 50),
          winner: -1, winBid: 0
        });
      }
    }

    function initGame() {
      players = [
        { name: 'You', color: GOLD, budget: 10000, items: [], totalSpent: 0, isHuman: true, passed: false }
      ];
      const numAI = rand(3, 4);
      const shuffled = [...AI_PROFILES].sort(() => Math.random() - 0.5);
      for (let i = 0; i < numAI; i++) {
        const p = shuffled[i];
        players.push({
          name: p.name, color: p.color, budget: 10000, items: [],
          totalSpent: 0, isHuman: false, passed: false,
          strategy: p.strategy, riskTol: p.riskTol, bluffChance: p.bluffChance
        });
      }
      round = 0;
      generateItems();
      score = 0;
      scoreEl.textContent = '$0';
      messageLog = [];
      sparkles = [];
      startNextRound();
    }

    function startNextRound() {
      if (round >= totalRounds) { showResults(); return; }
      currentItem = allItems[round];
      currentBid = currentItem.startBid;
      currentBidder = -1;
      auctionPhase = 'showing';
      showItemTimer = 75;
      gaveled = false; gavelTimer = 0; gavelCount = 0;
      for (const p of players) p.passed = false;
      respondedToBid = new Set();
      waitingForHuman = false;
      nextAiIdx = -1;
      aiActionTimer = 0;
      bidIncrement = currentBid < 300 ? 50 : (currentBid < 1000 ? 100 : 150);
      playerBidAmount = currentBid + bidIncrement;
      buildBidButtons();
      addMessage('Lot ' + (round + 1) + '/' + totalRounds + ': ' + currentItem.name);
      round++;
    }

    function buildBidButtons() {
      bidButtons = [
        { x: 400, y: 398, w: 85, h: 30, label: 'BID', action: 'bid' },
        { x: 500, y: 398, w: 85, h: 30, label: 'PASS', action: 'pass' }
      ];
      quickBidButtons = [];
      const increments = [50, 100, 250, 500];
      for (let i = 0; i < increments.length; i++) {
        quickBidButtons.push({
          x: 400 + i * 47, y: 365, w: 43, h: 22,
          label: '+' + increments[i], value: increments[i]
        });
      }
    }

    function addMessage(msg) {
      messageLog.unshift({ text: msg, time: 240 });
      if (messageLog.length > 8) messageLog.pop();
    }

    // After someone bids, schedule responses from everyone who hasn't responded
    function scheduleResponses() {
      // Find next AI that needs to respond
      waitingForHuman = false;
      nextAiIdx = -1;
      // Check if human needs to respond
      if (!players[0].passed && !respondedToBid.has(0) && currentBidder !== 0) {
        waitingForHuman = true;
      }
      // Find an AI to respond
      for (let i = 1; i < players.length; i++) {
        if (!players[i].passed && !respondedToBid.has(i) && currentBidder !== i) {
          nextAiIdx = i;
          aiActionTimer = rand(20, 45);
          return;
        }
      }
      // No AI needs to respond; if human doesn't either, check end
      if (!waitingForHuman) {
        checkAuctionEnd();
      }
    }

    function playerBid() {
      if (auctionPhase !== 'bidding' || players[0].passed) return;
      if (playerBidAmount > players[0].budget) return;
      if (currentBidder !== -1 && playerBidAmount <= currentBid) return;
      currentBid = playerBidAmount;
      currentBidder = 0;
      addMessage('You bid $' + currentBid);
      // New bid: everyone else must respond
      respondedToBid = new Set();
      respondedToBid.add(0);
      playerBidAmount = currentBid + bidIncrement;
      gaveled = false; gavelCount = 0;
      waitingForHuman = false;
      scheduleResponses();
    }

    function playerPass() {
      if (auctionPhase !== 'bidding' || players[0].passed) return;
      players[0].passed = true;
      respondedToBid.add(0);
      addMessage('You pass');
      waitingForHuman = false;
      scheduleResponses();
    }

    function aiDecide(idx) {
      const ai = players[idx];
      if (ai.passed || ai.budget < currentBid + bidIncrement) {
        ai.passed = true;
        respondedToBid.add(idx);
        addMessage(ai.name + ' passes');
        scheduleResponses();
        return;
      }
      const item = currentItem;
      let estValue = (item.estLow + item.estHigh) / 2;
      const personalBias = (Math.random() - 0.5) * 0.4 + 1.0;
      estValue *= personalBias * ai.riskTol;
      let maxWilling = estValue;
      switch (ai.strategy) {
        case 'aggressive': maxWilling = estValue * (1.1 + Math.random() * 0.3); break;
        case 'conservative': maxWilling = estValue * (0.6 + Math.random() * 0.2); break;
        case 'value-hunter':
          if (currentBid > estValue * 0.7) {
            ai.passed = true; respondedToBid.add(idx);
            addMessage(ai.name + ' passes'); scheduleResponses(); return;
          }
          maxWilling = estValue * 0.85; break;
        case 'bluffer':
          if (Math.random() < ai.bluffChance) maxWilling = estValue * (1.5 + Math.random());
          else maxWilling = estValue * (0.7 + Math.random() * 0.3); break;
        case 'steady': maxWilling = estValue * (0.8 + Math.random() * 0.2); break;
      }
      const budgetRatio = ai.budget / 10000;
      if (budgetRatio < 0.3) maxWilling *= 0.7;
      else if (budgetRatio < 0.5) maxWilling *= 0.85;
      const itemsLeft = totalRounds - round + 1;
      if (itemsLeft <= 3 && ai.items.length === 0) maxWilling *= 1.3;
      const nextBid = currentBid + bidIncrement + rand(0, 2) * 50;
      if (nextBid <= maxWilling && nextBid <= ai.budget) {
        currentBid = nextBid;
        currentBidder = idx;
        addMessage(ai.name + ' bids $' + currentBid);
        // New bid: reset responses
        respondedToBid = new Set();
        respondedToBid.add(idx);
        playerBidAmount = Math.max(playerBidAmount, currentBid + bidIncrement);
        gaveled = false; gavelCount = 0;
        scheduleResponses();
      } else {
        ai.passed = true;
        respondedToBid.add(idx);
        addMessage(ai.name + ' passes');
        scheduleResponses();
      }
    }

    function checkAuctionEnd() {
      // Everyone has responded to current bid
      if (currentBidder >= 0) {
        // All others have either passed permanently or responded
        let allDone = true;
        for (let i = 0; i < players.length; i++) {
          if (i !== currentBidder && !players[i].passed) { allDone = false; break; }
        }
        if (allDone) {
          if (!gaveled) { gaveled = true; gavelTimer = 45; gavelCount = 0; }
        }
      } else {
        // No one bid at all
        let anyActive = false;
        for (let i = 0; i < players.length; i++) { if (!players[i].passed) { anyActive = true; break; } }
        if (!anyActive) {
          auctionPhase = 'sold'; soldAnim = 70;
          currentItem.winner = -1;
          addMessage(currentItem.name + ' goes unsold!');
        }
      }
    }

    function sellItem() {
      const winner = currentBidder;
      const price = currentBid;
      currentItem.winner = winner;
      currentItem.winBid = price;
      players[winner].budget -= price;
      players[winner].totalSpent += price;
      players[winner].items.push({ ...currentItem, pricePaid: price });
      if (winner === 0) {
        addMessage('You won ' + currentItem.name + ' for $' + price + '!');
        for (let i = 0; i < 15; i++) {
          sparkles.push({
            x: 200 + Math.random() * 200, y: 80 + Math.random() * 80,
            vx: (Math.random() - 0.5) * 4, vy: -Math.random() * 3 - 1,
            life: rand(30, 60), maxLife: 60
          });
        }
      } else {
        addMessage(players[winner].name + ' wins ' + currentItem.name + ' for $' + price);
      }
      auctionPhase = 'sold'; soldAnim = 85;
    }

    function showResults() {
      auctionPhase = 'results';
      for (const p of players) {
        p.totalValue = 0;
        for (const item of p.items) p.totalValue += item.trueValue;
        p.profit = p.totalValue - p.totalSpent;
      }
      score = players[0].profit;
      scoreEl.textContent = '$' + score;
      if (score > bestScore) {
        bestScore = score;
        bestEl.textContent = '$' + bestScore;
        localStorage.setItem('auctionHouseBest', bestScore.toString());
      }
      gameState = 'over';
    }

    // === Drawing ===
    function drawIcon(cx, cy, size, type, color) {
      ctx.save();
      ctx.strokeStyle = color; ctx.fillStyle = color;
      ctx.lineWidth = 1.5; ctx.shadowColor = color; ctx.shadowBlur = 6;
      switch (type) {
        case 'art':
          ctx.strokeRect(cx - size, cy - size * 0.8, size * 2, size * 1.6);
          ctx.strokeRect(cx - size + 2, cy - size * 0.8 + 2, size * 2 - 4, size * 1.6 - 4);
          ctx.beginPath();
          ctx.moveTo(cx - size + 4, cy + size * 0.5);
          ctx.lineTo(cx - size * 0.3, cy - size * 0.2);
          ctx.lineTo(cx, cy + size * 0.1);
          ctx.lineTo(cx + size * 0.4, cy - size * 0.4);
          ctx.lineTo(cx + size - 4, cy + size * 0.5);
          ctx.stroke();
          break;
        case 'antique':
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.3, cy - size);
          ctx.quadraticCurveTo(cx - size * 0.8, cy - size * 0.3, cx - size * 0.5, cy + size * 0.5);
          ctx.lineTo(cx - size * 0.6, cy + size);
          ctx.lineTo(cx + size * 0.6, cy + size);
          ctx.lineTo(cx + size * 0.5, cy + size * 0.5);
          ctx.quadraticCurveTo(cx + size * 0.8, cy - size * 0.3, cx + size * 0.3, cy - size);
          ctx.closePath(); ctx.stroke();
          break;
        case 'jewel':
          ctx.beginPath();
          ctx.moveTo(cx, cy - size);
          ctx.lineTo(cx + size, cy - size * 0.2);
          ctx.lineTo(cx + size * 0.6, cy + size);
          ctx.lineTo(cx - size * 0.6, cy + size);
          ctx.lineTo(cx - size, cy - size * 0.2);
          ctx.closePath(); ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - size, cy - size * 0.2); ctx.lineTo(cx + size, cy - size * 0.2);
          ctx.moveTo(cx - size * 0.5, cy - size * 0.2); ctx.lineTo(cx, cy + size);
          ctx.moveTo(cx + size * 0.5, cy - size * 0.2); ctx.lineTo(cx, cy + size);
          ctx.stroke();
          break;
        case 'book':
          ctx.beginPath();
          ctx.moveTo(cx, cy - size * 0.8); ctx.lineTo(cx, cy + size * 0.8);
          ctx.moveTo(cx, cy - size * 0.8);
          ctx.quadraticCurveTo(cx - size, cy - size * 0.6, cx - size, cy + size * 0.6);
          ctx.lineTo(cx, cy + size * 0.8);
          ctx.moveTo(cx, cy - size * 0.8);
          ctx.quadraticCurveTo(cx + size, cy - size * 0.6, cx + size, cy + size * 0.6);
          ctx.lineTo(cx, cy + size * 0.8);
          ctx.stroke();
          break;
        case 'wine':
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.15, cy - size);
          ctx.lineTo(cx - size * 0.15, cy - size * 0.5);
          ctx.quadraticCurveTo(cx - size * 0.5, cy - size * 0.3, cx - size * 0.4, cy + size * 0.7);
          ctx.lineTo(cx + size * 0.4, cy + size * 0.7);
          ctx.quadraticCurveTo(cx + size * 0.5, cy - size * 0.3, cx + size * 0.15, cy - size * 0.5);
          ctx.lineTo(cx + size * 0.15, cy - size);
          ctx.closePath(); ctx.stroke();
          break;
        case 'sculpture':
          ctx.beginPath(); ctx.arc(cx, cy - size * 0.4, size * 0.45, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.6, cy + size);
          ctx.quadraticCurveTo(cx - size * 0.4, cy + size * 0.15, cx - size * 0.25, cy + size * 0.15);
          ctx.lineTo(cx + size * 0.25, cy + size * 0.15);
          ctx.quadraticCurveTo(cx + size * 0.4, cy + size * 0.15, cx + size * 0.6, cy + size);
          ctx.stroke();
          break;
        case 'watch':
          ctx.beginPath(); ctx.arc(cx, cy, size * 0.75, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - size * 0.45);
          ctx.moveTo(cx, cy); ctx.lineTo(cx + size * 0.3, cy);
          ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx, cy - size * 0.75); ctx.lineTo(cx, cy - size); ctx.stroke();
          break;
        case 'map':
          ctx.strokeRect(cx - size * 0.8, cy - size * 0.7, size * 1.6, size * 1.4);
          var mx2 = cx - size * 0.15, my2 = cy;
          ctx.beginPath();
          ctx.moveTo(mx2 - size * 0.2, my2 - size * 0.2); ctx.lineTo(mx2 + size * 0.2, my2 + size * 0.2);
          ctx.moveTo(mx2 + size * 0.2, my2 - size * 0.2); ctx.lineTo(mx2 - size * 0.2, my2 + size * 0.2);
          ctx.stroke();
          break;
        case 'coin':
          ctx.beginPath(); ctx.arc(cx, cy, size * 0.75, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(cx, cy, size * 0.55, 0, Math.PI * 2); ctx.stroke();
          ctx.font = (size * 0.7) + 'px Courier New';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('$', cx, cy + 1);
          break;
        case 'music':
          ctx.beginPath(); ctx.arc(cx - size * 0.2, cy + size * 0.35, size * 0.3, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.2 + size * 0.3, cy + size * 0.35);
          ctx.lineTo(cx - size * 0.2 + size * 0.3, cy - size * 0.7);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.2 + size * 0.3, cy - size * 0.7);
          ctx.quadraticCurveTo(cx + size * 0.5, cy - size * 0.4, cx - size * 0.2 + size * 0.3, cy - size * 0.15);
          ctx.stroke();
          break;
      }
      ctx.restore();
    }

    function roundRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r); ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r); ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r); ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r); ctx.closePath();
    }

    function drawItemCard(item, x, y, w, h, showValue) {
      ctx.save();
      ctx.fillStyle = PANEL; ctx.strokeStyle = item.category.color;
      ctx.lineWidth = 2; ctx.shadowColor = item.category.color; ctx.shadowBlur = 12;
      roundRect(x, y, w, h, 8); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

      ctx.fillStyle = item.category.color;
      ctx.font = '10px Courier New'; ctx.textAlign = 'center';
      ctx.fillText(item.category.name.toUpperCase(), x + w / 2, y + 16);

      drawIcon(x + w / 2, y + 55, 18, item.category.icon, item.category.color);

      ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Courier New'; ctx.textAlign = 'center';
      var words = item.name.split(' '), line = '', ly = y + 90;
      for (var wi = 0; wi < words.length; wi++) {
        var test = line + (line ? ' ' : '') + words[wi];
        if (ctx.measureText(test).width > w - 16) {
          ctx.fillText(line, x + w / 2, ly); line = words[wi]; ly += 13;
        } else line = test;
      }
      ctx.fillText(line, x + w / 2, ly);

      ly += 18;
      ctx.fillStyle = '#888'; ctx.font = '9px Courier New';
      ctx.fillText('Est. Value', x + w / 2, ly);
      ly += 12;
      ctx.fillStyle = GOLD; ctx.font = 'bold 11px Courier New';
      ctx.fillText('$' + item.estLow + ' - $' + item.estHigh, x + w / 2, ly);

      if (showValue) {
        ly += 16;
        ctx.fillStyle = '#4f4'; ctx.font = 'bold 12px Courier New';
        ctx.fillText('TRUE: $' + item.trueValue, x + w / 2, ly);
      }
      ctx.restore();
    }

    function drawButton(btn, hover, disabled) {
      ctx.save();
      var col = disabled ? '#444' : (hover ? '#fc2' : GOLD);
      ctx.fillStyle = disabled ? '#222' : (hover ? PANEL_LIGHT : PANEL);
      ctx.strokeStyle = col; ctx.lineWidth = hover ? 2 : 1;
      if (hover && !disabled) { ctx.shadowColor = GOLD; ctx.shadowBlur = 10; }
      roundRect(btn.x, btn.y, btn.w, btn.h, 4); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
      ctx.fillStyle = col; ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2);
      ctx.restore();
    }

    function drawPlayerPanel(p, idx, x, y, w, h) {
      ctx.save();
      var isCurrent = (currentBidder === idx);
      ctx.fillStyle = isCurrent ? 'rgba(255,170,0,0.08)' : PANEL;
      ctx.strokeStyle = isCurrent ? GOLD : (p.passed ? '#333' : p.color);
      ctx.lineWidth = isCurrent ? 2 : 1;
      if (isCurrent) { ctx.shadowColor = GOLD; ctx.shadowBlur = 8; }
      roundRect(x, y, w, h, 4); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

      ctx.fillStyle = p.passed ? '#555' : p.color;
      ctx.font = 'bold 10px Courier New'; ctx.textAlign = 'left';
      ctx.fillText(p.isHuman ? 'YOU' : p.name, x + 6, y + 13);

      ctx.fillStyle = p.passed ? '#444' : '#aaa'; ctx.font = '9px Courier New';
      ctx.fillText('$' + p.budget, x + 6, y + 26);

      ctx.textAlign = 'right';
      ctx.fillStyle = p.passed ? '#444' : '#666';
      ctx.fillText(p.items.length + ' items', x + w - 6, y + 13);

      if (p.passed && auctionPhase === 'bidding') {
        ctx.fillStyle = '#644'; ctx.textAlign = 'right';
        ctx.fillText('PASSED', x + w - 6, y + 26);
      } else if (isCurrent) {
        ctx.fillStyle = GOLD; ctx.textAlign = 'right'; ctx.font = 'bold 9px Courier New';
        ctx.fillText('LEADING', x + w - 6, y + 26);
      }
      ctx.restore();
    }

    function drawCollection() {
      var y0 = 440;
      ctx.fillStyle = '#666'; ctx.font = '9px Courier New'; ctx.textAlign = 'left';
      ctx.fillText('YOUR COLLECTION:', 15, y0);
      var items = players[0].items;
      if (items.length === 0) {
        ctx.fillStyle = '#444'; ctx.fillText('No items yet', 15, y0 + 14);
      } else {
        var maxShow = Math.min(items.length, 10);
        for (var i = 0; i < maxShow; i++) {
          var ix = 15 + i * 46;
          ctx.save();
          ctx.fillStyle = PANEL; ctx.strokeStyle = items[i].category.color; ctx.lineWidth = 1;
          roundRect(ix, y0 + 4, 42, 42, 3); ctx.fill(); ctx.stroke();
          drawIcon(ix + 21, y0 + 22, 10, items[i].category.icon, items[i].category.color);
          ctx.fillStyle = '#888'; ctx.font = '7px Courier New'; ctx.textAlign = 'center';
          ctx.fillText('$' + items[i].pricePaid, ix + 21, y0 + 42);
          ctx.restore();
        }
        if (items.length > 10) {
          ctx.fillStyle = '#666'; ctx.font = '9px Courier New'; ctx.textAlign = 'left';
          ctx.fillText('+' + (items.length - 10), 15 + 10 * 46, y0 + 26);
        }
      }
      ctx.fillStyle = '#888'; ctx.font = '10px Courier New'; ctx.textAlign = 'right';
      ctx.fillText('Budget:', W - 90, y0);
      ctx.fillStyle = players[0].budget < 1000 ? '#f44' : GOLD;
      ctx.font = 'bold 12px Courier New';
      ctx.fillText('$' + players[0].budget, W - 15, y0);
      ctx.fillStyle = '#666'; ctx.font = '9px Courier New';
      ctx.fillText('Spent: $' + players[0].totalSpent, W - 15, y0 + 14);
    }

    function drawMessages() {
      ctx.save();
      var mx = 15, my = 200;
      ctx.font = '9px Courier New'; ctx.textAlign = 'left';
      for (var i = 0; i < messageLog.length; i++) {
        var msg = messageLog[i];
        var alpha = Math.min(1, msg.time / 80);
        ctx.fillStyle = 'rgba(170,170,170,' + alpha + ')';
        ctx.fillText(msg.text, mx, my + i * 12);
      }
      ctx.restore();
    }

    function drawSparkles() {
      for (var i = 0; i < sparkles.length; i++) {
        var s = sparkles[i], alpha = s.life / s.maxLife;
        ctx.save();
        ctx.fillStyle = GOLD_GLOW + alpha + ')';
        ctx.shadowColor = GOLD; ctx.shadowBlur = 6;
        ctx.fillRect(s.x - 2, s.y - 2, 4, 4);
        ctx.restore();
      }
    }

    function drawResults() {
      ctx.save();
      ctx.fillStyle = GOLD; ctx.shadowColor = GOLD; ctx.shadowBlur = 15;
      ctx.font = 'bold 24px Courier New'; ctx.textAlign = 'center';
      ctx.fillText('AUCTION RESULTS', W / 2, 35);
      ctx.shadowBlur = 0;

      var sorted = [...players].sort(function(a, b) { return b.profit - a.profit; });
      var startY = 55, rowH = 62;

      for (var i = 0; i < sorted.length; i++) {
        var p = sorted[i], y = startY + i * rowH, isP = p.isHuman;
        ctx.fillStyle = isP ? 'rgba(255,170,0,0.08)' : PANEL;
        ctx.strokeStyle = isP ? GOLD : (i === 0 ? '#fd4' : '#333');
        ctx.lineWidth = isP ? 2 : 1;
        roundRect(20, y, W - 40, rowH - 5, 6); ctx.fill(); ctx.stroke();

        ctx.fillStyle = i === 0 ? '#fd4' : '#888';
        ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'left';
        ctx.fillText('#' + (i + 1), 32, y + 22);

        ctx.fillStyle = p.color; ctx.font = 'bold 12px Courier New';
        ctx.fillText(p.name, 70, y + 16);

        if (!p.isHuman) {
          ctx.fillStyle = '#555'; ctx.font = '9px Courier New';
          ctx.fillText('(' + p.strategy + ')', 70, y + 28);
        }

        ctx.fillStyle = '#888'; ctx.font = '9px Courier New';
        ctx.fillText(p.items.length + ' items won', 70, y + 44);

        ctx.textAlign = 'right'; ctx.fillStyle = '#aaa'; ctx.font = '9px Courier New';
        ctx.fillText('Spent: $' + p.totalSpent, W - 180, y + 16);
        ctx.fillText('Value: $' + p.totalValue, W - 180, y + 30);

        ctx.fillStyle = p.profit >= 0 ? '#4f4' : '#f44';
        ctx.font = 'bold 14px Courier New';
        ctx.fillText((p.profit >= 0 ? '+' : '') + '$' + p.profit, W - 35, y + 25);

        if (i === 0) {
          ctx.fillStyle = '#fd4'; ctx.font = '16px Courier New'; ctx.textAlign = 'right';
          ctx.fillText('\u2605', W - 35, y + 48);
        }

        var iconStartX = 200;
        for (var j = 0; j < p.items.length && j < 7; j++) {
          drawIcon(iconStartX + j * 26, y + 46, 6, p.items[j].category.icon, p.items[j].category.color);
        }
      }

      var unsold = allItems.filter(function(it) { return it.winner === -1; });
      if (unsold.length > 0) {
        var uy = startY + sorted.length * rowH + 5;
        ctx.fillStyle = '#555'; ctx.font = '10px Courier New'; ctx.textAlign = 'left';
        var names = unsold.map(function(u) { return u.name; }).join(', ');
        ctx.fillText('Unsold: ' + names, 25, uy);
      }

      ctx.fillStyle = GOLD_GLOW + (0.5 + Math.sin(animTimer * 0.05) * 0.3) + ')';
      ctx.font = '12px Courier New'; ctx.textAlign = 'center';
      ctx.fillText('Click to Play Again', W / 2, H - 15);
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, W, H); ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);
      if (auctionPhase === 'results') { drawResults(); return; }

      // Item card (left side)
      if (currentItem) {
        drawItemCard(currentItem, 15, 10, 160, 165, auctionPhase === 'sold' && currentItem.winner >= 0);
      }

      // Round info
      ctx.fillStyle = '#666'; ctx.font = '10px Courier New'; ctx.textAlign = 'left';
      ctx.fillText('Round ' + round + '/' + totalRounds, 20, 190);

      // Bidding display (center/right)
      if (auctionPhase === 'showing' || auctionPhase === 'bidding') {
        ctx.save();
        ctx.fillStyle = GOLD; ctx.shadowColor = GOLD; ctx.shadowBlur = 15;
        ctx.font = 'bold 28px Courier New'; ctx.textAlign = 'center';
        ctx.fillText('$' + currentBid, 380, 42);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#888'; ctx.font = '11px Courier New';
        if (currentBidder >= 0) ctx.fillText('Current bid by ' + players[currentBidder].name, 380, 62);
        else ctx.fillText('Starting bid', 380, 62);
        ctx.restore();

        if (gaveled) {
          ctx.save();
          var pa = 0.5 + Math.sin(animTimer * 0.15) * 0.3;
          ctx.fillStyle = GOLD_GLOW + pa + ')';
          ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center';
          var gt = gavelCount === 0 ? 'Going once...' : gavelCount === 1 ? 'Going twice...' : 'SOLD!';
          ctx.fillText(gt, 380, 84);
          ctx.restore();
        }

        if (auctionPhase === 'showing') {
          ctx.fillStyle = GOLD_GLOW + '0.5)';
          ctx.font = '11px Courier New'; ctx.textAlign = 'center';
          ctx.fillText('Presenting next item...', 380, 84);
        }
      }

      // Sold overlay
      if (auctionPhase === 'sold' && soldAnim > 0) {
        ctx.save();
        var alpha = Math.min(1, soldAnim / 30);
        if (currentItem.winner >= 0) {
          ctx.fillStyle = GOLD_GLOW + alpha + ')'; ctx.shadowColor = GOLD; ctx.shadowBlur = 20;
          ctx.font = 'bold 22px Courier New'; ctx.textAlign = 'center';
          ctx.fillText('SOLD!', 380, 38);
          ctx.shadowBlur = 0;
          ctx.fillStyle = 'rgba(255,255,255,' + alpha + ')'; ctx.font = '12px Courier New';
          ctx.fillText('to ' + players[currentItem.winner].name + ' for $' + currentItem.winBid, 380, 58);
          var profitOnItem = currentItem.trueValue - currentItem.winBid;
          ctx.fillStyle = profitOnItem >= 0 ? 'rgba(80,255,80,' + alpha + ')' : 'rgba(255,80,80,' + alpha + ')';
          ctx.font = 'bold 11px Courier New';
          ctx.fillText('True Value: $' + currentItem.trueValue + ' (' + (profitOnItem >= 0 ? '+' : '') + profitOnItem + ')', 380, 78);
        } else {
          ctx.fillStyle = 'rgba(150,150,150,' + alpha + ')';
          ctx.font = 'bold 18px Courier New'; ctx.textAlign = 'center';
          ctx.fillText('NO SALE', 380, 48);
        }
        ctx.restore();
      }

      // Player panels
      var panelX = 195, panelW = 390, panelRowH = 34;
      for (var i = 0; i < players.length; i++) {
        var px = panelX + (i % 2) * (panelW / 2 + 5);
        var py = 96 + Math.floor(i / 2) * (panelRowH + 4);
        drawPlayerPanel(players[i], i, px, py, panelW / 2 - 5, panelRowH);
      }

      // Bid controls
      if (auctionPhase === 'bidding' && !players[0].passed) {
        ctx.save();
        ctx.fillStyle = 'rgba(22,33,62,0.6)';
        roundRect(392, 325, 200, 115, 6); ctx.fill();
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        roundRect(392, 325, 200, 115, 6); ctx.stroke();
        ctx.restore();

        ctx.fillStyle = '#aaa'; ctx.font = '10px Courier New'; ctx.textAlign = 'left';
        ctx.fillText('Your bid:', 400, 345);
        ctx.fillStyle = playerBidAmount > players[0].budget ? '#f44' : GOLD;
        ctx.font = 'bold 14px Courier New';
        ctx.fillText('$' + playerBidAmount, 470, 345);

        for (var i = 0; i < quickBidButtons.length; i++) {
          drawButton(quickBidButtons[i], hoverBtn === 100 + i, false);
        }
        var canBid = playerBidAmount <= players[0].budget && (playerBidAmount > currentBid || currentBidder === -1);
        drawButton(bidButtons[0], hoverBtn === 0, !canBid);
        drawButton(bidButtons[1], hoverBtn === 1, false);

        // Waiting indicator
        if (waitingForHuman) {
          ctx.fillStyle = GOLD_GLOW + (0.5 + Math.sin(animTimer * 0.1) * 0.3) + ')';
          ctx.font = '9px Courier New'; ctx.textAlign = 'center';
          ctx.fillText('Your turn to respond!', 492, 318);
        }
      } else if (auctionPhase === 'bidding' && players[0].passed) {
        ctx.fillStyle = '#555'; ctx.font = '11px Courier New'; ctx.textAlign = 'center';
        ctx.fillText('You passed. Watching...', 490, 385);
      }

      drawCollection();
      drawMessages();
      drawSparkles();
    }

    function update() {
      animTimer++;
      for (var i = messageLog.length - 1; i >= 0; i--) {
        messageLog[i].time--;
        if (messageLog[i].time <= 0) messageLog.splice(i, 1);
      }
      for (var i = sparkles.length - 1; i >= 0; i--) {
        sparkles[i].x += sparkles[i].vx;
        sparkles[i].y += sparkles[i].vy;
        sparkles[i].vy += 0.05;
        sparkles[i].life--;
        if (sparkles[i].life <= 0) sparkles.splice(i, 1);
      }
      if (gameState !== 'playing') return;

      // Show item phase
      if (auctionPhase === 'showing') {
        showItemTimer--;
        if (showItemTimer <= 0) {
          auctionPhase = 'bidding';
          // Start bidding: no one has responded yet. Schedule first AI response
          respondedToBid = new Set();
          scheduleResponses();
        }
      }

      // AI action timer
      if (auctionPhase === 'bidding' && nextAiIdx >= 0) {
        aiActionTimer--;
        if (aiActionTimer <= 0) {
          var idx = nextAiIdx;
          nextAiIdx = -1;
          aiDecide(idx);
        }
      }

      // Gavel countdown
      if (gaveled && nextAiIdx < 0) {
        gavelTimer--;
        if (gavelTimer <= 0) {
          gavelCount++;
          if (gavelCount >= 3) sellItem();
          else gavelTimer = 40;
        }
      }

      // Sold animation
      if (auctionPhase === 'sold') {
        soldAnim--;
        if (soldAnim <= 0) startNextRound();
      }
    }

    // Input
    var mouseX = 0, mouseY = 0;

    canvas.addEventListener('mousemove', function(e) {
      var rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);
      hoverBtn = -1;
      if (auctionPhase === 'bidding' && !players[0].passed) {
        for (var i = 0; i < bidButtons.length; i++) {
          var b = bidButtons[i];
          if (mouseX >= b.x && mouseX <= b.x + b.w && mouseY >= b.y && mouseY <= b.y + b.h) hoverBtn = i;
        }
        for (var i = 0; i < quickBidButtons.length; i++) {
          var b = quickBidButtons[i];
          if (mouseX >= b.x && mouseX <= b.x + b.w && mouseY >= b.y && mouseY <= b.y + b.h) hoverBtn = 100 + i;
        }
      }
    });

    canvas.addEventListener('click', function(e) {
      var rect = canvas.getBoundingClientRect();
      var cx = (e.clientX - rect.left) * (W / rect.width);
      var cy = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        gameState = 'playing'; overlay.style.display = 'none'; initGame(); return;
      }
      if (gameState === 'over') {
        if (auctionPhase === 'results') { gameState = 'playing'; initGame(); } return;
      }
      if (auctionPhase === 'bidding' && !players[0].passed) {
        var b0 = bidButtons[0];
        if (cx >= b0.x && cx <= b0.x + b0.w && cy >= b0.y && cy <= b0.y + b0.h) { playerBid(); return; }
        var b1 = bidButtons[1];
        if (cx >= b1.x && cx <= b1.x + b1.w && cy >= b1.y && cy <= b1.y + b1.h) { playerPass(); return; }
        for (var i = 0; i < quickBidButtons.length; i++) {
          var qb = quickBidButtons[i];
          if (cx >= qb.x && cx <= qb.x + qb.w && cy >= qb.y && cy <= qb.y + qb.h) {
            playerBidAmount += qb.value; return;
          }
        }
      }
    });

    overlay.addEventListener('click', function() {
      if (gameState === 'waiting') { gameState = 'playing'; overlay.style.display = 'none'; initGame(); }
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

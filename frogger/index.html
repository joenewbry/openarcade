<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Frogger</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #4e8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 238, 136, 0.4); }
    h1 { color: #4e8; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 238, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4e8; }
    canvas {
      border: 2px solid #4e8;
      box-shadow: 0 0 20px rgba(68, 238, 136, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4e8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>FROGGER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">FROGGER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid layout: 14 rows, each 40px tall = 560px
    const CELL = 40;
    const COLS = W / CELL; // 12
    const ROWS = H / CELL; // 14

    // Row assignments (from top, row 0 to row 13):
    // Row 0: Home row (5 lily pad slots)
    // Rows 1-5: River lanes (logs and turtles)
    // Row 6: Safe zone (median)
    // Rows 7-11: Road lanes (cars and trucks)
    // Row 12: Safe zone (sidewalk)
    // Row 13: Start zone

    const HOME_ROW = 0;
    const RIVER_START = 1;
    const RIVER_END = 5;
    const MEDIAN_ROW = 6;
    const ROAD_START = 7;
    const ROAD_END = 11;
    const SIDEWALK_ROW = 12;
    const START_ROW = 13;

    // Home positions (5 lily pads evenly spaced)
    const HOME_POSITIONS = [1, 3, 5, 7, 9]; // column positions (each pad is 2 cells wide conceptually)
    const HOME_WIDTH = 2; // cells wide for each home slot

    // Lane definitions: direction (1=right, -1=left), speed, objects
    // Road lanes (rows 7-11)
    const LANE_DEFS = {
      // Road lanes
      7:  { type: 'road', dir: -1, baseSpeed: 1.2, objType: 'car',   objLen: 1.5, gap: 4, color: '#f44' },
      8:  { type: 'road', dir:  1, baseSpeed: 1.8, objType: 'truck', objLen: 2.5, gap: 5, color: '#ff0' },
      9:  { type: 'road', dir: -1, baseSpeed: 1.0, objType: 'car',   objLen: 1.5, gap: 3.5, color: '#f80' },
      10: { type: 'road', dir:  1, baseSpeed: 2.2, objType: 'car',   objLen: 1.5, gap: 4.5, color: '#f0f' },
      11: { type: 'road', dir: -1, baseSpeed: 1.5, objType: 'truck', objLen: 3,   gap: 6, color: '#88f' },
      // River lanes
      1:  { type: 'river', dir:  1, baseSpeed: 0.8, objType: 'log',    objLen: 3,   gap: 4, color: '#a52' },
      2:  { type: 'river', dir: -1, baseSpeed: 1.2, objType: 'turtle', objLen: 2,   gap: 3.5, color: '#0a6', diveInterval: 300 },
      3:  { type: 'river', dir:  1, baseSpeed: 1.0, objType: 'log',    objLen: 4,   gap: 5, color: '#a52' },
      4:  { type: 'river', dir: -1, baseSpeed: 0.6, objType: 'turtle', objLen: 3,   gap: 4, color: '#0a6', diveInterval: 400 },
      5:  { type: 'river', dir:  1, baseSpeed: 1.4, objType: 'log',    objLen: 2,   gap: 3, color: '#a52' },
    };

    let score, best = 0, gameState;
    let lives, level, frogX, frogY, frogMaxRow;
    let lanes; // lane objects
    let homes; // which homes are filled
    let timeLeft, maxTime, timerInterval;
    let deathAnim, deathTimer;

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      maxTime = 30; // seconds
      timeLeft = maxTime;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      homes = [false, false, false, false, false];
      initLanes();
      resetFrog();
      deathAnim = null;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'FROGGER';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function initLanes() {
      lanes = {};
      for (const [row, def] of Object.entries(LANE_DEFS)) {
        const r = parseInt(row);
        const speedMult = 1 + (level - 1) * 0.15;
        const speed = def.baseSpeed * speedMult * def.dir;
        const objLenPx = def.objLen * CELL;
        const gapPx = def.gap * CELL;
        const totalLen = objLenPx + gapPx;

        // Create enough objects to fill the screen + buffer
        const count = Math.ceil((W + totalLen * 2) / totalLen) + 1;
        const objects = [];
        for (let i = 0; i < count; i++) {
          const x = i * totalLen - totalLen;
          objects.push({
            x: x,
            len: objLenPx,
            // For turtles: diving state
            diveTimer: def.diveInterval ? Math.random() * def.diveInterval : 0,
            diving: false,
            divePhase: 0
          });
        }
        lanes[r] = {
          ...def,
          speed: speed,
          objects: objects,
          totalLen: totalLen
        };
      }
    }

    function resetFrog() {
      frogX = Math.floor(COLS / 2);
      frogY = START_ROW;
      frogMaxRow = START_ROW;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      deathAnim = null;
      startTimer();
      requestAnimationFrame(loop);
    }

    function startTimer() {
      clearInterval(timerInterval);
      timeLeft = maxTime;
      timerInterval = setInterval(() => {
        if (gameState !== 'playing') return;
        timeLeft -= 0.1;
        if (timeLeft <= 0) {
          timeLeft = 0;
          killFrog();
        }
      }, 100);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Update death animation
      if (deathAnim) {
        deathAnim.frame++;
        if (deathAnim.frame > 30) {
          deathAnim = null;
          if (lives <= 0) {
            gameOver();
            return;
          }
          resetFrog();
          timeLeft = maxTime;
        }
        return; // Don't update lanes during death animation
      }

      // Update lane objects
      for (const [row, lane] of Object.entries(lanes)) {
        for (const obj of lane.objects) {
          obj.x += lane.speed;

          // Wrap objects
          if (lane.speed > 0 && obj.x > W + obj.len) {
            obj.x -= lane.totalLen * lane.objects.length;
          } else if (lane.speed < 0 && obj.x + obj.len < -obj.len) {
            obj.x += lane.totalLen * lane.objects.length;
          }

          // Turtle diving
          if (lane.objType === 'turtle' && lane.diveInterval) {
            obj.diveTimer--;
            if (obj.diveTimer <= 0) {
              if (!obj.diving) {
                obj.diving = true;
                obj.divePhase = 0;
              }
              obj.divePhase++;
              if (obj.divePhase > 60) { // 1 second underwater
                obj.diving = false;
                obj.diveTimer = lane.diveInterval + Math.random() * 100;
                obj.divePhase = 0;
              }
            }
          }
        }
      }

      // Check frog on river
      if (frogY >= RIVER_START && frogY <= RIVER_END) {
        const lane = lanes[frogY];
        if (lane) {
          const frogPxX = frogX * CELL;
          const frogPxY = frogY * CELL;
          let onPlatform = false;

          for (const obj of lane.objects) {
            // Check if frog overlaps this object
            if (frogPxX + CELL * 0.8 > obj.x && frogPxX + CELL * 0.2 < obj.x + obj.len) {
              if (lane.objType === 'turtle' && obj.diving && obj.divePhase > 20) {
                // Turtle is submerged, can't stand on it
                continue;
              }
              onPlatform = true;
              // Move frog with platform
              frogX += lane.speed / CELL;
              break;
            }
          }

          if (!onPlatform) {
            killFrog();
            return;
          }

          // Frog drifted off screen
          if (frogX < -0.5 || frogX >= COLS + 0.5) {
            killFrog();
            return;
          }
        }
      }

      // Check frog on road (collision with vehicles)
      if (frogY >= ROAD_START && frogY <= ROAD_END) {
        const lane = lanes[frogY];
        if (lane) {
          const frogPxX = frogX * CELL;
          for (const obj of lane.objects) {
            if (frogPxX + CELL * 0.7 > obj.x && frogPxX + CELL * 0.3 < obj.x + obj.len) {
              killFrog();
              return;
            }
          }
        }
      }

      // Check if frog reached home row
      if (frogY === HOME_ROW) {
        let landed = false;
        for (let i = 0; i < HOME_POSITIONS.length; i++) {
          const homeX = HOME_POSITIONS[i];
          if (!homes[i] && Math.abs(frogX - homeX) < 1.2) {
            homes[i] = true;
            score += 50;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            landed = true;

            // Check if all homes filled
            if (homes.every(h => h)) {
              // Level complete!
              score += Math.floor(timeLeft) * 10; // Time bonus
              scoreEl.textContent = score;
              if (score > best) { best = score; bestEl.textContent = best; }
              level++;
              homes = [false, false, false, false, false];
              initLanes();
              maxTime = Math.max(15, 30 - (level - 1) * 2);
            }

            resetFrog();
            timeLeft = maxTime;
            break;
          }
        }
        if (!landed) {
          // Landed in invalid home spot (between pads or already filled)
          killFrog();
          return;
        }
      }

      // Update gameData for ML
      window.gameData = {
        frogX: frogX,
        frogY: frogY,
        lives: lives,
        level: level,
        timeLeft: timeLeft,
        homesFilled: homes.filter(h => h).length
      };
    }

    function killFrog() {
      lives--;
      livesEl.textContent = Math.max(0, lives);
      deathAnim = { x: frogX, y: frogY, frame: 0 };
    }

    function gameOver() {
      gameState = 'over';
      clearInterval(timerInterval);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function moveFrog(dx, dy) {
      if (deathAnim) return;
      const nx = frogX + dx;
      const ny = frogY + dy;

      // Bounds check
      if (nx < 0 || nx >= COLS || ny < 0 || ny > START_ROW) return;

      frogX = nx;
      frogY = ny;

      // Score for forward progress
      if (ny < frogMaxRow) {
        score += 10;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        frogMaxRow = ny;
      }
    }

    // ---- Drawing ----

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawHomeRow();
      drawRiver();
      drawMedian();
      drawRoad();
      drawSidewalk();
      drawStartZone();
      drawLaneObjects();
      drawFrog();
      drawTimerBar();
      drawHUD();
    }

    function drawHomeRow() {
      // Dark water background for home row
      ctx.fillStyle = '#0a1628';
      ctx.fillRect(0, HOME_ROW * CELL, W, CELL);

      // Lily pad slots
      for (let i = 0; i < HOME_POSITIONS.length; i++) {
        const x = HOME_POSITIONS[i] * CELL;
        const y = HOME_ROW * CELL;
        const cx = x + CELL / 2;
        const cy = y + CELL / 2;

        if (homes[i]) {
          // Filled: draw a bright frog
          ctx.fillStyle = '#4e8';
          ctx.shadowColor = '#4e8';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(cx, cy, CELL * 0.35, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          // Empty lily pad
          ctx.fillStyle = '#1a4a2a';
          ctx.shadowColor = '#4e8';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(cx, cy, CELL * 0.4, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Lily pad outline
          ctx.strokeStyle = '#2a6a3a';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(cx, cy, CELL * 0.4, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    function drawRiver() {
      // Water background
      ctx.fillStyle = '#0a1e3a';
      ctx.fillRect(0, RIVER_START * CELL, W, (RIVER_END - RIVER_START + 1) * CELL);

      // Subtle wave lines
      ctx.strokeStyle = '#0f2848';
      ctx.lineWidth = 1;
      for (let r = RIVER_START; r <= RIVER_END; r++) {
        const y = r * CELL + CELL / 2;
        ctx.beginPath();
        for (let x = 0; x < W; x += 4) {
          const wave = Math.sin((x + Date.now() * 0.002) * 0.05) * 3;
          if (x === 0) ctx.moveTo(x, y + wave);
          else ctx.lineTo(x, y + wave);
        }
        ctx.stroke();
      }
    }

    function drawMedian() {
      // Safe zone (grass)
      ctx.fillStyle = '#1a3a1e';
      ctx.fillRect(0, MEDIAN_ROW * CELL, W, CELL);

      // Dotted decorative line
      ctx.strokeStyle = '#2a5a2e';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(0, MEDIAN_ROW * CELL + CELL / 2);
      ctx.lineTo(W, MEDIAN_ROW * CELL + CELL / 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawRoad() {
      // Asphalt background
      ctx.fillStyle = '#1a1a28';
      ctx.fillRect(0, ROAD_START * CELL, W, (ROAD_END - ROAD_START + 1) * CELL);

      // Lane dividers
      ctx.strokeStyle = '#333340';
      ctx.lineWidth = 1;
      ctx.setLineDash([12, 12]);
      for (let r = ROAD_START; r <= ROAD_END; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * CELL);
        ctx.lineTo(W, r * CELL);
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function drawSidewalk() {
      ctx.fillStyle = '#1a3a1e';
      ctx.fillRect(0, SIDEWALK_ROW * CELL, W, CELL);
    }

    function drawStartZone() {
      ctx.fillStyle = '#1a3a1e';
      ctx.fillRect(0, START_ROW * CELL, W, CELL);

      // "START" text
      ctx.fillStyle = '#2a5a2e';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('START', W / 2, START_ROW * CELL + CELL / 2 + 4);
    }

    function drawLaneObjects() {
      for (const [row, lane] of Object.entries(lanes)) {
        const r = parseInt(row);
        const y = r * CELL;

        for (const obj of lane.objects) {
          if (lane.type === 'road') {
            drawVehicle(obj.x, y, obj.len, lane);
          } else if (lane.objType === 'log') {
            drawLog(obj.x, y, obj.len);
          } else if (lane.objType === 'turtle') {
            drawTurtles(obj.x, y, obj.len, obj);
          }
        }
      }
    }

    function drawVehicle(x, y, len, lane) {
      const margin = 4;
      const h = CELL - margin * 2;

      ctx.fillStyle = lane.color;
      ctx.shadowColor = lane.color;
      ctx.shadowBlur = 8;

      // Main body
      ctx.fillRect(x + 2, y + margin, len - 4, h);

      // Windshield
      ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
      if (lane.dir > 0) {
        ctx.fillRect(x + len - 14, y + margin + 3, 10, h - 6);
      } else {
        ctx.fillRect(x + 4, y + margin + 3, 10, h - 6);
      }

      // Headlights
      ctx.fillStyle = '#ff8';
      ctx.shadowColor = '#ff8';
      ctx.shadowBlur = 6;
      if (lane.dir > 0) {
        ctx.fillRect(x + len - 4, y + margin + 2, 3, 4);
        ctx.fillRect(x + len - 4, y + CELL - margin - 6, 3, 4);
      } else {
        ctx.fillRect(x + 1, y + margin + 2, 3, 4);
        ctx.fillRect(x + 1, y + CELL - margin - 6, 3, 4);
      }
      ctx.shadowBlur = 0;
    }

    function drawLog(x, y, len) {
      const margin = 5;
      const h = CELL - margin * 2;

      ctx.fillStyle = '#6a3a1a';
      ctx.shadowColor = '#a05020';
      ctx.shadowBlur = 4;
      ctx.fillRect(x + 2, y + margin, len - 4, h);
      ctx.shadowBlur = 0;

      // Wood grain lines
      ctx.strokeStyle = '#5a2a0a';
      ctx.lineWidth = 1;
      for (let lx = x + 10; lx < x + len - 5; lx += 15) {
        ctx.beginPath();
        ctx.moveTo(lx, y + margin + 2);
        ctx.lineTo(lx, y + CELL - margin - 2);
        ctx.stroke();
      }

      // Bark highlight on top
      ctx.fillStyle = '#8a5a2a';
      ctx.fillRect(x + 2, y + margin, len - 4, 3);
    }

    function drawTurtles(x, y, len, obj) {
      const numTurtles = Math.floor(len / CELL);
      const margin = 6;

      // Determine opacity based on dive state
      let alpha = 1;
      if (obj.diving) {
        if (obj.divePhase < 20) {
          alpha = 1 - (obj.divePhase / 20) * 0.8; // Fade out
        } else if (obj.divePhase > 40) {
          alpha = 0.2 + ((obj.divePhase - 40) / 20) * 0.8; // Fade in
        } else {
          alpha = 0.2; // Submerged
        }
      }

      for (let t = 0; t < numTurtles; t++) {
        const tx = x + t * CELL + CELL / 2;
        const ty = y + CELL / 2;

        // Shell
        ctx.fillStyle = `rgba(0, 170, 100, ${alpha})`;
        ctx.shadowColor = `rgba(0, 170, 100, ${alpha * 0.5})`;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(tx, ty, CELL / 2 - margin, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Shell pattern
        if (alpha > 0.4) {
          ctx.strokeStyle = `rgba(0, 130, 70, ${alpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(tx, ty, CELL / 2 - margin - 3, 0, Math.PI * 2);
          ctx.stroke();

          // Cross pattern on shell
          ctx.beginPath();
          ctx.moveTo(tx - 6, ty);
          ctx.lineTo(tx + 6, ty);
          ctx.moveTo(tx, ty - 6);
          ctx.lineTo(tx, ty + 6);
          ctx.stroke();
        }
      }
    }

    function drawFrog() {
      if (deathAnim) {
        // Death animation: spinning and fading
        const progress = deathAnim.frame / 30;
        const alpha = 1 - progress;
        const scale = 1 + progress * 0.5;
        const cx = deathAnim.x * CELL + CELL / 2;
        const cy = deathAnim.y * CELL + CELL / 2;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(progress * Math.PI * 4);
        ctx.scale(scale, scale);
        ctx.globalAlpha = alpha;

        // X shape for death
        ctx.strokeStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 10;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-10, -10);
        ctx.lineTo(10, 10);
        ctx.moveTo(10, -10);
        ctx.lineTo(-10, 10);
        ctx.stroke();

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
        return;
      }

      const cx = frogX * CELL + CELL / 2;
      const cy = frogY * CELL + CELL / 2;
      const r = CELL * 0.38;

      // Body
      ctx.fillStyle = '#4e8';
      ctx.shadowColor = '#4e8';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(cx - 6, cy - 6, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 6, cy - 6, 4, 0, Math.PI * 2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(cx - 6, cy - 7, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 6, cy - 7, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawTimerBar() {
      const barY = H - 6;
      const barH = 4;
      const pct = Math.max(0, timeLeft / maxTime);

      // Background
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, barY, W, barH);

      // Timer fill
      let barColor;
      if (pct > 0.5) barColor = '#4e8';
      else if (pct > 0.25) barColor = '#ff0';
      else barColor = '#f44';

      ctx.fillStyle = barColor;
      ctx.shadowColor = barColor;
      ctx.shadowBlur = 6;
      ctx.fillRect(0, barY, W * pct, barH);
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Level indicator (top-right of canvas)
      ctx.fillStyle = '#4e8';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`LVL ${level}`, W - 8, H - 14);
      ctx.textAlign = 'left';
    }

    // ---- Input ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowUp':    moveFrog(0, -1); break;
          case 'ArrowDown':  moveFrog(0, 1);  break;
          case 'ArrowLeft':  moveFrog(-1, 0); break;
          case 'ArrowRight': moveFrog(1, 0);  break;
        }
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

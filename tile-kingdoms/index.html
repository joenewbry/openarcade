<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tile Kingdoms</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #8d4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 221, 68, 0.5); }
    h1 { color: #8d4; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 221, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar .player-info { color: #48f; }
    .score-bar .ai-info { color: #8d4; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: #888;
    }
    canvas#game {
      border: 2px solid #8d4;
      box-shadow: 0 0 20px rgba(136, 221, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8d4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .controls {
      width: 600px;
      margin-top: 10px;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
    }
    .controls button {
      background: #16213e;
      color: #8d4;
      border: 1px solid #8d4;
      padding: 6px 16px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      cursor: pointer;
      border-radius: 4px;
    }
    .controls button:hover {
      background: rgba(136, 221, 68, 0.15);
    }
    .controls button:disabled {
      opacity: 0.3;
      cursor: default;
    }
    .status-text {
      width: 600px;
      text-align: center;
      margin-top: 8px;
      font-size: 0.95rem;
      color: #aaa;
      min-height: 1.4em;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>TILE KINGDOMS</h1>
  </div>
  <div class="score-bar">
    <div class="player-info">Player: <span id="score">0</span> pts | Meeples: <span id="playerMeeples">7</span></div>
    <div class="ai-info">AI: <span id="aiScore">0</span> pts | Meeples: <span id="aiMeeples">7</span></div>
  </div>
  <div class="info-bar">
    <div>Tiles left: <span id="tilesLeft">0</span></div>
    <div id="turnInfo">-</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">TILE KINGDOMS</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>
  <div class="controls">
    <button id="btnRotate" disabled>Rotate (R)</button>
    <button id="btnSkip" disabled>Skip Follower</button>
  </div>
  <div class="status-text" id="statusText"></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 600;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const playerMeeplesEl = document.getElementById('playerMeeples');
    const aiMeeplesEl = document.getElementById('aiMeeples');
    const tilesLeftEl = document.getElementById('tilesLeft');
    const turnInfoEl = document.getElementById('turnInfo');
    const statusEl = document.getElementById('statusText');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const btnRotate = document.getElementById('btnRotate');
    const btnSkip = document.getElementById('btnSkip');

    let gameState = 'waiting';
    let score = 0;

    // ===== EDGE TYPES =====
    // Each tile edge is: 'F' = field, 'R' = road, 'C' = city
    // Edges: [top, right, bottom, left]
    // Features describe what's on the tile for follower placement

    // ===== TILE DEFINITIONS =====
    // Each tile type has:
    //   edges: [top, right, bottom, left]
    //   features: array of {type, edges:[indices], ...}
    //   draw: function(ctx, x, y, size) to render the tile
    //   count: how many in pool

    const TILE_DEFS = [
      { // 0: All field
        id: 'field', edges: ['F','F','F','F'], count: 2,
        features: [{type:'field', edges:[0,1,2,3]}]
      },
      { // 1: Straight road (top-bottom)
        id: 'road_straight', edges: ['R','F','R','F'], count: 5,
        features: [{type:'road', edges:[0,2]}, {type:'field', edges:[1]}, {type:'field', edges:[3]}]
      },
      { // 2: Curved road (top-right)
        id: 'road_curve', edges: ['R','R','F','F'], count: 5,
        features: [{type:'road', edges:[0,1]}, {type:'field', edges:[2,3]}]
      },
      { // 3: T-intersection (top, right, bottom roads)
        id: 'road_t', edges: ['R','R','R','F'], count: 3,
        features: [{type:'road', edges:[0]}, {type:'road', edges:[1]}, {type:'road', edges:[2]}, {type:'field', edges:[3]}]
      },
      { // 4: Crossroads
        id: 'road_cross', edges: ['R','R','R','R'], count: 2,
        features: [{type:'road', edges:[0]}, {type:'road', edges:[1]}, {type:'road', edges:[2]}, {type:'road', edges:[3]}]
      },
      { // 5: City one side (top)
        id: 'city_edge', edges: ['C','F','F','F'], count: 5,
        features: [{type:'city', edges:[0]}, {type:'field', edges:[1,2,3]}]
      },
      { // 6: City two adjacent sides (top, right)
        id: 'city_corner', edges: ['C','C','F','F'], count: 4,
        features: [{type:'city', edges:[0,1]}, {type:'field', edges:[2,3]}]
      },
      { // 7: City two opposite sides (top, bottom)
        id: 'city_tunnel', edges: ['C','F','C','F'], count: 2,
        features: [{type:'city', edges:[0,2]}, {type:'field', edges:[1]}, {type:'field', edges:[3]}]
      },
      { // 8: City three sides
        id: 'city_3', edges: ['C','C','F','C'], count: 3,
        features: [{type:'city', edges:[0,1,3]}, {type:'field', edges:[2]}]
      },
      { // 9: Full city (all 4 sides)
        id: 'city_full', edges: ['C','C','C','C'], count: 1,
        features: [{type:'city', edges:[0,1,2,3]}]
      },
      { // 10: City edge with road through (city top, road left-right)
        id: 'city_road', edges: ['C','R','F','R'], count: 4,
        features: [{type:'city', edges:[0]}, {type:'road', edges:[1,3]}, {type:'field', edges:[2]}]
      },
      { // 11: Monastery (field all sides)
        id: 'monastery', edges: ['F','F','F','F'], count: 4,
        features: [{type:'monastery', edges:[]}, {type:'field', edges:[0,1,2,3]}]
      },
      { // 12: Monastery with road (road bottom)
        id: 'monastery_road', edges: ['F','F','R','F'], count: 2,
        features: [{type:'monastery', edges:[]}, {type:'road', edges:[2]}, {type:'field', edges:[0,1,3]}]
      },
      { // 13: City corner with road
        id: 'city_corner_road', edges: ['C','C','R','F'], count: 3,
        features: [{type:'city', edges:[0,1]}, {type:'road', edges:[2]}, {type:'field', edges:[3]}]
      },
    ];

    // ===== GAME STATE =====
    const TILE_SIZE = 40;
    let board = {};        // key: "x,y" -> {tile, rotation, followers:[]}
    let tilePool = [];
    let currentTile = null; // {defIdx, rotation}
    let currentPlayer = 0;  // 0=player, 1=AI
    let players = [
      { score: 0, meeples: 7, color: '#48f', name: 'Player' },
      { score: 0, meeples: 7, color: '#8d4', name: 'AI' }
    ];
    let phase = 'draw';    // 'draw', 'place', 'follower', 'ai_turn'
    let validPlacements = [];
    let hoverPos = null;
    let viewOffsetX = 0, viewOffsetY = 0;
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragViewStartX = 0, dragViewStartY = 0;
    let featureGroups = []; // merged feature tracking
    let nextFeatureId = 0;
    let followerOptions = []; // available follower spots after placing tile
    let hoverFollower = -1;
    let placedTilePos = null; // position of just-placed tile for follower phase

    // ===== UTILITY =====
    function rotateEdges(edges, rot) {
      const r = ((rot % 4) + 4) % 4;
      const e = [...edges];
      for (let i = 0; i < r; i++) {
        e.unshift(e.pop());
      }
      return e;
    }

    function rotateFeatureEdges(featureEdges, rot) {
      const r = ((rot % 4) + 4) % 4;
      return featureEdges.map(e => (e + r) % 4);
    }

    function getEffectiveEdges(defIdx, rotation) {
      return rotateEdges(TILE_DEFS[defIdx].edges, rotation);
    }

    function boardKey(x, y) { return x + ',' + y; }

    function getNeighbors(x, y) {
      return [
        { x, y: y - 1, edge: 0, oppEdge: 2 }, // top neighbor
        { x: x + 1, y, edge: 1, oppEdge: 3 }, // right neighbor
        { x, y: y + 1, edge: 2, oppEdge: 0 }, // bottom neighbor
        { x: x - 1, y, edge: 3, oppEdge: 1 }, // left neighbor
      ];
    }

    // ===== TILE POOL =====
    function buildTilePool() {
      tilePool = [];
      for (let i = 0; i < TILE_DEFS.length; i++) {
        for (let c = 0; c < TILE_DEFS[i].count; c++) {
          tilePool.push(i);
        }
      }
      // Shuffle
      for (let i = tilePool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tilePool[i], tilePool[j]] = [tilePool[j], tilePool[i]];
      }
    }

    function drawTileFromPool() {
      if (tilePool.length === 0) return null;
      return tilePool.pop();
    }

    // ===== PLACEMENT VALIDATION =====
    function getValidPlacements(defIdx, rotation) {
      const edges = getEffectiveEdges(defIdx, rotation);
      const candidates = new Set();

      // Find all empty cells adjacent to placed tiles
      for (const key of Object.keys(board)) {
        const [bx, by] = key.split(',').map(Number);
        for (const n of getNeighbors(bx, by)) {
          if (!board[boardKey(n.x, n.y)]) {
            candidates.add(boardKey(n.x, n.y));
          }
        }
      }

      const valid = [];
      for (const key of candidates) {
        const [cx, cy] = key.split(',').map(Number);
        if (canPlaceAt(defIdx, rotation, cx, cy)) {
          valid.push({ x: cx, y: cy });
        }
      }
      return valid;
    }

    function canPlaceAt(defIdx, rotation, x, y) {
      if (board[boardKey(x, y)]) return false;
      const edges = getEffectiveEdges(defIdx, rotation);
      let hasNeighbor = false;

      for (const n of getNeighbors(x, y)) {
        const nb = board[boardKey(n.x, n.y)];
        if (nb) {
          hasNeighbor = true;
          const nbEdges = getEffectiveEdges(nb.defIdx, nb.rotation);
          if (edges[n.edge] !== nbEdges[n.oppEdge]) return false;
        }
      }
      return hasNeighbor;
    }

    // ===== FEATURE TRACKING =====
    // Each feature group: {id, type, tiles:[{x,y,featureIdx}], owners:{0:count,1:count}, complete:false, scored:false}

    function placeTileOnBoard(defIdx, rotation, x, y) {
      const entry = { defIdx, rotation, followers: [] };
      board[boardKey(x, y)] = entry;

      const def = TILE_DEFS[defIdx];
      const tileFeatureIds = [];

      // Create feature entries for this tile
      for (let fi = 0; fi < def.features.length; fi++) {
        const feat = def.features[fi];
        const rotEdges = rotateFeatureEdges(feat.edges, rotation);
        const fid = nextFeatureId++;
        featureGroups.push({
          id: fid,
          type: feat.type,
          tiles: [{ x, y, featureIdx: fi }],
          owners: {},
          complete: false,
          scored: false,
          edges: rotEdges.slice()
        });
        tileFeatureIds.push(fid);
      }
      entry.featureIds = tileFeatureIds;

      // Merge features with neighbors
      for (const n of getNeighbors(x, y)) {
        const nb = board[boardKey(n.x, n.y)];
        if (!nb) continue;

        const edges = getEffectiveEdges(defIdx, rotation);
        const edgeType = edges[n.edge];

        // Find feature on this tile that includes this edge
        const myFeatIdx = findFeatureForEdge(def, rotation, n.edge);
        if (myFeatIdx < 0) continue;
        const myGroupId = tileFeatureIds[myFeatIdx];

        // Find feature on neighbor that includes the opposing edge
        const nbDef = TILE_DEFS[nb.defIdx];
        const nbFeatIdx = findFeatureForEdge(nbDef, nb.rotation, n.oppEdge);
        if (nbFeatIdx < 0) continue;
        const nbGroupId = nb.featureIds[nbFeatIdx];

        if (myGroupId !== nbGroupId) {
          mergeFeatureGroups(myGroupId, nbGroupId);
        }
      }
    }

    function findFeatureForEdge(def, rotation, edgeIdx) {
      for (let fi = 0; fi < def.features.length; fi++) {
        const feat = def.features[fi];
        const rotEdges = rotateFeatureEdges(feat.edges, rotation);
        if (rotEdges.includes(edgeIdx)) return fi;
      }
      return -1;
    }

    function mergeFeatureGroups(keepId, mergeId) {
      if (keepId === mergeId) return;
      const keepGroup = featureGroups.find(g => g.id === keepId);
      const mergeGroup = featureGroups.find(g => g.id === mergeId);
      if (!keepGroup || !mergeGroup) return;

      // Merge tiles
      for (const t of mergeGroup.tiles) {
        if (!keepGroup.tiles.some(kt => kt.x === t.x && kt.y === t.y && kt.featureIdx === t.featureIdx)) {
          keepGroup.tiles.push(t);
        }
      }

      // Merge owners
      for (const [pid, count] of Object.entries(mergeGroup.owners)) {
        keepGroup.owners[pid] = (keepGroup.owners[pid] || 0) + count;
      }

      // Update all references to mergeId
      for (const key of Object.keys(board)) {
        const entry = board[key];
        if (entry.featureIds) {
          entry.featureIds = entry.featureIds.map(fid => fid === mergeId ? keepId : fid);
        }
      }

      // Remove merged group
      const idx = featureGroups.indexOf(mergeGroup);
      if (idx >= 0) featureGroups.splice(idx, 1);
    }

    function getFeatureGroup(x, y, featureIdx) {
      const entry = board[boardKey(x, y)];
      if (!entry || !entry.featureIds) return null;
      const gid = entry.featureIds[featureIdx];
      return featureGroups.find(g => g.id === gid);
    }

    // ===== COMPLETION CHECKS =====
    function checkCompletions() {
      const completed = [];
      for (const group of featureGroups) {
        if (group.complete || group.scored) continue;
        if (group.type === 'field') continue;

        if (group.type === 'monastery') {
          if (isMonasteryComplete(group)) {
            group.complete = true;
            completed.push(group);
          }
        } else if (group.type === 'city') {
          if (isCityComplete(group)) {
            group.complete = true;
            completed.push(group);
          }
        } else if (group.type === 'road') {
          if (isRoadComplete(group)) {
            group.complete = true;
            completed.push(group);
          }
        }
      }
      return completed;
    }

    function isMonasteryComplete(group) {
      if (group.tiles.length === 0) return false;
      const { x, y } = group.tiles[0];
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          if (!board[boardKey(x + dx, y + dy)]) return false;
        }
      }
      return true;
    }

    function isCityComplete(group) {
      // A city is complete if every city-edge of every tile in the group
      // that faces outward has a matching neighbor
      const uniqueTiles = getUniqueTilePositions(group);
      for (const { x, y } of uniqueTiles) {
        const entry = board[boardKey(x, y)];
        const edges = getEffectiveEdges(entry.defIdx, entry.rotation);
        const def = TILE_DEFS[entry.defIdx];

        // Find which feature indices on this tile belong to this group
        for (let fi = 0; fi < def.features.length; fi++) {
          const gid = entry.featureIds[fi];
          const grp = featureGroups.find(g => g.id === gid);
          if (grp !== group) continue;
          if (def.features[fi].type !== 'city') continue;

          const rotEdges = rotateFeatureEdges(def.features[fi].edges, entry.rotation);
          for (const edgeIdx of rotEdges) {
            if (edges[edgeIdx] === 'C') {
              const neighbors = getNeighbors(x, y);
              const n = neighbors[edgeIdx];
              if (!board[boardKey(n.x, n.y)]) return false;
            }
          }
        }
      }
      return true;
    }

    function isRoadComplete(group) {
      // A road is complete if every road endpoint connects to something
      // Road endpoints are road edges that face outward without a matching neighbor,
      // OR road edges at intersections (T or crossroads where the road terminates)
      const uniqueTiles = getUniqueTilePositions(group);
      let openEnds = 0;

      for (const { x, y } of uniqueTiles) {
        const entry = board[boardKey(x, y)];
        const edges = getEffectiveEdges(entry.defIdx, entry.rotation);
        const def = TILE_DEFS[entry.defIdx];

        for (let fi = 0; fi < def.features.length; fi++) {
          const gid = entry.featureIds[fi];
          const grp = featureGroups.find(g => g.id === gid);
          if (grp !== group) continue;
          if (def.features[fi].type !== 'road') continue;

          const rotEdges = rotateFeatureEdges(def.features[fi].edges, entry.rotation);
          for (const edgeIdx of rotEdges) {
            if (edges[edgeIdx] === 'R') {
              const neighbors = getNeighbors(x, y);
              const n = neighbors[edgeIdx];
              if (!board[boardKey(n.x, n.y)]) openEnds++;
            }
          }
        }
      }
      return openEnds === 0;
    }

    function getUniqueTilePositions(group) {
      const seen = new Set();
      const result = [];
      for (const t of group.tiles) {
        const key = t.x + ',' + t.y;
        if (!seen.has(key)) {
          seen.add(key);
          result.push({ x: t.x, y: t.y });
        }
      }
      return result;
    }

    // ===== SCORING =====
    function scoreFeature(group, endGame = false) {
      if (group.scored) return;
      group.scored = true;

      const uniqueTiles = getUniqueTilePositions(group);
      let points = 0;

      if (group.type === 'city') {
        points = uniqueTiles.length * (endGame ? 1 : 2);
      } else if (group.type === 'road') {
        points = uniqueTiles.length * 1;
      } else if (group.type === 'monastery') {
        const { x, y } = group.tiles[0];
        let count = 1;
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            if (board[boardKey(x + dx, y + dy)]) count++;
          }
        }
        points = count;
      }

      if (points === 0) return;

      // Determine who scores - player(s) with most followers
      const ownerCounts = group.owners;
      const entries = Object.entries(ownerCounts).map(([pid, cnt]) => ({ pid: Number(pid), cnt }));
      if (entries.length === 0) return; // no followers, no score

      const maxCnt = Math.max(...entries.map(e => e.cnt));
      const winners = entries.filter(e => e.cnt === maxCnt);

      for (const w of winners) {
        players[w.pid].score += points;
      }

      // Return followers
      returnFollowers(group);
    }

    function returnFollowers(group) {
      for (const t of group.tiles) {
        const entry = board[boardKey(t.x, t.y)];
        if (!entry) continue;
        entry.followers = entry.followers.filter(f => {
          if (f.featureIdx === t.featureIdx) {
            players[f.player].meeples++;
            return false;
          }
          return true;
        });
      }
    }

    function scoreEndGame() {
      for (const group of featureGroups) {
        if (group.scored) continue;
        if (group.type === 'field') continue;
        if (Object.keys(group.owners).length === 0) continue;
        scoreFeature(group, true);
      }
    }

    // ===== FOLLOWER PLACEMENT =====
    function getFollowerOptions(x, y) {
      const entry = board[boardKey(x, y)];
      if (!entry) return [];
      const def = TILE_DEFS[entry.defIdx];
      const options = [];

      for (let fi = 0; fi < def.features.length; fi++) {
        const feat = def.features[fi];
        if (feat.type === 'field') continue; // Skip field features for simplicity

        const group = getFeatureGroup(x, y, fi);
        if (!group) continue;
        if (group.complete || group.scored) continue;

        // Check if anyone already has a follower on this feature group
        if (Object.keys(group.owners).length > 0) continue;

        options.push({
          featureIdx: fi,
          type: feat.type,
          group: group
        });
      }
      return options;
    }

    function placeFollower(x, y, featureIdx, playerIdx) {
      const entry = board[boardKey(x, y)];
      if (!entry) return false;
      if (players[playerIdx].meeples <= 0) return false;

      const group = getFeatureGroup(x, y, featureIdx);
      if (!group) return false;

      entry.followers.push({ featureIdx, player: playerIdx });
      players[playerIdx].meeples--;
      group.owners[playerIdx] = (group.owners[playerIdx] || 0) + 1;
      return true;
    }

    // ===== DRAWING =====
    function worldToScreen(wx, wy) {
      const cx = W / 2 + viewOffsetX;
      const cy = H / 2 + viewOffsetY;
      return {
        sx: cx + wx * TILE_SIZE,
        sy: cy + wy * TILE_SIZE
      };
    }

    function screenToWorld(sx, sy) {
      const cx = W / 2 + viewOffsetX;
      const cy = H / 2 + viewOffsetY;
      return {
        wx: Math.floor((sx - cx) / TILE_SIZE + 0.5),
        wy: Math.floor((sy - cy) / TILE_SIZE + 0.5)
      };
    }

    function drawTileAt(defIdx, rotation, sx, sy, size, alpha) {
      const def = TILE_DEFS[defIdx];
      const edges = getEffectiveEdges(defIdx, rotation);

      ctx.save();
      ctx.globalAlpha = alpha || 1;
      ctx.translate(sx, sy);

      const s = size;
      const hs = s / 2;

      // Background - green field
      ctx.fillStyle = '#2a4a20';
      ctx.fillRect(-hs, -hs, s, s);

      // Draw city sections
      for (let i = 0; i < 4; i++) {
        if (edges[i] === 'C') {
          ctx.fillStyle = '#c96';
          ctx.beginPath();
          switch (i) {
            case 0: // top
              ctx.moveTo(-hs, -hs);
              ctx.lineTo(hs, -hs);
              ctx.lineTo(hs * 0.4, -hs * 0.2);
              ctx.lineTo(-hs * 0.4, -hs * 0.2);
              break;
            case 1: // right
              ctx.moveTo(hs, -hs);
              ctx.lineTo(hs, hs);
              ctx.lineTo(hs * 0.2, hs * 0.4);
              ctx.lineTo(hs * 0.2, -hs * 0.4);
              break;
            case 2: // bottom
              ctx.moveTo(-hs, hs);
              ctx.lineTo(hs, hs);
              ctx.lineTo(hs * 0.4, hs * 0.2);
              ctx.lineTo(-hs * 0.4, hs * 0.2);
              break;
            case 3: // left
              ctx.moveTo(-hs, -hs);
              ctx.lineTo(-hs, hs);
              ctx.lineTo(-hs * 0.2, hs * 0.4);
              ctx.lineTo(-hs * 0.2, -hs * 0.4);
              break;
          }
          ctx.closePath();
          ctx.fill();
        }
      }

      // Check for connected city edges and fill the center
      const cityEdges = [];
      for (let i = 0; i < 4; i++) {
        if (edges[i] === 'C') cityEdges.push(i);
      }
      // If adjacent city edges share a feature, fill connection between them
      if (cityEdges.length >= 2) {
        const features = def.features;
        for (const feat of features) {
          if (feat.type !== 'city') continue;
          const rotEdges = rotateFeatureEdges(feat.edges, rotation);
          if (rotEdges.length >= 2) {
            // Fill center area connecting these city edges
            ctx.fillStyle = '#c96';
            if (rotEdges.length === 4) {
              ctx.fillRect(-hs, -hs, s, s);
            } else if (rotEdges.length === 3) {
              ctx.fillRect(-hs * 0.6, -hs * 0.6, s * 0.6, s * 0.6);
              for (const e of rotEdges) {
                switch (e) {
                  case 0: ctx.fillRect(-hs * 0.4, -hs, hs * 0.8, hs * 0.8); break;
                  case 1: ctx.fillRect(hs * 0.2, -hs * 0.4, hs * 0.8, hs * 0.8); break;
                  case 2: ctx.fillRect(-hs * 0.4, hs * 0.2, hs * 0.8, hs * 0.8); break;
                  case 3: ctx.fillRect(-hs, -hs * 0.4, hs * 0.8, hs * 0.8); break;
                }
              }
            } else if (rotEdges.length === 2) {
              // Two adjacent edges
              const [a, b] = rotEdges;
              if ((a + 1) % 4 === b || (b + 1) % 4 === a) {
                // Adjacent: fill corner
                ctx.beginPath();
                const corners = {
                  '0,1': [-hs * 0.4, -hs * 0.4, hs * 1.4, hs * 0.8],
                  '1,2': [hs * 0.2 - hs * 0.4, -hs * 0.4, hs * 0.8, hs * 1.4],
                  '2,3': [-hs, hs * 0.2 - hs * 0.4, hs * 1.4, hs * 0.8],
                  '3,0': [-hs * 0.4, -hs, hs * 0.8, hs * 1.4],
                  '1,0': [-hs * 0.4, -hs * 0.4, hs * 1.4, hs * 0.8],
                  '2,1': [hs * 0.2 - hs * 0.4, -hs * 0.4, hs * 0.8, hs * 1.4],
                  '3,2': [-hs, hs * 0.2 - hs * 0.4, hs * 1.4, hs * 0.8],
                  '0,3': [-hs * 0.4, -hs, hs * 0.8, hs * 1.4]
                };
                const key = a + ',' + b;
                if (corners[key]) {
                  ctx.fillRect(...corners[key]);
                }
              }
              // Opposite: they stay as separate wedges (tunnel)
            }
          }
        }
      }

      // Draw roads
      ctx.strokeStyle = '#999';
      ctx.lineWidth = Math.max(2, s / 8);
      ctx.lineCap = 'round';

      // Find road features and draw connections
      const roadEndpoints = [];
      for (let i = 0; i < 4; i++) {
        if (edges[i] === 'R') {
          const pts = {
            0: { x: 0, y: -hs },
            1: { x: hs, y: 0 },
            2: { x: 0, y: hs },
            3: { x: -hs, y: 0 }
          };
          roadEndpoints.push({ edge: i, ...pts[i] });
        }
      }

      // Draw roads based on features
      const features = def.features;
      for (const feat of features) {
        if (feat.type !== 'road') continue;
        const rotEdges = rotateFeatureEdges(feat.edges, rotation);
        if (rotEdges.length === 2) {
          const pts = {
            0: { x: 0, y: -hs },
            1: { x: hs, y: 0 },
            2: { x: 0, y: hs },
            3: { x: -hs, y: 0 }
          };
          ctx.beginPath();
          ctx.moveTo(pts[rotEdges[0]].x, pts[rotEdges[0]].y);
          ctx.lineTo(0, 0);
          ctx.lineTo(pts[rotEdges[1]].x, pts[rotEdges[1]].y);
          ctx.stroke();
        } else if (rotEdges.length === 1) {
          const pts = {
            0: { x: 0, y: -hs },
            1: { x: hs, y: 0 },
            2: { x: 0, y: hs },
            3: { x: -hs, y: 0 }
          };
          ctx.beginPath();
          ctx.moveTo(pts[rotEdges[0]].x, pts[rotEdges[0]].y);
          ctx.lineTo(0, 0);
          ctx.stroke();
          // Draw road end dot
          ctx.fillStyle = '#777';
          ctx.beginPath();
          ctx.arc(0, 0, s / 10, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Draw monastery
      if (def.id === 'monastery' || def.id === 'monastery_road') {
        ctx.fillStyle = '#964';
        ctx.fillRect(-s * 0.2, -s * 0.2, s * 0.4, s * 0.4);
        // Cross
        ctx.strokeStyle = '#fc8';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -s * 0.15);
        ctx.lineTo(0, s * 0.15);
        ctx.moveTo(-s * 0.1, -s * 0.05);
        ctx.lineTo(s * 0.1, -s * 0.05);
        ctx.stroke();
      }

      // Tile border
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(-hs, -hs, s, s);

      ctx.restore();
    }

    function drawMeeple(sx, sy, color, size) {
      const s = size || 8;
      ctx.fillStyle = color;
      ctx.beginPath();
      // Meeple shape: simple person
      ctx.arc(sx, sy - s * 0.5, s * 0.35, 0, Math.PI * 2); // head
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(sx - s * 0.5, sy + s * 0.5);
      ctx.lineTo(sx - s * 0.3, sy - s * 0.1);
      ctx.lineTo(sx, sy + s * 0.1);
      ctx.lineTo(sx + s * 0.3, sy - s * 0.1);
      ctx.lineTo(sx + s * 0.5, sy + s * 0.5);
      ctx.closePath();
      ctx.fill();
      // Outline
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    function getFeatureCenter(x, y, featureIdx, defIdx, rotation) {
      const def = TILE_DEFS[defIdx];
      const feat = def.features[featureIdx];
      const rotEdges = rotateFeatureEdges(feat.edges, rotation);

      if (feat.type === 'monastery') {
        return { fx: 0, fy: 0 };
      }

      if (rotEdges.length === 0) return { fx: 0, fy: 0 };

      // Average the edge positions to find feature center
      let fx = 0, fy = 0;
      const edgeCenters = {
        0: { x: 0, y: -0.3 },
        1: { x: 0.3, y: 0 },
        2: { x: 0, y: 0.3 },
        3: { x: -0.3, y: 0 }
      };

      for (const e of rotEdges) {
        fx += edgeCenters[e].x;
        fy += edgeCenters[e].y;
      }
      fx /= rotEdges.length;
      fy /= rotEdges.length;

      return { fx, fy };
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid dots for reference
      ctx.fillStyle = 'rgba(136, 221, 68, 0.08)';
      for (let gx = -20; gx <= 20; gx++) {
        for (let gy = -20; gy <= 20; gy++) {
          const { sx, sy } = worldToScreen(gx, gy);
          if (sx >= -TILE_SIZE && sx <= W + TILE_SIZE && sy >= -TILE_SIZE && sy <= H + TILE_SIZE) {
            ctx.fillRect(sx - 1, sy - 1, 2, 2);
          }
        }
      }

      // Draw valid placement spots
      if (phase === 'place' && currentPlayer === 0) {
        for (const vp of validPlacements) {
          const { sx, sy } = worldToScreen(vp.x, vp.y);
          ctx.fillStyle = 'rgba(136, 221, 68, 0.12)';
          ctx.fillRect(sx - TILE_SIZE / 2, sy - TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = 'rgba(136, 221, 68, 0.3)';
          ctx.lineWidth = 1;
          ctx.strokeRect(sx - TILE_SIZE / 2, sy - TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
        }
      }

      // Draw placed tiles
      for (const key of Object.keys(board)) {
        const [bx, by] = key.split(',').map(Number);
        const entry = board[key];
        const { sx, sy } = worldToScreen(bx, by);

        if (sx < -TILE_SIZE || sx > W + TILE_SIZE || sy < -TILE_SIZE || sy > H + TILE_SIZE) continue;

        drawTileAt(entry.defIdx, entry.rotation, sx, sy, TILE_SIZE, 1);

        // Draw followers on this tile
        for (const f of entry.followers) {
          const { fx, fy } = getFeatureCenter(bx, by, f.featureIdx, entry.defIdx, entry.rotation);
          drawMeeple(sx + fx * TILE_SIZE, sy + fy * TILE_SIZE, players[f.player].color, 7);
        }
      }

      // Draw hover preview
      if (phase === 'place' && currentPlayer === 0 && hoverPos && currentTile) {
        const isValid = validPlacements.some(v => v.x === hoverPos.wx && v.y === hoverPos.wy);
        if (isValid) {
          const { sx, sy } = worldToScreen(hoverPos.wx, hoverPos.wy);
          drawTileAt(currentTile.defIdx, currentTile.rotation, sx, sy, TILE_SIZE, 0.6);
        }
      }

      // Draw follower placement options
      if (phase === 'follower' && currentPlayer === 0 && placedTilePos) {
        const { sx, sy } = worldToScreen(placedTilePos.x, placedTilePos.y);
        const entry = board[boardKey(placedTilePos.x, placedTilePos.y)];

        for (let i = 0; i < followerOptions.length; i++) {
          const opt = followerOptions[i];
          const { fx, fy } = getFeatureCenter(placedTilePos.x, placedTilePos.y, opt.featureIdx, entry.defIdx, entry.rotation);
          const mx = sx + fx * TILE_SIZE;
          const my = sy + fy * TILE_SIZE;

          // Highlight circle
          ctx.fillStyle = i === hoverFollower ? 'rgba(68, 136, 255, 0.5)' : 'rgba(68, 136, 255, 0.25)';
          ctx.beginPath();
          ctx.arc(mx, my, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#48f';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Label
          ctx.fillStyle = '#fff';
          ctx.font = '8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(opt.type[0].toUpperCase(), mx, my + 3);
        }
      }

      // Preview tile in corner
      if (currentTile && phase !== 'follower') {
        ctx.fillStyle = 'rgba(22, 33, 62, 0.9)';
        ctx.fillRect(W - 75, 5, 70, 70);
        ctx.strokeStyle = '#8d4';
        ctx.lineWidth = 1;
        ctx.strokeRect(W - 75, 5, 70, 70);
        drawTileAt(currentTile.defIdx, currentTile.rotation, W - 40, 40, 50, 1);
        ctx.fillStyle = '#888';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Next Tile', W - 40, 68);
      }

      // Update UI
      scoreEl.textContent = players[0].score;
      aiScoreEl.textContent = players[1].score;
      playerMeeplesEl.textContent = players[0].meeples;
      aiMeeplesEl.textContent = players[1].meeples;
      tilesLeftEl.textContent = tilePool.length;
    }

    // ===== AI =====
    function aiTurn() {
      if (gameState !== 'playing') return;
      phase = 'ai_turn';
      turnInfoEl.textContent = 'AI thinking...';
      statusEl.textContent = 'AI is placing a tile...';

      setTimeout(() => {
        const defIdx = drawTileFromPool();
        if (defIdx === null) {
          endGame();
          return;
        }

        // Try all rotations and positions, pick the best
        let bestScore = -Infinity;
        let bestMove = null;

        for (let rot = 0; rot < 4; rot++) {
          const valid = getValidPlacements(defIdx, rot);
          for (const pos of valid) {
            const moveScore = evaluateAIMove(defIdx, rot, pos.x, pos.y);
            if (moveScore > bestScore) {
              bestScore = moveScore;
              bestMove = { rot, x: pos.x, y: pos.y };
            }
          }
        }

        if (!bestMove) {
          // Can't place this tile, skip
          statusEl.textContent = 'AI could not place tile. Skipping.';
          setTimeout(() => nextTurn(), 500);
          return;
        }

        // Place the tile
        currentTile = { defIdx, rotation: bestMove.rot };
        placeTileOnBoard(defIdx, bestMove.rot, bestMove.x, bestMove.y);
        placedTilePos = { x: bestMove.x, y: bestMove.y };

        // Check completions and score
        const completed = checkCompletions();
        for (const group of completed) {
          scoreFeature(group);
        }

        draw();

        // Decide on follower placement
        setTimeout(() => {
          aiPlaceFollower(bestMove.x, bestMove.y);
          draw();

          // Check completions again after follower
          const completed2 = checkCompletions();
          for (const group of completed2) {
            scoreFeature(group);
          }

          draw();
          setTimeout(() => nextTurn(), 400);
        }, 300);
      }, 400);
    }

    function evaluateAIMove(defIdx, rotation, x, y) {
      // Heuristic: evaluate how good placing this tile at this position is
      let score = 0;

      // Temporarily place and evaluate
      const tempBoard = JSON.parse(JSON.stringify(board));
      const tempFeatures = JSON.parse(JSON.stringify(featureGroups));
      const tempNextId = nextFeatureId;

      placeTileOnBoard(defIdx, rotation, x, y);

      // Score for completing features
      for (const group of featureGroups) {
        if (group.complete || group.scored) continue;
        if (group.type === 'field') continue;

        let isNowComplete = false;
        if (group.type === 'monastery') isNowComplete = isMonasteryComplete(group);
        else if (group.type === 'city') isNowComplete = isCityComplete(group);
        else if (group.type === 'road') isNowComplete = isRoadComplete(group);

        if (isNowComplete) {
          const tiles = getUniqueTilePositions(group);
          const hasAI = group.owners[1] > 0;
          const hasPlayer = group.owners[0] > 0;
          let pts = 0;
          if (group.type === 'city') pts = tiles.length * 2;
          else if (group.type === 'road') pts = tiles.length;
          else if (group.type === 'monastery') pts = 9;

          if (hasAI && !hasPlayer) score += pts * 3;
          else if (hasAI && hasPlayer) score += pts;
          else if (hasPlayer && !hasAI) score -= pts * 0.5; // completing opponent features gives them points
          else score += pts * 0.3; // unclaimed completed feature
        }
      }

      // Score for extending AI-claimed features
      for (const group of featureGroups) {
        if (group.scored || group.complete) continue;
        if (group.owners[1] > 0 && !group.owners[0]) {
          score += 1; // bonus for extending own features
        }
      }

      // Prefer placing near center
      score -= (Math.abs(x) + Math.abs(y)) * 0.05;

      // Restore state
      board = {};
      for (const key of Object.keys(tempBoard)) {
        board[key] = tempBoard[key];
      }
      featureGroups.length = 0;
      for (const g of tempFeatures) featureGroups.push(g);
      nextFeatureId = tempNextId;

      // Re-place all tiles from tempBoard
      // Actually we need a proper restore. Let me use a simpler approach.
      return score;
    }

    // Simpler AI evaluation that doesn't modify state
    function evaluateAIMove(defIdx, rotation, x, y) {
      let score = 0;
      const edges = getEffectiveEdges(defIdx, rotation);

      // Count matching city/road neighbors - prefer connecting to things
      for (const n of getNeighbors(x, y)) {
        const nb = board[boardKey(n.x, n.y)];
        if (nb) {
          const nbEdges = getEffectiveEdges(nb.defIdx, nb.rotation);
          if (edges[n.edge] === 'C' && nbEdges[n.oppEdge] === 'C') {
            // Check if AI owns this city feature
            const nbDef = TILE_DEFS[nb.defIdx];
            const nbFeatIdx = findFeatureForEdge(nbDef, nb.rotation, n.oppEdge);
            if (nbFeatIdx >= 0) {
              const group = getFeatureGroup(n.x, n.y, nbFeatIdx);
              if (group) {
                const aiOwns = group.owners[1] > 0;
                const playerOwns = group.owners[0] > 0;
                if (aiOwns && !playerOwns) score += 5;
                else if (playerOwns && !aiOwns) score -= 1;
                else score += 2;
              }
            }
            score += 3; // connecting city edges is good
          }
          if (edges[n.edge] === 'R' && nbEdges[n.oppEdge] === 'R') {
            score += 1;
          }
        }
      }

      // Check if this creates completion potential
      const def = TILE_DEFS[defIdx];
      if (def.id === 'monastery' || def.id === 'monastery_road') {
        // Count existing neighbors for monastery
        let neighbors = 0;
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            if (board[boardKey(x + dx, y + dy)]) neighbors++;
          }
        }
        score += neighbors * 0.5;
      }

      // Prefer near center early game
      const tilesPlaced = Object.keys(board).length;
      if (tilesPlaced < 15) {
        score -= (Math.abs(x) + Math.abs(y)) * 0.1;
      }

      // Small random factor for variety
      score += Math.random() * 0.5;

      return score;
    }

    function aiPlaceFollower(x, y) {
      if (players[1].meeples <= 0) return;

      const options = getFollowerOptions(x, y);
      if (options.length === 0) return;

      // Evaluate each option
      let bestOpt = null;
      let bestVal = -1;

      for (const opt of options) {
        let val = 0;
        const group = opt.group;
        const tiles = getUniqueTilePositions(group);

        if (opt.type === 'city') {
          val = tiles.length * 2 + 3;
          // Bigger cities are more valuable
          if (tiles.length >= 3) val += 3;
        } else if (opt.type === 'road') {
          val = tiles.length + 1;
        } else if (opt.type === 'monastery') {
          // Count neighbors already placed
          const { x: mx, y: my } = group.tiles[0];
          let nbCount = 0;
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              if (dx === 0 && dy === 0) continue;
              if (board[boardKey(mx + dx, my + dy)]) nbCount++;
            }
          }
          val = nbCount + 2;
          if (nbCount >= 5) val += 5; // likely to complete
        }

        // Don't place on tiny features unless we have plenty of meeples
        if (players[1].meeples <= 2 && val < 4) continue;

        if (val > bestVal) {
          bestVal = val;
          bestOpt = opt;
        }
      }

      if (bestOpt && bestVal >= 2) {
        placeFollower(x, y, bestOpt.featureIdx, 1);
      }
    }

    // ===== GAME FLOW =====
    function initGame() {
      board = {};
      tilePool = [];
      featureGroups = [];
      nextFeatureId = 0;
      currentPlayer = 0;
      players[0].score = 0;
      players[0].meeples = 7;
      players[1].score = 0;
      players[1].meeples = 7;
      score = 0;
      viewOffsetX = 0;
      viewOffsetY = 0;
      phase = 'draw';
      currentTile = null;
      validPlacements = [];
      hoverPos = null;
      followerOptions = [];
      hoverFollower = -1;
      placedTilePos = null;

      buildTilePool();

      // Place starting tile at center (city edge with road - a good starting tile)
      const startDef = 10; // city_road: city top, road left-right
      placeTileOnBoard(startDef, 0, 0, 0);

      gameState = 'playing';
      overlay.style.display = 'none';
      btnRotate.disabled = false;

      startPlayerTurn();
    }

    function startPlayerTurn() {
      currentPlayer = 0;
      turnInfoEl.textContent = "Your turn";

      const defIdx = drawTileFromPool();
      if (defIdx === null) {
        endGame();
        return;
      }

      currentTile = { defIdx, rotation: 0 };
      phase = 'place';

      // Check if tile can be placed in any rotation
      let canPlace = false;
      for (let r = 0; r < 4; r++) {
        if (getValidPlacements(defIdx, r).length > 0) {
          canPlace = true;
          break;
        }
      }

      if (!canPlace) {
        statusEl.textContent = 'Tile cannot be placed anywhere. Drawing new tile...';
        setTimeout(() => startPlayerTurn(), 800);
        return;
      }

      updateValidPlacements();
      statusEl.textContent = 'Place your tile. Press R to rotate.';
      btnSkip.disabled = true;
      draw();
    }

    function updateValidPlacements() {
      if (currentTile) {
        validPlacements = getValidPlacements(currentTile.defIdx, currentTile.rotation);
      }
    }

    function nextTurn() {
      currentTile = null;
      placedTilePos = null;
      followerOptions = [];
      phase = 'draw';

      if (tilePool.length === 0) {
        endGame();
        return;
      }

      if (currentPlayer === 0) {
        // AI turn
        currentPlayer = 1;
        aiTurn();
      } else {
        // Player turn
        startPlayerTurn();
      }
    }

    function endGame() {
      gameState = 'over';
      phase = 'draw';
      scoreEndGame();
      draw();

      const p = players[0].score;
      const a = players[1].score;
      overlayTitle.textContent = p > a ? 'YOU WIN!' : (p < a ? 'AI WINS!' : 'TIE GAME!');
      overlayText.textContent = `Final Score: You ${p} - AI ${a}\nClick to play again`;
      overlay.style.display = 'flex';
      btnRotate.disabled = true;
      btnSkip.disabled = true;
      statusEl.textContent = '';
      score = p;
    }

    // ===== INPUT =====
    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'waiting') return;
      if (gameState === 'over') return;

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (e.button === 1 || e.button === 2) {
        // Middle/right click to drag
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragViewStartX = viewOffsetX;
        dragViewStartY = viewOffsetY;
        e.preventDefault();
        return;
      }

      if (phase === 'place' && currentPlayer === 0) {
        const world = screenToWorld(mx, my);
        const isValid = validPlacements.some(v => v.x === world.wx && v.y === world.wy);
        if (isValid) {
          placeTileOnBoard(currentTile.defIdx, currentTile.rotation, world.wx, world.wy);
          placedTilePos = { x: world.wx, y: world.wy };

          // Check completions
          const completed = checkCompletions();
          for (const group of completed) {
            scoreFeature(group);
          }

          // Check follower options
          followerOptions = getFollowerOptions(world.wx, world.wy);
          if (followerOptions.length > 0 && players[0].meeples > 0) {
            phase = 'follower';
            statusEl.textContent = 'Click a feature to place follower, or Skip.';
            btnSkip.disabled = false;
          } else {
            phase = 'draw';
            setTimeout(() => nextTurn(), 200);
          }
          draw();
        }
      } else if (phase === 'follower' && currentPlayer === 0) {
        // Check if clicked on a follower option
        if (placedTilePos) {
          const entry = board[boardKey(placedTilePos.x, placedTilePos.y)];
          const { sx, sy } = worldToScreen(placedTilePos.x, placedTilePos.y);

          for (let i = 0; i < followerOptions.length; i++) {
            const opt = followerOptions[i];
            const { fx, fy } = getFeatureCenter(placedTilePos.x, placedTilePos.y, opt.featureIdx, entry.defIdx, entry.rotation);
            const px = sx + fx * TILE_SIZE;
            const py = sy + fy * TILE_SIZE;
            const dist = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
            if (dist < 12) {
              placeFollower(placedTilePos.x, placedTilePos.y, opt.featureIdx, 0);
              phase = 'draw';
              btnSkip.disabled = true;
              statusEl.textContent = '';
              draw();
              setTimeout(() => nextTurn(), 200);
              return;
            }
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (isDragging) {
        viewOffsetX = dragViewStartX + (e.clientX - dragStartX);
        viewOffsetY = dragViewStartY + (e.clientY - dragStartY);
        draw();
        return;
      }

      if (phase === 'place' && currentPlayer === 0) {
        hoverPos = screenToWorld(mx, my);
        draw();
      } else if (phase === 'follower' && currentPlayer === 0 && placedTilePos) {
        const entry = board[boardKey(placedTilePos.x, placedTilePos.y)];
        const { sx, sy } = worldToScreen(placedTilePos.x, placedTilePos.y);
        hoverFollower = -1;
        for (let i = 0; i < followerOptions.length; i++) {
          const opt = followerOptions[i];
          const { fx, fy } = getFeatureCenter(placedTilePos.x, placedTilePos.y, opt.featureIdx, entry.defIdx, entry.rotation);
          const px = sx + fx * TILE_SIZE;
          const py = sy + fy * TILE_SIZE;
          const dist = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
          if (dist < 12) {
            hoverFollower = i;
            break;
          }
        }
        draw();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      hoverPos = null;
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Pan with left mouse drag on empty space
    let leftDragStart = null;
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0 && gameState === 'playing') {
        leftDragStart = { x: e.clientX, y: e.clientY, vx: viewOffsetX, vy: viewOffsetY, moved: false };
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (leftDragStart && !isDragging) {
        const dx = e.clientX - leftDragStart.x;
        const dy = e.clientY - leftDragStart.y;
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
          leftDragStart.moved = true;
          viewOffsetX = leftDragStart.vx + dx;
          viewOffsetY = leftDragStart.vy + dy;
          draw();
        }
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (leftDragStart) {
        if (leftDragStart.moved) {
          // Was a drag, don't process as click
          e.stopImmediatePropagation?.();
        }
        leftDragStart = null;
      }
    }, true);

    document.addEventListener('keydown', (e) => {
      if (gameState !== 'playing') return;

      if (e.key === 'r' || e.key === 'R') {
        if (phase === 'place' && currentPlayer === 0 && currentTile) {
          currentTile.rotation = (currentTile.rotation + 1) % 4;
          updateValidPlacements();
          draw();
        }
      }
    });

    btnRotate.addEventListener('click', () => {
      if (phase === 'place' && currentPlayer === 0 && currentTile) {
        currentTile.rotation = (currentTile.rotation + 1) % 4;
        updateValidPlacements();
        draw();
      }
    });

    btnSkip.addEventListener('click', () => {
      if (phase === 'follower' && currentPlayer === 0) {
        phase = 'draw';
        btnSkip.disabled = true;
        statusEl.textContent = '';
        draw();
        setTimeout(() => nextTurn(), 200);
      }
    });

    // ===== OVERLAY CLICK =====
    overlay.style.cursor = 'pointer';
    overlay.style.pointerEvents = 'auto';
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        initGame();
      }
    });

    // ===== INIT =====
    draw();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

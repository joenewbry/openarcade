<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agar.io</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #a6c; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 102, 204, 0.5); }
    h1 { color: #a6c; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 102, 204, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a6c; }
    canvas {
      border: 2px solid #a6c;
      box-shadow: 0 0 20px rgba(170, 102, 204, 0.2);
      display: block;
      cursor: none;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a6c;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .controls-hint { font-size: 0.75rem; color: #666; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>AGAR.IO</h1>
  </div>
  <div class="score-bar">
    <div>Mass: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">AGAR.IO</h2>
      <p id="overlayText">Press SPACE to start</p>
      <p class="controls-hint">Arrow keys or mouse to move | SPACE to split | W to eject mass</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const WORLD_SIZE = 4000;
    const GRID_SPACING = 80;
    const FOOD_COUNT = 400;
    const AI_COUNT = 20;
    const MIN_SPLIT_MASS = 36;
    const EJECT_MASS = 14;
    const MIN_EJECT_MASS = 30;
    const MERGE_TIME = 300; // frames before split cells can merge
    const BASE_SPEED = 4;

    // Neon colors for cells
    const CELL_COLORS = [
      '#f44', '#4f4', '#44f', '#ff0', '#f0f', '#0ff',
      '#f80', '#8f0', '#08f', '#f08', '#80f', '#0f8',
      '#fa0', '#af0', '#0af', '#a0f', '#f0a', '#0fa'
    ];

    // --- Game State ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // Player cells (array for splitting)
    let playerCells = [];
    let food = [];
    let aiCells = [];
    let ejectedMass = [];
    let camera = { x: 0, y: 0, zoom: 1 };
    let keys = {};
    let mouse = { x: W / 2, y: H / 2, active: false };
    let frameCount = 0;
    let leaderboard = [];

    // --- Utility ---
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
    function massToRadius(mass) { return Math.sqrt(mass) * 4; }
    function randColor() { return CELL_COLORS[Math.floor(Math.random() * CELL_COLORS.length)]; }

    // AI names
    const AI_NAMES = [
      'Bot_Alpha', 'NomNom', 'CellKing', 'BlobMaster', 'Chomper',
      'Mitosis', 'Amoeba', 'SplitGod', 'BigCell', 'TinyTerror',
      'Nucleus', 'Membrane', 'Cytoplasm', 'Phagocyte', 'Microbe',
      'Protozoa', 'Organism', 'Petri', 'Colony', 'Spore',
      'Devourer', 'Absorber', 'GrowBot', 'MassHog', 'Engulfer'
    ];

    // --- Init ---
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      frameCount = 0;
      playerCells = [];
      food = [];
      aiCells = [];
      ejectedMass = [];
      mouse = { x: W / 2, y: H / 2, active: false };
      keys = {};
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'AGAR.IO';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      // Create player cell at center of world
      playerCells = [{
        x: WORLD_SIZE / 2,
        y: WORLD_SIZE / 2,
        mass: 20,
        vx: 0,
        vy: 0,
        color: '#a6c',
        mergeTimer: 0
      }];

      // Spawn food
      food = [];
      for (let i = 0; i < FOOD_COUNT; i++) {
        spawnFood();
      }

      // Spawn AI cells
      aiCells = [];
      for (let i = 0; i < AI_COUNT; i++) {
        spawnAI();
      }

      ejectedMass = [];
      score = 20;
      scoreEl.textContent = score;
      frameCount = 0;

      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function spawnFood() {
      food.push({
        x: rand(50, WORLD_SIZE - 50),
        y: rand(50, WORLD_SIZE - 50),
        mass: rand(1, 3),
        color: randColor()
      });
    }

    function spawnAI() {
      const mass = rand(10, 200);
      const spawnMargin = 200;
      aiCells.push({
        x: rand(spawnMargin, WORLD_SIZE - spawnMargin),
        y: rand(spawnMargin, WORLD_SIZE - spawnMargin),
        mass: mass,
        vx: 0,
        vy: 0,
        color: randColor(),
        name: AI_NAMES[Math.floor(Math.random() * AI_NAMES.length)],
        targetX: rand(200, WORLD_SIZE - 200),
        targetY: rand(200, WORLD_SIZE - 200),
        changeTimer: Math.floor(rand(60, 300)),
        splitCooldown: 0
      });
    }

    // --- Game Over ---
    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Mass: ${score} â€” Press any key to restart`;
    }

    // --- Player Center of Mass ---
    function getPlayerCenter() {
      if (playerCells.length === 0) return { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
      let tx = 0, ty = 0, tm = 0;
      for (const c of playerCells) {
        tx += c.x * c.mass;
        ty += c.y * c.mass;
        tm += c.mass;
      }
      return { x: tx / tm, y: ty / tm };
    }

    function getTotalMass() {
      let m = 0;
      for (const c of playerCells) m += c.mass;
      return Math.floor(m);
    }

    // --- Movement ---
    function getTargetDirection(cell) {
      const center = getPlayerCenter();

      // Determine target point: mouse position converted to world coords, or arrow keys
      let tx, ty;

      if (mouse.active) {
        // Convert mouse canvas position to world position
        tx = center.x + (mouse.x - W / 2) / camera.zoom;
        ty = center.y + (mouse.y - H / 2) / camera.zoom;
      } else {
        // Arrow keys: move in key direction (no WASD -- W is eject mass)
        let dx = 0, dy = 0;
        if (keys['ArrowLeft']) dx -= 1;
        if (keys['ArrowRight']) dx += 1;
        if (keys['ArrowUp']) dy -= 1;
        if (keys['ArrowDown']) dy += 1;

        if (dx === 0 && dy === 0) return { dx: 0, dy: 0, dist: 0 };

        const len = Math.hypot(dx, dy);
        tx = cell.x + (dx / len) * 200;
        ty = cell.y + (dy / len) * 200;
      }

      const ddx = tx - cell.x;
      const ddy = ty - cell.y;
      const d = Math.hypot(ddx, ddy);

      if (d < 2) return { dx: 0, dy: 0, dist: 0 };
      return { dx: ddx / d, dy: ddy / d, dist: d };
    }

    function moveCell(cell, dx, dy, speed) {
      cell.x += dx * speed;
      cell.y += dy * speed;
      // Clamp to world bounds
      const r = massToRadius(cell.mass);
      cell.x = Math.max(r, Math.min(WORLD_SIZE - r, cell.x));
      cell.y = Math.max(r, Math.min(WORLD_SIZE - r, cell.y));
    }

    // --- Split ---
    function splitPlayer() {
      const newCells = [];
      for (const cell of playerCells) {
        if (cell.mass < MIN_SPLIT_MASS) continue;
        if (playerCells.length + newCells.length >= 16) break;

        const dir = getTargetDirection(cell);
        const sdx = dir.dist > 0 ? dir.dx : 0;
        const sdy = dir.dist > 0 ? dir.dy : (sdx === 0 ? -1 : 0);

        const halfMass = cell.mass / 2;
        cell.mass = halfMass;

        const r = massToRadius(halfMass);
        newCells.push({
          x: cell.x + sdx * r * 4,
          y: cell.y + sdy * r * 4,
          mass: halfMass,
          vx: sdx * 15,
          vy: sdy * 15,
          color: cell.color,
          mergeTimer: MERGE_TIME
        });
      }
      playerCells.push(...newCells);
    }

    // --- Eject Mass ---
    function ejectMass() {
      for (const cell of playerCells) {
        if (cell.mass < MIN_EJECT_MASS) continue;

        const dir = getTargetDirection(cell);
        const edx = dir.dist > 0 ? dir.dx : 0;
        const edy = dir.dist > 0 ? dir.dy : -1;

        cell.mass -= EJECT_MASS;
        const r = massToRadius(cell.mass);
        ejectedMass.push({
          x: cell.x + edx * (r + 10),
          y: cell.y + edy * (r + 10),
          mass: EJECT_MASS,
          vx: edx * 12,
          vy: edy * 12,
          color: cell.color,
          life: 0
        });
      }
    }

    // --- AI Behavior ---
    function updateAI(ai) {
      ai.changeTimer--;
      ai.splitCooldown = Math.max(0, ai.splitCooldown - 1);

      // Find nearest threat or prey
      let nearestPrey = null;
      let nearestPreyDist = Infinity;
      let nearestThreat = null;
      let nearestThreatDist = Infinity;

      // Check player cells
      for (const pc of playerCells) {
        const d = dist(ai, pc);
        if (ai.mass > pc.mass * 1.15 && d < nearestPreyDist) {
          nearestPrey = pc;
          nearestPreyDist = d;
        }
        if (pc.mass > ai.mass * 1.15 && d < nearestThreatDist) {
          nearestThreat = pc;
          nearestThreatDist = d;
        }
      }

      // Check other AI cells
      for (const other of aiCells) {
        if (other === ai) continue;
        const d = dist(ai, other);
        if (ai.mass > other.mass * 1.15 && d < nearestPreyDist) {
          nearestPrey = other;
          nearestPreyDist = d;
        }
        if (other.mass > ai.mass * 1.15 && d < nearestThreatDist) {
          nearestThreat = other;
          nearestThreatDist = d;
        }
      }

      // Check food
      let nearestFood = null;
      let nearestFoodDist = Infinity;
      for (const f of food) {
        const d = dist(ai, f);
        if (d < nearestFoodDist) {
          nearestFood = f;
          nearestFoodDist = d;
        }
      }

      const senseRange = massToRadius(ai.mass) * 10 + 200;

      // Decision making
      if (nearestThreat && nearestThreatDist < senseRange) {
        // Flee from threats
        const dx = ai.x - nearestThreat.x;
        const dy = ai.y - nearestThreat.y;
        const d = Math.hypot(dx, dy) || 1;
        ai.targetX = ai.x + (dx / d) * 500;
        ai.targetY = ai.y + (dy / d) * 500;
      } else if (nearestPrey && nearestPreyDist < senseRange) {
        // Chase prey
        ai.targetX = nearestPrey.x;
        ai.targetY = nearestPrey.y;
      } else if (nearestFood && nearestFoodDist < senseRange * 0.5) {
        // Go for food
        ai.targetX = nearestFood.x;
        ai.targetY = nearestFood.y;
      } else if (ai.changeTimer <= 0) {
        // Wander
        ai.targetX = rand(200, WORLD_SIZE - 200);
        ai.targetY = rand(200, WORLD_SIZE - 200);
        ai.changeTimer = Math.floor(rand(120, 400));
      }

      // Move toward target
      const dx = ai.targetX - ai.x;
      const dy = ai.targetY - ai.y;
      const d = Math.hypot(dx, dy);
      if (d > 5) {
        const speed = BASE_SPEED * (30 / (massToRadius(ai.mass) + 20));
        ai.x += (dx / d) * speed;
        ai.y += (dy / d) * speed;
      }

      // Clamp to world
      const r = massToRadius(ai.mass);
      ai.x = Math.max(r, Math.min(WORLD_SIZE - r, ai.x));
      ai.y = Math.max(r, Math.min(WORLD_SIZE - r, ai.y));

      // Slow mass decay for large AI cells
      if (ai.mass > 100) {
        ai.mass *= 0.9998;
      }
    }

    // --- Collision ---
    function canEat(eater, prey) {
      return eater.mass > prey.mass * 1.15;
    }

    function overlaps(a, b) {
      const ra = massToRadius(a.mass);
      const rb = massToRadius(b.mass);
      const d = dist(a, b);
      // Eater must cover most of prey
      return d < ra - rb * 0.4;
    }

    // --- Update ---
    function update() {
      frameCount++;

      // Move player cells
      for (const cell of playerCells) {
        const dir = getTargetDirection(cell);
        if (dir.dist > 0) {
          // Speed inversely proportional to size
          const speed = BASE_SPEED * (30 / (massToRadius(cell.mass) + 20));
          // Smooth approach: slow down when close to cursor
          const factor = Math.min(1, dir.dist / 100);
          moveCell(cell, dir.dx * factor, dir.dy * factor, speed);
        }

        // Apply velocity (from splitting)
        if (Math.abs(cell.vx) > 0.1 || Math.abs(cell.vy) > 0.1) {
          cell.x += cell.vx;
          cell.y += cell.vy;
          cell.vx *= 0.9;
          cell.vy *= 0.9;
          const r = massToRadius(cell.mass);
          cell.x = Math.max(r, Math.min(WORLD_SIZE - r, cell.x));
          cell.y = Math.max(r, Math.min(WORLD_SIZE - r, cell.y));
        }

        // Merge timer
        if (cell.mergeTimer > 0) cell.mergeTimer--;

        // Slow mass decay for large player cells
        if (cell.mass > 100) {
          cell.mass *= 0.9999;
        }
      }

      // Merge player cells that can merge
      for (let i = 0; i < playerCells.length; i++) {
        for (let j = i + 1; j < playerCells.length; j++) {
          const a = playerCells[i];
          const b = playerCells[j];
          if (a.mergeTimer > 0 || b.mergeTimer > 0) continue;
          const ra = massToRadius(a.mass);
          const rb = massToRadius(b.mass);
          const d = dist(a, b);
          if (d < ra + rb - Math.min(ra, rb) * 0.5) {
            // Merge b into a (weighted average position)
            const totalM = a.mass + b.mass;
            a.x = (a.x * a.mass + b.x * b.mass) / totalM;
            a.y = (a.y * a.mass + b.y * b.mass) / totalM;
            a.mass = totalM;
            playerCells.splice(j, 1);
            j--;
          }
        }
      }

      // Separate overlapping player cells that can't merge
      for (let i = 0; i < playerCells.length; i++) {
        for (let j = i + 1; j < playerCells.length; j++) {
          const a = playerCells[i];
          const b = playerCells[j];
          const ra = massToRadius(a.mass);
          const rb = massToRadius(b.mass);
          const d = dist(a, b);
          const minDist = ra + rb;
          if (d < minDist && d > 0) {
            const overlap = minDist - d;
            const nx = (b.x - a.x) / d;
            const ny = (b.y - a.y) / d;
            const push = overlap * 0.3;
            a.x -= nx * push;
            a.y -= ny * push;
            b.x += nx * push;
            b.y += ny * push;
          }
        }
      }

      // Player eats food
      for (const cell of playerCells) {
        for (let i = food.length - 1; i >= 0; i--) {
          const f = food[i];
          const d = dist(cell, f);
          if (d < massToRadius(cell.mass)) {
            cell.mass += f.mass;
            food.splice(i, 1);
            spawnFood(); // Keep food count steady
          }
        }
      }

      // Player eats ejected mass
      for (const cell of playerCells) {
        for (let i = ejectedMass.length - 1; i >= 0; i--) {
          const e = ejectedMass[i];
          if (e.life < 10) continue; // Don't eat your own fresh ejects
          const d = dist(cell, e);
          if (d < massToRadius(cell.mass)) {
            cell.mass += e.mass;
            ejectedMass.splice(i, 1);
          }
        }
      }

      // Update ejected mass
      for (let i = ejectedMass.length - 1; i >= 0; i--) {
        const e = ejectedMass[i];
        e.x += e.vx;
        e.y += e.vy;
        e.vx *= 0.92;
        e.vy *= 0.92;
        e.life++;
        // Clamp
        e.x = Math.max(0, Math.min(WORLD_SIZE, e.x));
        e.y = Math.max(0, Math.min(WORLD_SIZE, e.y));
        // Remove old ejected mass
        if (e.life > 600) {
          ejectedMass.splice(i, 1);
        }
      }

      // AI eats food
      for (const ai of aiCells) {
        for (let i = food.length - 1; i >= 0; i--) {
          const f = food[i];
          const d = dist(ai, f);
          if (d < massToRadius(ai.mass)) {
            ai.mass += f.mass;
            food.splice(i, 1);
            spawnFood();
          }
        }
      }

      // AI eats ejected mass
      for (const ai of aiCells) {
        for (let i = ejectedMass.length - 1; i >= 0; i--) {
          const e = ejectedMass[i];
          const d = dist(ai, e);
          if (d < massToRadius(ai.mass)) {
            ai.mass += e.mass;
            ejectedMass.splice(i, 1);
          }
        }
      }

      // Player vs AI collisions
      for (let pi = playerCells.length - 1; pi >= 0; pi--) {
        const pc = playerCells[pi];
        for (let ai = aiCells.length - 1; ai >= 0; ai--) {
          const ac = aiCells[ai];
          if (canEat(pc, ac) && overlaps(pc, ac)) {
            // Player eats AI
            pc.mass += ac.mass;
            aiCells.splice(ai, 1);
            // Respawn a new AI
            setTimeout(() => { if (gameState === 'playing') spawnAI(); }, 3000);
          } else if (canEat(ac, pc) && overlaps(ac, pc)) {
            // AI eats player cell
            ac.mass += pc.mass;
            playerCells.splice(pi, 1);
            break;
          }
        }
      }

      // AI vs AI collisions
      for (let i = aiCells.length - 1; i >= 0; i--) {
        for (let j = aiCells.length - 1; j >= 0; j--) {
          if (i === j || i >= aiCells.length || j >= aiCells.length) continue;
          const a = aiCells[i];
          const b = aiCells[j];
          if (canEat(a, b) && overlaps(a, b)) {
            a.mass += b.mass;
            aiCells.splice(j, 1);
            if (j < i) i--;
            setTimeout(() => { if (gameState === 'playing') spawnAI(); }, 5000);
          }
        }
      }

      // Update AI
      for (const ai of aiCells) {
        updateAI(ai);
      }

      // Check if player is dead
      if (playerCells.length === 0) {
        gameOver();
        return;
      }

      // Update score
      score = getTotalMass();
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Update camera
      const center = getPlayerCenter();
      camera.x = center.x;
      camera.y = center.y;
      // Zoom out as player grows
      const totalMass = getTotalMass();
      const targetZoom = Math.max(0.15, Math.min(1, 40 / (massToRadius(totalMass) + 30)));
      camera.zoom += (targetZoom - camera.zoom) * 0.05;

      // Update leaderboard
      if (frameCount % 30 === 0) {
        updateLeaderboard();
      }

      // Maintain food count
      while (food.length < FOOD_COUNT) {
        spawnFood();
      }

      // Maintain AI count
      // (handled by respawn timers above)

      // Expose game data for ML
      window.gameData = {
        playerX: center.x,
        playerY: center.y,
        playerMass: totalMass,
        playerCells: playerCells.length,
        aiCount: aiCells.length,
        foodCount: food.length,
        zoom: camera.zoom
      };
    }

    // --- Leaderboard ---
    function updateLeaderboard() {
      leaderboard = [];
      // Add player
      const totalMass = getTotalMass();
      if (totalMass > 0) {
        leaderboard.push({ name: 'You', mass: totalMass, isPlayer: true });
      }
      // Add AI
      for (const ai of aiCells) {
        leaderboard.push({ name: ai.name, mass: Math.floor(ai.mass), isPlayer: false });
      }
      leaderboard.sort((a, b) => b.mass - a.mass);
      leaderboard = leaderboard.slice(0, 10);
    }

    // --- Drawing ---
    function worldToScreen(wx, wy) {
      return {
        x: (wx - camera.x) * camera.zoom + W / 2,
        y: (wy - camera.y) * camera.zoom + H / 2
      };
    }

    function drawGrid() {
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;

      // Calculate visible range
      const left = camera.x - (W / 2) / camera.zoom;
      const right = camera.x + (W / 2) / camera.zoom;
      const top = camera.y - (H / 2) / camera.zoom;
      const bottom = camera.y + (H / 2) / camera.zoom;

      const startX = Math.floor(left / GRID_SPACING) * GRID_SPACING;
      const startY = Math.floor(top / GRID_SPACING) * GRID_SPACING;

      ctx.beginPath();
      for (let x = startX; x <= right; x += GRID_SPACING) {
        if (x < 0 || x > WORLD_SIZE) continue;
        const s = worldToScreen(x, 0);
        ctx.moveTo(s.x, 0);
        ctx.lineTo(s.x, H);
      }
      for (let y = startY; y <= bottom; y += GRID_SPACING) {
        if (y < 0 || y > WORLD_SIZE) continue;
        const s = worldToScreen(0, y);
        ctx.moveTo(0, s.y);
        ctx.lineTo(W, s.y);
      }
      ctx.stroke();
    }

    function drawWorldBorder() {
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 4 * camera.zoom;
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 10;
      const tl = worldToScreen(0, 0);
      const br = worldToScreen(WORLD_SIZE, WORLD_SIZE);
      ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
      ctx.shadowBlur = 0;
    }

    function drawCell(cell, showName, nameText) {
      const pos = worldToScreen(cell.x, cell.y);
      const r = massToRadius(cell.mass) * camera.zoom;

      // Skip if off screen
      if (pos.x + r < -50 || pos.x - r > W + 50 || pos.y + r < -50 || pos.y - r > H + 50) return;

      // Cell body with glow
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, Math.max(r, 2), 0, Math.PI * 2);
      ctx.fillStyle = cell.color;
      ctx.shadowColor = cell.color;
      ctx.shadowBlur = Math.min(r * 0.5, 15);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Outline
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = Math.max(1, r * 0.08);
      ctx.stroke();

      // Name
      if (showName && r > 12) {
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fontSize = Math.max(10, Math.min(r * 0.45, 24));
        ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 4;
        ctx.fillText(nameText || '', pos.x, pos.y - fontSize * 0.4);
        // Mass number
        const massFontSize = Math.max(8, fontSize * 0.7);
        ctx.font = `${massFontSize}px 'Courier New', monospace`;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText(Math.floor(cell.mass), pos.x, pos.y + massFontSize * 0.5);
        ctx.shadowBlur = 0;
      }
    }

    function drawFood(f) {
      const pos = worldToScreen(f.x, f.y);
      const r = Math.max(massToRadius(f.mass) * camera.zoom, 2);

      if (pos.x + r < -5 || pos.x - r > W + 5 || pos.y + r < -5 || pos.y - r > H + 5) return;

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      ctx.fillStyle = f.color;
      ctx.shadowColor = f.color;
      ctx.shadowBlur = 4;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawEjected(e) {
      const pos = worldToScreen(e.x, e.y);
      const r = Math.max(massToRadius(e.mass) * camera.zoom, 3);

      if (pos.x + r < -5 || pos.x - r > W + 5 || pos.y + r < -5 || pos.y - r > H + 5) return;

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
      ctx.fillStyle = e.color;
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawLeaderboard() {
      const lbX = W - 160;
      const lbY = 10;
      const lbW = 150;
      const lineH = 18;
      const count = Math.min(leaderboard.length, 10);
      const lbH = 26 + count * lineH + 6;

      ctx.fillStyle = 'rgba(22, 33, 62, 0.8)';
      ctx.strokeStyle = 'rgba(15, 52, 96, 0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(lbX, lbY, lbW, lbH, 6);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#a6c';
      ctx.font = 'bold 12px Courier New, monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Leaderboard', lbX + 8, lbY + 6);

      ctx.font = '11px Courier New, monospace';
      for (let i = 0; i < count; i++) {
        const entry = leaderboard[i];
        ctx.fillStyle = entry.isPlayer ? '#a6c' : '#888';
        const text = `${i + 1}. ${entry.name}`;
        ctx.fillText(text, lbX + 8, lbY + 24 + i * lineH);
        ctx.fillText(entry.mass, lbX + lbW - 40, lbY + 24 + i * lineH);
      }
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'waiting') {
        // Draw some decorative cells on waiting screen
        ctx.globalAlpha = 0.3;
        for (let i = 0; i < 15; i++) {
          const x = 50 + (i * 41) % W;
          const y = 50 + (i * 67) % H;
          const r = 10 + (i * 7) % 30;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fillStyle = CELL_COLORS[i % CELL_COLORS.length];
          ctx.shadowColor = CELL_COLORS[i % CELL_COLORS.length];
          ctx.shadowBlur = 8;
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        return;
      }

      // Draw grid
      drawGrid();

      // Draw world border
      drawWorldBorder();

      // Draw food
      for (const f of food) {
        drawFood(f);
      }

      // Draw ejected mass
      for (const e of ejectedMass) {
        drawEjected(e);
      }

      // Collect all cells for depth sorting (draw smaller cells first)
      const allCells = [];
      for (const ai of aiCells) {
        allCells.push({ cell: ai, type: 'ai' });
      }
      for (const pc of playerCells) {
        allCells.push({ cell: pc, type: 'player' });
      }
      allCells.sort((a, b) => a.cell.mass - b.cell.mass);

      // Draw all cells
      for (const entry of allCells) {
        if (entry.type === 'ai') {
          drawCell(entry.cell, true, entry.cell.name);
        } else {
          drawCell(entry.cell, true, 'You');
        }
      }

      // Draw leaderboard
      drawLeaderboard();

      // Draw minimap
      drawMinimap();
    }

    function drawMinimap() {
      const mmSize = 100;
      const mmX = W - mmSize - 10;
      const mmY = H - mmSize - 10;
      const scale = mmSize / WORLD_SIZE;

      // Background
      ctx.fillStyle = 'rgba(22, 33, 62, 0.8)';
      ctx.strokeStyle = 'rgba(15, 52, 96, 0.6)';
      ctx.lineWidth = 1;
      ctx.fillRect(mmX, mmY, mmSize, mmSize);
      ctx.strokeRect(mmX, mmY, mmSize, mmSize);

      // Food dots (sparse, just for ambiance)
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      for (let i = 0; i < food.length; i += 10) {
        const f = food[i];
        ctx.fillRect(mmX + f.x * scale, mmY + f.y * scale, 1, 1);
      }

      // AI cells
      for (const ai of aiCells) {
        const r = Math.max(1, massToRadius(ai.mass) * scale);
        ctx.fillStyle = ai.color;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(mmX + ai.x * scale, mmY + ai.y * scale, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Player cells
      for (const pc of playerCells) {
        const r = Math.max(2, massToRadius(pc.mass) * scale);
        ctx.fillStyle = '#a6c';
        ctx.shadowColor = '#a6c';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(mmX + pc.x * scale, mmY + pc.y * scale, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Viewport indicator
      const vl = camera.x - (W / 2) / camera.zoom;
      const vt = camera.y - (H / 2) / camera.zoom;
      const vw = W / camera.zoom;
      const vh = H / camera.zoom;
      ctx.strokeStyle = 'rgba(170, 102, 204, 0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(
        mmX + Math.max(0, vl) * scale,
        mmY + Math.max(0, vt) * scale,
        Math.min(vw, WORLD_SIZE) * scale,
        Math.min(vh, WORLD_SIZE) * scale
      );
    }

    // --- Game Loop ---
    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'W'].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ') {
          splitPlayer();
        }
        if (e.key === 'w' || e.key === 'W') {
          ejectMass();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Mouse controls
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
      mouse.active = true;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.active = false;
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // --- Start ---
    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

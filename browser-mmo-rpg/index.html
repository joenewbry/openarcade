<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browser MMO RPG</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #ee44aa; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(228,68,170,0.4); }
    h1 { color: #ee44aa; font-size: 1.6rem; text-shadow: 0 0 15px rgba(228,68,170,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #ee44aa; }
    canvas {
      border: 2px solid #ee44aa;
      box-shadow: 0 0 20px rgba(228,68,170,0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ee44aa;
      text-align: center;
      pointer-events: none;
      background: rgba(26,26,46,0.92);
    }
    .overlay.active { pointer-events: auto; }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(228,68,170,0.5); }
    .overlay p { font-size: 0.9rem; color: #aaa; margin: 4px 0; }
    .overlay .btn {
      margin: 8px;
      padding: 10px 28px;
      background: transparent;
      border: 2px solid #ee44aa;
      color: #ee44aa;
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .overlay .btn:hover {
      background: #ee44aa;
      color: #1a1a2e;
      box-shadow: 0 0 15px rgba(228,68,170,0.5);
    }
    .controls {
      width: 600px;
      margin-top: 10px;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BROWSER MMO RPG</h1>
  </div>
  <div class="score-bar">
    <div>Level: <span id="levelDisp">1</span></div>
    <div>XP: <span id="xpDisp">0</span></div>
    <div>Gold: <span id="goldDisp">0</span></div>
    <div>Score: <span id="score">0</span></div>
  </div>
  <div style="position:relative;display:inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay active" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">BROWSER MMO RPG</h2>
      <p id="overlayMsg">Choose your class</p>
      <div id="overlayBtns">
        <button class="btn" onclick="startGame('warrior')">Warrior</button>
        <button class="btn" onclick="startGame('mage')">Mage</button>
        <button class="btn" onclick="startGame('ranger')">Ranger</button>
      </div>
    </div>
  </div>
  <div class="controls">
    WASD=Move | Click=Attack/Interact | 1-4=Abilities | I=Inventory | M=Map | Q=Quest Log | E=Interact
  </div>
  <script>
  // ========== GLOBALS ==========
  let gameState = 'menu'; // menu, playing, dead, paused, inventory, map, shop, questboard
  let score = 0;
  const C = document.getElementById('game');
  const ctx = C.getContext('2d');
  const W = 600, H = 500;
  const TILE = 32;
  const ACCENT = '#ee44aa';
  const ACCENT2 = '#ff66cc';

  // ========== WORLD MAP DATA ==========
  // World is 120x100 tiles. Zones: Town(center), Forest(east), Dungeon(north), PvP Arena(west)
  const WORLD_W = 120, WORLD_H = 100;
  const ZONES = {
    town: { x: 45, y: 40, w: 30, h: 20, name: 'Town of Haven', color: '#554433' },
    forest: { x: 80, y: 30, w: 35, h: 40, name: 'Darkwood Forest', color: '#1a3a1a' },
    dungeon: { x: 40, y: 5, w: 25, h: 25, name: 'Obsidian Dungeon', color: '#2a1a2a' },
    pvp: { x: 5, y: 35, w: 25, h: 25, name: 'PvP Arena', color: '#3a1a1a' }
  };

  // Tile types: 0=grass, 1=water, 2=wall, 3=path, 4=floor, 5=tree, 6=dungeon_floor, 7=lava, 8=sand
  let worldMap = [];
  let camera = { x: 0, y: 0 };

  function generateWorld() {
    worldMap = [];
    for (let y = 0; y < WORLD_H; y++) {
      worldMap[y] = [];
      for (let x = 0; x < WORLD_W; x++) {
        worldMap[y][x] = 0; // grass default
      }
    }
    // Water borders
    for (let y = 0; y < WORLD_H; y++) for (let x = 0; x < WORLD_W; x++) {
      if (x < 2 || x >= WORLD_W-2 || y < 2 || y >= WORLD_H-2) worldMap[y][x] = 1;
    }
    // Town zone - floor + walls
    let tz = ZONES.town;
    for (let y = tz.y; y < tz.y+tz.h; y++) for (let x = tz.x; x < tz.x+tz.w; x++) {
      worldMap[y][x] = 4;
      if (y === tz.y || y === tz.y+tz.h-1 || x === tz.x || x === tz.x+tz.w-1) worldMap[y][x] = 2;
    }
    // Town entrances
    worldMap[tz.y][tz.x+15] = 4; worldMap[tz.y+tz.h-1][tz.x+15] = 4;
    worldMap[tz.y+10][tz.x] = 4; worldMap[tz.y+10][tz.x+tz.w-1] = 4;
    // Town paths
    for (let x = tz.x+1; x < tz.x+tz.w-1; x++) worldMap[tz.y+10][x] = 3;
    for (let y = tz.y+1; y < tz.y+tz.h-1; y++) worldMap[y][tz.x+15] = 3;
    // Forest zone - trees
    let fz = ZONES.forest;
    for (let y = fz.y; y < fz.y+fz.h; y++) for (let x = fz.x; x < fz.x+fz.w; x++) {
      if (Math.random() < 0.35) worldMap[y][x] = 5;
    }
    // Dungeon zone
    let dz = ZONES.dungeon;
    for (let y = dz.y; y < dz.y+dz.h; y++) for (let x = dz.x; x < dz.x+dz.w; x++) {
      worldMap[y][x] = 6;
      if (y === dz.y || y === dz.y+dz.h-1 || x === dz.x || x === dz.x+dz.w-1) worldMap[y][x] = 2;
    }
    worldMap[dz.y+dz.h-1][dz.x+12] = 6; // entrance
    // Dungeon rooms
    for (let r = 0; r < 5; r++) {
      let rx = dz.x + 3 + Math.floor(Math.random()*18);
      let ry = dz.y + 3 + Math.floor(Math.random()*18);
      for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++) {
        let ty = ry+dy, tx = rx+dx;
        if (ty > dz.y && ty < dz.y+dz.h-1 && tx > dz.x && tx < dz.x+dz.w-1) worldMap[ty][tx] = 6;
      }
    }
    // PvP arena
    let pz = ZONES.pvp;
    for (let y = pz.y; y < pz.y+pz.h; y++) for (let x = pz.x; x < pz.x+pz.w; x++) {
      worldMap[y][x] = 8;
      if (y === pz.y || y === pz.y+pz.h-1 || x === pz.x || x === pz.x+pz.w-1) worldMap[y][x] = 7;
    }
    worldMap[pz.y+pz.h-1][pz.x+12] = 8; // entrance
    // Roads connecting zones
    for (let x = tz.x+tz.w; x < fz.x; x++) worldMap[tz.y+10][x] = 3;
    for (let y = dz.y+dz.h; y < tz.y; y++) worldMap[y][tz.x+15] = 3;
    for (let x = pz.x+pz.w; x < tz.x; x++) worldMap[pz.y+12][x] = 3;
    for (let y = pz.y+12; y <= tz.y+10; y++) worldMap[y][pz.x+pz.w] = 3;
    // Random water ponds
    for (let i = 0; i < 8; i++) {
      let px = 10 + Math.floor(Math.random()*100);
      let py = 10 + Math.floor(Math.random()*80);
      for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++) {
        if (dx*dx+dy*dy <= 5 && worldMap[py+dy] && worldMap[py+dy][px+dx] === 0) worldMap[py+dy][px+dx] = 1;
      }
    }
  }

  function isSolid(tx, ty) {
    if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return true;
    let t = worldMap[ty][tx];
    return t === 1 || t === 2 || t === 5 || t === 7;
  }

  // ========== CLASSES & ABILITIES ==========
  const CLASS_DATA = {
    warrior: {
      name: 'Warrior', hp: 120, mp: 30, str: 14, def: 12, spd: 3, int: 5, color: '#cc4444',
      abilities: [
        { name: 'Slash', cost: 0, cd: 500, dmg: 1.2, range: 48, desc: 'Basic melee attack', type: 'melee' },
        { name: 'Shield Bash', cost: 8, cd: 3000, dmg: 1.5, range: 48, desc: 'Stun enemy briefly', type: 'melee', stun: 1000 },
        { name: 'Whirlwind', cost: 15, cd: 6000, dmg: 2.0, range: 64, desc: 'Hit all nearby enemies', type: 'aoe' },
        { name: 'War Cry', cost: 10, cd: 10000, dmg: 0, range: 0, desc: '+50% damage for 5s', type: 'buff', duration: 5000 }
      ]
    },
    mage: {
      name: 'Mage', hp: 70, mp: 100, str: 6, def: 6, spd: 3, int: 16, color: '#4466ff',
      abilities: [
        { name: 'Firebolt', cost: 5, cd: 600, dmg: 1.3, range: 180, desc: 'Ranged fire attack', type: 'ranged', projSpd: 6 },
        { name: 'Ice Nova', cost: 15, cd: 4000, dmg: 1.8, range: 80, desc: 'Freeze nearby enemies', type: 'aoe', slow: 2000 },
        { name: 'Lightning', cost: 20, cd: 5000, dmg: 2.5, range: 200, desc: 'Chain lightning', type: 'ranged', chain: 2 },
        { name: 'Heal', cost: 25, cd: 8000, dmg: -2.0, range: 0, desc: 'Restore health', type: 'heal' }
      ]
    },
    ranger: {
      name: 'Ranger', hp: 90, mp: 50, str: 10, def: 8, spd: 4, int: 10, color: '#44cc44',
      abilities: [
        { name: 'Arrow', cost: 0, cd: 400, dmg: 1.1, range: 200, desc: 'Ranged arrow', type: 'ranged', projSpd: 8 },
        { name: 'Multi-Shot', cost: 10, cd: 3000, dmg: 0.8, range: 180, desc: 'Fire 3 arrows', type: 'ranged', projSpd: 7, multi: 3 },
        { name: 'Trap', cost: 12, cd: 5000, dmg: 1.5, range: 0, desc: 'Place a trap', type: 'trap' },
        { name: 'Companion', cost: 20, cd: 15000, dmg: 0, range: 0, desc: 'Summon wolf ally', type: 'summon', duration: 10000 }
      ]
    }
  };

  // ========== ITEM DATA ==========
  const ITEM_TEMPLATES = {
    // Weapons
    rusty_sword: { name: 'Rusty Sword', type: 'weapon', slot: 'weapon', str: 2, value: 10, sprite: 'sword', rarity: 0 },
    iron_sword: { name: 'Iron Sword', type: 'weapon', slot: 'weapon', str: 5, value: 50, sprite: 'sword', rarity: 1 },
    flame_blade: { name: 'Flame Blade', type: 'weapon', slot: 'weapon', str: 10, int: 3, value: 200, sprite: 'sword', rarity: 2 },
    oak_staff: { name: 'Oak Staff', type: 'weapon', slot: 'weapon', int: 4, value: 30, sprite: 'staff', rarity: 0 },
    crystal_staff: { name: 'Crystal Staff', type: 'weapon', slot: 'weapon', int: 10, mp: 20, value: 250, sprite: 'staff', rarity: 2 },
    hunting_bow: { name: 'Hunting Bow', type: 'weapon', slot: 'weapon', str: 3, spd: 1, value: 25, sprite: 'bow', rarity: 0 },
    longbow: { name: 'Longbow', type: 'weapon', slot: 'weapon', str: 7, spd: 1, value: 120, sprite: 'bow', rarity: 1 },
    // Armor
    leather_armor: { name: 'Leather Armor', type: 'armor', slot: 'armor', def: 3, value: 20, sprite: 'armor', rarity: 0 },
    chain_mail: { name: 'Chain Mail', type: 'armor', slot: 'armor', def: 7, value: 80, sprite: 'armor', rarity: 1 },
    plate_armor: { name: 'Plate Armor', type: 'armor', slot: 'armor', def: 14, hp: 20, value: 300, sprite: 'armor', rarity: 2 },
    mage_robe: { name: 'Mage Robe', type: 'armor', slot: 'armor', def: 2, int: 5, mp: 15, value: 100, sprite: 'robe', rarity: 1 },
    // Accessories
    health_ring: { name: 'Health Ring', type: 'accessory', slot: 'accessory', hp: 20, value: 60, sprite: 'ring', rarity: 1 },
    power_amulet: { name: 'Power Amulet', type: 'accessory', slot: 'accessory', str: 4, value: 80, sprite: 'amulet', rarity: 1 },
    // Consumables
    health_potion: { name: 'Health Potion', type: 'consumable', healHp: 40, value: 15, sprite: 'potion_r', rarity: 0 },
    mana_potion: { name: 'Mana Potion', type: 'consumable', healMp: 30, value: 15, sprite: 'potion_b', rarity: 0 },
    super_health: { name: 'Super Health Potion', type: 'consumable', healHp: 100, value: 50, sprite: 'potion_r', rarity: 1 },
    // Quest items
    wolf_fang: { name: 'Wolf Fang', type: 'quest', value: 5, sprite: 'fang', rarity: 0 },
    dark_crystal: { name: 'Dark Crystal', type: 'quest', value: 25, sprite: 'crystal', rarity: 1 },
    ancient_relic: { name: 'Ancient Relic', type: 'quest', value: 100, sprite: 'relic', rarity: 2 }
  };

  const SHOP_ITEMS = ['health_potion','mana_potion','super_health','iron_sword','chain_mail','longbow','mage_robe','health_ring','power_amulet'];

  // ========== ENEMY DATA ==========
  const ENEMY_TYPES = {
    slime: { name: 'Slime', hp: 25, str: 4, def: 2, spd: 1, xp: 15, color: '#44cc44', size: 12, zone: 'town', drops: ['health_potion'], dropRate: 0.3 },
    wolf: { name: 'Wolf', hp: 40, str: 7, def: 3, spd: 2.5, xp: 25, color: '#888888', size: 14, zone: 'forest', drops: ['wolf_fang','health_potion'], dropRate: 0.4 },
    goblin: { name: 'Goblin', hp: 50, str: 9, def: 5, spd: 2, xp: 35, color: '#66aa33', size: 13, zone: 'forest', drops: ['health_potion','mana_potion','leather_armor'], dropRate: 0.35 },
    bandit: { name: 'Bandit', hp: 70, str: 12, def: 7, spd: 2, xp: 50, color: '#aa6633', size: 14, zone: 'forest', drops: ['iron_sword','chain_mail','health_potion'], dropRate: 0.3 },
    skeleton: { name: 'Skeleton', hp: 60, str: 11, def: 8, spd: 1.5, xp: 45, color: '#ccccaa', size: 14, zone: 'dungeon', drops: ['mana_potion','dark_crystal'], dropRate: 0.35 },
    wraith: { name: 'Wraith', hp: 80, str: 15, def: 6, spd: 2.5, xp: 65, color: '#8844cc', size: 15, zone: 'dungeon', drops: ['dark_crystal','crystal_staff','mage_robe'], dropRate: 0.3 },
    dark_knight: { name: 'Dark Knight', hp: 120, str: 18, def: 14, spd: 1.5, xp: 90, color: '#333355', size: 16, zone: 'dungeon', drops: ['flame_blade','plate_armor','super_health'], dropRate: 0.4 },
    dragon_boss: { name: 'Shadow Dragon', hp: 500, str: 30, def: 20, spd: 1.2, xp: 500, color: '#cc2222', size: 28, zone: 'dungeon', drops: ['ancient_relic','flame_blade','plate_armor','crystal_staff'], dropRate: 1.0, boss: true },
    pvp_champion: { name: 'Arena Champion', hp: 150, str: 20, def: 12, spd: 2.5, xp: 100, color: '#ccaa22', size: 16, zone: 'pvp', drops: ['super_health','power_amulet'], dropRate: 0.5 }
  };

  // ========== QUEST DATA ==========
  const QUEST_TEMPLATES = [
    { id: 'q_slimes', name: 'Slime Cleanup', desc: 'Kill 5 slimes near town', type: 'kill', target: 'slime', count: 5, xpReward: 80, goldReward: 30, zone: 'town' },
    { id: 'q_wolves', name: 'Wolf Menace', desc: 'Collect 3 wolf fangs', type: 'collect', target: 'wolf_fang', count: 3, xpReward: 120, goldReward: 50, zone: 'forest' },
    { id: 'q_goblins', name: 'Goblin Camp', desc: 'Kill 8 goblins in the forest', type: 'kill', target: 'goblin', count: 8, xpReward: 200, goldReward: 80, zone: 'forest' },
    { id: 'q_bandits', name: 'Bandit Bounty', desc: 'Kill 5 bandits', type: 'kill', target: 'bandit', count: 5, xpReward: 250, goldReward: 100, zone: 'forest' },
    { id: 'q_crystals', name: 'Dark Research', desc: 'Collect 3 dark crystals', type: 'collect', target: 'dark_crystal', count: 3, xpReward: 300, goldReward: 120, zone: 'dungeon' },
    { id: 'q_skeletons', name: 'Bone Yard', desc: 'Kill 10 skeletons', type: 'kill', target: 'skeleton', count: 10, xpReward: 350, goldReward: 150, zone: 'dungeon' },
    { id: 'q_boss', name: 'Slay the Dragon', desc: 'Defeat the Shadow Dragon', type: 'kill', target: 'dragon_boss', count: 1, xpReward: 1000, goldReward: 500, zone: 'dungeon' },
    { id: 'q_arena', name: 'Arena Challenge', desc: 'Defeat 3 arena champions', type: 'kill', target: 'pvp_champion', count: 3, xpReward: 400, goldReward: 200, zone: 'pvp' }
  ];

  // ========== PLAYER & ENTITIES ==========
  let player = null;
  let party = []; // AI party members
  let enemies = [];
  let npcs = [];
  let projectiles = [];
  let particles = [];
  let traps = [];
  let drops = []; // items on ground
  let floatingTexts = [];
  let questLog = [];
  let availableQuests = [];
  let completedQuests = new Set();

  // ========== INPUT ==========
  let keys = {};
  let mouse = { x: 0, y: 0, clicked: false, worldX: 0, worldY: 0 };
  document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (['i','m','q','e','1','2','3','4'].includes(e.key.toLowerCase())) e.preventDefault();
    handleKeyPress(e.key.toLowerCase());
  });
  document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
  C.addEventListener('mousemove', e => {
    let r = C.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.worldX = mouse.x + camera.x;
    mouse.worldY = mouse.y + camera.y;
  });
  C.addEventListener('click', e => {
    let r = C.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.worldX = mouse.x + camera.x;
    mouse.worldY = mouse.y + camera.y;
    mouse.clicked = true;
  });

  function handleKeyPress(k) {
    if (gameState === 'playing') {
      if (k === 'i') { gameState = 'inventory'; return; }
      if (k === 'm') { gameState = 'map'; return; }
      if (k === 'q') { gameState = 'questlog'; return; }
      if (k === 'e') interactNearby();
      if (k >= '1' && k <= '4') useAbility(parseInt(k)-1);
    } else if (gameState === 'inventory' || gameState === 'map' || gameState === 'questlog') {
      if (k === 'i' || k === 'm' || k === 'q' || k === 'escape') gameState = 'playing';
    } else if (gameState === 'shop' || gameState === 'questboard') {
      if (k === 'escape' || k === 'e') gameState = 'playing';
    }
  }

  // ========== PLAYER CREATION ==========
  function createPlayer(cls) {
    let cd = CLASS_DATA[cls];
    player = {
      x: (ZONES.town.x + 15) * TILE, y: (ZONES.town.y + 10) * TILE,
      class: cls, className: cd.name, color: cd.color,
      maxHp: cd.hp, hp: cd.hp, maxMp: cd.mp, mp: cd.mp,
      str: cd.str, def: cd.def, spd: cd.spd, int: cd.int,
      level: 1, xp: 0, xpToLevel: 100,
      gold: 50,
      abilities: cd.abilities.map(a => ({ ...a, cdTimer: 0 })),
      equipment: { weapon: null, armor: null, accessory: null },
      inventory: [],
      buffs: [],
      attackCd: 0,
      facing: { x: 0, y: 1 },
      invuln: 0,
      size: 14
    };
    // Starting items
    if (cls === 'warrior') addItem('rusty_sword');
    else if (cls === 'mage') addItem('oak_staff');
    else addItem('hunting_bow');
    addItem('health_potion');
    addItem('health_potion');
    addItem('mana_potion');
    // Auto-equip starting weapon
    let wpn = player.inventory.find(i => i.type === 'weapon');
    if (wpn) equipItem(player.inventory.indexOf(wpn));
  }

  function addItem(templateId) {
    let t = ITEM_TEMPLATES[templateId];
    if (!t) return false;
    if (player.inventory.length >= 20) { addFloatingText(player.x, player.y-20, 'Inventory Full!', '#ff4444'); return false; }
    player.inventory.push({ ...t, templateId });
    return true;
  }

  function equipItem(idx) {
    let item = player.inventory[idx];
    if (!item || !item.slot) return;
    let old = player.equipment[item.slot];
    if (old) {
      // Remove old stats
      if (old.str) player.str -= old.str;
      if (old.def) player.def -= old.def;
      if (old.int) player.int -= old.int;
      if (old.hp) { player.maxHp -= old.hp; player.hp = Math.min(player.hp, player.maxHp); }
      if (old.mp) { player.maxMp -= old.mp; player.mp = Math.min(player.mp, player.maxMp); }
      if (old.spd) player.spd -= old.spd;
      player.inventory.push(old);
    }
    // Apply new stats
    if (item.str) player.str += item.str;
    if (item.def) player.def += item.def;
    if (item.int) player.int += item.int;
    if (item.hp) { player.maxHp += item.hp; }
    if (item.mp) { player.maxMp += item.mp; }
    if (item.spd) player.spd += item.spd;
    player.equipment[item.slot] = item;
    player.inventory.splice(idx, 1);
  }

  function useItem(idx) {
    let item = player.inventory[idx];
    if (!item) return;
    if (item.type === 'consumable') {
      if (item.healHp) { player.hp = Math.min(player.hp + item.healHp, player.maxHp); addFloatingText(player.x, player.y-20, '+'+item.healHp+' HP', '#44ff44'); }
      if (item.healMp) { player.mp = Math.min(player.mp + item.healMp, player.maxMp); addFloatingText(player.x, player.y-20, '+'+item.healMp+' MP', '#4488ff'); }
      player.inventory.splice(idx, 1);
    } else if (item.slot) {
      equipItem(idx);
    }
  }

  // ========== AI PARTY MEMBER ==========
  function createPartyMember() {
    let classes = ['warrior','mage','ranger'].filter(c => c !== player.class);
    let cls = classes[Math.floor(Math.random()*classes.length)];
    let cd = CLASS_DATA[cls];
    return {
      x: player.x + 30, y: player.y + 30,
      class: cls, className: cd.name, color: cd.color, name: ['Aria','Kael','Luna','Theron','Lyra','Finn'][Math.floor(Math.random()*6)],
      maxHp: cd.hp, hp: cd.hp, maxMp: cd.mp, mp: cd.mp,
      str: cd.str, def: cd.def, spd: cd.spd, int: cd.int,
      abilities: cd.abilities.map(a => ({ ...a, cdTimer: 0 })),
      attackCd: 0, target: null, state: 'follow', size: 13,
      level: 1
    };
  }

  // ========== ENEMY SPAWNING ==========
  function spawnEnemies() {
    enemies = [];
    // Town slimes
    for (let i = 0; i < 6; i++) spawnEnemy('slime', ZONES.town);
    // Forest enemies
    for (let i = 0; i < 10; i++) spawnEnemy('wolf', ZONES.forest);
    for (let i = 0; i < 8; i++) spawnEnemy('goblin', ZONES.forest);
    for (let i = 0; i < 5; i++) spawnEnemy('bandit', ZONES.forest);
    // Dungeon enemies
    for (let i = 0; i < 8; i++) spawnEnemy('skeleton', ZONES.dungeon);
    for (let i = 0; i < 5; i++) spawnEnemy('wraith', ZONES.dungeon);
    for (let i = 0; i < 3; i++) spawnEnemy('dark_knight', ZONES.dungeon);
    // Boss
    spawnEnemy('dragon_boss', ZONES.dungeon, ZONES.dungeon.x+12, ZONES.dungeon.y+5);
    // PvP champions
    for (let i = 0; i < 4; i++) spawnEnemy('pvp_champion', ZONES.pvp);
  }

  function spawnEnemy(type, zone, fx, fy) {
    let et = ENEMY_TYPES[type];
    let x, y, attempts = 0;
    if (fx !== undefined) { x = fx; y = fy; }
    else {
      do {
        x = zone.x + 2 + Math.floor(Math.random()*(zone.w-4));
        y = zone.y + 2 + Math.floor(Math.random()*(zone.h-4));
        attempts++;
      } while (isSolid(x, y) && attempts < 50);
    }
    enemies.push({
      x: x*TILE, y: y*TILE,
      type, ...et,
      maxHp: et.hp, curHp: et.hp,
      homeX: x*TILE, homeY: y*TILE,
      target: null, state: 'idle', stateTimer: 0,
      attackCd: 0, stunTimer: 0, slowTimer: 0,
      alive: true, respawnTimer: 0, spawnZone: zone
    });
  }

  // ========== NPC SPAWNING ==========
  function spawnNPCs() {
    npcs = [];
    let tz = ZONES.town;
    // Merchant
    npcs.push({ x: (tz.x+5)*TILE, y: (tz.y+5)*TILE, name: 'Merchant', type: 'shop', color: '#ddaa33', dialog: 'Buy or sell goods!', size: 14 });
    // Quest Board
    npcs.push({ x: (tz.x+25)*TILE, y: (tz.y+5)*TILE, name: 'Quest Board', type: 'questboard', color: '#aa8855', dialog: 'Check available quests!', size: 14 });
    // Inn Keeper
    npcs.push({ x: (tz.x+15)*TILE, y: (tz.y+15)*TILE, name: 'Innkeeper', type: 'inn', color: '#cc8866', dialog: 'Rest and restore HP/MP!', size: 14 });
    // Guild Master
    npcs.push({ x: (tz.x+10)*TILE, y: (tz.y+8)*TILE, name: 'Guild Master', type: 'guild', color: '#8866cc', dialog: 'Join a guild for bonuses!', size: 14 });
  }

  // ========== COMBAT ==========
  function calcDamage(atk, def, str, baseDmg) {
    let dmg = Math.max(1, Math.floor((str * baseDmg) - def * 0.4 + (Math.random()*4-2)));
    return dmg;
  }

  function useAbility(idx) {
    if (!player || idx >= player.abilities.length) return;
    let ab = player.abilities[idx];
    if (ab.cdTimer > 0) return;
    if (player.mp < ab.cost) { addFloatingText(player.x, player.y-20, 'No Mana!', '#4488ff'); return; }
    player.mp -= ab.cost;
    ab.cdTimer = ab.cd;
    let buffMult = player.buffs.some(b => b.type === 'dmgup') ? 1.5 : 1.0;
    let strStat = player.class === 'mage' ? player.int : player.str;

    if (ab.type === 'melee') {
      let range = ab.range;
      enemies.forEach(e => {
        if (!e.alive) return;
        let dx = e.x - player.x, dy = e.y - player.y;
        if (Math.sqrt(dx*dx+dy*dy) < range) {
          let dmg = Math.floor(calcDamage(strStat, e.def, strStat, ab.dmg) * buffMult);
          damageEnemy(e, dmg);
          if (ab.stun) e.stunTimer = ab.stun;
          spawnHitParticles(e.x, e.y, e.color);
        }
      });
    } else if (ab.type === 'ranged') {
      let count = ab.multi || 1;
      for (let i = 0; i < count; i++) {
        let angle = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);
        if (count > 1) angle += (i - (count-1)/2) * 0.2;
        projectiles.push({
          x: player.x, y: player.y, vx: Math.cos(angle)*(ab.projSpd||5), vy: Math.sin(angle)*(ab.projSpd||5),
          dmg: Math.floor(calcDamage(strStat, 0, strStat, ab.dmg) * buffMult), owner: 'player', life: 60,
          color: player.color, size: 4, chain: ab.chain || 0
        });
      }
    } else if (ab.type === 'aoe') {
      let range = ab.range;
      enemies.forEach(e => {
        if (!e.alive) return;
        let dx = e.x - player.x, dy = e.y - player.y;
        if (Math.sqrt(dx*dx+dy*dy) < range) {
          let dmg = Math.floor(calcDamage(strStat, e.def, strStat, ab.dmg) * buffMult);
          damageEnemy(e, dmg);
          if (ab.slow) e.slowTimer = ab.slow;
          spawnHitParticles(e.x, e.y, '#88ccff');
        }
      });
      // Visual
      particles.push({ x: player.x, y: player.y, size: range, life: 15, maxLife: 15, color: ACCENT, type: 'ring' });
    } else if (ab.type === 'heal') {
      let heal = Math.floor(Math.abs(ab.dmg) * player.int);
      player.hp = Math.min(player.hp + heal, player.maxHp);
      addFloatingText(player.x, player.y-20, '+'+heal+' HP', '#44ff44');
      party.forEach(p => { p.hp = Math.min(p.hp + Math.floor(heal*0.5), p.maxHp); });
      particles.push({ x: player.x, y: player.y, size: 40, life: 20, maxLife: 20, color: '#44ff44', type: 'ring' });
    } else if (ab.type === 'buff') {
      player.buffs.push({ type: 'dmgup', duration: ab.duration, timer: ab.duration });
      addFloatingText(player.x, player.y-30, 'War Cry!', '#ffaa44');
    } else if (ab.type === 'trap') {
      traps.push({ x: player.x, y: player.y, dmg: Math.floor(calcDamage(strStat, 0, strStat, ab.dmg) * buffMult), life: 600, owner: 'player', size: 10 });
    } else if (ab.type === 'summon') {
      let wolf = {
        x: player.x + 30, y: player.y,
        maxHp: 60, hp: 60, str: player.str, def: 5, spd: 3,
        color: '#aa8844', size: 12, name: 'Wolf',
        attackCd: 0, target: null, state: 'follow', timer: ab.duration, isSummon: true
      };
      party.push(wolf);
    }
  }

  function damageEnemy(e, dmg) {
    e.curHp -= dmg;
    addFloatingText(e.x, e.y - 20, '-'+dmg, '#ff4444');
    e.state = 'aggro';
    e.target = player;
    if (e.curHp <= 0) {
      e.alive = false;
      e.respawnTimer = 600 + Math.random()*300;
      // XP + drops
      let xp = e.xp + Math.floor(e.xp * 0.1 * (player.level - 1));
      giveXP(xp);
      // Quest tracking
      questLog.forEach(q => {
        if (q.type === 'kill' && q.target === e.type) q.progress = Math.min(q.progress+1, q.count);
      });
      // Drops
      if (Math.random() < e.dropRate && e.drops && e.drops.length > 0) {
        let dropId = e.drops[Math.floor(Math.random()*e.drops.length)];
        drops.push({ x: e.x, y: e.y, item: { ...ITEM_TEMPLATES[dropId], templateId: dropId }, life: 900 });
      }
      // Gold drop
      let gold = Math.floor(e.xp * 0.3 + Math.random()*5);
      player.gold += gold;
      addFloatingText(e.x, e.y - 30, '+'+gold+' gold', '#ffdd44');
      score += e.xp;
      for (let i = 0; i < 8; i++) particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 30, maxLife: 30, color: e.color, size: 3, type: 'spark' });
    }
  }

  function giveXP(xp) {
    player.xp += xp;
    score += Math.floor(xp * 0.5);
    while (player.xp >= player.xpToLevel) {
      player.xp -= player.xpToLevel;
      player.level++;
      player.xpToLevel = Math.floor(player.xpToLevel * 1.5);
      // Level up stats
      let cd = CLASS_DATA[player.class];
      player.maxHp += 10 + Math.floor(cd.hp * 0.08);
      player.hp = player.maxHp;
      player.maxMp += 5 + Math.floor(cd.mp * 0.05);
      player.mp = player.maxMp;
      player.str += 1 + (player.class === 'warrior' ? 1 : 0);
      player.def += 1;
      player.int += 1 + (player.class === 'mage' ? 1 : 0);
      addFloatingText(player.x, player.y - 40, 'LEVEL UP! Lv.'+player.level, '#ffdd44');
      particles.push({ x: player.x, y: player.y, size: 50, life: 30, maxLife: 30, color: '#ffdd44', type: 'ring' });
      // Level party
      party.forEach(p => { if (!p.isSummon) { p.level++; p.maxHp += 8; p.hp = p.maxHp; p.str += 1; p.def += 1; }});
    }
  }

  // ========== NPC INTERACTION ==========
  function interactNearby() {
    // Check NPCs
    npcs.forEach(npc => {
      let dx = npc.x - player.x, dy = npc.y - player.y;
      if (Math.sqrt(dx*dx+dy*dy) < 50) {
        if (npc.type === 'shop') gameState = 'shop';
        else if (npc.type === 'questboard') { refreshQuests(); gameState = 'questboard'; }
        else if (npc.type === 'inn') {
          if (player.gold >= 10) {
            player.gold -= 10;
            player.hp = player.maxHp;
            player.mp = player.maxMp;
            addFloatingText(player.x, player.y-20, 'Rested! Full HP/MP', '#44ff44');
          } else { addFloatingText(player.x, player.y-20, 'Need 10 gold!', '#ff4444'); }
        } else if (npc.type === 'guild') {
          addFloatingText(npc.x, npc.y-20, 'Guild: +10% XP bonus!', '#8866cc');
        }
      }
    });
    // Pick up drops
    for (let i = drops.length-1; i >= 0; i--) {
      let d = drops[i];
      let dx = d.x - player.x, dy = d.y - player.y;
      if (Math.sqrt(dx*dx+dy*dy) < 40) {
        if (addItem(d.item.templateId)) {
          // Quest collect tracking
          questLog.forEach(q => {
            if (q.type === 'collect' && q.target === d.item.templateId) q.progress = Math.min(q.progress+1, q.count);
          });
          drops.splice(i, 1);
        }
      }
    }
  }

  function refreshQuests() {
    availableQuests = QUEST_TEMPLATES.filter(q => !completedQuests.has(q.id) && !questLog.find(ql => ql.id === q.id));
  }

  function acceptQuest(idx) {
    if (questLog.length >= 5) return;
    let q = availableQuests[idx];
    if (!q) return;
    questLog.push({ ...q, progress: 0 });
    availableQuests.splice(idx, 1);
  }

  function checkQuestCompletion() {
    for (let i = questLog.length-1; i >= 0; i--) {
      let q = questLog[i];
      if (q.progress >= q.count) {
        giveXP(q.xpReward);
        player.gold += q.goldReward;
        score += q.xpReward;
        addFloatingText(player.x, player.y-40, 'Quest Complete! +'+q.xpReward+'XP +'+q.goldReward+'G', '#ffdd44');
        completedQuests.add(q.id);
        questLog.splice(i, 1);
      }
    }
  }

  // ========== PARTICLES & EFFECTS ==========
  function spawnHitParticles(x, y, color) {
    for (let i = 0; i < 5; i++) particles.push({ x, y, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, life: 15, maxLife: 15, color, size: 2, type: 'spark' });
  }

  function addFloatingText(x, y, text, color) {
    floatingTexts.push({ x, y, text, color, life: 60, maxLife: 60 });
  }

  // ========== UPDATE ==========
  let lastTime = 0;
  function update(dt) {
    if (gameState !== 'playing') return;
    // Player movement
    let mx = 0, my = 0;
    if (keys['w'] || keys['arrowup']) my = -1;
    if (keys['s'] || keys['arrowdown']) my = 1;
    if (keys['a'] || keys['arrowleft']) mx = -1;
    if (keys['d'] || keys['arrowright']) mx = 1;
    if (mx || my) {
      let len = Math.sqrt(mx*mx+my*my);
      mx /= len; my /= len;
      player.facing = { x: mx, y: my };
      let nx = player.x + mx * player.spd;
      let ny = player.y + my * player.spd;
      let tx = Math.floor(nx / TILE), ty = Math.floor(ny / TILE);
      if (!isSolid(tx, ty)) { player.x = nx; player.y = ny; }
      else {
        tx = Math.floor((player.x + mx*player.spd)/TILE);
        ty = Math.floor(player.y/TILE);
        if (!isSolid(tx, ty)) player.x += mx * player.spd;
        else {
          tx = Math.floor(player.x/TILE);
          ty = Math.floor((player.y + my*player.spd)/TILE);
          if (!isSolid(tx, ty)) player.y += my * player.spd;
        }
      }
    }
    // Mouse click attack
    if (mouse.clicked) {
      mouse.clicked = false;
      useAbility(0); // basic attack
    }
    // Update cooldowns
    player.abilities.forEach(a => { if (a.cdTimer > 0) a.cdTimer = Math.max(0, a.cdTimer - 16); });
    // Update buffs
    player.buffs = player.buffs.filter(b => { b.timer -= 16; return b.timer > 0; });
    // Mana regen
    player.mp = Math.min(player.mp + 0.02, player.maxMp);
    // Invulnerability
    if (player.invuln > 0) player.invuln -= 16;

    // Camera
    camera.x = Math.max(0, Math.min(player.x - W/2, WORLD_W*TILE - W));
    camera.y = Math.max(0, Math.min(player.y - H/2, WORLD_H*TILE - H));

    // Update enemies
    enemies.forEach(e => {
      if (!e.alive) {
        e.respawnTimer -= 1;
        if (e.respawnTimer <= 0) {
          e.alive = true;
          e.curHp = e.hp + Math.floor(e.hp * 0.05 * (player.level - 1));
          e.maxHp = e.curHp;
          e.x = e.homeX; e.y = e.homeY;
          e.state = 'idle'; e.target = null;
        }
        return;
      }
      if (e.stunTimer > 0) { e.stunTimer -= 16; return; }
      let spdMult = e.slowTimer > 0 ? 0.3 : 1;
      if (e.slowTimer > 0) e.slowTimer -= 16;
      e.attackCd = Math.max(0, e.attackCd - 16);
      // AI
      let dx = player.x - e.x, dy = player.y - e.y;
      let dist = Math.sqrt(dx*dx+dy*dy);
      let aggroRange = e.boss ? 200 : 150;
      let leashRange = 400;

      if (e.state === 'idle') {
        e.stateTimer -= 1;
        if (e.stateTimer <= 0) {
          e.stateTimer = 60 + Math.random()*120;
          // Random wander
          let angle = Math.random()*Math.PI*2;
          e.wanderX = e.x + Math.cos(angle)*40;
          e.wanderY = e.y + Math.sin(angle)*40;
        }
        if (e.wanderX) {
          let wdx = e.wanderX - e.x, wdy = e.wanderY - e.y;
          let wdist = Math.sqrt(wdx*wdx+wdy*wdy);
          if (wdist > 2) { e.x += (wdx/wdist)*e.spd*0.3*spdMult; e.y += (wdy/wdist)*e.spd*0.3*spdMult; }
        }
        if (dist < aggroRange) { e.state = 'aggro'; e.target = player; }
      } else if (e.state === 'aggro') {
        let homeDx = e.homeX - e.x, homeDy = e.homeY - e.y;
        let homeDist = Math.sqrt(homeDx*homeDx+homeDy*homeDy);
        if (homeDist > leashRange) { e.state = 'return'; e.target = null; }
        else if (dist < 40) {
          // Attack
          if (e.attackCd <= 0) {
            let dmg = calcDamage(e.str, player.def, e.str, 1.0);
            if (player.invuln <= 0) {
              player.hp -= dmg;
              player.invuln = 200;
              addFloatingText(player.x, player.y-20, '-'+dmg, '#ff6666');
              spawnHitParticles(player.x, player.y, '#ff4444');
            }
            e.attackCd = e.boss ? 1200 : 800;
          }
        } else {
          e.x += (dx/dist)*e.spd*spdMult;
          e.y += (dy/dist)*e.spd*spdMult;
        }
      } else if (e.state === 'return') {
        let hdx = e.homeX - e.x, hdy = e.homeY - e.y;
        let hd = Math.sqrt(hdx*hdx+hdy*hdy);
        if (hd < 10) { e.state = 'idle'; e.curHp = e.maxHp; }
        else { e.x += (hdx/hd)*e.spd; e.y += (hdy/hd)*e.spd; }
      }
    });

    // Update party AI
    party.forEach((p, pi) => {
      if (p.isSummon) { p.timer -= 16; if (p.timer <= 0) { party.splice(pi, 1); return; } }
      p.attackCd = Math.max(0, p.attackCd - 16);
      // Find nearest enemy
      let nearestE = null, nearestD = 150;
      enemies.forEach(e => {
        if (!e.alive) return;
        let d = Math.sqrt((e.x-p.x)**2+(e.y-p.y)**2);
        if (d < nearestD) { nearestD = d; nearestE = e; }
      });
      if (nearestE && nearestD < 120) {
        p.state = 'attack';
        p.target = nearestE;
        let dx = nearestE.x - p.x, dy = nearestE.y - p.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        if (dist > 35) { p.x += (dx/dist)*p.spd; p.y += (dy/dist)*p.spd; }
        else if (p.attackCd <= 0) {
          let dmg = calcDamage(p.str, nearestE.def, p.str, 1.0);
          damageEnemy(nearestE, dmg);
          p.attackCd = 800;
          spawnHitParticles(nearestE.x, nearestE.y, p.color);
        }
      } else {
        p.state = 'follow';
        let dx = player.x - p.x + (pi+1)*20, dy = player.y - p.y + 20;
        let dist = Math.sqrt(dx*dx+dy*dy);
        if (dist > 40) { p.x += (dx/dist)*p.spd; p.y += (dy/dist)*p.spd; }
      }
      // Regen
      p.hp = Math.min(p.hp + 0.01, p.maxHp);
      p.mp = Math.min(p.mp + 0.02, p.maxMp);
    });

    // Update projectiles
    for (let i = projectiles.length-1; i >= 0; i--) {
      let p = projectiles[i];
      p.x += p.vx; p.y += p.vy; p.life--;
      if (p.life <= 0) { projectiles.splice(i, 1); continue; }
      // Check tile collision
      let tx = Math.floor(p.x/TILE), ty = Math.floor(p.y/TILE);
      if (isSolid(tx, ty)) { projectiles.splice(i, 1); continue; }

      if (p.owner === 'player') {
        for (let e of enemies) {
          if (!e.alive) continue;
          let dx = e.x - p.x, dy = e.y - p.y;
          if (Math.sqrt(dx*dx+dy*dy) < e.size + p.size) {
            let dmg = Math.max(1, p.dmg - Math.floor(e.def*0.3));
            damageEnemy(e, dmg);
            spawnHitParticles(e.x, e.y, p.color);
            // Chain lightning
            if (p.chain > 0) {
              let nearest = null, nd = 120;
              enemies.forEach(e2 => {
                if (!e2.alive || e2 === e) return;
                let d = Math.sqrt((e2.x-e.x)**2+(e2.y-e.y)**2);
                if (d < nd) { nd = d; nearest = e2; }
              });
              if (nearest) {
                let angle = Math.atan2(nearest.y - e.y, nearest.x - e.x);
                projectiles.push({ x: e.x, y: e.y, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5, dmg: Math.floor(p.dmg*0.7), owner: 'player', life: 30, color: '#88aaff', size: 3, chain: p.chain-1 });
              }
            }
            projectiles.splice(i, 1);
            break;
          }
        }
      }
    }

    // Update traps
    for (let i = traps.length-1; i >= 0; i--) {
      let t = traps[i]; t.life--;
      if (t.life <= 0) { traps.splice(i, 1); continue; }
      enemies.forEach(e => {
        if (!e.alive) return;
        let dx = e.x - t.x, dy = e.y - t.y;
        if (Math.sqrt(dx*dx+dy*dy) < 25) {
          damageEnemy(e, t.dmg);
          e.slowTimer = 2000;
          spawnHitParticles(e.x, e.y, '#ffaa44');
          traps.splice(i, 1);
        }
      });
    }

    // Update drops (auto-pickup nearby)
    for (let i = drops.length-1; i >= 0; i--) {
      drops[i].life--;
      if (drops[i].life <= 0) { drops.splice(i, 1); continue; }
      let d = drops[i];
      let dx = d.x - player.x, dy = d.y - player.y;
      if (Math.sqrt(dx*dx+dy*dy) < 30) {
        if (addItem(d.item.templateId)) {
          questLog.forEach(q => {
            if (q.type === 'collect' && q.target === d.item.templateId) q.progress = Math.min(q.progress+1, q.count);
          });
          drops.splice(i, 1);
        }
      }
    }

    // Update particles
    for (let i = particles.length-1; i >= 0; i--) {
      let p = particles[i]; p.life--;
      if (p.vx) { p.x += p.vx; p.y += p.vy; }
      if (p.life <= 0) particles.splice(i, 1);
    }
    // Update floating texts
    for (let i = floatingTexts.length-1; i >= 0; i--) {
      floatingTexts[i].y -= 0.5;
      floatingTexts[i].life--;
      if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }

    // Check quests
    checkQuestCompletion();

    // Check player death
    if (player.hp <= 0) {
      gameState = 'dead';
      showOverlay('YOU DIED', 'Level ' + player.level + ' | Score: ' + score, [{ text: 'Respawn in Town', action: 'respawn' }]);
    }

    // Update HUD
    document.getElementById('levelDisp').textContent = player.level;
    document.getElementById('xpDisp').textContent = player.xp + '/' + player.xpToLevel;
    document.getElementById('goldDisp').textContent = player.gold;
    document.getElementById('score').textContent = score;
  }

  // ========== RENDERING ==========
  const TILE_COLORS = {
    0: '#2a4a2a', 1: '#223355', 2: '#555555', 3: '#887755', 4: '#665544', 5: '#1a3a1a', 6: '#332233', 7: '#cc3300', 8: '#aa9966'
  };

  function draw() {
    ctx.fillStyle = '#111122';
    ctx.fillRect(0, 0, W, H);

    if (gameState === 'menu') return;

    // Draw tiles
    let startTX = Math.floor(camera.x / TILE);
    let startTY = Math.floor(camera.y / TILE);
    let endTX = startTX + Math.ceil(W/TILE) + 1;
    let endTY = startTY + Math.ceil(H/TILE) + 1;

    for (let ty = startTY; ty <= endTY; ty++) {
      for (let tx = startTX; tx <= endTX; tx++) {
        if (ty < 0 || ty >= WORLD_H || tx < 0 || tx >= WORLD_W) continue;
        let t = worldMap[ty][tx];
        let sx = tx * TILE - camera.x, sy = ty * TILE - camera.y;
        ctx.fillStyle = TILE_COLORS[t] || '#2a4a2a';
        ctx.fillRect(sx, sy, TILE, TILE);
        // Tile detail
        if (t === 5) { // Tree
          ctx.fillStyle = '#0d2a0d';
          ctx.beginPath();
          ctx.arc(sx+16, sy+10, 12, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#553311';
          ctx.fillRect(sx+14, sy+18, 4, 14);
        } else if (t === 1) { // Water shimmer
          ctx.fillStyle = 'rgba(100,150,255,0.1)';
          ctx.fillRect(sx + (Math.sin(Date.now()/500+tx)*4), sy + (Math.cos(Date.now()/400+ty)*3), 8, 2);
        } else if (t === 7) { // Lava
          ctx.fillStyle = 'rgba(255,200,0,'+(0.2+Math.sin(Date.now()/200+tx+ty)*0.1)+')';
          ctx.fillRect(sx, sy, TILE, TILE);
        } else if (t === 3) { // Path stones
          ctx.fillStyle = '#776644';
          ctx.fillRect(sx+4, sy+4, 6, 6);
          ctx.fillRect(sx+18, sy+18, 8, 8);
        }
      }
    }

    // Draw drops
    drops.forEach(d => {
      let sx = d.x - camera.x, sy = d.y - camera.y;
      if (sx < -20 || sx > W+20 || sy < -20 || sy > H+20) return;
      let bob = Math.sin(Date.now()/300) * 3;
      ctx.fillStyle = d.item.rarity >= 2 ? '#ff44ff' : d.item.rarity >= 1 ? '#4488ff' : '#ffffff';
      ctx.fillRect(sx-5, sy-5+bob, 10, 10);
      ctx.strokeStyle = '#ffffff';
      ctx.strokeRect(sx-5, sy-5+bob, 10, 10);
    });

    // Draw traps
    traps.forEach(t => {
      let sx = t.x - camera.x, sy = t.y - camera.y;
      ctx.fillStyle = 'rgba(255,170,60,0.3)';
      ctx.beginPath(); ctx.arc(sx, sy, t.size, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#ffaa44';
      ctx.beginPath(); ctx.arc(sx, sy, t.size, 0, Math.PI*2); ctx.stroke();
    });

    // Draw NPCs
    npcs.forEach(npc => {
      let sx = npc.x - camera.x, sy = npc.y - camera.y;
      if (sx < -30 || sx > W+30 || sy < -30 || sy > H+30) return;
      drawCharacter(sx, sy, npc.size, npc.color, npc.name, true);
      // Interaction indicator
      let dx = npc.x - player.x, dy = npc.y - player.y;
      if (Math.sqrt(dx*dx+dy*dy) < 60) {
        ctx.fillStyle = '#ffdd44';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('[E] ' + npc.name, sx, sy - 24);
      }
    });

    // Draw enemies
    enemies.forEach(e => {
      if (!e.alive) return;
      let sx = e.x - camera.x, sy = e.y - camera.y;
      if (sx < -30 || sx > W+30 || sy < -30 || sy > H+30) return;
      // Body
      ctx.fillStyle = e.color;
      if (e.boss) {
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 15;
      }
      ctx.beginPath(); ctx.arc(sx, sy, e.size, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Eyes
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(sx-4, sy-3, 3, 3);
      ctx.fillRect(sx+2, sy-3, 3, 3);
      // HP bar
      let barW = e.size * 2;
      ctx.fillStyle = '#333';
      ctx.fillRect(sx - barW/2, sy - e.size - 8, barW, 4);
      ctx.fillStyle = e.curHp/e.maxHp > 0.5 ? '#44cc44' : e.curHp/e.maxHp > 0.25 ? '#ccaa44' : '#cc4444';
      ctx.fillRect(sx - barW/2, sy - e.size - 8, barW * (e.curHp/e.maxHp), 4);
      // Name
      ctx.fillStyle = e.boss ? '#ff4444' : '#cccccc';
      ctx.font = (e.boss ? 'bold ' : '') + '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(e.name + (e.boss ? ' [BOSS]' : ''), sx, sy - e.size - 12);
      // Stun/slow indicator
      if (e.stunTimer > 0) {
        ctx.fillStyle = '#ffff44';
        ctx.font = '8px Courier New';
        ctx.fillText('STUNNED', sx, sy + e.size + 10);
      }
    });

    // Draw party
    party.forEach(p => {
      let sx = p.x - camera.x, sy = p.y - camera.y;
      if (sx < -30 || sx > W+30 || sy < -30 || sy > H+30) return;
      drawCharacter(sx, sy, p.size, p.color, p.name, false);
      // HP bar
      let barW = 24;
      ctx.fillStyle = '#333';
      ctx.fillRect(sx - barW/2, sy - 20, barW, 3);
      ctx.fillStyle = '#44cc44';
      ctx.fillRect(sx - barW/2, sy - 20, barW * (p.hp/p.maxHp), 3);
    });

    // Draw player
    if (player) {
      let sx = player.x - camera.x, sy = player.y - camera.y;
      let flash = player.invuln > 0 && Math.floor(player.invuln/50) % 2;
      if (!flash) {
        drawCharacter(sx, sy, player.size, player.color, null, false);
        // Direction indicator
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(sx + player.facing.x*12, sy + player.facing.y*12, 3, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Draw projectiles
    projectiles.forEach(p => {
      let sx = p.x - camera.x, sy = p.y - camera.y;
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.arc(sx, sy, p.size, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
    });

    // Draw particles
    particles.forEach(p => {
      let alpha = p.life / p.maxLife;
      if (p.type === 'ring') {
        ctx.strokeStyle = p.color;
        ctx.globalAlpha = alpha * 0.5;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x - camera.x, p.y - camera.y, p.size * (1 - alpha) + 5, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
      } else {
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - camera.x - p.size/2, p.y - camera.y - p.size/2, p.size, p.size);
        ctx.globalAlpha = 1;
      }
    });

    // Draw floating texts
    floatingTexts.forEach(ft => {
      let sx = ft.x - camera.x, sy = ft.y - camera.y;
      ctx.globalAlpha = ft.life / ft.maxLife;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(ft.text, sx, sy);
      ctx.globalAlpha = 1;
    });

    // ===== HUD =====
    drawHUD();

    // ===== UI OVERLAYS =====
    if (gameState === 'inventory') drawInventory();
    if (gameState === 'map') drawMap();
    if (gameState === 'questlog') drawQuestLog();
    if (gameState === 'shop') drawShop();
    if (gameState === 'questboard') drawQuestBoard();
  }

  function drawCharacter(sx, sy, size, color, label, isNPC) {
    // Body
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill();
    // Outline
    ctx.strokeStyle = '#ffffff33';
    ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.stroke();
    // Eyes
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(sx-4, sy-3, 3, 3);
    ctx.fillRect(sx+2, sy-3, 3, 3);
    if (isNPC) {
      ctx.fillStyle = '#ffdd44';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('!', sx, sy - size - 6);
    }
    if (label) {
      ctx.fillStyle = '#aaaaaa';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(label, sx, sy - size - 14);
    }
  }

  function drawHUD() {
    // HP Bar
    let bx = 10, by = H - 60, bw = 150, bh = 16;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(bx-1, by-1, bw+2, bh+2);
    ctx.fillStyle = '#331111';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = player.hp/player.maxHp > 0.3 ? '#cc2222' : '#ff4444';
    ctx.fillRect(bx, by, bw * Math.max(0, player.hp/player.maxHp), bh);
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('HP: '+Math.ceil(player.hp)+'/'+player.maxHp, bx+4, by+12);

    // MP Bar
    by += 20;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(bx-1, by-1, bw+2, bh+2);
    ctx.fillStyle = '#111133';
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = '#2244cc';
    ctx.fillRect(bx, by, bw * Math.max(0, player.mp/player.maxMp), bh);
    ctx.fillStyle = '#ffffff';
    ctx.fillText('MP: '+Math.ceil(player.mp)+'/'+player.maxMp, bx+4, by+12);

    // XP Bar
    by += 20;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(bx-1, by-1, bw+2, 8);
    ctx.fillStyle = '#222211';
    ctx.fillRect(bx, by, bw, 6);
    ctx.fillStyle = '#ccaa22';
    ctx.fillRect(bx, by, bw * (player.xp/player.xpToLevel), 6);

    // Ability bar
    let abx = W/2 - 100, aby = H - 45;
    player.abilities.forEach((ab, i) => {
      let ax = abx + i * 52;
      let cdPct = ab.cdTimer / ab.cd;
      ctx.fillStyle = cdPct > 0 ? '#222233' : '#333355';
      ctx.fillRect(ax, aby, 46, 36);
      ctx.strokeStyle = cdPct > 0 ? '#444466' : ACCENT;
      ctx.strokeRect(ax, aby, 46, 36);
      if (cdPct > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(ax, aby, 46, 36 * cdPct);
      }
      ctx.fillStyle = cdPct > 0 ? '#666688' : '#ffffff';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText((i+1), ax+23, aby+12);
      ctx.font = '7px Courier New';
      ctx.fillText(ab.name, ax+23, aby+24);
      if (ab.cost > 0) {
        ctx.fillStyle = '#4488ff';
        ctx.fillText(ab.cost+'mp', ax+23, aby+33);
      }
    });

    // Zone name
    let zone = getCurrentZone();
    ctx.fillStyle = ACCENT;
    ctx.font = '11px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(zone, W/2, 18);

    // Minimap
    drawMinimap();

    // Quest tracker (top-right)
    if (questLog.length > 0) {
      ctx.fillStyle = 'rgba(26,26,46,0.8)';
      ctx.fillRect(W-180, 28, 175, questLog.length * 28 + 8);
      ctx.strokeStyle = ACCENT + '44';
      ctx.strokeRect(W-180, 28, 175, questLog.length * 28 + 8);
      ctx.font = '8px Courier New';
      ctx.textAlign = 'left';
      questLog.forEach((q, i) => {
        let y = 44 + i * 28;
        ctx.fillStyle = q.progress >= q.count ? '#44ff44' : '#cccccc';
        ctx.fillText(q.name, W-174, y);
        ctx.fillStyle = '#888888';
        ctx.fillText(q.progress + '/' + q.count, W-174, y+12);
      });
    }

    // Party status
    if (party.length > 0) {
      party.forEach((p, i) => {
        if (p.isSummon && p.timer <= 0) return;
        let px = 10, py = 10 + i * 30;
        ctx.fillStyle = 'rgba(26,26,46,0.7)';
        ctx.fillRect(px, py, 120, 25);
        ctx.fillStyle = p.color;
        ctx.font = '9px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(p.name + ' Lv' + (p.level||1), px+4, py+11);
        ctx.fillStyle = '#331111';
        ctx.fillRect(px+4, py+15, 80, 5);
        ctx.fillStyle = '#cc2222';
        ctx.fillRect(px+4, py+15, 80*(p.hp/p.maxHp), 5);
      });
    }
  }

  function drawMinimap() {
    let mx = W - 110, my = H - 100, mw = 100, mh = 80;
    ctx.fillStyle = 'rgba(10,10,20,0.85)';
    ctx.fillRect(mx, my, mw, mh);
    ctx.strokeStyle = ACCENT + '66';
    ctx.strokeRect(mx, my, mw, mh);
    let scaleX = mw / (WORLD_W*TILE), scaleY = mh / (WORLD_H*TILE);
    // Zone rects
    Object.values(ZONES).forEach(z => {
      ctx.fillStyle = z.color + '88';
      ctx.fillRect(mx + z.x*TILE*scaleX, my + z.y*TILE*scaleY, z.w*TILE*scaleX, z.h*TILE*scaleY);
    });
    // Enemies as red dots
    enemies.forEach(e => {
      if (!e.alive) return;
      ctx.fillStyle = e.boss ? '#ff0000' : '#ff444444';
      ctx.fillRect(mx + e.x*scaleX, my + e.y*scaleY, e.boss ? 3 : 1, e.boss ? 3 : 1);
    });
    // Player
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(mx + player.x*scaleX - 1, my + player.y*scaleY - 1, 3, 3);
    // Camera viewport
    ctx.strokeStyle = '#ffffff33';
    ctx.strokeRect(mx + camera.x*scaleX, my + camera.y*scaleY, W*scaleX, H*scaleY);
  }

  function getCurrentZone() {
    let ptx = Math.floor(player.x/TILE), pty = Math.floor(player.y/TILE);
    for (let [k, z] of Object.entries(ZONES)) {
      if (ptx >= z.x && ptx < z.x+z.w && pty >= z.y && pty < z.y+z.h) return z.name;
    }
    return 'Wilderness';
  }

  // ===== UI PANELS =====
  function drawPanel(x, y, w, h, title) {
    ctx.fillStyle = 'rgba(20,20,40,0.95)';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = ACCENT;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
    ctx.lineWidth = 1;
    ctx.fillStyle = ACCENT;
    ctx.font = 'bold 14px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(title, x+w/2, y+20);
    ctx.fillStyle = '#666';
    ctx.font = '9px Courier New';
    ctx.fillText('Press ESC to close', x+w/2, y+h-8);
  }

  let invCursor = 0;
  function drawInventory() {
    drawPanel(50, 30, 500, 440, 'INVENTORY');
    let ix = 60, iy = 55;
    // Equipment slots
    ctx.fillStyle = '#aaaaaa';
    ctx.font = '10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('-- Equipment --', ix, iy); iy += 16;
    ['weapon','armor','accessory'].forEach(slot => {
      let item = player.equipment[slot];
      ctx.fillStyle = item ? getRarityColor(item.rarity) : '#555555';
      ctx.fillText(slot.toUpperCase() + ': ' + (item ? item.name : '(empty)'), ix, iy);
      if (item) {
        let stats = [];
        if (item.str) stats.push('+'+item.str+' STR');
        if (item.def) stats.push('+'+item.def+' DEF');
        if (item.int) stats.push('+'+item.int+' INT');
        if (item.hp) stats.push('+'+item.hp+' HP');
        if (item.mp) stats.push('+'+item.mp+' MP');
        ctx.fillStyle = '#888888';
        ctx.fillText('  ' + stats.join(', '), ix + 200, iy);
      }
      iy += 14;
    });
    iy += 10;
    // Stats
    ctx.fillStyle = ACCENT;
    ctx.fillText('-- Stats --', ix, iy); iy += 14;
    ctx.fillStyle = '#cccccc';
    ctx.fillText('STR: '+player.str+'  DEF: '+player.def+'  INT: '+player.int+'  SPD: '+player.spd, ix, iy); iy += 14;
    ctx.fillText('HP: '+Math.ceil(player.hp)+'/'+player.maxHp+'  MP: '+Math.ceil(player.mp)+'/'+player.maxMp, ix, iy); iy += 20;
    // Inventory grid
    ctx.fillStyle = ACCENT;
    ctx.fillText('-- Backpack ('+player.inventory.length+'/20) --', ix, iy); iy += 6;
    player.inventory.forEach((item, i) => {
      let row = Math.floor(i/4), col = i%4;
      let bx = ix + col*120, by = iy + row*50;
      let hover = mouse.x >= bx && mouse.x < bx+115 && mouse.y >= by && mouse.y < by+45;
      ctx.fillStyle = hover ? '#333355' : '#222244';
      ctx.fillRect(bx, by, 115, 45);
      ctx.strokeStyle = hover ? ACCENT : '#444466';
      ctx.strokeRect(bx, by, 115, 45);
      ctx.fillStyle = getRarityColor(item.rarity);
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(item.name, bx+4, by+14);
      ctx.fillStyle = '#888888';
      ctx.font = '8px Courier New';
      ctx.fillText(item.type === 'consumable' ? 'Use' : item.slot ? 'Equip' : 'Quest', bx+4, by+26);
      ctx.fillText(item.value+'g', bx+4, by+38);
      if (hover && mouse.clicked) {
        mouse.clicked = false;
        useItem(i);
      }
    });
  }

  function drawMap() {
    drawPanel(50, 30, 500, 440, 'WORLD MAP');
    let mx = 100, my = 70, mw = 400, mh = 350;
    let scaleX = mw / (WORLD_W*TILE), scaleY = mh / (WORLD_H*TILE);
    // Zones
    Object.entries(ZONES).forEach(([k, z]) => {
      let zx = mx + z.x*TILE*scaleX, zy = my + z.y*TILE*scaleY;
      let zw = z.w*TILE*scaleX, zh = z.h*TILE*scaleY;
      ctx.fillStyle = z.color;
      ctx.fillRect(zx, zy, zw, zh);
      ctx.strokeStyle = '#888888';
      ctx.strokeRect(zx, zy, zw, zh);
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(z.name, zx+zw/2, zy+zh/2);
    });
    // Roads
    ctx.strokeStyle = '#88775544';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(mx+(ZONES.town.x+ZONES.town.w)*TILE*scaleX, my+(ZONES.town.y+10)*TILE*scaleY);
    ctx.lineTo(mx+ZONES.forest.x*TILE*scaleX, my+(ZONES.town.y+10)*TILE*scaleY);
    ctx.moveTo(mx+(ZONES.town.x+15)*TILE*scaleX, my+ZONES.town.y*TILE*scaleY);
    ctx.lineTo(mx+(ZONES.town.x+15)*TILE*scaleX, my+(ZONES.dungeon.y+ZONES.dungeon.h)*TILE*scaleY);
    ctx.stroke();
    ctx.lineWidth = 1;
    // Player dot
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(mx + player.x*scaleX, my + player.y*scaleY, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = ACCENT;
    ctx.font = '9px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('You are in: ' + getCurrentZone(), mx, my + mh + 18);
  }

  function drawQuestLog() {
    drawPanel(50, 30, 500, 440, 'QUEST LOG');
    let qx = 70, qy = 55;
    if (questLog.length === 0) {
      ctx.fillStyle = '#666666';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('No active quests. Visit the Quest Board in town!', qx, qy+20);
      return;
    }
    questLog.forEach((q, i) => {
      let by = qy + i * 70;
      ctx.fillStyle = q.progress >= q.count ? '#1a3a1a' : '#222244';
      ctx.fillRect(qx, by, 460, 62);
      ctx.strokeStyle = q.progress >= q.count ? '#44ff44' : '#444466';
      ctx.strokeRect(qx, by, 460, 62);
      ctx.fillStyle = q.progress >= q.count ? '#44ff44' : ACCENT;
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(q.name + (q.progress >= q.count ? ' [COMPLETE]' : ''), qx+8, by+16);
      ctx.fillStyle = '#aaaaaa';
      ctx.font = '9px Courier New';
      ctx.fillText(q.desc, qx+8, by+30);
      ctx.fillStyle = '#888888';
      ctx.fillText('Progress: ' + q.progress + '/' + q.count + '  |  Reward: ' + q.xpReward + 'XP, ' + q.goldReward + 'G', qx+8, by+44);
      // Progress bar
      ctx.fillStyle = '#333333';
      ctx.fillRect(qx+8, by+50, 200, 5);
      ctx.fillStyle = '#44cc44';
      ctx.fillRect(qx+8, by+50, 200*(q.progress/q.count), 5);
    });
  }

  let shopScroll = 0;
  function drawShop() {
    drawPanel(50, 30, 500, 440, 'MERCHANT - Gold: ' + player.gold);
    let sx = 70, sy = 55;
    ctx.fillStyle = ACCENT;
    ctx.font = '10px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('-- Buy --', sx, sy); sy += 6;
    SHOP_ITEMS.forEach((id, i) => {
      let item = ITEM_TEMPLATES[id];
      let by = sy + i * 40;
      if (by > 400) return;
      let hover = mouse.x >= sx && mouse.x < sx+460 && mouse.y >= by && mouse.y < by+35;
      ctx.fillStyle = hover ? '#333355' : '#222244';
      ctx.fillRect(sx, by, 460, 35);
      ctx.strokeStyle = hover ? ACCENT : '#444466';
      ctx.strokeRect(sx, by, 460, 35);
      ctx.fillStyle = getRarityColor(item.rarity);
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(item.name, sx+8, by+14);
      ctx.fillStyle = '#888888';
      ctx.font = '9px Courier New';
      let desc = [];
      if (item.str) desc.push('+'+item.str+' STR');
      if (item.def) desc.push('+'+item.def+' DEF');
      if (item.int) desc.push('+'+item.int+' INT');
      if (item.healHp) desc.push('+'+item.healHp+' HP');
      if (item.healMp) desc.push('+'+item.healMp+' MP');
      ctx.fillText(desc.join(', '), sx+8, by+26);
      ctx.fillStyle = player.gold >= item.value ? '#ffdd44' : '#ff4444';
      ctx.textAlign = 'right';
      ctx.fillText(item.value + 'g', sx+450, by+18);
      if (hover && mouse.clicked) {
        mouse.clicked = false;
        if (player.gold >= item.value) {
          player.gold -= item.value;
          addItem(id);
          addFloatingText(player.x, player.y-20, 'Bought '+item.name, '#44ff44');
        } else {
          addFloatingText(player.x, player.y-20, 'Not enough gold!', '#ff4444');
        }
      }
    });
    // Sell section
    sy = sy + SHOP_ITEMS.length * 40 + 15;
    if (sy < 410) {
      ctx.fillStyle = ACCENT;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('-- Sell (click inventory items, 50% value) --', sx, sy);
    }
  }

  function drawQuestBoard() {
    drawPanel(50, 30, 500, 440, 'QUEST BOARD');
    let qx = 70, qy = 55;
    if (availableQuests.length === 0) {
      ctx.fillStyle = '#666666';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('No quests available right now.', qx, qy+20);
      return;
    }
    availableQuests.forEach((q, i) => {
      let by = qy + i * 60;
      if (by > 420) return;
      let hover = mouse.x >= qx && mouse.x < qx+460 && mouse.y >= by && mouse.y < by+52;
      ctx.fillStyle = hover ? '#333355' : '#222244';
      ctx.fillRect(qx, by, 460, 52);
      ctx.strokeStyle = hover ? '#44ff44' : '#444466';
      ctx.strokeRect(qx, by, 460, 52);
      ctx.fillStyle = ACCENT;
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(q.name, qx+8, by+16);
      ctx.fillStyle = '#aaaaaa';
      ctx.font = '9px Courier New';
      ctx.fillText(q.desc, qx+8, by+30);
      ctx.fillStyle = '#888888';
      ctx.fillText('Reward: ' + q.xpReward + 'XP, ' + q.goldReward + 'G  |  Zone: ' + q.zone, qx+8, by+44);
      if (hover) {
        ctx.fillStyle = '#44ff44';
        ctx.textAlign = 'right';
        ctx.fillText('[CLICK TO ACCEPT]', qx+450, by+18);
      }
      if (hover && mouse.clicked) {
        mouse.clicked = false;
        acceptQuest(i);
      }
    });
  }

  function getRarityColor(r) {
    return r >= 2 ? '#cc44ff' : r >= 1 ? '#4488ff' : '#ffffff';
  }

  // ========== OVERLAY ==========
  function showOverlay(title, msg, buttons) {
    let ov = document.getElementById('overlay');
    document.getElementById('overlayTitle').textContent = title;
    document.getElementById('overlayMsg').textContent = msg;
    let btns = document.getElementById('overlayBtns');
    btns.innerHTML = '';
    if (buttons) {
      buttons.forEach(b => {
        let btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = b.text;
        btn.onclick = () => {
          if (b.action === 'respawn') respawnPlayer();
          else if (b.action === 'restart') location.reload();
        };
        btns.appendChild(btn);
      });
    }
    ov.style.display = 'flex';
    ov.classList.add('active');
  }

  function hideOverlay() {
    let ov = document.getElementById('overlay');
    ov.style.display = 'none';
    ov.classList.remove('active');
  }

  function respawnPlayer() {
    player.hp = player.maxHp;
    player.mp = player.maxMp;
    player.x = (ZONES.town.x + 15) * TILE;
    player.y = (ZONES.town.y + 10) * TILE;
    player.gold = Math.max(0, player.gold - 20);
    score = Math.max(0, score - 50);
    player.invuln = 2000;
    gameState = 'playing';
    hideOverlay();
  }

  // ========== GAME START ==========
  function startGame(cls) {
    generateWorld();
    createPlayer(cls);
    party = [createPartyMember()];
    spawnEnemies();
    spawnNPCs();
    refreshQuests();
    drops = []; projectiles = []; particles = []; floatingTexts = []; traps = [];
    score = 0;
    gameState = 'playing';
    hideOverlay();
  }
  window.startGame = startGame;

  // ========== GAME LOOP ==========
  function gameLoop(ts) {
    let dt = Math.min(ts - lastTime, 50);
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);

  // ========== EXPOSE GAME DATA ==========
  window.gameData = {};
  function updateGameData() {
    window.gameData = { gameState, score, player: player ? { level: player.level, class: player.class, hp: player.hp, maxHp: player.maxHp, gold: player.gold } : null };
  }
  setInterval(updateGameData, 500);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

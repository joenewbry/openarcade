<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plants vs Zombies</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #6d4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102, 221, 68, 0.5); }
    h1 { color: #6d4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(102, 221, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #6d4; }
    canvas {
      border: 2px solid #6d4;
      box-shadow: 0 0 20px rgba(102, 221, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6d4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PLANTS VS ZOMBIES</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">PLANTS VS ZOMBIES</h2>
      <p id="overlayText">Click or press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Layout constants
    const SIDEBAR_W = 60;       // left sidebar for plant selection
    const TOP_BAR = 50;         // top bar for sun counter
    const COLS = 9;
    const ROWS = 5;
    const CELL_W = (W - SIDEBAR_W) / COLS;  // ~60
    const CELL_H = (H - TOP_BAR) / ROWS;    // ~90

    // Plant types
    const PLANT_TYPES = [
      { name: 'Peashooter', key: '1', cost: 100, color: '#4f4', hp: 100, shootRate: 60, shootDmg: 20, sunRate: 0, slow: false, symbol: 'P' },
      { name: 'Sunflower',  key: '2', cost: 50,  color: '#ff0', hp: 60,  shootRate: 0,  shootDmg: 0,  sunRate: 300, slow: false, symbol: 'S' },
      { name: 'Wall-nut',   key: '3', cost: 50,  color: '#a86',  hp: 400, shootRate: 0,  shootDmg: 0,  sunRate: 0, slow: false, symbol: 'W' },
      { name: 'Snow Pea',   key: '4', cost: 175, color: '#0ef', hp: 100, shootRate: 60, shootDmg: 18, sunRate: 0, slow: true, symbol: 'I' }
    ];

    // Zombie types
    const ZOMBIE_TYPES = {
      basic:  { hp: 100, speed: 0.3, damage: 10, color: '#a66', headColor: '#d99', size: 14 },
      cone:   { hp: 200, speed: 0.3, damage: 10, color: '#f80', headColor: '#fa4', size: 15 },
      bucket: { hp: 400, speed: 0.25, damage: 12, color: '#888', headColor: '#aaa', size: 16 },
      flag:   { hp: 120, speed: 0.5, damage: 10, color: '#a44', headColor: '#f66', size: 14 }
    };

    // Game state
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let sun, selectedPlant, plants, zombies, projectiles, particles, suns;
    let wave, waveTimer, zombiesSpawned, zombiesInWave, frameCount;
    let mouseX = -1, mouseY = -1;

    function init() {
      score = 0;
      sun = 150;
      selectedPlant = 0;
      plants = [];
      zombies = [];
      projectiles = [];
      particles = [];
      suns = [];
      wave = 0;
      waveTimer = 0;
      zombiesSpawned = 0;
      zombiesInWave = 0;
      frameCount = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PLANTS VS ZOMBIES';
      overlayText.textContent = 'Click or press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      nextWave();
      requestAnimationFrame(loop);
    }

    function nextWave() {
      wave++;
      waveTimer = 0;
      zombiesSpawned = 0;
      // Each wave: more zombies, tougher types
      if (wave <= 2) {
        zombiesInWave = 3 + wave * 2;
      } else if (wave <= 5) {
        zombiesInWave = 5 + wave * 2;
      } else if (wave <= 10) {
        zombiesInWave = 8 + wave * 2;
      } else {
        zombiesInWave = 10 + wave * 3;
      }
    }

    function getZombieType() {
      const r = Math.random();
      if (wave <= 2) return 'basic';
      if (wave <= 4) return r < 0.7 ? 'basic' : 'cone';
      if (wave <= 6) return r < 0.5 ? 'basic' : r < 0.8 ? 'cone' : 'flag';
      if (wave <= 9) return r < 0.3 ? 'basic' : r < 0.6 ? 'cone' : r < 0.85 ? 'bucket' : 'flag';
      return r < 0.2 ? 'basic' : r < 0.45 ? 'cone' : r < 0.75 ? 'bucket' : 'flag';
    }

    function spawnZombie() {
      const type = getZombieType();
      const zt = ZOMBIE_TYPES[type];
      const row = Math.floor(Math.random() * ROWS);
      const hpMult = 1 + (wave - 1) * 0.1;
      zombies.push({
        type,
        x: W + 10,
        row,
        y: TOP_BAR + row * CELL_H + CELL_H / 2,
        hp: Math.round(zt.hp * hpMult),
        maxHp: Math.round(zt.hp * hpMult),
        speed: zt.speed,
        damage: zt.damage,
        color: zt.color,
        headColor: zt.headColor,
        size: zt.size,
        eating: false,
        slowTimer: 0
      });
      zombiesSpawned++;
    }

    function spawnSkySun() {
      const x = SIDEBAR_W + Math.random() * (W - SIDEBAR_W - 30) + 15;
      suns.push({
        x, y: -20,
        targetY: TOP_BAR + Math.random() * (H - TOP_BAR - 60) + 30,
        speed: 0.5,
        falling: true,
        life: 600, // disappears after 10 seconds
        size: 16,
        collected: false,
        collectAnim: 0
      });
    }

    function spawnPlantSun(px, py) {
      suns.push({
        x: px + (Math.random() - 0.5) * 20,
        y: py - 10,
        targetY: py + 15 + Math.random() * 20,
        speed: 0.4,
        falling: true,
        life: 480,
        size: 14,
        collected: false,
        collectAnim: 0
      });
    }

    function gridToPixel(col, row) {
      return {
        x: SIDEBAR_W + col * CELL_W + CELL_W / 2,
        y: TOP_BAR + row * CELL_H + CELL_H / 2
      };
    }

    function pixelToGrid(px, py) {
      const col = Math.floor((px - SIDEBAR_W) / CELL_W);
      const row = Math.floor((py - TOP_BAR) / CELL_H);
      return { col, row };
    }

    function canPlace(col, row) {
      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return false;
      return !plants.some(p => p.col === col && p.row === row);
    }

    function placePlant(col, row) {
      if (gameState !== 'playing') return;
      const type = PLANT_TYPES[selectedPlant];
      if (sun < type.cost) return;
      if (!canPlace(col, row)) return;
      sun -= type.cost;
      const pos = gridToPixel(col, row);
      plants.push({
        col, row,
        x: pos.x, y: pos.y,
        typeIdx: selectedPlant,
        hp: type.hp,
        maxHp: type.hp,
        shootTimer: type.shootRate > 0 ? Math.floor(Math.random() * type.shootRate) : 0,
        sunTimer: type.sunRate > 0 ? Math.floor(Math.random() * type.sunRate) : 0,
        color: type.color,
        symbol: type.symbol,
        shootRate: type.shootRate,
        shootDmg: type.shootDmg,
        sunRate: type.sunRate,
        slow: type.slow
      });
      // Placement particles
      for (let i = 0; i < 5; i++) {
        particles.push({
          x: pos.x, y: pos.y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 15, color: type.color
        });
      }
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Wave: ${wave} — Click or press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Spawn sky suns
      if (frameCount % 360 === 0) {
        spawnSkySun();
      }

      // Spawn zombies for current wave
      if (zombiesSpawned < zombiesInWave) {
        waveTimer++;
        const spawnInterval = Math.max(40, 120 - wave * 5);
        if (waveTimer >= spawnInterval) {
          waveTimer = 0;
          spawnZombie();
        }
      }

      // Check wave complete — all spawned and all dead
      if (zombiesSpawned >= zombiesInWave && zombies.length === 0) {
        // Brief pause then next wave
        waveTimer++;
        if (waveTimer >= 120) {
          sun += 25; // bonus sun between waves
          nextWave();
        }
      }

      // Update suns
      for (let i = suns.length - 1; i >= 0; i--) {
        const s = suns[i];
        if (s.collected) {
          s.collectAnim++;
          // Animate toward sun counter
          s.x += (35 - s.x) * 0.15;
          s.y += (25 - s.y) * 0.15;
          s.size *= 0.95;
          if (s.collectAnim > 20) {
            suns.splice(i, 1);
          }
          continue;
        }
        if (s.falling && s.y < s.targetY) {
          s.y += s.speed;
        } else {
          s.falling = false;
        }
        s.life--;
        if (s.life <= 0) {
          suns.splice(i, 1);
        }
      }

      // Update plants
      for (let i = plants.length - 1; i >= 0; i--) {
        const p = plants[i];
        if (p.hp <= 0) {
          // Death particles
          for (let j = 0; j < 6; j++) {
            particles.push({
              x: p.x, y: p.y,
              vx: (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 3,
              life: 20, color: p.color
            });
          }
          plants.splice(i, 1);
          continue;
        }

        // Shooting plants
        if (p.shootRate > 0) {
          // Only shoot if there's a zombie in this row
          const hasTarget = zombies.some(z => z.row === p.row && z.x > p.x);
          if (hasTarget) {
            p.shootTimer++;
            if (p.shootTimer >= p.shootRate) {
              p.shootTimer = 0;
              projectiles.push({
                x: p.x + 15,
                y: p.y,
                speed: 4,
                damage: p.shootDmg,
                row: p.row,
                color: p.slow ? '#0ef' : '#4f4',
                slow: p.slow,
                size: p.slow ? 5 : 4
              });
            }
          }
        }

        // Sun-producing plants
        if (p.sunRate > 0) {
          p.sunTimer++;
          if (p.sunTimer >= p.sunRate) {
            p.sunTimer = 0;
            spawnPlantSun(p.x, p.y);
          }
        }
      }

      // Update projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        proj.x += proj.speed;

        // Check hit zombies
        let hit = false;
        for (let j = 0; j < zombies.length; j++) {
          const z = zombies[j];
          if (z.row === proj.row && Math.abs(z.x - proj.x) < z.size + 4 && z.x > SIDEBAR_W) {
            z.hp -= proj.damage;
            if (proj.slow) {
              z.slowTimer = 120; // 2 seconds slow
            }
            // Hit particles
            for (let k = 0; k < 3; k++) {
              particles.push({
                x: proj.x, y: proj.y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 10, color: proj.color
              });
            }
            hit = true;
            break;
          }
        }
        if (hit || proj.x > W + 20) {
          projectiles.splice(i, 1);
        }
      }

      // Update zombies
      for (let i = zombies.length - 1; i >= 0; i--) {
        const z = zombies[i];

        // Check if dead
        if (z.hp <= 0) {
          score++;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
          // Death particles
          for (let j = 0; j < 8; j++) {
            particles.push({
              x: z.x, y: z.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 25, color: z.headColor
            });
          }
          zombies.splice(i, 1);
          continue;
        }

        // Check if eating a plant
        z.eating = false;
        for (let j = 0; j < plants.length; j++) {
          const p = plants[j];
          if (p.row === z.row && Math.abs(z.x - p.x) < CELL_W * 0.4) {
            z.eating = true;
            if (frameCount % 30 === 0) {
              p.hp -= z.damage;
            }
            break;
          }
        }

        // Move if not eating
        if (!z.eating) {
          let speed = z.speed;
          if (z.slowTimer > 0) {
            speed *= 0.4;
            z.slowTimer--;
          }
          z.x -= speed;
        }

        // Reached the left edge — game over
        if (z.x < SIDEBAR_W - 10) {
          gameOver();
          return;
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw top bar background
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, 0, W, TOP_BAR);

      // Draw sidebar background
      ctx.fillStyle = '#121a30';
      ctx.fillRect(0, TOP_BAR, SIDEBAR_W, H - TOP_BAR);

      // Draw lawn grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = SIDEBAR_W + c * CELL_W;
          const y = TOP_BAR + r * CELL_H;
          // Alternating dark/light green tint
          const shade = (r + c) % 2 === 0 ? '#1a2a1e' : '#182418';
          ctx.fillStyle = shade;
          ctx.fillRect(x, y, CELL_W, CELL_H);
          ctx.strokeStyle = '#1e3322';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, CELL_W, CELL_H);
        }
      }

      // Row separators (brighter lines between lawn rows)
      for (let r = 0; r <= ROWS; r++) {
        const y = TOP_BAR + r * CELL_H;
        ctx.strokeStyle = '#2a4a2e';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(SIDEBAR_W, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Draw sidebar plant selection
      for (let i = 0; i < PLANT_TYPES.length; i++) {
        const pt = PLANT_TYPES[i];
        const sy = TOP_BAR + i * 90 + 10;
        const sx = 5;
        const sw = SIDEBAR_W - 10;
        const sh = 80;

        // Selection highlight
        if (i === selectedPlant) {
          ctx.fillStyle = 'rgba(102, 221, 68, 0.15)';
          ctx.fillRect(sx, sy, sw, sh);
          ctx.strokeStyle = '#6d4';
          ctx.lineWidth = 2;
          ctx.strokeRect(sx, sy, sw, sh);
        } else {
          ctx.fillStyle = 'rgba(22, 33, 62, 0.8)';
          ctx.fillRect(sx, sy, sw, sh);
          ctx.strokeStyle = '#0f3460';
          ctx.lineWidth = 1;
          ctx.strokeRect(sx, sy, sw, sh);
        }

        // Plant icon
        ctx.fillStyle = sun >= pt.cost ? pt.color : '#555';
        ctx.shadowColor = sun >= pt.cost ? pt.color : 'transparent';
        ctx.shadowBlur = sun >= pt.cost ? 6 : 0;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pt.symbol, sx + sw / 2, sy + 28);
        ctx.shadowBlur = 0;

        // Cost
        ctx.fillStyle = sun >= pt.cost ? '#ff0' : '#644';
        ctx.font = '10px Courier New';
        ctx.fillText(pt.cost, sx + sw / 2, sy + 50);

        // Key number
        ctx.fillStyle = '#666';
        ctx.font = '9px Courier New';
        ctx.fillText(pt.key, sx + sw / 2, sy + 65);
      }

      // Draw plants on grid
      plants.forEach(p => {
        const pt = PLANT_TYPES[p.typeIdx];

        // Plant body
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;

        if (p.symbol === 'P') {
          // Peashooter — circle head + stem
          ctx.fillStyle = '#2a5a2a';
          ctx.fillRect(p.x - 3, p.y + 5, 6, CELL_H * 0.3);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y - 2, 14, 0, Math.PI * 2);
          ctx.fill();
          // Mouth/barrel
          ctx.fillStyle = '#2a2';
          ctx.fillRect(p.x + 8, p.y - 5, 10, 6);
          // Eye
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(p.x + 2, p.y - 6, 3, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.symbol === 'S') {
          // Sunflower — petals + center
          ctx.fillStyle = '#2a5a2a';
          ctx.fillRect(p.x - 3, p.y + 5, 6, CELL_H * 0.3);
          // Petals
          ctx.fillStyle = '#ff0';
          for (let a = 0; a < 8; a++) {
            const angle = (a / 8) * Math.PI * 2 + frameCount * 0.01;
            const px = p.x + Math.cos(angle) * 13;
            const py = p.y - 2 + Math.sin(angle) * 13;
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fill();
          }
          // Center
          ctx.fillStyle = '#a80';
          ctx.beginPath();
          ctx.arc(p.x, p.y - 2, 8, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.symbol === 'W') {
          // Wall-nut — large brown circle
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 18, 0, Math.PI * 2);
          ctx.fill();
          // Face cracks based on damage
          const dmgRatio = p.hp / p.maxHp;
          ctx.fillStyle = '#654';
          if (dmgRatio < 0.6) {
            ctx.fillRect(p.x - 5, p.y - 8, 2, 12);
          }
          if (dmgRatio < 0.3) {
            ctx.fillRect(p.x + 3, p.y - 6, 2, 10);
            ctx.fillRect(p.x - 8, p.y + 2, 8, 2);
          }
          // Eyes
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(p.x - 5, p.y - 4, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(p.x + 5, p.y - 4, 2.5, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.symbol === 'I') {
          // Snow Pea — like peashooter but blue/icy
          ctx.fillStyle = '#1a4a5a';
          ctx.fillRect(p.x - 3, p.y + 5, 6, CELL_H * 0.3);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y - 2, 14, 0, Math.PI * 2);
          ctx.fill();
          // Ice crystals
          ctx.fillStyle = '#aef';
          ctx.fillRect(p.x + 8, p.y - 5, 10, 6);
          // Frost sparkles
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(p.x - 4, p.y - 10, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(p.x + 8, p.y + 4, 1.5, 0, Math.PI * 2);
          ctx.fill();
          // Eye
          ctx.fillStyle = '#111';
          ctx.beginPath();
          ctx.arc(p.x + 2, p.y - 6, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.shadowBlur = 0;

        // Health bar (only show if damaged)
        if (p.hp < p.maxHp) {
          const barW = 28;
          const barH = 3;
          const barX = p.x - barW / 2;
          const barY = p.y + 20;
          ctx.fillStyle = '#333';
          ctx.fillRect(barX, barY, barW, barH);
          const ratio = p.hp / p.maxHp;
          ctx.fillStyle = ratio > 0.5 ? '#4f4' : ratio > 0.25 ? '#ff0' : '#f44';
          ctx.fillRect(barX, barY, barW * ratio, barH);
        }
      });

      // Draw zombies
      zombies.forEach(z => {
        ctx.shadowColor = z.slowTimer > 0 ? '#0ef' : z.color;
        ctx.shadowBlur = 8;

        const bodyColor = z.slowTimer > 0 ? '#68a' : z.color;
        const headCol = z.slowTimer > 0 ? '#8ac' : z.headColor;

        // Legs (animated wobble)
        const legOffset = Math.sin(frameCount * 0.1 + z.x * 0.1) * 3;
        ctx.fillStyle = bodyColor;
        ctx.fillRect(z.x - 5, z.y + 8, 4, 16 + legOffset);
        ctx.fillRect(z.x + 2, z.y + 8, 4, 16 - legOffset);

        // Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(z.x - 7, z.y - 8, 14, 18);

        // Arms
        const armSwing = Math.sin(frameCount * 0.08 + z.x * 0.05) * 4;
        ctx.fillRect(z.x - 12, z.y - 4 + armSwing, 6, 3);
        ctx.fillRect(z.x + 7, z.y - 2 - armSwing, 6, 3);

        // Head
        ctx.fillStyle = headCol;
        ctx.beginPath();
        ctx.arc(z.x, z.y - 14, z.size * 0.65, 0, Math.PI * 2);
        ctx.fill();

        // Headgear for special types
        if (z.type === 'cone') {
          ctx.fillStyle = '#f80';
          ctx.beginPath();
          ctx.moveTo(z.x - 6, z.y - 18);
          ctx.lineTo(z.x + 6, z.y - 18);
          ctx.lineTo(z.x, z.y - 30);
          ctx.fill();
        } else if (z.type === 'bucket') {
          ctx.fillStyle = '#999';
          ctx.fillRect(z.x - 7, z.y - 26, 14, 14);
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;
          ctx.strokeRect(z.x - 7, z.y - 26, 14, 14);
        } else if (z.type === 'flag') {
          ctx.fillStyle = '#f44';
          ctx.fillRect(z.x + 5, z.y - 30, 12, 8);
          ctx.fillStyle = '#642';
          ctx.fillRect(z.x + 4, z.y - 30, 2, 20);
        }

        // Eyes (red glowing)
        ctx.fillStyle = '#f00';
        ctx.shadowColor = '#f00';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(z.x - 3, z.y - 16, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(z.x + 3, z.y - 16, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Health bar
        const barW = z.size + 8;
        const barH = 3;
        const barX = z.x - barW / 2;
        const barY = z.y - z.size - 16;
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barW, barH);
        const hpRatio = Math.max(0, z.hp / z.maxHp);
        ctx.fillStyle = hpRatio > 0.5 ? '#4f4' : hpRatio > 0.25 ? '#ff0' : '#f44';
        ctx.fillRect(barX, barY, barW * hpRatio, barH);
      });

      // Draw projectiles
      projectiles.forEach(proj => {
        ctx.fillStyle = proj.color;
        ctx.shadowColor = proj.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
        ctx.fill();
        // Trail
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(proj.x - 6, proj.y, proj.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      });

      // Draw suns
      suns.forEach(s => {
        if (s.collected && s.collectAnim > 15) return;
        const alpha = s.collected ? 1 - s.collectAnim / 20 : (s.life < 60 ? s.life / 60 : 1);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 12;

        // Sun shape — circle with rays
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Rays
        ctx.fillStyle = '#ffa';
        for (let r = 0; r < 8; r++) {
          const angle = (r / 8) * Math.PI * 2 + frameCount * 0.03;
          const rx = s.x + Math.cos(angle) * s.size * 0.85;
          const ry = s.y + Math.sin(angle) * s.size * 0.85;
          ctx.beginPath();
          ctx.arc(rx, ry, s.size * 0.25, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      });

      // Draw particles
      particles.forEach(p => {
        const alpha = p.life / 25;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // Draw placement preview
      if (gameState === 'playing' && mouseX > SIDEBAR_W && mouseY > TOP_BAR) {
        const g = pixelToGrid(mouseX, mouseY);
        if (g.col >= 0 && g.col < COLS && g.row >= 0 && g.row < ROWS) {
          const valid = canPlace(g.col, g.row);
          const affordable = sun >= PLANT_TYPES[selectedPlant].cost;
          const px = SIDEBAR_W + g.col * CELL_W;
          const py = TOP_BAR + g.row * CELL_H;
          ctx.fillStyle = valid && affordable ? 'rgba(102, 221, 68, 0.15)' : 'rgba(255, 68, 68, 0.12)';
          ctx.fillRect(px, py, CELL_W, CELL_H);
          ctx.strokeStyle = valid && affordable ? '#6d4' : '#f44';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(px, py, CELL_W, CELL_H);

          // Show plant symbol preview
          ctx.fillStyle = valid && affordable ? PLANT_TYPES[selectedPlant].color : '#555';
          ctx.globalAlpha = 0.5;
          ctx.font = 'bold 20px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(PLANT_TYPES[selectedPlant].symbol, px + CELL_W / 2, py + CELL_H / 2);
          ctx.globalAlpha = 1;
        }
      }

      // Top bar HUD
      // Sun counter
      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 6;
      ctx.font = 'bold 18px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('SUN: ' + sun, 10, 25);
      ctx.shadowBlur = 0;

      // Wave indicator
      ctx.fillStyle = '#6d4';
      ctx.shadowColor = '#6d4';
      ctx.shadowBlur = 4;
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('Wave ' + wave, W - 10, 18);
      ctx.shadowBlur = 0;

      // Zombies remaining
      const remaining = (zombiesInWave - zombiesSpawned) + zombies.length;
      ctx.fillStyle = '#888';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText('Zombies: ' + remaining, W - 10, 36);

      // Wave cleared text
      if (zombiesSpawned >= zombiesInWave && zombies.length === 0 && waveTimer > 0 && waveTimer < 120) {
        ctx.fillStyle = '#6d4';
        ctx.shadowColor = '#6d4';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 18px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Wave ' + wave + ' cleared!', SIDEBAR_W + (W - SIDEBAR_W) / 2, H / 2 - 15);
        ctx.fillStyle = '#aaa';
        ctx.font = '13px Courier New';
        ctx.fillText('Next wave incoming...', SIDEBAR_W + (W - SIDEBAR_W) / 2, H / 2 + 10);
        ctx.shadowBlur = 0;
      }

      // Expose game data for ML
      window.gameData = {
        sun, wave, score,
        plantCount: plants.length,
        zombieCount: zombies.length,
        selectedPlant,
        gameState
      };
    }

    // Mouse handlers
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);
    });

    canvas.addEventListener('mouseleave', () => {
      mouseX = -1;
      mouseY = -1;
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      // Check sun collection
      for (let i = suns.length - 1; i >= 0; i--) {
        const s = suns[i];
        if (s.collected) continue;
        const dx = mx - s.x;
        const dy = my - s.y;
        if (Math.sqrt(dx * dx + dy * dy) < s.size + 10) {
          s.collected = true;
          sun += 25;
          break; // collect one at a time
        }
      }

      // Check sidebar plant selection
      if (mx < SIDEBAR_W && my > TOP_BAR) {
        const idx = Math.floor((my - TOP_BAR - 10) / 90);
        if (idx >= 0 && idx < PLANT_TYPES.length) {
          selectedPlant = idx;
        }
        return;
      }

      // Place plant on grid
      if (mx > SIDEBAR_W && my > TOP_BAR) {
        const g = pixelToGrid(mx, my);
        placePlant(g.col, g.row);
      }
    });

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case '1': selectedPlant = 0; break;
          case '2': selectedPlant = 1; break;
          case '3': selectedPlant = 2; break;
          case '4': selectedPlant = 3; break;
        }
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

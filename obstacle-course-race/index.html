<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Obstacle Course Race</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #ff44aa; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 170, 0.4); }
    h1 { color: #ff44aa; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 68, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #ff44aa; }
    canvas {
      border: 2px solid #ff44aa;
      box-shadow: 0 0 20px rgba(255, 68, 170, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ff44aa;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 68, 170, 0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 6px; }
    .controls-hint { width: 600px; margin-top: 10px; font-size: 0.8rem; color: #666; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>OBSTACLE COURSE RACE</h1>
  </div>
  <div class="score-bar">
    <div>Round: <span id="roundDisplay">1</span>/3</div>
    <div>Timer: <span id="timerDisplay">0.0</span>s</div>
    <div>Score: <span id="scoreDisplay">0</span> pts</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">OBSTACLE COURSE RACE</h2>
      <p id="overlayText">Fall Guys-lite Party Racer!</p>
      <p id="overlaySubtext" style="margin-top:12px; color:#ff44aa;">Click to start</p>
    </div>
  </div>
  <div class="controls-hint">Arrows = Move/Jump &bull; Space = Dive &bull; Race through obstacles to the finish!</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const roundEl = document.getElementById('roundDisplay');
    const timerEl = document.getElementById('timerDisplay');
    const scoreEl = document.getElementById('scoreDisplay');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlaySubtext = document.getElementById('overlaySubtext');

    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });

    let gameState = 'menu';
    let score = 0;
    let round = 1;
    const TOTAL_ROUNDS = 3;
    let raceTimer = 0;
    let finishOrder = [];
    let courseLength = 3000;
    let cameraX = 0;
    let countdown = 0;
    let countdownTimer = 0;
    let obstacles = [];
    let platforms = [];
    let players = [];
    let particles = [];
    let lastTime = 0;

    const GRAVITY = 800;
    const GROUND_Y = 340;
    const PLAYER_W = 20;
    const PLAYER_H = 24;

    const COLORS = ['#ff44aa','#44aaff','#44ff88','#ffaa44'];
    const NAMES = ['You','Blue AI','Green AI','Orange AI'];

    const keys = {};
    document.addEventListener('keydown', e => { keys[e.key] = true; });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function createPlayer(idx, isHuman) {
      return {
        x: 60, y: GROUND_Y - PLAYER_H,
        vx: 0, vy: 0,
        w: PLAYER_W, h: PLAYER_H,
        color: COLORS[idx],
        name: NAMES[idx],
        idx: idx,
        isHuman: isHuman,
        onGround: true,
        finished: false,
        finishTime: 0,
        diving: false,
        diveTimer: 0,
        stunTimer: 0,
        speedBoost: 0,
        slowTimer: 0,
        facing: 1,
        runAnim: 0,
        // AI state
        ai: !isHuman ? {
          jumpCooldown: 0,
          targetSpeed: 140 + Math.random() * 40,
          reactionDelay: 0.1 + Math.random() * 0.15,
          scanTimer: 0,
          wantJump: false,
          wantDive: false,
          skill: 0.7 + Math.random() * 0.25
        } : null
      };
    }

    function generateCourse() {
      obstacles = [];
      platforms = [];
      const len = courseLength;

      // Ground segments with gaps
      let gx = 0;
      while (gx < len + 200) {
        let segLen = 200 + Math.random() * 300;
        platforms.push({ x: gx, y: GROUND_Y, w: segLen, h: 60, type: 'ground' });
        gx += segLen;
        // Occasional gap
        if (gx > 300 && gx < len - 200 && Math.random() < 0.3) {
          gx += 50 + Math.random() * 40;
        }
      }

      let ox = 250;
      while (ox < len - 100) {
        let type = ['spinner','pendulum','conveyor','slime','bounce','movingPlatform','wall'][Math.floor(Math.random() * 7)];
        let obs = { x: ox, type: type };

        switch (type) {
          case 'spinner':
            obs.y = GROUND_Y - 40;
            obs.radius = 50 + Math.random() * 20;
            obs.angle = Math.random() * Math.PI * 2;
            obs.speed = (1.5 + Math.random()) * (Math.random() < 0.5 ? 1 : -1);
            obs.barW = 8;
            break;
          case 'pendulum':
            obs.y = GROUND_Y - 120;
            obs.anchorY = obs.y - 40;
            obs.length = 60 + Math.random() * 30;
            obs.angle = Math.random() * Math.PI * 2;
            obs.speed = 1.8 + Math.random() * 0.8;
            obs.bobR = 12;
            break;
          case 'conveyor':
            obs.y = GROUND_Y - 4;
            obs.w = 100 + Math.random() * 80;
            obs.h = 8;
            obs.dir = Math.random() < 0.5 ? -1 : 1;
            obs.speed = 80 + Math.random() * 60;
            obs.animOff = 0;
            break;
          case 'slime':
            obs.y = GROUND_Y - 3;
            obs.w = 60 + Math.random() * 60;
            obs.h = 6;
            break;
          case 'bounce':
            obs.y = GROUND_Y - 6;
            obs.w = 40;
            obs.h = 10;
            obs.compressed = 0;
            break;
          case 'movingPlatform':
            obs.y = GROUND_Y - 60 - Math.random() * 50;
            obs.baseY = obs.y;
            obs.w = 60 + Math.random() * 30;
            obs.h = 10;
            obs.ampY = 20 + Math.random() * 30;
            obs.phase = Math.random() * Math.PI * 2;
            obs.speed = 1 + Math.random();
            break;
          case 'wall':
            obs.y = GROUND_Y - 40 - Math.random() * 30;
            obs.w = 15;
            obs.h = GROUND_Y - obs.y;
            break;
        }
        obstacles.push(obs);
        ox += 120 + Math.random() * 150;
      }
    }

    function startRace() {
      finishOrder = [];
      raceTimer = 0;
      cameraX = 0;
      particles = [];
      generateCourse();
      players = [];
      for (let i = 0; i < 4; i++) {
        players.push(createPlayer(i, i === 0));
        players[i].x = 40 + i * 12;
        players[i].y = GROUND_Y - PLAYER_H;
      }
      countdown = 3;
      countdownTimer = 0;
      gameState = 'countdown';
    }

    function startGame() {
      score = 0;
      round = 1;
      courseLength = 2500 + round * 500;
      startRace();
    }

    function getGroundAt(x, w) {
      for (let p of platforms) {
        if (p.type === 'ground' && x + w > p.x && x < p.x + p.w) {
          return p.y;
        }
      }
      return H + 200; // No ground - pit
    }

    function resolveCollisions(p) {
      // Platform collisions
      for (let plat of platforms) {
        if (plat.type !== 'ground') continue;
        if (p.x + p.w > plat.x && p.x < plat.x + plat.w) {
          if (p.y + p.h > plat.y && p.y + p.h < plat.y + 20 && p.vy >= 0) {
            p.y = plat.y - p.h;
            p.vy = 0;
            p.onGround = true;
          }
        }
      }

      // Moving platform collisions
      for (let obs of obstacles) {
        if (obs.type === 'movingPlatform') {
          if (p.x + p.w > obs.x && p.x < obs.x + obs.w) {
            if (p.y + p.h > obs.y && p.y + p.h < obs.y + 16 && p.vy >= 0) {
              p.y = obs.y - p.h;
              p.vy = 0;
              p.onGround = true;
            }
          }
        }
      }
    }

    function updatePlayer(p, dt) {
      if (p.finished) return;
      if (p.stunTimer > 0) { p.stunTimer -= dt; p.vx *= 0.9; }
      if (p.diveTimer > 0) { p.diveTimer -= dt; if (p.diveTimer <= 0) p.diving = false; }
      if (p.slowTimer > 0) p.slowTimer -= dt;
      if (p.speedBoost > 0) p.speedBoost -= dt;

      let maxSpeed = 180;
      if (p.slowTimer > 0) maxSpeed = 80;
      if (p.speedBoost > 0) maxSpeed = 260;

      if (p.isHuman && p.stunTimer <= 0) {
        let accel = 600;
        if (keys['ArrowRight']) { p.vx += accel * dt; p.facing = 1; }
        else if (keys['ArrowLeft']) { p.vx -= accel * dt; p.facing = -1; }
        else { p.vx *= (1 - 8 * dt); }
        if (keys['ArrowUp'] && p.onGround) { p.vy = -380; p.onGround = false; }
        if (keys[' '] && !p.diving && p.diveTimer <= 0) {
          p.diving = true;
          p.diveTimer = 0.4;
          p.vx += p.facing * 120;
          if (!p.onGround) p.vy += 150;
        }
      } else if (!p.isHuman) {
        updateAI(p, dt);
      }

      p.vx = Math.max(-maxSpeed, Math.min(maxSpeed, p.vx));
      if (!p.isHuman && p.stunTimer <= 0) {
        // AI friction handled in AI update
      }

      p.vy += GRAVITY * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.onGround = false;

      resolveCollisions(p);

      // Fell into pit
      if (p.y > H + 100) {
        p.y = GROUND_Y - PLAYER_H - 40;
        p.vy = -200;
        p.x = Math.max(p.x - 80, 40);
        p.stunTimer = 0.5;
        spawnParticles(p.x, GROUND_Y, p.color, 8);
      }

      // Obstacle interactions
      for (let obs of obstacles) {
        switch (obs.type) {
          case 'spinner': {
            let ex1 = obs.x + Math.cos(obs.angle) * obs.radius;
            let ey1 = obs.y + Math.sin(obs.angle) * obs.radius;
            let ex2 = obs.x - Math.cos(obs.angle) * obs.radius;
            let ey2 = obs.y - Math.sin(obs.angle) * obs.radius;
            let pc = { x: p.x + p.w / 2, y: p.y + p.h / 2 };
            if (distToSeg(pc, ex1, ey1, ex2, ey2) < 16) {
              let pushAngle = obs.angle + Math.PI / 2;
              p.vx += Math.cos(pushAngle) * 300 * obs.speed;
              p.vy += Math.sin(pushAngle) * 200 - 100;
              p.stunTimer = 0.4;
              spawnParticles(p.x + p.w / 2, p.y + p.h / 2, '#fff', 5);
            }
            break;
          }
          case 'pendulum': {
            let bx = obs.x + Math.sin(obs.angle) * obs.length;
            let by = obs.anchorY + Math.cos(obs.angle) * obs.length;
            let dx = (p.x + p.w / 2) - bx;
            let dy = (p.y + p.h / 2) - by;
            if (Math.sqrt(dx * dx + dy * dy) < obs.bobR + 12) {
              let swing = Math.cos(obs.angle) * obs.speed;
              p.vx += swing * 200;
              p.vy = -200;
              p.stunTimer = 0.3;
              spawnParticles(bx, by, '#ff8844', 5);
            }
            break;
          }
          case 'conveyor': {
            if (p.x + p.w > obs.x && p.x < obs.x + obs.w &&
                p.y + p.h > obs.y - 4 && p.y + p.h < obs.y + obs.h + 10 && p.onGround) {
              p.vx += obs.dir * obs.speed * dt * 3;
            }
            break;
          }
          case 'slime': {
            if (p.x + p.w > obs.x && p.x < obs.x + obs.w &&
                p.y + p.h > obs.y - 4 && p.y + p.h < obs.y + obs.h + 6) {
              p.slowTimer = 0.5;
            }
            break;
          }
          case 'bounce': {
            if (p.x + p.w > obs.x && p.x < obs.x + obs.w &&
                p.y + p.h > obs.y && p.y + p.h < obs.y + obs.h + 8 && p.vy >= 0) {
              p.vy = -500;
              p.onGround = false;
              obs.compressed = 0.2;
              spawnParticles(obs.x + obs.w / 2, obs.y, '#ffff44', 6);
            }
            break;
          }
          case 'wall': {
            if (p.x + p.w > obs.x && p.x < obs.x + obs.w &&
                p.y + p.h > obs.y && p.y < obs.y + obs.h) {
              if (p.vx > 0) { p.x = obs.x - p.w; }
              else { p.x = obs.x + obs.w; }
              p.vx *= -0.3;
            }
            break;
          }
        }
      }

      // Player-player bumping
      for (let other of players) {
        if (other === p || other.finished) continue;
        let dx = (p.x + p.w / 2) - (other.x + other.w / 2);
        let dy = (p.y + p.h / 2) - (other.y + other.h / 2);
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 20) {
          let nx = dx / (dist || 1);
          let ny = dy / (dist || 1);
          let push = 80;
          if (p.diving) push = 180;
          p.vx += nx * push * dt * 20;
          other.vx -= nx * push * dt * 20;
          if (p.diving) { other.stunTimer = 0.3; }
        }
      }

      // Run animation
      if (p.onGround && Math.abs(p.vx) > 20) {
        p.runAnim += Math.abs(p.vx) * dt * 0.05;
      }

      // Finish line
      if (p.x > courseLength && !p.finished) {
        p.finished = true;
        p.finishTime = raceTimer;
        finishOrder.push(p.idx);
        spawnParticles(p.x, p.y, p.color, 20);
      }
    }

    function updateAI(p, dt) {
      let ai = p.ai;
      ai.scanTimer -= dt;
      if (ai.jumpCooldown > 0) ai.jumpCooldown -= dt;

      // Move right toward finish
      let accel = 500;
      let targetVx = ai.targetSpeed;

      // Scan for nearby obstacles
      if (ai.scanTimer <= 0) {
        ai.scanTimer = ai.reactionDelay;
        ai.wantJump = false;
        ai.wantDive = false;

        let lookAhead = 80 + Math.abs(p.vx) * 0.3;

        for (let obs of obstacles) {
          let odist = obs.x - p.x;
          if (odist < -40 || odist > lookAhead) continue;

          switch (obs.type) {
            case 'spinner':
              if (odist < 60 && Math.abs(obs.y - (p.y + p.h / 2)) < obs.radius + 20) {
                let armY1 = obs.y + Math.sin(obs.angle) * obs.radius;
                let armY2 = obs.y - Math.sin(obs.angle) * obs.radius;
                let dangerY = Math.min(armY1, armY2);
                if (dangerY > p.y - 20 || Math.random() > ai.skill) {
                  ai.wantJump = true;
                }
              }
              break;
            case 'pendulum':
              if (odist < 70) {
                let bx = obs.x + Math.sin(obs.angle) * obs.length;
                let by = obs.anchorY + Math.cos(obs.angle) * obs.length;
                if (Math.abs(bx - p.x) < 40 && by > p.y - 20) {
                  if (Math.random() < ai.skill) {
                    targetVx *= 0.3; // Slow down and wait
                  } else {
                    ai.wantJump = true;
                  }
                }
              }
              break;
            case 'wall':
              if (odist < 50 && odist > -10) {
                ai.wantJump = true;
              }
              break;
            case 'slime':
              if (odist < 60 && odist > -10) {
                ai.wantJump = true;
              }
              break;
            case 'bounce':
              // Run into bounce pads intentionally
              if (odist < 50 && odist > 0) {
                targetVx = ai.targetSpeed * 1.1;
              }
              break;
            case 'conveyor':
              if (odist < 60 && obs.dir < 0) {
                targetVx = ai.targetSpeed * 1.3;
              }
              break;
          }
        }

        // Check for gaps in ground
        let groundAhead = getGroundAt(p.x + 40, p.w);
        if (groundAhead > H) {
          ai.wantJump = true;
        }

        // Occasionally dive for speed
        if (Math.random() < 0.005 * ai.skill && p.onGround) {
          ai.wantDive = true;
        }
      }

      // Apply AI inputs
      if (p.stunTimer <= 0) {
        let diff = targetVx - p.vx;
        p.vx += Math.sign(diff) * accel * dt;
        p.facing = 1;

        if (ai.wantJump && p.onGround && ai.jumpCooldown <= 0) {
          p.vy = -380;
          p.onGround = false;
          ai.jumpCooldown = 0.3;
          ai.wantJump = false;
        }

        if (ai.wantDive && !p.diving && p.diveTimer <= 0) {
          p.diving = true;
          p.diveTimer = 0.4;
          p.vx += 120;
          ai.wantDive = false;
        }
      } else {
        p.vx *= (1 - 5 * dt);
      }
    }

    function distToSeg(pt, x1, y1, x2, y2) {
      let dx = x2 - x1, dy = y2 - y1;
      let len2 = dx * dx + dy * dy;
      if (len2 === 0) return Math.sqrt((pt.x - x1) ** 2 + (pt.y - y1) ** 2);
      let t = Math.max(0, Math.min(1, ((pt.x - x1) * dx + (pt.y - y1) * dy) / len2));
      let px = x1 + t * dx, py = y1 + t * dy;
      return Math.sqrt((pt.x - px) ** 2 + (pt.y - py) ** 2);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x, y: y,
          vx: (Math.random() - 0.5) * 200,
          vy: (Math.random() - 0.8) * 200,
          life: 0.5 + Math.random() * 0.5,
          color: color,
          r: 2 + Math.random() * 3
        });
      }
    }

    function updateObstacles(dt) {
      for (let obs of obstacles) {
        switch (obs.type) {
          case 'spinner':
            obs.angle += obs.speed * dt;
            break;
          case 'pendulum':
            obs.angle = Math.sin(raceTimer * obs.speed) * 1.2;
            break;
          case 'conveyor':
            obs.animOff += obs.dir * obs.speed * dt;
            break;
          case 'movingPlatform':
            obs.y = obs.baseY + Math.sin(raceTimer * obs.speed + obs.phase) * obs.ampY;
            break;
          case 'bounce':
            if (obs.compressed > 0) obs.compressed -= dt;
            break;
        }
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        let pt = particles[i];
        pt.x += pt.vx * dt;
        pt.y += pt.vy * dt;
        pt.vy += 300 * dt;
        pt.life -= dt;
        if (pt.life <= 0) particles.splice(i, 1);
      }
    }

    // ---- RENDERING ----

    function drawBackground() {
      // Sky gradient
      let grd = ctx.createLinearGradient(0, 0, 0, H);
      grd.addColorStop(0, '#1a1a2e');
      grd.addColorStop(1, '#16213e');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      // Distant mountains
      ctx.fillStyle = '#0f3460';
      for (let i = 0; i < 10; i++) {
        let mx = (i * 200 - cameraX * 0.1) % (W + 200) - 100;
        let mh = 60 + Math.sin(i * 1.7) * 30;
        ctx.beginPath();
        ctx.moveTo(mx - 80, H);
        ctx.lineTo(mx, H - mh);
        ctx.lineTo(mx + 80, H);
        ctx.fill();
      }

      // Stars
      ctx.fillStyle = '#ffffff33';
      for (let i = 0; i < 30; i++) {
        let sx = (i * 73 + 10) % W;
        let sy = (i * 47 + 5) % (H * 0.6);
        ctx.fillRect(sx, sy, 1.5, 1.5);
      }
    }

    function drawGround() {
      for (let plat of platforms) {
        if (plat.type !== 'ground') continue;
        let px = plat.x - cameraX;
        if (px + plat.w < -20 || px > W + 20) continue;
        ctx.fillStyle = '#2a2a4e';
        ctx.fillRect(px, plat.y, plat.w, plat.h);
        ctx.fillStyle = '#3a3a6e';
        ctx.fillRect(px, plat.y, plat.w, 4);
        // Edge lines
        ctx.strokeStyle = '#4a4a8e';
        ctx.lineWidth = 1;
        ctx.strokeRect(px, plat.y, plat.w, 4);
      }
    }

    function drawObstacles() {
      for (let obs of obstacles) {
        let ox = obs.x - cameraX;
        if (ox < -120 || ox > W + 120) continue;

        switch (obs.type) {
          case 'spinner': {
            let ex1x = ox + Math.cos(obs.angle) * obs.radius;
            let ex1y = obs.y + Math.sin(obs.angle) * obs.radius;
            let ex2x = ox - Math.cos(obs.angle) * obs.radius;
            let ex2y = obs.y - Math.sin(obs.angle) * obs.radius;
            // Bar
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = obs.barW;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(ex1x, ex1y);
            ctx.lineTo(ex2x, ex2y);
            ctx.stroke();
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Center
            ctx.fillStyle = '#aa2222';
            ctx.beginPath();
            ctx.arc(ox, obs.y, 6, 0, Math.PI * 2);
            ctx.fill();
            break;
          }
          case 'pendulum': {
            let bx = ox + Math.sin(obs.angle) * obs.length;
            let by = obs.anchorY + Math.cos(obs.angle) * obs.length;
            // Rod
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(ox, obs.anchorY);
            ctx.lineTo(bx, by);
            ctx.stroke();
            // Bob
            ctx.fillStyle = '#ff8844';
            ctx.shadowColor = '#ff8844';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(bx, by, obs.bobR, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Anchor
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(ox, obs.anchorY, 4, 0, Math.PI * 2);
            ctx.fill();
            break;
          }
          case 'conveyor': {
            ctx.fillStyle = '#555577';
            ctx.fillRect(ox, obs.y, obs.w, obs.h);
            // Arrows
            ctx.fillStyle = obs.dir > 0 ? '#88ff88' : '#ff8888';
            for (let i = 0; i < obs.w; i += 16) {
              let ax = ((i + obs.animOff) % obs.w + obs.w) % obs.w;
              ctx.fillText(obs.dir > 0 ? '>' : '<', ox + ax, obs.y + obs.h - 1);
            }
            // Border
            ctx.strokeStyle = '#7777aa';
            ctx.lineWidth = 1;
            ctx.strokeRect(ox, obs.y, obs.w, obs.h);
            break;
          }
          case 'slime': {
            ctx.fillStyle = '#44cc44';
            ctx.shadowColor = '#44cc44';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.ellipse(ox + obs.w / 2, obs.y + obs.h / 2, obs.w / 2, obs.h / 2 + 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Bubbles
            ctx.fillStyle = '#66ee6644';
            for (let i = 0; i < 3; i++) {
              let bx = ox + obs.w * 0.2 + i * obs.w * 0.3;
              let by = obs.y + Math.sin(raceTimer * 3 + i) * 2;
              ctx.beginPath();
              ctx.arc(bx, by, 2, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
          }
          case 'bounce': {
            let comp = obs.compressed > 0 ? 4 : 0;
            ctx.fillStyle = '#ffff44';
            ctx.shadowColor = '#ffff44';
            ctx.shadowBlur = 8;
            ctx.fillRect(ox, obs.y + comp, obs.w, obs.h - comp);
            ctx.shadowBlur = 0;
            // Spring coils
            ctx.strokeStyle = '#cccc22';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
              let sy = obs.y + comp + 2 + i * 3;
              ctx.beginPath();
              ctx.moveTo(ox + 4, sy);
              ctx.lineTo(ox + obs.w - 4, sy);
              ctx.stroke();
            }
            break;
          }
          case 'movingPlatform': {
            ctx.fillStyle = '#8866cc';
            ctx.shadowColor = '#8866cc';
            ctx.shadowBlur = 6;
            ctx.fillRect(ox, obs.y, obs.w, obs.h);
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#aa88ee';
            ctx.fillRect(ox, obs.y, obs.w, 3);
            break;
          }
          case 'wall': {
            ctx.fillStyle = '#cc6644';
            ctx.fillRect(ox, obs.y, obs.w, obs.h);
            // Brick pattern
            ctx.strokeStyle = '#994422';
            ctx.lineWidth = 1;
            for (let r = 0; r < obs.h; r += 10) {
              ctx.beginPath();
              ctx.moveTo(ox, obs.y + r);
              ctx.lineTo(ox + obs.w, obs.y + r);
              ctx.stroke();
            }
            break;
          }
        }
      }
    }

    function drawPlayer(p) {
      if (p.finished && finishOrder.indexOf(p.idx) >= 0) {
        // Show at finish line area
        let fx = courseLength - cameraX + 20 + finishOrder.indexOf(p.idx) * 25;
        if (fx < -30 || fx > W + 30) return;
        drawPlayerSprite(p, fx, GROUND_Y - PLAYER_H);
        return;
      }

      let px = p.x - cameraX;
      if (px < -40 || px > W + 40) return;
      drawPlayerSprite(p, px, p.y);
    }

    function drawPlayerSprite(p, px, py) {
      let alpha = p.stunTimer > 0 ? 0.5 + Math.sin(raceTimer * 20) * 0.3 : 1;
      ctx.globalAlpha = alpha;

      // Body (blob shape)
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 10;

      if (p.diving) {
        // Diving pose - horizontal
        ctx.beginPath();
        ctx.ellipse(px + p.w / 2, py + p.h * 0.6, p.w * 0.7, p.h * 0.35, 0.3 * p.facing, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Normal blob body
        ctx.beginPath();
        ctx.ellipse(px + p.w / 2, py + p.h * 0.4, p.w * 0.5, p.h * 0.45, 0, 0, Math.PI * 2);
        ctx.fill();

        // Legs
        let legOff = p.onGround ? Math.sin(p.runAnim) * 4 : 2;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.ellipse(px + p.w * 0.3, py + p.h * 0.8 + legOff, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(px + p.w * 0.7, py + p.h * 0.8 - legOff, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;

      // Eyes
      let eyeOffX = p.facing * 3;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(px + p.w / 2 - 3 + eyeOffX, py + p.h * 0.3, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(px + p.w / 2 + 3 + eyeOffX, py + p.h * 0.3, 3, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(px + p.w / 2 - 2 + eyeOffX, py + p.h * 0.3, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(px + p.w / 2 + 4 + eyeOffX, py + p.h * 0.3, 1.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;

      // Name tag (small)
      if (p.slowTimer > 0) {
        ctx.fillStyle = '#44cc44';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('SLOW', px + p.w / 2, py - 6);
      }
    }

    function drawFinishLine() {
      let fx = courseLength - cameraX;
      if (fx < -20 || fx > W + 20) return;

      // Checkered flag pole
      ctx.fillStyle = '#ccc';
      ctx.fillRect(fx, GROUND_Y - 100, 4, 100);

      // Flag
      let flagW = 30, flagH = 20;
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 6; c++) {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#fff' : '#111';
          ctx.fillRect(fx + 4 + c * 5, GROUND_Y - 100 + r * 5, 5, 5);
        }
      }

      // Finish banner
      ctx.fillStyle = '#ff44aa44';
      ctx.fillRect(fx - 2, GROUND_Y - 70, 8, 70);

      ctx.fillStyle = '#ff44aa';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.translate(fx + 2, GROUND_Y - 35);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('FINISH', 0, 0);
      ctx.restore();
    }

    function drawHUD() {
      // Position indicators (minimap bar)
      ctx.fillStyle = '#ffffff15';
      ctx.fillRect(50, 10, W - 100, 12);
      ctx.strokeStyle = '#ffffff33';
      ctx.lineWidth = 1;
      ctx.strokeRect(50, 10, W - 100, 12);

      for (let p of players) {
        let progress = Math.min(p.x / courseLength, 1);
        let mx = 50 + progress * (W - 100);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(mx, 16, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      // Finish marker on minimap
      ctx.fillStyle = '#fff';
      ctx.fillRect(W - 50, 10, 2, 12);

      // Position text
      let humanPlayer = players[0];
      let position = 1;
      for (let p of players) {
        if (p !== humanPlayer && p.x > humanPlayer.x) position++;
      }
      let suffix = ['st','nd','rd','th'][Math.min(position - 1, 3)];

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(position + suffix + ' Place', 10, 40);

      // Player legend
      ctx.font = '10px Courier New';
      for (let i = 0; i < players.length; i++) {
        let p = players[i];
        ctx.fillStyle = p.color;
        let status = p.finished ? 'âœ“' : Math.floor(p.x / courseLength * 100) + '%';
        ctx.fillText(p.name + ' ' + status, W - 140, 36 + i * 14);
      }
    }

    function drawParticles() {
      for (let pt of particles) {
        let px = pt.x - cameraX;
        ctx.globalAlpha = pt.life;
        ctx.fillStyle = pt.color;
        ctx.beginPath();
        ctx.arc(px, pt.y, pt.r * pt.life, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawCountdown() {
      if (gameState !== 'countdown') return;
      ctx.fillStyle = '#ff44aa';
      ctx.font = 'bold 60px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff44aa';
      ctx.shadowBlur = 20;
      let text = countdown > 0 ? Math.ceil(countdown).toString() : 'GO!';
      ctx.fillText(text, W / 2, H / 2);
      ctx.shadowBlur = 0;
    }

    function drawRoundEnd() {
      ctx.fillStyle = 'rgba(26, 26, 46, 0.8)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#ff44aa';
      ctx.font = 'bold 28px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff44aa';
      ctx.shadowBlur = 15;
      ctx.fillText('Round ' + round + ' Complete!', W / 2, 80);
      ctx.shadowBlur = 0;

      // Show finishing order
      ctx.font = '16px Courier New';
      let pts = [10, 6, 3, 1];
      for (let i = 0; i < finishOrder.length; i++) {
        let p = players[finishOrder[i]];
        ctx.fillStyle = p.color;
        let posText = (i + 1) + '. ' + p.name + ' - ' + p.finishTime.toFixed(1) + 's (+' + pts[i] + 'pts)';
        ctx.fillText(posText, W / 2, 130 + i * 30);
      }

      // Players who didn't finish
      for (let p of players) {
        if (!p.finished) {
          ctx.fillStyle = '#666';
          ctx.fillText('DNF - ' + p.name + ' (+0pts)', W / 2, 130 + finishOrder.length * 30);
        }
      }

      ctx.fillStyle = '#aaa';
      ctx.font = '14px Courier New';
      if (round < TOTAL_ROUNDS) {
        ctx.fillText('Click for Round ' + (round + 1), W / 2, 320);
      } else {
        ctx.fillText('Click to see final results', W / 2, 320);
      }
    }

    // ---- GAME LOOP ----

    let playerScores = [0, 0, 0, 0];

    function update(dt) {
      if (gameState === 'countdown') {
        countdown -= dt;
        countdownTimer += dt;
        if (countdown <= -0.5) {
          gameState = 'racing';
        }
        return;
      }

      if (gameState !== 'racing') return;

      raceTimer += dt;
      updateObstacles(dt);

      for (let p of players) {
        updatePlayer(p, dt);
      }

      updateParticles(dt);

      // Camera follows human player
      let targetCam = players[0].x - 120;
      cameraX += (targetCam - cameraX) * 4 * dt;
      cameraX = Math.max(0, cameraX);

      // Auto-finish remaining players after timeout or all humans done
      if (raceTimer > 60) {
        for (let p of players) {
          if (!p.finished) {
            p.finished = true;
            p.finishTime = raceTimer;
            finishOrder.push(p.idx);
          }
        }
      }

      // Check if all players finished
      if (players.every(p => p.finished)) {
        gameState = 'roundEnd';
        // Award points
        let pts = [10, 6, 3, 1];
        for (let i = 0; i < finishOrder.length; i++) {
          playerScores[finishOrder[i]] += pts[i] || 0;
        }
        score = playerScores[0];
        scoreEl.textContent = score;
      }

      // Update HUD
      timerEl.textContent = raceTimer.toFixed(1);
      roundEl.textContent = round;
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      drawBackground();
      drawGround();
      drawObstacles();
      drawFinishLine();

      // Draw players sorted by Y for depth
      let sorted = [...players].sort((a, b) => a.y - b.y);
      for (let p of sorted) drawPlayer(p);

      drawParticles();
      drawHUD();

      if (gameState === 'countdown') drawCountdown();
      if (gameState === 'roundEnd') drawRoundEnd();
    }

    function gameLoop(timestamp) {
      let dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      if (gameState !== 'menu' && gameState !== 'gameover') {
        update(dt);
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // ---- CLICK HANDLERS ----

    canvas.addEventListener('click', () => {
      if (gameState === 'menu') {
        overlay.style.display = 'none';
        startGame();
      } else if (gameState === 'roundEnd') {
        if (round < TOTAL_ROUNDS) {
          round++;
          courseLength = 2500 + round * 500;
          startRace();
        } else {
          gameState = 'gameover';
          showGameOver();
        }
      } else if (gameState === 'gameover') {
        overlay.style.display = 'none';
        playerScores = [0, 0, 0, 0];
        startGame();
      }
    });

    overlay.addEventListener('click', () => {
      if (gameState === 'menu' || gameState === 'gameover') {
        overlay.style.display = 'none';
        if (gameState === 'gameover') {
          playerScores = [0, 0, 0, 0];
        }
        startGame();
      }
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    function showGameOver() {
      // Determine winner
      let maxScore = Math.max(...playerScores);
      let winner = playerScores.indexOf(maxScore);

      overlayTitle.textContent = winner === 0 ? 'YOU WIN!' : NAMES[winner] + ' WINS!';
      overlayTitle.style.color = COLORS[winner];

      let results = '';
      let indices = [0, 1, 2, 3].sort((a, b) => playerScores[b] - playerScores[a]);
      for (let i = 0; i < indices.length; i++) {
        let idx = indices[i];
        results += (i + 1) + '. ' + NAMES[idx] + ': ' + playerScores[idx] + ' pts\n';
      }
      overlayText.textContent = results;
      overlayText.style.whiteSpace = 'pre';
      overlaySubtext.textContent = 'Click to play again';
      overlay.style.display = 'flex';

      score = playerScores[0];
      scoreEl.textContent = score;
    }

    // ---- Draw initial menu state ----
    function drawMenu() {
      drawBackground();
      // Draw some decorative obstacles
      ctx.fillStyle = '#ff44aa33';
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.arc(100 + i * 120, 300 + Math.sin(i) * 30, 15, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ---- INIT ----
    function init() {
      lastTime = performance.now();
      drawMenu();
      requestAnimationFrame(gameLoop);
    }

    // Expose game data
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState, score, round,
        raceTimer,
        playerScores: [...playerScores],
        finishOrder: [...finishOrder]
      };
    }
    setInterval(updateGameData, 500);

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

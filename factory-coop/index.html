<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Factory Co-op</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 68, 0.5); }
    h1 { color: #f84; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f84; }
    canvas {
      border: 2px solid #f84;
      box-shadow: 0 0 20px rgba(255, 136, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>FACTORY CO-OP</h1>
  </div>
  <div class="score-bar">
    <div>Orders: <span id="score">0</span></div>
    <div>Time: <span id="timer">3:00</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">FACTORY CO-OP</h2>
      <p id="overlayText">WASD move | SPACE grab/drop | E interact<br><br>Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting'; // waiting, playing, over
    let score = 0;

    // --- Constants ---
    const TILE = 40;
    const COLS = W / TILE; // 15
    const ROWS = H / TILE; // 10
    const ROUND_TIME = 180; // 3 minutes
    const PLAYER_SPEED = 2.5;

    // Colors
    const C_FLOOR = '#2a2a3e';
    const C_WALL = '#3a3a5e';
    const C_CONVEYOR = '#333350';
    const C_MACHINE_PAINT = '#c44';
    const C_MACHINE_CUT = '#4c4';
    const C_MACHINE_ASSEMBLE = '#44c';
    const C_BIN = '#555';
    const C_OUTPUT = '#f84';
    const C_PLAYER = '#0f0';
    const C_AI = '#ff0';

    // Materials / Products
    const MATERIALS = {
      raw_red: { color: '#e44', label: 'R' },
      raw_blue: { color: '#48f', label: 'B' },
      raw_green: { color: '#4d4', label: 'G' },
      raw_yellow: { color: '#ee4', label: 'Y' },
      painted_red: { color: '#f66', label: 'PR' },
      painted_blue: { color: '#6af', label: 'PB' },
      painted_green: { color: '#6f6', label: 'PG' },
      cut_red: { color: '#f66', label: 'CR' },
      cut_blue: { color: '#6af', label: 'CB' },
      cut_green: { color: '#6f6', label: 'CG' },
      red_widget: { color: '#f44', label: 'RW' },
      blue_gadget: { color: '#48f', label: 'BG' },
      green_gizmo: { color: '#4d4', label: 'GG' },
      yellow_device: { color: '#ee4', label: 'YD' },
    };

    // Recipes: product -> steps (each step: machine type + input -> output)
    const RECIPES = {
      red_widget: {
        name: 'Red Widget',
        color: '#f44',
        steps: [
          { machine: 'paint', input: 'raw_red', output: 'painted_red' },
          { machine: 'cut', input: 'painted_red', output: 'cut_red' },
          { machine: 'assemble', input: 'cut_red', output: 'red_widget' },
        ]
      },
      blue_gadget: {
        name: 'Blue Gadget',
        color: '#48f',
        steps: [
          { machine: 'paint', input: 'raw_blue', output: 'painted_blue' },
          { machine: 'cut', input: 'painted_blue', output: 'cut_blue' },
          { machine: 'assemble', input: 'cut_blue', output: 'blue_gadget' },
        ]
      },
      green_gizmo: {
        name: 'Green Gizmo',
        color: '#4d4',
        steps: [
          { machine: 'paint', input: 'raw_green', output: 'painted_green' },
          { machine: 'cut', input: 'painted_green', output: 'cut_green' },
          { machine: 'assemble', input: 'cut_green', output: 'green_gizmo' },
        ]
      },
      yellow_device: {
        name: 'Yellow Device',
        color: '#ee4',
        steps: [
          { machine: 'cut', input: 'raw_yellow', output: 'cut_yellow' },
          { machine: 'paint', input: 'cut_yellow', output: 'painted_yellow' },
          { machine: 'assemble', input: 'painted_yellow', output: 'yellow_device' },
        ]
      },
    };
    // Add missing intermediate materials
    MATERIALS.cut_yellow = { color: '#ee4', label: 'CY' };
    MATERIALS.painted_yellow = { color: '#fd4', label: 'PY' };

    const PRODUCT_KEYS = Object.keys(RECIPES);

    // --- Factory Layout ---
    // 0=floor, 1=wall, 2=bin, 3=paint, 4=cut, 5=assemble, 6=output, 7=conveyor
    const layout = [];
    const machines = [];
    const bins = [];
    let outputZone = null;

    function buildFactory() {
      // Clear
      for (let r = 0; r < ROWS; r++) {
        layout[r] = [];
        for (let c = 0; c < COLS; c++) {
          layout[r][c] = 0;
        }
      }
      // Walls: top and bottom
      for (let c = 0; c < COLS; c++) {
        layout[0][c] = 1;
        layout[ROWS-1][c] = 1;
      }
      // Left and right walls
      for (let r = 0; r < ROWS; r++) {
        layout[r][0] = 1;
        layout[r][COLS-1] = 1;
      }

      machines.length = 0;
      bins.length = 0;

      // Material bins on left side (col 1, rows 2-5)
      const binMats = ['raw_red', 'raw_blue', 'raw_green', 'raw_yellow'];
      for (let i = 0; i < 4; i++) {
        layout[2 + i][1] = 2;
        bins.push({ col: 1, row: 2 + i, material: binMats[i] });
      }

      // Paint machines (col 4, rows 2-3) - top area (player side)
      layout[2][4] = 3;
      machines.push({ col: 4, row: 2, type: 'paint', processing: null, timer: 0, output: null });
      // Paint machine bottom area (AI side)
      layout[7][4] = 3;
      machines.push({ col: 4, row: 7, type: 'paint', processing: null, timer: 0, output: null });

      // Cut machines (col 7, rows 2-3)
      layout[2][7] = 4;
      machines.push({ col: 7, row: 2, type: 'cut', processing: null, timer: 0, output: null });
      layout[7][7] = 4;
      machines.push({ col: 7, row: 7, type: 'cut', processing: null, timer: 0, output: null });

      // Assemble machines (col 10, rows 2-3)
      layout[2][10] = 5;
      machines.push({ col: 10, row: 2, type: 'assemble', processing: null, timer: 0, output: null });
      layout[7][10] = 5;
      machines.push({ col: 10, row: 7, type: 'assemble', processing: null, timer: 0, output: null });

      // Output zone (col 13, rows 4-5)
      layout[4][13] = 6;
      layout[5][13] = 6;
      outputZone = { col: 13, rows: [4, 5] };

      // Conveyor belt decoration (horizontal strips)
      for (let c = 2; c <= 12; c++) {
        if (layout[4][c] === 0) layout[4][c] = 7;
        if (layout[5][c] === 0) layout[5][c] = 7;
      }
    }

    // --- Game State ---
    let timeLeft = ROUND_TIME;
    let orders = [];
    let orderIdCounter = 0;
    let nextOrderTime = 0;
    let difficulty = 1;
    let conveyorOffset = 0;

    // Player
    const player = {
      x: 2 * TILE + TILE/2,
      y: 3 * TILE + TILE/2,
      holding: null,
      radius: 14,
      color: C_PLAYER,
      label: 'P1',
      interactCooldown: 0,
    };

    // AI ally
    const ai = {
      x: 2 * TILE + TILE/2,
      y: 6 * TILE + TILE/2,
      holding: null,
      radius: 14,
      color: C_AI,
      label: 'AI',
      targetX: 0,
      targetY: 0,
      task: null, // { type, order, step, target }
      taskCooldown: 0,
      interactCooldown: 0,
      state: 'idle', // idle, moving, interacting
    };

    // Input
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (['space', 'e'].includes(e.key.toLowerCase()) || e.key === ' ') e.preventDefault();
    });
    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    // --- Orders ---
    function spawnOrder() {
      const product = PRODUCT_KEYS[Math.floor(Math.random() * Math.min(2 + difficulty, PRODUCT_KEYS.length))];
      const recipe = RECIPES[product];
      const timeLimit = 30 - Math.min(difficulty * 2, 15);
      orders.push({
        id: orderIdCounter++,
        product,
        name: recipe.name,
        color: recipe.color,
        timeLeft: timeLimit,
        maxTime: timeLimit,
        completed: false,
        claimed: null, // null, 'player', 'ai'
      });
    }

    // --- Collision ---
    function isWalkable(px, py, radius) {
      // Check corners of bounding box
      const offsets = [[-radius, -radius], [radius, -radius], [-radius, radius], [radius, radius]];
      for (const [ox, oy] of offsets) {
        const c = Math.floor((px + ox) / TILE);
        const r = Math.floor((py + oy) / TILE);
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
        const t = layout[r][c];
        if (t === 1 || t === 2 || t === 3 || t === 4 || t === 5) return false;
      }
      return true;
    }

    function nearestMachine(px, py) {
      let best = null, bestDist = Infinity;
      for (const m of machines) {
        const mx = m.col * TILE + TILE/2;
        const my = m.row * TILE + TILE/2;
        const d = Math.hypot(px - mx, py - my);
        if (d < bestDist) { bestDist = d; best = m; }
      }
      return bestDist < TILE * 1.5 ? best : null;
    }

    function nearestBin(px, py) {
      let best = null, bestDist = Infinity;
      for (const b of bins) {
        const bx = b.col * TILE + TILE/2;
        const by = b.row * TILE + TILE/2;
        const d = Math.hypot(px - bx, py - by);
        if (d < bestDist) { bestDist = d; best = b; }
      }
      return bestDist < TILE * 1.5 ? best : null;
    }

    function nearOutput(px, py) {
      if (!outputZone) return false;
      const ox = outputZone.col * TILE + TILE/2;
      for (const r of outputZone.rows) {
        const oy = r * TILE + TILE/2;
        if (Math.hypot(px - ox, py - oy) < TILE * 1.5) return true;
      }
      return false;
    }

    // --- Interaction ---
    function interact(entity) {
      if (entity.interactCooldown > 0) return;
      entity.interactCooldown = 15;

      // Near a bin? Grab material
      const bin = nearestBin(entity.x, entity.y);
      if (bin && !entity.holding) {
        entity.holding = bin.material;
        return;
      }

      // Near a machine?
      const machine = nearestMachine(entity.x, entity.y);
      if (machine) {
        // If machine has output, grab it
        if (machine.output && !entity.holding) {
          entity.holding = machine.output;
          machine.output = null;
          return;
        }
        // If holding something, try to put it in
        if (entity.holding && !machine.processing && !machine.output) {
          // Check if any recipe uses this machine+input combo
          for (const pk of PRODUCT_KEYS) {
            for (const step of RECIPES[pk].steps) {
              if (step.machine === machine.type && step.input === entity.holding) {
                machine.processing = { input: entity.holding, output: step.output };
                machine.timer = 90; // 1.5 seconds at 60fps
                entity.holding = null;
                return;
              }
            }
          }
        }
        return;
      }

      // Near output? Deliver
      if (nearOutput(entity.x, entity.y) && entity.holding) {
        // Check if holding is a finished product
        for (let i = 0; i < orders.length; i++) {
          const order = orders[i];
          if (!order.completed && order.product === entity.holding) {
            order.completed = true;
            const bonus = Math.ceil(order.timeLeft / order.maxTime * 5);
            score += 1 + bonus;
            entity.holding = null;
            scoreEl.textContent = score;
            // Particle burst
            for (let p = 0; p < 8; p++) {
              particles.push({
                x: entity.x, y: entity.y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 30,
                color: order.color,
              });
            }
            return;
          }
        }
      }
    }

    function grabDrop(entity) {
      if (entity.interactCooldown > 0) return;
      entity.interactCooldown = 15;

      // If holding, drop on floor (or into machine/output via interact)
      // Near bin: grab
      const bin = nearestBin(entity.x, entity.y);
      if (bin && !entity.holding) {
        entity.holding = bin.material;
        return;
      }

      // Near machine: grab output or deposit
      const machine = nearestMachine(entity.x, entity.y);
      if (machine) {
        if (machine.output && !entity.holding) {
          entity.holding = machine.output;
          machine.output = null;
          return;
        }
        if (entity.holding && !machine.processing && !machine.output) {
          // Check recipe match
          for (const pk of PRODUCT_KEYS) {
            for (const step of RECIPES[pk].steps) {
              if (step.machine === machine.type && step.input === entity.holding) {
                machine.processing = { input: entity.holding, output: step.output };
                machine.timer = 90;
                entity.holding = null;
                return;
              }
            }
          }
        }
        return;
      }

      // Near output
      if (nearOutput(entity.x, entity.y) && entity.holding) {
        interact(entity);
        return;
      }

      // Drop on ground
      if (entity.holding) {
        entity.holding = null;
      }
    }

    // --- Particles ---
    let particles = [];

    // --- AI Logic ---
    function findRecipeStep(product, currentMaterial) {
      const recipe = RECIPES[product];
      if (!recipe) return null;
      for (let i = 0; i < recipe.steps.length; i++) {
        if (recipe.steps[i].input === currentMaterial) {
          return { stepIndex: i, step: recipe.steps[i] };
        }
      }
      return null;
    }

    function getMachineForType(type, preferBottom) {
      // AI prefers bottom machines (rows 7), player gets top (rows 2)
      let best = null;
      for (const m of machines) {
        if (m.type === type) {
          if (preferBottom && m.row >= 5) return m;
          if (!preferBottom && m.row < 5) return m;
          if (!best) best = m;
        }
      }
      return best;
    }

    function aiDecideTask() {
      // Find unclaimed/AI-claimed incomplete orders
      let targetOrder = null;
      for (const order of orders) {
        if (!order.completed && (order.claimed === 'ai' || order.claimed === null)) {
          if (!targetOrder || (order.claimed === 'ai')) {
            targetOrder = order;
            if (order.claimed === 'ai') break;
          }
        }
      }

      if (!targetOrder) return null;
      targetOrder.claimed = 'ai';

      const recipe = RECIPES[targetOrder.product];
      if (!recipe) return null;

      // Determine what step we're on based on what AI is holding or what needs doing
      if (!ai.holding) {
        // Need to grab starting material
        return {
          type: 'grab',
          order: targetOrder,
          material: recipe.steps[0].input,
        };
      }

      // Check if holding a finished product
      if (ai.holding === targetOrder.product) {
        return {
          type: 'deliver',
          order: targetOrder,
        };
      }

      // Find which step this material goes to
      const stepInfo = findRecipeStep(targetOrder.product, ai.holding);
      if (stepInfo) {
        return {
          type: 'process',
          order: targetOrder,
          step: stepInfo.step,
        };
      }

      // Holding something useless - drop it
      return { type: 'drop' };
    }

    function aiUpdate() {
      if (ai.interactCooldown > 0) ai.interactCooldown--;
      if (ai.taskCooldown > 0) { ai.taskCooldown--; return; }

      // Decide what to do
      if (!ai.task || ai.task.type === 'idle') {
        ai.task = aiDecideTask();
        if (!ai.task) {
          ai.task = { type: 'idle' };
          ai.taskCooldown = 30;
          return;
        }
      }

      const task = ai.task;

      if (task.type === 'grab') {
        // Move to the appropriate bin
        const bin = bins.find(b => b.material === task.material);
        if (!bin) { ai.task = null; return; }
        const tx = bin.col * TILE + TILE/2 + TILE;
        const ty = bin.row * TILE + TILE/2;
        if (aiMoveTo(tx, ty)) {
          if (nearestBin(ai.x, ai.y)) {
            grabDrop(ai);
            if (ai.holding) {
              ai.task = null; // Re-evaluate
              ai.taskCooldown = 10;
            }
          }
        }
        return;
      }

      if (task.type === 'process') {
        const machine = getMachineForType(task.step.machine, true);
        if (!machine) { ai.task = null; return; }

        // If machine has output ready, we need to grab it first if it matches what we need
        // Or wait if it's processing
        if (machine.processing) {
          // Wait near the machine
          const tx = machine.col * TILE + TILE/2;
          const ty = machine.row * TILE + TILE/2 + TILE;
          aiMoveTo(tx, ty);
          return;
        }

        if (machine.output) {
          // Grab the output if we're not holding anything useful, or if it's what we want
          if (!ai.holding) {
            const tx = machine.col * TILE + TILE/2;
            const ty = machine.row * TILE + TILE/2 + TILE;
            if (aiMoveTo(tx, ty)) {
              if (nearestMachine(ai.x, ai.y) === machine) {
                grabDrop(ai);
                ai.task = null;
                ai.taskCooldown = 5;
              }
            }
            return;
          }
          // Machine is full, wait
          ai.taskCooldown = 20;
          return;
        }

        // Machine is free - move to it and deposit
        const tx = machine.col * TILE + TILE/2;
        const ty = machine.row * TILE + TILE/2 + TILE;
        if (aiMoveTo(tx, ty)) {
          if (nearestMachine(ai.x, ai.y) === machine) {
            grabDrop(ai);
            if (!ai.holding) {
              // Deposited - now wait for output
              ai.task = { type: 'wait_machine', machine, order: task.order };
            }
          }
        }
        return;
      }

      if (task.type === 'wait_machine') {
        const machine = task.machine;
        // Stay near machine
        const tx = machine.col * TILE + TILE/2;
        const ty = machine.row * TILE + TILE/2 + TILE;
        aiMoveTo(tx, ty);

        if (machine.output && !ai.holding) {
          if (nearestMachine(ai.x, ai.y) === machine) {
            grabDrop(ai);
            ai.task = null;
            ai.taskCooldown = 5;
          }
        }
        return;
      }

      if (task.type === 'deliver') {
        const tx = outputZone.col * TILE + TILE/2 - TILE;
        const ty = outputZone.rows[1] * TILE + TILE/2;
        if (aiMoveTo(tx, ty)) {
          if (nearOutput(ai.x, ai.y)) {
            interact(ai);
            ai.task = null;
            ai.taskCooldown = 15;
          }
        }
        return;
      }

      if (task.type === 'drop') {
        ai.holding = null;
        ai.task = null;
        ai.taskCooldown = 10;
        return;
      }

      // Fallback
      ai.task = null;
      ai.taskCooldown = 30;
    }

    function aiMoveTo(tx, ty) {
      const dx = tx - ai.x;
      const dy = ty - ai.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 3) return true;
      const speed = PLAYER_SPEED;
      const nx = ai.x + (dx / dist) * speed;
      const ny = ai.y + (dy / dist) * speed;
      // Try to move, avoid player
      const playerDist = Math.hypot(nx - player.x, ny - player.y);
      if (playerDist < 30) {
        // Dodge around player
        const perpX = -dy / dist;
        const perpY = dx / dist;
        const dodgeX = ai.x + perpX * speed;
        const dodgeY = ai.y + perpY * speed;
        if (isWalkable(dodgeX, dodgeY, ai.radius)) {
          ai.x = dodgeX;
          ai.y = dodgeY;
        }
        return false;
      }
      if (isWalkable(nx, ai.y, ai.radius)) ai.x = nx;
      if (isWalkable(ai.x, ny, ai.radius)) ai.y = ny;
      return false;
    }

    // --- Update ---
    let lastTime = 0;
    let frameCount = 0;

    function update() {
      frameCount++;
      if (player.interactCooldown > 0) player.interactCooldown--;

      // Player movement
      let dx = 0, dy = 0;
      if (keys['w'] || keys['arrowup']) dy = -PLAYER_SPEED;
      if (keys['s'] || keys['arrowdown']) dy = PLAYER_SPEED;
      if (keys['a'] || keys['arrowleft']) dx = -PLAYER_SPEED;
      if (keys['d'] || keys['arrowright']) dx = PLAYER_SPEED;
      if (dx && dy) { dx *= 0.707; dy *= 0.707; }

      const newX = player.x + dx;
      const newY = player.y + dy;
      if (isWalkable(newX, player.y, player.radius)) player.x = newX;
      if (isWalkable(player.x, newY, player.radius)) player.y = newY;

      // Player interactions
      if (keys[' ']) {
        keys[' '] = false;
        grabDrop(player);
      }
      if (keys['e']) {
        keys['e'] = false;
        interact(player);
      }

      // Update machines
      for (const m of machines) {
        if (m.processing) {
          m.timer--;
          if (m.timer <= 0) {
            m.output = m.processing.output;
            m.processing = null;
          }
        }
      }

      // AI update
      aiUpdate();

      // Timer
      if (frameCount % 60 === 0) {
        timeLeft--;
        if (timeLeft <= 0) {
          gameState = 'over';
          overlayTitle.textContent = 'SHIFT OVER!';
          overlayText.innerHTML = 'Orders completed: ' + score + '<br><br>Click to play again';
          overlay.style.display = 'flex';
          overlay.style.pointerEvents = 'auto';
          return;
        }
        const min = Math.floor(timeLeft / 60);
        const sec = timeLeft % 60;
        timerEl.textContent = min + ':' + (sec < 10 ? '0' : '') + sec;
      }

      // Spawn orders
      if (frameCount % 60 === 0) {
        nextOrderTime--;
        if (nextOrderTime <= 0) {
          // Remove expired/completed orders
          orders = orders.filter(o => !o.completed && o.timeLeft > 0);
          const maxOrders = Math.min(2 + Math.floor(difficulty / 2), 5);
          if (orders.length < maxOrders) {
            spawnOrder();
          }
          nextOrderTime = Math.max(4, 10 - difficulty);
        }

        // Update order timers
        for (const order of orders) {
          if (!order.completed) {
            order.timeLeft--;
            if (order.timeLeft <= 0) {
              order.completed = true; // expired
            }
          }
        }

        // Increase difficulty
        if (frameCount % 600 === 0) {
          difficulty++;
        }
      }

      // Conveyor animation
      conveyorOffset = (conveyorOffset + 0.3) % TILE;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- Render ---
    function render() {
      ctx.fillStyle = C_FLOOR;
      ctx.fillRect(0, 0, W, H);

      // Draw tiles
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = c * TILE;
          const y = r * TILE;
          const t = layout[r][c];

          if (t === 1) {
            ctx.fillStyle = C_WALL;
            ctx.fillRect(x, y, TILE, TILE);
            ctx.strokeStyle = '#4a4a6e';
            ctx.strokeRect(x + 1, y + 1, TILE - 2, TILE - 2);
          } else if (t === 7) {
            // Conveyor belt
            ctx.fillStyle = C_CONVEYOR;
            ctx.fillRect(x, y, TILE, TILE);
            ctx.strokeStyle = '#444468';
            // Animated chevrons
            ctx.beginPath();
            const offset = conveyorOffset;
            for (let cx = -TILE; cx < TILE * 2; cx += 20) {
              const bx = x + ((cx + offset) % TILE);
              if (bx >= x && bx <= x + TILE) {
                ctx.moveTo(bx, y + 10);
                ctx.lineTo(bx + 6, y + TILE/2);
                ctx.lineTo(bx, y + TILE - 10);
              }
            }
            ctx.strokeStyle = '#555578';
            ctx.stroke();
          } else if (t === 6) {
            // Output zone
            ctx.fillStyle = '#332211';
            ctx.fillRect(x, y, TILE, TILE);
            ctx.strokeStyle = C_OUTPUT;
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 2, y + 2, TILE - 4, TILE - 4);
            ctx.lineWidth = 1;
            ctx.fillStyle = C_OUTPUT;
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('OUT', x + TILE/2, y + TILE/2 + 4);
          }
        }
      }

      // Draw bins
      for (const bin of bins) {
        const x = bin.col * TILE;
        const y = bin.row * TILE;
        ctx.fillStyle = C_BIN;
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
        const mat = MATERIALS[bin.material];
        ctx.fillStyle = mat.color;
        ctx.fillRect(x + 8, y + 8, TILE - 16, TILE - 16);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(mat.label, x + TILE/2, y + TILE/2 + 4);
      }

      // Draw machines
      for (const m of machines) {
        const x = m.col * TILE;
        const y = m.row * TILE;
        let color = m.type === 'paint' ? C_MACHINE_PAINT :
                    m.type === 'cut' ? C_MACHINE_CUT : C_MACHINE_ASSEMBLE;
        ctx.fillStyle = color;
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);

        // Machine label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        const labels = { paint: 'PAINT', cut: 'CUT', assemble: 'ASM' };
        ctx.fillText(labels[m.type], x + TILE/2, y + 14);

        // Processing indicator
        if (m.processing) {
          ctx.fillStyle = '#fff';
          const progress = 1 - (m.timer / 90);
          ctx.fillRect(x + 5, y + TILE - 10, (TILE - 10) * progress, 5);
          ctx.strokeStyle = '#aaa';
          ctx.strokeRect(x + 5, y + TILE - 10, TILE - 10, 5);
          // Spinning gear effect
          const angle = frameCount * 0.1;
          ctx.save();
          ctx.translate(x + TILE/2, y + TILE/2 + 3);
          ctx.rotate(angle);
          ctx.strokeStyle = '#fff8';
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const a = (Math.PI * 2 / 6) * i;
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(a) * 8, Math.sin(a) * 8);
          }
          ctx.stroke();
          ctx.restore();
        }

        // Output indicator
        if (m.output) {
          const mat = MATERIALS[m.output];
          if (mat) {
            ctx.fillStyle = mat.color;
            ctx.beginPath();
            ctx.arc(x + TILE/2, y + TILE - 6, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '7px Courier New';
            ctx.fillText(mat.label, x + TILE/2, y + TILE - 4);
          }
          // Glow pulse
          ctx.strokeStyle = '#fff';
          ctx.globalAlpha = 0.3 + 0.3 * Math.sin(frameCount * 0.1);
          ctx.strokeRect(x, y, TILE, TILE);
          ctx.globalAlpha = 1;
        }
      }

      // Draw entities
      function drawEntity(e) {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(e.x + 2, e.y + 4, e.radius, e.radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fill();

        // Glow
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;

        // Label
        ctx.fillStyle = '#000';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(e.label, e.x, e.y + 4);

        // Held item
        if (e.holding) {
          const mat = MATERIALS[e.holding];
          if (mat) {
            ctx.fillStyle = mat.color;
            ctx.beginPath();
            ctx.arc(e.x + 12, e.y - 12, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.lineWidth = 1;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 7px Courier New';
            ctx.fillText(mat.label, e.x + 12, e.y - 10);
          }
        }
      }

      drawEntity(player);
      drawEntity(ai);

      // Draw order queue on left
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, 130, Math.min(orders.filter(o => !o.completed).length * 36 + 24, H));
      ctx.fillStyle = '#f84';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('ORDERS', 8, 16);

      let oy = 30;
      for (const order of orders) {
        if (order.completed) continue;
        if (oy > H - 20) break;

        // Order background
        ctx.fillStyle = order.timeLeft < 5 ? 'rgba(255,50,50,0.3)' : 'rgba(50,50,80,0.5)';
        ctx.fillRect(4, oy - 10, 122, 30);

        // Product name
        ctx.fillStyle = order.color;
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'left';
        ctx.fillText(order.name, 8, oy + 2);

        // Timer bar
        const timerFrac = order.timeLeft / order.maxTime;
        const barColor = timerFrac > 0.5 ? '#4d4' : timerFrac > 0.25 ? '#ee4' : '#e44';
        ctx.fillStyle = '#333';
        ctx.fillRect(8, oy + 8, 100, 6);
        ctx.fillStyle = barColor;
        ctx.fillRect(8, oy + 8, 100 * timerFrac, 6);

        // Claimed indicator
        if (order.claimed === 'ai') {
          ctx.fillStyle = C_AI;
          ctx.font = '8px Courier New';
          ctx.textAlign = 'right';
          ctx.fillText('AI', 122, oy + 2);
        }

        oy += 36;
      }

      // Draw particles
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;

      // Legend at bottom right
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(W - 160, H - 50, 160, 50);
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.fillStyle = C_MACHINE_PAINT; ctx.fillText('PAINT', W - 150, H - 35);
      ctx.fillStyle = C_MACHINE_CUT; ctx.fillText('CUT', W - 100, H - 35);
      ctx.fillStyle = C_MACHINE_ASSEMBLE; ctx.fillText('ASM', W - 55, H - 35);
      ctx.fillStyle = '#888';
      ctx.fillText('WASD E SPACE', W - 150, H - 15);
    }

    // --- Game Loop ---
    function gameLoop() {
      if (gameState === 'playing') {
        update();
      }
      render();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      gameState = 'playing';
      score = 0;
      scoreEl.textContent = '0';
      timeLeft = ROUND_TIME;
      timerEl.textContent = '3:00';
      frameCount = 0;
      orders = [];
      orderIdCounter = 0;
      nextOrderTime = 2;
      difficulty = 1;
      particles = [];

      player.x = 2 * TILE + TILE/2;
      player.y = 3 * TILE + TILE/2;
      player.holding = null;
      player.interactCooldown = 0;

      ai.x = 2 * TILE + TILE/2;
      ai.y = 6 * TILE + TILE/2;
      ai.holding = null;
      ai.task = null;
      ai.taskCooldown = 0;
      ai.interactCooldown = 0;

      for (const m of machines) {
        m.processing = null;
        m.timer = 0;
        m.output = null;
      }

      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';

      // Spawn first orders
      spawnOrder();
      spawnOrder();
    }

    // Click to start/restart
    overlay.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
      }
    });
    canvas.addEventListener('click', () => {
      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
      }
    });

    buildFactory();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

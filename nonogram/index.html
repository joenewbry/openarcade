<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nonogram</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 560px;
    }
    .back { color: #a8e; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(170, 136, 238, 0.5); }
    h1 { color: #a8e; font-size: 2rem; text-shadow: 0 0 15px rgba(170, 136, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 560px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #a8e; }
    canvas {
      border: 2px solid #a8e;
      box-shadow: 0 0 20px rgba(170, 136, 238, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #a8e;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>NONOGRAM</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="560" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:560px;height:560px;">
      <h2 id="overlayTitle">NONOGRAM</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // ---- Puzzle definitions ----
    // Each puzzle: { name, size, data (1D array row-major, 1=filled 0=empty) }
    const PUZZLES = [
      // 5x5 puzzles
      {
        name: 'Heart',
        size: 5,
        data: [
          0,1,0,1,0,
          1,1,1,1,1,
          1,1,1,1,1,
          0,1,1,1,0,
          0,0,1,0,0
        ]
      },
      {
        name: 'Star',
        size: 5,
        data: [
          0,0,1,0,0,
          0,1,1,1,0,
          1,1,1,1,1,
          0,1,0,1,0,
          1,0,0,0,1
        ]
      },
      {
        name: 'Arrow',
        size: 5,
        data: [
          0,0,1,0,0,
          0,1,1,0,0,
          1,1,1,1,1,
          0,1,1,0,0,
          0,0,1,0,0
        ]
      },
      {
        name: 'Cross',
        size: 5,
        data: [
          0,1,1,1,0,
          1,0,1,0,1,
          1,1,1,1,1,
          1,0,1,0,1,
          0,1,1,1,0
        ]
      },
      // 10x10 puzzles
      {
        name: 'Mushroom',
        size: 10,
        data: [
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,0,1,1,0,1,1,0,
          0,1,1,1,1,1,1,1,1,0,
          1,1,0,1,1,1,1,0,1,1,
          1,1,1,1,1,1,1,1,1,1,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,0,0,1,1,0,0,
          0,0,1,1,0,0,1,1,0,0,
          0,0,1,1,1,1,1,1,0,0
        ]
      },
      {
        name: 'Skull',
        size: 10,
        data: [
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,1,1,1,1,1,1,0,
          1,1,1,1,1,1,1,1,1,1,
          1,1,0,0,1,1,0,0,1,1,
          1,1,0,0,1,1,0,0,1,1,
          1,1,1,1,1,1,1,1,1,1,
          0,1,1,0,1,1,0,1,1,0,
          0,0,1,1,1,1,1,1,0,0,
          0,0,0,1,0,0,1,0,0,0,
          0,0,1,0,1,1,0,1,0,0
        ]
      },
      {
        name: 'Spaceship',
        size: 10,
        data: [
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,0,1,1,0,1,1,0,
          0,1,1,1,1,1,1,1,1,0,
          1,1,1,1,1,1,1,1,1,1,
          1,0,1,1,0,0,1,1,0,1,
          1,0,0,1,0,0,1,0,0,1,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,0,0,0,0,1,0,0
        ]
      },
      {
        name: 'Cat',
        size: 10,
        data: [
          1,0,0,0,0,0,0,0,0,1,
          1,1,0,0,0,0,0,0,1,1,
          1,1,1,0,0,0,0,1,1,1,
          1,0,1,1,1,1,1,1,0,1,
          1,0,0,1,0,0,1,0,0,1,
          1,1,0,0,1,1,0,0,1,1,
          0,1,1,1,1,1,1,1,1,0,
          0,0,1,1,1,1,1,1,0,0,
          0,0,0,1,0,0,1,0,0,0,
          0,0,1,1,0,0,1,1,0,0
        ]
      },
      {
        name: 'House',
        size: 10,
        data: [
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,1,1,1,1,1,1,0,
          1,1,1,1,1,1,1,1,1,1,
          1,1,1,1,1,1,1,1,1,1,
          1,1,0,0,1,1,0,0,1,1,
          1,1,0,0,1,1,0,0,1,1,
          1,1,1,1,0,0,1,1,1,1,
          1,1,1,1,0,0,1,1,1,1
        ]
      },
      {
        name: 'Anchor',
        size: 10,
        data: [
          0,0,0,1,1,1,1,0,0,0,
          0,0,0,1,0,0,1,0,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          1,0,0,0,1,1,0,0,0,1,
          1,1,0,0,1,1,0,0,1,1,
          0,1,1,0,1,1,0,1,1,0,
          0,0,1,1,1,1,1,1,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,0,0,1,1,0,0
        ]
      },
      {
        name: 'Tree',
        size: 10,
        data: [
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,1,1,1,1,1,1,0,
          0,0,1,1,1,1,1,1,0,0,
          0,1,1,1,1,1,1,1,1,0,
          1,1,1,1,1,1,1,1,1,1,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,1,1,1,1,0,0,0
        ]
      },
      {
        name: 'Sword',
        size: 10,
        data: [
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,1,1,1,1,1,1,0,0,
          0,0,0,1,1,1,1,0,0,0,
          0,0,0,0,1,1,0,0,0,0,
          0,0,0,0,1,1,0,0,0,0
        ]
      }
    ];

    // ---- Game state ----
    let currentPuzzleIndex = 0;
    let puzzleSize = 0;
    let solution = [];     // The target pattern
    let grid = [];         // Player's grid: 0=unknown, 1=filled, 2=marked-empty
    let cursorR = 0;
    let cursorC = 0;
    let rowClues = [];
    let colClues = [];
    let maxRowClueLen = 0;
    let maxColClueLen = 0;
    let startTime = 0;
    let elapsedTime = 0;
    let timerInterval = null;
    let puzzleComplete = false;
    let mistakes = 0;
    let totalFilled = 0;   // Total filled cells in solution

    // Layout constants (recalculated per puzzle)
    let CLUE_AREA_LEFT = 0;
    let CLUE_AREA_TOP = 0;
    let CELL_SIZE = 0;
    let GRID_X = 0;
    let GRID_Y = 0;

    // ---- Clue computation ----
    function computeClues(data, size) {
      const rClues = [];
      const cClues = [];

      for (let r = 0; r < size; r++) {
        const row = [];
        let count = 0;
        for (let c = 0; c < size; c++) {
          if (data[r * size + c]) {
            count++;
          } else if (count > 0) {
            row.push(count);
            count = 0;
          }
        }
        if (count > 0) row.push(count);
        rClues.push(row.length ? row : [0]);
      }

      for (let c = 0; c < size; c++) {
        const col = [];
        let count = 0;
        for (let r = 0; r < size; r++) {
          if (data[r * size + c]) {
            count++;
          } else if (count > 0) {
            col.push(count);
            count = 0;
          }
        }
        if (count > 0) col.push(count);
        cClues.push(col.length ? col : [0]);
      }

      return { rowClues: rClues, colClues: cClues };
    }

    // ---- Layout calculation ----
    function calcLayout() {
      maxRowClueLen = Math.max(...rowClues.map(c => c.length));
      maxColClueLen = Math.max(...colClues.map(c => c.length));

      // Available space for grid + clues
      const availW = W - 20; // 10px margin each side
      const availH = H - 40; // top margin for timer text + bottom margin

      // Cell size calculation: total cells = clue area + grid
      const totalCellsH = maxRowClueLen + puzzleSize;
      const totalCellsV = maxColClueLen + puzzleSize;
      CELL_SIZE = Math.floor(Math.min(availW / totalCellsH, availH / totalCellsV));
      if (CELL_SIZE > 40) CELL_SIZE = 40;
      if (CELL_SIZE < 20) CELL_SIZE = 20;

      const totalW = totalCellsH * CELL_SIZE;
      const totalH = totalCellsV * CELL_SIZE;

      // Center the whole thing
      const startX = Math.floor((W - totalW) / 2);
      const startY = Math.floor((H - totalH) / 2) + 10;

      CLUE_AREA_LEFT = maxRowClueLen * CELL_SIZE;
      CLUE_AREA_TOP = maxColClueLen * CELL_SIZE;
      GRID_X = startX + CLUE_AREA_LEFT;
      GRID_Y = startY + CLUE_AREA_TOP;
    }

    // ---- Check row/col completion ----
    function isRowComplete(r) {
      const clue = rowClues[r];
      const groups = [];
      let count = 0;
      for (let c = 0; c < puzzleSize; c++) {
        if (grid[r * puzzleSize + c] === 1) {
          count++;
        } else {
          if (count > 0) groups.push(count);
          count = 0;
        }
      }
      if (count > 0) groups.push(count);
      if (clue.length === 1 && clue[0] === 0) return groups.length === 0;
      if (groups.length !== clue.length) return false;
      return groups.every((g, i) => g === clue[i]);
    }

    function isColComplete(c) {
      const clue = colClues[c];
      const groups = [];
      let count = 0;
      for (let r = 0; r < puzzleSize; r++) {
        if (grid[r * puzzleSize + c] === 1) {
          count++;
        } else {
          if (count > 0) groups.push(count);
          count = 0;
        }
      }
      if (count > 0) groups.push(count);
      if (clue.length === 1 && clue[0] === 0) return groups.length === 0;
      if (groups.length !== clue.length) return false;
      return groups.every((g, i) => g === clue[i]);
    }

    // ---- Check full puzzle completion ----
    function checkWin() {
      for (let r = 0; r < puzzleSize; r++) {
        for (let c = 0; c < puzzleSize; c++) {
          const idx = r * puzzleSize + c;
          if (solution[idx] === 1 && grid[idx] !== 1) return false;
          if (solution[idx] === 0 && grid[idx] === 1) return false;
        }
      }
      return true;
    }

    // ---- Scoring ----
    function calculateScore() {
      const elapsed = elapsedTime;
      const sizeBonus = puzzleSize === 5 ? 100 : 500;
      // Time penalty: lose 1 point per second after a base time
      const baseTime = puzzleSize === 5 ? 30 : 120;
      const timePenalty = Math.max(0, Math.floor((elapsed - baseTime)));
      // Mistake penalty
      const mistakePenalty = mistakes * 20;
      return Math.max(10, sizeBonus - timePenalty - mistakePenalty);
    }

    // ---- Init / Start / GameOver ----
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      puzzleComplete = false;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'NONOGRAM';
      const p = PUZZLES[currentPuzzleIndex];
      overlayText.innerHTML = `Puzzle ${currentPuzzleIndex + 1}/${PUZZLES.length}: "${p.name}" (${p.size}x${p.size})<br>Press SPACE to start`;
      draw();
    }

    function loadPuzzle() {
      const p = PUZZLES[currentPuzzleIndex];
      puzzleSize = p.size;
      solution = [...p.data];
      grid = new Array(puzzleSize * puzzleSize).fill(0);
      cursorR = 0;
      cursorC = 0;
      mistakes = 0;
      puzzleComplete = false;
      totalFilled = solution.filter(v => v === 1).length;

      const clues = computeClues(solution, puzzleSize);
      rowClues = clues.rowClues;
      colClues = clues.colClues;
      calcLayout();
    }

    function start() {
      loadPuzzle();
      startTime = Date.now();
      elapsedTime = 0;
      gameState = 'playing';
      overlay.style.display = 'none';

      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (gameState === 'playing') {
          elapsedTime = Math.floor((Date.now() - startTime) / 1000);
          draw();
        }
      }, 1000);

      draw();
    }

    function puzzleSolved() {
      puzzleComplete = true;
      clearInterval(timerInterval);
      elapsedTime = Math.floor((Date.now() - startTime) / 1000);

      const puzzleScore = calculateScore();
      score += puzzleScore;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Auto-fill any unmarked empty cells for visual completion
      for (let i = 0; i < puzzleSize * puzzleSize; i++) {
        if (solution[i] === 0 && grid[i] === 0) grid[i] = 2;
      }

      draw();

      // Brief pause to show completed puzzle, then move on or end
      setTimeout(() => {
        if (gameState !== 'playing') return;
        currentPuzzleIndex++;
        if (currentPuzzleIndex >= PUZZLES.length) {
          // All puzzles done
          gameState = 'over';
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'ALL PUZZLES COMPLETE!';
          overlayText.textContent = `Final Score: ${score} -- Press any key to restart`;
          currentPuzzleIndex = 0;
        } else {
          // Load next puzzle
          loadPuzzle();
          startTime = Date.now();
          elapsedTime = 0;
          clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            if (gameState === 'playing') {
              elapsedTime = Math.floor((Date.now() - startTime) / 1000);
              draw();
            }
          }, 1000);
          draw();
        }
      }, 1500);
    }

    function gameOver() {
      gameState = 'over';
      clearInterval(timerInterval);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    // ---- Cell actions ----
    function fillCell(r, c) {
      if (puzzleComplete) return;
      if (r < 0 || r >= puzzleSize || c < 0 || c >= puzzleSize) return;
      const idx = r * puzzleSize + c;
      if (grid[idx] === 1) {
        // Unfill
        grid[idx] = 0;
      } else {
        grid[idx] = 1;
        // Check for mistake
        if (solution[idx] === 0) {
          mistakes++;
        }
      }
      if (checkWin()) puzzleSolved();
      draw();
    }

    function markCell(r, c) {
      if (puzzleComplete) return;
      if (r < 0 || r >= puzzleSize || c < 0 || c >= puzzleSize) return;
      const idx = r * puzzleSize + c;
      if (grid[idx] === 2) {
        grid[idx] = 0;
      } else if (grid[idx] === 0) {
        grid[idx] = 2;
      }
      draw();
    }

    // ---- Drawing ----
    function formatTime(secs) {
      const m = Math.floor(secs / 60);
      const s = secs % 60;
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'waiting') {
        // Draw a preview hint
        ctx.fillStyle = '#888';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Use number clues to fill cells and reveal the picture!', W / 2, H / 2 - 20);
        ctx.fillText('Arrow Keys = Move | Space = Fill | X = Mark Empty', W / 2, H / 2 + 5);
        ctx.fillText('Mouse: Left Click = Fill | Right Click = Mark', W / 2, H / 2 + 25);
        ctx.textAlign = 'left';
        return;
      }

      if (gameState === 'over') return;

      // Timer display
      ctx.fillStyle = '#a8e';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`Time: ${formatTime(elapsedTime)}`, 10, 18);
      ctx.fillText(`Puzzle ${currentPuzzleIndex + 1}/${PUZZLES.length}: "${PUZZLES[currentPuzzleIndex].name}"`, 200, 18);
      ctx.fillText(`Errors: ${mistakes}`, W - 100, 18);
      ctx.textAlign = 'left';

      // Draw grid background
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(GRID_X, GRID_Y, puzzleSize * CELL_SIZE, puzzleSize * CELL_SIZE);

      // Draw grid lines
      ctx.strokeStyle = '#2a2a4e';
      ctx.lineWidth = 1;
      for (let i = 0; i <= puzzleSize; i++) {
        // Thicker lines every 5 cells
        if (i % 5 === 0 && puzzleSize === 10) {
          ctx.strokeStyle = '#4a4a6e';
          ctx.lineWidth = 2;
        } else {
          ctx.strokeStyle = '#2a2a4e';
          ctx.lineWidth = 1;
        }
        ctx.beginPath();
        ctx.moveTo(GRID_X + i * CELL_SIZE, GRID_Y);
        ctx.lineTo(GRID_X + i * CELL_SIZE, GRID_Y + puzzleSize * CELL_SIZE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(GRID_X, GRID_Y + i * CELL_SIZE);
        ctx.lineTo(GRID_X + puzzleSize * CELL_SIZE, GRID_Y + i * CELL_SIZE);
        ctx.stroke();
      }

      // Draw outer border
      ctx.strokeStyle = '#a8e';
      ctx.lineWidth = 2;
      ctx.strokeRect(GRID_X, GRID_Y, puzzleSize * CELL_SIZE, puzzleSize * CELL_SIZE);

      // Draw cells
      for (let r = 0; r < puzzleSize; r++) {
        for (let c = 0; c < puzzleSize; c++) {
          const idx = r * puzzleSize + c;
          const cx = GRID_X + c * CELL_SIZE;
          const cy = GRID_Y + r * CELL_SIZE;

          if (grid[idx] === 1) {
            // Filled cell
            const isCorrect = solution[idx] === 1;
            if (puzzleComplete) {
              ctx.fillStyle = '#a8e';
              ctx.shadowColor = '#a8e';
              ctx.shadowBlur = 8;
            } else if (!isCorrect) {
              ctx.fillStyle = '#f44';
              ctx.shadowColor = '#f44';
              ctx.shadowBlur = 6;
            } else {
              ctx.fillStyle = '#a8e';
              ctx.shadowColor = '#a8e';
              ctx.shadowBlur = 6;
            }
            ctx.fillRect(cx + 2, cy + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            ctx.shadowBlur = 0;
          } else if (grid[idx] === 2) {
            // Marked as empty (X)
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            const pad = 6;
            ctx.beginPath();
            ctx.moveTo(cx + pad, cy + pad);
            ctx.lineTo(cx + CELL_SIZE - pad, cy + CELL_SIZE - pad);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + CELL_SIZE - pad, cy + pad);
            ctx.lineTo(cx + pad, cy + CELL_SIZE - pad);
            ctx.stroke();
          }
        }
      }

      // Draw cursor (only when not complete)
      if (!puzzleComplete) {
        ctx.strokeStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.lineWidth = 3;
        ctx.strokeRect(
          GRID_X + cursorC * CELL_SIZE + 1,
          GRID_Y + cursorR * CELL_SIZE + 1,
          CELL_SIZE - 2,
          CELL_SIZE - 2
        );
        ctx.shadowBlur = 0;
      }

      // Draw row clues
      const clueFont = CELL_SIZE <= 24 ? '11px Courier New' : '13px Courier New';
      ctx.font = clueFont;
      ctx.textBaseline = 'middle';

      for (let r = 0; r < puzzleSize; r++) {
        const clue = rowClues[r];
        const completed = isRowComplete(r);
        const cy = GRID_Y + r * CELL_SIZE + CELL_SIZE / 2;

        for (let i = 0; i < clue.length; i++) {
          const cx = GRID_X - (clue.length - i) * CELL_SIZE + CELL_SIZE / 2;
          ctx.textAlign = 'center';
          if (completed) {
            ctx.fillStyle = '#4a6';
          } else {
            ctx.fillStyle = '#c8c8e8';
          }
          ctx.fillText(String(clue[i]), cx, cy);
        }
      }

      // Draw column clues
      ctx.textAlign = 'center';
      for (let c = 0; c < puzzleSize; c++) {
        const clue = colClues[c];
        const completed = isColComplete(c);
        const cx = GRID_X + c * CELL_SIZE + CELL_SIZE / 2;

        for (let i = 0; i < clue.length; i++) {
          const cy = GRID_Y - (clue.length - i) * CELL_SIZE + CELL_SIZE / 2;
          if (completed) {
            ctx.fillStyle = '#4a6';
          } else {
            ctx.fillStyle = '#c8c8e8';
          }
          ctx.fillText(String(clue[i]), cx, cy);
        }
      }

      // Draw clue area backgrounds
      // Row clue background
      ctx.fillStyle = 'rgba(22, 33, 62, 0.5)';
      ctx.fillRect(GRID_X - maxRowClueLen * CELL_SIZE, GRID_Y, maxRowClueLen * CELL_SIZE, puzzleSize * CELL_SIZE);
      // Col clue background
      ctx.fillRect(GRID_X, GRID_Y - maxColClueLen * CELL_SIZE, puzzleSize * CELL_SIZE, maxColClueLen * CELL_SIZE);

      // Redraw clues on top of backgrounds
      for (let r = 0; r < puzzleSize; r++) {
        const clue = rowClues[r];
        const completed = isRowComplete(r);
        const cy = GRID_Y + r * CELL_SIZE + CELL_SIZE / 2;

        for (let i = 0; i < clue.length; i++) {
          const cx = GRID_X - (clue.length - i) * CELL_SIZE + CELL_SIZE / 2;
          ctx.textAlign = 'center';
          ctx.fillStyle = completed ? '#4a6' : '#c8c8e8';
          ctx.fillText(String(clue[i]), cx, cy);
        }
      }

      for (let c = 0; c < puzzleSize; c++) {
        const clue = colClues[c];
        const completed = isColComplete(c);
        const cx = GRID_X + c * CELL_SIZE + CELL_SIZE / 2;

        for (let i = 0; i < clue.length; i++) {
          const cy = GRID_Y - (clue.length - i) * CELL_SIZE + CELL_SIZE / 2;
          ctx.fillStyle = completed ? '#4a6' : '#c8c8e8';
          ctx.fillText(String(clue[i]), cx, cy);
        }
      }

      // Separator lines between clue area and grid
      ctx.strokeStyle = '#a8e';
      ctx.lineWidth = 2;
      // Left of grid (vertical separator)
      ctx.beginPath();
      ctx.moveTo(GRID_X, GRID_Y - maxColClueLen * CELL_SIZE);
      ctx.lineTo(GRID_X, GRID_Y + puzzleSize * CELL_SIZE);
      ctx.stroke();
      // Top of grid (horizontal separator)
      ctx.beginPath();
      ctx.moveTo(GRID_X - maxRowClueLen * CELL_SIZE, GRID_Y);
      ctx.lineTo(GRID_X + puzzleSize * CELL_SIZE, GRID_Y);
      ctx.stroke();

      // Puzzle complete flash
      if (puzzleComplete) {
        ctx.fillStyle = 'rgba(170, 136, 238, 0.15)';
        ctx.fillRect(GRID_X, GRID_Y, puzzleSize * CELL_SIZE, puzzleSize * CELL_SIZE);
        ctx.fillStyle = '#a8e';
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#a8e';
        ctx.shadowBlur = 15;
        ctx.fillText('COMPLETE!', GRID_X + puzzleSize * CELL_SIZE / 2, GRID_Y + puzzleSize * CELL_SIZE + 25);
        ctx.shadowBlur = 0;
      }
    }

    // ---- Mouse input ----
    function getCellFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const c = Math.floor((mx - GRID_X) / CELL_SIZE);
      const r = Math.floor((my - GRID_Y) / CELL_SIZE);
      if (r >= 0 && r < puzzleSize && c >= 0 && c < puzzleSize) {
        return { r, c };
      }
      return null;
    }

    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing' || puzzleComplete) return;
      const cell = getCellFromMouse(e);
      if (cell) {
        cursorR = cell.r;
        cursorC = cell.c;
        fillCell(cell.r, cell.c);
      }
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (gameState !== 'playing' || puzzleComplete) return;
      const cell = getCellFromMouse(e);
      if (cell) {
        cursorR = cell.r;
        cursorC = cell.c;
        markCell(cell.r, cell.c);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'playing' || puzzleComplete) return;
      const cell = getCellFromMouse(e);
      if (cell) {
        if (cell.r !== cursorR || cell.c !== cursorC) {
          cursorR = cell.r;
          cursorC = cell.c;
          draw();
        }
      }
    });

    // ---- Keyboard input ----
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'x', 'X'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        currentPuzzleIndex = 0;
        init();
        return;
      }

      if (gameState === 'playing' && !puzzleComplete) {
        switch (e.key) {
          case 'ArrowUp':
            cursorR = Math.max(0, cursorR - 1);
            draw();
            break;
          case 'ArrowDown':
            cursorR = Math.min(puzzleSize - 1, cursorR + 1);
            draw();
            break;
          case 'ArrowLeft':
            cursorC = Math.max(0, cursorC - 1);
            draw();
            break;
          case 'ArrowRight':
            cursorC = Math.min(puzzleSize - 1, cursorC + 1);
            draw();
            break;
          case ' ':
            fillCell(cursorR, cursorC);
            break;
          case 'x':
          case 'X':
            markCell(cursorR, cursorC);
            break;
        }
      }
    });

    // ---- Expose game data for ML ----
    window.gameData = {
      get puzzleIndex() { return currentPuzzleIndex; },
      get puzzleSize() { return puzzleSize; },
      get cursorR() { return cursorR; },
      get cursorC() { return cursorC; },
      get grid() { return grid; },
      get mistakes() { return mistakes; },
      get elapsed() { return elapsedTime; }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

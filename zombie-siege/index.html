<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zombie Siege Co-op</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4a4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 68, 0.5); }
    h1 { color: #4a4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 170, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #4a4; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 6px;
      font-size: 0.85rem;
      color: #888;
    }
    .info-bar span { color: #4a4; }
    canvas {
      border: 2px solid #4a4;
      box-shadow: 0 0 20px rgba(68, 170, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4a4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(68,170,68,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
    .overlay .controls { font-size: 0.8rem; color: #777; margin-top: 12px; line-height: 1.6; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ZOMBIE SIEGE CO-OP</h1>
  </div>
  <div class="score-bar">
    <div>Kills: <span id="score">0</span></div>
    <div>Wave: <span id="wave">1</span></div>
    <div>Base: <span id="baseHp">100</span>%</div>
  </div>
  <div class="info-bar">
    <div>HP: <span id="playerHp">100</span> | Ammo: <span id="ammo">--</span> | Scrap: <span id="scrap">0</span></div>
    <div>Ally: <span id="allyHp">100</span> HP | Class: <span id="classInfo">Soldier</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">ZOMBIE SIEGE CO-OP</h2>
      <p id="overlayText">Click to Start</p>
      <div class="controls" id="controlsText">
        WASD = Move | Mouse = Aim + Shoot | R = Reload<br>
        E = Build Barricade (5 scrap) | Q = Class Ability<br>
        1/2/3 = Pistol/Shotgun/Rifle<br>
        Choose class: [M]edic  [N]gineer  [S]oldier
      </div>
    </div>
  </div>

  <script>
    // =============================================
    // ZOMBIE SIEGE CO-OP - Full Game
    // =============================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const waveEl = document.getElementById('wave');
    const baseHpEl = document.getElementById('baseHp');
    const playerHpEl = document.getElementById('playerHp');
    const ammoEl = document.getElementById('ammo');
    const scrapEl = document.getElementById('scrap');
    const allyHpEl = document.getElementById('allyHp');
    const classInfoEl = document.getElementById('classInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const controlsText = document.getElementById('controlsText');

    let gameState = 'menu';
    let score = 0;
    let animFrame = null;
    let lastTime = 0;

    // ---- Constants ----
    const BASE_X = W / 2, BASE_Y = H / 2;
    const BASE_RADIUS = 28;
    const PLAYER_RADIUS = 8;
    const ZOMBIE_RADIUS = 7;
    const BULLET_RADIUS = 2;
    const BARRICADE_W = 24, BARRICADE_H = 8;
    const TURRET_RADIUS = 7;
    const GRENADE_RADIUS = 3;
    const GRENADE_EXPLODE_RADIUS = 40;
    const SCRAP_PER_KILL = 1;
    const BARRICADE_COST = 5;
    const BARRICADE_HP = 60;

    // Weapon definitions
    const WEAPONS = {
      pistol:  { name: 'Pistol',  damage: 15, fireRate: 0.35, spread: 0.03, bullets: 1, speed: 400, maxAmmo: Infinity, reloadTime: 0 },
      shotgun: { name: 'Shotgun', damage: 10, fireRate: 0.7,  spread: 0.15, bullets: 5, speed: 350, maxAmmo: 24, reloadTime: 1.2 },
      rifle:   { name: 'Rifle',   damage: 12, fireRate: 0.12, spread: 0.02, bullets: 1, speed: 500, maxAmmo: 60, reloadTime: 1.5 }
    };

    // ---- Input ----
    const keys = {};
    let mouseX = W / 2, mouseY = H / 2;
    let mouseDown = false;

    document.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if (gameState === 'menu') {
        gameState = 'classSelect';
        overlayTitle.textContent = 'CHOOSE YOUR CLASS';
        overlayText.textContent = '';
        controlsText.innerHTML =
          '<span style="color:#4a4">[M]</span> Medic: Q heals nearby allies<br>' +
          '<span style="color:#4a4">[N]</span> Engineer: Q places auto-turret<br>' +
          '<span style="color:#4a4">[S]</span> Soldier: Q throws grenade';
        return;
      }
      if (gameState === 'classSelect') {
        if (e.key.toLowerCase() === 'm') { playerClass = 'medic'; startGame(); }
        else if (e.key.toLowerCase() === 'n') { playerClass = 'engineer'; startGame(); }
        else if (e.key.toLowerCase() === 's') { playerClass = 'soldier'; startGame(); }
        return;
      }
      if (gameState === 'playing') {
        if (e.key === '1') switchWeapon('pistol');
        if (e.key === '2') switchWeapon('shotgun');
        if (e.key === '3') switchWeapon('rifle');
        if (e.key.toLowerCase() === 'r') startReload();
        if (e.key.toLowerCase() === 'e') buildBarricade();
        if (e.key.toLowerCase() === 'q') useAbility();
      }
    });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (W / rect.width);
      mouseY = (e.clientY - rect.top) * (H / rect.height);
    });
    canvas.addEventListener('mousedown', e => {
      mouseDown = true;
      if (gameState === 'menu') {
        gameState = 'classSelect';
        overlayTitle.textContent = 'CHOOSE YOUR CLASS';
        overlayText.textContent = '';
        controlsText.innerHTML =
          '<span style="color:#4a4">[M]</span> Medic: Q heals nearby allies<br>' +
          '<span style="color:#4a4">[N]</span> Engineer: Q places auto-turret<br>' +
          '<span style="color:#4a4">[S]</span> Soldier: Q throws grenade';
        return;
      }
      if (gameState === 'gameover') {
        gameState = 'classSelect';
        overlayTitle.textContent = 'CHOOSE YOUR CLASS';
        overlayText.textContent = '';
        overlay.style.display = 'flex';
        controlsText.innerHTML =
          '<span style="color:#4a4">[M]</span> Medic: Q heals nearby allies<br>' +
          '<span style="color:#4a4">[N]</span> Engineer: Q places auto-turret<br>' +
          '<span style="color:#4a4">[S]</span> Soldier: Q throws grenade';
        return;
      }
    });
    canvas.addEventListener('mouseup', () => { mouseDown = false; });

    // ---- Game State Variables ----
    let playerClass = 'soldier';
    let player, ally, base;
    let zombies, bullets, barricades, turrets, grenades, particles, scrapDrops, healEffects;
    let wave, zombiesRemaining, waveTimer, spawnTimer, betweenWaves;

    // ---- Player / Ally constructor ----
    function makePlayer(x, y, cls, isAI) {
      return {
        x, y, hp: 100, maxHp: 100, speed: 100, radius: PLAYER_RADIUS,
        class: cls, isAI,
        weapon: 'pistol',
        ammo: { pistol: Infinity, shotgun: 24, rifle: 60 },
        maxAmmo: { pistol: Infinity, shotgun: 24, rifle: 60 },
        reloading: false, reloadTimer: 0,
        fireTimer: 0,
        angle: 0,
        scrap: 0,
        abilityCooldown: 0,
        invulnTimer: 0,
        alive: true
      };
    }

    function startGame() {
      overlay.style.display = 'none';
      score = 0;
      scoreEl.textContent = '0';
      player = makePlayer(BASE_X - 30, BASE_Y, playerClass, false);
      // AI ally gets a complementary class
      let allyClass = playerClass === 'soldier' ? 'medic' : (playerClass === 'medic' ? 'soldier' : 'soldier');
      ally = makePlayer(BASE_X + 30, BASE_Y, allyClass, true);
      base = { x: BASE_X, y: BASE_Y, hp: 100, maxHp: 100, radius: BASE_RADIUS };
      zombies = [];
      bullets = [];
      barricades = [];
      turrets = [];
      grenades = [];
      particles = [];
      scrapDrops = [];
      healEffects = [];
      wave = 0;
      zombiesRemaining = 0;
      waveTimer = 2;
      spawnTimer = 0;
      betweenWaves = true;
      classInfoEl.textContent = playerClass.charAt(0).toUpperCase() + playerClass.slice(1);
      nextWave();
      gameState = 'playing';
      lastTime = performance.now();
    }

    // ---- Waves ----
    function nextWave() {
      wave++;
      waveEl.textContent = wave;
      let count = 5 + wave * 3 + Math.floor(wave * wave * 0.3);
      zombiesRemaining = count;
      spawnTimer = 0;
      betweenWaves = false;
      // Replenish some ammo between waves
      if (player) {
        player.ammo.shotgun = Math.min(player.maxAmmo.shotgun, player.ammo.shotgun + 8);
        player.ammo.rifle = Math.min(player.maxAmmo.rifle, player.ammo.rifle + 15);
      }
      if (ally) {
        ally.ammo.shotgun = Math.min(ally.maxAmmo.shotgun, ally.ammo.shotgun + 8);
        ally.ammo.rifle = Math.min(ally.maxAmmo.rifle, ally.ammo.rifle + 15);
      }
    }

    function spawnZombie() {
      let side = Math.random() * 4 | 0;
      let x, y;
      if (side === 0) { x = -10; y = Math.random() * H; }
      else if (side === 1) { x = W + 10; y = Math.random() * H; }
      else if (side === 2) { x = Math.random() * W; y = -10; }
      else { x = Math.random() * W; y = H + 10; }

      let type = 'normal';
      let r = Math.random();
      if (wave >= 3 && r < 0.15) type = 'fast';
      if (wave >= 5 && r < 0.08) type = 'tank';
      if (wave >= 7 && r < 0.05) type = 'boss';

      let hp, speed, damage, radius, color;
      switch (type) {
        case 'normal': hp = 20 + wave * 3; speed = 30 + Math.random() * 15; damage = 8; radius = ZOMBIE_RADIUS; color = '#4a4'; break;
        case 'fast':   hp = 12 + wave * 2; speed = 60 + Math.random() * 20; damage = 5; radius = 5; color = '#8f8'; break;
        case 'tank':   hp = 60 + wave * 8; speed = 18 + Math.random() * 8; damage = 15; radius = 10; color = '#2a6'; break;
        case 'boss':   hp = 150 + wave * 15; speed = 22; damage = 25; radius = 14; color = '#f44'; break;
      }

      zombies.push({
        x, y, hp, maxHp: hp, speed, damage, radius, color, type,
        attackTimer: 0, attackRate: 0.8,
        knockback: { x: 0, y: 0 },
        stunTimer: 0
      });
    }

    // ---- Weapons ----
    function switchWeapon(wep) {
      if (player.reloading) return;
      player.weapon = wep;
    }

    function startReload() {
      let p = player;
      if (p.reloading) return;
      let w = WEAPONS[p.weapon];
      if (w.maxAmmo === Infinity) return;
      if (p.ammo[p.weapon] >= w.maxAmmo) return;
      p.reloading = true;
      p.reloadTimer = w.reloadTime;
    }

    function fireBullet(shooter, targetX, targetY) {
      let w = WEAPONS[shooter.weapon];
      if (shooter.fireTimer > 0) return;
      if (shooter.reloading) return;
      if (shooter.ammo[shooter.weapon] <= 0 && w.maxAmmo !== Infinity) {
        shooter.reloading = true;
        shooter.reloadTimer = w.reloadTime;
        return;
      }

      shooter.fireTimer = w.fireRate;
      if (w.maxAmmo !== Infinity) shooter.ammo[shooter.weapon]--;

      let angle = Math.atan2(targetY - shooter.y, targetX - shooter.x);
      for (let i = 0; i < w.bullets; i++) {
        let a = angle + (Math.random() - 0.5) * w.spread * 2;
        bullets.push({
          x: shooter.x, y: shooter.y,
          vx: Math.cos(a) * w.speed,
          vy: Math.sin(a) * w.speed,
          damage: w.damage,
          owner: shooter === player ? 'player' : 'ally',
          life: 1.2
        });
      }
      particles.push({
        x: shooter.x + Math.cos(angle) * 10,
        y: shooter.y + Math.sin(angle) * 10,
        vx: 0, vy: 0, life: 0.08, maxLife: 0.08,
        color: '#ff8', radius: 4
      });
    }

    // ---- Barricades ----
    function buildBarricade() {
      if (player.scrap < BARRICADE_COST) return;
      let angle = Math.atan2(mouseY - player.y, mouseX - player.x);
      let bx = player.x + Math.cos(angle) * 20;
      let by = player.y + Math.sin(angle) * 20;
      if (dist(bx, by, base.x, base.y) < BASE_RADIUS + 10) return;
      player.scrap -= BARRICADE_COST;
      barricades.push({
        x: bx, y: by, w: BARRICADE_W, h: BARRICADE_H,
        hp: BARRICADE_HP, maxHp: BARRICADE_HP,
        angle: angle
      });
    }

    // ---- Abilities ----
    function useAbility() {
      if (player.abilityCooldown > 0) return;
      doAbility(player);
    }

    function doAbility(p) {
      switch (p.class) {
        case 'medic':
          p.abilityCooldown = 8;
          let healRange = 60;
          [player, ally].forEach(target => {
            if (!target.alive) return;
            if (dist(p.x, p.y, target.x, target.y) < healRange) {
              target.hp = Math.min(target.maxHp, target.hp + 30);
              healEffects.push({ x: target.x, y: target.y, timer: 0.6 });
            }
          });
          if (dist(p.x, p.y, base.x, base.y) < healRange + BASE_RADIUS) {
            base.hp = Math.min(base.maxHp, base.hp + 5);
            healEffects.push({ x: base.x, y: base.y, timer: 0.6 });
          }
          break;
        case 'engineer':
          if (turrets.length >= 4) turrets.shift();
          p.abilityCooldown = 12;
          let tx = p.x + (p.isAI ? (Math.random()-0.5)*30 : Math.cos(Math.atan2(mouseY-p.y,mouseX-p.x))*25);
          let ty = p.y + (p.isAI ? (Math.random()-0.5)*30 : Math.sin(Math.atan2(mouseY-p.y,mouseX-p.x))*25);
          turrets.push({
            x: tx, y: ty, hp: 50, maxHp: 50,
            fireTimer: 0, fireRate: 0.5, damage: 8, range: 80,
            angle: 0
          });
          break;
        case 'soldier':
          p.abilityCooldown = 6;
          let gx, gy;
          if (p.isAI) {
            let best = null, bestCount = 0;
            zombies.forEach(z => {
              let count = zombies.filter(z2 => dist(z.x,z.y,z2.x,z2.y) < GRENADE_EXPLODE_RADIUS).length;
              if (count > bestCount) { bestCount = count; best = z; }
            });
            if (best) { gx = best.x; gy = best.y; }
            else { gx = p.x + 50; gy = p.y; }
          } else {
            gx = mouseX; gy = mouseY;
          }
          grenades.push({
            x: p.x, y: p.y,
            tx: gx, ty: gy,
            timer: 0.6, speed: 200
          });
          break;
      }
    }

    // ---- Utility ----
    function dist(x1, y1, x2, y2) {
      let dx = x2 - x1, dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function clamp(v, mn, mx) { return Math.max(mn, Math.min(mx, v)); }

    // ---- AI Ally Behavior ----
    function updateAlly(dt) {
      if (!ally.alive) return;

      let nearestZombie = null, nearestDist = Infinity;
      let zombiesNearBase = 0;
      let zombiesNearAlly = 0;

      zombies.forEach(z => {
        let d = dist(ally.x, ally.y, z.x, z.y);
        if (d < nearestDist) { nearestDist = d; nearestZombie = z; }
        if (dist(z.x, z.y, base.x, base.y) < 80) zombiesNearBase++;
        if (d < 60) zombiesNearAlly++;
      });

      let lowHp = ally.hp < 30;
      let targetX, targetY;

      if (lowHp && ally.class !== 'medic') {
        targetX = base.x + (ally.x > base.x ? 15 : -15);
        targetY = base.y + (ally.y > base.y ? 15 : -15);
      } else if (zombiesNearBase > 2) {
        if (nearestZombie) {
          let angle = Math.atan2(nearestZombie.y - base.y, nearestZombie.x - base.x);
          targetX = base.x + Math.cos(angle) * (BASE_RADIUS + 25);
          targetY = base.y + Math.sin(angle) * (BASE_RADIUS + 25);
        } else {
          targetX = base.x + 25; targetY = base.y;
        }
      } else {
        let px = player.alive ? player.x : base.x;
        let py = player.alive ? player.y : base.y;
        let angleFromBase = Math.atan2(py - base.y, px - base.x);
        let patrolAngle = angleFromBase + Math.PI + Math.sin(performance.now() * 0.001) * 0.5;
        targetX = base.x + Math.cos(patrolAngle) * 55;
        targetY = base.y + Math.sin(patrolAngle) * 55;
      }

      let dx = targetX - ally.x, dy = targetY - ally.y;
      let d = Math.sqrt(dx * dx + dy * dy);
      if (d > 3) {
        ally.x += (dx / d) * ally.speed * dt;
        ally.y += (dy / d) * ally.speed * dt;
      }
      ally.x = clamp(ally.x, 10, W - 10);
      ally.y = clamp(ally.y, 10, H - 10);

      if (nearestZombie && nearestDist < 150) {
        ally.angle = Math.atan2(nearestZombie.y - ally.y, nearestZombie.x - ally.x);
        if (nearestDist < 50 && ally.ammo.shotgun > 0) ally.weapon = 'shotgun';
        else if (ally.ammo.rifle > 0) ally.weapon = 'rifle';
        else ally.weapon = 'pistol';
        fireBullet(ally, nearestZombie.x, nearestZombie.y);
      }

      if (ally.abilityCooldown <= 0) {
        if (ally.class === 'medic') {
          if (ally.hp < 50 || (player.alive && player.hp < 50) || base.hp < 60) {
            doAbility(ally);
          }
        } else if (ally.class === 'engineer') {
          if (turrets.length < 2 && zombies.length > 3) {
            doAbility(ally);
          }
        } else if (ally.class === 'soldier') {
          if (zombiesNearBase >= 3 || zombiesNearAlly >= 4) {
            doAbility(ally);
          }
        }
      }

      if (ally.scrap >= BARRICADE_COST && zombiesNearBase >= 2 && barricades.length < 8 && Math.random() < 0.01) {
        let angle = Math.atan2(
          (nearestZombie ? nearestZombie.y : ally.y + 20) - ally.y,
          (nearestZombie ? nearestZombie.x : ally.x + 20) - ally.x
        );
        let bx = ally.x + Math.cos(angle) * 20;
        let by = ally.y + Math.sin(angle) * 20;
        if (dist(bx, by, base.x, base.y) > BASE_RADIUS + 10) {
          ally.scrap -= BARRICADE_COST;
          barricades.push({
            x: bx, y: by, w: BARRICADE_W, h: BARRICADE_H,
            hp: BARRICADE_HP, maxHp: BARRICADE_HP, angle
          });
        }
      }

      if (ally.scrap > 10 && player.alive && player.scrap < 3 && dist(ally.x, ally.y, player.x, player.y) < 40) {
        let give = Math.min(3, ally.scrap - 5);
        ally.scrap -= give;
        player.scrap += give;
      }

      ally.fireTimer = Math.max(0, ally.fireTimer - dt);
      if (ally.reloading) {
        ally.reloadTimer -= dt;
        if (ally.reloadTimer <= 0) {
          ally.reloading = false;
          ally.ammo[ally.weapon] = WEAPONS[ally.weapon].maxAmmo;
        }
      }
      if (ally.ammo[ally.weapon] <= 0 && WEAPONS[ally.weapon].maxAmmo !== Infinity && !ally.reloading) {
        ally.reloading = true;
        ally.reloadTimer = WEAPONS[ally.weapon].reloadTime;
      }
      ally.abilityCooldown = Math.max(0, ally.abilityCooldown - dt);
      ally.invulnTimer = Math.max(0, ally.invulnTimer - dt);
    }

    // ---- Update ----
    function update(dt) {
      if (gameState !== 'playing') return;

      // Player movement
      if (player.alive) {
        let mx = 0, my = 0;
        if (keys['w'] || keys['arrowup']) my = -1;
        if (keys['s'] || keys['arrowdown']) my = 1;
        if (keys['a'] || keys['arrowleft']) mx = -1;
        if (keys['d'] || keys['arrowright']) mx = 1;
        if (mx || my) {
          let len = Math.sqrt(mx * mx + my * my);
          player.x += (mx / len) * player.speed * dt;
          player.y += (my / len) * player.speed * dt;
        }
        player.x = clamp(player.x, 10, W - 10);
        player.y = clamp(player.y, 10, H - 10);
        player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);

        if (mouseDown) fireBullet(player, mouseX, mouseY);

        player.fireTimer = Math.max(0, player.fireTimer - dt);
        if (player.reloading) {
          player.reloadTimer -= dt;
          if (player.reloadTimer <= 0) {
            player.reloading = false;
            player.ammo[player.weapon] = WEAPONS[player.weapon].maxAmmo;
          }
        }
        player.abilityCooldown = Math.max(0, player.abilityCooldown - dt);
        player.invulnTimer = Math.max(0, player.invulnTimer - dt);
      }

      updateAlly(dt);

      // Spawn zombies
      if (!betweenWaves && zombiesRemaining > 0) {
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
          let spawnRate = Math.max(0.15, 0.8 - wave * 0.04);
          spawnTimer = spawnRate;
          spawnZombie();
          zombiesRemaining--;
        }
      }

      if (!betweenWaves && zombiesRemaining <= 0 && zombies.length === 0) {
        betweenWaves = true;
        waveTimer = 3;
      }
      if (betweenWaves) {
        waveTimer -= dt;
        if (waveTimer <= 0) nextWave();
      }

      // Update zombies
      for (let i = zombies.length - 1; i >= 0; i--) {
        let z = zombies[i];
        z.attackTimer = Math.max(0, z.attackTimer - dt);
        z.stunTimer = Math.max(0, z.stunTimer - dt);

        if (Math.abs(z.knockback.x) > 0.1 || Math.abs(z.knockback.y) > 0.1) {
          z.x += z.knockback.x * dt * 8;
          z.y += z.knockback.y * dt * 8;
          z.knockback.x *= 0.9;
          z.knockback.y *= 0.9;
        }

        if (z.stunTimer > 0) continue;

        let targets = [];
        targets.push({ x: base.x, y: base.y, type: 'base', dist: dist(z.x,z.y,base.x,base.y) });
        if (player.alive) targets.push({ x: player.x, y: player.y, type: 'player', dist: dist(z.x,z.y,player.x,player.y) });
        if (ally.alive) targets.push({ x: ally.x, y: ally.y, type: 'ally', dist: dist(z.x,z.y,ally.x,ally.y) });

        let best = null, bestDist = Infinity;
        targets.forEach(t => {
          if (t.dist < bestDist) { bestDist = t.dist; best = t; }
        });

        let blockedByBarricade = null;
        barricades.forEach(b => {
          let d = dist(z.x, z.y, b.x, b.y);
          if (d < 30 && d < bestDist) blockedByBarricade = b;
        });

        if (blockedByBarricade) {
          let b = blockedByBarricade;
          let d = dist(z.x, z.y, b.x, b.y);
          if (d < z.radius + 14) {
            if (z.attackTimer <= 0) {
              b.hp -= z.damage;
              z.attackTimer = z.attackRate;
              if (b.hp <= 0) {
                barricades.splice(barricades.indexOf(b), 1);
                for (let j = 0; j < 5; j++) {
                  particles.push({
                    x: b.x, y: b.y,
                    vx: (Math.random() - 0.5) * 80, vy: (Math.random() - 0.5) * 80,
                    life: 0.5, maxLife: 0.5, color: '#864', radius: 3
                  });
                }
              }
            }
          } else {
            let ddx = b.x - z.x, ddy = b.y - z.y;
            let dd = Math.sqrt(ddx*ddx + ddy*ddy);
            z.x += (ddx / dd) * z.speed * dt;
            z.y += (ddy / dd) * z.speed * dt;
          }
        } else if (best) {
          let ddx = best.x - z.x, ddy = best.y - z.y;
          let dd = Math.sqrt(ddx * ddx + ddy * ddy);
          let hitDist = best.type === 'base' ? (z.radius + BASE_RADIUS) : (z.radius + PLAYER_RADIUS);

          if (dd > hitDist) {
            z.x += (ddx / dd) * z.speed * dt;
            z.y += (ddy / dd) * z.speed * dt;
          } else {
            if (z.attackTimer <= 0) {
              z.attackTimer = z.attackRate;
              if (best.type === 'base') {
                base.hp -= z.damage * 0.5;
              } else if (best.type === 'player' && player.invulnTimer <= 0) {
                player.hp -= z.damage;
                player.invulnTimer = 0.3;
              } else if (best.type === 'ally' && ally.invulnTimer <= 0) {
                ally.hp -= z.damage;
                ally.invulnTimer = 0.3;
              }
            }
          }
        }

        // Zombie-zombie separation
        for (let j = i + 1; j < zombies.length; j++) {
          let z2 = zombies[j];
          let dd = dist(z.x, z.y, z2.x, z2.y);
          let minD = z.radius + z2.radius;
          if (dd < minD && dd > 0.1) {
            let push = (minD - dd) * 0.3;
            let nx = (z2.x - z.x) / dd, ny = (z2.y - z.y) / dd;
            z.x -= nx * push; z.y -= ny * push;
            z2.x += nx * push; z2.y += ny * push;
          }
        }
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;
        if (b.life <= 0 || b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10) {
          bullets.splice(i, 1);
          continue;
        }

        let hit = false;
        for (let j = zombies.length - 1; j >= 0; j--) {
          let z = zombies[j];
          if (dist(b.x, b.y, z.x, z.y) < z.radius + BULLET_RADIUS) {
            z.hp -= b.damage;
            let angle = Math.atan2(b.vy, b.vx);
            z.knockback.x += Math.cos(angle) * 15;
            z.knockback.y += Math.sin(angle) * 15;
            z.stunTimer = 0.05;
            particles.push({
              x: b.x, y: b.y,
              vx: (Math.random() - 0.5) * 40, vy: (Math.random() - 0.5) * 40,
              life: 0.2, maxLife: 0.2, color: '#f84', radius: 2
            });
            if (z.hp <= 0) {
              score++;
              scoreEl.textContent = score;
              for (let k = 0; k < 4; k++) {
                particles.push({
                  x: z.x, y: z.y,
                  vx: (Math.random() - 0.5) * 60, vy: (Math.random() - 0.5) * 60,
                  life: 0.4, maxLife: 0.4, color: '#4a4', radius: 3
                });
              }
              let scrapAmt = SCRAP_PER_KILL + (z.type === 'boss' ? 5 : z.type === 'tank' ? 2 : 0);
              scrapDrops.push({ x: z.x, y: z.y, amount: scrapAmt, timer: 10 });
              zombies.splice(j, 1);
            }
            hit = true;
            break;
          }
        }
        if (hit) bullets.splice(i, 1);
      }

      // Update turrets
      for (let i = turrets.length - 1; i >= 0; i--) {
        let t = turrets[i];
        t.fireTimer = Math.max(0, t.fireTimer - dt);
        let nearest = null, nearDist = Infinity;
        zombies.forEach(z => {
          let d = dist(t.x, t.y, z.x, z.y);
          if (d < t.range && d < nearDist) { nearDist = d; nearest = z; }
        });
        if (nearest && t.fireTimer <= 0) {
          t.fireTimer = t.fireRate;
          t.angle = Math.atan2(nearest.y - t.y, nearest.x - t.x);
          bullets.push({
            x: t.x, y: t.y,
            vx: Math.cos(t.angle) * 300, vy: Math.sin(t.angle) * 300,
            damage: t.damage, owner: 'turret', life: 0.5
          });
        } else if (nearest) {
          t.angle = Math.atan2(nearest.y - t.y, nearest.x - t.x);
        }
        t.hp -= dt * 2;
        if (t.hp <= 0) turrets.splice(i, 1);
      }

      // Update grenades
      for (let i = grenades.length - 1; i >= 0; i--) {
        let g = grenades[i];
        let gdx = g.tx - g.x, gdy = g.ty - g.y;
        let gdd = Math.sqrt(gdx * gdx + gdy * gdy);
        if (gdd > 5) {
          g.x += (gdx / gdd) * g.speed * dt;
          g.y += (gdy / gdd) * g.speed * dt;
        }
        g.timer -= dt;
        if (g.timer <= 0) {
          zombies.forEach(z => {
            if (dist(z.x, z.y, g.x, g.y) < GRENADE_EXPLODE_RADIUS) {
              z.hp -= 40 + wave * 2;
              let angle = Math.atan2(z.y - g.y, z.x - g.x);
              z.knockback.x += Math.cos(angle) * 40;
              z.knockback.y += Math.sin(angle) * 40;
              z.stunTimer = 0.3;
            }
          });
          for (let j = 0; j < 12; j++) {
            let a = (j / 12) * Math.PI * 2;
            particles.push({
              x: g.x, y: g.y,
              vx: Math.cos(a) * (60 + Math.random() * 40),
              vy: Math.sin(a) * (60 + Math.random() * 40),
              life: 0.4, maxLife: 0.4,
              color: j % 2 === 0 ? '#f84' : '#ff4', radius: 4
            });
          }
          barricades.forEach(b => {
            if (dist(b.x, b.y, g.x, g.y) < GRENADE_EXPLODE_RADIUS) b.hp -= 15;
          });
          grenades.splice(i, 1);
        }
      }

      // Scrap pickup
      for (let i = scrapDrops.length - 1; i >= 0; i--) {
        let s = scrapDrops[i];
        s.timer -= dt;
        if (s.timer <= 0) { scrapDrops.splice(i, 1); continue; }
        if (player.alive && dist(player.x, player.y, s.x, s.y) < 18) {
          player.scrap += s.amount;
          scrapDrops.splice(i, 1);
          continue;
        }
        if (ally.alive && dist(ally.x, ally.y, s.x, s.y) < 18) {
          ally.scrap += s.amount;
          scrapDrops.splice(i, 1);
          continue;
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Heal effects
      for (let i = healEffects.length - 1; i >= 0; i--) {
        healEffects[i].timer -= dt;
        if (healEffects[i].timer <= 0) healEffects.splice(i, 1);
      }

      // Remove dead barricades
      barricades = barricades.filter(b => b.hp > 0);

      // Check player/ally death
      if (player.alive && player.hp <= 0) {
        player.alive = false;
        for (let j = 0; j < 8; j++) {
          particles.push({
            x: player.x, y: player.y,
            vx: (Math.random()-0.5)*80, vy: (Math.random()-0.5)*80,
            life: 0.5, maxLife: 0.5, color: '#48f', radius: 3
          });
        }
      }
      if (ally.alive && ally.hp <= 0) {
        ally.alive = false;
        for (let j = 0; j < 8; j++) {
          particles.push({
            x: ally.x, y: ally.y,
            vx: (Math.random()-0.5)*80, vy: (Math.random()-0.5)*80,
            life: 0.5, maxLife: 0.5, color: '#f84', radius: 3
          });
        }
      }

      // Revive mechanic - stand near base
      if (!player.alive && ally.alive && dist(ally.x, ally.y, base.x, base.y) < BASE_RADIUS + 15) {
        player.alive = true;
        player.hp = 50;
        player.x = base.x - 15;
        player.y = base.y;
        healEffects.push({ x: player.x, y: player.y, timer: 0.8 });
      }
      if (!ally.alive && player.alive && dist(player.x, player.y, base.x, base.y) < BASE_RADIUS + 15) {
        ally.alive = true;
        ally.hp = 50;
        ally.x = base.x + 15;
        ally.y = base.y;
        healEffects.push({ x: ally.x, y: ally.y, timer: 0.8 });
      }

      // Game over
      if (base.hp <= 0) {
        base.hp = 0;
        gameState = 'gameover';
        overlayTitle.textContent = 'BASE DESTROYED';
        overlayText.textContent = 'Wave ' + wave + ' | Kills: ' + score;
        controlsText.textContent = 'Click to restart';
        overlay.style.display = 'flex';
      }

      // HUD updates
      baseHpEl.textContent = Math.max(0, Math.round(base.hp));
      playerHpEl.textContent = player.alive ? Math.round(player.hp) : 'DEAD';
      allyHpEl.textContent = ally.alive ? Math.round(ally.hp) : 'DEAD';
      let wepName = WEAPONS[player.weapon].name;
      let ammoStr = player.ammo[player.weapon] === Infinity ? 'INF' : player.ammo[player.weapon];
      if (player.reloading) ammoStr = 'RELOAD';
      ammoEl.textContent = wepName + ' ' + ammoStr;
      scrapEl.textContent = player.scrap;
    }

    // ---- Render ----
    function render() {
      ctx.fillStyle = '#111118';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = 'rgba(68, 170, 68, 0.04)';
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += 30) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y < H; y += 30) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      if (gameState === 'menu' || gameState === 'classSelect') {
        renderMenuBg();
        return;
      }

      // ---- Base ----
      let baseAlpha = 0.1 + 0.05 * Math.sin(performance.now() * 0.003);
      let baseGrad = ctx.createRadialGradient(base.x, base.y, 0, base.x, base.y, BASE_RADIUS * 2.5);
      baseGrad.addColorStop(0, 'rgba(68, 170, 68, ' + baseAlpha + ')');
      baseGrad.addColorStop(1, 'rgba(68, 170, 68, 0)');
      ctx.fillStyle = baseGrad;
      ctx.beginPath();
      ctx.arc(base.x, base.y, BASE_RADIUS * 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#1a3a1a';
      ctx.strokeStyle = '#4a4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(base.x, base.y, BASE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Base HP bar
      let baseHpFrac = base.hp / base.maxHp;
      ctx.fillStyle = '#222';
      ctx.fillRect(base.x - 20, base.y - BASE_RADIUS - 8, 40, 4);
      ctx.fillStyle = baseHpFrac > 0.5 ? '#4a4' : baseHpFrac > 0.25 ? '#aa4' : '#a44';
      ctx.fillRect(base.x - 20, base.y - BASE_RADIUS - 8, 40 * baseHpFrac, 4);

      // Base icon
      ctx.strokeStyle = '#4a4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(base.x - 10, base.y); ctx.lineTo(base.x + 10, base.y);
      ctx.moveTo(base.x, base.y - 10); ctx.lineTo(base.x, base.y + 10);
      ctx.stroke();

      // ---- Barricades ----
      barricades.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.angle);
        let hpFrac = b.hp / b.maxHp;
        ctx.fillStyle = 'rgb(' + Math.round(100 + 60 * hpFrac) + ',' + Math.round(70 + 40 * hpFrac) + ',30)';
        ctx.strokeStyle = '#864';
        ctx.lineWidth = 1;
        ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);
        ctx.strokeRect(-b.w / 2, -b.h / 2, b.w, b.h);
        if (hpFrac < 0.6) {
          ctx.strokeStyle = '#432';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-b.w * 0.3, -b.h * 0.3);
          ctx.lineTo(b.w * 0.1, b.h * 0.2);
          ctx.stroke();
        }
        ctx.restore();
      });

      // ---- Turrets ----
      turrets.forEach(t => {
        ctx.fillStyle = '#556';
        ctx.beginPath();
        ctx.arc(t.x, t.y, TURRET_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#88a';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.strokeStyle = '#aab';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x, t.y);
        ctx.lineTo(t.x + Math.cos(t.angle) * 10, t.y + Math.sin(t.angle) * 10);
        ctx.stroke();
        let hpFrac = t.hp / t.maxHp;
        ctx.fillStyle = '#222';
        ctx.fillRect(t.x - 6, t.y - TURRET_RADIUS - 5, 12, 2);
        ctx.fillStyle = '#88a';
        ctx.fillRect(t.x - 6, t.y - TURRET_RADIUS - 5, 12 * hpFrac, 2);
      });

      // ---- Scrap drops ----
      scrapDrops.forEach(s => {
        let blink = s.timer < 3 ? (Math.sin(performance.now() * 0.02) > 0 ? 1 : 0.3) : 1;
        ctx.fillStyle = 'rgba(200, 180, 60, ' + blink + ')';
        ctx.beginPath();
        ctx.moveTo(s.x, s.y - 4);
        ctx.lineTo(s.x + 4, s.y);
        ctx.lineTo(s.x, s.y + 4);
        ctx.lineTo(s.x - 4, s.y);
        ctx.closePath();
        ctx.fill();
      });

      // ---- Zombies ----
      zombies.forEach(z => {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(z.x + 2, z.y + 3, z.radius * 0.8, z.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = z.color;
        ctx.shadowColor = z.color;
        ctx.shadowBlur = z.type === 'boss' ? 10 : 4;
        ctx.beginPath();
        ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        let lookAngle = Math.atan2(base.y - z.y, base.x - z.x);
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(z.x + Math.cos(lookAngle - 0.3) * z.radius * 0.4, z.y + Math.sin(lookAngle - 0.3) * z.radius * 0.4, 1.5, 0, Math.PI * 2);
        ctx.arc(z.x + Math.cos(lookAngle + 0.3) * z.radius * 0.4, z.y + Math.sin(lookAngle + 0.3) * z.radius * 0.4, 1.5, 0, Math.PI * 2);
        ctx.fill();

        if (z.hp < z.maxHp) {
          let frac = z.hp / z.maxHp;
          ctx.fillStyle = '#222';
          ctx.fillRect(z.x - z.radius, z.y - z.radius - 5, z.radius * 2, 2);
          ctx.fillStyle = frac > 0.5 ? '#4a4' : frac > 0.25 ? '#aa4' : '#a44';
          ctx.fillRect(z.x - z.radius, z.y - z.radius - 5, z.radius * 2 * frac, 2);
        }
      });

      // ---- Players ----
      function drawPlayer(p, color, outlineColor) {
        if (!p.alive) return;

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(p.x + 2, p.y + 3, PLAYER_RADIUS * 0.8, PLAYER_RADIUS * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = color;
        ctx.shadowColor = outlineColor;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + Math.cos(p.angle) * 14, p.y + Math.sin(p.angle) * 14);
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        let icon = p.class === 'medic' ? '+' : p.class === 'engineer' ? '#' : '*';
        ctx.fillText(icon, p.x, p.y);

        let hpFrac = p.hp / p.maxHp;
        ctx.fillStyle = '#222';
        ctx.fillRect(p.x - 10, p.y - PLAYER_RADIUS - 6, 20, 3);
        ctx.fillStyle = hpFrac > 0.5 ? '#4a4' : hpFrac > 0.25 ? '#aa4' : '#a44';
        ctx.fillRect(p.x - 10, p.y - PLAYER_RADIUS - 6, 20 * hpFrac, 3);

        if (p.invulnTimer > 0 && Math.sin(performance.now() * 0.03) > 0) {
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, PLAYER_RADIUS + 3, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (p.reloading) {
          let prog = 1 - (p.reloadTimer / WEAPONS[p.weapon].reloadTime);
          ctx.strokeStyle = '#ff8';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, PLAYER_RADIUS + 5, -Math.PI / 2, -Math.PI / 2 + prog * Math.PI * 2);
          ctx.stroke();
        }

        if (p.abilityCooldown > 0) {
          let maxCD = p.class === 'medic' ? 8 : p.class === 'engineer' ? 12 : 6;
          let prog = 1 - (p.abilityCooldown / maxCD);
          ctx.strokeStyle = 'rgba(100,200,255,0.4)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, PLAYER_RADIUS + 7, -Math.PI / 2, -Math.PI / 2 + prog * Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillStyle = outlineColor;
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(p.isAI ? 'ALLY' : 'YOU', p.x, p.y + PLAYER_RADIUS + 12);
      }

      drawPlayer(player, '#224', '#48f');
      drawPlayer(ally, '#422', '#f84');

      // ---- Bullets ----
      bullets.forEach(b => {
        ctx.fillStyle = b.owner === 'player' ? '#8cf' : b.owner === 'ally' ? '#fc8' : '#ff8';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // ---- Grenades ----
      grenades.forEach(g => {
        let flash = Math.sin(performance.now() * 0.02) > 0;
        ctx.fillStyle = flash ? '#f44' : '#a22';
        ctx.beginPath();
        ctx.arc(g.x, g.y, GRENADE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#f88';
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // ---- Particles ----
      particles.forEach(p => {
        let alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // ---- Heal effects ----
      healEffects.forEach(h => {
        let alpha = h.timer / 0.6;
        let size = 12 * (1 - alpha * 0.5);
        ctx.strokeStyle = 'rgba(100, 255, 100, ' + alpha + ')';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(h.x - size, h.y); ctx.lineTo(h.x + size, h.y);
        ctx.moveTo(h.x, h.y - size); ctx.lineTo(h.x, h.y + size);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(100, 255, 100, ' + (alpha * 0.4) + ')';
        ctx.beginPath();
        ctx.arc(h.x, h.y, size * 1.5, 0, Math.PI * 2);
        ctx.stroke();
      });

      // ---- Wave announcement ----
      if (betweenWaves && gameState === 'playing') {
        ctx.fillStyle = '#4a4';
        ctx.shadowColor = '#4a4';
        ctx.shadowBlur = 10;
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('WAVE ' + (wave + 1) + ' INCOMING...', W / 2, 30);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#888';
        ctx.font = '11px Courier New';
        ctx.fillText('Stand near base to revive fallen ally', W / 2, 50);
      }

      // ---- Crosshair ----
      if (gameState === 'playing' && player.alive) {
        ctx.strokeStyle = 'rgba(68, 170, 68, 0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(mouseX - 8, mouseY); ctx.lineTo(mouseX - 3, mouseY);
        ctx.moveTo(mouseX + 3, mouseY); ctx.lineTo(mouseX + 8, mouseY);
        ctx.moveTo(mouseX, mouseY - 8); ctx.lineTo(mouseX, mouseY - 3);
        ctx.moveTo(mouseX, mouseY + 3); ctx.lineTo(mouseX, mouseY + 8);
        ctx.stroke();
      }

      // ---- HUD on canvas ----
      if (gameState === 'playing') {
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        let weapons = ['pistol', 'shotgun', 'rifle'];
        weapons.forEach((w, idx) => {
          let selected = player.weapon === w;
          ctx.fillStyle = selected ? '#4a4' : '#555';
          let label = (idx + 1) + ':' + WEAPONS[w].name;
          if (WEAPONS[w].maxAmmo !== Infinity) label += '(' + player.ammo[w] + ')';
          ctx.fillText(label, 8, H - 30 + idx * 12);
        });

        ctx.fillStyle = player.abilityCooldown > 0 ? '#555' : '#4af';
        let abilityName = player.class === 'medic' ? 'Q:Heal' : player.class === 'engineer' ? 'Q:Turret' : 'Q:Grenade';
        if (player.abilityCooldown > 0) abilityName += ' (' + Math.ceil(player.abilityCooldown) + 's)';
        ctx.fillText(abilityName, 8, H - 42);

        ctx.fillStyle = player.scrap >= BARRICADE_COST ? '#cc8' : '#666';
        ctx.fillText('E:Barricade (' + BARRICADE_COST + ' scrap)', 150, H - 6);

        ctx.fillStyle = '#4a4';
        ctx.textAlign = 'right';
        ctx.font = 'bold 11px Courier New';
        ctx.fillText('Zombies: ' + zombies.length, W - 8, H - 6);
      }
    }

    // Menu background
    function renderMenuBg() {
      let t = performance.now() * 0.001;
      for (let i = 0; i < 8; i++) {
        let a = (i / 8) * Math.PI * 2 + t * 0.2;
        let x = W / 2 + Math.cos(a) * 140;
        let y = H / 2 + Math.sin(a) * 90;
        ctx.fillStyle = '#4a4';
        ctx.shadowColor = '#4a4';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(x, y, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        let ea = Math.atan2(H/2 - y, W/2 - x);
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(x + Math.cos(ea-0.3)*3, y + Math.sin(ea-0.3)*3, 1.2, 0, Math.PI*2);
        ctx.arc(x + Math.cos(ea+0.3)*3, y + Math.sin(ea+0.3)*3, 1.2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.fillStyle = '#1a3a1a';
      ctx.strokeStyle = '#4a4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(W/2, H/2, BASE_RADIUS, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.strokeStyle = '#4a4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(W/2-10, H/2); ctx.lineTo(W/2+10, H/2);
      ctx.moveTo(W/2, H/2-10); ctx.lineTo(W/2, H/2+10);
      ctx.stroke();
    }

    // ---- Game Loop ----
    function loop(time) {
      let dt = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;

      update(dt);
      render();

      window.gameData = { gameState, score, wave: wave || 0 };

      animFrame = requestAnimationFrame(loop);
    }

    lastTime = performance.now();
    animFrame = requestAnimationFrame(loop);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Joust</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f86; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 102, 0.5); }
    h1 { color: #f86; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f86; }
    canvas {
      border: 2px solid #f86;
      box-shadow: 0 0 20px rgba(255, 136, 102, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f86;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>JOUST</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Wave: <span id="wave">1</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">JOUST</h2>
      <p id="overlayText">Press SPACE to flap &mdash; Arrow keys to move</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const waveEl = document.getElementById('wave');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const GRAVITY = 0.28;
    const FLAP_POWER = -4.8;
    const MAX_FALL = 5;
    const MOVE_ACCEL = 0.4;
    const MAX_SPEED_X = 3.5;
    const FRICTION = 0.92;
    const PLAYER_W = 28;
    const PLAYER_H = 24;
    const MOUNT_W = 32;
    const MOUNT_H = 16;
    const LANCE_LEN = 14;
    const EGG_SIZE = 10;
    const EGG_HATCH_TIME = 300; // frames until egg hatches
    const LAVA_H = 20;

    // --- Platforms ---
    const platforms = [
      // Bottom ground (lava edges with walkable middle)
      { x: 0, y: H - LAVA_H, w: 130, h: 6 },
      { x: W - 130, y: H - LAVA_H, w: 130, h: 6 },
      // Middle platforms
      { x: 170, y: 380, w: 260, h: 6 },
      // Upper platforms
      { x: 0, y: 270, w: 160, h: 6 },
      { x: W - 160, y: 270, w: 160, h: 6 },
      // Top platform
      { x: 200, y: 170, w: 200, h: 6 },
    ];

    // --- State ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let wave = 1;
    let lives = 3;
    let player, enemies, eggs, particles, keys, frameCount;
    let waveTransition = 0;
    let respawnTimer = 0;
    let playerInvincible = 0;

    function createPlayer() {
      return {
        x: W / 2,
        y: 350,
        vx: 0,
        vy: 0,
        facing: 1, // 1 right, -1 left
        flapFrame: 0,
        onGround: false,
        alive: true
      };
    }

    function createEnemy(type, x, y) {
      // type: 0 = Bounder (easy), 1 = Hunter (medium), 2 = Shadow Lord (hard)
      const speeds = [1.5, 2.2, 3.0];
      const flapPowers = [-3.5, -4.2, -5.0];
      const colors = ['#f44', '#ff0', '#a4f'];
      const mountColors = ['#844', '#884', '#648'];
      const points = [500, 750, 1000];
      return {
        x: x,
        y: y,
        vx: (Math.random() > 0.5 ? 1 : -1) * speeds[type] * (0.7 + Math.random() * 0.3),
        vy: -2,
        facing: 1,
        flapFrame: 0,
        onGround: false,
        type: type,
        maxSpeed: speeds[type],
        flapPower: flapPowers[type],
        color: colors[type],
        mountColor: mountColors[type],
        points: points[type],
        flapTimer: 0,
        flapInterval: type === 0 ? 50 : type === 1 ? 35 : 25,
        alive: true,
        targetY: Math.random() * (H * 0.6),
        aiTimer: 0
      };
    }

    function createEgg(x, y, points) {
      return {
        x: x,
        y: y,
        vy: -2,
        points: points,
        timer: 0,
        onGround: false,
        hatching: false
      };
    }

    function spawnWaveEnemies() {
      enemies = [];
      // More enemies with higher waves, mix of types
      const count = Math.min(2 + wave, 8);
      for (let i = 0; i < count; i++) {
        let type = 0;
        if (wave >= 3 && Math.random() < 0.4) type = 1;
        if (wave >= 5 && Math.random() < 0.3) type = 2;
        if (wave >= 7 && Math.random() < 0.5) type = Math.random() < 0.5 ? 2 : 1;

        // Spawn at random positions along top portion
        const spawnX = Math.random() * (W - 60) + 30;
        const spawnY = 30 + Math.random() * 80;
        enemies.push(createEnemy(type, spawnX, spawnY));
      }
    }

    function init() {
      score = 0;
      wave = 1;
      lives = 3;
      scoreEl.textContent = '0';
      waveEl.textContent = '1';
      livesEl.textContent = '3';
      player = createPlayer();
      enemies = [];
      eggs = [];
      particles = [];
      keys = {};
      frameCount = 0;
      waveTransition = 0;
      respawnTimer = 0;
      playerInvincible = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'JOUST';
      overlayText.textContent = 'Press SPACE to flap \u2014 Arrow keys to move';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      spawnWaveEnemies();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Wave ${wave} \u2014 Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Physics helpers ---
    function applyGravity(entity) {
      entity.vy += GRAVITY;
      if (entity.vy > MAX_FALL) entity.vy = MAX_FALL;
    }

    function wrapX(entity, hw) {
      if (entity.x < -hw) entity.x = W + hw;
      if (entity.x > W + hw) entity.x = -hw;
    }

    function collidePlatforms(entity, halfW, fullH) {
      entity.onGround = false;
      for (const p of platforms) {
        // Check if entity is within platform X range
        if (entity.x + halfW > p.x && entity.x - halfW < p.x + p.w) {
          // Landing on top (was above, now at or below platform)
          const entityBottom = entity.y + fullH;
          const prevBottom = entityBottom - entity.vy;
          if (entity.vy >= 0 && entityBottom >= p.y && prevBottom <= p.y + 8) {
            entity.y = p.y - fullH;
            entity.vy = 0;
            entity.onGround = true;
            return;
          }
        }
      }

      // Lava floor
      if (entity.y + fullH > H - LAVA_H + 4) {
        return 'lava';
      }
    }

    // --- Update ---
    function update() {
      frameCount++;

      // Wave transition
      if (waveTransition > 0) {
        waveTransition--;
        if (waveTransition === 0) {
          spawnWaveEnemies();
        }
        updateParticles();
        updateEggs();
        return;
      }

      // Player respawn
      if (respawnTimer > 0) {
        respawnTimer--;
        if (respawnTimer === 0) {
          player = createPlayer();
          player.alive = true;
          playerInvincible = 120; // 2 seconds of invincibility
        }
        updateEnemies();
        updateEggs();
        updateParticles();
        return;
      }

      if (playerInvincible > 0) playerInvincible--;

      // Player input
      if (player.alive) {
        if (keys['ArrowLeft']) {
          player.vx -= MOVE_ACCEL;
          player.facing = -1;
        }
        if (keys['ArrowRight']) {
          player.vx += MOVE_ACCEL;
          player.facing = 1;
        }
        player.vx = Math.max(-MAX_SPEED_X, Math.min(MAX_SPEED_X, player.vx));
        if (!keys['ArrowLeft'] && !keys['ArrowRight']) {
          player.vx *= FRICTION;
          if (Math.abs(player.vx) < 0.1) player.vx = 0;
        }

        // Apply physics
        applyGravity(player);
        player.x += player.vx;
        player.y += player.vy;

        // Wing flap animation
        if (player.flapFrame > 0) player.flapFrame--;

        // Wrap around screen
        wrapX(player, MOUNT_W / 2);

        // Platform collision
        const platResult = collidePlatforms(player, MOUNT_W / 2, PLAYER_H + MOUNT_H / 2);
        if (platResult === 'lava') {
          killPlayer();
          return;
        }

        // Ceiling bounce
        if (player.y < 0) {
          player.y = 0;
          player.vy = Math.abs(player.vy) * 0.3;
        }
      }

      // Update enemies
      updateEnemies();

      // Check player-enemy collisions
      if (player.alive && playerInvincible <= 0) {
        checkCombat();
      }

      // Update eggs
      updateEggs();

      // Collect eggs
      if (player.alive) {
        collectEggs();
      }

      // Update particles
      updateParticles();

      // Check wave completion
      if (enemies.length === 0 && eggs.length === 0 && waveTransition === 0) {
        wave++;
        waveEl.textContent = wave;
        waveTransition = 90; // 1.5 second pause
        // Bonus points for completing wave
        score += 200;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerVX: player.vx,
        playerVY: player.vy,
        enemies: enemies.map(e => ({ x: e.x, y: e.y, type: e.type })),
        eggs: eggs.map(e => ({ x: e.x, y: e.y })),
        wave: wave,
        lives: lives
      };
    }

    function updateEnemies() {
      for (const e of enemies) {
        if (!e.alive) continue;

        // AI behavior
        e.aiTimer++;

        // Flap periodically (more often when below target height)
        e.flapTimer++;
        let shouldFlap = e.flapTimer >= e.flapInterval;
        if (e.y > e.targetY + 50) shouldFlap = shouldFlap || e.flapTimer >= e.flapInterval * 0.6;

        if (shouldFlap) {
          e.vy = e.flapPower;
          e.flapFrame = 8;
          e.flapTimer = 0;
        }

        // Change direction based on AI type
        if (e.aiTimer % 60 === 0) {
          e.targetY = 60 + Math.random() * (H * 0.5);
          // Hunters and Shadow Lords target the player
          if (e.type >= 1 && player.alive) {
            const dx = player.x - e.x;
            // Wrap-aware targeting
            const wrapDx = dx > W / 2 ? dx - W : dx < -W / 2 ? dx + W : dx;
            e.vx = Math.sign(wrapDx) * e.maxSpeed * (0.7 + Math.random() * 0.3);
            e.facing = Math.sign(e.vx) || 1;
          } else {
            // Bounder: random movement
            if (Math.random() < 0.4) {
              e.vx = (Math.random() > 0.5 ? 1 : -1) * e.maxSpeed * (0.5 + Math.random() * 0.5);
              e.facing = Math.sign(e.vx) || 1;
            }
          }
        }

        // Apply physics
        applyGravity(e);
        e.x += e.vx;
        e.y += e.vy;

        if (e.flapFrame > 0) e.flapFrame--;

        // Wrap around
        wrapX(e, MOUNT_W / 2);

        // Platform collision
        const platResult = collidePlatforms(e, MOUNT_W / 2, PLAYER_H + MOUNT_H / 2);
        if (platResult === 'lava') {
          // Enemy falls in lava - just respawn them up top
          e.y = -20;
          e.vy = 0;
        }

        // Ceiling bounce
        if (e.y < 0) {
          e.y = 0;
          e.vy = Math.abs(e.vy) * 0.3;
        }

        // Random direction shifts for bounder type
        if (e.type === 0 && e.onGround && Math.random() < 0.02) {
          e.vx = -e.vx;
          e.facing = Math.sign(e.vx) || 1;
        }
      }
    }

    function checkCombat() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.alive) continue;

        // Collision check between player and enemy
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < (MOUNT_W * 0.8)) {
          // The higher rider wins (lower Y = higher on screen)
          const playerBottom = player.y + PLAYER_H;
          const enemyBottom = e.y + PLAYER_H;

          if (playerBottom < enemyBottom - 4) {
            // Player wins - they're higher
            defeatEnemy(i);
          } else if (enemyBottom < playerBottom - 4) {
            // Enemy wins
            killPlayer();
            return;
          } else {
            // Same height - bounce apart
            player.vx = -Math.sign(dx || 1) * 3;
            player.vy = -3;
            e.vx = Math.sign(dx || 1) * 3;
            e.vy = -3;
          }
        }
      }
    }

    function defeatEnemy(index) {
      const e = enemies[index];
      // Spawn egg
      eggs.push(createEgg(e.x, e.y, e.points));
      // Points
      score += e.points;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      // Particles
      spawnParticles(e.x, e.y, e.color, 12);
      // Player bounce
      player.vy = -4;
      // Remove enemy
      enemies.splice(index, 1);
    }

    function killPlayer() {
      if (!player.alive) return;
      player.alive = false;
      spawnParticles(player.x, player.y, '#f86', 15);
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        // Delay game over slightly so particles show
        setTimeout(() => {
          if (gameState === 'playing') gameOver();
        }, 500);
      } else {
        respawnTimer = 90; // 1.5 second respawn delay
      }
    }

    function updateEggs() {
      for (let i = eggs.length - 1; i >= 0; i--) {
        const egg = eggs[i];

        if (!egg.onGround) {
          // Fall
          egg.vy += GRAVITY * 0.5;
          egg.y += egg.vy;

          // Land on platforms or ground
          for (const p of platforms) {
            if (egg.x + EGG_SIZE / 2 > p.x && egg.x - EGG_SIZE / 2 < p.x + p.w) {
              if (egg.vy >= 0 && egg.y + EGG_SIZE >= p.y) {
                egg.y = p.y - EGG_SIZE;
                egg.vy = 0;
                egg.onGround = true;
                break;
              }
            }
          }
          // Ground
          if (egg.y + EGG_SIZE > H - LAVA_H) {
            egg.y = H - LAVA_H - EGG_SIZE;
            egg.vy = 0;
            egg.onGround = true;
          }
        }

        if (egg.onGround) {
          egg.timer++;
          // Hatch into new enemy
          if (egg.timer >= EGG_HATCH_TIME) {
            // Hatches into a Bounder
            const newEnemy = createEnemy(0, egg.x, egg.y - PLAYER_H);
            newEnemy.vy = -4;
            enemies.push(newEnemy);
            spawnParticles(egg.x, egg.y, '#ff0', 8);
            eggs.splice(i, 1);
          }
        }
      }
    }

    function collectEggs() {
      for (let i = eggs.length - 1; i >= 0; i--) {
        const egg = eggs[i];
        const dx = player.x - egg.x;
        const dy = (player.y + PLAYER_H / 2) - (egg.y + EGG_SIZE / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < MOUNT_W / 2 + EGG_SIZE / 2) {
          // Collect
          score += 250;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
          spawnParticles(egg.x, egg.y, '#0f0', 6);
          eggs.splice(i, 1);
        }
      }
    }

    // --- Particles ---
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6 - 2,
          life: 30 + Math.random() * 20,
          color: color,
          size: 2 + Math.random() * 3
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- Drawing ---
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Stars
      ctx.fillStyle = '#334';
      for (let i = 0; i < 40; i++) {
        const sx = (i * 137 + 50) % W;
        const sy = (i * 97 + 30) % (H - 60);
        ctx.fillRect(sx, sy, 1, 1);
      }

      // Lava at bottom
      drawLava();

      // Platforms
      drawPlatforms();

      // Eggs
      drawEggs();

      // Enemies
      for (const e of enemies) {
        if (e.alive) drawKnight(e.x, e.y, e.vx, e.facing, e.flapFrame, e.color, e.mountColor);
      }

      // Player
      if (player.alive && (playerInvincible <= 0 || frameCount % 6 < 3)) {
        drawKnight(player.x, player.y, player.vx, player.facing, player.flapFrame, '#f86', '#a64');
      }

      // Particles
      drawParticles();

      // Wave transition text
      if (waveTransition > 0) {
        ctx.save();
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#f86';
        ctx.shadowColor = '#f86';
        ctx.shadowBlur = 20;
        const alpha = Math.min(1, waveTransition / 30);
        ctx.globalAlpha = alpha;
        ctx.fillText(`WAVE ${wave}`, W / 2, H / 2 - 20);
        ctx.font = '16px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.shadowBlur = 0;
        ctx.fillText('Get ready!', W / 2, H / 2 + 15);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // Respawn text
      if (respawnTimer > 0 && lives > 0) {
        ctx.save();
        ctx.font = '18px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#f86';
        ctx.shadowColor = '#f86';
        ctx.shadowBlur = 10;
        ctx.fillText(`Lives: ${lives}`, W / 2, H / 2);
        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawKnight(x, y, vx, facing, flapFrame, bodyColor, mountColor) {
      ctx.save();

      // Mount body (ostrich/buzzard)
      ctx.fillStyle = mountColor;
      ctx.shadowColor = mountColor;
      ctx.shadowBlur = 6;

      // Body oval
      const bx = x - MOUNT_W / 2;
      const by = y + PLAYER_H * 0.4;
      ctx.beginPath();
      ctx.ellipse(x, by + MOUNT_H / 2, MOUNT_W / 2, MOUNT_H / 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.shadowBlur = 4;
      const wingAngle = flapFrame > 0 ? -0.6 : 0.3;
      const wingLen = 16;
      // Left wing
      ctx.beginPath();
      ctx.moveTo(x - 6, by + 4);
      ctx.lineTo(x - 6 - wingLen * Math.cos(wingAngle), by + 4 - wingLen * Math.sin(wingAngle));
      ctx.lineTo(x - 2, by + 8);
      ctx.closePath();
      ctx.fill();
      // Right wing
      ctx.beginPath();
      ctx.moveTo(x + 6, by + 4);
      ctx.lineTo(x + 6 + wingLen * Math.cos(wingAngle), by + 4 - wingLen * Math.sin(wingAngle));
      ctx.lineTo(x + 2, by + 8);
      ctx.closePath();
      ctx.fill();

      // Legs (dangling when airborne, tucked when on ground)
      ctx.strokeStyle = mountColor;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 0;
      const legLen = 8;
      ctx.beginPath();
      ctx.moveTo(x - 5, by + MOUNT_H / 2);
      ctx.lineTo(x - 5, by + MOUNT_H / 2 + legLen);
      ctx.moveTo(x + 5, by + MOUNT_H / 2);
      ctx.lineTo(x + 5, by + MOUNT_H / 2 + legLen);
      ctx.stroke();

      // Rider body
      ctx.fillStyle = bodyColor;
      ctx.shadowColor = bodyColor;
      ctx.shadowBlur = 8;
      ctx.fillRect(x - 6, y, 12, PLAYER_H * 0.5);

      // Rider head (helmet)
      ctx.beginPath();
      ctx.arc(x, y - 2, 7, 0, Math.PI * 2);
      ctx.fill();

      // Lance
      ctx.strokeStyle = '#fff';
      ctx.shadowColor = bodyColor;
      ctx.shadowBlur = 6;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x, y + 4);
      ctx.lineTo(x + facing * (MOUNT_W / 2 + LANCE_LEN), y + 2);
      ctx.stroke();

      // Lance tip
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x + facing * (MOUNT_W / 2 + LANCE_LEN), y + 2, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawPlatforms() {
      ctx.shadowColor = '#0f3460';
      ctx.shadowBlur = 8;
      for (const p of platforms) {
        // Platform surface
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        // Platform highlight
        ctx.fillStyle = '#1a5a90';
        ctx.fillRect(p.x, p.y, p.w, 2);
        // Platform underside texture
        ctx.fillStyle = '#0a2240';
        ctx.fillRect(p.x, p.y + p.h, p.w, 3);
      }
      ctx.shadowBlur = 0;
    }

    function drawLava() {
      const lavaY = H - LAVA_H;
      // Lava glow
      const grad = ctx.createLinearGradient(0, lavaY - 10, 0, H);
      grad.addColorStop(0, 'rgba(255, 60, 0, 0)');
      grad.addColorStop(0.3, 'rgba(255, 60, 0, 0.2)');
      grad.addColorStop(1, 'rgba(255, 60, 0, 0.8)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, lavaY - 10, W, LAVA_H + 10);

      // Lava surface waves
      ctx.fillStyle = '#f40';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 10;
      for (let x = 0; x < W; x += 20) {
        const waveOffset = Math.sin((x + frameCount * 2) * 0.05) * 3;
        ctx.fillRect(x, lavaY + waveOffset, 18, LAVA_H - waveOffset);
      }
      // Bright highlights
      ctx.fillStyle = '#fa0';
      ctx.shadowBlur = 4;
      for (let x = 0; x < W; x += 40) {
        const waveOffset = Math.sin((x + frameCount * 2) * 0.05) * 3;
        ctx.fillRect(x + 5, lavaY + waveOffset + 2, 8, 3);
      }
      ctx.shadowBlur = 0;
    }

    function drawEggs() {
      for (const egg of eggs) {
        const hatchProgress = egg.timer / EGG_HATCH_TIME;
        ctx.save();

        // Egg glow when near hatching
        if (hatchProgress > 0.5) {
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 8 + hatchProgress * 12;
        }

        // Egg body
        ctx.fillStyle = hatchProgress > 0.7 ? '#ff0' : hatchProgress > 0.4 ? '#ffa' : '#fff';
        ctx.beginPath();
        ctx.ellipse(egg.x, egg.y + EGG_SIZE / 2, EGG_SIZE / 2, EGG_SIZE * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Shake when about to hatch
        if (hatchProgress > 0.7) {
          const shake = Math.sin(frameCount * 0.5) * 2 * hatchProgress;
          ctx.fillStyle = '#fa0';
          ctx.beginPath();
          ctx.ellipse(egg.x + shake, egg.y + EGG_SIZE / 2, EGG_SIZE / 2 - 1, EGG_SIZE * 0.5, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life / 50);
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // --- Input ---
    function handleFlap() {
      if (player.alive) {
        player.vy = FLAP_POWER;
        player.flapFrame = 8;
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        if (e.key === ' ') handleFlap();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
        if (e.key === ' ' && !e.repeat) {
          handleFlap();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

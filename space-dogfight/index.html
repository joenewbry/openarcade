<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Dogfight</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4af; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 255, 0.5); }
    h1 { color: #4af; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 170, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #4af; }
    canvas {
      border: 2px solid #4af;
      box-shadow: 0 0 20px rgba(68, 170, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4af;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
      cursor: pointer;
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(68,170,255,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; white-space: pre-line; }
    .overlay .controls { font-size: 0.75rem; color: #668; margin-top: 14px; line-height: 1.6; }
    .overlay .controls span { color: #4af; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SPACE DOGFIGHT</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span> kills</div>
    <div>Time: <span id="timer">3:00</span></div>
    <div>Leader: <span id="leader">---</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;pointer-events:auto;">
      <h2 id="overlayTitle">SPACE DOGFIGHT</h2>
      <p id="overlayText">Click to Launch</p>
      <div class="controls">
        <span>LEFT/RIGHT</span> Rotate &nbsp; <span>UP</span> Thrust &nbsp; <span>SPACE</span> Laser<br>
        <span>Z</span> Missile &nbsp; <span>X</span> Shield &nbsp; <span>C</span> Boost
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 600;
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const leaderEl = document.getElementById('leader');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'menu';
    let score = 0;

    // --- Constants ---
    const MATCH_TIME = 180;
    const TURN_SPEED = 0.065;
    const THRUST = 0.12;
    const MAX_SPEED = 3.5;
    const FRICTION = 0.992;
    const LASER_SPEED = 7;
    const LASER_LIFE = 55;
    const LASER_DMG = 12;
    const LASER_COOLDOWN = 10;
    const MISSILE_SPEED = 4;
    const MISSILE_TURN = 0.045;
    const MISSILE_LIFE = 180;
    const MISSILE_DMG = 40;
    const MAX_MISSILES = 5;
    const MISSILE_RELOAD = 300;
    const SHIELD_MAX = 100;
    const SHIELD_REGEN = 0.06;
    const SHIELD_DRAIN = 0.8;
    const SHIELD_ABSORB = 0.7;
    const BOOST_MAX = 100;
    const BOOST_DRAIN = 1.2;
    const BOOST_REGEN = 0.15;
    const BOOST_MULT = 2.2;
    const SHIP_HP = 100;
    const RESPAWN_TIME = 120;
    const SHIP_RADIUS = 10;
    const NUM_ASTEROIDS = 8;
    const NUM_STARS = 120;

    const SHIP_COLORS = ['#4af', '#f44', '#4f4', '#fa4'];
    const SHIP_NAMES = ['PLAYER', 'RED AI', 'GRN AI', 'GLD AI'];

    // --- State ---
    let ships = [];
    let lasers = [];
    let missiles = [];
    let asteroids = [];
    let particles = [];
    let explosions = [];
    let stars = [];
    let timeLeft = MATCH_TIME;
    let frameTick = 0;
    let keys = {};

    // --- Starfield ---
    function initStars() {
      stars = [];
      for (let i = 0; i < NUM_STARS; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: Math.random() * 1.8 + 0.3,
          brightness: Math.random() * 0.5 + 0.3
        });
      }
    }

    // --- Ship ---
    function createShip(id, isPlayer) {
      return {
        id, isPlayer,
        x: 100 + Math.random() * (W - 200),
        y: 100 + Math.random() * (H - 200),
        vx: 0, vy: 0,
        angle: Math.random() * Math.PI * 2,
        hp: SHIP_HP,
        alive: true,
        respawnTimer: 0,
        kills: 0,
        shield: SHIELD_MAX,
        shielding: false,
        boost: BOOST_MAX,
        boosting: false,
        missiles: MAX_MISSILES,
        missileReload: 0,
        laserCooldown: 0,
        thrustOn: false,
        // AI
        aiTarget: null,
        aiMissileTimer: 60 + Math.random() * 120,
        aiThrust: false,
        aiShoot: false,
        aiMissile: false,
        aiShield: false,
        aiBoost: false,
        aiTurnDir: 0
      };
    }

    // --- Asteroid ---
    function createAsteroid() {
      let r = 18 + Math.random() * 22;
      let verts = [];
      let n = 7 + Math.floor(Math.random() * 5);
      for (let i = 0; i < n; i++) {
        let a = (i / n) * Math.PI * 2;
        let d = r * (0.7 + Math.random() * 0.6);
        verts.push({ x: Math.cos(a) * d, y: Math.sin(a) * d });
      }
      return {
        x: Math.random() * W,
        y: Math.random() * H,
        vx: (Math.random() - 0.5) * 1.0,
        vy: (Math.random() - 0.5) * 1.0,
        r, rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.015,
        verts
      };
    }

    // --- Wrap ---
    function wrap(obj) {
      if (obj.x < -20) obj.x += W + 40;
      if (obj.x > W + 20) obj.x -= W + 40;
      if (obj.y < -20) obj.y += H + 40;
      if (obj.y > H + 20) obj.y -= H + 40;
    }

    function wrapDist(x1, y1, x2, y2) {
      let dx = x2 - x1;
      let dy = y2 - y1;
      if (dx > W / 2) dx -= W;
      if (dx < -W / 2) dx += W;
      if (dy > H / 2) dy -= H;
      if (dy < -H / 2) dy += H;
      return { dx, dy, dist: Math.sqrt(dx * dx + dy * dy) };
    }

    // --- Init ---
    function init() {
      ships = []; lasers = []; missiles = [];
      asteroids = []; particles = []; explosions = [];
      timeLeft = MATCH_TIME;
      frameTick = 0;
      score = 0;
      scoreEl.textContent = '0';
      timerEl.textContent = '3:00';
      leaderEl.textContent = '---';

      for (let i = 0; i < 4; i++) {
        ships.push(createShip(i, i === 0));
      }
      ships[0].x = 150; ships[0].y = 150; ships[0].angle = Math.PI * 0.25;
      ships[1].x = W - 150; ships[1].y = 150; ships[1].angle = Math.PI * 0.75;
      ships[2].x = 150; ships[2].y = H - 150; ships[2].angle = -Math.PI * 0.25;
      ships[3].x = W - 150; ships[3].y = H - 150; ships[3].angle = -Math.PI * 0.75;

      for (let i = 0; i < NUM_ASTEROIDS; i++) {
        asteroids.push(createAsteroid());
      }
      initStars();
    }

    // --- Particles ---
    function spawnParticles(x, y, color, count, speed, life) {
      for (let i = 0; i < count; i++) {
        let a = Math.random() * Math.PI * 2;
        let s = Math.random() * speed;
        particles.push({
          x, y,
          vx: Math.cos(a) * s, vy: Math.sin(a) * s,
          life: life * (0.5 + Math.random() * 0.5),
          maxLife: life, color,
          size: Math.random() * 3 + 1
        });
      }
    }

    function spawnExplosion(x, y, size) {
      explosions.push({ x, y, r: 0, maxR: size, life: 1 });
      spawnParticles(x, y, '#ff8', 20, 4, 40);
      spawnParticles(x, y, '#f84', 15, 3, 30);
      spawnParticles(x, y, '#fff', 5, 2, 20);
    }

    // --- Fire laser ---
    function fireLaser(ship) {
      if (ship.laserCooldown > 0) return;
      ship.laserCooldown = LASER_COOLDOWN;
      let cos = Math.cos(ship.angle), sin = Math.sin(ship.angle);
      lasers.push({
        x: ship.x + cos * 14, y: ship.y + sin * 14,
        vx: cos * LASER_SPEED + ship.vx * 0.3,
        vy: sin * LASER_SPEED + ship.vy * 0.3,
        life: LASER_LIFE, owner: ship.id,
        color: SHIP_COLORS[ship.id]
      });
    }

    // --- Fire missile ---
    function fireMissile(ship) {
      if (ship.missiles <= 0) return;
      ship.missiles--;
      let cos = Math.cos(ship.angle), sin = Math.sin(ship.angle);
      let target = null, minD = Infinity;
      for (let s of ships) {
        if (s.id === ship.id || !s.alive) continue;
        let d = wrapDist(ship.x, ship.y, s.x, s.y).dist;
        if (d < minD) { minD = d; target = s.id; }
      }
      missiles.push({
        x: ship.x + cos * 14, y: ship.y + sin * 14,
        vx: cos * MISSILE_SPEED * 0.5 + ship.vx * 0.5,
        vy: sin * MISSILE_SPEED * 0.5 + ship.vy * 0.5,
        angle: ship.angle, life: MISSILE_LIFE,
        owner: ship.id, target,
        color: SHIP_COLORS[ship.id]
      });
    }

    // --- AI Logic ---
    function updateAI(ship) {
      if (!ship.alive) return;

      let bestTarget = null, bestDist = Infinity;
      for (let s of ships) {
        if (s.id === ship.id || !s.alive) continue;
        let d = wrapDist(ship.x, ship.y, s.x, s.y).dist;
        if (d < bestDist) { bestDist = d; bestTarget = s; }
      }
      ship.aiTarget = bestTarget;
      ship.aiShoot = false;
      ship.aiMissile = false;
      ship.aiShield = false;
      ship.aiBoost = false;
      ship.aiThrust = false;
      ship.aiTurnDir = 0;

      if (!bestTarget) { ship.aiThrust = true; return; }

      let { dx, dy, dist } = wrapDist(ship.x, ship.y, bestTarget.x, bestTarget.y);

      // Lead target prediction
      let tHit = dist / LASER_SPEED;
      let predX = dx + (bestTarget.vx - ship.vx * 0.3) * tHit;
      let predY = dy + (bestTarget.vy - ship.vy * 0.3) * tHit;
      let targetAngle = Math.atan2(predY, predX);

      let angleDiff = targetAngle - ship.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

      // Turn
      if (angleDiff > 0.05) ship.aiTurnDir = 1;
      else if (angleDiff < -0.05) ship.aiTurnDir = -1;

      // Thrust logic
      if (dist > 150) ship.aiThrust = true;
      else if (dist < 80) ship.aiThrust = false;
      else ship.aiThrust = Math.abs(angleDiff) < 1.0;

      // Shoot if aimed
      if (Math.abs(angleDiff) < 0.3 && dist < 400) ship.aiShoot = true;

      // Missile
      ship.aiMissileTimer--;
      if (ship.aiMissileTimer <= 0 && ship.missiles > 0 && dist < 300 && dist > 60 && Math.abs(angleDiff) < 0.6) {
        ship.aiMissile = true;
        ship.aiMissileTimer = 90 + Math.random() * 60;
      }

      // Shield: react to incoming threats
      let threatened = false;
      for (let l of lasers) {
        if (l.owner === ship.id) continue;
        let ld = wrapDist(ship.x, ship.y, l.x, l.y);
        if (ld.dist < 60) {
          let ldot = (-ld.dx * l.vx + -ld.dy * l.vy);
          if (ldot > 0) { threatened = true; break; }
        }
      }
      for (let m of missiles) {
        if (m.owner === ship.id) continue;
        let md = wrapDist(ship.x, ship.y, m.x, m.y);
        if (md.dist < 100) { threatened = true; break; }
      }
      if (threatened && ship.shield > 20) ship.aiShield = true;

      // Boost if chasing far target
      if (dist > 250 && ship.boost > 40) ship.aiBoost = true;

      // Dodge asteroids
      for (let a of asteroids) {
        let ad = wrapDist(ship.x, ship.y, a.x, a.y);
        if (ad.dist < a.r + 40) {
          let avoidAngle = Math.atan2(-ad.dy, -ad.dx);
          let avoidDiff = avoidAngle - ship.angle;
          while (avoidDiff > Math.PI) avoidDiff -= Math.PI * 2;
          while (avoidDiff < -Math.PI) avoidDiff += Math.PI * 2;
          ship.aiTurnDir = avoidDiff > 0 ? 1 : -1;
          ship.aiThrust = true;
          break;
        }
      }
    }

    // --- Apply input ---
    function applyInput(ship) {
      if (!ship.alive) return;

      let turnDir = 0, thrust = false, shoot = false;
      let missile = false, shield = false, boost = false;

      if (ship.isPlayer) {
        turnDir = (keys['ArrowRight'] || keys['d'] ? 1 : 0) - (keys['ArrowLeft'] || keys['a'] ? 1 : 0);
        thrust = keys['ArrowUp'] || keys['w'];
        shoot = keys[' '];
        missile = keys['z'];
        shield = keys['x'];
        boost = keys['c'];
      } else {
        turnDir = ship.aiTurnDir;
        thrust = ship.aiThrust;
        shoot = ship.aiShoot;
        missile = ship.aiMissile;
        shield = ship.aiShield;
        boost = ship.aiBoost;
      }

      ship.angle += turnDir * TURN_SPEED;

      ship.thrustOn = thrust;
      let thrustPower = THRUST;
      ship.boosting = false;
      if (boost && ship.boost > 0) {
        thrustPower *= BOOST_MULT;
        ship.boost -= BOOST_DRAIN;
        ship.boosting = true;
        if (ship.boost < 0) ship.boost = 0;
      }

      if (thrust) {
        ship.vx += Math.cos(ship.angle) * thrustPower;
        ship.vy += Math.sin(ship.angle) * thrustPower;
      }

      let spd = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      let maxSpd = ship.boosting ? MAX_SPEED * 1.6 : MAX_SPEED;
      if (spd > maxSpd) {
        ship.vx *= maxSpd / spd;
        ship.vy *= maxSpd / spd;
      }
      ship.vx *= FRICTION;
      ship.vy *= FRICTION;

      ship.shielding = shield && ship.shield > 5;
      if (ship.shielding) {
        ship.shield -= SHIELD_DRAIN;
        if (ship.shield < 0) ship.shield = 0;
      } else {
        ship.shield = Math.min(SHIELD_MAX, ship.shield + SHIELD_REGEN);
      }

      if (!ship.boosting) {
        ship.boost = Math.min(BOOST_MAX, ship.boost + BOOST_REGEN);
      }

      if (ship.missiles < MAX_MISSILES) {
        ship.missileReload++;
        if (ship.missileReload >= MISSILE_RELOAD) {
          ship.missileReload = 0;
          ship.missiles++;
        }
      }

      if (ship.laserCooldown > 0) ship.laserCooldown--;

      if (shoot) fireLaser(ship);
      if (missile) {
        fireMissile(ship);
        if (ship.isPlayer) keys['z'] = false;
        else ship.aiMissile = false;
      }

      ship.x += ship.vx;
      ship.y += ship.vy;
      wrap(ship);
    }

    // --- Damage ---
    function damageShip(ship, dmg, attackerId) {
      if (!ship.alive) return;
      let actual = dmg;
      if (ship.shielding) {
        actual *= (1 - SHIELD_ABSORB);
        ship.shield -= dmg * 0.5;
        spawnParticles(ship.x, ship.y, '#8ef', 4, 2, 15);
      }
      ship.hp -= actual;
      if (ship.hp <= 0) {
        ship.hp = 0;
        ship.alive = false;
        ship.respawnTimer = RESPAWN_TIME;
        spawnExplosion(ship.x, ship.y, 40);
        if (attackerId !== undefined && attackerId !== ship.id) {
          ships[attackerId].kills++;
          if (attackerId === 0) {
            score = ships[0].kills;
            scoreEl.textContent = score;
          }
        }
      }
    }

    // --- Update ---
    function update() {
      if (gameState !== 'playing') return;
      frameTick++;

      // Timer
      if (frameTick % 60 === 0) {
        timeLeft--;
        let m = Math.floor(timeLeft / 60);
        let s = timeLeft % 60;
        timerEl.textContent = m + ':' + (s < 10 ? '0' : '') + s;
        if (timeLeft <= 0) { endMatch(); return; }
      }

      // Leader update
      if (frameTick % 30 === 0) {
        let best = ships.reduce((a, b) => a.kills > b.kills ? a : b);
        leaderEl.textContent = SHIP_NAMES[best.id] + ' (' + best.kills + ')';
      }

      // AI
      for (let s of ships) {
        if (!s.isPlayer) updateAI(s);
      }

      // Ships
      for (let s of ships) {
        if (s.alive) {
          applyInput(s);
          if (s.thrustOn && frameTick % 2 === 0) {
            let ex = s.x - Math.cos(s.angle) * 12;
            let ey = s.y - Math.sin(s.angle) * 12;
            spawnParticles(ex, ey, s.boosting ? '#ff8' : '#f84', 2, 2, 15);
          }
        } else {
          s.respawnTimer--;
          if (s.respawnTimer <= 0) {
            s.alive = true;
            s.hp = SHIP_HP;
            s.shield = SHIELD_MAX;
            s.boost = BOOST_MAX;
            s.x = 100 + Math.random() * (W - 200);
            s.y = 100 + Math.random() * (H - 200);
            s.vx = 0; s.vy = 0;
            spawnParticles(s.x, s.y, SHIP_COLORS[s.id], 15, 3, 25);
          }
        }
      }

      // Lasers
      for (let i = lasers.length - 1; i >= 0; i--) {
        let l = lasers[i];
        l.x += l.vx; l.y += l.vy;
        l.life--;
        wrap(l);
        if (l.life <= 0) { lasers.splice(i, 1); continue; }
        let hit = false;
        for (let s of ships) {
          if (s.id === l.owner || !s.alive) continue;
          if (wrapDist(l.x, l.y, s.x, s.y).dist < SHIP_RADIUS + 3) {
            damageShip(s, LASER_DMG, l.owner);
            spawnParticles(l.x, l.y, l.color, 5, 2, 12);
            hit = true; break;
          }
        }
        if (hit) { lasers.splice(i, 1); continue; }
        for (let a of asteroids) {
          if (wrapDist(l.x, l.y, a.x, a.y).dist < a.r) {
            spawnParticles(l.x, l.y, '#888', 3, 1.5, 10);
            hit = true; break;
          }
        }
        if (hit) lasers.splice(i, 1);
      }

      // Missiles
      for (let i = missiles.length - 1; i >= 0; i--) {
        let m = missiles[i];
        m.life--;
        if (m.life <= 0) {
          spawnParticles(m.x, m.y, '#ff8', 8, 2, 15);
          missiles.splice(i, 1); continue;
        }
        // Homing
        if (m.target !== null) {
          let t = ships[m.target];
          if (t && t.alive) {
            let d = wrapDist(m.x, m.y, t.x, t.y);
            let ta = Math.atan2(d.dy, d.dx);
            let diff = ta - m.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            if (diff > MISSILE_TURN) m.angle += MISSILE_TURN;
            else if (diff < -MISSILE_TURN) m.angle -= MISSILE_TURN;
            else m.angle = ta;
          }
        }
        m.vx = Math.cos(m.angle) * MISSILE_SPEED;
        m.vy = Math.sin(m.angle) * MISSILE_SPEED;
        m.x += m.vx; m.y += m.vy;
        wrap(m);
        if (frameTick % 2 === 0) spawnParticles(m.x, m.y, m.color, 1, 1, 12);
        let hit = false;
        for (let s of ships) {
          if (s.id === m.owner || !s.alive) continue;
          if (wrapDist(m.x, m.y, s.x, s.y).dist < SHIP_RADIUS + 5) {
            damageShip(s, MISSILE_DMG, m.owner);
            spawnExplosion(m.x, m.y, 25);
            hit = true; break;
          }
        }
        if (hit) { missiles.splice(i, 1); continue; }
        for (let a of asteroids) {
          if (wrapDist(m.x, m.y, a.x, a.y).dist < a.r) {
            spawnExplosion(m.x, m.y, 20);
            hit = true; break;
          }
        }
        if (hit) missiles.splice(i, 1);
      }

      // Asteroids
      for (let a of asteroids) {
        a.x += a.vx; a.y += a.vy;
        a.rot += a.rotSpeed;
        wrap(a);
        for (let s of ships) {
          if (!s.alive) continue;
          let d = wrapDist(a.x, a.y, s.x, s.y);
          if (d.dist < a.r + SHIP_RADIUS) {
            damageShip(s, 25, undefined);
            s.vx += (-d.dx / d.dist) * 3;
            s.vy += (-d.dy / d.dist) * 3;
            spawnParticles(s.x, s.y, '#888', 5, 2, 12);
          }
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.96; p.vy *= 0.96;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        let e = explosions[i];
        e.life -= 0.04;
        e.r = e.maxR * (1 - e.life);
        if (e.life <= 0) explosions.splice(i, 1);
      }
    }

    // --- Draw ---
    function drawShip(s) {
      if (!s.alive) return;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.angle);

      // Shield bubble
      if (s.shielding) {
        ctx.beginPath();
        ctx.arc(0, 0, SHIP_RADIUS + 6, 0, Math.PI * 2);
        ctx.strokeStyle = SHIP_COLORS[s.id] + '80';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = SHIP_COLORS[s.id] + '20';
        ctx.fill();
      }

      // Ship body
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.lineTo(-9, -8);
      ctx.lineTo(-6, 0);
      ctx.lineTo(-9, 8);
      ctx.closePath();
      ctx.fillStyle = SHIP_COLORS[s.id];
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 0.5;
      ctx.stroke();

      // Engine glow
      if (s.thrustOn) {
        let glow = (4 + Math.random() * 6) * (s.boosting ? 1.8 : 1);
        ctx.beginPath();
        ctx.moveTo(-7, -4);
        ctx.lineTo(-7 - glow, 0);
        ctx.lineTo(-7, 4);
        ctx.closePath();
        ctx.fillStyle = s.boosting ? '#ff4' : '#f84';
        ctx.fill();
      }

      ctx.restore();

      // HP bar
      if (s.hp < SHIP_HP) {
        let barW = 24, barH = 3;
        let bx = s.x - barW / 2, by = s.y - 18;
        ctx.fillStyle = '#333';
        ctx.fillRect(bx, by, barW, barH);
        let ratio = s.hp / SHIP_HP;
        ctx.fillStyle = ratio > 0.5 ? '#4f4' : ratio > 0.25 ? '#fa4' : '#f44';
        ctx.fillRect(bx, by, barW * ratio, barH);
      }

      // Name
      ctx.fillStyle = SHIP_COLORS[s.id];
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(SHIP_NAMES[s.id], s.x, s.y + 20);
    }

    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, W, H);

      // Stars
      for (let s of stars) {
        let fl = s.brightness + Math.sin(frameTick * 0.02 + s.x) * 0.15;
        ctx.fillStyle = 'rgba(200,220,255,' + fl + ')';
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      // Asteroids
      for (let a of asteroids) {
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(a.rot);
        ctx.beginPath();
        ctx.moveTo(a.verts[0].x, a.verts[0].y);
        for (let v = 1; v < a.verts.length; v++) ctx.lineTo(a.verts[v].x, a.verts[v].y);
        ctx.closePath();
        ctx.fillStyle = '#3a3a3a';
        ctx.fill();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }

      // Lasers
      ctx.shadowBlur = 0;
      for (let l of lasers) {
        let alpha = l.life / LASER_LIFE;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.moveTo(l.x, l.y);
        ctx.lineTo(l.x - l.vx * 3, l.y - l.vy * 3);
        ctx.strokeStyle = l.color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowColor = l.color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(l.x, l.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.shadowBlur = 0;
      }
      ctx.globalAlpha = 1;

      // Missiles
      for (let m of missiles) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(m.angle);
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fillStyle = m.color;
        ctx.shadowColor = m.color;
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // Particles
      for (let p of particles) {
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;

      // Explosions
      for (let e of explosions) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,200,80,' + (e.life * 0.4) + ')';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,120,40,' + (e.life * 0.6) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Ships
      for (let s of ships) drawShip(s);

      // HUD
      let p = ships[0];
      if (!p) return;
      let hudY = H - 12;
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';

      // Shield bar
      ctx.fillStyle = '#333';
      ctx.fillRect(10, hudY - 22, 80, 8);
      ctx.fillStyle = '#4af';
      ctx.fillRect(10, hudY - 22, 80 * (p.shield / SHIELD_MAX), 8);
      ctx.fillStyle = '#8cf';
      ctx.fillText('SHD', 94, hudY - 14);

      // Boost bar
      ctx.fillStyle = '#333';
      ctx.fillRect(10, hudY - 10, 80, 8);
      ctx.fillStyle = '#fa4';
      ctx.fillRect(10, hudY - 10, 80 * (p.boost / BOOST_MAX), 8);
      ctx.fillStyle = '#fc8';
      ctx.fillText('BST', 94, hudY - 2);

      // Missiles
      ctx.textAlign = 'right';
      ctx.fillStyle = '#f88';
      let msl = 'MSL: ';
      for (let i = 0; i < MAX_MISSILES; i++) msl += i < p.missiles ? '\u25C6' : '\u25C7';
      ctx.fillText(msl, W - 10, hudY - 14);

      // HP
      ctx.fillStyle = p.hp > 50 ? '#4f4' : p.hp > 25 ? '#fa4' : '#f44';
      ctx.fillText('HP: ' + Math.ceil(p.hp), W - 10, hudY - 2);

      // Respawn overlay
      if (!p.alive) {
        ctx.textAlign = 'center';
        ctx.font = '18px Courier New';
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 10;
        ctx.fillText('DESTROYED', W / 2, H / 2 - 10);
        ctx.shadowBlur = 0;
        ctx.font = '12px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Respawning in ' + Math.ceil(p.respawnTimer / 60) + '...', W / 2, H / 2 + 10);
      }

      // Scoreboard
      ctx.textAlign = 'right';
      ctx.font = '10px Courier New';
      let sorted = [...ships].sort((a, b) => b.kills - a.kills);
      for (let i = 0; i < sorted.length; i++) {
        ctx.fillStyle = SHIP_COLORS[sorted[i].id];
        ctx.fillText(SHIP_NAMES[sorted[i].id] + ': ' + sorted[i].kills, W - 10, 20 + i * 14);
      }
    }

    // --- End match ---
    function endMatch() {
      gameState = 'over';
      let sorted = [...ships].sort((a, b) => b.kills - a.kills);
      let winner = sorted[0];
      let rank = sorted.findIndex(s => s.id === 0) + 1;
      let places = ['1st', '2nd', '3rd', '4th'];

      overlayTitle.textContent = winner.id === 0 ? 'VICTORY!' : 'MATCH OVER';
      overlayTitle.style.color = winner.id === 0 ? '#4f4' : '#4af';
      let lines = places[rank - 1] + ' Place - ' + score + ' kills\n\n';
      for (let s of sorted) lines += SHIP_NAMES[s.id] + ': ' + s.kills + ' kills\n';
      lines += '\nClick to play again';
      overlayText.textContent = lines;
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
    }

    // --- Input ---
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });
    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
      keys[e.key] = false;
    });

    function startGame() {
      if (gameState === 'menu' || gameState === 'over') {
        gameState = 'playing';
        overlay.style.display = 'none';
        overlay.style.pointerEvents = 'none';
        init();
      }
    }

    canvas.addEventListener('click', startGame);
    overlay.addEventListener('click', startGame);

    // --- Loop ---
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    draw();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

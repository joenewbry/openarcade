<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spy Hunter</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #e86; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 136, 102, 0.5); }
    h1 { color: #e86; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 136, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e86; }
    canvas {
      border: 2px solid #e86;
      box-shadow: 0 0 20px rgba(238, 136, 102, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e86;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SPY HUNTER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:600px;">
      <h2 id="overlayTitle">SPY HUNTER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ── Constants ──────────────────────────────────────────────
    const ROAD_LEFT = 60;
    const ROAD_RIGHT = W - 60;
    const ROAD_W = ROAD_RIGHT - ROAD_LEFT;
    const NUM_LANES = 4;
    const LANE_W = ROAD_W / NUM_LANES;
    const PLAYER_W = 28;
    const PLAYER_H = 48;
    const BULLET_SPEED = 8;
    const MAX_BULLETS = 5;

    // Enemy types
    const ENEMY_TYPES = {
      roadLord: { color: '#f44', glowColor: '#f44', w: 28, h: 44, speed: 0.6, points: 100, hp: 2, label: 'Road Lord' },
      switchblade: { color: '#ff0', glowColor: '#ff0', w: 30, h: 42, speed: 0.8, points: 150, hp: 1, label: 'Switchblade' },
      enforcer: { color: '#f0f', glowColor: '#f0f', w: 26, h: 46, speed: 0.7, points: 200, hp: 1, label: 'Enforcer' },
    };

    const CIVILIAN_COLOR = '#4af';
    const CIVILIAN_GLOW = '#4af';

    // Power-up types
    const POWERUP_TYPES = {
      oil: { color: '#0f0', label: 'OIL', duration: 0 },
      smoke: { color: '#aaa', label: 'SMK', duration: 300 },
      missile: { color: '#f80', label: 'MSL', duration: 0 },
    };

    // ── Game state ────────────────────────────────────────────
    let score, best = 0, gameState;
    let player, bullets, enemies, civilians, powerups, oilSlicks, particles;
    let keys = {};
    let roadOffset, scrollSpeed, baseScrollSpeed;
    let frameCount, distScore;
    let spawnTimer, civilianTimer, powerupTimer;
    let activePowerup, powerupTimeLeft;
    let missileCount, oilCount;
    let enforcerBullets;

    // Road fork state
    let fork, forkTimer;

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SPY HUNTER';
      overlayText.textContent = 'Press SPACE to start';

      player = {
        x: W / 2 - PLAYER_W / 2,
        y: H - 100,
        lane: 1,
        invincible: 0,
      };
      bullets = [];
      enemies = [];
      civilians = [];
      powerups = [];
      oilSlicks = [];
      particles = [];
      enforcerBullets = [];
      roadOffset = 0;
      scrollSpeed = 3;
      baseScrollSpeed = 3;
      frameCount = 0;
      distScore = 0;
      spawnTimer = 0;
      civilianTimer = 0;
      powerupTimer = 0;
      activePowerup = null;
      powerupTimeLeft = 0;
      missileCount = 0;
      oilCount = 0;
      fork = null;
      forkTimer = 0;
      keys = {};

      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── Update ────────────────────────────────────────────────
    function update() {
      frameCount++;

      // Difficulty ramp: speed increases over time
      const difficulty = Math.min(frameCount / 7200, 1); // ramps over ~2 minutes
      scrollSpeed = baseScrollSpeed + difficulty * 3;

      // Player controls
      const playerSpeed = 4;
      if (keys['ArrowLeft']) player.x -= playerSpeed;
      if (keys['ArrowRight']) player.x += playerSpeed;
      if (keys['ArrowUp']) player.y -= 2;
      if (keys['ArrowDown']) player.y += 2;

      // Clamp to road
      player.x = Math.max(ROAD_LEFT + 4, Math.min(ROAD_RIGHT - PLAYER_W - 4, player.x));
      player.y = Math.max(H * 0.3, Math.min(H - PLAYER_H - 10, player.y));

      // Road scroll
      roadOffset = (roadOffset + scrollSpeed) % 40;

      // Distance score
      distScore += scrollSpeed * 0.1;
      if (Math.floor(distScore) > score - countEnemyScore()) {
        score = Math.floor(distScore) + countEnemyScore();
        scoreEl.textContent = score;
      }

      // Invincibility countdown
      if (player.invincible > 0) player.invincible--;

      // Active power-up timer
      if (activePowerup === 'smoke' && powerupTimeLeft > 0) {
        powerupTimeLeft--;
        if (powerupTimeLeft <= 0) activePowerup = null;
      }

      // ── Spawn enemies ──
      spawnTimer++;
      const spawnRate = Math.max(40, 100 - difficulty * 60);
      if (spawnTimer >= spawnRate) {
        spawnTimer = 0;
        spawnEnemy();
      }

      // ── Spawn civilians ──
      civilianTimer++;
      const civRate = Math.max(80, 180 - difficulty * 80);
      if (civilianTimer >= civRate) {
        civilianTimer = 0;
        spawnCivilian();
      }

      // ── Spawn power-ups ──
      powerupTimer++;
      if (powerupTimer >= 400) {
        powerupTimer = 0;
        spawnPowerup();
      }

      // ── Road forks ──
      forkTimer++;
      if (forkTimer > 600 && !fork && Math.random() < 0.003) {
        fork = {
          y: -200,
          side: Math.random() < 0.5 ? 'left' : 'right',
          active: true,
        };
        forkTimer = 0;
      }
      if (fork) {
        fork.y += scrollSpeed;
        if (fork.y > H + 300) fork = null;
      }

      // ── Update bullets ──
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        if (b.type === 'missile') {
          b.y -= BULLET_SPEED * 1.5;
        } else {
          b.y -= BULLET_SPEED;
        }
        if (b.y < -20) { bullets.splice(i, 1); continue; }

        // Bullet vs enemies
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (rectCollide(b.x - 2, b.y, 4, 10, e.x, e.y, e.w, e.h)) {
            e.hp--;
            if (e.hp <= 0) {
              spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, ENEMY_TYPES[e.type].color);
              addScore(ENEMY_TYPES[e.type].points);
              enemies.splice(j, 1);
            } else {
              spawnSpark(e.x + e.w / 2, e.y + e.h / 4);
            }
            bullets.splice(i, 1);
            hit = true;
            break;
          }
        }
        if (hit) continue;

        // Bullet vs civilians -- penalty!
        for (let j = civilians.length - 1; j >= 0; j--) {
          const c = civilians[j];
          if (rectCollide(b.x - 2, b.y, 4, 10, c.x, c.y, c.w, c.h)) {
            spawnExplosion(c.x + c.w / 2, c.y + c.h / 2, '#4af');
            addScore(-200);
            civilians.splice(j, 1);
            bullets.splice(i, 1);
            break;
          }
        }
      }

      // ── Update enemies ──
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const typeInfo = ENEMY_TYPES[e.type];

        // Move downward relative to scroll
        e.y += scrollSpeed * typeInfo.speed;

        // Type-specific behavior
        if (e.type === 'roadLord') {
          // Track toward player laterally
          const dx = (player.x + PLAYER_W / 2) - (e.x + e.w / 2);
          e.x += Math.sign(dx) * 1.2;
        } else if (e.type === 'switchblade') {
          // Weave side to side
          e.x += Math.sin(frameCount * 0.06 + e.phase) * 2;
        } else if (e.type === 'enforcer') {
          // Shoot at player
          e.shootTimer++;
          if (e.shootTimer >= 80) {
            e.shootTimer = 0;
            if (e.y > 0 && e.y < H * 0.7) {
              enforcerBullets.push({
                x: e.x + e.w / 2,
                y: e.y + e.h,
                vy: 4,
              });
            }
          }
        }

        // Clamp enemies to road
        e.x = Math.max(ROAD_LEFT + 2, Math.min(ROAD_RIGHT - e.w - 2, e.x));

        // Remove if off screen
        if (e.y > H + 50) { enemies.splice(i, 1); continue; }

        // Check oil slick collision
        for (let oi = oilSlicks.length - 1; oi >= 0; oi--) {
          const o = oilSlicks[oi];
          if (rectCollide(e.x, e.y, e.w, e.h, o.x - 12, o.y - 12, 24, 24)) {
            // Spin out
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, typeInfo.color);
            addScore(typeInfo.points);
            enemies.splice(i, 1);
            oilSlicks.splice(oi, 1);
            break;
          }
        }

        // Collision with player
        if (i < enemies.length && player.invincible <= 0) {
          const e2 = enemies[i];
          if (e2 && rectCollide(player.x, player.y, PLAYER_W, PLAYER_H, e2.x, e2.y, e2.w, e2.h)) {
            if (activePowerup === 'smoke') {
              // Smoke screen protects
              continue;
            }
            spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#e86');
            gameOver();
            return;
          }
        }
      }

      // ── Update enforcer bullets ──
      for (let i = enforcerBullets.length - 1; i >= 0; i--) {
        enforcerBullets[i].y += enforcerBullets[i].vy;
        if (enforcerBullets[i].y > H + 10) { enforcerBullets.splice(i, 1); continue; }

        // Hit player
        if (player.invincible <= 0 && rectCollide(
          enforcerBullets[i].x - 2, enforcerBullets[i].y, 4, 8,
          player.x, player.y, PLAYER_W, PLAYER_H)) {
          if (activePowerup === 'smoke') {
            enforcerBullets.splice(i, 1);
            continue;
          }
          spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#e86');
          gameOver();
          return;
        }
      }

      // ── Update civilians ──
      for (let i = civilians.length - 1; i >= 0; i--) {
        const c = civilians[i];
        c.y += scrollSpeed * c.speed;
        if (c.y > H + 50) { civilians.splice(i, 1); continue; }

        // Collision with player = penalty + temporary invincibility
        if (player.invincible <= 0 && rectCollide(player.x, player.y, PLAYER_W, PLAYER_H, c.x, c.y, c.w, c.h)) {
          addScore(-100);
          spawnSpark(c.x + c.w / 2, c.y + c.h / 2);
          civilians.splice(i, 1);
          player.invincible = 30;
        }
      }

      // ── Update power-ups ──
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += scrollSpeed * 0.5;
        if (p.y > H + 20) { powerups.splice(i, 1); continue; }

        if (rectCollide(player.x, player.y, PLAYER_W, PLAYER_H, p.x - 12, p.y - 12, 24, 24)) {
          collectPowerup(p);
          powerups.splice(i, 1);
        }
      }

      // ── Update oil slicks ──
      for (let i = oilSlicks.length - 1; i >= 0; i--) {
        oilSlicks[i].y += scrollSpeed;
        if (oilSlicks[i].y > H + 30) oilSlicks.splice(i, 1);
      }

      // ── Update particles ──
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        enemies: enemies.map(e => ({ x: e.x, y: e.y, type: e.type })),
        civilians: civilians.map(c => ({ x: c.x, y: c.y })),
        scrollSpeed,
        missileCount,
        oilCount,
        activePowerup,
      };
    }

    let enemyScoreTotal = 0;
    function countEnemyScore() { return enemyScoreTotal; }
    function addScore(pts) {
      if (pts > 0) enemyScoreTotal += pts;
      score = Math.max(0, Math.floor(distScore) + enemyScoreTotal);
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function spawnEnemy() {
      const types = Object.keys(ENEMY_TYPES);
      // Weight toward easier enemies early on
      const difficulty = Math.min(frameCount / 7200, 1);
      let type;
      const r = Math.random();
      if (difficulty < 0.3) {
        type = r < 0.7 ? 'roadLord' : 'switchblade';
      } else if (difficulty < 0.6) {
        type = r < 0.4 ? 'roadLord' : r < 0.7 ? 'switchblade' : 'enforcer';
      } else {
        type = types[Math.floor(Math.random() * types.length)];
      }

      const info = ENEMY_TYPES[type];
      const lane = Math.floor(Math.random() * NUM_LANES);
      const lx = ROAD_LEFT + lane * LANE_W + (LANE_W - info.w) / 2;
      enemies.push({
        type,
        x: lx,
        y: -info.h - Math.random() * 60,
        w: info.w,
        h: info.h,
        hp: info.hp,
        phase: Math.random() * Math.PI * 2,
        shootTimer: Math.floor(Math.random() * 40),
      });
    }

    function spawnCivilian() {
      const w = 24;
      const h = 40;
      const lane = Math.floor(Math.random() * NUM_LANES);
      const lx = ROAD_LEFT + lane * LANE_W + (LANE_W - w) / 2;
      civilians.push({
        x: lx,
        y: -h - Math.random() * 40,
        w, h,
        speed: 0.3 + Math.random() * 0.3,
      });
    }

    function spawnPowerup() {
      const types = Object.keys(POWERUP_TYPES);
      const type = types[Math.floor(Math.random() * types.length)];
      const lane = Math.floor(Math.random() * NUM_LANES);
      const lx = ROAD_LEFT + lane * LANE_W + LANE_W / 2;
      powerups.push({
        type,
        x: lx,
        y: -20,
      });
    }

    function collectPowerup(p) {
      if (p.type === 'oil') {
        oilCount += 3;
      } else if (p.type === 'smoke') {
        activePowerup = 'smoke';
        powerupTimeLeft = POWERUP_TYPES.smoke.duration;
      } else if (p.type === 'missile') {
        missileCount += 3;
      }
      // Flash effect
      spawnSpark(p.x, p.y);
    }

    function fireWeapon() {
      if (bullets.length >= MAX_BULLETS) return;
      bullets.push({
        x: player.x + PLAYER_W / 2,
        y: player.y,
        type: 'bullet',
      });
    }

    function fireMissile() {
      if (missileCount <= 0) return;
      missileCount--;
      bullets.push({
        x: player.x + PLAYER_W / 2,
        y: player.y,
        type: 'missile',
      });
    }

    function dropOil() {
      if (oilCount <= 0) return;
      oilCount--;
      oilSlicks.push({
        x: player.x + PLAYER_W / 2,
        y: player.y + PLAYER_H + 5,
        life: 300,
      });
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 14; i++) {
        const ang = (Math.PI * 2 / 14) * i + Math.random() * 0.4;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 18 + Math.random() * 12,
          color,
        });
      }
    }

    function spawnSpark(x, y) {
      for (let i = 0; i < 6; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 10,
          color: '#fff',
        });
      }
    }

    function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // ── Draw ──────────────────────────────────────────────────
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grass / terrain edges
      ctx.fillStyle = '#0a2a0a';
      ctx.fillRect(0, 0, ROAD_LEFT, H);
      ctx.fillRect(ROAD_RIGHT, 0, W - ROAD_RIGHT, H);

      // Road surface
      ctx.fillStyle = '#222';
      ctx.fillRect(ROAD_LEFT, 0, ROAD_W, H);

      // Road edges
      ctx.fillStyle = '#e86';
      ctx.shadowColor = '#e86';
      ctx.shadowBlur = 4;
      ctx.fillRect(ROAD_LEFT - 2, 0, 3, H);
      ctx.fillRect(ROAD_RIGHT - 1, 0, 3, H);
      ctx.shadowBlur = 0;

      // Lane dashes
      ctx.fillStyle = '#555';
      for (let lane = 1; lane < NUM_LANES; lane++) {
        const lx = ROAD_LEFT + lane * LANE_W;
        for (let dy = -40 + (roadOffset % 40); dy < H; dy += 40) {
          ctx.fillRect(lx - 1, dy, 2, 20);
        }
      }

      // Road fork
      if (fork) {
        drawFork();
      }

      // Oil slicks
      oilSlicks.forEach(o => {
        ctx.fillStyle = 'rgba(0, 200, 0, 0.6)';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.ellipse(o.x, o.y, 14, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Power-ups
      powerups.forEach(p => {
        const info = POWERUP_TYPES[p.type];
        const pulse = Math.sin(frameCount * 0.08) * 0.3 + 0.7;
        ctx.fillStyle = info.color;
        ctx.shadowColor = info.color;
        ctx.shadowBlur = 12 * pulse;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#1a1a2e';
        ctx.font = 'bold 8px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(info.label, p.x, p.y);
      });

      // Civilians
      civilians.forEach(c => {
        drawCivilian(c);
      });

      // Enemies
      enemies.forEach(e => {
        drawEnemy(e);
      });

      // Enforcer bullets
      ctx.fillStyle = '#f0f';
      ctx.shadowColor = '#f0f';
      ctx.shadowBlur = 6;
      enforcerBullets.forEach(b => {
        ctx.fillRect(b.x - 2, b.y, 4, 8);
      });
      ctx.shadowBlur = 0;

      // Player bullets
      bullets.forEach(b => {
        if (b.type === 'missile') {
          ctx.fillStyle = '#f80';
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(b.x, b.y - 6);
          ctx.lineTo(b.x - 3, b.y + 6);
          ctx.lineTo(b.x + 3, b.y + 6);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = '#e86';
          ctx.shadowColor = '#e86';
          ctx.shadowBlur = 6;
          ctx.fillRect(b.x - 1.5, b.y, 3, 10);
        }
      });
      ctx.shadowBlur = 0;

      // Player car
      drawPlayerCar();

      // Particles
      particles.forEach(p => {
        const alpha = Math.max(0, p.life / 30);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // Smoke screen effect
      if (activePowerup === 'smoke' && powerupTimeLeft > 0) {
        const smokeAlpha = Math.min(0.3, powerupTimeLeft / 300 * 0.3);
        ctx.fillStyle = `rgba(180, 180, 180, ${smokeAlpha})`;
        ctx.fillRect(player.x - 20, player.y - 15, PLAYER_W + 40, PLAYER_H + 30);
      }

      // HUD - weapon indicators
      drawHUD();
    }

    function drawPlayerCar() {
      const x = player.x, y = player.y;
      const blinkOff = player.invincible > 0 && Math.floor(player.invincible / 3) % 2 === 0;
      if (blinkOff) return;

      ctx.shadowColor = '#e86';
      ctx.shadowBlur = 10;

      // Car body
      ctx.fillStyle = '#e86';
      ctx.fillRect(x + 4, y + 6, PLAYER_W - 8, PLAYER_H - 10);

      // Hood / front
      ctx.fillStyle = '#d75';
      ctx.beginPath();
      ctx.moveTo(x + 6, y + 6);
      ctx.lineTo(x + PLAYER_W / 2, y);
      ctx.lineTo(x + PLAYER_W - 6, y + 6);
      ctx.closePath();
      ctx.fill();

      // Rear
      ctx.fillStyle = '#c64';
      ctx.fillRect(x + 5, y + PLAYER_H - 8, PLAYER_W - 10, 8);

      // Windshield
      ctx.fillStyle = '#4af';
      ctx.fillRect(x + 8, y + 14, PLAYER_W - 16, 8);

      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(x + 1, y + 8, 4, 10);
      ctx.fillRect(x + PLAYER_W - 5, y + 8, 4, 10);
      ctx.fillRect(x + 1, y + PLAYER_H - 14, 4, 10);
      ctx.fillRect(x + PLAYER_W - 5, y + PLAYER_H - 14, 4, 10);

      // Gun barrel
      ctx.fillStyle = '#aaa';
      ctx.fillRect(x + PLAYER_W / 2 - 1, y - 4, 2, 6);

      ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
      const info = ENEMY_TYPES[e.type];
      const x = e.x, y = e.y;

      ctx.shadowColor = info.glowColor;
      ctx.shadowBlur = 8;

      if (e.type === 'roadLord') {
        // Bulky armored car
        ctx.fillStyle = '#f44';
        ctx.fillRect(x + 2, y + 4, e.w - 4, e.h - 8);
        ctx.fillStyle = '#c22';
        ctx.fillRect(x + 4, y + e.h - 12, e.w - 8, 10);
        // Armor plate
        ctx.fillStyle = '#922';
        ctx.fillRect(x + 6, y + 6, e.w - 12, 10);
        // Wheels
        ctx.fillStyle = '#333';
        ctx.fillRect(x, y + 6, 3, 10);
        ctx.fillRect(x + e.w - 3, y + 6, 3, 10);
        ctx.fillRect(x, y + e.h - 14, 3, 10);
        ctx.fillRect(x + e.w - 3, y + e.h - 14, 3, 10);
        // HP indicator
        if (e.hp > 1) {
          ctx.fillStyle = '#ff0';
          ctx.fillRect(x + 4, y + 1, (e.w - 8) * (e.hp / info.hp), 2);
        }
      } else if (e.type === 'switchblade') {
        // Sleek car with blade extensions
        ctx.fillStyle = '#ff0';
        ctx.fillRect(x + 4, y + 4, e.w - 8, e.h - 8);
        ctx.fillStyle = '#cc0';
        ctx.fillRect(x + 6, y + 8, e.w - 12, e.h - 16);
        // Tire slashers (blades sticking out sides)
        ctx.fillStyle = '#fff';
        const bladePhase = Math.sin(frameCount * 0.15 + e.phase) * 4;
        ctx.fillRect(x - 4 + bladePhase, y + e.h / 2 - 1, 6, 2);
        ctx.fillRect(x + e.w - 2 - bladePhase, y + e.h / 2 - 1, 6, 2);
        // Wheels
        ctx.fillStyle = '#333';
        ctx.fillRect(x + 1, y + 6, 3, 8);
        ctx.fillRect(x + e.w - 4, y + 6, 3, 8);
        ctx.fillRect(x + 1, y + e.h - 14, 3, 8);
        ctx.fillRect(x + e.w - 4, y + e.h - 14, 3, 8);
      } else if (e.type === 'enforcer') {
        // Aggressive car with front-mounted gun
        ctx.fillStyle = '#f0f';
        ctx.fillRect(x + 3, y + 6, e.w - 6, e.h - 10);
        ctx.fillStyle = '#b0b';
        ctx.fillRect(x + 5, y + e.h - 14, e.w - 10, 12);
        // Gun turret
        ctx.fillStyle = '#aaa';
        ctx.fillRect(x + e.w / 2 - 2, y + e.h - 2, 4, 8);
        // Wheels
        ctx.fillStyle = '#333';
        ctx.fillRect(x, y + 8, 3, 8);
        ctx.fillRect(x + e.w - 3, y + 8, 3, 8);
        ctx.fillRect(x, y + e.h - 14, 3, 8);
        ctx.fillRect(x + e.w - 3, y + e.h - 14, 3, 8);
        // Warning flash
        if (e.shootTimer > 60) {
          ctx.fillStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(frameCount * 0.3) * 0.3})`;
          ctx.beginPath();
          ctx.arc(x + e.w / 2, y + e.h + 4, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.shadowBlur = 0;
    }

    function drawCivilian(c) {
      const x = c.x, y = c.y;
      ctx.shadowColor = CIVILIAN_GLOW;
      ctx.shadowBlur = 4;

      // Simple sedan shape
      ctx.fillStyle = '#4af';
      ctx.fillRect(x + 3, y + 4, c.w - 6, c.h - 8);
      ctx.fillStyle = '#38d';
      ctx.fillRect(x + 5, y + 8, c.w - 10, c.h - 16);

      // Windshield
      ctx.fillStyle = '#adf';
      ctx.fillRect(x + 6, y + 10, c.w - 12, 6);

      // Wheels
      ctx.fillStyle = '#333';
      ctx.fillRect(x + 1, y + 6, 3, 7);
      ctx.fillRect(x + c.w - 4, y + 6, 3, 7);
      ctx.fillRect(x + 1, y + c.h - 12, 3, 7);
      ctx.fillRect(x + c.w - 4, y + c.h - 12, 3, 7);

      ctx.shadowBlur = 0;
    }

    function drawFork() {
      if (!fork) return;
      const fy = fork.y;
      // Draw a branching road section
      ctx.fillStyle = '#333';
      if (fork.side === 'left') {
        ctx.beginPath();
        ctx.moveTo(ROAD_LEFT, fy);
        ctx.lineTo(ROAD_LEFT - 60, fy + 100);
        ctx.lineTo(ROAD_LEFT - 60, fy + 200);
        ctx.lineTo(ROAD_LEFT, fy + 300);
        ctx.closePath();
        ctx.fill();
        // Edge lines
        ctx.strokeStyle = '#e86';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ROAD_LEFT, fy);
        ctx.lineTo(ROAD_LEFT - 60, fy + 100);
        ctx.lineTo(ROAD_LEFT - 60, fy + 200);
        ctx.lineTo(ROAD_LEFT, fy + 300);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(ROAD_RIGHT, fy);
        ctx.lineTo(ROAD_RIGHT + 60, fy + 100);
        ctx.lineTo(ROAD_RIGHT + 60, fy + 200);
        ctx.lineTo(ROAD_RIGHT, fy + 300);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#e86';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ROAD_RIGHT, fy);
        ctx.lineTo(ROAD_RIGHT + 60, fy + 100);
        ctx.lineTo(ROAD_RIGHT + 60, fy + 200);
        ctx.lineTo(ROAD_RIGHT, fy + 300);
        ctx.stroke();
      }
    }

    function drawHUD() {
      // Bottom-left: weapon indicators
      const hudY = H - 28;
      ctx.font = '11px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      // Machine gun (always available)
      ctx.fillStyle = '#e86';
      ctx.fillText('GUN', ROAD_LEFT + 4, hudY);

      // Missiles
      ctx.fillStyle = missileCount > 0 ? '#f80' : '#444';
      ctx.fillText(`MSL:${missileCount}`, ROAD_LEFT + 50, hudY);

      // Oil
      ctx.fillStyle = oilCount > 0 ? '#0f0' : '#444';
      ctx.fillText(`OIL:${oilCount}`, ROAD_LEFT + 110, hudY);

      // Smoke
      if (activePowerup === 'smoke') {
        ctx.fillStyle = '#aaa';
        const pctLeft = powerupTimeLeft / POWERUP_TYPES.smoke.duration;
        ctx.fillText(`SMK:${Math.ceil(pctLeft * 100)}%`, ROAD_LEFT + 170, hudY);
      }

      // Speed indicator
      ctx.fillStyle = '#e86';
      ctx.textAlign = 'right';
      ctx.fillText(`${Math.floor(scrollSpeed * 30)}mph`, ROAD_RIGHT - 4, hudY);
    }

    // ── Input ─────────────────────────────────────────────────
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'x'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === ' ') fireWeapon();
        if (e.key === 'z' || e.key === 'Z') fireMissile();
        if (e.key === 'x' || e.key === 'X') dropOil();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

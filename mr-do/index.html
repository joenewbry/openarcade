<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mr. Do!</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #fa4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 170, 68, 0.5); }
    h1 { color: #fa4; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 170, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fa4; }
    canvas {
      border: 2px solid #fa4;
      box-shadow: 0 0 20px rgba(255, 170, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fa4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>MR. DO!</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">MR. DO!</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid dimensions
    const COLS = 15;
    const ROWS = 15;
    const CELL = W / COLS; // 32px

    // Tile types
    const DIRT = 0;
    const EMPTY = 1;
    const CHERRY = 2;
    const APPLE = 3;
    const BONUS = 4;

    let score, best = 0, gameState;
    let lives, level;
    let grid;
    let player;
    let monsters;
    let powerBall;
    let apples;
    let cherryGroups;
    let totalCherries, collectedCherries;
    let totalMonsters, killedMonsters;
    let bonusItem;
    let bonusTimer;
    let keys = {};
    let lastDir = { x: 0, y: -1 };
    let moveTimer = 0;
    const MOVE_INTERVAL = 7; // frames between moves
    let monsterMoveTimer = 0;
    const MONSTER_MOVE_INTERVAL = 12;
    let levelCompleteTimer = 0;
    let ballReturnTimer = 0;
    let frameCount = 0;

    // Cherry group positions (predefined clusters)
    function getCherryGroupPositions(cols, rows) {
      const groups = [];
      // Place 4-6 groups of 4 cherries each
      const numGroups = 4 + Math.min(level, 3);
      const used = new Set();

      for (let g = 0; g < numGroups; g++) {
        let attempts = 0;
        while (attempts < 100) {
          const cx = 2 + Math.floor(Math.random() * (cols - 4));
          const cy = 2 + Math.floor(Math.random() * (rows - 4));
          const key = cx + ',' + cy;
          if (used.has(key)) { attempts++; continue; }

          // 2x2 cluster
          const cells = [
            [cx, cy], [cx + 1, cy],
            [cx, cy + 1], [cx + 1, cy + 1]
          ];

          let valid = true;
          for (const [x, y] of cells) {
            const k = x + ',' + y;
            if (used.has(k) || x <= 0 || x >= cols - 1 || y <= 0 || y >= rows - 1) {
              valid = false;
              break;
            }
          }
          if (valid) {
            cells.forEach(([x, y]) => used.add(x + ',' + y));
            groups.push(cells);
            break;
          }
          attempts++;
        }
      }
      return groups;
    }

    function initLevel() {
      // Create grid filled with dirt
      grid = [];
      for (let y = 0; y < ROWS; y++) {
        grid[y] = [];
        for (let x = 0; x < COLS; x++) {
          grid[y][x] = DIRT;
        }
      }

      // Place cherries
      cherryGroups = getCherryGroupPositions(COLS, ROWS);
      totalCherries = 0;
      collectedCherries = 0;
      for (const group of cherryGroups) {
        for (const [cx, cy] of group) {
          grid[cy][cx] = CHERRY;
          totalCherries++;
        }
      }

      // Place apples (3-5)
      apples = [];
      const numApples = 3 + Math.min(level, 3);
      for (let i = 0; i < numApples; i++) {
        let ax, ay;
        let attempts = 0;
        do {
          ax = 1 + Math.floor(Math.random() * (COLS - 2));
          ay = 1 + Math.floor(Math.random() * (ROWS - 4));
          attempts++;
        } while ((grid[ay][ax] !== DIRT || (ax === Math.floor(COLS / 2) && ay === ROWS - 2)) && attempts < 100);

        if (attempts < 100) {
          grid[ay][ax] = APPLE;
          apples.push({ x: ax, y: ay, falling: false, fallSpeed: 0, settled: true, pixelY: ay * CELL });
        }
      }

      // Player starts at bottom center
      const px = Math.floor(COLS / 2);
      const py = ROWS - 2;
      player = { x: px, y: py, dir: { x: 0, y: -1 }, animFrame: 0 };
      grid[py][px] = EMPTY;
      // Clear a small area around player start
      grid[py - 1][px] = EMPTY;
      grid[py][px - 1] = EMPTY;
      grid[py][px + 1] = EMPTY;

      // Spawn monsters at top
      monsters = [];
      const numMonsters = 3 + Math.min(level * 2, 8);
      totalMonsters = numMonsters;
      killedMonsters = 0;
      for (let i = 0; i < numMonsters; i++) {
        const mx = 2 + Math.floor(Math.random() * (COLS - 4));
        const my = 1 + Math.floor(Math.random() * 3);
        // Clear path for monster
        grid[my][mx] = EMPTY;
        monsters.push({
          x: mx, y: my,
          alive: true,
          type: i < numMonsters / 2 ? 0 : 1, // 0=normal, 1=digger
          stunTimer: 0,
          color: i < numMonsters / 2 ? '#f55' : '#f0f'
        });
      }

      // Power ball
      powerBall = null;
      ballReturnTimer = 0;

      // Bonus
      bonusItem = null;
      bonusTimer = 300 + Math.floor(Math.random() * 300);

      moveTimer = 0;
      monsterMoveTimer = 0;
      levelCompleteTimer = 0;
      lastDir = { x: 0, y: -1 };
    }

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'MR. DO!';
      overlayText.textContent = 'Press SPACE to start';
      initLevel();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function nextLevel() {
      level++;
      initLevel();
      // Brief flash
      levelCompleteTimer = 60;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function isWalkable(x, y) {
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
      const tile = grid[y][x];
      return tile === EMPTY || tile === CHERRY || tile === BONUS;
    }

    function update() {
      frameCount++;

      // Level complete timer
      if (levelCompleteTimer > 0) {
        levelCompleteTimer--;
        if (levelCompleteTimer === 0) {
          // Level already advanced
        }
        return;
      }

      // Player movement
      moveTimer++;
      if (moveTimer >= MOVE_INTERVAL) {
        moveTimer = 0;
        let dx = 0, dy = 0;
        if (keys['ArrowLeft']) { dx = -1; }
        else if (keys['ArrowRight']) { dx = 1; }
        else if (keys['ArrowUp']) { dy = -1; }
        else if (keys['ArrowDown']) { dy = 1; }

        if (dx !== 0 || dy !== 0) {
          lastDir = { x: dx, y: dy };
          player.dir = { x: dx, y: dy };
          player.animFrame = (player.animFrame + 1) % 4;

          const nx = player.x + dx;
          const ny = player.y + dy;

          if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
            const tile = grid[ny][nx];

            // Can't walk into apples
            if (tile === APPLE) {
              // Try to push apple
              const apx = nx + dx;
              const apy = ny + dy;
              // Apples can't be pushed, player just blocked
            } else {
              // Dig through dirt
              if (tile === DIRT) {
                grid[ny][nx] = EMPTY;
              }

              // Collect cherry
              if (tile === CHERRY) {
                grid[ny][nx] = EMPTY;
                score += 50;
                collectedCherries++;
                scoreEl.textContent = score;

                // Check if all cherries collected
                if (collectedCherries >= totalCherries) {
                  score += 500; // Level bonus
                  scoreEl.textContent = score;
                  nextLevel();
                  return;
                }
              }

              // Collect bonus
              if (tile === BONUS) {
                grid[ny][nx] = EMPTY;
                score += 500;
                scoreEl.textContent = score;
                bonusItem = null;
              }

              player.x = nx;
              player.y = ny;
            }
          }
        }
      }

      // Update apples - check for unsupported apples
      for (const apple of apples) {
        if (!apple.settled) continue;

        const ax = apple.x;
        const ay = apple.y;

        // Check if tile below is empty (dug out)
        if (ay + 1 < ROWS && grid[ay + 1][ax] === EMPTY) {
          // Check if the tile we're on is still APPLE
          if (grid[ay][ax] === APPLE) {
            apple.falling = true;
            apple.settled = false;
            apple.fallSpeed = 0;
            apple.pixelY = ay * CELL;
            grid[ay][ax] = EMPTY;
          }
        }
      }

      // Update falling apples
      for (let i = apples.length - 1; i >= 0; i--) {
        const apple = apples[i];
        if (!apple.falling) continue;

        apple.fallSpeed = Math.min(apple.fallSpeed + 0.5, 4);
        apple.pixelY += apple.fallSpeed;
        const newGridY = Math.floor(apple.pixelY / CELL);

        // Check if apple hits something below
        const nextY = newGridY + 1;
        if (nextY >= ROWS || (grid[nextY] && grid[nextY][apple.x] !== EMPTY)) {
          // Apple lands or breaks
          if (apple.fallSpeed > 2) {
            // Apple shatters after falling far
            apples.splice(i, 1);
            // Visual feedback handled in draw
          } else {
            // Apple settles
            apple.y = newGridY;
            apple.pixelY = newGridY * CELL;
            apple.falling = false;
            apple.settled = true;
            apple.fallSpeed = 0;
            if (newGridY >= 0 && newGridY < ROWS) {
              grid[newGridY][apple.x] = APPLE;
            }
          }
          continue;
        }

        apple.y = newGridY;

        // Check if apple hits player
        if (apple.x === player.x && newGridY === player.y) {
          apples.splice(i, 1);
          loseLife();
          return;
        }

        // Check if apple hits monster
        for (let m = monsters.length - 1; m >= 0; m--) {
          if (!monsters[m].alive) continue;
          if (apple.x === monsters[m].x && newGridY === monsters[m].y) {
            monsters[m].alive = false;
            killedMonsters++;
            score += 300;
            scoreEl.textContent = score;
            apples.splice(i, 1);
            if (killedMonsters >= totalMonsters) {
              score += 1000;
              scoreEl.textContent = score;
              nextLevel();
              return;
            }
            break;
          }
        }
      }

      // Power ball movement
      if (powerBall) {
        powerBall.x += powerBall.dx * 3;
        powerBall.y += powerBall.dy * 3;

        // Bounce off walls
        if (powerBall.x <= 0 || powerBall.x >= W) {
          powerBall.dx *= -1;
          powerBall.x = Math.max(0, Math.min(W, powerBall.x));
          powerBall.bounces++;
        }
        if (powerBall.y <= 0 || powerBall.y >= H) {
          powerBall.dy *= -1;
          powerBall.y = Math.max(0, Math.min(H, powerBall.y));
          powerBall.bounces++;
        }

        // Check monster hits
        for (let m = monsters.length - 1; m >= 0; m--) {
          if (!monsters[m].alive) continue;
          const mx = monsters[m].x * CELL + CELL / 2;
          const my = monsters[m].y * CELL + CELL / 2;
          const dist = Math.hypot(powerBall.x - mx, powerBall.y - my);
          if (dist < CELL * 0.8) {
            monsters[m].alive = false;
            killedMonsters++;
            const killScore = [100, 200, 400, 800];
            score += killScore[Math.min(killedMonsters - 1, 3)];
            scoreEl.textContent = score;
            powerBall = null;
            ballReturnTimer = 120;

            if (killedMonsters >= totalMonsters) {
              score += 1000;
              scoreEl.textContent = score;
              nextLevel();
              return;
            }
            break;
          }
        }

        // Ball expires after too many bounces
        if (powerBall && powerBall.bounces > 8) {
          powerBall = null;
          ballReturnTimer = 120;
        }
      }

      // Ball return timer
      if (ballReturnTimer > 0) {
        ballReturnTimer--;
      }

      // Monster movement
      monsterMoveTimer++;
      const monsterSpeed = Math.max(6, MONSTER_MOVE_INTERVAL - level);
      if (monsterMoveTimer >= monsterSpeed) {
        monsterMoveTimer = 0;
        for (const monster of monsters) {
          if (!monster.alive) continue;
          if (monster.stunTimer > 0) {
            monster.stunTimer--;
            continue;
          }

          // Simple AI: move toward player through tunnels
          const dx = player.x - monster.x;
          const dy = player.y - monster.y;

          // Possible moves
          const moves = [];
          const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];

          for (const [mx, my] of dirs) {
            const nx = monster.x + mx;
            const ny = monster.y + my;
            if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;

            const tile = grid[ny][nx];
            // Normal monsters only move through empty space; diggers can dig
            if (tile === EMPTY || tile === CHERRY || tile === BONUS ||
                (monster.type === 1 && tile === DIRT)) {
              // Prefer moves toward player
              const distToPlayer = Math.abs(nx - player.x) + Math.abs(ny - player.y);
              moves.push({ x: mx, y: my, dist: distToPlayer, nx, ny });
            }
          }

          if (moves.length > 0) {
            // Sort by distance to player, with some randomness
            moves.sort((a, b) => a.dist - b.dist);

            // 70% chance to pick best move, 30% random
            let chosen;
            if (Math.random() < 0.7) {
              chosen = moves[0];
            } else {
              chosen = moves[Math.floor(Math.random() * moves.length)];
            }

            // If digger, clear dirt
            if (monster.type === 1 && grid[chosen.ny][chosen.nx] === DIRT) {
              grid[chosen.ny][chosen.nx] = EMPTY;
            }

            // Don't walk into apples
            if (grid[chosen.ny][chosen.nx] !== APPLE) {
              monster.x = chosen.nx;
              monster.y = chosen.ny;
            }
          }

          // Check collision with player
          if (monster.x === player.x && monster.y === player.y) {
            loseLife();
            return;
          }
        }
      }

      // Check player-monster collision every frame
      for (const monster of monsters) {
        if (!monster.alive) continue;
        if (monster.x === player.x && monster.y === player.y) {
          loseLife();
          return;
        }
      }

      // Bonus item spawn
      if (!bonusItem) {
        bonusTimer--;
        if (bonusTimer <= 0) {
          // Spawn bonus at center
          const bx = Math.floor(COLS / 2);
          const by = Math.floor(ROWS / 2);
          if (grid[by][bx] === EMPTY || grid[by][bx] === DIRT) {
            grid[by][bx] = BONUS;
            bonusItem = { x: bx, y: by, timer: 300 };
          }
          bonusTimer = 600 + Math.floor(Math.random() * 300);
        }
      } else {
        bonusItem.timer--;
        if (bonusItem.timer <= 0) {
          if (grid[bonusItem.y][bonusItem.x] === BONUS) {
            grid[bonusItem.y][bonusItem.x] = EMPTY;
          }
          bonusItem = null;
        }
      }

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        monsters: monsters.filter(m => m.alive).map(m => ({ x: m.x, y: m.y })),
        cherries: collectedCherries + '/' + totalCherries,
        level: level,
        lives: lives
      };
    }

    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      } else {
        // Respawn player at bottom center
        player.x = Math.floor(COLS / 2);
        player.y = ROWS - 2;
        grid[player.y][player.x] = EMPTY;
        powerBall = null;
        ballReturnTimer = 0;
        // Brief invincibility via stun on nearby monsters
        for (const m of monsters) {
          if (m.alive) m.stunTimer = 30;
        }
      }
    }

    function throwBall() {
      if (powerBall || ballReturnTimer > 0) return;
      powerBall = {
        x: player.x * CELL + CELL / 2,
        y: player.y * CELL + CELL / 2,
        dx: lastDir.x || 0,
        dy: lastDir.y || -1,
        bounces: 0
      };
      // Ensure it has a direction
      if (powerBall.dx === 0 && powerBall.dy === 0) {
        powerBall.dy = -1;
      }
      // Normalize
      const mag = Math.hypot(powerBall.dx, powerBall.dy);
      powerBall.dx /= mag;
      powerBall.dy /= mag;
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const tile = grid[y][x];
          const px = x * CELL;
          const py = y * CELL;

          if (tile === DIRT) {
            // Dirt - earthy brown with subtle pattern
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(px, py, CELL, CELL);
            // Dots for texture
            ctx.fillStyle = '#5c4433';
            const dotSeed = (x * 7 + y * 13) % 5;
            ctx.fillRect(px + 4 + dotSeed * 3, py + 4 + dotSeed * 2, 2, 2);
            ctx.fillRect(px + 14 + dotSeed * 2, py + 12 + dotSeed, 2, 2);
            ctx.fillRect(px + 8, py + 20 + dotSeed, 2, 2);
            // Grid line
            ctx.strokeStyle = '#3a2a1c';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(px, py, CELL, CELL);
          } else if (tile === EMPTY) {
            // Tunnel/dug space
            ctx.fillStyle = '#0d0d1a';
            ctx.fillRect(px, py, CELL, CELL);
          } else if (tile === CHERRY) {
            // Cherry background
            ctx.fillStyle = '#0d0d1a';
            ctx.fillRect(px, py, CELL, CELL);
            // Cherry fruit
            drawCherry(px + CELL / 2, py + CELL / 2);
          } else if (tile === APPLE) {
            // Apple sits in dirt
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(px, py, CELL, CELL);
          } else if (tile === BONUS) {
            // Bonus background
            ctx.fillStyle = '#0d0d1a';
            ctx.fillRect(px, py, CELL, CELL);
            // Bonus diamond
            drawBonus(px + CELL / 2, py + CELL / 2);
          }
        }
      }

      // Draw apples on top
      for (const apple of apples) {
        if (apple.falling) {
          drawApple(apple.x * CELL + CELL / 2, apple.pixelY + CELL / 2);
        } else if (apple.settled) {
          drawApple(apple.x * CELL + CELL / 2, apple.y * CELL + CELL / 2);
        }
      }

      // Draw monsters
      for (const monster of monsters) {
        if (!monster.alive) continue;
        drawMonster(monster.x * CELL + CELL / 2, monster.y * CELL + CELL / 2, monster);
      }

      // Draw player
      drawPlayer(player.x * CELL + CELL / 2, player.y * CELL + CELL / 2);

      // Draw power ball
      if (powerBall) {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fa4';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(powerBall.x, powerBall.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Trail
        ctx.fillStyle = 'rgba(255, 170, 68, 0.3)';
        ctx.beginPath();
        ctx.arc(powerBall.x - powerBall.dx * 5, powerBall.y - powerBall.dy * 5, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Ball recharge indicator
      if (!powerBall && ballReturnTimer > 0) {
        const pct = 1 - ballReturnTimer / 120;
        ctx.strokeStyle = 'rgba(255, 170, 68, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x * CELL + CELL / 2, player.y * CELL - 4, 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
        ctx.stroke();
      }

      // Level info
      ctx.fillStyle = '#fa4';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Lv.' + level, 4, 14);

      // Cherries remaining
      ctx.textAlign = 'right';
      const remaining = totalCherries - collectedCherries;
      ctx.fillText('Cherries: ' + remaining, W - 4, 14);

      // Level complete flash
      if (levelCompleteTimer > 0) {
        const alpha = levelCompleteTimer / 60 * 0.6;
        ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fa4';
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fa4';
        ctx.shadowBlur = 20;
        ctx.fillText('LEVEL ' + level + '!', W / 2, H / 2);
        ctx.shadowBlur = 0;
      }
    }

    function drawCherry(cx, cy) {
      // Two small red circles with a stem
      ctx.fillStyle = '#f22';
      ctx.shadowColor = '#f22';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.arc(cx - 4, cy + 2, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 4, cy + 2, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Stem
      ctx.strokeStyle = '#0a0';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx - 4, cy - 3);
      ctx.quadraticCurveTo(cx, cy - 10, cx + 4, cy - 3);
      ctx.stroke();
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(cx - 5, cy, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawApple(cx, cy) {
      // Large round green apple
      ctx.fillStyle = '#2d2';
      ctx.shadowColor = '#2d2';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL / 2 - 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Darker border
      ctx.strokeStyle = '#1a1';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL / 2 - 2, 0, Math.PI * 2);
      ctx.stroke();
      // Stem
      ctx.strokeStyle = '#841';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy - CELL / 2 + 2);
      ctx.lineTo(cx, cy - CELL / 2 - 3);
      ctx.stroke();
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      ctx.arc(cx - 4, cy - 4, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBonus(cx, cy) {
      // Flashing diamond
      const pulse = Math.sin(frameCount * 0.15) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.moveTo(cx, cy - 10);
      ctx.lineTo(cx + 8, cy);
      ctx.lineTo(cx, cy + 10);
      ctx.lineTo(cx - 8, cy);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawMonster(cx, cy, monster) {
      const color = monster.color;
      // Body (ghost-like shape)
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      // Body
      ctx.beginPath();
      ctx.arc(cx, cy - 2, CELL / 2 - 3, Math.PI, 0);
      ctx.lineTo(cx + CELL / 2 - 3, cy + CELL / 2 - 4);
      // Wavy bottom
      const waveAmp = 3;
      const waveOff = (frameCount * 0.2) % (Math.PI * 2);
      for (let i = CELL - 6; i >= 0; i -= 4) {
        const wx = cx - CELL / 2 + 3 + i;
        const wy = cy + CELL / 2 - 4 + Math.sin(waveOff + i * 0.5) * waveAmp;
        ctx.lineTo(wx, wy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#111';
      const pupilDx = (player.x * CELL + CELL / 2 - cx) > 0 ? 1 : -1;
      const pupilDy = (player.y * CELL + CELL / 2 - cy) > 0 ? 1 : -1;
      ctx.beginPath();
      ctx.arc(cx - 4 + pupilDx, cy - 4 + pupilDy, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 4 + pupilDx, cy - 4 + pupilDy, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Digger indicator
      if (monster.type === 1) {
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy - 2, CELL / 2 - 1, Math.PI, 0);
        ctx.stroke();
      }
    }

    function drawPlayer(cx, cy) {
      // Clown-like character
      // Body (blue suit)
      ctx.fillStyle = '#44f';
      ctx.shadowColor = '#44f';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(cx, cy + 2, CELL / 2 - 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // White face
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx, cy - 3, 7, 0, Math.PI * 2);
      ctx.fill();

      // Red nose
      ctx.fillStyle = '#f22';
      ctx.beginPath();
      ctx.arc(cx, cy - 2, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(cx - 3, cy - 5, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 3, cy - 5, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Hat (red pointy hat)
      ctx.fillStyle = '#f44';
      ctx.beginPath();
      ctx.moveTo(cx - 7, cy - 9);
      ctx.lineTo(cx, cy - 18);
      ctx.lineTo(cx + 7, cy - 9);
      ctx.closePath();
      ctx.fill();

      // Hat pom-pom
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx, cy - 18, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Direction indicator (subtle)
      if (gameState === 'playing') {
        ctx.fillStyle = 'rgba(255, 170, 68, 0.4)';
        ctx.beginPath();
        ctx.arc(cx + lastDir.x * 8, cy + lastDir.y * 8 + 2, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ') {
          throwBall();
        }
        // Update lastDir immediately on keypress for responsiveness
        if (e.key === 'ArrowLeft') lastDir = { x: -1, y: 0 };
        if (e.key === 'ArrowRight') lastDir = { x: 1, y: 0 };
        if (e.key === 'ArrowUp') lastDir = { x: 0, y: -1 };
        if (e.key === 'ArrowDown') lastDir = { x: 0, y: 1 };
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crossy Road</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #fc4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 204, 68, 0.4); }
    h1 { color: #fc4; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 204, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fc4; }
    canvas {
      border: 2px solid #fc4;
      box-shadow: 0 0 20px rgba(255, 204, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fc4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CROSSY ROAD</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:600px;">
      <h2 id="overlayTitle">CROSSY ROAD</h2>
      <p id="overlayText">Press any arrow key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const ROW_H = 40;           // Height of each row
    const COLS = Math.floor(W / ROW_H); // Logical columns
    const COL_W = W / COLS;     // Width of each column
    const VISIBLE_ROWS = Math.ceil(H / ROW_H) + 2;

    // Row types
    const GRASS = 'grass';
    const ROAD = 'road';
    const RIVER = 'river';

    // Player constants
    const PLAYER_SIZE = 28;

    // Game state
    let score, best = 0, gameState;
    let player, rows, cameraY, furthestRow, deathTimer;
    let hopAnim, hopFrom, hopTo, hopProgress;
    let idleTimer, maxIdleFrames;

    // Seeded decoration for grass rows
    function hashRow(rowIndex) {
      let h = rowIndex * 2654435761;
      h = ((h >>> 16) ^ h) * 0x45d9f3b;
      h = ((h >>> 16) ^ h) * 0x45d9f3b;
      return (h >>> 16) ^ h;
    }

    function generateRow(rowIndex) {
      // Row 0 and first few rows are always grass (safe start)
      if (rowIndex <= 2) {
        return { type: GRASS, index: rowIndex, decorations: generateDecorations(rowIndex) };
      }

      // Progressive difficulty
      const difficulty = Math.min(rowIndex / 80, 1);
      const rand = (hashRow(rowIndex) % 1000) / 1000;

      // Determine row type based on patterns
      // Avoid too many of same type in a row by checking neighbors
      let type;
      if (rand < 0.35) {
        type = GRASS;
      } else if (rand < 0.70) {
        type = ROAD;
      } else {
        type = RIVER;
      }

      if (type === ROAD) {
        return generateRoadRow(rowIndex, difficulty);
      } else if (type === RIVER) {
        return generateRiverRow(rowIndex, difficulty);
      } else {
        return { type: GRASS, index: rowIndex, decorations: generateDecorations(rowIndex) };
      }
    }

    function generateDecorations(rowIndex) {
      const decos = [];
      const h = hashRow(rowIndex * 7 + 3);
      const count = (h % 4);
      for (let i = 0; i < count; i++) {
        const dh = hashRow(rowIndex * 13 + i * 37);
        const col = dh % COLS;
        const type = (dh >> 8) % 3; // 0=bush, 1=rock, 2=flower
        decos.push({ col, type });
      }
      return decos;
    }

    function generateRoadRow(rowIndex, difficulty) {
      const h = hashRow(rowIndex * 11 + 5);
      const dir = (h % 2 === 0) ? 1 : -1;
      const baseSpeed = 1 + difficulty * 2.5;
      const speed = baseSpeed * (0.7 + ((h >> 4) % 100) / 200);

      // Number of cars
      const carCount = 1 + Math.floor(difficulty * 2) + ((h >> 8) % 2);

      // Generate car positions spread across the row
      const cars = [];
      const totalWidth = W + 400; // extra space for offscreen cars
      for (let i = 0; i < carCount; i++) {
        const ch = hashRow(rowIndex * 23 + i * 41);
        const carW = 40 + (ch % 3) * 15; // 40, 55, or 70 wide
        const colorIdx = (ch >> 4) % 5;
        const colors = ['#e44', '#4ae', '#ea4', '#e4a', '#4ea'];
        const x = (i * (totalWidth / carCount)) + ((ch >> 8) % 40) - 200;
        cars.push({ x, w: carW, color: colors[colorIdx] });
      }

      return { type: ROAD, index: rowIndex, dir, speed, cars };
    }

    function generateRiverRow(rowIndex, difficulty) {
      const h = hashRow(rowIndex * 17 + 7);
      const dir = (h % 2 === 0) ? 1 : -1;
      const baseSpeed = 0.8 + difficulty * 1.5;
      const speed = baseSpeed * (0.6 + ((h >> 4) % 100) / 200);

      // Number of logs
      const logCount = 3 - Math.floor(difficulty * 1.5);
      const finalCount = Math.max(1, logCount + ((h >> 8) % 2));

      const logs = [];
      const totalWidth = W + 300;
      for (let i = 0; i < finalCount; i++) {
        const lh = hashRow(rowIndex * 29 + i * 53);
        const logW = 80 + (lh % 4) * 20 - Math.floor(difficulty * 30); // shrink with difficulty
        const finalW = Math.max(50, logW);
        const x = (i * (totalWidth / finalCount)) + ((lh >> 8) % 30) - 150;
        const hasLilyPad = (lh >> 12) % 5 === 0;
        logs.push({ x, w: finalW, hasLilyPad });
      }

      return { type: RIVER, index: rowIndex, dir, speed, logs };
    }

    function getRow(rowIndex) {
      if (!rows[rowIndex]) {
        rows[rowIndex] = generateRow(rowIndex);
      }
      return rows[rowIndex];
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'CROSSY ROAD';
      overlayText.textContent = 'Press any arrow key to start';

      player = { col: Math.floor(COLS / 2), row: 0 };
      rows = {};
      cameraY = 0;
      furthestRow = 0;
      deathTimer = 0;
      hopAnim = false;
      hopProgress = 0;
      idleTimer = 0;
      maxIdleFrames = 300; // ~5 seconds at 60fps before pushed off screen

      // Pre-generate visible rows
      for (let i = -2; i < VISIBLE_ROWS + 5; i++) {
        getRow(i);
      }

      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function getPlayerScreenPos() {
      const baseX = player.col * COL_W + COL_W / 2;
      const baseY = H - ROW_H - (player.row * ROW_H) + cameraY;

      if (hopAnim) {
        const fromX = hopFrom.col * COL_W + COL_W / 2;
        const fromY = H - ROW_H - (hopFrom.row * ROW_H) + cameraY;
        const toX = hopTo.col * COL_W + COL_W / 2;
        const toY = H - ROW_H - (hopTo.row * ROW_H) + cameraY;
        const t = hopProgress;
        const eased = t * t * (3 - 2 * t); // smoothstep
        const x = fromX + (toX - fromX) * eased;
        const y = fromY + (toY - fromY) * eased;
        // Arc for hop
        const arcHeight = -15 * Math.sin(t * Math.PI);
        return { x, y: y + arcHeight };
      }
      return { x: baseX, y: baseY };
    }

    function tryHop(dCol, dRow) {
      if (hopAnim) return;

      const newCol = player.col + dCol;
      const newRow = player.row + dRow;

      // Boundary check (columns)
      if (newCol < 0 || newCol >= COLS) return;

      // Can't go below row 0
      if (newRow < 0) return;

      // Check if destination on grass row has a blocking decoration (bush/rock)
      const destRow = getRow(newRow);
      if (destRow.type === GRASS) {
        const blocked = destRow.decorations.some(d => d.col === newCol && (d.type === 0 || d.type === 1));
        if (blocked) return;
      }

      hopAnim = true;
      hopFrom = { col: player.col, row: player.row };
      hopTo = { col: newCol, row: newRow };
      hopProgress = 0;
      idleTimer = 0;
    }

    function update() {
      // Update hop animation
      if (hopAnim) {
        hopProgress += 0.15;
        if (hopProgress >= 1) {
          hopProgress = 1;
          hopAnim = false;
          player.col = hopTo.col;
          player.row = hopTo.row;

          // Update score
          if (player.row > furthestRow) {
            furthestRow = player.row;
            score = furthestRow;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
          }
        }
      }

      // Scroll camera to follow player
      const targetCameraY = Math.max(0, (player.row - 4) * ROW_H);
      cameraY += (targetCameraY - cameraY) * 0.1;

      // Pre-generate rows ahead
      for (let i = player.row - 2; i < player.row + VISIBLE_ROWS + 5; i++) {
        getRow(i);
      }

      // Update moving objects
      const minRow = Math.floor(cameraY / ROW_H) - 2;
      const maxRow = minRow + VISIBLE_ROWS + 6;

      for (let ri = minRow; ri <= maxRow; ri++) {
        const row = getRow(ri);
        if (row.type === ROAD) {
          row.cars.forEach(car => {
            car.x += row.speed * row.dir;
            // Wrap cars
            if (row.dir > 0 && car.x > W + 100) car.x = -car.w - 50;
            if (row.dir < 0 && car.x + car.w < -100) car.x = W + 50;
          });
        } else if (row.type === RIVER) {
          row.logs.forEach(log => {
            log.x += row.speed * row.dir;
            // Wrap logs
            if (row.dir > 0 && log.x > W + 100) log.x = -log.w - 50;
            if (row.dir < 0 && log.x + log.w < -100) log.x = W + 50;
          });
        }
      }

      // Player interactions (only when not mid-hop)
      if (!hopAnim) {
        const currentRow = getRow(player.row);
        const px = player.col * COL_W + COL_W / 2;

        // On a river row: check if on a log
        if (currentRow.type === RIVER) {
          let onLog = false;
          currentRow.logs.forEach(log => {
            if (px >= log.x && px <= log.x + log.w) {
              onLog = true;
              // Push player with the log
              const newPx = px + currentRow.speed * currentRow.dir;
              player.col = Math.round((newPx - COL_W / 2) / COL_W);
            }
          });

          if (!onLog) {
            // Fell in water
            die();
            return;
          }

          // Pushed off screen
          if (player.col < 0 || player.col >= COLS) {
            die();
            return;
          }
        }

        // On a road row: check for car collision
        if (currentRow.type === ROAD) {
          const playerLeft = px - PLAYER_SIZE / 2;
          const playerRight = px + PLAYER_SIZE / 2;
          for (const car of currentRow.cars) {
            if (playerRight > car.x + 4 && playerLeft < car.x + car.w - 4) {
              die();
              return;
            }
          }
        }

        // Idle timeout: camera keeps scrolling, if player is too far behind, die
        idleTimer++;
        const playerScreenY = H - ROW_H - (player.row * ROW_H) + cameraY;
        if (playerScreenY > H + ROW_H) {
          die();
          return;
        }
      }

      // Slowly push camera forward to create urgency
      if (furthestRow > 5) {
        const pushSpeed = 0.15 + Math.min(furthestRow / 200, 0.3);
        const minCamera = (furthestRow - 10) * ROW_H;
        if (cameraY < minCamera) {
          cameraY += pushSpeed;
        }
      }
    }

    function die() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Determine visible row range
      const minRow = Math.floor(cameraY / ROW_H) - 2;
      const maxRow = minRow + VISIBLE_ROWS + 4;

      // Draw rows from back to front
      for (let ri = maxRow; ri >= minRow; ri--) {
        const row = getRow(ri);
        const screenY = H - ROW_H - (ri * ROW_H) + cameraY;

        // Skip if off screen
        if (screenY > H + ROW_H || screenY < -ROW_H * 2) continue;

        drawRow(row, screenY);
      }

      // Draw player
      const pPos = getPlayerScreenPos();
      drawPlayer(pPos.x, pPos.y);
    }

    function drawRow(row, screenY) {
      if (row.type === GRASS) {
        drawGrassRow(row, screenY);
      } else if (row.type === ROAD) {
        drawRoadRow(row, screenY);
      } else if (row.type === RIVER) {
        drawRiverRow(row, screenY);
      }
    }

    function drawGrassRow(row, screenY) {
      // Grass background - alternating shades
      const shade = row.index % 2 === 0 ? '#1a3a1a' : '#1e3e1e';
      ctx.fillStyle = shade;
      ctx.fillRect(0, screenY, W, ROW_H);

      // Subtle grass texture lines
      ctx.strokeStyle = 'rgba(40, 120, 40, 0.15)';
      ctx.lineWidth = 1;
      for (let i = 0; i < COLS; i++) {
        const h = hashRow(row.index * 100 + i);
        if (h % 3 === 0) {
          const x = i * COL_W + (h % 20);
          ctx.beginPath();
          ctx.moveTo(x, screenY + ROW_H);
          ctx.lineTo(x + 2, screenY + ROW_H - 8 - (h % 6));
          ctx.stroke();
        }
      }

      // Decorations
      row.decorations.forEach(d => {
        const dx = d.col * COL_W + COL_W / 2;
        const dy = screenY + ROW_H / 2;

        if (d.type === 0) {
          // Bush
          ctx.fillStyle = '#2a6a2a';
          ctx.shadowColor = '#2a6a2a';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(dx, dy, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#3a8a3a';
          ctx.beginPath();
          ctx.arc(dx - 4, dy - 3, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (d.type === 1) {
          // Rock
          ctx.fillStyle = '#555';
          ctx.beginPath();
          ctx.ellipse(dx, dy + 2, 10, 8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#666';
          ctx.beginPath();
          ctx.ellipse(dx - 2, dy, 7, 5, 0, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Flower
          ctx.fillStyle = '#4a4';
          ctx.fillRect(dx - 1, dy, 2, 10);
          const fh = hashRow(row.index * 200 + d.col);
          const flowerColor = ['#f4a', '#fa4', '#a4f', '#4af'][fh % 4];
          ctx.fillStyle = flowerColor;
          ctx.beginPath();
          ctx.arc(dx, dy, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function drawRoadRow(row, screenY) {
      // Road background
      ctx.fillStyle = '#2a2a3e';
      ctx.fillRect(0, screenY, W, ROW_H);

      // Road markings (dashed line)
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.setLineDash([12, 8]);
      ctx.beginPath();
      ctx.moveTo(0, screenY + ROW_H / 2);
      ctx.lineTo(W, screenY + ROW_H / 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // Edge lines
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, screenY);
      ctx.lineTo(W, screenY);
      ctx.moveTo(0, screenY + ROW_H);
      ctx.lineTo(W, screenY + ROW_H);
      ctx.stroke();

      // Cars
      row.cars.forEach(car => {
        const carH = ROW_H - 10;
        const carY = screenY + 5;

        // Car body
        ctx.fillStyle = car.color;
        ctx.shadowColor = car.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(car.x, carY, car.w, carH);
        ctx.shadowBlur = 0;

        // Car roof (darker shade)
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(car.x + car.w * 0.2, carY + 2, car.w * 0.6, carH * 0.4);

        // Headlights
        const hlColor = '#ff8';
        ctx.fillStyle = hlColor;
        if (row.dir > 0) {
          ctx.fillRect(car.x + car.w - 4, carY + 3, 3, 4);
          ctx.fillRect(car.x + car.w - 4, carY + carH - 7, 3, 4);
        } else {
          ctx.fillRect(car.x + 1, carY + 3, 3, 4);
          ctx.fillRect(car.x + 1, carY + carH - 7, 3, 4);
        }

        // Taillights
        ctx.fillStyle = '#f22';
        if (row.dir > 0) {
          ctx.fillRect(car.x + 1, carY + 3, 3, 4);
          ctx.fillRect(car.x + 1, carY + carH - 7, 3, 4);
        } else {
          ctx.fillRect(car.x + car.w - 4, carY + 3, 3, 4);
          ctx.fillRect(car.x + car.w - 4, carY + carH - 7, 3, 4);
        }
      });
    }

    function drawRiverRow(row, screenY) {
      // Water background
      ctx.fillStyle = '#0a2a4e';
      ctx.fillRect(0, screenY, W, ROW_H);

      // Water ripples
      ctx.strokeStyle = 'rgba(40, 120, 200, 0.2)';
      ctx.lineWidth = 1;
      const time = Date.now() * 0.002;
      for (let i = 0; i < 5; i++) {
        const rx = (hashRow(row.index * 50 + i) % W);
        const ry = screenY + 10 + (i * 7);
        ctx.beginPath();
        ctx.moveTo(rx, ry);
        ctx.quadraticCurveTo(rx + 10, ry + Math.sin(time + i) * 3, rx + 20, ry);
        ctx.stroke();
      }

      // Logs
      row.logs.forEach(log => {
        const logH = ROW_H - 8;
        const logY = screenY + 4;

        // Log body
        ctx.fillStyle = '#6a4a2a';
        ctx.shadowColor = '#6a4a2a';
        ctx.shadowBlur = 4;
        ctx.fillRect(log.x, logY, log.w, logH);
        ctx.shadowBlur = 0;

        // Log texture (horizontal lines)
        ctx.strokeStyle = '#5a3a1a';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const ly = logY + 6 + i * 8;
          ctx.beginPath();
          ctx.moveTo(log.x + 3, ly);
          ctx.lineTo(log.x + log.w - 3, ly);
          ctx.stroke();
        }

        // Log ends (circles)
        ctx.fillStyle = '#7a5a3a';
        ctx.beginPath();
        ctx.arc(log.x + 5, logY + logH / 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(log.x + log.w - 5, logY + logH / 2, 5, 0, Math.PI * 2);
        ctx.fill();

        // Ring pattern on log ends
        ctx.strokeStyle = '#5a3a1a';
        ctx.beginPath();
        ctx.arc(log.x + 5, logY + logH / 2, 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(log.x + log.w - 5, logY + logH / 2, 3, 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    function drawPlayer(x, y) {
      const s = PLAYER_SIZE;

      ctx.save();
      ctx.translate(x, y + ROW_H / 2);

      // Shadow under the chicken
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(0, s / 2 - 2, s / 2.5, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body
      ctx.fillStyle = '#fc4';
      ctx.shadowColor = '#fc4';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.ellipse(0, 0, s / 2.5, s / 2.2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Head (slightly above body)
      ctx.fillStyle = '#fda';
      ctx.beginPath();
      ctx.arc(0, -s / 2.5, s / 4, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(-3, -s / 2.5 - 1, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(3, -s / 2.5 - 1, 2, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#f80';
      ctx.beginPath();
      ctx.moveTo(-3, -s / 2.5 + 3);
      ctx.lineTo(0, -s / 2.5 + 7);
      ctx.lineTo(3, -s / 2.5 + 3);
      ctx.closePath();
      ctx.fill();

      // Comb (red on top of head)
      ctx.fillStyle = '#e33';
      ctx.beginPath();
      ctx.arc(-2, -s / 2.5 - s / 4 - 1, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2, -s / 2.5 - s / 4 + 1, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Feet
      ctx.fillStyle = '#f80';
      ctx.fillRect(-6, s / 2.2 - 3, 3, 5);
      ctx.fillRect(3, s / 2.2 - 3, 3, 5);

      ctx.restore();
    }

    // Keyboard input
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        // Process the first key as a hop
        handleGameInput(e.key);
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        handleGameInput(e.key);
      }
    });

    function handleGameInput(key) {
      switch (key) {
        case 'ArrowUp':    tryHop(0, 1); break;
        case 'ArrowDown':  tryHop(0, -1); break;
        case 'ArrowLeft':  tryHop(-1, 0); break;
        case 'ArrowRight': tryHop(1, 0); break;
      }
    }

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

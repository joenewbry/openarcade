<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Survival Island</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4a8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 136, 0.5); }
    h1 { color: #4a8; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 170, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #4a8; }
    canvas {
      border: 2px solid #4a8;
      box-shadow: 0 0 20px rgba(68, 170, 136, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4a8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(68,170,136,0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .keys { font-size: 0.8rem; color: #6c8; margin-top: 12px; }
    .controls {
      width: 600px;
      margin-top: 10px;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SURVIVAL ISLAND</h1>
  </div>
  <div class="score-bar">
    <div>Day: <span id="dayNum">1</span> | Score: <span id="score">0</span></div>
    <div>Health: <span id="health">100</span> | Hunger: <span id="hunger">100</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">SURVIVAL ISLAND</h2>
      <p id="overlayText">Gather, Craft, Survive, Escape!</p>
      <p class="keys">WASD=Move | Click=Gather/Attack | E=Interact | I=Inventory | C=Craft</p>
      <p style="margin-top:16px;color:#4a8;font-size:1.1rem;">Click to Start</p>
    </div>
  </div>
  <div class="controls">WASD: Move | Click: Gather/Attack | E: Interact/Pickup | I: Inventory | C: Craft Menu</div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 600, H = 500;
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayText = document.getElementById('overlayText');
  const dayEl = document.getElementById('dayNum');
  const scoreEl = document.getElementById('score');
  const healthEl = document.getElementById('health');
  const hungerEl = document.getElementById('hunger');

  let gameState = 'waiting';
  let score = 0;

  // ---------- ISLAND MAP GENERATION ----------
  const MAP_W = 80, MAP_H = 60;
  const TILE = 16;
  const TILE_WATER = 0, TILE_SAND = 1, TILE_GRASS = 2, TILE_FOREST = 3;
  let map = [];
  let resources = []; // {x,y,type,hp}
  let droppedItems = []; // {x,y,type,amount}
  let shelters = []; // {x,y,owner}
  let campfires = []; // {x,y,owner}

  const RESOURCE_TYPES = {
    TREE: { tile: 'üå≥', hp: 3, drop: 'wood', dropAmt: 2, color: '#2a7' },
    ROCK: { tile: 'ü™®', hp: 4, drop: 'stone', dropAmt: 2, color: '#888' },
    BERRY: { tile: 'ü´ê', hp: 1, drop: 'food', dropAmt: 3, color: '#a3e' },
    PLANT: { tile: 'üåø', hp: 2, drop: 'fiber', dropAmt: 2, color: '#5b5' },
    FISH_SPOT: { tile: 'üêü', hp: 2, drop: 'food', dropAmt: 4, color: '#48d' }
  };

  const RECIPES = {
    axe: { name: 'Axe', ingredients: { wood: 2, stone: 2 }, desc: 'Gather faster' },
    spear: { name: 'Spear', ingredients: { wood: 2, fiber: 2 }, desc: 'Defend & hunt' },
    shelter: { name: 'Shelter', ingredients: { wood: 5 }, desc: 'Night safety' },
    campfire: { name: 'Campfire', ingredients: { wood: 2, stone: 1 }, desc: 'Warmth & light' },
    raft: { name: 'Raft', ingredients: { wood: 10, fiber: 5 }, desc: 'ESCAPE the island!' }
  };

  function generateIsland() {
    map = [];
    resources = [];
    droppedItems = [];
    shelters = [];
    campfires = [];
    // Create island shape using distance from center
    const cx = MAP_W / 2, cy = MAP_H / 2;
    for (let y = 0; y < MAP_H; y++) {
      map[y] = [];
      for (let x = 0; x < MAP_W; x++) {
        let dx = (x - cx) / (MAP_W * 0.42), dy = (y - cy) / (MAP_H * 0.42);
        let dist = Math.sqrt(dx * dx + dy * dy);
        // Add noise
        dist += (Math.sin(x * 0.3) * 0.08 + Math.cos(y * 0.25) * 0.08 + Math.sin((x + y) * 0.15) * 0.06);
        if (dist > 1.0) map[y][x] = TILE_WATER;
        else if (dist > 0.88) map[y][x] = TILE_SAND;
        else if (dist > 0.4 && Math.random() < 0.35) map[y][x] = TILE_FOREST;
        else map[y][x] = TILE_GRASS;
      }
    }
    // Place resources
    for (let y = 2; y < MAP_H - 2; y++) {
      for (let x = 2; x < MAP_W - 2; x++) {
        if (map[y][x] === TILE_WATER) continue;
        let r = Math.random();
        if (map[y][x] === TILE_FOREST && r < 0.3) {
          resources.push({ x, y, type: 'TREE', hp: RESOURCE_TYPES.TREE.hp, maxHp: RESOURCE_TYPES.TREE.hp });
        } else if (map[y][x] === TILE_GRASS) {
          if (r < 0.03) resources.push({ x, y, type: 'ROCK', hp: RESOURCE_TYPES.ROCK.hp, maxHp: RESOURCE_TYPES.ROCK.hp });
          else if (r < 0.05) resources.push({ x, y, type: 'BERRY', hp: RESOURCE_TYPES.BERRY.hp, maxHp: RESOURCE_TYPES.BERRY.hp });
          else if (r < 0.065) resources.push({ x, y, type: 'PLANT', hp: RESOURCE_TYPES.PLANT.hp, maxHp: RESOURCE_TYPES.PLANT.hp });
        } else if (map[y][x] === TILE_SAND && r < 0.015) {
          resources.push({ x, y, type: 'FISH_SPOT', hp: RESOURCE_TYPES.FISH_SPOT.hp, maxHp: RESOURCE_TYPES.FISH_SPOT.hp });
        }
      }
    }
  }

  function isLand(x, y) {
    if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return false;
    return map[y][x] !== TILE_WATER;
  }

  // ---------- ENTITIES ----------
  let player = null;
  let aiCastaways = [];
  let dayTime = 0; // 0-1, 0=dawn, 0.5=dusk, 0.75=midnight
  let dayCount = 1;
  let daySpeed = 0.0003;
  let showInventory = false;
  let showCraft = false;
  let craftSelection = 0;
  let notifications = []; // {text, timer, color}
  let particles = []; // {x,y,vx,vy,life,color}
  let gameOverReason = '';

  const AI_NAMES = ['Morgan', 'Quinn', 'Reese'];
  const AI_COLORS = ['#e84', '#48e', '#e4e'];

  function createEntity(x, y, name, color, isAI) {
    return {
      x, y, vx: 0, vy: 0, name, color, isAI,
      health: 100, hunger: 100,
      inventory: { wood: 0, stone: 0, food: 0, fiber: 0 },
      tools: { axe: false, spear: false },
      hasShelter: false, hasCampfire: false, hasRaft: false,
      gatherTarget: null, gatherTimer: 0,
      itemsCrafted: 0,
      // AI state
      aiState: 'idle', aiTimer: 0, aiTarget: null,
      personality: Math.random(), // 0=cooperative, 1=aggressive
      tradeCooldown: 0
    };
  }

  function findSpawnPoint() {
    for (let i = 0; i < 500; i++) {
      let x = 15 + Math.floor(Math.random() * (MAP_W - 30));
      let y = 10 + Math.floor(Math.random() * (MAP_H - 20));
      if (map[y][x] === TILE_GRASS || map[y][x] === TILE_SAND) {
        // Check not too close to other spawns
        let ok = true;
        if (player && Math.hypot(player.x - x, player.y - y) < 8) ok = false;
        for (let ai of aiCastaways) {
          if (Math.hypot(ai.x - x, ai.y - y) < 8) ok = false;
        }
        if (ok) return { x, y };
      }
    }
    return { x: MAP_W / 2, y: MAP_H / 2 };
  }

  function initGame() {
    generateIsland();
    let sp = findSpawnPoint();
    player = createEntity(sp.x, sp.y, 'You', '#4a8', false);
    aiCastaways = [];
    for (let i = 0; i < 3; i++) {
      let asp = findSpawnPoint();
      let ai = createEntity(asp.x, asp.y, AI_NAMES[i], AI_COLORS[i], true);
      ai.personality = 0.2 + Math.random() * 0.8;
      aiCastaways.push(ai);
    }
    dayTime = 0;
    dayCount = 1;
    score = 0;
    showInventory = false;
    showCraft = false;
    notifications = [];
    particles = [];
    gameOverReason = '';
  }

  // ---------- INPUT ----------
  let keys = {};
  let mouseX = 0, mouseY = 0;
  let mouseDown = false;

  document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (gameState === 'playing') {
      if (e.key.toLowerCase() === 'i') { showInventory = !showInventory; showCraft = false; }
      if (e.key.toLowerCase() === 'c') { showCraft = !showCraft; showInventory = false; craftSelection = 0; }
      if (e.key.toLowerCase() === 'e') interact();
      if (showCraft) {
        let recipeKeys = Object.keys(RECIPES);
        if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') { craftSelection = (craftSelection - 1 + recipeKeys.length) % recipeKeys.length; e.preventDefault(); }
        if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') { craftSelection = (craftSelection + 1) % recipeKeys.length; e.preventDefault(); }
        if (e.key === 'Enter' || e.key === ' ') { craftItem(player, recipeKeys[craftSelection]); }
      }
    }
    if (e.key === ' ' || e.key === 'Enter') {
      if (gameState === 'waiting') { gameState = 'playing'; initGame(); overlay.style.display = 'none'; }
      else if (gameState === 'gameover') { gameState = 'playing'; initGame(); overlay.style.display = 'none'; }
    }
  });
  document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  canvas.addEventListener('mousemove', e => {
    let r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left;
    mouseY = e.clientY - r.top;
  });
  canvas.addEventListener('mousedown', e => {
    mouseDown = true;
    if (gameState === 'waiting') { gameState = 'playing'; initGame(); overlay.style.display = 'none'; }
    else if (gameState === 'gameover') { gameState = 'playing'; initGame(); overlay.style.display = 'none'; }
    else if (gameState === 'playing' && !showCraft && !showInventory) {
      handleClick();
    }
  });
  canvas.addEventListener('mouseup', () => { mouseDown = false; });

  // ---------- CAMERA ----------
  let camX = 0, camY = 0;
  function updateCamera() {
    let targetX = player.x * TILE - W / 2;
    let targetY = player.y * TILE - H / 2;
    camX += (targetX - camX) * 0.1;
    camY += (targetY - camY) * 0.1;
    camX = Math.max(0, Math.min(MAP_W * TILE - W, camX));
    camY = Math.max(0, Math.min(MAP_H * TILE - H, camY));
  }

  // ---------- GAME LOGIC ----------
  function notify(text, color = '#4a8') {
    notifications.push({ text, timer: 180, color });
    if (notifications.length > 5) notifications.shift();
  }

  function addParticles(x, y, color, count = 5) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x * TILE + 8, y: y * TILE + 8,
        vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
        life: 30 + Math.random() * 20, color
      });
    }
  }

  function worldToTile(sx, sy) {
    return { tx: Math.floor((sx + camX) / TILE), ty: Math.floor((sy + camY) / TILE) };
  }

  function handleClick() {
    let { tx, ty } = worldToTile(mouseX, mouseY);
    let dist = Math.hypot(tx - player.x, ty - player.y);
    if (dist > 3) return;
    // Check for resource at tile
    let res = resources.find(r => r.x === tx && r.y === ty);
    if (res) {
      gatherResource(player, res);
      return;
    }
    // Check for AI to attack
    let target = aiCastaways.find(a => Math.abs(a.x - tx) < 1 && Math.abs(a.y - ty) < 1 && a.health > 0);
    if (target) {
      attackEntity(player, target);
    }
  }

  function gatherResource(entity, res) {
    let rt = RESOURCE_TYPES[res.type];
    let dmg = entity.tools.axe ? 2 : 1;
    res.hp -= dmg;
    addParticles(res.x, res.y, rt.color, 3);
    if (res.hp <= 0) {
      entity.inventory[rt.drop] += rt.dropAmt;
      if (!entity.isAI) notify(`+${rt.dropAmt} ${rt.drop}`, '#ff0');
      addParticles(res.x, res.y, rt.color, 8);
      // Respawn resource after delay
      let idx = resources.indexOf(res);
      resources.splice(idx, 1);
      setTimeout(() => {
        if (gameState === 'playing') {
          res.hp = res.maxHp;
          resources.push(res);
        }
      }, 15000 + Math.random() * 15000);
    }
  }

  function attackEntity(attacker, target) {
    let dmg = attacker.tools.spear ? 20 : 8;
    target.health -= dmg;
    addParticles(target.x, target.y, '#f44', 6);
    if (!attacker.isAI) notify(`Hit ${target.name} for ${dmg}!`, '#f44');
    if (target.health <= 0) {
      // Drop some inventory
      for (let key of Object.keys(target.inventory)) {
        if (target.inventory[key] > 0) {
          droppedItems.push({ x: target.x, y: target.y, type: key, amount: target.inventory[key] });
          target.inventory[key] = 0;
        }
      }
      if (!attacker.isAI) { notify(`${target.name} defeated!`, '#f84'); score += 10; }
      // Respawn AI after a while
      setTimeout(() => {
        if (gameState === 'playing' && target.isAI) {
          let sp = findSpawnPoint();
          target.x = sp.x; target.y = sp.y;
          target.health = 100; target.hunger = 100;
          target.tools = { axe: false, spear: false };
          target.hasShelter = false; target.hasCampfire = false; target.hasRaft = false;
          target.inventory = { wood: 0, stone: 0, food: 0, fiber: 0 };
          target.aiState = 'idle';
          if (!attacker.isAI) notify(`${target.name} washed ashore again...`, '#48e');
        }
      }, 20000);
    }
  }

  function interact() {
    // Pickup dropped items nearby
    for (let i = droppedItems.length - 1; i >= 0; i--) {
      let it = droppedItems[i];
      if (Math.hypot(it.x - player.x, it.y - player.y) < 2) {
        player.inventory[it.type] += it.amount;
        notify(`Picked up ${it.amount} ${it.type}`, '#ff0');
        droppedItems.splice(i, 1);
      }
    }
    // Eat food
    if (player.inventory.food > 0 && player.hunger < 80) {
      player.inventory.food--;
      player.hunger = Math.min(100, player.hunger + 30);
      player.health = Math.min(100, player.health + 5);
      notify('Ate food (+30 hunger, +5 health)', '#4a8');
    }
    // Trade with nearby cooperative AI
    for (let ai of aiCastaways) {
      if (ai.health <= 0) continue;
      if (Math.hypot(ai.x - player.x, ai.y - player.y) < 2.5 && ai.personality < 0.5 && ai.tradeCooldown <= 0) {
        // AI offers a trade
        let aiHas = Object.keys(ai.inventory).filter(k => ai.inventory[k] >= 2);
        let playerHas = Object.keys(player.inventory).filter(k => player.inventory[k] >= 2);
        if (aiHas.length > 0 && playerHas.length > 0) {
          let give = playerHas[Math.floor(Math.random() * playerHas.length)];
          let get = aiHas.filter(k => k !== give)[0] || aiHas[0];
          if (get && give !== get) {
            player.inventory[give] -= 2;
            player.inventory[get] += 2;
            ai.inventory[give] += 2;
            ai.inventory[get] -= 2;
            notify(`Traded 2 ${give} for 2 ${get} with ${ai.name}`, '#4af');
            ai.tradeCooldown = 600;
          }
        }
      }
    }
  }

  function canCraft(entity, recipeKey) {
    let recipe = RECIPES[recipeKey];
    for (let [item, amt] of Object.entries(recipe.ingredients)) {
      if ((entity.inventory[item] || 0) < amt) return false;
    }
    return true;
  }

  function craftItem(entity, recipeKey) {
    if (!canCraft(entity, recipeKey)) {
      if (!entity.isAI) notify('Not enough materials!', '#f44');
      return false;
    }
    let recipe = RECIPES[recipeKey];
    for (let [item, amt] of Object.entries(recipe.ingredients)) {
      entity.inventory[item] -= amt;
    }
    entity.itemsCrafted++;
    if (!entity.isAI) score += 5;

    switch (recipeKey) {
      case 'axe': entity.tools.axe = true; if (!entity.isAI) notify('Crafted Axe! Gather faster.', '#ff0'); break;
      case 'spear': entity.tools.spear = true; if (!entity.isAI) notify('Crafted Spear! Better attacks.', '#ff0'); break;
      case 'shelter':
        entity.hasShelter = true;
        shelters.push({ x: Math.round(entity.x), y: Math.round(entity.y), owner: entity.name, color: entity.color });
        if (!entity.isAI) notify('Built Shelter! Safe at night.', '#ff0');
        break;
      case 'campfire':
        entity.hasCampfire = true;
        campfires.push({ x: Math.round(entity.x), y: Math.round(entity.y), owner: entity.name, color: entity.color });
        if (!entity.isAI) notify('Built Campfire! Warmth at night.', '#ff0');
        break;
      case 'raft':
        entity.hasRaft = true;
        if (!entity.isAI) {
          score += 50;
          gameOverReason = 'You built a raft and escaped the island!';
          endGame(true);
        } else {
          notify(`${entity.name} built a raft and ESCAPED!`, '#f84');
          // Remove AI
          let idx = aiCastaways.indexOf(entity);
          if (idx >= 0) {
            entity.health = 0;
            setTimeout(() => {
              let sp = findSpawnPoint();
              entity.x = sp.x; entity.y = sp.y;
              entity.health = 100; entity.hunger = 100;
              entity.tools = { axe: false, spear: false };
              entity.hasShelter = false; entity.hasCampfire = false; entity.hasRaft = false;
              entity.inventory = { wood: 0, stone: 0, food: 0, fiber: 0 };
            }, 20000);
          }
        }
        break;
    }
    addParticles(entity.x, entity.y, '#ff0', 10);
    return true;
  }

  function endGame(won) {
    gameState = 'gameover';
    score += dayCount * 2;
    overlay.style.display = 'flex';
    overlayTitle.textContent = won ? 'ESCAPED!' : 'PERISHED';
    overlayTitle.style.color = won ? '#4a8' : '#f44';
    let html = `${gameOverReason}<br>Days survived: ${dayCount}<br>Score: ${score}`;
    html += `<br><br><span style="color:#4a8;font-size:1.1rem;">Click to Play Again</span>`;
    overlayText.innerHTML = html;
  }

  // ---------- AI BEHAVIOR ----------
  function updateAI(ai, dt) {
    if (ai.health <= 0) return;
    ai.tradeCooldown = Math.max(0, ai.tradeCooldown - 1);
    ai.aiTimer -= dt;

    // Eat when hungry
    if (ai.hunger < 50 && ai.inventory.food > 0) {
      ai.inventory.food--;
      ai.hunger = Math.min(100, ai.hunger + 30);
      ai.health = Math.min(100, ai.health + 5);
    }

    if (ai.aiTimer > 0) {
      // Move toward target
      if (ai.aiTarget) {
        let dx = ai.aiTarget.x - ai.x, dy = ai.aiTarget.y - ai.y;
        let dist = Math.hypot(dx, dy);
        if (dist > 0.5) {
          let speed = 0.04;
          ai.x += (dx / dist) * speed;
          ai.y += (dy / dist) * speed;
          // Don't walk into water
          if (!isLand(Math.round(ai.x), Math.round(ai.y))) {
            ai.x -= (dx / dist) * speed;
            ai.y -= (dy / dist) * speed;
            ai.aiTimer = 0; // Pick new goal
          }
        } else {
          // Arrived at target
          if (ai.aiState === 'gather') {
            let res = resources.find(r => r.x === ai.aiTarget.x && r.y === ai.aiTarget.y);
            if (res) gatherResource(ai, res);
            ai.aiTimer = 0;
          } else if (ai.aiState === 'steal') {
            // Try to take dropped items
            for (let i = droppedItems.length - 1; i >= 0; i--) {
              let it = droppedItems[i];
              if (Math.hypot(it.x - ai.x, it.y - ai.y) < 2) {
                ai.inventory[it.type] += it.amount;
                droppedItems.splice(i, 1);
              }
            }
            ai.aiTimer = 0;
          }
        }
      }
      return;
    }

    // Decide next action
    let totalRes = ai.inventory.wood + ai.inventory.stone + ai.inventory.food + ai.inventory.fiber;

    // Priority: Craft raft if possible
    if (canCraft(ai, 'raft')) {
      craftItem(ai, 'raft');
      return;
    }
    // Craft tools if possible
    if (!ai.tools.axe && canCraft(ai, 'axe')) { craftItem(ai, 'axe'); return; }
    if (!ai.tools.spear && canCraft(ai, 'spear')) { craftItem(ai, 'spear'); return; }
    // Craft shelter at night
    let isNight = dayTime > 0.4 && dayTime < 0.9;
    if (isNight && !ai.hasShelter && canCraft(ai, 'shelter')) { craftItem(ai, 'shelter'); return; }
    if (isNight && !ai.hasCampfire && canCraft(ai, 'campfire')) { craftItem(ai, 'campfire'); return; }

    // Aggressive AI might attack nearby player or other AI
    if (ai.personality > 0.7 && ai.tools.spear) {
      let dist = Math.hypot(player.x - ai.x, player.y - ai.y);
      if (dist < 4 && Math.random() < 0.15) {
        ai.aiState = 'attack';
        ai.aiTarget = { x: player.x, y: player.y };
        ai.aiTimer = 120;
        if (dist < 1.5) {
          attackEntity(ai, player);
          notify(`${ai.name} attacks you!`, '#f44');
        }
        return;
      }
    }

    // Pick dropped items
    if (droppedItems.length > 0) {
      let nearest = null, ndist = Infinity;
      for (let it of droppedItems) {
        let d = Math.hypot(it.x - ai.x, it.y - ai.y);
        if (d < ndist && d < 20) { nearest = it; ndist = d; }
      }
      if (nearest && Math.random() < 0.3) {
        ai.aiState = 'steal';
        ai.aiTarget = { x: nearest.x, y: nearest.y };
        ai.aiTimer = 200;
        return;
      }
    }

    // Determine what to gather based on needs
    let needType = null;
    if (ai.hunger < 60) needType = 'BERRY';
    else if (ai.inventory.wood < 10) needType = 'TREE';
    else if (ai.inventory.stone < 4) needType = 'ROCK';
    else if (ai.inventory.fiber < 5) needType = 'PLANT';
    else needType = 'TREE'; // hoard wood for raft

    // Find nearest resource of type
    let best = null, bestDist = Infinity;
    for (let r of resources) {
      if (needType && r.type !== needType) continue;
      let d = Math.hypot(r.x - ai.x, r.y - ai.y);
      if (d < bestDist) { best = r; bestDist = d; }
    }
    if (!best) {
      // Gather anything
      for (let r of resources) {
        let d = Math.hypot(r.x - ai.x, r.y - ai.y);
        if (d < bestDist) { best = r; bestDist = d; }
      }
    }
    if (best) {
      ai.aiState = 'gather';
      ai.aiTarget = { x: best.x, y: best.y };
      ai.aiTimer = 300;
    } else {
      // Wander
      ai.aiState = 'wander';
      let wx = ai.x + (Math.random() - 0.5) * 10;
      let wy = ai.y + (Math.random() - 0.5) * 10;
      wx = Math.max(2, Math.min(MAP_W - 2, wx));
      wy = Math.max(2, Math.min(MAP_H - 2, wy));
      ai.aiTarget = { x: wx, y: wy };
      ai.aiTimer = 200;
    }
  }

  // ---------- UPDATE ----------
  function update() {
    if (gameState !== 'playing') return;

    // Player movement
    let speed = 0.08;
    let mx = 0, my = 0;
    if (keys['w'] && !showCraft) my -= speed;
    if (keys['s'] && !showCraft) my += speed;
    if (keys['a']) mx -= speed;
    if (keys['d']) mx += speed;
    if (mx && my) { mx *= 0.707; my *= 0.707; }
    let nx = player.x + mx, ny = player.y + my;
    if (isLand(Math.round(nx), Math.round(player.y))) player.x = nx;
    if (isLand(Math.round(player.x), Math.round(ny))) player.y = ny;

    // Continuous gathering when holding click
    if (mouseDown && !showCraft && !showInventory) {
      let { tx, ty } = worldToTile(mouseX, mouseY);
      let dist = Math.hypot(tx - player.x, ty - player.y);
      if (dist <= 3) {
        player.gatherTimer++;
        if (player.gatherTimer >= 15) {
          player.gatherTimer = 0;
          let res = resources.find(r => r.x === tx && r.y === ty);
          if (res) gatherResource(player, res);
        }
      }
    } else {
      player.gatherTimer = 0;
    }

    // Day/night cycle
    dayTime += daySpeed;
    if (dayTime >= 1.0) {
      dayTime = 0;
      dayCount++;
      score += 2;
      notify(`Day ${dayCount} dawns`, '#ff0');
    }

    // Hunger decreases over time
    player.hunger -= 0.015;
    for (let ai of aiCastaways) {
      if (ai.health > 0) ai.hunger -= 0.012;
    }

    // Night damage if no shelter
    let isNight = dayTime > 0.4 && dayTime < 0.9;
    if (isNight) {
      if (!player.hasShelter && !player.hasCampfire) {
        player.health -= 0.03;
      } else if (!player.hasShelter) {
        player.health -= 0.01; // Campfire helps partially
      }
      for (let ai of aiCastaways) {
        if (ai.health <= 0) continue;
        if (!ai.hasShelter && !ai.hasCampfire) ai.health -= 0.03;
        else if (!ai.hasShelter) ai.health -= 0.01;
      }
    }

    // Starvation
    if (player.hunger <= 0) {
      player.hunger = 0;
      player.health -= 0.08;
    }
    for (let ai of aiCastaways) {
      if (ai.hunger <= 0) {
        ai.hunger = 0;
        if (ai.health > 0) ai.health -= 0.06;
      }
    }

    // Check player death
    if (player.health <= 0) {
      player.health = 0;
      gameOverReason = player.hunger <= 0 ? 'You starved to death...' : 'You perished in the night...';
      endGame(false);
      return;
    }

    // Update AI
    for (let ai of aiCastaways) updateAI(ai, 1);

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.05;
      p.life--;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Update notifications
    for (let i = notifications.length - 1; i >= 0; i--) {
      notifications[i].timer--;
      if (notifications[i].timer <= 0) notifications.splice(i, 1);
    }

    // Update score display
    updateCamera();
    dayEl.textContent = dayCount;
    scoreEl.textContent = score;
    healthEl.textContent = Math.round(player.health);
    hungerEl.textContent = Math.round(player.hunger);
  }

  // ---------- RENDER ----------
  const TILE_COLORS = ['#1a3a5c', '#d4c07a', '#3a7a3a', '#2a5a2a'];
  const TILE_COLORS_NIGHT = ['#0a1a2e', '#5a5030', '#1a3a1a', '#0e2a0e'];

  function lerp(a, b, t) { return a + (b - a) * t; }

  function getTileColor(tileType) {
    let nightFactor = 0;
    if (dayTime > 0.35 && dayTime < 0.95) {
      if (dayTime < 0.5) nightFactor = (dayTime - 0.35) / 0.15;
      else if (dayTime > 0.85) nightFactor = (0.95 - dayTime) / 0.1;
      else nightFactor = 1;
    }
    let dc = TILE_COLORS[tileType];
    let nc = TILE_COLORS_NIGHT[tileType];
    let r1 = parseInt(dc.slice(1, 3), 16), g1 = parseInt(dc.slice(3, 5), 16), b1 = parseInt(dc.slice(5, 7), 16);
    let r2 = parseInt(nc.slice(1, 3), 16), g2 = parseInt(nc.slice(3, 5), 16), b2 = parseInt(nc.slice(5, 7), 16);
    let r = Math.round(lerp(r1, r2, nightFactor));
    let g = Math.round(lerp(g1, g2, nightFactor));
    let b = Math.round(lerp(b1, b2, nightFactor));
    return `rgb(${r},${g},${b})`;
  }

  function draw() {
    ctx.fillStyle = '#0a1a2e';
    ctx.fillRect(0, 0, W, H);

    let startTX = Math.floor(camX / TILE);
    let startTY = Math.floor(camY / TILE);
    let endTX = Math.min(MAP_W, startTX + Math.ceil(W / TILE) + 2);
    let endTY = Math.min(MAP_H, startTY + Math.ceil(H / TILE) + 2);

    // Draw tiles
    for (let ty = startTY; ty < endTY; ty++) {
      for (let tx = startTX; tx < endTX; tx++) {
        if (ty < 0 || ty >= MAP_H || tx < 0 || tx >= MAP_W) continue;
        let sx = tx * TILE - camX, sy = ty * TILE - camY;
        ctx.fillStyle = getTileColor(map[ty][tx]);
        ctx.fillRect(sx, sy, TILE + 1, TILE + 1);
        // Water animation
        if (map[ty][tx] === TILE_WATER) {
          ctx.fillStyle = `rgba(100,180,255,${0.05 + 0.03 * Math.sin(Date.now() * 0.002 + tx * 0.5 + ty * 0.3)})`;
          ctx.fillRect(sx, sy, TILE + 1, TILE + 1);
        }
      }
    }

    // Draw shelters
    for (let s of shelters) {
      let sx = s.x * TILE - camX, sy = s.y * TILE - camY;
      if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) continue;
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(sx - 4, sy - 4, TILE + 8, TILE + 8);
      ctx.fillStyle = '#A0522D';
      ctx.fillRect(sx - 2, sy - 2, TILE + 4, TILE + 4);
      // Roof triangle
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.moveTo(sx - 6, sy + TILE + 4);
      ctx.lineTo(sx + TILE / 2, sy - 10);
      ctx.lineTo(sx + TILE + 6, sy + TILE + 4);
      ctx.fill();
      ctx.fillStyle = s.color;
      ctx.font = '7px Courier New';
      ctx.fillText(s.owner, sx - 2, sy + TILE + 14);
    }

    // Draw campfires
    for (let c of campfires) {
      let sx = c.x * TILE - camX, sy = c.y * TILE - camY;
      if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) continue;
      // Fire glow
      let isNight = dayTime > 0.4 && dayTime < 0.9;
      if (isNight) {
        let grad = ctx.createRadialGradient(sx + 8, sy + 8, 2, sx + 8, sy + 8, 40);
        grad.addColorStop(0, 'rgba(255,150,50,0.3)');
        grad.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(sx - 40, sy - 40, 96, 96);
      }
      // Fire
      ctx.fillStyle = '#f80';
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 8, 5 + Math.sin(Date.now() * 0.01) * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff0';
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 6, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw resources
    for (let r of resources) {
      let sx = r.x * TILE - camX, sy = r.y * TILE - camY;
      if (sx < -TILE * 2 || sx > W + TILE || sy < -TILE * 2 || sy > H + TILE) continue;
      let rt = RESOURCE_TYPES[r.type];
      ctx.font = '14px serif';
      ctx.fillText(rt.tile, sx, sy + 13);
      // Health bar for damaged resources
      if (r.hp < r.maxHp) {
        ctx.fillStyle = '#400';
        ctx.fillRect(sx, sy - 3, TILE, 2);
        ctx.fillStyle = '#4a8';
        ctx.fillRect(sx, sy - 3, TILE * (r.hp / r.maxHp), 2);
      }
    }

    // Draw dropped items
    for (let it of droppedItems) {
      let sx = it.x * TILE - camX, sy = it.y * TILE - camY;
      if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) continue;
      ctx.fillStyle = '#ff0';
      ctx.globalAlpha = 0.6 + 0.3 * Math.sin(Date.now() * 0.005);
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 8, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.font = '7px Courier New';
      ctx.fillStyle = '#ff0';
      ctx.fillText(`${it.amount}${it.type[0]}`, sx, sy - 2);
    }

    // Draw AI castaways
    for (let ai of aiCastaways) {
      if (ai.health <= 0) continue;
      let sx = ai.x * TILE - camX, sy = ai.y * TILE - camY;
      if (sx < -20 || sx > W + 20 || sy < -20 || sy > H + 20) continue;
      // Body
      ctx.fillStyle = ai.color;
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 8, 7, 0, Math.PI * 2);
      ctx.fill();
      // Face
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sx + 6, sy + 6, 1.5, 0, Math.PI * 2);
      ctx.arc(sx + 10, sy + 6, 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Tool indicator
      if (ai.tools.spear) {
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(sx + 14, sy - 2);
        ctx.lineTo(sx + 14, sy + 14);
        ctx.stroke();
        ctx.fillStyle = '#888';
        ctx.beginPath();
        ctx.moveTo(sx + 12, sy - 2);
        ctx.lineTo(sx + 14, sy - 5);
        ctx.lineTo(sx + 16, sy - 2);
        ctx.fill();
      }
      if (ai.tools.axe) {
        ctx.fillStyle = '#aaa';
        ctx.fillRect(sx - 4, sy + 2, 2, 10);
        ctx.fillStyle = '#888';
        ctx.fillRect(sx - 7, sy + 1, 5, 4);
      }
      // Name
      ctx.font = '8px Courier New';
      ctx.fillStyle = ai.color;
      ctx.textAlign = 'center';
      ctx.fillText(ai.name, sx + 8, sy - 6);
      // Health bar
      ctx.fillStyle = '#400';
      ctx.fillRect(sx - 2, sy - 3, 20, 3);
      ctx.fillStyle = ai.health > 50 ? '#4a8' : ai.health > 25 ? '#ea4' : '#f44';
      ctx.fillRect(sx - 2, sy - 3, 20 * (ai.health / 100), 3);
      // Personality indicator
      ctx.font = '6px Courier New';
      ctx.fillStyle = ai.personality > 0.6 ? '#f44' : '#4af';
      ctx.fillText(ai.personality > 0.6 ? '‚öî' : '‚ô•', sx + 8, sy + 22);
      ctx.textAlign = 'left';
    }

    // Draw player
    {
      let sx = player.x * TILE - camX, sy = player.y * TILE - camY;
      // Player glow
      ctx.shadowColor = '#4a8';
      ctx.shadowBlur = 10;
      ctx.fillStyle = '#4a8';
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 8, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Face
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sx + 6, sy + 6, 2, 0, Math.PI * 2);
      ctx.arc(sx + 10, sy + 6, 2, 0, Math.PI * 2);
      ctx.fill();
      // Smile
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(sx + 8, sy + 8, 3, 0.2, Math.PI - 0.2);
      ctx.stroke();
      // Tool display
      if (player.tools.spear) {
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sx + 16, sy - 4);
        ctx.lineTo(sx + 16, sy + 16);
        ctx.stroke();
        ctx.fillStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(sx + 14, sy - 4);
        ctx.lineTo(sx + 16, sy - 8);
        ctx.lineTo(sx + 18, sy - 4);
        ctx.fill();
      }
      if (player.tools.axe) {
        ctx.fillStyle = '#ba8';
        ctx.fillRect(sx - 6, sy + 2, 3, 12);
        ctx.fillStyle = '#aaa';
        ctx.fillRect(sx - 9, sy + 1, 6, 5);
      }
      // Name
      ctx.font = '8px Courier New';
      ctx.fillStyle = '#4a8';
      ctx.textAlign = 'center';
      ctx.fillText('You', sx + 8, sy - 8);
      ctx.textAlign = 'left';
    }

    // Draw particles
    for (let p of particles) {
      let sx = p.x - camX, sy = p.y - camY;
      ctx.globalAlpha = p.life / 50;
      ctx.fillStyle = p.color;
      ctx.fillRect(sx - 1, sy - 1, 3, 3);
    }
    ctx.globalAlpha = 1;

    // Night overlay
    let isNight = dayTime > 0.35 && dayTime < 0.95;
    if (isNight) {
      let nightAlpha = 0;
      if (dayTime < 0.5) nightAlpha = (dayTime - 0.35) / 0.15 * 0.55;
      else if (dayTime > 0.85) nightAlpha = (0.95 - dayTime) / 0.1 * 0.55;
      else nightAlpha = 0.55;
      ctx.fillStyle = `rgba(0,0,30,${nightAlpha})`;
      ctx.fillRect(0, 0, W, H);

      // Player light circle
      if (player.hasCampfire || player.tools.axe) {
        let px = player.x * TILE - camX + 8;
        let py = player.y * TILE - camY + 8;
        let radius = player.hasCampfire ? 60 : 30;
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        let grad = ctx.createRadialGradient(px, py, 0, px, py, radius);
        grad.addColorStop(0, `rgba(0,0,0,${nightAlpha * 0.6})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // ---------- HUD ----------
    // Minimap
    let mmX = W - 110, mmY = 10, mmW = 100, mmH = 75;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);
    ctx.strokeStyle = '#4a8';
    ctx.lineWidth = 1;
    ctx.strokeRect(mmX - 2, mmY - 2, mmW + 4, mmH + 4);
    for (let my = 0; my < MAP_H; my += 2) {
      for (let mx = 0; mx < MAP_W; mx += 2) {
        let px = mmX + (mx / MAP_W) * mmW;
        let py = mmY + (my / MAP_H) * mmH;
        ctx.fillStyle = TILE_COLORS[map[my][mx]];
        ctx.fillRect(px, py, 2, 2);
      }
    }
    // Player dot on minimap
    ctx.fillStyle = '#4a8';
    ctx.fillRect(mmX + (player.x / MAP_W) * mmW - 1, mmY + (player.y / MAP_H) * mmH - 1, 3, 3);
    // AI dots
    for (let ai of aiCastaways) {
      if (ai.health <= 0) continue;
      ctx.fillStyle = ai.color;
      ctx.fillRect(mmX + (ai.x / MAP_W) * mmW - 1, mmY + (ai.y / MAP_H) * mmH - 1, 3, 3);
    }

    // Day/night indicator
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(mmX, mmY + mmH + 6, mmW, 12);
    // Sun/moon position
    let sunX = mmX + dayTime * mmW;
    ctx.fillStyle = dayTime > 0.4 && dayTime < 0.9 ? '#88a' : '#ff0';
    ctx.beginPath();
    ctx.arc(sunX, mmY + mmH + 12, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.font = '8px Courier New';
    ctx.fillStyle = '#aaa';
    ctx.fillText(isNight ? 'NIGHT' : 'DAY', mmX + 2, mmY + mmH + 14);

    // Health & Hunger bars (left side)
    let barX = 10, barY = 10, barW = 80, barH = 10;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(barX - 2, barY - 2, barW + 40, 42);
    // Health
    ctx.font = '8px Courier New';
    ctx.fillStyle = '#f44';
    ctx.fillText('HP', barX, barY + 8);
    ctx.fillStyle = '#400';
    ctx.fillRect(barX + 16, barY, barW, barH);
    ctx.fillStyle = player.health > 50 ? '#4a8' : player.health > 25 ? '#ea4' : '#f44';
    ctx.fillRect(barX + 16, barY, barW * (player.health / 100), barH);
    ctx.fillStyle = '#fff';
    ctx.fillText(Math.round(player.health), barX + barW + 20, barY + 8);
    // Hunger
    ctx.fillStyle = '#e84';
    ctx.fillText('FD', barX, barY + 22);
    ctx.fillStyle = '#420';
    ctx.fillRect(barX + 16, barY + 14, barW, barH);
    ctx.fillStyle = player.hunger > 50 ? '#ea4' : player.hunger > 25 ? '#e84' : '#f44';
    ctx.fillRect(barX + 16, barY + 14, barW * (player.hunger / 100), barH);
    ctx.fillStyle = '#fff';
    ctx.fillText(Math.round(player.hunger), barX + barW + 20, barY + 22);
    // Tools
    ctx.fillStyle = '#aaa';
    ctx.fillText('Tools:', barX, barY + 36);
    let toolStr = '';
    if (player.tools.axe) toolStr += 'ü™ì';
    if (player.tools.spear) toolStr += 'üî±';
    if (player.hasShelter) toolStr += 'üè†';
    if (player.hasCampfire) toolStr += 'üî•';
    if (!toolStr) toolStr = 'none';
    ctx.fillText(toolStr, barX + 40, barY + 36);

    // Quick inventory (bottom)
    let invY = H - 30;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(W / 2 - 140, invY - 4, 280, 28);
    ctx.strokeStyle = '#4a855';
    ctx.font = '10px Courier New';
    let items = ['wood', 'stone', 'food', 'fiber'];
    let icons = ['ü™µ', 'ü™®', 'üçñ', 'üåø'];
    for (let i = 0; i < 4; i++) {
      let ix = W / 2 - 120 + i * 65;
      ctx.fillStyle = '#aaa';
      ctx.fillText(`${icons[i]} ${items[i]}: `, ix, invY + 12);
      ctx.fillStyle = '#4a8';
      ctx.fillText(player.inventory[items[i]], ix + 55, invY + 12);
    }

    // Inventory panel
    if (showInventory) {
      ctx.fillStyle = 'rgba(10,10,30,0.9)';
      ctx.fillRect(W / 2 - 120, 60, 240, 200);
      ctx.strokeStyle = '#4a8';
      ctx.lineWidth = 2;
      ctx.strokeRect(W / 2 - 120, 60, 240, 200);
      ctx.font = '14px Courier New';
      ctx.fillStyle = '#4a8';
      ctx.fillText('INVENTORY [I]', W / 2 - 55, 82);
      ctx.font = '12px Courier New';
      let iy = 100;
      for (let i = 0; i < 4; i++) {
        ctx.fillStyle = '#aaa';
        ctx.fillText(`${icons[i]} ${items[i].padEnd(6)}: `, W / 2 - 90, iy);
        ctx.fillStyle = '#4a8';
        ctx.fillText(`${player.inventory[items[i]]}`, W / 2 + 30, iy);
        iy += 22;
      }
      iy += 10;
      ctx.fillStyle = '#aaa';
      ctx.fillText('Tools:', W / 2 - 90, iy);
      iy += 20;
      ctx.fillStyle = player.tools.axe ? '#4a8' : '#444';
      ctx.fillText(`ü™ì Axe: ${player.tools.axe ? 'YES' : 'NO'}`, W / 2 - 90, iy);
      iy += 18;
      ctx.fillStyle = player.tools.spear ? '#4a8' : '#444';
      ctx.fillText(`üî± Spear: ${player.tools.spear ? 'YES' : 'NO'}`, W / 2 - 90, iy);
      iy += 18;
      ctx.fillStyle = player.hasShelter ? '#4a8' : '#444';
      ctx.fillText(`üè† Shelter: ${player.hasShelter ? 'YES' : 'NO'}`, W / 2 - 90, iy);
      iy += 18;
      ctx.fillStyle = player.hasCampfire ? '#4a8' : '#444';
      ctx.fillText(`üî• Campfire: ${player.hasCampfire ? 'YES' : 'NO'}`, W / 2 - 90, iy);
    }

    // Craft panel
    if (showCraft) {
      let panelW = 280, panelH = 240;
      let px = W / 2 - panelW / 2, py = 50;
      ctx.fillStyle = 'rgba(10,10,30,0.92)';
      ctx.fillRect(px, py, panelW, panelH);
      ctx.strokeStyle = '#4a8';
      ctx.lineWidth = 2;
      ctx.strokeRect(px, py, panelW, panelH);
      ctx.font = '14px Courier New';
      ctx.fillStyle = '#4a8';
      ctx.fillText('CRAFTING [C]  ‚Üë‚Üì Enter', px + 20, py + 22);
      ctx.font = '11px Courier New';
      let recipeKeys = Object.keys(RECIPES);
      for (let i = 0; i < recipeKeys.length; i++) {
        let ry = py + 40 + i * 38;
        let rk = recipeKeys[i];
        let recipe = RECIPES[rk];
        let can = canCraft(player, rk);
        // Selection highlight
        if (i === craftSelection) {
          ctx.fillStyle = 'rgba(68,170,136,0.15)';
          ctx.fillRect(px + 4, ry - 10, panelW - 8, 36);
          ctx.strokeStyle = '#4a8';
          ctx.lineWidth = 1;
          ctx.strokeRect(px + 4, ry - 10, panelW - 8, 36);
        }
        ctx.fillStyle = can ? '#4a8' : '#555';
        ctx.fillText(`${recipe.name}`, px + 14, ry + 4);
        ctx.fillStyle = can ? '#aaa' : '#444';
        ctx.font = '9px Courier New';
        let ingStr = Object.entries(recipe.ingredients).map(([k, v]) => `${k}:${v}`).join(' ');
        ctx.fillText(ingStr, px + 14, ry + 16);
        ctx.fillStyle = can ? '#6a6' : '#444';
        ctx.fillText(recipe.desc, px + 140, ry + 4);
        ctx.font = '11px Courier New';
        if (can) {
          ctx.fillStyle = '#ff0';
          ctx.fillText('‚úì', px + panelW - 20, ry + 4);
        }
      }
    }

    // Notifications
    for (let i = 0; i < notifications.length; i++) {
      let n = notifications[i];
      ctx.globalAlpha = Math.min(1, n.timer / 40);
      ctx.font = '10px Courier New';
      ctx.fillStyle = n.color;
      ctx.textAlign = 'center';
      ctx.fillText(n.text, W / 2, H - 50 - i * 14);
      ctx.textAlign = 'left';
    }
    ctx.globalAlpha = 1;

    // AI status panel (top-left below health)
    let aiPanelY = 56;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(8, aiPanelY, 130, 3 * 24 + 6);
    ctx.font = '8px Courier New';
    for (let i = 0; i < aiCastaways.length; i++) {
      let ai = aiCastaways[i];
      let ay = aiPanelY + 4 + i * 24;
      ctx.fillStyle = ai.color;
      ctx.fillText(ai.name, 12, ay + 8);
      // Mini health bar
      ctx.fillStyle = '#400';
      ctx.fillRect(55, ay + 2, 40, 5);
      ctx.fillStyle = ai.health > 50 ? '#4a8' : '#f44';
      ctx.fillRect(55, ay + 2, 40 * Math.max(0, ai.health / 100), 5);
      // Status
      ctx.fillStyle = '#888';
      let status = ai.health <= 0 ? 'DEAD' : ai.aiState;
      ctx.fillText(status, 100, ay + 8);
      // Personality
      ctx.fillStyle = ai.personality > 0.6 ? '#f44' : '#4af';
      ctx.fillText(ai.personality > 0.6 ? 'hostile' : 'friendly', 55, ay + 18);
      // Items count
      let total = ai.inventory.wood + ai.inventory.stone + ai.inventory.food + ai.inventory.fiber;
      ctx.fillStyle = '#666';
      ctx.fillText(`${total} items`, 100, ay + 18);
    }
  }

  // ---------- GAME LOOP ----------
  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
  </script>
  <script src="../recorder.js"></script>
</body>
</html>

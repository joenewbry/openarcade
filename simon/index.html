<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simon</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #f6c; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 204, 0.4); }
    h1 { color: #f6c; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 102, 204, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f6c; }
    canvas {
      border: 2px solid #f6c;
      box-shadow: 0 0 20px rgba(255, 102, 204, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f6c;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SIMON</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="450"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:450px;">
      <h2 id="overlayTitle">SIMON</h2>
      <p id="overlayText">Press SPACE or click to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Panel colors: bright (active) and dim (inactive)
    const panels = [
      { // 0 = top-left = Green
        bright: '#4f4',
        dim: '#164016',
        glow: '#4f4',
        key: ['1', 'ArrowUp']
      },
      { // 1 = top-right = Red
        bright: '#f44',
        dim: '#401616',
        glow: '#f44',
        key: ['2', 'ArrowRight']
      },
      { // 2 = bottom-left = Yellow
        bright: '#ff4',
        dim: '#404016',
        glow: '#ff4',
        key: ['3', 'ArrowLeft']
      },
      { // 3 = bottom-right = Blue
        bright: '#44f',
        dim: '#161640',
        glow: '#44f',
        key: ['4', 'ArrowDown']
      }
    ];

    // Panel geometry -- 2x2 grid with gap
    const PAD = 30;         // padding from canvas edges
    const GAP = 16;         // gap between panels
    const PANEL_W = (W - PAD * 2 - GAP) / 2;
    const PANEL_H = (350 - GAP) / 2;  // panels occupy top 350px, bottom 100px for info
    const PANEL_Y_START = 10;
    const CORNER_R = 16;

    function panelRect(i) {
      const col = i % 2;
      const row = Math.floor(i / 2);
      return {
        x: PAD + col * (PANEL_W + GAP),
        y: PANEL_Y_START + row * (PANEL_H + GAP),
        w: PANEL_W,
        h: PANEL_H
      };
    }

    // Game state
    let sequence = [];
    let playerIndex = 0;
    let showIndex = 0;
    let phase = 'idle';  // idle, showing, input, flash-correct, flash-wrong
    let activePanel = -1;
    let flashTimer = 0;
    let showTimer = 0;
    let showDelay = 0;
    let roundDisplay = 0;
    let animFrame = null;
    let lastTime = 0;
    let inputFlashTime = 0;
    const INPUT_FLASH_MS = 200;

    // Timing
    function getShowInterval() {
      // Start at 600ms, speed up to 250ms over 20 rounds
      const base = 600;
      const min = 250;
      const ramp = Math.min(sequence.length / 20, 1);
      return base - ramp * (base - min);
    }

    function getShowPause() {
      // Pause between lights: 150ms, shrinks to 80ms
      const base = 150;
      const min = 80;
      const ramp = Math.min(sequence.length / 20, 1);
      return base - ramp * (base - min);
    }

    // Audio context for tones
    let audioCtx = null;
    const toneFreqs = [329.63, 261.63, 220.00, 164.81]; // E4, C4, A3, E3

    function playTone(panelIdx, duration) {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
      }
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = toneFreqs[panelIdx];
      gain.gain.value = 0.15;
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (duration || 0.3));
      osc.stop(audioCtx.currentTime + (duration || 0.3));
    }

    function playBuzz() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) { return; }
      }
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.value = 80;
      gain.gain.value = 0.2;
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
      osc.stop(audioCtx.currentTime + 0.6);
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      sequence = [];
      playerIndex = 0;
      showIndex = 0;
      phase = 'idle';
      activePanel = -1;
      roundDisplay = 0;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SIMON';
      overlayText.textContent = 'Press SPACE or click to start';
      if (animFrame) cancelAnimationFrame(animFrame);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      sequence = [];
      playerIndex = 0;
      score = 0;
      scoreEl.textContent = '0';
      roundDisplay = 0;
      addToSequence();
      lastTime = performance.now();
      loop(lastTime);
    }

    function addToSequence() {
      sequence.push(Math.floor(Math.random() * 4));
      roundDisplay = sequence.length;
      phase = 'pre-show';
      showIndex = 0;
      activePanel = -1;
      showTimer = 0;
      showDelay = 500; // brief pause before showing sequence
    }

    function gameOver() {
      gameState = 'over';
      phase = 'idle';
      activePanel = -1;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press SPACE or click to restart`;
      if (animFrame) cancelAnimationFrame(animFrame);
      draw();
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function update(dt) {
      if (phase === 'pre-show') {
        showDelay -= dt;
        if (showDelay <= 0) {
          phase = 'showing';
          showIndex = 0;
          showTimer = 0;
          activePanel = sequence[0];
          playTone(activePanel, getShowInterval() / 1000);
        }
        return;
      }

      if (phase === 'showing') {
        showTimer += dt;
        const interval = getShowInterval();
        const pause = getShowPause();

        if (activePanel >= 0) {
          // Currently lighting a panel
          if (showTimer >= interval) {
            activePanel = -1;  // turn off
            showTimer = 0;
          }
        } else {
          // In the pause between panels
          if (showTimer >= pause) {
            showIndex++;
            if (showIndex >= sequence.length) {
              // Done showing sequence, player's turn
              phase = 'input';
              playerIndex = 0;
              activePanel = -1;
            } else {
              activePanel = sequence[showIndex];
              playTone(activePanel, interval / 1000);
              showTimer = 0;
            }
          }
        }
        return;
      }

      if (phase === 'input') {
        // Handle input flash timeout
        if (activePanel >= 0) {
          inputFlashTime += dt;
          if (inputFlashTime >= INPUT_FLASH_MS) {
            activePanel = -1;
          }
        }
        return;
      }

      if (phase === 'flash-correct') {
        flashTimer -= dt;
        if (flashTimer <= 0) {
          // Next round
          addToSequence();
        }
        return;
      }

      if (phase === 'flash-wrong') {
        flashTimer -= dt;
        if (flashTimer <= 0) {
          gameOver();
        }
        return;
      }
    }

    function handlePanelInput(panelIdx) {
      if (gameState !== 'playing' || phase !== 'input') return;
      if (panelIdx < 0 || panelIdx > 3) return;

      // Show the pressed panel
      activePanel = panelIdx;
      inputFlashTime = 0;
      playTone(panelIdx, 0.2);

      if (panelIdx === sequence[playerIndex]) {
        // Correct!
        playerIndex++;
        if (playerIndex >= sequence.length) {
          // Completed the round
          score = sequence.length;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
          phase = 'flash-correct';
          flashTimer = 400;
          activePanel = -1;
        }
      } else {
        // Wrong!
        playBuzz();
        phase = 'flash-wrong';
        flashTimer = 800;
        // Flash all panels red briefly
        activePanel = -1;
      }
    }

    function drawRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw panels
      for (let i = 0; i < 4; i++) {
        const p = panels[i];
        const r = panelRect(i);
        const isActive = (activePanel === i);
        const isWrongFlash = (phase === 'flash-wrong');

        if (isWrongFlash) {
          // Flash all panels with a red tint
          ctx.fillStyle = '#622';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 20;
        } else if (isActive) {
          ctx.fillStyle = p.bright;
          ctx.shadowColor = p.glow;
          ctx.shadowBlur = 30;
        } else {
          ctx.fillStyle = p.dim;
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
        }

        drawRoundedRect(r.x, r.y, r.w, r.h, CORNER_R);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Panel border
        ctx.strokeStyle = isActive ? p.bright : (isWrongFlash ? '#f44' : '#333');
        ctx.lineWidth = isActive ? 3 : 2;
        drawRoundedRect(r.x, r.y, r.w, r.h, CORNER_R);
        ctx.stroke();

        // Panel label (key number)
        ctx.fillStyle = isActive ? '#fff' : '#555';
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const labels = ['1', '2', '3', '4'];
        ctx.fillText(labels[i], r.x + r.w / 2, r.y + r.h / 2);
      }

      // Info area at bottom
      const infoY = PANEL_Y_START + 2 * (PANEL_H + GAP) + 20;

      // Round display
      ctx.fillStyle = '#f6c';
      ctx.shadowColor = '#f6c';
      ctx.shadowBlur = 10;
      ctx.font = 'bold 22px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Round ' + roundDisplay, W / 2, infoY);
      ctx.shadowBlur = 0;

      // Phase indicator
      ctx.fillStyle = '#888';
      ctx.font = '14px Courier New';
      let phaseText = '';
      if (phase === 'pre-show' || phase === 'showing') {
        phaseText = 'Watch...';
      } else if (phase === 'input') {
        phaseText = 'Your turn! (' + playerIndex + '/' + sequence.length + ')';
      } else if (phase === 'flash-correct') {
        phaseText = 'Correct!';
        ctx.fillStyle = '#4f4';
      } else if (phase === 'flash-wrong') {
        phaseText = 'Wrong!';
        ctx.fillStyle = '#f44';
      } else if (gameState === 'waiting') {
        phaseText = 'Click or press 1-4 / arrow keys';
      }
      ctx.fillText(phaseText, W / 2, infoY + 30);

      // Key hints at bottom
      ctx.fillStyle = '#444';
      ctx.font = '12px Courier New';
      ctx.fillText('Keys: 1=Green  2=Red  3=Yellow  4=Blue', W / 2, H - 15);

      // Update gameData for ML
      window.gameData = {
        phase: phase,
        round: roundDisplay,
        sequenceLength: sequence.length,
        playerIndex: playerIndex,
        activePanel: activePanel,
        score: score
      };
    }

    // Keyboard handler
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', '1', '2', '3', '4'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        // Map keys to panels
        let panelIdx = -1;
        if (e.key === '1' || e.key === 'ArrowUp') panelIdx = 0;      // Green (top-left)
        else if (e.key === '2' || e.key === 'ArrowRight') panelIdx = 1; // Red (top-right)
        else if (e.key === '3' || e.key === 'ArrowLeft') panelIdx = 2;  // Yellow (bottom-left)
        else if (e.key === '4' || e.key === 'ArrowDown') panelIdx = 3;  // Blue (bottom-right)

        if (panelIdx >= 0) {
          handlePanelInput(panelIdx);
        }
      }
    });

    // Mouse/click handler
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        // Check which panel was clicked
        for (let i = 0; i < 4; i++) {
          const r = panelRect(i);
          if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
            handlePanelInput(i);
            return;
          }
        }
      }
    });

    // Hover effect - change cursor when over a panel during input phase
    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'playing' || phase !== 'input') {
        canvas.style.cursor = 'pointer';
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);
      let overPanel = false;
      for (let i = 0; i < 4; i++) {
        const r = panelRect(i);
        if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
          overPanel = true;
          break;
        }
      }
      canvas.style.cursor = overPanel ? 'pointer' : 'default';
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

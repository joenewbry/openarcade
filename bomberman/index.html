<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bomberman</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f90; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 153, 0, 0.4); }
    h1 { color: #f90; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 153, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f90; }
    canvas {
      border: 2px solid #f90;
      box-shadow: 0 0 20px rgba(255, 153, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f90;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BOMBERMAN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">BOMBERMAN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid configuration: 15 columns x 15 rows
    const COLS = 15;
    const ROWS = 15;
    const TILE = W / COLS;  // 32px per tile

    // Tile types
    const EMPTY = 0;
    const WALL = 1;       // Indestructible
    const SOFT = 2;       // Destructible block

    // Power-up types
    const PU_BOMB = 'bomb';
    const PU_RANGE = 'range';
    const PU_SPEED = 'speed';

    // Colors
    const THEME = '#f90';
    const BG = '#1a1a2e';
    const GRID_LINE = '#16213e';
    const WALL_COLOR = '#445';
    const WALL_HIGHLIGHT = '#667';
    const SOFT_COLOR = '#8b6914';
    const SOFT_HIGHLIGHT = '#c9a029';

    let score, best = 0, gameState;
    let grid, player, enemies, bombs, explosions, powerups;
    let keys = {};
    let level;
    let lives;
    let lastTime;
    let animFrame;

    // Status bar area at top of canvas
    const STATUS_H = TILE; // one tile row for status

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      level = 1;
      lives = 3;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BOMBERMAN';
      overlayText.textContent = 'Arrows: Move | Space: Bomb\nPress SPACE to start';
      setupLevel();
      draw();
    }

    function setupLevel() {
      grid = [];
      bombs = [];
      explosions = [];
      powerups = [];

      // Build grid
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          // Border walls
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
            grid[r][c] = WALL;
          }
          // Pillar pattern: every other cell inside border
          else if (r % 2 === 0 && c % 2 === 0) {
            grid[r][c] = WALL;
          } else {
            grid[r][c] = EMPTY;
          }
        }
      }

      // Place soft blocks randomly (about 40% of empty cells)
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (grid[r][c] === EMPTY) {
            // Keep player spawn area clear (top-left corner)
            if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) continue;
            if (Math.random() < 0.4 + level * 0.02) {
              grid[r][c] = SOFT;
            }
          }
        }
      }

      // Player setup
      player = {
        x: 1, y: 1,        // grid position
        px: TILE,           // pixel position (for smooth movement)
        py: TILE,
        speed: 2.0 + (level > 3 ? 0.3 : 0),
        maxBombs: 1,
        bombRange: 2,
        activeBombs: 0,
        moving: false,
        dir: 'down',
        animTimer: 0,
        invincible: 0       // invincibility frames after taking damage
      };

      // Enemies
      enemies = [];
      const enemyCount = Math.min(3 + level, 8);
      const emptyCells = [];
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (grid[r][c] === EMPTY) {
            // Keep away from player spawn
            const dist = Math.abs(r - 1) + Math.abs(c - 1);
            if (dist >= 5) {
              emptyCells.push({ r, c });
            }
          }
        }
      }

      // Shuffle and pick enemy positions
      for (let i = emptyCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
      }

      for (let i = 0; i < Math.min(enemyCount, emptyCells.length); i++) {
        const cell = emptyCells[i];
        const speed = 0.8 + Math.random() * 0.4 + level * 0.1;
        enemies.push({
          x: cell.c,
          y: cell.r,
          px: cell.c * TILE,
          py: cell.r * TILE,
          speed: Math.min(speed, 2.5),
          dir: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
          changeTimer: 0,
          changeCooldown: 60 + Math.floor(Math.random() * 120),
          type: i < 2 && level >= 3 ? 'fast' : 'normal',
          animTimer: Math.random() * 100
        });
      }
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      loop();
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;
      if (!timestamp) timestamp = performance.now();
      const dt = Math.min(timestamp - lastTime, 33.33); // cap at ~30fps delta
      lastTime = timestamp;
      update(dt);
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function gridAt(gx, gy) {
      if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return WALL;
      return grid[gy][gx];
    }

    function hasBombAt(gx, gy) {
      return bombs.some(b => b.x === gx && b.y === gy);
    }

    function canWalk(gx, gy, isEnemy) {
      if (gridAt(gx, gy) !== EMPTY) return false;
      if (isEnemy && hasBombAt(gx, gy)) return false;
      return true;
    }

    function update(dt) {
      const step = dt / 16.67; // normalize to ~60fps

      // Update player invincibility
      if (player.invincible > 0) player.invincible -= step;

      // Player movement
      updatePlayer(step);

      // Update enemies
      updateEnemies(step);

      // Update bombs
      updateBombs(step);

      // Update explosions
      updateExplosions(step);

      // Check if player hits enemy
      checkPlayerEnemyCollision();

      // Check if level complete
      if (enemies.length === 0) {
        score += 100 * level;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        level++;
        setupLevel();
      }
    }

    function updatePlayer(step) {
      let dx = 0, dy = 0;
      if (keys['ArrowLeft']) { dx = -1; player.dir = 'left'; }
      else if (keys['ArrowRight']) { dx = 1; player.dir = 'right'; }
      else if (keys['ArrowUp']) { dy = -1; player.dir = 'up'; }
      else if (keys['ArrowDown']) { dy = 1; player.dir = 'down'; }

      player.moving = (dx !== 0 || dy !== 0);
      if (player.moving) player.animTimer += step;

      if (dx !== 0 || dy !== 0) {
        const speed = player.speed * step;
        const newPx = player.px + dx * speed;
        const newPy = player.py + dy * speed;

        // Calculate grid alignment with some tolerance for turning corners
        const margin = TILE * 0.35;

        if (dx !== 0) {
          // Moving horizontally: snap to grid row, check horizontal collision
          const alignedY = Math.round(player.py / TILE) * TILE;
          const diffY = Math.abs(player.py - alignedY);
          if (diffY < margin) {
            player.py = alignedY; // snap
            const targetGy = Math.round(player.py / TILE);
            const checkGx = dx > 0 ? Math.floor((newPx + TILE - 1) / TILE) : Math.floor(newPx / TILE);
            if (canWalk(checkGx, targetGy, false)) {
              player.px = newPx;
            }
          }
        }

        if (dy !== 0) {
          // Moving vertically: snap to grid column, check vertical collision
          const alignedX = Math.round(player.px / TILE) * TILE;
          const diffX = Math.abs(player.px - alignedX);
          if (diffX < margin) {
            player.px = alignedX; // snap
            const targetGx = Math.round(player.px / TILE);
            const checkGy = dy > 0 ? Math.floor((newPy + TILE - 1) / TILE) : Math.floor(newPy / TILE);
            if (canWalk(targetGx, checkGy, false)) {
              player.py = newPy;
            }
          }
        }

        // Clamp to bounds
        player.px = Math.max(TILE, Math.min((COLS - 2) * TILE, player.px));
        player.py = Math.max(TILE, Math.min((ROWS - 2) * TILE, player.py));

        // Update grid position
        player.x = Math.round(player.px / TILE);
        player.y = Math.round(player.py / TILE);
      }
    }

    function updateEnemies(step) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.animTimer += step;
        e.changeTimer += step;

        const speed = e.speed * step;
        let dx = 0, dy = 0;

        switch (e.dir) {
          case 'left': dx = -1; break;
          case 'right': dx = 1; break;
          case 'up': dy = -1; break;
          case 'down': dy = 1; break;
        }

        // Try to move
        const newPx = e.px + dx * speed;
        const newPy = e.py + dy * speed;

        // Check alignment and collision
        let blocked = false;

        if (dx !== 0) {
          const alignedY = Math.round(e.py / TILE) * TILE;
          e.py = alignedY;
          const gy = Math.round(e.py / TILE);
          const checkGx = dx > 0 ? Math.floor((newPx + TILE - 1) / TILE) : Math.floor(newPx / TILE);
          if (canWalk(checkGx, gy, true)) {
            e.px = newPx;
          } else {
            blocked = true;
            e.px = Math.round(e.px / TILE) * TILE;
          }
        }

        if (dy !== 0) {
          const alignedX = Math.round(e.px / TILE) * TILE;
          e.px = alignedX;
          const gx = Math.round(e.px / TILE);
          const checkGy = dy > 0 ? Math.floor((newPy + TILE - 1) / TILE) : Math.floor(newPy / TILE);
          if (canWalk(gx, checkGy, true)) {
            e.py = newPy;
          } else {
            blocked = true;
            e.py = Math.round(e.py / TILE) * TILE;
          }
        }

        // Update grid position
        e.x = Math.round(e.px / TILE);
        e.y = Math.round(e.py / TILE);

        // Change direction on block or periodically
        if (blocked || e.changeTimer >= e.changeCooldown) {
          e.changeTimer = 0;
          const dirs = ['up', 'down', 'left', 'right'].filter(d => d !== e.dir);
          // Prefer directions that are walkable
          const walkable = dirs.filter(d => {
            let nx = e.x, ny = e.y;
            switch (d) {
              case 'left': nx--; break;
              case 'right': nx++; break;
              case 'up': ny--; break;
              case 'down': ny++; break;
            }
            return canWalk(nx, ny, true);
          });
          if (walkable.length > 0) {
            e.dir = walkable[Math.floor(Math.random() * walkable.length)];
          } else {
            e.dir = dirs[Math.floor(Math.random() * dirs.length)];
          }
          e.changeCooldown = 40 + Math.floor(Math.random() * 100);
        }
      }
    }

    function placeBomb() {
      if (player.activeBombs >= player.maxBombs) return;
      const bx = player.x;
      const by = player.y;
      if (hasBombAt(bx, by)) return;

      bombs.push({
        x: bx,
        y: by,
        timer: 120, // ~2 seconds at 60fps
        range: player.bombRange,
        owner: 'player',
        pulseTimer: 0
      });
      player.activeBombs++;
    }

    function updateBombs(step) {
      for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        b.timer -= step;
        b.pulseTimer += step;
        if (b.timer <= 0) {
          explodeBomb(i);
        }
      }
    }

    function explodeBomb(index) {
      const b = bombs[index];
      bombs.splice(index, 1);
      if (b.owner === 'player') player.activeBombs--;

      // Create explosion at bomb center
      addExplosion(b.x, b.y, 'center');

      // Expand in 4 directions
      const dirs = [
        { dx: 0, dy: -1 }, // up
        { dx: 0, dy: 1 },  // down
        { dx: -1, dy: 0 }, // left
        { dx: 1, dy: 0 }   // right
      ];

      for (const d of dirs) {
        for (let dist = 1; dist <= b.range; dist++) {
          const ex = b.x + d.dx * dist;
          const ey = b.y + d.dy * dist;

          if (gridAt(ex, ey) === WALL) break;

          if (gridAt(ex, ey) === SOFT) {
            // Destroy soft block
            grid[ey][ex] = EMPTY;
            score += 10;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }

            // Maybe drop power-up
            if (Math.random() < 0.3) {
              const types = [PU_BOMB, PU_RANGE, PU_SPEED];
              powerups.push({
                x: ex,
                y: ey,
                type: types[Math.floor(Math.random() * types.length)],
                timer: 600 // disappears after ~10 seconds
              });
            }

            addExplosion(ex, ey, dist === b.range ? 'end' : 'mid');
            break; // explosion stops at soft block
          }

          addExplosion(ex, ey, dist === b.range ? 'end' : 'mid');

          // Chain reaction: if explosion hits another bomb, detonate it
          const chainIdx = bombs.findIndex(ob => ob.x === ex && ob.y === ey);
          if (chainIdx !== -1) {
            explodeBomb(chainIdx);
          }
        }
      }
    }

    function addExplosion(gx, gy, part) {
      // Check if explosion already exists at this position
      if (explosions.some(e => e.x === gx && e.y === gy)) return;

      explosions.push({
        x: gx,
        y: gy,
        timer: 30, // lasts ~0.5 seconds
        part: part
      });

      // Kill enemies in explosion
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].x === gx && enemies[i].y === gy) {
          enemies.splice(i, 1);
          score += 50;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
        }
      }

      // Kill player in explosion
      if (player.x === gx && player.y === gy && player.invincible <= 0) {
        playerHit();
      }
    }

    function updateExplosions(step) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].timer -= step;
        if (explosions[i].timer <= 0) {
          explosions.splice(i, 1);
        }
      }

      // Check if player walks into active explosion
      for (const exp of explosions) {
        if (player.x === exp.x && player.y === exp.y && player.invincible <= 0) {
          playerHit();
        }
      }

      // Check if enemies walk into active explosion
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (const exp of explosions) {
          if (enemies[i] && enemies[i].x === exp.x && enemies[i].y === exp.y) {
            enemies.splice(i, 1);
            score += 50;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            break;
          }
        }
      }

      // Power-up collection
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        pu.timer -= step;
        if (pu.timer <= 0) {
          powerups.splice(i, 1);
          continue;
        }
        if (player.x === pu.x && player.y === pu.y) {
          applyPowerUp(pu.type);
          powerups.splice(i, 1);
        }
      }
    }

    function applyPowerUp(type) {
      switch (type) {
        case PU_BOMB:
          player.maxBombs = Math.min(player.maxBombs + 1, 5);
          break;
        case PU_RANGE:
          player.bombRange = Math.min(player.bombRange + 1, 6);
          break;
        case PU_SPEED:
          player.speed = Math.min(player.speed + 0.4, 3.5);
          break;
      }
      score += 20;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
    }

    function playerHit() {
      if (player.invincible > 0) return;
      lives--;
      if (lives <= 0) {
        gameOver();
      } else {
        // Respawn at start with brief invincibility
        player.x = 1;
        player.y = 1;
        player.px = TILE;
        player.py = TILE;
        player.invincible = 120; // 2 seconds of invincibility
      }
    }

    function checkPlayerEnemyCollision() {
      if (player.invincible > 0) return;
      for (const e of enemies) {
        const dx = Math.abs(player.px - e.px);
        const dy = Math.abs(player.py - e.py);
        if (dx < TILE * 0.7 && dy < TILE * 0.7) {
          playerHit();
          return;
        }
      }
    }

    function gameOver() {
      gameState = 'over';
      if (animFrame) cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Level: ${level}\nPress any key to restart`;
    }

    // ---- DRAWING ----

    function draw() {
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      drawGrid();
      drawPowerUps();
      drawBombs();
      drawExplosions();
      drawEnemies();
      drawPlayer();
      drawHUD();
    }

    function drawGrid() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = c * TILE;
          const y = r * TILE;
          const tile = grid[r][c];

          if (tile === WALL) {
            // Indestructible wall - dark gray bricks
            ctx.fillStyle = WALL_COLOR;
            ctx.fillRect(x, y, TILE, TILE);
            // Brick pattern
            ctx.fillStyle = WALL_HIGHLIGHT;
            ctx.fillRect(x + 1, y + 1, TILE - 2, TILE / 2 - 1);
            ctx.fillRect(x + 1, y + TILE / 2 + 1, TILE - 2, TILE / 2 - 2);
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y + TILE / 2 - 1, TILE, 2);
            ctx.fillRect(x + TILE / 2, y, 2, TILE / 2 - 1);
            ctx.fillRect(x + TILE / 4, y + TILE / 2 + 1, 2, TILE / 2 - 2);
          } else if (tile === SOFT) {
            // Destructible block - brownish
            ctx.fillStyle = SOFT_COLOR;
            ctx.fillRect(x + 1, y + 1, TILE - 2, TILE - 2);
            ctx.fillStyle = SOFT_HIGHLIGHT;
            ctx.fillRect(x + 3, y + 3, TILE - 6, 3);
            ctx.fillRect(x + 3, y + 3, 3, TILE - 6);
            ctx.fillStyle = '#6b4f10';
            ctx.fillRect(x + TILE - 5, y + 4, 2, TILE - 8);
            ctx.fillRect(x + 4, y + TILE - 5, TILE - 8, 2);
          } else {
            // Empty - dark floor with subtle grid
            ctx.fillStyle = '#12122a';
            ctx.fillRect(x, y, TILE, TILE);
            ctx.strokeStyle = GRID_LINE;
            ctx.lineWidth = 0.5;
            ctx.strokeRect(x, y, TILE, TILE);
          }
        }
      }
    }

    function drawPlayer() {
      const x = player.px;
      const y = player.py;
      const s = TILE;
      const flash = player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0;

      if (flash) {
        ctx.globalAlpha = 0.4;
      }

      // Body (white/light colored character)
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#f90';
      ctx.shadowBlur = 8;
      // Head
      ctx.beginPath();
      ctx.arc(x + s / 2, y + s * 0.3, s * 0.25, 0, Math.PI * 2);
      ctx.fill();
      // Body
      ctx.fillRect(x + s * 0.25, y + s * 0.45, s * 0.5, s * 0.35);
      ctx.shadowBlur = 0;

      // Eyes
      ctx.fillStyle = '#222';
      const eyeOffset = player.dir === 'left' ? -2 : player.dir === 'right' ? 2 : 0;
      const eyeYOffset = player.dir === 'up' ? -1 : player.dir === 'down' ? 1 : 0;
      ctx.fillRect(x + s * 0.38 + eyeOffset, y + s * 0.25 + eyeYOffset, 3, 3);
      ctx.fillRect(x + s * 0.55 + eyeOffset, y + s * 0.25 + eyeYOffset, 3, 3);

      // Feet animation
      const walkPhase = Math.sin(player.animTimer * 0.3);
      ctx.fillStyle = '#f90';
      if (player.moving) {
        ctx.fillRect(x + s * 0.28, y + s * 0.78 + walkPhase * 2, s * 0.18, s * 0.12);
        ctx.fillRect(x + s * 0.54, y + s * 0.78 - walkPhase * 2, s * 0.18, s * 0.12);
      } else {
        ctx.fillRect(x + s * 0.28, y + s * 0.78, s * 0.18, s * 0.12);
        ctx.fillRect(x + s * 0.54, y + s * 0.78, s * 0.18, s * 0.12);
      }

      ctx.globalAlpha = 1.0;
    }

    function drawEnemies() {
      for (const e of enemies) {
        const x = e.px;
        const y = e.py;
        const s = TILE;
        const bob = Math.sin(e.animTimer * 0.15) * 2;

        if (e.type === 'fast') {
          // Fast enemy: reddish, angular
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
        } else {
          // Normal enemy: purple-ish
          ctx.fillStyle = '#a4f';
          ctx.shadowColor = '#a4f';
        }
        ctx.shadowBlur = 8;

        // Ghost-like body
        ctx.beginPath();
        ctx.arc(x + s / 2, y + s * 0.35 + bob, s * 0.3, Math.PI, 0);
        ctx.lineTo(x + s * 0.8, y + s * 0.75 + bob);
        // Wavy bottom
        const wavePhase = e.animTimer * 0.2;
        for (let i = 0; i < 4; i++) {
          const wx = x + s * 0.8 - (i * s * 0.15);
          const wy = y + s * 0.75 + bob + Math.sin(wavePhase + i * 1.5) * 3;
          ctx.lineTo(wx, wy);
        }
        ctx.lineTo(x + s * 0.2, y + s * 0.75 + bob);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x + s * 0.37, y + s * 0.33 + bob, 4, 0, Math.PI * 2);
        ctx.arc(x + s * 0.63, y + s * 0.33 + bob, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#222';
        const lookDx = e.dir === 'left' ? -1 : e.dir === 'right' ? 1 : 0;
        const lookDy = e.dir === 'up' ? -1 : e.dir === 'down' ? 1 : 0;
        ctx.beginPath();
        ctx.arc(x + s * 0.37 + lookDx * 2, y + s * 0.33 + bob + lookDy * 1, 2, 0, Math.PI * 2);
        ctx.arc(x + s * 0.63 + lookDx * 2, y + s * 0.33 + bob + lookDy * 1, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawBombs() {
      for (const b of bombs) {
        const x = b.x * TILE;
        const y = b.y * TILE;
        const s = TILE;
        const pulse = 1.0 + Math.sin(b.pulseTimer * 0.3) * 0.1;
        const urgency = b.timer < 30 ? 1.0 + Math.sin(b.pulseTimer * 0.8) * 0.15 : 1.0;
        const r = s * 0.35 * pulse * urgency;

        // Bomb body
        ctx.fillStyle = '#333';
        ctx.shadowColor = b.timer < 30 ? '#f44' : '#f90';
        ctx.shadowBlur = b.timer < 30 ? 15 : 8;
        ctx.beginPath();
        ctx.arc(x + s / 2, y + s / 2 + 2, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Highlight
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(x + s / 2 - 3, y + s / 2 - 2, r * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Fuse
        ctx.strokeStyle = b.timer < 30 ? '#f44' : '#f90';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + s / 2, y + s / 2 - r);
        ctx.quadraticCurveTo(x + s / 2 + 5, y + s / 2 - r - 6, x + s / 2 + 3, y + s / 2 - r - 10);
        ctx.stroke();

        // Spark at fuse tip
        if (Math.random() > 0.3) {
          ctx.fillStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(x + s / 2 + 3 + Math.random() * 3, y + s / 2 - r - 10 + Math.random() * 3, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawExplosions() {
      for (const exp of explosions) {
        const x = exp.x * TILE;
        const y = exp.y * TILE;
        const s = TILE;
        const alpha = Math.min(1, exp.timer / 15);
        const intensity = exp.timer / 30;

        // Outer glow
        ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.4})`;
        ctx.shadowColor = '#f90';
        ctx.shadowBlur = 20 * intensity;
        ctx.fillRect(x - 2, y - 2, s + 4, s + 4);
        ctx.shadowBlur = 0;

        // Inner fire
        ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.8})`;
        ctx.fillRect(x + 2, y + 2, s - 4, s - 4);

        // Hot core
        ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.6})`;
        ctx.fillRect(x + s * 0.25, y + s * 0.25, s * 0.5, s * 0.5);
      }
    }

    function drawPowerUps() {
      for (const pu of powerups) {
        const x = pu.x * TILE;
        const y = pu.y * TILE;
        const s = TILE;
        const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;

        // Blinking when about to expire
        if (pu.timer < 120 && Math.floor(pu.timer / 8) % 2 === 0) continue;

        ctx.shadowBlur = 10;

        switch (pu.type) {
          case PU_BOMB:
            // Extra bomb: blue circle with B
            ctx.fillStyle = '#4af';
            ctx.shadowColor = '#4af';
            ctx.beginPath();
            ctx.arc(x + s / 2, y + s / 2, s * 0.3 * pulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('B', x + s / 2, y + s / 2);
            break;

          case PU_RANGE:
            // Range up: red diamond with R
            ctx.fillStyle = '#f44';
            ctx.shadowColor = '#f44';
            ctx.save();
            ctx.translate(x + s / 2, y + s / 2);
            ctx.rotate(Math.PI / 4);
            ctx.fillRect(-s * 0.22 * pulse, -s * 0.22 * pulse, s * 0.44 * pulse, s * 0.44 * pulse);
            ctx.restore();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('R', x + s / 2, y + s / 2);
            break;

          case PU_SPEED:
            // Speed up: green triangle with S
            ctx.fillStyle = '#4f4';
            ctx.shadowColor = '#4f4';
            ctx.beginPath();
            const sz = s * 0.35 * pulse;
            ctx.moveTo(x + s / 2, y + s / 2 - sz);
            ctx.lineTo(x + s / 2 + sz, y + s / 2 + sz * 0.7);
            ctx.lineTo(x + s / 2 - sz, y + s / 2 + sz * 0.7);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('S', x + s / 2, y + s / 2 + 2);
            break;
        }
        ctx.shadowBlur = 0;
      }
    }

    function drawHUD() {
      // Draw lives and level info at top of canvas, over the wall border
      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(0, 0, W, TILE);

      ctx.fillStyle = '#f90';
      ctx.font = 'bold 13px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      // Lives
      let livesText = 'Lives: ';
      ctx.fillText(livesText, 6, TILE / 2);
      const lvOff = ctx.measureText(livesText).width + 6;
      for (let i = 0; i < lives; i++) {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(lvOff + i * 18 + 6, TILE / 2, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Level
      ctx.fillStyle = '#f90';
      ctx.textAlign = 'center';
      ctx.fillText(`Level ${level}`, W / 2, TILE / 2);

      // Power-up status
      ctx.textAlign = 'right';
      ctx.fillStyle = '#aaa';
      ctx.font = '11px Courier New';
      const statusParts = [];
      if (player) {
        statusParts.push(`B:${player.maxBombs}`);
        statusParts.push(`R:${player.bombRange}`);
      }
      ctx.fillText(statusParts.join(' | '), W - 6, TILE / 2);
    }

    // ---- INPUT ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
        if (e.key === ' ') {
          placeBomb();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

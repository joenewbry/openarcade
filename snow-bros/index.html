<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snow Bros</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #6fe; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102, 255, 238, 0.5); }
    h1 { color: #6fe; font-size: 2rem; text-shadow: 0 0 15px rgba(102, 255, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #6fe; }
    canvas {
      border: 2px solid #6fe;
      box-shadow: 0 0 20px rgba(102, 255, 238, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6fe;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SNOW BROS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">SNOW BROS</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // ── Constants ─────────────────────────────────────────────
    const GRAVITY = 0.45;
    const TILE = 32;
    const COLS = 15;   // 480 / 32
    const ROWS = 17;   // ~544 usable, bottom row = floor at 17*32=544
    const PLAYER_W = 24;
    const PLAYER_H = 28;
    const PLAYER_SPEED = 3;
    const JUMP_FORCE = -8.5;
    const SNOW_SPEED = 5;
    const SNOW_LIFETIME = 40; // frames before snow projectile dies
    const SNOWBALL_ROLL_SPEED = 6;
    const MAX_SNOW_HITS = 4; // hits to fully encase enemy
    const LIVES_START = 3;

    // ── Level layouts ─────────────────────────────────────────
    // Each level is an array of platform definitions: [x_tile, y_tile, width_tiles]
    // Platforms are solid from above (player stands on them) and passable from below
    const LEVEL_LAYOUTS = [
      // Level 1: Simple symmetric platforms
      [
        [0, 15, 15],   // ground floor
        [0, 12, 5], [10, 12, 5],
        [3, 9, 9],
        [0, 6, 5], [10, 6, 5],
        [4, 3, 7],
      ],
      // Level 2: Staircase
      [
        [0, 15, 15],
        [0, 13, 4], [11, 13, 4],
        [2, 11, 4], [9, 11, 4],
        [0, 9, 5], [10, 9, 5],
        [4, 7, 7],
        [1, 5, 4], [10, 5, 4],
        [5, 3, 5],
      ],
      // Level 3: Narrow gaps
      [
        [0, 15, 15],
        [0, 13, 3], [5, 13, 5], [12, 13, 3],
        [1, 11, 4], [8, 11, 5],
        [0, 9, 6], [9, 9, 6],
        [3, 7, 3], [8, 7, 3],
        [0, 5, 4], [11, 5, 4],
        [5, 3, 5],
      ],
      // Level 4: Dense platforms
      [
        [0, 15, 15],
        [1, 13, 3], [6, 13, 3], [11, 13, 3],
        [0, 11, 4], [5, 11, 5], [11, 11, 4],
        [2, 9, 3], [7, 9, 3], [11, 9, 3],
        [0, 7, 5], [10, 7, 5],
        [3, 5, 4], [8, 5, 4],
        [5, 3, 5],
      ],
      // Level 5: Wide open
      [
        [0, 15, 15],
        [0, 12, 4], [11, 12, 4],
        [4, 10, 7],
        [0, 8, 3], [12, 8, 3],
        [2, 6, 11],
        [0, 4, 4], [11, 4, 4],
        [5, 2, 5],
      ],
    ];

    // Enemy spawn definitions per level: [{x_tile, y_tile, type}]
    const LEVEL_ENEMIES = [
      // Level 1: 4 basic enemies
      [
        {x: 1, y: 11, type: 'basic'},
        {x: 13, y: 11, type: 'basic'},
        {x: 6, y: 8, type: 'basic'},
        {x: 1, y: 5, type: 'basic'},
      ],
      // Level 2: 5 enemies with a fast one
      [
        {x: 1, y: 12, type: 'basic'},
        {x: 13, y: 12, type: 'basic'},
        {x: 3, y: 10, type: 'basic'},
        {x: 11, y: 4, type: 'fast'},
        {x: 6, y: 2, type: 'basic'},
      ],
      // Level 3: 6 enemies with fast
      [
        {x: 1, y: 12, type: 'basic'},
        {x: 13, y: 12, type: 'fast'},
        {x: 6, y: 12, type: 'basic'},
        {x: 2, y: 10, type: 'basic'},
        {x: 10, y: 8, type: 'fast'},
        {x: 6, y: 2, type: 'basic'},
      ],
      // Level 4: 7 enemies with tough
      [
        {x: 2, y: 12, type: 'basic'},
        {x: 7, y: 12, type: 'tough'},
        {x: 12, y: 12, type: 'basic'},
        {x: 1, y: 10, type: 'fast'},
        {x: 7, y: 10, type: 'basic'},
        {x: 12, y: 10, type: 'fast'},
        {x: 6, y: 2, type: 'tough'},
      ],
      // Level 5: 8 mixed enemies
      [
        {x: 1, y: 11, type: 'fast'},
        {x: 13, y: 11, type: 'fast'},
        {x: 6, y: 9, type: 'tough'},
        {x: 1, y: 7, type: 'basic'},
        {x: 13, y: 7, type: 'basic'},
        {x: 4, y: 5, type: 'tough'},
        {x: 10, y: 5, type: 'fast'},
        {x: 7, y: 1, type: 'tough'},
      ],
    ];

    // Enemy type definitions
    const ENEMY_TYPES = {
      basic: { color: '#f66', speed: 1.2, jumpChance: 0.008, points: 100 },
      fast:  { color: '#ff0', speed: 2.2, jumpChance: 0.015, points: 200 },
      tough: { color: '#f80', speed: 1.5, jumpChance: 0.01,  points: 300 },
    };

    // ── Game state ────────────────────────────────────────────
    let player, enemies, snowballs, rollingBalls, particles, platforms;
    let level, lives, keys, tick;
    let levelTransition, levelTransitionTimer;
    let invincibleTimer;

    function init() {
      score = 0;
      level = 1;
      lives = LIVES_START;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SNOW BROS';
      overlayText.textContent = 'Press SPACE to start';
      keys = {};
      tick = 0;
      levelTransition = false;
      levelTransitionTimer = 0;
      invincibleTimer = 0;
      loadLevel(level);
      draw();
    }

    function loadLevel(lvl) {
      const layoutIndex = (lvl - 1) % LEVEL_LAYOUTS.length;
      const enemyIndex = (lvl - 1) % LEVEL_ENEMIES.length;

      // Build platforms
      platforms = [];
      const layout = LEVEL_LAYOUTS[layoutIndex];
      layout.forEach(([tx, ty, tw]) => {
        platforms.push({
          x: tx * TILE,
          y: ty * TILE,
          w: tw * TILE,
          h: TILE,
          isGround: ty === 15
        });
      });

      // Add walls (thin invisible platforms on sides)
      // We handle walls in movement logic instead

      // Spawn enemies with difficulty scaling
      enemies = [];
      const enemyDefs = LEVEL_ENEMIES[enemyIndex];
      const speedMult = 1 + (lvl - 1) * 0.12;
      enemyDefs.forEach(def => {
        const et = ENEMY_TYPES[def.type];
        enemies.push({
          x: def.x * TILE,
          y: def.y * TILE - 24,
          w: 22,
          h: 24,
          vx: (Math.random() > 0.5 ? 1 : -1) * et.speed * speedMult,
          vy: 0,
          type: def.type,
          color: et.color,
          speed: et.speed * speedMult,
          jumpChance: et.jumpChance,
          points: et.points + (lvl - 1) * 10,
          snowHits: 0,      // how many snow hits received
          encased: false,    // fully encased in snowball
          encaseTimer: 0,    // timer before enemy breaks free
          alive: true,
          onGround: false,
          facing: 1,
          animFrame: 0,
        });
      });

      // Reset projectiles
      snowballs = [];
      rollingBalls = [];
      particles = [];

      // Spawn player
      player = {
        x: 7 * TILE,
        y: 14 * TILE - PLAYER_H,
        w: PLAYER_W,
        h: PLAYER_H,
        vx: 0,
        vy: 0,
        onGround: false,
        facing: 1,
        shooting: false,
        shootCooldown: 0,
        animFrame: 0,
      };
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      invincibleTimer = 60;
      loop();
    }

    function loop() {
      if (gameState !== 'playing') return;
      tick++;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── Collision helpers ─────────────────────────────────────
    function rectOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x &&
             a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function isOnPlatform(entity) {
      const footY = entity.y + entity.h;
      const footL = entity.x + 2;
      const footR = entity.x + entity.w - 2;
      for (const p of platforms) {
        if (footY >= p.y && footY <= p.y + 6 &&
            footR > p.x && footL < p.x + p.w &&
            entity.vy >= 0) {
          return p;
        }
      }
      return null;
    }

    function resolveVertical(entity) {
      if (entity.vy >= 0) {
        const plat = isOnPlatform(entity);
        if (plat) {
          entity.y = plat.y - entity.h;
          entity.vy = 0;
          entity.onGround = true;
          return;
        }
      }
      entity.onGround = false;
    }

    // ── Update ────────────────────────────────────────────────
    function update() {
      // Level transition
      if (levelTransition) {
        levelTransitionTimer--;
        if (levelTransitionTimer <= 0) {
          levelTransition = false;
          level++;
          levelEl.textContent = level;
          loadLevel(level);
          invincibleTimer = 60;
        }
        return;
      }

      if (invincibleTimer > 0) invincibleTimer--;

      updatePlayer();
      updateSnowballs();
      updateRollingBalls();
      updateEnemies();
      updateParticles();
      checkLevelComplete();

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        enemies: enemies.filter(e => e.alive).map(e => ({x: e.x, y: e.y, encased: e.encased})),
        level: level,
      };
    }

    function updatePlayer() {
      // Horizontal movement
      if (keys['ArrowLeft']) {
        player.vx = -PLAYER_SPEED;
        player.facing = -1;
      } else if (keys['ArrowRight']) {
        player.vx = PLAYER_SPEED;
        player.facing = 1;
      } else {
        player.vx = 0;
      }

      // Jump
      if ((keys['ArrowUp'] || keys['z'] || keys['Z']) && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
      }

      // Apply gravity
      player.vy += GRAVITY;
      if (player.vy > 10) player.vy = 10;

      // Move horizontally
      player.x += player.vx;

      // Wall boundaries (wrap around)
      if (player.x + player.w < 0) player.x = W;
      if (player.x > W) player.x = -player.w;

      // Move vertically
      player.y += player.vy;

      // Floor
      if (player.y + player.h > H) {
        player.y = H - player.h;
        player.vy = 0;
        player.onGround = true;
      }

      // Platform collision
      resolveVertical(player);

      // Ceiling
      if (player.y < 0) {
        player.y = 0;
        player.vy = 0;
      }

      // Shooting
      if (player.shootCooldown > 0) player.shootCooldown--;
      if (keys[' '] && player.shootCooldown <= 0) {
        shootSnow();
        player.shootCooldown = 12;
      }

      player.animFrame = (tick >> 3) & 1;
    }

    function shootSnow() {
      snowballs.push({
        x: player.x + (player.facing === 1 ? player.w : -8),
        y: player.y + 6,
        vx: SNOW_SPEED * player.facing,
        vy: 0,
        life: SNOW_LIFETIME,
        w: 10,
        h: 10,
      });
    }

    function updateSnowballs() {
      for (let i = snowballs.length - 1; i >= 0; i--) {
        const s = snowballs[i];
        s.x += s.vx;
        s.life--;

        // Remove if off screen or expired
        if (s.life <= 0 || s.x < -20 || s.x > W + 20) {
          snowballs.splice(i, 1);
          continue;
        }

        // Check hit against enemies
        let hitEnemy = false;
        for (const e of enemies) {
          if (!e.alive || e.encased) continue;
          if (rectOverlap(s, e)) {
            e.snowHits++;
            spawnSnowPuff(s.x, s.y);
            if (e.snowHits >= MAX_SNOW_HITS) {
              e.encased = true;
              e.encaseTimer = 300 + Math.floor(Math.random() * 120); // ~5-7 seconds to break free
              e.vx = 0;
              e.vy = 0;
            }
            hitEnemy = true;
            break;
          }
        }
        if (hitEnemy) {
          snowballs.splice(i, 1);
        }
      }
    }

    function updateRollingBalls() {
      for (let i = rollingBalls.length - 1; i >= 0; i--) {
        const rb = rollingBalls[i];
        rb.x += rb.vx;
        rb.vy += GRAVITY;
        if (rb.vy > 12) rb.vy = 12;
        rb.y += rb.vy;

        // Platform collision for rolling balls
        const footY = rb.y + rb.h;
        for (const p of platforms) {
          if (footY >= p.y && footY <= p.y + 8 &&
              rb.x + rb.w > p.x && rb.x < p.x + p.w &&
              rb.vy >= 0) {
            rb.y = p.y - rb.h;
            rb.vy = 0;
            break;
          }
        }

        // Floor
        if (rb.y + rb.h > H) {
          rb.y = H - rb.h;
          rb.vy = -4; // bounce a little
        }

        // Wrap around walls
        if (rb.x + rb.w < 0) rb.x = W;
        if (rb.x > W) rb.x = -rb.w;

        rb.life--;
        rb.rotation += rb.vx * 0.1;

        // Check collision with other enemies
        for (const e of enemies) {
          if (!e.alive) continue;
          if (e === rb.sourceEnemy && rb.life > 160) continue; // grace period
          if (rectOverlap(rb, e)) {
            // Kill the enemy
            e.alive = false;
            rb.chainCount++;
            const chainBonus = rb.chainCount * rb.chainCount * 100;
            score += e.points + chainBonus;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color);
            spawnScorePopup(e.x, e.y, e.points + chainBonus);
          }
        }

        // Remove if expired
        if (rb.life <= 0) {
          // Kill the encased enemy
          if (rb.sourceEnemy && rb.sourceEnemy.alive) {
            rb.sourceEnemy.alive = false;
            score += rb.sourceEnemy.points;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
            spawnExplosion(rb.x + rb.w / 2, rb.y + rb.h / 2, '#6fe');
          }
          rollingBalls.splice(i, 1);
        }
      }
    }

    function updateEnemies() {
      for (const e of enemies) {
        if (!e.alive) continue;

        if (e.encased) {
          // Encased enemies just sit there with a timer
          e.encaseTimer--;
          e.vy += GRAVITY;
          if (e.vy > 10) e.vy = 10;
          e.y += e.vy;
          resolveVertical(e);

          // Floor
          if (e.y + e.h > H) {
            e.y = H - e.h;
            e.vy = 0;
            e.onGround = true;
          }

          // Check if player kicks this snowball
          if (rectOverlap(player, e) && invincibleTimer <= 0) {
            // Kick the snowball!
            kickSnowball(e);
            continue;
          }

          // Break free
          if (e.encaseTimer <= 0) {
            e.encased = false;
            e.snowHits = 0;
            e.vx = (Math.random() > 0.5 ? 1 : -1) * e.speed;
            invincibleTimer = 10;
          }
          continue;
        }

        // AI movement
        e.animFrame = (tick >> 4) & 1;

        // Apply gravity
        e.vy += GRAVITY;
        if (e.vy > 10) e.vy = 10;

        // Horizontal movement
        e.x += e.vx;
        e.facing = e.vx > 0 ? 1 : -1;

        // Wrap around walls
        if (e.x + e.w < 0) e.x = W;
        if (e.x > W) e.x = -e.w;

        // Vertical
        e.y += e.vy;

        // Floor
        if (e.y + e.h > H) {
          e.y = H - e.h;
          e.vy = 0;
          e.onGround = true;
        }

        resolveVertical(e);

        // Edge detection: reverse at platform edges
        if (e.onGround) {
          const aheadX = e.vx > 0 ? e.x + e.w + 2 : e.x - 2;
          const footY = e.y + e.h + 2;
          let onEdge = true;
          for (const p of platforms) {
            if (aheadX >= p.x && aheadX <= p.x + p.w &&
                footY >= p.y && footY <= p.y + TILE) {
              onEdge = false;
              break;
            }
          }
          if (onEdge && Math.random() < 0.4) {
            e.vx = -e.vx;
          }
        }

        // Random direction change
        if (Math.random() < 0.005) {
          e.vx = -e.vx;
        }

        // Random jump
        if (e.onGround && Math.random() < e.jumpChance) {
          e.vy = JUMP_FORCE * 0.85;
          e.onGround = false;
        }

        // Drop through platforms sometimes (move down)
        if (e.onGround && Math.random() < 0.003) {
          e.y += 4; // drop through
          e.onGround = false;
        }

        // Collision with player (damages player)
        if (invincibleTimer <= 0 && rectOverlap(player, e)) {
          playerHit();
        }
      }
    }

    function kickSnowball(enemy) {
      const dir = player.facing;
      rollingBalls.push({
        x: enemy.x,
        y: enemy.y,
        w: 28,
        h: 28,
        vx: SNOWBALL_ROLL_SPEED * dir,
        vy: 0,
        life: 180, // ~3 seconds
        rotation: 0,
        sourceEnemy: enemy,
        chainCount: 0,
      });
      enemy.encased = false;
      enemy.snowHits = 0;
      // Score for kicking
      score += 10;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      spawnSnowPuff(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2);
      // Make enemy invisible (it's now inside the rolling ball)
      enemy.x = -999;
      enemy.y = -999;
    }

    function playerHit() {
      lives--;
      invincibleTimer = 120; // 2 seconds invincibility
      spawnExplosion(player.x + player.w / 2, player.y + player.h / 2, '#6fe');

      if (lives <= 0) {
        gameOver();
        return;
      }

      // Reset player position
      player.x = 7 * TILE;
      player.y = 14 * TILE - PLAYER_H;
      player.vx = 0;
      player.vy = 0;
    }

    function checkLevelComplete() {
      const aliveCount = enemies.filter(e => e.alive).length;
      const rollingCount = rollingBalls.length;
      if (aliveCount === 0 && rollingCount === 0) {
        levelTransition = true;
        levelTransitionTimer = 90; // 1.5 seconds
        // Bonus for clearing level
        const bonus = 500 * level;
        score += bonus;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        spawnScorePopup(W / 2 - 40, H / 2, bonus);
      }
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    // ── Particles ─────────────────────────────────────────────
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        if (p.gravity) p.vy += 0.15;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 16; i++) {
        const ang = (Math.PI * 2 / 16) * i + Math.random() * 0.3;
        const spd = 1.5 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 20 + Math.random() * 15,
          color,
          size: 3 + Math.random() * 3,
          gravity: true,
        });
      }
    }

    function spawnSnowPuff(x, y) {
      for (let i = 0; i < 6; i++) {
        particles.push({
          x: x + (Math.random() - 0.5) * 10,
          y: y + (Math.random() - 0.5) * 10,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2 - 1,
          life: 15 + Math.random() * 10,
          color: '#fff',
          size: 2 + Math.random() * 3,
          gravity: false,
        });
      }
    }

    function spawnScorePopup(x, y, pts) {
      particles.push({
        x, y,
        vx: 0,
        vy: -1.5,
        life: 50,
        color: '#ff0',
        text: '+' + pts,
        size: 0,
        gravity: false,
      });
    }

    // ── Drawing ───────────────────────────────────────────────
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Snowflakes in background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 83 + tick * (0.2 + (i % 3) * 0.1)) % (W + 20)) - 10;
        const sy = ((i * 251 + 47 + tick * (0.5 + (i % 4) * 0.2)) % (H + 20)) - 10;
        const sz = 1 + (i % 3);
        ctx.fillRect(sx, sy, sz, sz);
      }

      drawPlatforms();
      drawEnemies();
      drawSnowballs();
      drawRollingBalls();
      drawPlayer();
      drawParticles();
      drawHUD();

      // Level transition overlay
      if (levelTransition) {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.6)';
        ctx.fillRect(0, 0, W, H);
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#6fe';
        ctx.shadowColor = '#6fe';
        ctx.shadowBlur = 20;
        ctx.fillText(`LEVEL ${level} CLEAR!`, W / 2, H / 2 - 20);
        ctx.font = '18px Courier New';
        ctx.fillStyle = '#ff0';
        ctx.fillText(`Bonus: ${500 * level}`, W / 2, H / 2 + 20);
        ctx.shadowBlur = 0;
      }
    }

    function drawPlatforms() {
      for (const p of platforms) {
        if (p.isGround) {
          // Ground floor - solid
          ctx.fillStyle = '#16213e';
          ctx.fillRect(p.x, p.y, p.w, p.h);
          ctx.fillStyle = '#0f3460';
          ctx.fillRect(p.x, p.y, p.w, 3);
          // Snow on top
          ctx.fillStyle = 'rgba(102, 255, 238, 0.15)';
          ctx.fillRect(p.x, p.y, p.w, 2);
        } else {
          // Regular platform
          ctx.fillStyle = '#16213e';
          ctx.fillRect(p.x, p.y, p.w, 8);
          // Top edge glow
          ctx.fillStyle = '#0f3460';
          ctx.fillRect(p.x, p.y, p.w, 2);
          // Snow detail on top
          ctx.fillStyle = 'rgba(102, 255, 238, 0.2)';
          ctx.fillRect(p.x + 2, p.y - 1, p.w - 4, 2);
        }
      }

      // Side walls (visual only, wrapping handles collision)
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, 0, 3, H);
      ctx.fillRect(W - 3, 0, 3, H);
    }

    function drawPlayer() {
      const px = player.x;
      const py = player.y;
      const f = player.facing;
      const alpha = invincibleTimer > 0 && (tick & 3) < 2 ? 0.4 : 1;

      ctx.save();
      ctx.globalAlpha = alpha;

      // Body (snowman shape)
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#6fe';
      ctx.shadowBlur = 8;

      // Bottom body (larger circle)
      ctx.beginPath();
      ctx.ellipse(px + PLAYER_W / 2, py + PLAYER_H - 6, 11, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Top body (smaller circle = head)
      ctx.beginPath();
      ctx.ellipse(px + PLAYER_W / 2, py + 8, 9, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Hat
      ctx.fillStyle = '#6fe';
      ctx.fillRect(px + PLAYER_W / 2 - 8, py - 2, 16, 3);
      ctx.fillRect(px + PLAYER_W / 2 - 5, py - 9, 10, 8);

      // Eyes
      ctx.fillStyle = '#1a1a2e';
      const eyeOff = f === 1 ? 2 : -2;
      ctx.beginPath();
      ctx.arc(px + PLAYER_W / 2 - 3 + eyeOff, py + 6, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(px + PLAYER_W / 2 + 3 + eyeOff, py + 6, 2, 0, Math.PI * 2);
      ctx.fill();

      // Nose (carrot)
      ctx.fillStyle = '#f80';
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2 + eyeOff, py + 9);
      ctx.lineTo(px + PLAYER_W / 2 + f * 6 + eyeOff, py + 10);
      ctx.lineTo(px + PLAYER_W / 2 + eyeOff, py + 11);
      ctx.closePath();
      ctx.fill();

      // Arms (shooting animation)
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 2;
      const armY = py + 14;
      if (player.shootCooldown > 6) {
        // Shooting pose - arm extended
        ctx.beginPath();
        ctx.moveTo(px + PLAYER_W / 2, armY);
        ctx.lineTo(px + PLAYER_W / 2 + f * 18, armY - 4);
        ctx.stroke();
      } else {
        // Normal arms
        ctx.beginPath();
        ctx.moveTo(px + PLAYER_W / 2 - 8, armY);
        ctx.lineTo(px + PLAYER_W / 2 - 14, armY + 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(px + PLAYER_W / 2 + 8, armY);
        ctx.lineTo(px + PLAYER_W / 2 + 14, armY + 4);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawEnemies() {
      for (const e of enemies) {
        if (!e.alive) continue;

        if (e.encased) {
          drawEncasedEnemy(e);
          continue;
        }

        // Draw enemy based on type
        const cx = e.x + e.w / 2;
        const cy = e.y + e.h / 2;

        ctx.shadowColor = e.color;
        ctx.shadowBlur = 6;

        // Snow coverage indicator
        if (e.snowHits > 0) {
          const snowAlpha = e.snowHits / MAX_SNOW_HITS;
          // Draw enemy body
          drawEnemyBody(e);
          // Snow overlay
          ctx.fillStyle = `rgba(255, 255, 255, ${snowAlpha * 0.6})`;
          ctx.beginPath();
          ctx.ellipse(cx, cy + 2, e.w / 2 + 2, e.h / 2 + 2, 0, 0, Math.PI * 2);
          ctx.fill();
        } else {
          drawEnemyBody(e);
        }

        ctx.shadowBlur = 0;
      }
    }

    function drawEnemyBody(e) {
      const cx = e.x + e.w / 2;
      const cy = e.y + e.h / 2;
      const bounce = e.animFrame * 2;

      ctx.fillStyle = e.color;

      if (e.type === 'basic') {
        // Round blob monster
        ctx.beginPath();
        ctx.ellipse(cx, cy + bounce, 11, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        // Feet
        ctx.fillRect(e.x + 2, e.y + e.h - 4, 6, 4);
        ctx.fillRect(e.x + e.w - 8, e.y + e.h - 4, 6, 4);
      } else if (e.type === 'fast') {
        // Triangular speedy monster
        ctx.beginPath();
        ctx.moveTo(cx, e.y + bounce);
        ctx.lineTo(e.x + e.w + 2, e.y + e.h);
        ctx.lineTo(e.x - 2, e.y + e.h);
        ctx.closePath();
        ctx.fill();
      } else if (e.type === 'tough') {
        // Square armored monster
        ctx.fillRect(e.x - 1, e.y + bounce, e.w + 2, e.h);
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        ctx.strokeRect(e.x + 1, e.y + bounce + 2, e.w - 2, e.h - 4);
      }

      // Eyes
      ctx.fillStyle = '#fff';
      const eyeX1 = cx - 4;
      const eyeX2 = cx + 4;
      const eyeY = cy - 2 + bounce;
      ctx.beginPath();
      ctx.arc(eyeX1, eyeY, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(eyeX2, eyeY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = '#1a1a2e';
      const pupilOff = e.facing || 0;
      ctx.beginPath();
      ctx.arc(eyeX1 + pupilOff, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(eyeX2 + pupilOff, eyeY, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Angry mouth
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx - 4, cy + 5 + bounce);
      ctx.lineTo(cx, cy + 3 + bounce);
      ctx.lineTo(cx + 4, cy + 5 + bounce);
      ctx.stroke();
    }

    function drawEncasedEnemy(e) {
      const cx = e.x + e.w / 2;
      const cy = e.y + e.h / 2;

      // Snowball
      const pulse = Math.sin(tick * 0.1) * 2;
      ctx.fillStyle = '#ddf';
      ctx.shadowColor = '#6fe';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 14 + pulse, 14 + pulse, 0, 0, Math.PI * 2);
      ctx.fill();

      // Snow texture
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.ellipse(cx - 4, cy - 4, 5, 4, -0.3, 0, Math.PI * 2);
      ctx.fill();

      // Warning: enemy breaking free
      if (e.encaseTimer < 90) {
        const shake = (tick & 1) ? 1 : -1;
        ctx.fillStyle = e.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(cx + shake, cy, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Crack lines
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
          const ang = (Math.PI * 2 / 3) * i + tick * 0.05;
          ctx.beginPath();
          ctx.moveTo(cx + Math.cos(ang) * 8, cy + Math.sin(ang) * 8);
          ctx.lineTo(cx + Math.cos(ang) * 14, cy + Math.sin(ang) * 14);
          ctx.stroke();
        }
      }

      ctx.shadowBlur = 0;
    }

    function drawSnowballs() {
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#6fe';
      ctx.shadowBlur = 6;
      for (const s of snowballs) {
        ctx.beginPath();
        ctx.arc(s.x + s.w / 2, s.y + s.h / 2, 5, 0, Math.PI * 2);
        ctx.fill();

        // Trail
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(s.x + s.w / 2 - s.vx * 0.5, s.y + s.h / 2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
      }
      ctx.shadowBlur = 0;
    }

    function drawRollingBalls() {
      for (const rb of rollingBalls) {
        const cx = rb.x + rb.w / 2;
        const cy = rb.y + rb.h / 2;

        // Main ball
        ctx.fillStyle = '#eef';
        ctx.shadowColor = '#6fe';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.fill();

        // Rolling texture
        ctx.strokeStyle = 'rgba(102, 255, 238, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, 10, rb.rotation, rb.rotation + Math.PI);
        ctx.stroke();

        // Speed lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        for (let j = 0; j < 3; j++) {
          const lx = cx - rb.vx * (3 + j * 4);
          ctx.beginPath();
          ctx.moveTo(lx, cy - 4 + j * 4);
          ctx.lineTo(lx - rb.vx * 2, cy - 4 + j * 4);
          ctx.stroke();
        }

        // Chain count display
        if (rb.chainCount > 0) {
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#ff0';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 8;
          ctx.fillText(`x${rb.chainCount}`, cx, cy - 20);
        }

        ctx.shadowBlur = 0;
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = Math.min(1, p.life / 15);

        if (p.text) {
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.fillText(p.text, p.x, p.y);
          ctx.globalAlpha = 1;
        } else {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          ctx.globalAlpha = 1;
        }
      }
    }

    function drawHUD() {
      // Lives display
      ctx.fillStyle = '#6fe';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'left';
      for (let i = 0; i < lives; i++) {
        // Small snowman icon for each life
        const lx = 10 + i * 22;
        const ly = H - 20;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(lx + 6, ly, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(lx + 6, ly + 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#6fe';
        ctx.fillRect(lx + 2, ly - 7, 8, 3);
      }

      // Level indicator on canvas
      ctx.fillStyle = '#6fe';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`LVL ${level}`, W - 10, H - 10);
    }

    // ── Keyboard handler ──────────────────────────────────────
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'Z'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

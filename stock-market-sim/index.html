<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock Market Sim</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4c4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 204, 68, 0.4); }
    h1 { color: #4c4; font-size: 1.6rem; text-shadow: 0 0 15px rgba(68, 204, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #4c4; }
    canvas {
      border: 2px solid #4c4;
      box-shadow: 0 0 20px rgba(68, 204, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4c4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.92);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(68,204,68,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 6px; }
    .overlay .sub { font-size: 0.85rem; color: #888; margin-top: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>STOCK MARKET SIM</h1>
  </div>
  <div class="score-bar">
    <div>Cash: $<span id="cash">100,000</span></div>
    <div>Round: <span id="round">0</span>/20</div>
    <div>Portfolio: $<span id="score">100,000</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">STOCK MARKET SIM</h2>
      <p id="overlayText">Competitive trading simulation</p>
      <p class="sub">Click to start trading</p>
    </div>
  </div>
  <script src="../recorder.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const cashEl = document.getElementById('cash');
    const roundEl = document.getElementById('round');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting'; // waiting, playing, roundEnd, gameOver
    let score = 0;

    // --- STOCKS ---
    const STOCK_DEFS = [
      { ticker: 'NVTK', name: 'NovaTech', sector: 'tech', color: '#4af', basePrice: 150, volatility: 0.06 },
      { ticker: 'CBIT', name: 'CyberBit', sector: 'tech', color: '#6cf', basePrice: 85, volatility: 0.07 },
      { ticker: 'PETX', name: 'PetroMax', sector: 'energy', color: '#fa0', basePrice: 65, volatility: 0.05 },
      { ticker: 'SOLR', name: 'SolarWave', sector: 'energy', color: '#fc0', basePrice: 42, volatility: 0.08 },
      { ticker: 'BPHR', name: 'BioPharma', sector: 'pharma', color: '#f4a', basePrice: 120, volatility: 0.09 },
      { ticker: 'MDRX', name: 'MedRelix', sector: 'pharma', color: '#f6c', basePrice: 78, volatility: 0.07 },
      { ticker: 'SHPX', name: 'ShopMax', sector: 'retail', color: '#af4', basePrice: 55, volatility: 0.04 },
      { ticker: 'DLVR', name: 'DeliverEZ', sector: 'retail', color: '#cf6', basePrice: 38, volatility: 0.06 },
    ];

    const MARKET_EVENTS = [
      { text: 'FDA approves new drug!', sector: 'pharma', effect: 0.15, icon: 'ðŸ’Š' },
      { text: 'Drug trial fails!', sector: 'pharma', effect: -0.18, icon: 'ðŸ’Š' },
      { text: 'Tech earnings CRUSH estimates!', sector: 'tech', effect: 0.12, icon: 'ðŸ’»' },
      { text: 'Major data breach reported!', sector: 'tech', effect: -0.14, icon: 'ðŸ’»' },
      { text: 'Oil prices surge on supply cut!', sector: 'energy', effect: 0.13, icon: 'â›½' },
      { text: 'Oil spill causes market panic!', sector: 'energy', effect: -0.16, icon: 'â›½' },
      { text: 'Holiday sales smash records!', sector: 'retail', effect: 0.10, icon: 'ðŸ›’' },
      { text: 'Consumer spending drops sharply!', sector: 'retail', effect: -0.12, icon: 'ðŸ›’' },
      { text: 'Fed raises interest rates!', sector: 'all', effect: -0.06, icon: 'ðŸ¦' },
      { text: 'Fed signals rate cuts ahead!', sector: 'all', effect: 0.07, icon: 'ðŸ¦' },
      { text: 'Trade war escalates!', sector: 'all', effect: -0.08, icon: 'ðŸŒ' },
      { text: 'New trade deal signed!', sector: 'all', effect: 0.06, icon: 'ðŸŒ' },
      { text: 'Green energy subsidies announced!', sector: 'energy', effect: 0.11, icon: 'â›½' },
      { text: 'AI breakthrough announced!', sector: 'tech', effect: 0.16, icon: 'ðŸ’»' },
      { text: 'Retail chain files bankruptcy!', sector: 'retail', effect: -0.10, icon: 'ðŸ›’' },
      { text: 'Pandemic fears resurface!', sector: 'pharma', effect: 0.14, icon: 'ðŸ’Š' },
    ];

    const INSIDER_TIPS = [
      { text: 'Insider: Big pharma deal coming...', sector: 'pharma', reliable: true },
      { text: 'Rumor: Tech bubble about to pop!', sector: 'tech', reliable: false },
      { text: 'Insider: Energy merger imminent!', sector: 'energy', reliable: true },
      { text: 'Tip: Retail earnings will disappoint', sector: 'retail', reliable: false },
      { text: 'Source says: Buy tech NOW', sector: 'tech', reliable: true },
      { text: 'Whisper: Pharma scandal brewing...', sector: 'pharma', reliable: false },
      { text: 'Insider: Retail expansion coming', sector: 'retail', reliable: true },
      { text: 'Rumor: Energy crash imminent!', sector: 'energy', reliable: false },
    ];

    // --- GAME STATE ---
    let round = 0;
    const MAX_ROUNDS = 20;
    let stocks = [];
    let players = [];
    let currentEvent = null;
    let currentTip = null;
    let newsTicker = [];
    let selectedStock = 0;
    let tradeQty = 1;
    let phase = 'trade'; // trade, news, resolve
    let phaseTimer = 0;
    let animFrame = 0;
    let sectorTrends = { tech: 0, energy: 0, pharma: 0, retail: 0 };
    let hoverBtn = -1;
    let scrollOffset = 0;
    let chartHover = -1;

    // UI layout constants
    const CHART_X = 10, CHART_Y = 10, CHART_W = 280, CHART_H = 180;
    const PORT_X = 300, PORT_Y = 10, PORT_W = 290, PORT_H = 180;
    const TRADE_X = 10, TRADE_Y = 200, TRADE_W = 280, TRADE_H = 200;
    const NEWS_X = 300, NEWS_Y = 200, NEWS_W = 290, NEWS_H = 100;
    const BOARD_X = 300, BOARD_Y = 308, BOARD_W = 290, BOARD_H = 92;
    const BTN_Y = 410, BTN_H = 32;
    const TICKER_Y = 450, TICKER_H = 45;

    function initGame() {
      round = 0;
      phase = 'trade';
      selectedStock = 0;
      tradeQty = 1;
      newsTicker = ['Welcome to the Stock Market! Trade wisely.'];
      currentEvent = null;
      currentTip = null;
      sectorTrends = { tech: 0, energy: 0, pharma: 0, retail: 0 };

      stocks = STOCK_DEFS.map(d => ({
        ...d,
        price: d.basePrice,
        history: [d.basePrice],
        change: 0,
      }));

      // Players: 0 = human, 1-3 = AI
      players = [
        { name: 'You', cash: 100000, holdings: {}, shorts: {}, shortPrices: {}, isAI: false, strategy: 'human', color: '#4c4' },
        { name: 'ValueBot', cash: 100000, holdings: {}, shorts: {}, shortPrices: {}, isAI: true, strategy: 'value', color: '#4af' },
        { name: 'MomentumAI', cash: 100000, holdings: {}, shorts: {}, shortPrices: {}, isAI: true, strategy: 'momentum', color: '#fa0' },
        { name: 'Contrarian', cash: 100000, holdings: {}, shorts: {}, shortPrices: {}, isAI: true, strategy: 'contrarian', color: '#f4a' },
      ];
      players.forEach(p => {
        stocks.forEach(s => { p.holdings[s.ticker] = 0; p.shorts[s.ticker] = 0; p.shortPrices[s.ticker] = 0; });
      });

      nextRound();
    }

    function portfolioValue(p) {
      let val = p.cash;
      stocks.forEach(s => {
        val += (p.holdings[s.ticker] || 0) * s.price;
        // short positions: profit = (shortPrice - currentPrice) * qty
        const sq = p.shorts[s.ticker] || 0;
        if (sq > 0) {
          val += sq * (p.shortPrices[s.ticker] - s.price);
        }
      });
      return Math.max(0, val);
    }

    function nextRound() {
      round++;
      if (round > MAX_ROUNDS) {
        endGame();
        return;
      }
      phase = 'trade';
      phaseTimer = 0;

      // Generate event for this round
      if (round > 1 && Math.random() < 0.7) {
        currentEvent = MARKET_EVENTS[Math.floor(Math.random() * MARKET_EVENTS.length)];
      } else {
        currentEvent = null;
      }

      // Generate insider tip
      if (Math.random() < 0.5) {
        currentTip = INSIDER_TIPS[Math.floor(Math.random() * INSIDER_TIPS.length)];
      } else {
        currentTip = null;
      }

      // Sector trend drift
      for (let s in sectorTrends) {
        sectorTrends[s] += (Math.random() - 0.5) * 0.03;
        sectorTrends[s] = Math.max(-0.1, Math.min(0.1, sectorTrends[s]));
      }

      updateUI();
    }

    function resolveRound() {
      phase = 'news';

      // AI trades
      players.forEach(p => { if (p.isAI) aiTrade(p); });

      // Apply market event
      if (currentEvent) {
        newsTicker.unshift(currentEvent.icon + ' ' + currentEvent.text);
        if (newsTicker.length > 8) newsTicker.pop();
      }

      // Move prices
      stocks.forEach(s => {
        let delta = (Math.random() - 0.48) * s.volatility; // slight upward bias
        delta += sectorTrends[s.sector] || 0;

        if (currentEvent) {
          if (currentEvent.sector === 'all' || currentEvent.sector === s.sector) {
            delta += currentEvent.effect * (0.7 + Math.random() * 0.6);
          }
        }

        // Individual stock random walk
        delta += (Math.random() - 0.5) * 0.03;

        let newPrice = s.price * (1 + delta);
        newPrice = Math.max(2, Math.round(newPrice * 100) / 100);
        s.change = ((newPrice - s.price) / s.price) * 100;
        s.price = newPrice;
        s.history.push(newPrice);
      });

      // Update score
      const pv = portfolioValue(players[0]);
      score = Math.round(pv);
      scoreEl.textContent = score.toLocaleString();
      cashEl.textContent = Math.round(players[0].cash).toLocaleString();
      roundEl.textContent = round + '/' + MAX_ROUNDS;

      setTimeout(() => {
        nextRound();
      }, 1200);
    }

    function endGame() {
      gameState = 'gameOver';
      // Close all shorts at final prices
      players.forEach(p => {
        stocks.forEach(s => {
          const sq = p.shorts[s.ticker] || 0;
          if (sq > 0) {
            p.cash += sq * p.shortPrices[s.ticker]; // return collateral
            p.cash += sq * (p.shortPrices[s.ticker] - s.price); // profit/loss
            p.shorts[s.ticker] = 0;
          }
        });
      });

      score = Math.round(portfolioValue(players[0]));
      const rankings = players.map((p, i) => ({ name: p.name, value: Math.round(portfolioValue(p)), idx: i }));
      rankings.sort((a, b) => b.value - a.value);
      const rank = rankings.findIndex(r => r.idx === 0) + 1;

      overlayTitle.textContent = rank === 1 ? 'MARKET CHAMPION!' : 'GAME OVER';
      let txt = 'Final Portfolio: $' + score.toLocaleString() + '\n';
      txt += 'Rank: #' + rank + ' of 4\n\n';
      rankings.forEach((r, i) => {
        txt += (i + 1) + '. ' + r.name + ': $' + r.value.toLocaleString() + '\n';
      });
      overlayText.textContent = txt;
      overlay.querySelector('.sub').textContent = 'Click to play again';
      overlay.style.display = 'flex';
      scoreEl.textContent = score.toLocaleString();
      if (window.GameRecorder) GameRecorder.stop();
    }

    // --- AI TRADING ---
    function aiTrade(p) {
      const budget = p.cash * 0.3; // Use up to 30% of cash per round

      stocks.forEach(s => {
        const hist = s.history;
        const momentum = hist.length >= 3 ? (hist[hist.length - 1] - hist[hist.length - 3]) / hist[hist.length - 3] : 0;
        const valueRatio = s.basePrice / s.price;

        let action = 'hold';
        let qty = 0;

        switch (p.strategy) {
          case 'value':
            // Buy undervalued, sell overvalued
            if (valueRatio > 1.15) {
              action = 'buy';
              qty = Math.floor(Math.min(budget / 4, p.cash * 0.15) / s.price);
            } else if (valueRatio < 0.8) {
              action = 'sell';
              qty = Math.floor((p.holdings[s.ticker] || 0) * 0.4);
            }
            break;
          case 'momentum':
            // Follow trends
            if (momentum > 0.04) {
              action = 'buy';
              qty = Math.floor(Math.min(budget / 3, p.cash * 0.2) / s.price);
            } else if (momentum < -0.04) {
              action = 'sell';
              qty = Math.floor((p.holdings[s.ticker] || 0) * 0.5);
              // Short on strong downtrend
              if (momentum < -0.08 && p.shorts[s.ticker] === 0 && p.cash > s.price * 5) {
                const sq = Math.floor(Math.min(p.cash * 0.1, budget / 4) / s.price);
                if (sq > 0) {
                  p.shorts[s.ticker] = sq;
                  p.shortPrices[s.ticker] = s.price;
                  p.cash -= sq * s.price; // collateral
                }
              }
            }
            break;
          case 'contrarian':
            // Do the opposite of the market
            if (momentum < -0.05) {
              action = 'buy';
              qty = Math.floor(Math.min(budget / 3, p.cash * 0.2) / s.price);
            } else if (momentum > 0.06) {
              action = 'sell';
              qty = Math.floor((p.holdings[s.ticker] || 0) * 0.5);
            }
            // Close shorts on dips
            if (p.shorts[s.ticker] > 0 && momentum < -0.03) {
              const sq = p.shorts[s.ticker];
              p.cash += sq * p.shortPrices[s.ticker];
              p.cash += sq * (p.shortPrices[s.ticker] - s.price);
              p.shorts[s.ticker] = 0;
            }
            break;
        }

        if (action === 'buy' && qty > 0) {
          const cost = qty * s.price;
          if (cost <= p.cash) {
            p.cash -= cost;
            p.holdings[s.ticker] = (p.holdings[s.ticker] || 0) + qty;
          }
        } else if (action === 'sell' && qty > 0) {
          const have = p.holdings[s.ticker] || 0;
          qty = Math.min(qty, have);
          if (qty > 0) {
            p.cash += qty * s.price;
            p.holdings[s.ticker] -= qty;
          }
        }
      });
    }

    // --- PLAYER ACTIONS ---
    function playerBuy() {
      const s = stocks[selectedStock];
      const cost = tradeQty * s.price;
      if (cost > players[0].cash) return;
      players[0].cash -= cost;
      players[0].holdings[s.ticker] = (players[0].holdings[s.ticker] || 0) + tradeQty;
      newsTicker.unshift('Bought ' + tradeQty + ' ' + s.ticker + ' @ $' + s.price.toFixed(2));
      if (newsTicker.length > 8) newsTicker.pop();
      updateUI();
    }

    function playerSell() {
      const s = stocks[selectedStock];
      const have = players[0].holdings[s.ticker] || 0;
      const qty = Math.min(tradeQty, have);
      if (qty <= 0) return;
      players[0].cash += qty * s.price;
      players[0].holdings[s.ticker] -= qty;
      newsTicker.unshift('Sold ' + qty + ' ' + s.ticker + ' @ $' + s.price.toFixed(2));
      if (newsTicker.length > 8) newsTicker.pop();
      updateUI();
    }

    function playerShort() {
      const s = stocks[selectedStock];
      const collateral = tradeQty * s.price;
      if (collateral > players[0].cash) return;
      players[0].cash -= collateral;
      players[0].shorts[s.ticker] = (players[0].shorts[s.ticker] || 0) + tradeQty;
      players[0].shortPrices[s.ticker] = s.price;
      newsTicker.unshift('Shorted ' + tradeQty + ' ' + s.ticker + ' @ $' + s.price.toFixed(2));
      if (newsTicker.length > 8) newsTicker.pop();
      updateUI();
    }

    function playerCoverShort() {
      const s = stocks[selectedStock];
      const sq = players[0].shorts[s.ticker] || 0;
      if (sq <= 0) return;
      const coverQty = Math.min(tradeQty, sq);
      // Return collateral + profit/loss
      players[0].cash += coverQty * players[0].shortPrices[s.ticker];
      players[0].cash += coverQty * (players[0].shortPrices[s.ticker] - s.price);
      players[0].shorts[s.ticker] -= coverQty;
      const pnl = coverQty * (players[0].shortPrices[s.ticker] - s.price);
      newsTicker.unshift('Covered ' + coverQty + ' ' + s.ticker + ' P/L: $' + pnl.toFixed(0));
      if (newsTicker.length > 8) newsTicker.pop();
      updateUI();
    }

    function updateUI() {
      const pv = portfolioValue(players[0]);
      score = Math.round(pv);
      scoreEl.textContent = score.toLocaleString();
      cashEl.textContent = Math.round(players[0].cash).toLocaleString();
      roundEl.textContent = round + '/' + MAX_ROUNDS;
    }

    // --- RENDERING ---
    function drawPanel(x, y, w, h, title) {
      ctx.fillStyle = 'rgba(20, 20, 40, 0.9)';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
      if (title) {
        ctx.fillStyle = '#4c4';
        ctx.font = 'bold 11px Courier New';
        ctx.fillText(title, x + 6, y + 13);
      }
    }

    function drawChart() {
      drawPanel(CHART_X, CHART_Y, CHART_W, CHART_H, 'PRICE CHART');
      const s = stocks[selectedStock];
      const hist = s.history;
      if (hist.length < 2) return;

      const px = CHART_X + 8, py = CHART_Y + 22;
      const pw = CHART_W - 16, ph = CHART_H - 32;

      let minP = Infinity, maxP = 0;
      hist.forEach(v => { minP = Math.min(minP, v); maxP = Math.max(maxP, v); });
      const range = maxP - minP || 1;
      const padRange = range * 0.1;
      minP -= padRange;
      maxP += padRange;

      // Grid lines
      ctx.strokeStyle = '#252540';
      ctx.lineWidth = 0.5;
      for (let i = 0; i < 4; i++) {
        const gy = py + (ph * i / 3);
        ctx.beginPath(); ctx.moveTo(px, gy); ctx.lineTo(px + pw, gy); ctx.stroke();
        ctx.fillStyle = '#555';
        ctx.font = '8px Courier New';
        const pVal = maxP - (i / 3) * (maxP - minP);
        ctx.fillText('$' + pVal.toFixed(0), px, gy - 2);
      }

      // Price line
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 2;
      ctx.shadowColor = s.color;
      ctx.shadowBlur = 4;
      ctx.beginPath();
      for (let i = 0; i < hist.length; i++) {
        const hx = px + (i / Math.max(1, hist.length - 1)) * pw;
        const hy = py + ph - ((hist[i] - minP) / (maxP - minP)) * ph;
        if (i === 0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Fill under the curve
      const lastX = px + pw;
      const lastY = py + ph - ((hist[hist.length - 1] - minP) / (maxP - minP)) * ph;
      ctx.lineTo(lastX, py + ph);
      ctx.lineTo(px, py + ph);
      ctx.closePath();
      ctx.fillStyle = s.color + '15';
      ctx.fill();

      // Current price
      ctx.fillStyle = s.color;
      ctx.font = 'bold 12px Courier New';
      ctx.fillText(s.ticker + ' $' + s.price.toFixed(2), px + pw - 110, py + 12);
      const chg = s.change;
      ctx.fillStyle = chg >= 0 ? '#4c4' : '#f44';
      ctx.fillText((chg >= 0 ? '+' : '') + chg.toFixed(1) + '%', px + pw - 42, py + 12);
    }

    function drawPortfolio() {
      drawPanel(PORT_X, PORT_Y, PORT_W, PORT_H, 'LEADERBOARD');
      const py = PORT_Y + 24;
      const rankings = players.map((p, i) => ({ ...p, value: Math.round(portfolioValue(p)), idx: i }));
      rankings.sort((a, b) => b.value - a.value);

      rankings.forEach((r, i) => {
        const ry = py + i * 38;
        const isPlayer = r.idx === 0;
        ctx.fillStyle = isPlayer ? 'rgba(68,204,68,0.1)' : 'rgba(255,255,255,0.03)';
        ctx.fillRect(PORT_X + 4, ry - 2, PORT_W - 8, 34);

        ctx.fillStyle = r.color;
        ctx.font = 'bold 11px Courier New';
        ctx.fillText((i + 1) + '. ' + r.name, PORT_X + 10, ry + 10);

        ctx.fillStyle = '#ccc';
        ctx.font = '10px Courier New';
        ctx.fillText('$' + r.value.toLocaleString(), PORT_X + 10, ry + 24);

        // Performance bar
        const perf = ((r.value - 100000) / 100000) * 100;
        const barW = Math.min(80, Math.abs(perf) * 0.8);
        const barX = PORT_X + 160;
        ctx.fillStyle = perf >= 0 ? '#4c4' : '#f44';
        ctx.fillRect(barX, ry + 17, perf >= 0 ? barW : -barW, 6);
        ctx.fillText((perf >= 0 ? '+' : '') + perf.toFixed(1) + '%', barX + (perf >= 0 ? barW + 4 : -barW - 40), ry + 24);
      });
    }

    function drawTradePanel() {
      drawPanel(TRADE_X, TRADE_Y, TRADE_W, TRADE_H, 'TRADING DESK');

      // Stock selector tabs
      const tabW = 33, tabH = 18;
      stocks.forEach((s, i) => {
        const tx = TRADE_X + 6 + i * (tabW + 2);
        const ty = TRADE_Y + 20;
        const sel = i === selectedStock;
        ctx.fillStyle = sel ? s.color + '40' : '#1a1a2e';
        ctx.strokeStyle = sel ? s.color : '#333';
        ctx.lineWidth = sel ? 1.5 : 0.5;
        ctx.fillRect(tx, ty, tabW, tabH);
        ctx.strokeRect(tx, ty, tabW, tabH);
        ctx.fillStyle = sel ? s.color : '#777';
        ctx.font = (sel ? 'bold ' : '') + '8px Courier New';
        ctx.fillText(s.ticker.substring(0, 4), tx + 2, ty + 12);
      });

      const s = stocks[selectedStock];
      const baseY = TRADE_Y + 48;

      // Stock info
      ctx.fillStyle = s.color;
      ctx.font = 'bold 13px Courier New';
      ctx.fillText(s.ticker + ' - ' + s.name, TRADE_X + 10, baseY);
      ctx.font = '10px Courier New';
      ctx.fillStyle = '#888';
      ctx.fillText('Sector: ' + s.sector.toUpperCase(), TRADE_X + 10, baseY + 16);
      ctx.fillStyle = '#ddd';
      ctx.fillText('Price: $' + s.price.toFixed(2), TRADE_X + 10, baseY + 32);
      const chg = s.change;
      ctx.fillStyle = chg >= 0 ? '#4c4' : '#f44';
      ctx.fillText((chg >= 0 ? '+' : '') + chg.toFixed(2) + '%', TRADE_X + 130, baseY + 32);

      // Holdings
      const held = players[0].holdings[s.ticker] || 0;
      const shorted = players[0].shorts[s.ticker] || 0;
      ctx.fillStyle = '#aaa';
      ctx.fillText('Held: ' + held + ' ($' + Math.round(held * s.price).toLocaleString() + ')', TRADE_X + 10, baseY + 50);
      if (shorted > 0) {
        ctx.fillStyle = '#f84';
        ctx.fillText('Short: ' + shorted, TRADE_X + 180, baseY + 50);
      }

      // Quantity selector
      ctx.fillStyle = '#aaa';
      ctx.font = '10px Courier New';
      ctx.fillText('Qty:', TRADE_X + 10, baseY + 72);

      const qtyBtns = [1, 5, 10, 50, 'MAX'];
      qtyBtns.forEach((q, i) => {
        const bx = TRADE_X + 45 + i * 44;
        const by = baseY + 60;
        const bw = 40, bh = 18;
        const isActive = (q === 'MAX' && tradeQty === Math.floor(players[0].cash / s.price)) ||
                         (q !== 'MAX' && tradeQty === q);
        ctx.fillStyle = isActive ? '#4c4' + '40' : '#222';
        ctx.strokeStyle = isActive ? '#4c4' : '#444';
        ctx.lineWidth = 1;
        ctx.fillRect(bx, by, bw, bh);
        ctx.strokeRect(bx, by, bw, bh);
        ctx.fillStyle = isActive ? '#4c4' : '#aaa';
        ctx.font = '9px Courier New';
        ctx.fillText('' + q, bx + (q === 'MAX' ? 6 : 14), by + 13);
      });

      // Action buttons
      if (phase === 'trade') {
        const btns = [
          { label: 'BUY', color: '#4c4', x: TRADE_X + 10, enabled: players[0].cash >= s.price * tradeQty },
          { label: 'SELL', color: '#f44', x: TRADE_X + 78, enabled: (players[0].holdings[s.ticker] || 0) > 0 },
          { label: 'SHORT', color: '#f84', x: TRADE_X + 146, enabled: players[0].cash >= s.price * tradeQty },
          { label: 'COVER', color: '#48f', x: TRADE_X + 214, enabled: (players[0].shorts[s.ticker] || 0) > 0 },
        ];
        btns.forEach((b, i) => {
          const by = baseY + 88;
          const bw = 60, bh = 24;
          ctx.fillStyle = b.enabled ? b.color + '30' : '#1a1a2e';
          ctx.strokeStyle = b.enabled ? b.color : '#333';
          ctx.lineWidth = b.enabled ? 1.5 : 0.5;
          ctx.fillRect(b.x, by, bw, bh);
          ctx.strokeRect(b.x, by, bw, bh);
          ctx.fillStyle = b.enabled ? b.color : '#555';
          ctx.font = 'bold 10px Courier New';
          ctx.fillText(b.label, b.x + (bw - ctx.measureText(b.label).width) / 2, by + 16);
        });

        // End turn button
        const etx = TRADE_X + 80, ety = baseY + 122, etw = 120, eth = 26;
        ctx.fillStyle = '#4c4' + '25';
        ctx.strokeStyle = '#4c4';
        ctx.lineWidth = 2;
        ctx.fillRect(etx, ety, etw, eth);
        ctx.strokeRect(etx, ety, etw, eth);
        ctx.fillStyle = '#4c4';
        ctx.font = 'bold 12px Courier New';
        ctx.fillText('END TURN >>',  etx + 10, ety + 17);
      } else {
        ctx.fillStyle = '#fa0';
        ctx.font = 'bold 12px Courier New';
        ctx.fillText('Processing market...', TRADE_X + 50, baseY + 104);
      }
    }

    function drawNews() {
      drawPanel(NEWS_X, NEWS_Y, NEWS_W, NEWS_H, 'NEWS FEED');
      const ny = NEWS_Y + 22;

      // Current event
      if (currentEvent && phase === 'trade') {
        ctx.fillStyle = '#fa0';
        ctx.font = 'bold 10px Courier New';
        ctx.fillText('BREAKING:', NEWS_X + 8, ny + 2);
        ctx.fillStyle = '#ddd';
        ctx.font = '9px Courier New';
        // Word wrap the event text
        const words = currentEvent.text.split(' ');
        let line = '';
        let lineY = ny + 15;
        words.forEach(w => {
          const test = line + w + ' ';
          if (ctx.measureText(test).width > NEWS_W - 20) {
            ctx.fillText(line, NEWS_X + 8, lineY);
            line = w + ' ';
            lineY += 12;
          } else {
            line = test;
          }
        });
        ctx.fillText(line, NEWS_X + 8, lineY);
      }

      // Insider tip
      if (currentTip && phase === 'trade') {
        ctx.fillStyle = '#f4a';
        ctx.font = '9px Courier New';
        ctx.fillText('TIP: ' + currentTip.text, NEWS_X + 8, ny + 56);
        ctx.fillStyle = '#666';
        ctx.font = '8px Courier New';
        ctx.fillText('(Tips may be misleading!)', NEWS_X + 8, ny + 68);
      }
    }

    function drawLeaderboard() {
      drawPanel(BOARD_X, BOARD_Y, BOARD_W, BOARD_H, 'ORDER BOOK / HOLDINGS');
      const s = stocks[selectedStock];
      const by = BOARD_Y + 20;

      // Show all players' holdings for selected stock
      players.forEach((p, i) => {
        const ry = by + i * 17;
        const held = p.holdings[s.ticker] || 0;
        const shrt = p.shorts[s.ticker] || 0;
        ctx.fillStyle = p.color;
        ctx.font = '9px Courier New';
        ctx.fillText(p.name.padEnd(12), BOARD_X + 8, ry + 10);
        ctx.fillStyle = held > 0 ? '#4c4' : '#555';
        ctx.fillText('H:' + ('' + held).padStart(4), BOARD_X + 110, ry + 10);
        ctx.fillStyle = shrt > 0 ? '#f84' : '#555';
        ctx.fillText('S:' + ('' + shrt).padStart(4), BOARD_X + 175, ry + 10);
        ctx.fillStyle = '#777';
        const val = held * s.price;
        ctx.fillText('$' + Math.round(val).toLocaleString(), BOARD_X + 220, ry + 10);
      });
    }

    function drawNewsTicker() {
      drawPanel(10, TICKER_Y, W - 20, TICKER_H, null);
      ctx.fillStyle = '#888';
      ctx.font = '9px Courier New';
      const visibleNews = newsTicker.slice(0, 3);
      visibleNews.forEach((n, i) => {
        ctx.fillStyle = i === 0 ? '#ddd' : '#666';
        ctx.fillText(n.substring(0, 80), 18, TICKER_Y + 14 + i * 14);
      });
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState !== 'playing') {
        // Draw a stock-chart-style background animation for overlay
        ctx.strokeStyle = '#4c4' + '20';
        ctx.lineWidth = 1;
        const t = animFrame * 0.02;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          for (let x = 0; x < W; x += 4) {
            const y = H / 2 + Math.sin(x * 0.01 + t + i * 2) * 60 + Math.sin(x * 0.03 + t * 1.5) * 30 - i * 40;
            if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        animFrame++;
        requestAnimationFrame(draw);
        return;
      }

      drawChart();
      drawPortfolio();
      drawTradePanel();
      drawNews();
      drawLeaderboard();
      drawNewsTicker();

      // Round phase indicator
      if (phase !== 'trade') {
        ctx.fillStyle = 'rgba(26,26,46,0.6)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fa0';
        ctx.font = 'bold 16px Courier New';
        ctx.shadowColor = '#fa0';
        ctx.shadowBlur = 10;
        ctx.fillText('MARKET MOVING...', W / 2 - 90, H / 2);
        ctx.shadowBlur = 0;
      }

      animFrame++;
      requestAnimationFrame(draw);
    }

    // --- INPUT ---
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        if (window.GameRecorder) GameRecorder.start();
        requestAnimationFrame(draw);
        return;
      }

      if (gameState === 'gameOver') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        if (window.GameRecorder) GameRecorder.start();
        requestAnimationFrame(draw);
        return;
      }

      if (phase !== 'trade') return;

      // Stock selector tabs
      const tabW = 33, tabH = 18;
      stocks.forEach((s, i) => {
        const tx = TRADE_X + 6 + i * (tabW + 2);
        const ty = TRADE_Y + 20;
        if (mx >= tx && mx <= tx + tabW && my >= ty && my <= ty + tabH) {
          selectedStock = i;
          tradeQty = 1;
        }
      });

      // Quantity buttons
      const s = stocks[selectedStock];
      const baseY = TRADE_Y + 48;
      const qtyBtns = [1, 5, 10, 50, 'MAX'];
      qtyBtns.forEach((q, i) => {
        const bx = TRADE_X + 45 + i * 44;
        const by = baseY + 60;
        const bw = 40, bh = 18;
        if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
          tradeQty = q === 'MAX' ? Math.max(1, Math.floor(players[0].cash / s.price)) : q;
        }
      });

      // Action buttons
      const btns = [
        { label: 'BUY', x: TRADE_X + 10, action: playerBuy, enabled: players[0].cash >= s.price * tradeQty },
        { label: 'SELL', x: TRADE_X + 78, action: playerSell, enabled: (players[0].holdings[s.ticker] || 0) > 0 },
        { label: 'SHORT', x: TRADE_X + 146, action: playerShort, enabled: players[0].cash >= s.price * tradeQty },
        { label: 'COVER', x: TRADE_X + 214, action: playerCoverShort, enabled: (players[0].shorts[s.ticker] || 0) > 0 },
      ];
      btns.forEach(b => {
        const by2 = baseY + 88;
        const bw = 60, bh = 24;
        if (mx >= b.x && mx <= b.x + bw && my >= by2 && my <= by2 + bh && b.enabled) {
          b.action();
        }
      });

      // End turn button
      const etx = TRADE_X + 80, ety = baseY + 122, etw = 120, eth = 26;
      if (mx >= etx && mx <= etx + etw && my >= ety && my <= ety + eth) {
        resolveRound();
      }
    });

    // Prevent scrolling
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
    });

    // Start the render loop
    requestAnimationFrame(draw);
  </script>
</body>
</html>

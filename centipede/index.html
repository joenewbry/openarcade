<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Centipede</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #6f8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(102,255,136,0.5); }
    h1 { color: #6f8; font-size: 2rem; text-shadow: 0 0 15px rgba(102,255,136,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #6f8; }
    canvas {
      border: 2px solid #6f8;
      box-shadow: 0 0 20px rgba(102,255,136,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #6f8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>CENTIPEDE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">CENTIPEDE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const CELL = 20;
    const COLS = W / CELL;   // 24
    const ROWS = H / CELL;   // 30
    const PLAYER_ZONE_TOP = ROWS - 7; // player can move in bottom 7 rows (~quarter)

    // Game globals (recorder contract)
    let score, best = 0, gameState;
    let lives;

    // Game objects
    let player, bullets, centipedes, mushrooms, spider, flea, particles;
    let keys = {};
    let frameCount, lastShotFrame;
    let level;
    let fleaTimer, spiderTimer;

    // Mushroom grid: mushrooms[row][col] = hp (0 = none, 1-4 = hits remaining)
    // Persists between lives, reset on new game

    const PLAYER_SPEED = 4;
    const BULLET_SPEED = 8;
    const SHOT_COOLDOWN = 6; // frames between shots

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      keys = {};
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      mushrooms = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      placeMushrooms();
      resetLife();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'CENTIPEDE';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function placeMushrooms() {
      // Scatter mushrooms in rows 2 through PLAYER_ZONE_TOP-1
      const count = 25 + level * 3;
      for (let i = 0; i < count; i++) {
        const r = 2 + Math.floor(Math.random() * (PLAYER_ZONE_TOP - 3));
        const c = Math.floor(Math.random() * COLS);
        if (mushrooms[r][c] === 0) {
          mushrooms[r][c] = 4;
        }
      }
    }

    function resetLife() {
      player = { x: W / 2 - CELL / 2, y: H - CELL * 2 };
      bullets = [];
      particles = [];
      centipedes = [];
      spider = null;
      flea = null;
      frameCount = 0;
      lastShotFrame = -SHOT_COOLDOWN;
      fleaTimer = 200 + Math.floor(Math.random() * 200);
      spiderTimer = 150 + Math.floor(Math.random() * 150);
      spawnCentipede();
    }

    function spawnCentipede() {
      // Create one centipede with 10+level segments entering from top
      const segCount = Math.min(12, 10 + Math.floor(level / 2));
      const segments = [];
      const startCol = Math.floor(Math.random() * (COLS - 4)) + 2;
      for (let i = 0; i < segCount; i++) {
        segments.push({
          x: (startCol - i) * CELL,
          y: 0,
          dir: 1,        // 1 = right, -1 = left
          dropping: false,
          dropTarget: 0,
          head: i === 0
        });
      }
      centipedes.push(segments);
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // -- Player movement (constrained to bottom quarter) --
      if (keys['ArrowLeft'])  player.x -= PLAYER_SPEED;
      if (keys['ArrowRight']) player.x += PLAYER_SPEED;
      if (keys['ArrowUp'])    player.y -= PLAYER_SPEED;
      if (keys['ArrowDown'])  player.y += PLAYER_SPEED;

      // Clamp to bounds
      player.x = Math.max(0, Math.min(W - CELL, player.x));
      player.y = Math.max(PLAYER_ZONE_TOP * CELL, Math.min(H - CELL, player.y));

      // -- Auto-fire while space is held --
      if (keys[' '] && frameCount - lastShotFrame >= SHOT_COOLDOWN) {
        bullets.push({ x: player.x + CELL / 2, y: player.y });
        lastShotFrame = frameCount;
      }

      // -- Update bullets --
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= BULLET_SPEED;
        if (bullets[i].y < -10) {
          bullets.splice(i, 1);
          continue;
        }

        const b = bullets[i];
        let bulletHit = false;

        // Bullet vs mushroom
        const mc = Math.floor(b.x / CELL);
        const mr = Math.floor(b.y / CELL);
        if (mr >= 0 && mr < ROWS && mc >= 0 && mc < COLS && mushrooms[mr][mc] > 0) {
          mushrooms[mr][mc]--;
          if (mushrooms[mr][mc] === 0) {
            addScore(1);
          }
          bullets.splice(i, 1);
          spawnParticles(mc * CELL + CELL / 2, mr * CELL + CELL / 2, '#5a5', 3);
          continue;
        }

        // Bullet vs centipede segments
        for (let ci = centipedes.length - 1; ci >= 0; ci--) {
          const segs = centipedes[ci];
          for (let si = segs.length - 1; si >= 0; si--) {
            const s = segs[si];
            if (b.x >= s.x && b.x <= s.x + CELL &&
                b.y >= s.y && b.y <= s.y + CELL) {
              // Hit this segment
              bulletHit = true;
              addScore(s.head ? 100 : 10);
              spawnParticles(s.x + CELL / 2, s.y + CELL / 2, s.head ? '#f44' : '#6f8', 8);

              // Leave a mushroom where the segment died
              const mr2 = Math.floor((s.y + CELL / 2) / CELL);
              const mc2 = Math.floor((s.x + CELL / 2) / CELL);
              if (mr2 >= 0 && mr2 < ROWS && mc2 >= 0 && mc2 < COLS) {
                mushrooms[mr2][mc2] = 4;
              }

              // Split centipede: segments before si become one, segments after si become another
              if (segs.length === 1) {
                centipedes.splice(ci, 1);
              } else {
                const before = segs.slice(0, si);
                const after = segs.slice(si + 1);
                centipedes.splice(ci, 1);
                if (before.length > 0) {
                  // The last segment of 'before' was following the killed one
                  // It becomes the tail of its group (no head change needed)
                  centipedes.push(before);
                }
                if (after.length > 0) {
                  // First segment of 'after' becomes a head
                  after[0].head = true;
                  centipedes.push(after);
                }
              }
              break;
            }
          }
          if (bulletHit) break;
        }
        if (bulletHit) {
          bullets.splice(i, 1);
          continue;
        }

        // Bullet vs spider
        if (spider) {
          if (b.x >= spider.x && b.x <= spider.x + CELL * 1.2 &&
              b.y >= spider.y && b.y <= spider.y + CELL * 1.2) {
            // Distance-based scoring
            const dist = Math.abs(spider.y - player.y);
            const pts = dist < 60 ? 900 : dist < 150 ? 600 : 300;
            addScore(pts);
            spawnParticles(spider.x + CELL / 2, spider.y + CELL / 2, '#f0f', 10);
            spider = null;
            bullets.splice(i, 1);
            continue;
          }
        }

        // Bullet vs flea
        if (flea) {
          if (b.x >= flea.x && b.x <= flea.x + CELL &&
              b.y >= flea.y && b.y <= flea.y + CELL) {
            flea.hp--;
            if (flea.hp <= 0) {
              addScore(200);
              spawnParticles(flea.x + CELL / 2, flea.y + CELL / 2, '#ff0', 8);
              flea = null;
            }
            bullets.splice(i, 1);
            continue;
          }
        }
      }

      // -- Update centipedes --
      // Move centipedes every 3 frames for readable speed
      if (frameCount % 3 === 0) {
        for (const segs of centipedes) {
          // Store old positions
          const oldPos = segs.map(s => ({ x: s.x, y: s.y, dir: s.dir }));
          // Move head
          moveCentipedeHead(segs[0]);
          // Each follower takes the old position of the one before it
          for (let si = 1; si < segs.length; si++) {
            segs[si].x = oldPos[si - 1].x;
            segs[si].y = oldPos[si - 1].y;
            segs[si].dir = oldPos[si - 1].dir;
          }
        }
      }

      // Check if centipede segments collide with player
      for (const segs of centipedes) {
        for (const s of segs) {
          if (rectsOverlap(player.x, player.y, CELL, CELL, s.x, s.y, CELL, CELL)) {
            killPlayer();
            return;
          }
        }
      }

      // Check if all centipedes are dead - spawn new wave
      if (centipedes.length === 0) {
        level++;
        // Repair mushrooms to full hp
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (mushrooms[r][c] > 0 && mushrooms[r][c] < 4) {
              addScore(5);
              mushrooms[r][c] = 4;
            }
          }
        }
        spawnCentipede();
      }

      // -- Spider --
      spiderTimer--;
      if (!spider && spiderTimer <= 0) {
        const side = Math.random() < 0.5 ? 0 : W - CELL;
        spider = {
          x: side,
          y: PLAYER_ZONE_TOP * CELL + Math.random() * (H - PLAYER_ZONE_TOP * CELL - CELL * 2),
          vx: side === 0 ? 2 : -2,
          vy: 0,
          phase: Math.random() * Math.PI * 2
        };
      }
      if (spider) {
        spider.phase += 0.08;
        spider.x += spider.vx;
        spider.vy = Math.sin(spider.phase) * 3;
        spider.y += spider.vy;

        // Keep in player zone
        if (spider.y < (PLAYER_ZONE_TOP - 2) * CELL) spider.y = (PLAYER_ZONE_TOP - 2) * CELL;
        if (spider.y > H - CELL * 2) spider.y = H - CELL * 2;

        // Remove if off screen
        if (spider.x < -CELL * 2 || spider.x > W + CELL * 2) {
          spider = null;
          spiderTimer = 100 + Math.floor(Math.random() * 200);
        }

        // Spider eats mushrooms it passes over
        if (spider) {
          const sc = Math.floor((spider.x + CELL / 2) / CELL);
          const sr = Math.floor((spider.y + CELL / 2) / CELL);
          if (sc >= 0 && sc < COLS && sr >= 0 && sr < ROWS && mushrooms[sr][sc] > 0) {
            mushrooms[sr][sc] = 0;
          }

          // Spider vs player
          if (rectsOverlap(player.x, player.y, CELL, CELL,
                           spider.x, spider.y, CELL * 1.2, CELL * 1.2)) {
            killPlayer();
            return;
          }
        }
      }

      // -- Flea --
      fleaTimer--;
      if (!flea && fleaTimer <= 0) {
        // Flea spawns when player area has few mushrooms
        let playerAreaMushrooms = 0;
        for (let r = PLAYER_ZONE_TOP; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (mushrooms[r][c] > 0) playerAreaMushrooms++;
          }
        }
        if (playerAreaMushrooms < 5) {
          flea = {
            x: Math.floor(Math.random() * COLS) * CELL,
            y: -CELL,
            hp: 2,
            speed: 3 + level * 0.3
          };
        }
        fleaTimer = 300 + Math.floor(Math.random() * 200);
      }
      if (flea) {
        flea.y += flea.speed;

        // Flea drops mushrooms as it falls
        const fc = Math.floor((flea.x + CELL / 2) / CELL);
        const fr = Math.floor((flea.y + CELL / 2) / CELL);
        if (fr >= 0 && fr < ROWS && fc >= 0 && fc < COLS && mushrooms[fr][fc] === 0) {
          if (Math.random() < 0.3) {
            mushrooms[fr][fc] = 4;
          }
        }

        // Off screen
        if (flea.y > H + CELL) {
          flea = null;
          fleaTimer = 200 + Math.floor(Math.random() * 300);
        }

        // Flea vs player
        if (flea && rectsOverlap(player.x, player.y, CELL, CELL,
                                  flea.x, flea.y, CELL, CELL)) {
          killPlayer();
          return;
        }
      }

      // -- Particles --
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life--;
        if (particles[i].life <= 0) particles.splice(i, 1);
      }
    }

    function moveCentipedeHead(s) {
      // Current grid position
      const col = Math.round(s.x / CELL);
      const row = Math.round(s.y / CELL);
      const nextCol = col + s.dir;

      // Check if we need to turn: hit wall or mushroom
      let mustTurn = false;
      if (nextCol < 0 || nextCol >= COLS) {
        mustTurn = true;
      } else if (row >= 0 && row < ROWS && mushrooms[row][nextCol] > 0) {
        mustTurn = true;
      }

      if (mustTurn) {
        // Move down one row and reverse direction
        s.y += CELL;
        s.dir *= -1;

        // If centipede has gone below the screen, wrap to top
        if (s.y >= H) {
          s.y = 0;
        }
      } else {
        s.x += s.dir * CELL;
      }

      // Snap to grid
      s.x = Math.round(s.x / CELL) * CELL;
      s.y = Math.round(s.y / CELL) * CELL;
    }

    function killPlayer() {
      lives--;
      livesEl.textContent = lives;
      spawnParticles(player.x + CELL / 2, player.y + CELL / 2, '#6f8', 15);

      if (lives <= 0) {
        gameOver();
      } else {
        // Reset position, keep mushrooms
        player.x = W / 2 - CELL / 2;
        player.y = H - CELL * 2;
        bullets = [];
        spider = null;
        flea = null;
        spiderTimer = 150 + Math.floor(Math.random() * 150);
        fleaTimer = 200 + Math.floor(Math.random() * 200);

        // Partially repair damaged mushrooms (restore to 4 hp)
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (mushrooms[r][c] > 0 && mushrooms[r][c] < 4) {
              mushrooms[r][c] = 4;
              addScore(5);
            }
          }
        }

        // Reset centipedes at top
        centipedes = [];
        spawnCentipede();
      }
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function addScore(pts) {
      score += pts;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const ang = (Math.PI * 2 / count) * i + Math.random() * 0.5;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.random() * 10,
          color
        });
      }
    }

    // -- Drawing --

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Subtle grid
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= W; x += CELL) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y <= H; y += CELL) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Player zone line
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, PLAYER_ZONE_TOP * CELL);
      ctx.lineTo(W, PLAYER_ZONE_TOP * CELL);
      ctx.stroke();

      // Mushrooms
      drawMushrooms();

      // Centipedes
      for (const segs of centipedes) {
        drawCentipede(segs);
      }

      // Spider
      if (spider) drawSpider();

      // Flea
      if (flea) drawFlea();

      // Player
      drawPlayer();

      // Bullets
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#6f8';
      ctx.shadowBlur = 6;
      for (const b of bullets) {
        ctx.fillRect(b.x - 1.5, b.y, 3, 8);
      }
      ctx.shadowBlur = 0;

      // Particles
      for (const p of particles) {
        const alpha = p.life / 25;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      }
      ctx.globalAlpha = 1;
    }

    function drawMushrooms() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const hp = mushrooms[r][c];
          if (hp <= 0) continue;

          const x = c * CELL;
          const y = r * CELL;
          const frac = hp / 4;

          // Mushroom cap (dome)
          const capH = CELL * 0.55 * frac + CELL * 0.2;
          const green = Math.floor(100 + 155 * frac);
          ctx.fillStyle = `rgb(${Math.floor(80 * frac)}, ${green}, ${Math.floor(60 * frac)})`;
          ctx.shadowColor = `rgb(0, ${green}, 0)`;
          ctx.shadowBlur = 4;

          // Cap shape
          ctx.beginPath();
          ctx.ellipse(x + CELL / 2, y + CELL - CELL * 0.35, CELL * 0.45, capH, 0, Math.PI, 0);
          ctx.fill();

          // Stem
          ctx.fillStyle = `rgb(${Math.floor(60 * frac)}, ${Math.floor(80 + 40 * frac)}, ${Math.floor(50 * frac)})`;
          ctx.fillRect(x + CELL * 0.35, y + CELL - CELL * 0.4, CELL * 0.3, CELL * 0.4);
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawCentipede(segs) {
      // Draw segments from tail to head
      for (let i = segs.length - 1; i >= 0; i--) {
        const s = segs[i];
        const cx = s.x + CELL / 2;
        const cy = s.y + CELL / 2;
        const r = CELL * 0.45;

        if (s.head) {
          // Head: brighter, larger
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(cx, cy, r + 2, 0, Math.PI * 2);
          ctx.fill();

          // Eyes
          ctx.fillStyle = '#fff';
          const eyeOffX = s.dir * 3;
          ctx.beginPath(); ctx.arc(cx + eyeOffX - 3, cy - 3, 2.5, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + eyeOffX + 3, cy - 3, 2.5, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath(); ctx.arc(cx + eyeOffX - 3, cy - 3, 1.2, 0, Math.PI * 2); ctx.fill();
          ctx.beginPath(); ctx.arc(cx + eyeOffX + 3, cy - 3, 1.2, 0, Math.PI * 2); ctx.fill();

          // Antennae
          ctx.strokeStyle = '#f44';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(cx - 4, cy - r);
          ctx.lineTo(cx - 8, cy - r - 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + 4, cy - r);
          ctx.lineTo(cx + 8, cy - r - 6);
          ctx.stroke();
        } else {
          // Body segment
          ctx.fillStyle = '#6f8';
          ctx.shadowColor = '#6f8';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();

          // Segment detail - stripe
          ctx.fillStyle = '#4d6';
          ctx.beginPath();
          ctx.arc(cx, cy, r * 0.5, 0, Math.PI * 2);
          ctx.fill();

          // Legs
          ctx.strokeStyle = '#4d6';
          ctx.lineWidth = 1;
          const legAnim = Math.sin(frameCount * 0.15 + i) * 2;
          ctx.beginPath(); ctx.moveTo(cx - r, cy); ctx.lineTo(cx - r - 3, cy + 4 + legAnim); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx + r, cy); ctx.lineTo(cx + r + 3, cy + 4 - legAnim); ctx.stroke();
        }
        ctx.shadowBlur = 0;
      }

      // Draw connections between segments
      if (segs.length > 1) {
        ctx.strokeStyle = '#4d6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(segs[0].x + CELL / 2, segs[0].y + CELL / 2);
        for (let i = 1; i < segs.length; i++) {
          ctx.lineTo(segs[i].x + CELL / 2, segs[i].y + CELL / 2);
        }
        ctx.stroke();
      }
    }

    function drawSpider() {
      const cx = spider.x + CELL * 0.6;
      const cy = spider.y + CELL * 0.6;
      const r = CELL * 0.55;

      ctx.fillStyle = '#f0f';
      ctx.shadowColor = '#f0f';
      ctx.shadowBlur = 10;

      // Body
      ctx.beginPath();
      ctx.ellipse(cx, cy, r, r * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();

      // Smaller head
      ctx.beginPath();
      ctx.arc(cx, cy - r * 0.5, r * 0.4, 0, Math.PI * 2);
      ctx.fill();

      // Legs (4 pairs)
      ctx.strokeStyle = '#f0f';
      ctx.lineWidth = 1.5;
      for (let i = -1; i <= 1; i += 2) {
        for (let j = 0; j < 4; j++) {
          const angle = (j * 0.4 + 0.3) * i;
          const legLen = r + 4 + Math.sin(frameCount * 0.2 + j * 1.5) * 3;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          const knee = r * 0.6;
          const kx = cx + Math.cos(angle) * knee * i;
          const ky = cy + Math.sin(angle + 0.5) * knee;
          ctx.lineTo(kx, ky);
          ctx.lineTo(cx + Math.cos(angle - 0.2) * legLen * i, cy + legLen * 0.4 + Math.sin(frameCount * 0.15 + j) * 2);
          ctx.stroke();
        }
      }

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(cx - 3, cy - r * 0.5 - 2, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 3, cy - r * 0.5 - 2, 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#f00';
      ctx.beginPath(); ctx.arc(cx - 3, cy - r * 0.5 - 2, 1, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 3, cy - r * 0.5 - 2, 1, 0, Math.PI * 2); ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawFlea() {
      const cx = flea.x + CELL / 2;
      const cy = flea.y + CELL / 2;

      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 8;

      // Body
      ctx.beginPath();
      ctx.ellipse(cx, cy, CELL * 0.3, CELL * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Trail effect
      ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(cx, cy - CELL * 0.4, CELL * 0.15, CELL * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#f00';
      ctx.beginPath(); ctx.arc(cx - 3, cy - 3, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 3, cy - 3, 2, 0, Math.PI * 2); ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawPlayer() {
      const x = player.x;
      const y = player.y;

      ctx.fillStyle = '#6f8';
      ctx.shadowColor = '#6f8';
      ctx.shadowBlur = 10;

      // Ship body (arrow/triangle shape)
      ctx.beginPath();
      ctx.moveTo(x + CELL / 2, y);
      ctx.lineTo(x + CELL, y + CELL);
      ctx.lineTo(x + CELL * 0.7, y + CELL * 0.75);
      ctx.lineTo(x + CELL * 0.3, y + CELL * 0.75);
      ctx.lineTo(x, y + CELL);
      ctx.closePath();
      ctx.fill();

      // Gun barrel
      ctx.fillRect(x + CELL / 2 - 1.5, y - 4, 3, 6);

      ctx.shadowBlur = 0;
    }

    // -- Input --
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pocket Generals</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #e55; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 85, 85, 0.5); }
    h1 { color: #e55; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 85, 85, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e55; }
    canvas {
      border: 2px solid #e55;
      box-shadow: 0 0 20px rgba(238, 85, 85, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e55;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>POCKET GENERALS</h1>
  </div>
  <div class="score-bar">
    <div>Player: <span id="score">0</span> pts</div>
    <div id="turnIndicator" style="color:#e55;">--</div>
    <div>AI: <span id="aiScore">0</span> pts</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">POCKET GENERALS</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const turnIndicatorEl = document.getElementById('turnIndicator');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let aiScore = 0;

    // Grid constants
    const COLS = 8, ROWS = 8;
    const CELL_W = 60, CELL_H = 50;
    const GRID_X = (W - COLS * CELL_W) / 2;   // 60
    const GRID_Y = 10;
    const GRID_BOTTOM = GRID_Y + ROWS * CELL_H; // 410
    const BTN_Y = GRID_BOTTOM + 16;
    const BTN_W = 120, BTN_H = 36;
    const BTN_X = (W - BTN_W) / 2;

    // Terrain types
    const PLAIN = 0, MOUNTAIN = 1, FOREST = 2;
    const TERRAIN_NAMES = ['Plains', 'Mountain', 'Forest'];

    // Unit types
    const INFANTRY = 'infantry';
    const TANK = 'tank';
    const ARTILLERY = 'artillery';

    const UNIT_STATS = {
      [INFANTRY]:  { move: 1, hp: 3, atk: 2, minRange: 1, maxRange: 1, value: 10 },
      [TANK]:      { move: 2, hp: 5, atk: 4, minRange: 1, maxRange: 1, value: 20 },
      [ARTILLERY]: { move: 1, hp: 2, atk: 5, minRange: 2, maxRange: 3, value: 15 },
    };

    // Game state
    let terrain = [];
    let units = [];
    let bases = { player: null, ai: null };
    let currentTurn = 'player'; // 'player' or 'ai'
    let phase = 'select'; // 'select', 'move', 'attack', 'aiTurn', 'animating'
    let selectedUnit = null;
    let movableCells = [];
    let attackableCells = [];
    let movedUnits = new Set();
    let hoverCell = null;
    let animFrame = null;
    let turnNumber = 0;
    let statusMessage = '';

    // ===================== MAP GENERATION =====================

    function generateTerrain() {
      terrain = [];
      for (let r = 0; r < ROWS; r++) {
        terrain[r] = [];
        for (let c = 0; c < COLS; c++) {
          terrain[r][c] = PLAIN;
        }
      }
      // Place mountains (impassable) - symmetrical
      const mountainPositions = [[2, 3], [2, 4], [5, 3], [5, 4], [3, 1], [4, 6]];
      mountainPositions.forEach(([r, c]) => {
        terrain[r][c] = MOUNTAIN;
        terrain[ROWS - 1 - r][COLS - 1 - c] = MOUNTAIN;
      });
      // Remove duplicates from symmetry
      // Place forests (defense bonus) - symmetrical
      const forestPositions = [[1, 2], [1, 5], [3, 3], [4, 4], [6, 1], [6, 6], [2, 6], [5, 1]];
      forestPositions.forEach(([r, c]) => {
        if (terrain[r][c] === PLAIN) terrain[r][c] = FOREST;
        const sr = ROWS - 1 - r, sc = COLS - 1 - c;
        if (terrain[sr][sc] === PLAIN) terrain[sr][sc] = FOREST;
      });
      // Ensure base positions and adjacent cells are plain
      terrain[0][0] = PLAIN; terrain[0][1] = PLAIN; terrain[1][0] = PLAIN;
      terrain[7][7] = PLAIN; terrain[7][6] = PLAIN; terrain[6][7] = PLAIN;
    }

    function createUnit(type, team, row, col) {
      const stats = UNIT_STATS[type];
      return {
        type, team, row, col,
        hp: stats.hp, maxHp: stats.hp,
        atk: stats.atk, move: stats.move,
        minRange: stats.minRange, maxRange: stats.maxRange,
        id: Math.random().toString(36).substr(2, 9)
      };
    }

    function initGame() {
      generateTerrain();
      units = [];
      movedUnits = new Set();

      // Player units (blue) - bottom-left area
      units.push(createUnit(INFANTRY, 'player', 7, 1));
      units.push(createUnit(INFANTRY, 'player', 6, 0));
      units.push(createUnit(INFANTRY, 'player', 7, 2));
      units.push(createUnit(TANK, 'player', 6, 1));
      units.push(createUnit(ARTILLERY, 'player', 7, 0));

      // AI units (red) - top-right area
      units.push(createUnit(INFANTRY, 'ai', 0, 6));
      units.push(createUnit(INFANTRY, 'ai', 1, 7));
      units.push(createUnit(INFANTRY, 'ai', 0, 5));
      units.push(createUnit(TANK, 'ai', 1, 6));
      units.push(createUnit(ARTILLERY, 'ai', 0, 7));

      // Bases
      bases.player = { row: 7, col: 0 };
      bases.ai = { row: 0, col: 7 };

      currentTurn = 'player';
      phase = 'select';
      selectedUnit = null;
      movableCells = [];
      attackableCells = [];
      turnNumber = 1;
      score = 0;
      aiScore = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      statusMessage = '';
    }

    // ===================== PATHFINDING & RANGE =====================

    function getUnitAt(r, c) {
      return units.find(u => u.row === r && u.col === c && u.hp > 0);
    }

    function manhattan(r1, c1, r2, c2) {
      return Math.abs(r1 - r2) + Math.abs(c1 - c2);
    }

    function inBounds(r, c) {
      return r >= 0 && r < ROWS && c >= 0 && c < COLS;
    }

    function getMovableCells(unit) {
      const cells = [];
      const visited = {};
      const queue = [{ r: unit.row, c: unit.col, steps: 0 }];
      visited[`${unit.row},${unit.col}`] = true;

      while (queue.length > 0) {
        const { r, c, steps } = queue.shift();
        if (steps > 0) {
          const occupant = getUnitAt(r, c);
          if (!occupant) cells.push({ r, c });
        }
        if (steps < unit.move) {
          const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
          for (const [dr, dc] of dirs) {
            const nr = r + dr, nc = c + dc;
            const key = `${nr},${nc}`;
            if (inBounds(nr, nc) && !visited[key] && terrain[nr][nc] !== MOUNTAIN) {
              const occupant = getUnitAt(nr, nc);
              if (!occupant || (occupant.team === unit.team && steps + 1 < unit.move)) {
                // Can pass through friendly units but not stop on them
                visited[key] = true;
                queue.push({ r: nr, c: nc, steps: steps + 1 });
              }
            }
          }
        }
      }
      return cells;
    }

    function getAttackableCells(unit, fromRow, fromCol) {
      const cells = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const dist = manhattan(fromRow !== undefined ? fromRow : unit.row,
                                  fromCol !== undefined ? fromCol : unit.col, r, c);
          if (dist >= unit.minRange && dist <= unit.maxRange) {
            const target = getUnitAt(r, c);
            if (target && target.team !== unit.team) {
              cells.push({ r, c });
            }
          }
        }
      }
      return cells;
    }

    // Check if any enemies are attackable from the unit's current position
    function canAttackFromPosition(unit) {
      return getAttackableCells(unit, unit.row, unit.col).length > 0;
    }

    // ===================== COMBAT =====================

    function getTerrainDefenseBonus(r, c) {
      return terrain[r][c] === FOREST ? 1 : 0;
    }

    function performAttack(attacker, defender) {
      const defBonus = getTerrainDefenseBonus(defender.row, defender.col);
      const damage = Math.max(1, attacker.atk - defBonus);
      defender.hp -= damage;
      let killed = false;
      if (defender.hp <= 0) {
        defender.hp = 0;
        killed = true;
        if (attacker.team === 'player') {
          score += UNIT_STATS[defender.type].value;
          scoreEl.textContent = score;
        } else {
          aiScore += UNIT_STATS[defender.type].value;
          aiScoreEl.textContent = aiScore;
        }
      }
      return { damage, killed };
    }

    // ===================== WIN CHECK =====================

    function checkVictory() {
      const playerUnits = units.filter(u => u.team === 'player' && u.hp > 0);
      const aiUnits = units.filter(u => u.team === 'ai' && u.hp > 0);

      // Check base capture
      const unitOnAiBase = units.find(u => u.team === 'player' && u.hp > 0 &&
                                        u.row === bases.ai.row && u.col === bases.ai.col);
      const unitOnPlayerBase = units.find(u => u.team === 'ai' && u.hp > 0 &&
                                            u.row === bases.player.row && u.col === bases.player.col);

      if (unitOnAiBase || aiUnits.length === 0) return 'player';
      if (unitOnPlayerBase || playerUnits.length === 0) return 'ai';
      return null;
    }

    // ===================== AI (Minimax) =====================

    function cloneState() {
      return {
        units: units.filter(u => u.hp > 0).map(u => ({ ...u })),
        terrain: terrain // terrain doesn't change
      };
    }

    function restoreState(state) {
      units = state.units;
    }

    function evaluateBoard(state) {
      let playerScore = 0, aiScoreVal = 0;
      for (const u of state.units) {
        if (u.hp <= 0) continue;
        const stats = UNIT_STATS[u.type];
        const hpRatio = u.hp / stats.hp;
        let val = stats.value * hpRatio;
        // Positional bonus - closer to enemy base is better
        if (u.team === 'ai') {
          const distToBase = manhattan(u.row, u.col, bases.player.row, bases.player.col);
          val += (14 - distToBase) * 0.5; // max manhattan on 8x8 is 14
          // Protect artillery: bonus if infantry is adjacent
          if (u.type === ARTILLERY) {
            const hasGuard = state.units.some(g => g.team === 'ai' && g.hp > 0 &&
              g.type === INFANTRY && manhattan(g.row, g.col, u.row, u.col) <= 1);
            if (hasGuard) val += 3;
          }
          aiScoreVal += val;
        } else {
          const distToBase = manhattan(u.row, u.col, bases.ai.row, bases.ai.col);
          val += (14 - distToBase) * 0.5;
          playerScore += val;
        }
      }
      // Check base capture threats
      const aiOnPlayerBase = state.units.some(u => u.team === 'ai' && u.hp > 0 &&
        u.row === bases.player.row && u.col === bases.player.col);
      const playerOnAiBase = state.units.some(u => u.team === 'player' && u.hp > 0 &&
        u.row === bases.ai.row && u.col === bases.ai.col);
      if (aiOnPlayerBase) aiScoreVal += 100;
      if (playerOnAiBase) playerScore += 100;

      return aiScoreVal - playerScore;
    }

    function getAIMoves(state) {
      const moves = [];
      const aiUnits = state.units.filter(u => u.team === 'ai' && u.hp > 0);

      for (const unit of aiUnits) {
        // Get movable cells for this unit
        const origGetUnitAt = (r, c) => state.units.find(u => u.row === r && u.col === c && u.hp > 0);
        const moveCells = [{ r: unit.row, c: unit.col }]; // Can stay in place

        // BFS for movement
        const visited = {};
        const queue = [{ r: unit.row, c: unit.col, steps: 0 }];
        visited[`${unit.row},${unit.col}`] = true;
        while (queue.length > 0) {
          const { r, c, steps } = queue.shift();
          if (steps > 0) {
            const occupant = origGetUnitAt(r, c);
            if (!occupant) moveCells.push({ r, c });
          }
          if (steps < unit.move) {
            for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
              const nr = r + dr, nc = c + dc;
              const key = `${nr},${nc}`;
              if (inBounds(nr, nc) && !visited[key] && terrain[nr][nc] !== MOUNTAIN) {
                const occ = origGetUnitAt(nr, nc);
                if (!occ || (occ.team === 'ai' && occ.id !== unit.id)) {
                  visited[key] = true;
                  queue.push({ r: nr, c: nc, steps: steps + 1 });
                }
              }
            }
          }
        }

        for (const mc of moveCells) {
          // Check attack targets from this position
          const attackTargets = [];
          for (const t of state.units) {
            if (t.team === 'player' && t.hp > 0) {
              const dist = manhattan(mc.r, mc.c, t.row, t.col);
              if (dist >= unit.minRange && dist <= unit.maxRange) {
                attackTargets.push(t);
              }
            }
          }

          if (attackTargets.length > 0) {
            for (const target of attackTargets) {
              moves.push({ unit, moveTo: mc, attack: target });
            }
          } else {
            moves.push({ unit, moveTo: mc, attack: null });
          }
        }
      }
      return moves;
    }

    function aiMinimax(state, depth, isMax, alpha, beta) {
      // Terminal or depth 0
      const aiAlive = state.units.filter(u => u.team === 'ai' && u.hp > 0);
      const plAlive = state.units.filter(u => u.team === 'player' && u.hp > 0);
      if (aiAlive.length === 0) return -1000;
      if (plAlive.length === 0) return 1000;
      if (depth === 0) return evaluateBoard(state);

      if (isMax) {
        // AI turn - try each AI unit's best move independently
        let best = -Infinity;
        const moves = getAIMoves(state);
        if (moves.length === 0) return evaluateBoard(state);

        // Limit branching - take top 8 moves by heuristic
        const scoredMoves = moves.map(m => {
          let h = 0;
          if (m.attack) {
            h += m.attack.hp <= m.unit.atk ? 50 : m.unit.atk * 3;
            h += UNIT_STATS[m.attack.type].value;
          }
          h += (ROWS - manhattan(m.moveTo.r, m.moveTo.c, bases.player.row, bases.player.col)) * 0.5;
          return { ...m, h };
        });
        scoredMoves.sort((a, b) => b.h - a.h);
        const topMoves = scoredMoves.slice(0, 8);

        for (const move of topMoves) {
          const saved = {
            unitRow: move.unit.row, unitCol: move.unit.col,
            targetHp: move.attack ? move.attack.hp : 0
          };
          // Apply move
          move.unit.row = move.moveTo.r;
          move.unit.col = move.moveTo.c;
          if (move.attack) {
            const defBonus = getTerrainDefenseBonus(move.attack.row, move.attack.col);
            move.attack.hp -= Math.max(1, move.unit.atk - defBonus);
          }

          const val = aiMinimax(state, depth - 1, false, alpha, beta);
          best = Math.max(best, val);
          alpha = Math.max(alpha, val);

          // Undo
          move.unit.row = saved.unitRow;
          move.unit.col = saved.unitCol;
          if (move.attack) move.attack.hp = saved.targetHp;

          if (beta <= alpha) break;
        }
        return best;
      } else {
        // Simulate player turn simply - evaluate board
        return evaluateBoard(state);
      }
    }

    function aiTakeTurn() {
      phase = 'aiTurn';
      turnIndicatorEl.textContent = 'AI Turn...';
      statusMessage = 'AI is thinking...';

      setTimeout(() => {
        const aiUnits = units.filter(u => u.team === 'ai' && u.hp > 0);
        const moveQueue = [];

        // For each AI unit, find its best move
        const usedCells = new Set(); // Track cells claimed by earlier units this turn

        // Sort AI units: artillery first (so they attack from range), then tanks, then infantry
        const sortedUnits = [...aiUnits].sort((a, b) => {
          const order = { artillery: 0, tank: 1, infantry: 2 };
          return order[a.type] - order[b.type];
        });

        for (const unit of sortedUnits) {
          const state = cloneState();
          const stateUnit = state.units.find(u => u.id === unit.id);
          if (!stateUnit || stateUnit.hp <= 0) continue;

          let bestScore = -Infinity;
          let bestMove = null;

          // Get possible moves for this single unit
          const moveCells = [{ r: unit.row, c: unit.col }];
          const visited = {};
          const queue = [{ r: unit.row, c: unit.col, steps: 0 }];
          visited[`${unit.row},${unit.col}`] = true;
          while (queue.length > 0) {
            const { r, c, steps } = queue.shift();
            if (steps > 0) {
              const occupant = getUnitAt(r, c);
              if (!occupant && !usedCells.has(`${r},${c}`)) {
                moveCells.push({ r, c });
              }
            }
            if (steps < unit.move) {
              for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                const nr = r + dr, nc = c + dc;
                const key = `${nr},${nc}`;
                if (inBounds(nr, nc) && !visited[key] && terrain[nr][nc] !== MOUNTAIN) {
                  const occ = getUnitAt(nr, nc);
                  if (!occ || occ.team === 'ai') {
                    visited[key] = true;
                    queue.push({ r: nr, c: nc, steps: steps + 1 });
                  }
                }
              }
            }
          }

          for (const mc of moveCells) {
            // Find attack targets from this position
            const targets = [];
            for (const t of units) {
              if (t.team === 'player' && t.hp > 0) {
                const dist = manhattan(mc.r, mc.c, t.row, t.col);
                if (dist >= unit.minRange && dist <= unit.maxRange) {
                  targets.push(t);
                }
              }
            }

            const tryAttacks = targets.length > 0 ? targets : [null];
            for (const target of tryAttacks) {
              // Evaluate using minimax
              const saved = {
                unitRow: stateUnit.row, unitCol: stateUnit.col,
                targetHp: target ? state.units.find(u => u.id === target.id)?.hp : 0,
                targetRef: target ? state.units.find(u => u.id === target.id) : null
              };

              stateUnit.row = mc.r;
              stateUnit.col = mc.c;
              if (target && saved.targetRef) {
                const defBonus = getTerrainDefenseBonus(target.row, target.col);
                saved.targetRef.hp -= Math.max(1, unit.atk - defBonus);
              }

              const val = aiMinimax(state, 1, false, -Infinity, Infinity);

              // Undo
              stateUnit.row = saved.unitRow;
              stateUnit.col = saved.unitCol;
              if (saved.targetRef) saved.targetRef.hp = saved.targetHp;

              // Prefer attacking weakened enemies
              let bonus = 0;
              if (target) {
                bonus += 5;
                if (target.hp <= unit.atk) bonus += 15; // Can kill
              }
              // Penalty for artillery moving adjacent to enemies
              if (unit.type === ARTILLERY) {
                const adjEnemy = units.some(u => u.team === 'player' && u.hp > 0 &&
                  manhattan(mc.r, mc.c, u.row, u.col) === 1);
                if (adjEnemy) bonus -= 10;
              }

              const totalScore = val + bonus;
              if (totalScore > bestScore) {
                bestScore = totalScore;
                bestMove = { unit, moveTo: mc, attack: target };
              }
            }
          }

          if (bestMove) {
            moveQueue.push(bestMove);
            usedCells.add(`${bestMove.moveTo.r},${bestMove.moveTo.c}`);
          }
        }

        // Execute AI moves sequentially with animation delay
        executeAIMoves(moveQueue, 0);
      }, 300);
    }

    function executeAIMoves(queue, index) {
      if (index >= queue.length) {
        // AI turn done, check victory
        const victor = checkVictory();
        if (victor) {
          endGame(victor);
          return;
        }
        // Switch to player
        currentTurn = 'player';
        phase = 'select';
        movedUnits = new Set();
        turnNumber++;
        turnIndicatorEl.textContent = 'Your Turn';
        statusMessage = `Turn ${turnNumber} - Select a unit`;
        draw();
        return;
      }

      const move = queue[index];
      if (move.unit.hp <= 0) {
        executeAIMoves(queue, index + 1);
        return;
      }

      // Move
      move.unit.row = move.moveTo.r;
      move.unit.col = move.moveTo.c;
      statusMessage = `AI moves ${move.unit.type}`;
      draw();

      setTimeout(() => {
        // Attack
        if (move.attack && move.attack.hp > 0) {
          const result = performAttack(move.unit, move.attack);
          statusMessage = `AI ${move.unit.type} attacks! ${result.damage} dmg${result.killed ? ' - DESTROYED!' : ''}`;
          if (result.killed) {
            units = units.filter(u => u.hp > 0);
          }
          draw();

          // Check victory after attack
          const victor = checkVictory();
          if (victor) {
            setTimeout(() => endGame(victor), 400);
            return;
          }
        }

        setTimeout(() => executeAIMoves(queue, index + 1), 350);
      }, 300);
    }

    // ===================== TURN MANAGEMENT =====================

    function endPlayerTurn() {
      if (currentTurn !== 'player' || phase === 'aiTurn' || phase === 'animating') return;
      selectedUnit = null;
      movableCells = [];
      attackableCells = [];
      phase = 'select';

      // Check victory
      const victor = checkVictory();
      if (victor) {
        endGame(victor);
        return;
      }

      currentTurn = 'ai';
      draw();
      aiTakeTurn();
    }

    function endGame(winner) {
      gameState = 'over';
      if (winner === 'player') {
        overlayTitle.textContent = 'VICTORY!';
        overlayText.textContent = `Score: ${score} pts - Click to play again`;
        overlay.style.display = 'flex';
      } else {
        overlayTitle.textContent = 'DEFEAT';
        overlayText.textContent = `Score: ${score} pts - Click to play again`;
        overlay.style.display = 'flex';
      }
    }

    // ===================== DRAWING =====================

    function drawTerrain() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x = GRID_X + c * CELL_W;
          const y = GRID_Y + r * CELL_H;
          const t = terrain[r][c];

          // Base color
          if (t === PLAIN) {
            ctx.fillStyle = '#2a2a3e';
          } else if (t === MOUNTAIN) {
            ctx.fillStyle = '#3a3a4e';
          } else if (t === FOREST) {
            ctx.fillStyle = '#2a4a2a';
          }
          ctx.fillRect(x, y, CELL_W, CELL_H);

          // Grid lines
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, CELL_W, CELL_H);

          // Mountain icon
          if (t === MOUNTAIN) {
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.moveTo(x + CELL_W * 0.3, y + CELL_H * 0.75);
            ctx.lineTo(x + CELL_W * 0.5, y + CELL_H * 0.25);
            ctx.lineTo(x + CELL_W * 0.7, y + CELL_H * 0.75);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(x + CELL_W * 0.42, y + CELL_H * 0.5);
            ctx.lineTo(x + CELL_W * 0.5, y + CELL_H * 0.35);
            ctx.lineTo(x + CELL_W * 0.58, y + CELL_H * 0.5);
            ctx.closePath();
            ctx.fill();
          }

          // Forest icon
          if (t === FOREST) {
            ctx.fillStyle = '#3a7a3a';
            // Tree trunk
            ctx.fillRect(x + CELL_W * 0.46, y + CELL_H * 0.6, CELL_W * 0.08, CELL_H * 0.2);
            // Canopy
            ctx.beginPath();
            ctx.moveTo(x + CELL_W * 0.3, y + CELL_H * 0.65);
            ctx.lineTo(x + CELL_W * 0.5, y + CELL_H * 0.2);
            ctx.lineTo(x + CELL_W * 0.7, y + CELL_H * 0.65);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      // Draw bases
      drawBase(bases.player.row, bases.player.col, '#4488ff');
      drawBase(bases.ai.row, bases.ai.col, '#e55');
    }

    function drawBase(r, c, color) {
      const x = GRID_X + c * CELL_W;
      const y = GRID_Y + r * CELL_H;
      ctx.fillStyle = color + '33';
      ctx.fillRect(x + 2, y + 2, CELL_W - 4, CELL_H - 4);
      // Flag
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + CELL_W * 0.35, y + CELL_H * 0.2);
      ctx.lineTo(x + CELL_W * 0.35, y + CELL_H * 0.8);
      ctx.stroke();
      ctx.fillStyle = color + 'aa';
      ctx.beginPath();
      ctx.moveTo(x + CELL_W * 0.35, y + CELL_H * 0.2);
      ctx.lineTo(x + CELL_W * 0.7, y + CELL_H * 0.32);
      ctx.lineTo(x + CELL_W * 0.35, y + CELL_H * 0.45);
      ctx.closePath();
      ctx.fill();
      // BASE text
      ctx.fillStyle = color;
      ctx.font = 'bold 8px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('BASE', x + CELL_W / 2, y + CELL_H * 0.92);
    }

    function drawHighlights() {
      // Movement range
      for (const cell of movableCells) {
        const x = GRID_X + cell.c * CELL_W;
        const y = GRID_Y + cell.r * CELL_H;
        ctx.fillStyle = 'rgba(68, 136, 255, 0.25)';
        ctx.fillRect(x + 1, y + 1, CELL_W - 2, CELL_H - 2);
        ctx.strokeStyle = 'rgba(68, 136, 255, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 2, y + 2, CELL_W - 4, CELL_H - 4);
      }

      // Attack range
      for (const cell of attackableCells) {
        const x = GRID_X + cell.c * CELL_W;
        const y = GRID_Y + cell.r * CELL_H;
        ctx.fillStyle = 'rgba(238, 85, 85, 0.3)';
        ctx.fillRect(x + 1, y + 1, CELL_W - 2, CELL_H - 2);
        ctx.strokeStyle = 'rgba(238, 85, 85, 0.7)';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 2, y + 2, CELL_W - 4, CELL_H - 4);
      }
    }

    function drawUnit(unit) {
      if (unit.hp <= 0) return;
      const x = GRID_X + unit.col * CELL_W + CELL_W / 2;
      const y = GRID_Y + unit.row * CELL_H + CELL_H / 2;
      const isPlayer = unit.team === 'player';
      const baseColor = isPlayer ? '#4488ff' : '#e55';
      const darkColor = isPlayer ? '#2266cc' : '#c33';
      const isMoved = movedUnits.has(unit.id);
      const isSelected = selectedUnit && selectedUnit.id === unit.id;

      // Selection glow
      if (isSelected) {
        ctx.shadowColor = baseColor;
        ctx.shadowBlur = 12;
      }

      // Dim moved units
      const alpha = (isMoved && currentTurn === 'player' && unit.team === 'player') ? 0.5 : 1.0;
      ctx.globalAlpha = alpha;

      if (unit.type === INFANTRY) {
        // Small square
        const size = 14;
        ctx.fillStyle = baseColor;
        ctx.fillRect(x - size / 2, y - size / 2, size, size);
        ctx.strokeStyle = darkColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x - size / 2, y - size / 2, size, size);
      } else if (unit.type === TANK) {
        // Larger diamond
        const size = 16;
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x, y + size);
        ctx.lineTo(x - size, y);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = darkColor;
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (unit.type === ARTILLERY) {
        // Triangle
        const size = 14;
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size, y + size * 0.7);
        ctx.lineTo(x - size, y + size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = darkColor;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1.0;

      // HP bar
      const barW = CELL_W * 0.65;
      const barH = 4;
      const barX = x - barW / 2;
      const barY = GRID_Y + unit.row * CELL_H + CELL_H - 10;
      const hpRatio = unit.hp / unit.maxHp;

      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpRatio > 0.5 ? '#4c4' : hpRatio > 0.25 ? '#cc4' : '#c44';
      ctx.fillRect(barX, barY, barW * hpRatio, barH);

      // Unit type label
      ctx.fillStyle = '#ddd';
      ctx.font = '8px Courier New';
      ctx.textAlign = 'center';
      const label = unit.type === INFANTRY ? 'INF' : unit.type === TANK ? 'TNK' : 'ART';
      ctx.fillText(label, x, GRID_Y + unit.row * CELL_H + 10);
    }

    function drawEndTurnButton() {
      if (currentTurn !== 'player' || gameState !== 'playing') return;

      const isHover = hoverCell && hoverCell.btn;
      ctx.fillStyle = isHover ? 'rgba(238, 85, 85, 0.4)' : 'rgba(238, 85, 85, 0.2)';
      ctx.fillRect(BTN_X, BTN_Y, BTN_W, BTN_H);
      ctx.strokeStyle = '#e55';
      ctx.lineWidth = 2;
      ctx.strokeRect(BTN_X, BTN_Y, BTN_W, BTN_H);
      ctx.fillStyle = '#e55';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('END TURN', BTN_X + BTN_W / 2, BTN_Y + BTN_H / 2);
      ctx.textBaseline = 'alphabetic';
    }

    function drawStatusBar() {
      const y = GRID_BOTTOM + 60;
      ctx.fillStyle = '#888';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';
      if (statusMessage) {
        ctx.fillText(statusMessage, W / 2, y);
      }

      // Hover info
      if (hoverCell && hoverCell.r !== undefined && inBounds(hoverCell.r, hoverCell.c)) {
        const t = TERRAIN_NAMES[terrain[hoverCell.r][hoverCell.c]];
        const u = getUnitAt(hoverCell.r, hoverCell.c);
        let info = `${t}`;
        if (terrain[hoverCell.r][hoverCell.c] === FOREST) info += ' (+1 DEF)';
        if (u) {
          const stats = UNIT_STATS[u.type];
          info += ` | ${u.team === 'player' ? 'Player' : 'AI'} ${u.type} HP:${u.hp}/${stats.hp} ATK:${stats.atk}`;
          if (u.type === ARTILLERY) info += ` RNG:${stats.minRange}-${stats.maxRange}`;
        }
        ctx.fillStyle = '#aaa';
        ctx.fillText(info, W / 2, y + 16);
      }
    }

    function drawTurnBanner() {
      // Turn number in top area
      ctx.fillStyle = '#666';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`Turn ${turnNumber}`, GRID_X + COLS * CELL_W - 4, GRID_Y + ROWS * CELL_H + 80);
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawTerrain();
      drawHighlights();

      // Draw all alive units
      for (const unit of units) {
        if (unit.hp > 0) drawUnit(unit);
      }

      drawEndTurnButton();
      drawStatusBar();
      drawTurnBanner();
    }

    // ===================== INPUT HANDLING =====================

    function getCellFromMouse(mx, my) {
      const c = Math.floor((mx - GRID_X) / CELL_W);
      const r = Math.floor((my - GRID_Y) / CELL_H);
      if (r >= 0 && r < ROWS && c >= 0 && c < COLS) return { r, c };
      return null;
    }

    function isInButton(mx, my) {
      return mx >= BTN_X && mx <= BTN_X + BTN_W && my >= BTN_Y && my <= BTN_Y + BTN_H;
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = getCellFromMouse(mx, my);
      if (cell) {
        hoverCell = cell;
      } else if (isInButton(mx, my)) {
        hoverCell = { btn: true };
      } else {
        hoverCell = null;
      }
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (gameState === 'waiting') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        turnIndicatorEl.textContent = 'Your Turn';
        statusMessage = `Turn ${turnNumber} - Select a unit`;
        draw();
        return;
      }

      if (gameState === 'over') {
        gameState = 'playing';
        overlay.style.display = 'none';
        initGame();
        turnIndicatorEl.textContent = 'Your Turn';
        statusMessage = `Turn ${turnNumber} - Select a unit`;
        draw();
        return;
      }

      if (gameState !== 'playing') return;
      if (currentTurn !== 'player') return;
      if (phase === 'aiTurn' || phase === 'animating') return;

      // Check End Turn button
      if (isInButton(mx, my)) {
        endPlayerTurn();
        return;
      }

      const cell = getCellFromMouse(mx, my);
      if (!cell) return;

      handlePlayerClick(cell.r, cell.c);
    });

    function handlePlayerClick(r, c) {
      if (phase === 'select') {
        // Select a player unit
        const unit = getUnitAt(r, c);
        if (unit && unit.team === 'player' && !movedUnits.has(unit.id)) {
          selectedUnit = unit;
          movableCells = getMovableCells(unit);
          // Also show attack range from current position
          attackableCells = getAttackableCells(unit, unit.row, unit.col);
          phase = 'move';
          statusMessage = `${unit.type} selected - Click to move or attack`;
          draw();
        } else if (unit && unit.team === 'player' && movedUnits.has(unit.id)) {
          statusMessage = 'That unit already moved this turn';
          draw();
        }
      } else if (phase === 'move') {
        // Check if clicking an enemy in attack range (attack without moving)
        const target = getUnitAt(r, c);
        if (target && target.team === 'ai' && target.hp > 0) {
          const dist = manhattan(selectedUnit.row, selectedUnit.col, r, c);
          if (dist >= selectedUnit.minRange && dist <= selectedUnit.maxRange) {
            // Attack from current position
            const result = performAttack(selectedUnit, target);
            statusMessage = `${selectedUnit.type} attacks ${target.type}! ${result.damage} dmg${result.killed ? ' - DESTROYED!' : ''}`;
            if (result.killed) {
              units = units.filter(u => u.hp > 0);
            }
            movedUnits.add(selectedUnit.id);
            selectedUnit = null;
            movableCells = [];
            attackableCells = [];
            phase = 'select';

            const victor = checkVictory();
            if (victor) {
              draw();
              setTimeout(() => endGame(victor), 300);
              return;
            }
            draw();
            return;
          }
        }

        // Check if clicking a movable cell
        const isMovable = movableCells.some(m => m.r === r && m.c === c);
        if (isMovable) {
          selectedUnit.row = r;
          selectedUnit.col = c;

          // After moving, check for attack targets
          attackableCells = getAttackableCells(selectedUnit, r, c);
          movableCells = [];

          if (attackableCells.length > 0) {
            phase = 'attack';
            statusMessage = `Click enemy to attack or click elsewhere to skip`;
            draw();
          } else {
            // No targets - end this unit's turn
            movedUnits.add(selectedUnit.id);

            // Check base capture
            const victor = checkVictory();
            if (victor) {
              draw();
              setTimeout(() => endGame(victor), 300);
              return;
            }

            selectedUnit = null;
            attackableCells = [];
            phase = 'select';
            statusMessage = 'Select another unit or End Turn';
            draw();
          }
          return;
        }

        // Clicking own unit or empty non-movable: deselect
        selectedUnit = null;
        movableCells = [];
        attackableCells = [];
        phase = 'select';

        // Maybe selecting a different unit
        const newUnit = getUnitAt(r, c);
        if (newUnit && newUnit.team === 'player' && !movedUnits.has(newUnit.id)) {
          selectedUnit = newUnit;
          movableCells = getMovableCells(newUnit);
          attackableCells = getAttackableCells(newUnit, newUnit.row, newUnit.col);
          phase = 'move';
          statusMessage = `${newUnit.type} selected - Click to move or attack`;
        } else {
          statusMessage = 'Select a unit';
        }
        draw();
      } else if (phase === 'attack') {
        // Check if clicking an attackable enemy
        const isAttackable = attackableCells.some(a => a.r === r && a.c === c);
        if (isAttackable) {
          const target = getUnitAt(r, c);
          if (target && target.team === 'ai') {
            const result = performAttack(selectedUnit, target);
            statusMessage = `${selectedUnit.type} attacks ${target.type}! ${result.damage} dmg${result.killed ? ' - DESTROYED!' : ''}`;
            if (result.killed) {
              units = units.filter(u => u.hp > 0);
            }
          }
        } else {
          statusMessage = 'Attack skipped';
        }

        movedUnits.add(selectedUnit.id);
        selectedUnit = null;
        movableCells = [];
        attackableCells = [];
        phase = 'select';

        const victor = checkVictory();
        if (victor) {
          draw();
          setTimeout(() => endGame(victor), 300);
          return;
        }
        draw();
      }
    }

    // ===================== GAME LOOP =====================

    function gameLoop() {
      if (gameState === 'playing') {
        // Turn-based, so we just redraw when needed
        // But we keep the loop for smooth hover effects
      }
      animFrame = requestAnimationFrame(gameLoop);
    }

    // Initial draw for waiting state
    function init() {
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'POCKET GENERALS';
      overlayText.textContent = 'Click to Start';
      turnIndicatorEl.textContent = '--';

      // Draw a preview board
      initGame();
      draw();

      // Re-show overlay
      overlay.style.display = 'flex';
      gameState = 'waiting';

      gameLoop();
    }

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>XCOM Tactics</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4e8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 238, 136, 0.5); }
    h1 { color: #4e8; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 238, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4e8; }
    canvas {
      border: 2px solid #4e8;
      box-shadow: 0 0 20px rgba(68, 238, 136, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4e8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>XCOM TACTICS</h1>
  </div>
  <div class="score-bar">
    <div>Kills: <span id="score">0</span></div>
    <div id="turnInfo" style="color:#aaa;font-size:0.9rem;">YOUR TURN</div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">XCOM TACTICS</h2>
      <p id="overlayText">Click to deploy your squad</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const turnInfoEl = document.getElementById('turnInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    canvas.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState === 'playing') {
        if (e.key === 'e' || e.key === 'E') endTurn();
        if (e.key === 'g' || e.key === 'G') setAction('grenade');
        if (e.key === 'h' || e.key === 'H') setAction('hunker');
        if (e.key === 'Escape') cancelAction();
      }
    });

    let gameState, score, best = 0;

    // Grid
    const COLS = 12, ROWS = 12;
    const CELL = Math.min(Math.floor((W - 40) / COLS), Math.floor((H - 80) / ROWS));
    const OX = Math.floor((W - COLS * CELL) / 2);
    const OY = 36;

    // Cover types
    const COVER_NONE = 0, COVER_HALF = 1, COVER_FULL = 2;
    const COVER_BONUS = { 0: 0, 1: 25, 2: 50 };

    // Game state
    let grid, soldiers, selectedSoldier, currentAction, turn, animQueue, aiThinking;
    let moveRange, shootRange, grenadeRange, overwatchTriggers;
    let floatingTexts, logMessages;

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'XCOM TACTICS';
      overlayText.textContent = 'Click to deploy your squad';
      generateMap();
      draw();
    }

    function generateMap() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = { cover: COVER_NONE, destroyed: false };
        }
      }
      // Place cover objects - walls and crates
      const coverCount = 18 + Math.floor(Math.random() * 8);
      for (let i = 0; i < coverCount; i++) {
        let r = Math.floor(Math.random() * ROWS);
        let c = Math.floor(Math.random() * COLS);
        // Keep spawn areas clear (top 2 rows for AI, bottom 2 for player)
        if (r < 2 || r >= ROWS - 2) continue;
        if (grid[r][c].cover !== COVER_NONE) continue;
        let type = Math.random() < 0.4 ? COVER_FULL : COVER_HALF;
        grid[r][c].cover = type;
        // Sometimes place pairs for walls
        if (type === COVER_FULL && Math.random() < 0.5) {
          let dr = Math.random() < 0.5 ? 0 : 1;
          let dc = dr === 0 ? 1 : 0;
          let nr = r + dr, nc = c + dc;
          if (nr >= 2 && nr < ROWS - 2 && nc >= 0 && nc < COLS && grid[nr][nc].cover === COVER_NONE) {
            grid[nr][nc].cover = COVER_FULL;
          }
        }
      }

      soldiers = [];
      selectedSoldier = null;
      currentAction = null;
      turn = 'player';
      animQueue = [];
      aiThinking = false;
      moveRange = [];
      shootRange = [];
      grenadeRange = [];
      overwatchTriggers = [];
      floatingTexts = [];
      logMessages = [];

      // Player soldiers (bottom area) - blue team
      const playerNames = ['Alpha', 'Bravo', 'Charlie', 'Delta'];
      const playerPositions = shufflePositions(ROWS - 2, ROWS, 0, COLS);
      for (let i = 0; i < 4; i++) {
        soldiers.push({
          id: i,
          team: 'player',
          name: playerNames[i],
          row: playerPositions[i].r,
          col: playerPositions[i].c,
          hp: 3 + Math.floor(Math.random() * 3), // 3-5
          maxHp: 0,
          moved: false,
          acted: false,
          overwatch: false,
          hunkered: false,
          alive: true,
          color: '#4488ff',
          glowColor: 'rgba(68,136,255,0.4)'
        });
        soldiers[soldiers.length - 1].maxHp = soldiers[soldiers.length - 1].hp;
      }

      // AI soldiers (top area) - red/green team (aliens)
      const aiNames = ['Sectoid-1', 'Sectoid-2', 'Muton-1', 'Muton-2'];
      const aiPositions = shufflePositions(0, 2, 0, COLS);
      for (let i = 0; i < 4; i++) {
        soldiers.push({
          id: i + 4,
          team: 'ai',
          name: aiNames[i],
          row: aiPositions[i].r,
          col: aiPositions[i].c,
          hp: 3 + Math.floor(Math.random() * 3),
          maxHp: 0,
          moved: false,
          acted: false,
          overwatch: false,
          hunkered: false,
          alive: true,
          color: '#e44',
          glowColor: 'rgba(238,68,68,0.4)'
        });
        soldiers[soldiers.length - 1].maxHp = soldiers[soldiers.length - 1].hp;
      }
    }

    function shufflePositions(rMin, rMax, cMin, cMax) {
      let positions = [];
      for (let r = rMin; r < rMax; r++)
        for (let c = cMin; c < cMax; c++)
          positions.push({ r, c });
      // Shuffle
      for (let i = positions.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
      }
      return positions.slice(0, 4);
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      turn = 'player';
      resetTurn('player');
      addLog('Your turn. Select a soldier.');
      draw();
    }

    function endTurn() {
      if (turn !== 'player' || aiThinking) return;
      selectedSoldier = null;
      currentAction = null;
      moveRange = [];
      shootRange = [];
      grenadeRange = [];

      // Check for win
      if (checkWin()) return;

      turn = 'ai';
      turnInfoEl.textContent = 'ALIEN TURN';
      turnInfoEl.style.color = '#e44';
      resetTurn('ai');
      addLog('Alien turn...');
      draw();
      aiThinking = true;
      setTimeout(() => runAI(), 600);
    }

    function resetTurn(team) {
      soldiers.forEach(s => {
        if (s.team === team && s.alive) {
          s.moved = false;
          s.acted = false;
          // Overwatch persists until triggered or new turn
          if (team === s.team) {
            // Keep overwatch from previous turn active
          }
          s.hunkered = false;
        }
      });
      if (team === 'player') {
        turnInfoEl.textContent = 'YOUR TURN  [E] End Turn';
        turnInfoEl.style.color = '#4488ff';
      }
    }

    function checkWin() {
      let playerAlive = soldiers.filter(s => s.team === 'player' && s.alive).length;
      let aiAlive = soldiers.filter(s => s.team === 'ai' && s.alive).length;
      if (aiAlive === 0) {
        gameState = 'over';
        if (score > best) { best = score; bestEl.textContent = best; }
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'VICTORY';
        overlayText.textContent = `Kills: ${score} — Click to play again`;
        return true;
      }
      if (playerAlive === 0) {
        gameState = 'over';
        if (score > best) { best = score; bestEl.textContent = best; }
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'SQUAD WIPED';
        overlayText.textContent = `Kills: ${score} — Click to play again`;
        return true;
      }
      return false;
    }

    // ---- Actions ----
    function setAction(action) {
      if (!selectedSoldier || selectedSoldier.acted || turn !== 'player') return;
      currentAction = action;
      if (action === 'grenade') {
        grenadeRange = getGrenadeRange(selectedSoldier);
      } else if (action === 'hunker') {
        doHunker(selectedSoldier);
        currentAction = null;
      }
      draw();
    }

    function cancelAction() {
      currentAction = null;
      grenadeRange = [];
      draw();
    }

    function getMovementRange(soldier) {
      if (soldier.moved) return [];
      let range = [];
      let maxDist = 4; // Movement range
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let dist = Math.abs(r - soldier.row) + Math.abs(c - soldier.col);
          if (dist > 0 && dist <= maxDist) {
            if (!isOccupied(r, c) && grid[r][c].cover !== COVER_FULL) {
              // Check pathability (simple: just distance for now, but block full cover)
              range.push({ r, c, dist });
            }
          }
        }
      }
      return range;
    }

    function getShootRange(soldier) {
      if (soldier.acted) return [];
      let range = [];
      let enemies = soldiers.filter(s => s.team !== soldier.team && s.alive);
      for (let e of enemies) {
        let dist = Math.abs(e.row - soldier.row) + Math.abs(e.col - soldier.col);
        if (dist <= 10) { // Max shoot range
          let hitChance = calcHitChance(soldier, e);
          range.push({ soldier: e, hitChance, dist });
        }
      }
      return range;
    }

    function getGrenadeRange(soldier) {
      if (soldier.acted) return [];
      let range = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let dist = Math.abs(r - soldier.row) + Math.abs(c - soldier.col);
          if (dist > 0 && dist <= 6) {
            range.push({ r, c });
          }
        }
      }
      return range;
    }

    function calcHitChance(attacker, target) {
      let dist = Math.abs(target.row - attacker.row) + Math.abs(target.col - attacker.col);
      // Base hit chance decreases with distance
      let base = 90 - (dist - 1) * 8;
      base = Math.max(base, 20);

      // Check if target is flanked
      let flanked = isFlanked(attacker, target);

      if (!flanked) {
        // Cover bonus for target
        let coverType = getEffectiveCover(attacker, target);
        base -= COVER_BONUS[coverType];
      }

      // Hunkered bonus
      if (target.hunkered) base -= 20;

      return Math.max(Math.min(base, 95), 5);
    }

    function getEffectiveCover(attacker, target) {
      // Check adjacent cells to target for cover between attacker and target
      let dr = Math.sign(attacker.row - target.row);
      let dc = Math.sign(attacker.col - target.col);

      let bestCover = COVER_NONE;
      // Check the cell in direction of attacker
      let checkPositions = [];
      if (dr !== 0) checkPositions.push({ r: target.row + dr, c: target.col });
      if (dc !== 0) checkPositions.push({ r: target.row, c: target.col + dc });
      if (dr !== 0 && dc !== 0) checkPositions.push({ r: target.row + dr, c: target.col + dc });

      // Also check the target's own cell for destroyed cover
      for (let p of checkPositions) {
        if (p.r >= 0 && p.r < ROWS && p.c >= 0 && p.c < COLS) {
          let cell = grid[p.r][p.c];
          if (!cell.destroyed && cell.cover > bestCover) {
            bestCover = cell.cover;
          }
        }
      }

      // Also check adjacent cells to target (the cell target is hiding behind)
      let adjCells = [
        { r: target.row - 1, c: target.col },
        { r: target.row + 1, c: target.col },
        { r: target.row, c: target.col - 1 },
        { r: target.row, c: target.col + 1 }
      ];

      for (let adj of adjCells) {
        if (adj.r < 0 || adj.r >= ROWS || adj.c < 0 || adj.c >= COLS) continue;
        let cell = grid[adj.r][adj.c];
        if (cell.destroyed || cell.cover === COVER_NONE) continue;
        // Only counts if the cover is between target and attacker
        let toAttacker = { r: attacker.row - target.row, c: attacker.col - target.col };
        let toCover = { r: adj.r - target.row, c: adj.c - target.col };
        let dot = toAttacker.r * toCover.r + toAttacker.c * toCover.c;
        if (dot > 0 && cell.cover > bestCover) {
          bestCover = cell.cover;
        }
      }

      return bestCover;
    }

    function isFlanked(attacker, target) {
      // A target is flanked if attacker approaches from a side with no cover
      let coverDir = getEffectiveCover(attacker, target);
      return coverDir === COVER_NONE;
    }

    function isOccupied(r, c) {
      return soldiers.some(s => s.alive && s.row === r && s.col === c);
    }

    function getSoldierAt(r, c) {
      return soldiers.find(s => s.alive && s.row === r && s.col === c) || null;
    }

    function hasLineOfSight(r1, c1, r2, c2) {
      // Bresenham-ish check for full-cover blocking LOS
      let dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
      let sr = r1 < r2 ? 1 : -1, sc = c1 < c2 ? 1 : -1;
      let err = dr - dc;
      let cr = r1, cc = c1;
      while (cr !== r2 || cc !== c2) {
        let e2 = 2 * err;
        if (e2 > -dc) { err -= dc; cr += sr; }
        if (e2 < dr) { err += dr; cc += sc; }
        if (cr === r2 && cc === c2) break;
        if (cr >= 0 && cr < ROWS && cc >= 0 && cc < COLS) {
          if (grid[cr][cc].cover === COVER_FULL && !grid[cr][cc].destroyed) return false;
        }
      }
      return true;
    }

    // ---- Execute Actions ----
    function doMove(soldier, r, c) {
      let oldR = soldier.row, oldC = soldier.col;
      soldier.row = r;
      soldier.col = c;
      soldier.moved = true;
      soldier.overwatch = false; // Moving cancels overwatch
      addLog(`${soldier.name} moves to (${c},${r})`);

      // Check overwatch triggers
      checkOverwatchTriggers(soldier, oldR, oldC, r, c);
    }

    function checkOverwatchTriggers(movingSoldier, fromR, fromC, toR, toC) {
      let enemies = soldiers.filter(s => s.team !== movingSoldier.team && s.alive && s.overwatch);
      for (let e of enemies) {
        let distFrom = Math.abs(fromR - e.row) + Math.abs(fromC - e.col);
        let distTo = Math.abs(toR - e.row) + Math.abs(toC - e.col);
        if (distTo <= 8 && hasLineOfSight(e.row, e.col, toR, toC)) {
          // Overwatch shot!
          let hitChance = calcHitChance(e, movingSoldier);
          hitChance = Math.max(hitChance - 10, 5); // Overwatch penalty
          let hit = Math.random() * 100 < hitChance;
          e.overwatch = false;
          if (hit) {
            let dmg = 1 + Math.floor(Math.random() * 2);
            movingSoldier.hp -= dmg;
            addLog(`${e.name} OVERWATCH! Hit ${movingSoldier.name} for ${dmg} dmg!`);
            addFloat(movingSoldier.row, movingSoldier.col, `-${dmg}`, '#f44');
            if (movingSoldier.hp <= 0) {
              movingSoldier.alive = false;
              addLog(`${movingSoldier.name} is KIA!`);
              addFloat(movingSoldier.row, movingSoldier.col, 'KIA', '#f44');
              if (movingSoldier.team === 'ai') { score++; scoreEl.textContent = score; }
            }
          } else {
            addLog(`${e.name} OVERWATCH! Missed ${movingSoldier.name}.`);
            addFloat(movingSoldier.row, movingSoldier.col, 'MISS', '#aaa');
          }
        }
      }
    }

    function doShoot(attacker, target) {
      let hitChance = calcHitChance(attacker, target);
      let hit = Math.random() * 100 < hitChance;
      attacker.acted = true;

      if (hit) {
        let dmg = 1 + Math.floor(Math.random() * 2); // 1-2 damage
        target.hp -= dmg;
        addLog(`${attacker.name} shoots ${target.name} (${hitChance}%) — HIT for ${dmg}!`);
        addFloat(target.row, target.col, `-${dmg}`, '#f44');
        if (target.hp <= 0) {
          target.alive = false;
          addLog(`${target.name} is KIA!`);
          addFloat(target.row, target.col, 'KIA', '#f44');
          if (target.team === 'ai') { score++; scoreEl.textContent = score; }
        }
      } else {
        addLog(`${attacker.name} shoots ${target.name} (${hitChance}%) — MISS!`);
        addFloat(target.row, target.col, 'MISS', '#aaa');
      }
      // Shooting also counts as acting but not moving
      if (!attacker.moved) attacker.moved = true; // End movement too
    }

    function doGrenade(attacker, r, c) {
      attacker.acted = true;
      if (!attacker.moved) attacker.moved = true;
      addLog(`${attacker.name} throws grenade at (${c},${r})!`);

      // Area of effect: target cell + adjacent
      let aoe = [{ r, c }];
      let dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      for (let d of dirs) {
        let nr = r + d[0], nc = c + d[1];
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) aoe.push({ r: nr, c: nc });
      }

      for (let cell of aoe) {
        // Destroy cover
        if (grid[cell.r][cell.c].cover !== COVER_NONE) {
          grid[cell.r][cell.c].destroyed = true;
          grid[cell.r][cell.c].cover = COVER_NONE;
        }
        // Damage soldiers in AOE
        let s = getSoldierAt(cell.r, cell.c);
        if (s && s.id !== attacker.id) {
          let dmg = cell.r === r && cell.c === c ? 2 : 1;
          s.hp -= dmg;
          addFloat(s.row, s.col, `-${dmg}`, '#fa0');
          addLog(`Grenade hits ${s.name} for ${dmg}!`);
          if (s.hp <= 0) {
            s.alive = false;
            addLog(`${s.name} is KIA!`);
            addFloat(s.row, s.col, 'KIA', '#f44');
            if (s.team === 'ai') { score++; scoreEl.textContent = score; }
          }
        }
      }
      addFloat(r, c, 'BOOM', '#fa0');
    }

    function doOverwatch(soldier) {
      soldier.overwatch = true;
      soldier.acted = true;
      if (!soldier.moved) soldier.moved = true;
      addLog(`${soldier.name} sets Overwatch.`);
      addFloat(soldier.row, soldier.col, 'OVERWATCH', '#4e8');
    }

    function doHunker(soldier) {
      soldier.hunkered = true;
      soldier.acted = true;
      if (!soldier.moved) soldier.moved = true;
      addLog(`${soldier.name} hunkers down.`);
      addFloat(soldier.row, soldier.col, 'HUNKERED', '#48f');
    }

    // ---- Floating Text ----
    function addFloat(r, c, text, color) {
      floatingTexts.push({
        x: OX + c * CELL + CELL / 2,
        y: OY + r * CELL,
        text, color, life: 60
      });
    }

    function addLog(msg) {
      logMessages.unshift(msg);
      if (logMessages.length > 5) logMessages.pop();
    }

    // ---- AI ----
    function runAI() {
      let aiSoldiers = soldiers.filter(s => s.team === 'ai' && s.alive && (!s.moved || !s.acted));
      if (aiSoldiers.length === 0) {
        aiThinking = false;
        if (checkWin()) return;
        turn = 'player';
        resetTurn('player');
        addLog('Your turn. Select a soldier.');
        draw();
        return;
      }

      let soldier = aiSoldiers[0];
      aiTakeTurn(soldier);

      draw();
      setTimeout(() => {
        if (gameState !== 'playing') return;
        if (checkWin()) return;
        runAI();
      }, 500);
    }

    function aiTakeTurn(soldier) {
      let enemies = soldiers.filter(s => s.team === 'player' && s.alive);
      if (enemies.length === 0) return;

      // Evaluate threats
      let threats = enemies.map(e => {
        let dist = Math.abs(e.row - soldier.row) + Math.abs(e.col - soldier.col);
        let hitChanceOnMe = calcHitChance(e, soldier);
        let myHitChance = calcHitChance(soldier, e);
        let los = hasLineOfSight(soldier.row, soldier.col, e.row, e.col);
        return { enemy: e, dist, hitChanceOnMe, myHitChance, los };
      }).sort((a, b) => a.dist - b.dist);

      let bestTarget = threats.find(t => t.los && t.dist <= 10);

      // Phase 1: Move
      if (!soldier.moved) {
        let moveOptions = getMovementRange(soldier);
        if (moveOptions.length > 0) {
          let bestMove = null;
          let bestScore = -Infinity;

          for (let m of moveOptions) {
            let mScore = 0;
            // Prefer positions with cover
            let adjCover = getAdjacentCover(m.r, m.c);
            mScore += adjCover * 15;

            // Prefer positions that can shoot at enemies
            for (let t of threats) {
              let newDist = Math.abs(m.r - t.enemy.row) + Math.abs(m.c - t.enemy.col);
              if (newDist <= 8 && hasLineOfSight(m.r, m.c, t.enemy.row, t.enemy.col)) {
                mScore += 20;
                // Prefer flanking positions
                let coverFromHere = getEffectiveCover({ row: m.r, col: m.c }, t.enemy);
                if (coverFromHere === COVER_NONE) mScore += 5; // flanking doesn't help us shoot but...
                // Actually check if WE would flank THEM
                let enemyCover = getEffectiveCover({ row: m.r, col: m.c }, t.enemy);
                // Recalc from new position perspective
                let tmpSoldier = { row: m.r, col: m.c };
                let theirCover = getEffectiveCover(tmpSoldier, t.enemy);
                if (theirCover === COVER_NONE) mScore += 25; // Flanking bonus!
              }
              // Don't get too close
              if (newDist <= 2) mScore -= 10;
              // Medium range is good
              if (newDist >= 3 && newDist <= 5) mScore += 10;
            }

            if (mScore > bestScore) {
              bestScore = mScore;
              bestMove = m;
            }
          }

          if (bestMove && (bestScore > 0 || !bestTarget)) {
            doMove(soldier, bestMove.r, bestMove.c);
            if (!soldier.alive) return; // Killed by overwatch
          }
        }
      }

      // Re-evaluate after moving
      if (!soldier.acted && soldier.alive) {
        threats = enemies.filter(e => e.alive).map(e => {
          let dist = Math.abs(e.row - soldier.row) + Math.abs(e.col - soldier.col);
          let myHitChance = calcHitChance(soldier, e);
          let los = hasLineOfSight(soldier.row, soldier.col, e.row, e.col);
          return { enemy: e, dist, myHitChance, los };
        }).sort((a, b) => b.myHitChance - a.myHitChance);

        bestTarget = threats.find(t => t.los && t.dist <= 10);

        if (bestTarget && bestTarget.myHitChance >= 30) {
          // Shoot the best target
          doShoot(soldier, bestTarget.enemy);
        } else if (bestTarget && Math.random() < 0.3) {
          // Try grenade if clustered enemies
          let grenadeTarget = findGrenadeTarget(soldier, enemies.filter(e => e.alive));
          if (grenadeTarget) {
            doGrenade(soldier, grenadeTarget.r, grenadeTarget.c);
          } else if (bestTarget) {
            doShoot(soldier, bestTarget.enemy);
          } else {
            doOverwatch(soldier);
          }
        } else if (threats.some(t => t.dist <= 8 && t.los)) {
          // Set overwatch if enemies nearby
          doOverwatch(soldier);
        } else {
          // Hunker down
          let adjCover = getAdjacentCover(soldier.row, soldier.col);
          if (adjCover > 0) {
            doHunker(soldier);
          } else {
            doOverwatch(soldier);
          }
        }
      }

      // Mark turn as complete
      soldier.moved = true;
      soldier.acted = true;
    }

    function findGrenadeTarget(soldier, enemies) {
      let bestTarget = null;
      let bestHits = 0;

      for (let e of enemies) {
        let dist = Math.abs(e.row - soldier.row) + Math.abs(e.col - soldier.col);
        if (dist > 6) continue;

        // Count enemies in AOE
        let hits = 0;
        let dirs = [[-1,0],[1,0],[0,-1],[0,1],[0,0]];
        for (let d of dirs) {
          let cr = e.row + d[0], cc = e.col + d[1];
          let s = getSoldierAt(cr, cc);
          if (s && s.team === 'player') hits++;
          if (s && s.team === 'ai') hits -= 2; // Avoid friendly fire
        }
        if (hits > bestHits) {
          bestHits = hits;
          bestTarget = { r: e.row, c: e.col };
        }
      }
      return bestHits >= 2 ? bestTarget : null;
    }

    function getAdjacentCover(r, c) {
      let best = 0;
      let dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      for (let d of dirs) {
        let nr = r + d[0], nc = c + d[1];
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
          if (!grid[nr][nc].destroyed && grid[nr][nc].cover > best) {
            best = grid[nr][nc].cover;
          }
        }
      }
      return best;
    }

    // ---- Mouse Input ----
    canvas.addEventListener('click', e => {
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { init(); return; }
      if (turn !== 'player' || aiThinking) return;

      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      let col = Math.floor((mx - OX) / CELL);
      let row = Math.floor((my - OY) / CELL);

      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

      let clickedSoldier = getSoldierAt(row, col);

      // Grenade mode
      if (currentAction === 'grenade' && selectedSoldier && !selectedSoldier.acted) {
        let inRange = grenadeRange.some(g => g.r === row && g.c === col);
        if (inRange) {
          doGrenade(selectedSoldier, row, col);
          currentAction = null;
          grenadeRange = [];
          selectedSoldier = null;
          checkWin();
          draw();
          return;
        }
      }

      // Click on own soldier to select
      if (clickedSoldier && clickedSoldier.team === 'player') {
        selectedSoldier = clickedSoldier;
        currentAction = null;
        grenadeRange = [];
        moveRange = getMovementRange(clickedSoldier);
        shootRange = getShootRange(clickedSoldier);
        draw();
        return;
      }

      // Click on enemy to shoot
      if (clickedSoldier && clickedSoldier.team === 'ai' && selectedSoldier && !selectedSoldier.acted) {
        let canShoot = shootRange.some(s => s.soldier.id === clickedSoldier.id);
        if (canShoot) {
          doShoot(selectedSoldier, clickedSoldier);
          selectedSoldier = null;
          moveRange = [];
          shootRange = [];
          checkWin();
          draw();
          return;
        }
      }

      // Click on empty cell to move
      if (!clickedSoldier && selectedSoldier && !selectedSoldier.moved) {
        let inRange = moveRange.some(m => m.r === row && m.c === col);
        if (inRange) {
          doMove(selectedSoldier, row, col);
          if (!selectedSoldier.alive) {
            selectedSoldier = null;
            moveRange = [];
            shootRange = [];
          } else {
            moveRange = [];
            shootRange = getShootRange(selectedSoldier);
          }
          checkWin();
          draw();
          return;
        }
      }

      // Click on empty space to deselect
      selectedSoldier = null;
      currentAction = null;
      moveRange = [];
      shootRange = [];
      grenadeRange = [];
      draw();
    });

    // Right click for overwatch
    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      if (gameState !== 'playing' || turn !== 'player') return;
      if (selectedSoldier && !selectedSoldier.acted) {
        doOverwatch(selectedSoldier);
        selectedSoldier = null;
        moveRange = [];
        shootRange = [];
        draw();
      }
    });

    // ---- Drawing ----
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawGrid();
      drawCover();
      drawRanges();
      drawSoldiers();
      drawUI();
      drawFloatingTexts();
      drawLog();
    }

    function drawGrid() {
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(OX, OY + r * CELL);
        ctx.lineTo(OX + COLS * CELL, OY + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(OX + c * CELL, OY);
        ctx.lineTo(OX + c * CELL, OY + ROWS * CELL);
        ctx.stroke();
      }
    }

    function drawCover() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let cell = grid[r][c];
          let x = OX + c * CELL, y = OY + r * CELL;
          if (cell.destroyed) {
            // Rubble
            ctx.fillStyle = '#2a2a3e';
            ctx.fillRect(x + 2, y + 2, CELL - 4, CELL - 4);
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 5, y + 8, 6, 4);
            ctx.fillRect(x + 14, y + 5, 5, 5);
          } else if (cell.cover === COVER_FULL) {
            // Full cover - solid wall
            ctx.fillStyle = '#445';
            ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
            ctx.strokeStyle = '#667';
            ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
            // Wall pattern
            ctx.fillStyle = '#556';
            ctx.fillRect(x + 3, y + 3, CELL / 2 - 2, CELL / 2 - 4);
            ctx.fillRect(x + CELL / 2 + 1, y + CELL / 2 - 1, CELL / 2 - 4, CELL / 2 - 2);
          } else if (cell.cover === COVER_HALF) {
            // Half cover - crate
            ctx.fillStyle = '#553';
            ctx.fillRect(x + 3, y + CELL / 3, CELL - 6, CELL * 2 / 3 - 3);
            ctx.strokeStyle = '#774';
            ctx.strokeRect(x + 3, y + CELL / 3, CELL - 6, CELL * 2 / 3 - 3);
            // Cross on crate
            ctx.strokeStyle = '#664';
            ctx.beginPath();
            ctx.moveTo(x + CELL / 2, y + CELL / 3 + 2);
            ctx.lineTo(x + CELL / 2, y + CELL - 5);
            ctx.moveTo(x + 5, y + CELL / 2 + 3);
            ctx.lineTo(x + CELL - 5, y + CELL / 2 + 3);
            ctx.stroke();
          }
        }
      }
    }

    function drawRanges() {
      // Movement range
      if (selectedSoldier && !selectedSoldier.moved) {
        for (let m of moveRange) {
          let x = OX + m.c * CELL, y = OY + m.r * CELL;
          ctx.fillStyle = 'rgba(68,136,255,0.15)';
          ctx.fillRect(x, y, CELL, CELL);
          ctx.strokeStyle = 'rgba(68,136,255,0.4)';
          ctx.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
        }
      }

      // Shoot range indicators on enemies
      if (selectedSoldier && !selectedSoldier.acted && currentAction !== 'grenade') {
        for (let s of shootRange) {
          let x = OX + s.soldier.col * CELL, y = OY + s.soldier.row * CELL;
          ctx.strokeStyle = s.hitChance >= 60 ? 'rgba(68,238,136,0.6)' : s.hitChance >= 30 ? 'rgba(255,170,0,0.6)' : 'rgba(255,68,68,0.4)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, CELL, CELL);
          ctx.lineWidth = 1;
          // Hit chance text
          ctx.fillStyle = '#fff';
          ctx.font = '9px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(s.hitChance + '%', x + CELL / 2, y + CELL - 2);
        }
      }

      // Grenade range
      if (currentAction === 'grenade') {
        for (let g of grenadeRange) {
          let x = OX + g.c * CELL, y = OY + g.r * CELL;
          ctx.fillStyle = 'rgba(255,170,0,0.1)';
          ctx.fillRect(x, y, CELL, CELL);
        }
      }
    }

    function drawSoldiers() {
      for (let s of soldiers) {
        if (!s.alive) continue;
        let x = OX + s.col * CELL + CELL / 2;
        let y = OY + s.row * CELL + CELL / 2;
        let r = CELL * 0.35;

        // Selection highlight
        if (s === selectedSoldier) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(OX + s.col * CELL, OY + s.row * CELL, CELL, CELL);
          ctx.lineWidth = 1;
        }

        // Glow
        ctx.shadowColor = s.color;
        ctx.shadowBlur = s === selectedSoldier ? 15 : 8;

        // Body
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(x, y + 2, r, 0, Math.PI * 2);
        ctx.fill();

        // Head
        ctx.fillStyle = s.team === 'player' ? '#6af' : '#f66';
        ctx.beginPath();
        ctx.arc(x, y - r * 0.5, r * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;

        // HP bar
        let barW = CELL - 4;
        let barH = 3;
        let barX = OX + s.col * CELL + 2;
        let barY = OY + s.row * CELL + 1;
        ctx.fillStyle = '#300';
        ctx.fillRect(barX, barY, barW, barH);
        let hpFrac = s.hp / s.maxHp;
        ctx.fillStyle = hpFrac > 0.5 ? '#0a0' : hpFrac > 0.25 ? '#fa0' : '#f00';
        ctx.fillRect(barX, barY, barW * hpFrac, barH);

        // Status icons
        if (s.overwatch) {
          ctx.fillStyle = '#4e8';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('OW', x, OY + s.row * CELL + CELL - 1);
        }
        if (s.hunkered) {
          ctx.fillStyle = '#48f';
          ctx.font = 'bold 8px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('HD', x, OY + s.row * CELL + CELL - 1);
        }

        // Acted/moved indicators
        if (s.team === 'player' && turn === 'player') {
          if (s.moved && s.acted) {
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = '#000';
            ctx.fillRect(OX + s.col * CELL, OY + s.row * CELL, CELL, CELL);
            ctx.globalAlpha = 1;
          }
        }
      }
    }

    function drawUI() {
      // Action panel at bottom
      let panelY = OY + ROWS * CELL + 4;
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, panelY, W, H - panelY);

      if (selectedSoldier && turn === 'player') {
        let s = selectedSoldier;
        ctx.font = '11px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = s.color;
        ctx.fillText(`${s.name}  HP: ${s.hp}/${s.maxHp}`, OX, panelY + 14);

        ctx.fillStyle = '#aaa';
        let actions = [];
        if (!s.moved) actions.push('Click tile: Move');
        if (!s.acted) {
          actions.push('Click enemy: Shoot');
          actions.push('[G] Grenade');
          actions.push('[H] Hunker');
          actions.push('Right-click: Overwatch');
        }
        ctx.fillText(actions.join('  |  '), OX, panelY + 28);

        if (currentAction === 'grenade') {
          ctx.fillStyle = '#fa0';
          ctx.fillText('GRENADE MODE — Click target tile (ESC to cancel)', OX, panelY + 42);
        }
      } else if (turn === 'player') {
        ctx.font = '11px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Click a soldier to select  |  [E] End Turn', OX, panelY + 14);
      }
    }

    function drawFloatingTexts() {
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.life--;
        ft.y -= 0.5;
        let alpha = ft.life / 60;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = ft.color;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = ft.color;
        ctx.shadowBlur = 8;
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        if (ft.life <= 0) floatingTexts.splice(i, 1);
      }
    }

    function drawLog() {
      let logX = OX + COLS * CELL + 6;
      // If no room on right, draw at bottom
      let logY = OY + 4;
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      for (let i = 0; i < logMessages.length && i < 5; i++) {
        ctx.fillStyle = i === 0 ? '#4e8' : '#666';
        let msg = logMessages[i];
        if (msg.length > 28) msg = msg.substring(0, 27) + '..';
        // Wrap within canvas - draw along right edge
        // Actually, let's draw in top-right area
      }
    }

    // Animation loop for floating texts
    function animLoop() {
      if (gameState === 'playing') {
        if (floatingTexts.length > 0) draw();
      }
      requestAnimationFrame(animLoop);
    }

    init();
    animLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

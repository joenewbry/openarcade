<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lode Runner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #ea4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 170, 68, 0.4); }
    h1 { color: #ea4; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 170, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ea4; }
    canvas {
      border: 2px solid #ea4;
      box-shadow: 0 0 20px rgba(238, 170, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ea4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .game-row { display: flex; gap: 20px; align-items: flex-start; }
    .keypad { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 20px; }
    .keypad-row { display: flex; gap: 4px; }
    .kp-key {
      width: 44px; height: 44px;
      background: #16213e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; color: #555;
      transition: background 0.06s, border-color 0.06s, color 0.06s, box-shadow 0.06s;
    }
    .kp-key.active {
      background: rgba(238, 170, 68, 0.15);
      border-color: #ea4;
      color: #ea4;
      box-shadow: 0 0 12px rgba(238, 170, 68, 0.4);
    }
    .kp-spacer { width: 44px; height: 44px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>LODE RUNNER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="game-row">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="500" height="400"></canvas>
      <div class="overlay" id="overlay" style="width:500px;height:400px;">
        <h2 id="overlayTitle">LODE RUNNER</h2>
        <p id="overlayText">Press SPACE to start</p>
      </div>
    </div>
    <div class="keypad">
      <div class="keypad-row">
        <div class="kp-spacer"></div>
        <div class="kp-key" id="kp-up">&uarr;</div>
        <div class="kp-spacer"></div>
      </div>
      <div class="keypad-row">
        <div class="kp-key" id="kp-left">&larr;</div>
        <div class="kp-key" id="kp-down">&darr;</div>
        <div class="kp-key" id="kp-right">&rarr;</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    const COLS = 25;
    const ROWS = 16;
    const TW = W / COLS;
    const TH = H / ROWS;

    const EMPTY = 0, BRICK = 1, LADDER = 2, BAR = 3, GOLD = 4, SOLID = 5, ESCAPE_LADDER = 6;

    let score, best = 0, gameState;
    let level, grid, player, guards, goldCount, totalGold;
    let holes, keys = {}, animFrame, lastTime, lives, escapeLadderShown;

    const PLAYER_SPEED = 100;
    const GUARD_SPEED = 70;
    const HOLE_DURATION = 4000;
    const HOLE_DIG_TIME = 300;
    const GUARD_TRAPPED_TIME = 3000;

    function L(s) { return (s + '.........................').slice(0, 25); }

    const LEVELS = [
      [
        L('.........................'),
        L('.........................'),
        L('.........................'),
        L('..G........G.......G....'),
        L('#####H###########H#####'),
        L('.....H...........H.....'),
        L('.....H..G........H.....'),
        L('.....H########...H.....'),
        L('..G..H.......H...H.....'),
        L('#####H.......H...H.G...'),
        L('.....H.......H###H####.'),
        L('.....H..G....H...H.....'),
        L('..P..H.......H.E.H.....'),
        L('#####H#######H###H####.'),
        L('.....H...........H.....'),
        L('SSSSSSSSSSSSSSSSSSSSSSSSS')
      ],
      [
        L('.........................'),
        L('.........................'),
        L('.G.......G..........G...'),
        L('##H####----###H###--#H.'),
        L('..H............H.....H.'),
        L('..H.G..........H.G...H.'),
        L('..H#####.E..####H.##.H.'),
        L('..H.....######.......H.'),
        L('..H.G................H.'),
        L('..H####..###H####.##.H.'),
        L('..H..........H.......H.'),
        L('..H...G......H..G....H.'),
        L('..HP..####...H..###E.H.'),
        L('..H#########.H######.H.'),
        L('..H..........H.......H.'),
        L('SSSSSSSSSSSSSSSSSSSSSSSSS')
      ],
      [
        L('.........................'),
        L('..G..........G..........'),
        L('#####H####..###H########'),
        L('.....H.........H.......'),
        L('.....H.G.......H.......'),
        L('..####H######..H.......'),
        L('..G...H.E......H..G....'),
        L('..#####..####..H.####..'),
        L('..........H....H.H.....'),
        L('...G......H....H.H.G...'),
        L('..######..H#####.H####.'),
        L('..........H......H.....'),
        L('..E.G.....H.P....H.G...'),
        L('..######..H.####.H####.'),
        L('..........H......H.....'),
        L('SSSSSSSSSSSSSSSSSSSSSSSSS')
      ],
      [
        L('.........................'),
        L('.G..G...G...G....G......'),
        L('##H###H#####H####H####.'),
        L('..H...H.....H....H.....'),
        L('..H---H-----H----H----.'),
        L('..H...H.....H....H.....'),
        L('..H.G.H.....H.G..H.....'),
        L('##H##.H..##.H..#H####..'),
        L('..H...H..E..H...H..G...'),
        L('..H---H-----H---H.###..'),
        L('..H...H.....H...H......'),
        L('.EH...H..G..H...H..E...'),
        L('##H.##H####.H###H.##...'),
        L('..H...H..P..H...H......'),
        L('..H...H.....H...H......'),
        L('SSSSSSSSSSSSSSSSSSSSSSSSS')
      ],
      [
        L('.........................'),
        L('.G.G.G.G.G..G.G.G.G.G..'),
        L('##H####H####H####H####.'),
        L('..H....H.E..H....H.....'),
        L('..H----H----H----H----.'),
        L('..H....H....H....H.....'),
        L('##H.#..H..#.H..#.H.##..'),
        L('..H.G..H..G.H..G.H.G...'),
        L('..H-#--H--#-H--#-H-#...'),
        L('..H....H....H....H.....'),
        L('##H.E..H.##.H.E..H####.'),
        L('..H....H....H....H.....'),
        L('..H.P.....E.H....H.....'),
        L('##H########.H####H####.'),
        L('..H.........H....H.....'),
        L('SSSSSSSSSSSSSSSSSSSSSSSSS')
      ]
    ];

    function parseLevel(idx) {
      const data = LEVELS[idx];
      grid = [];
      guards = [];
      goldCount = 0;
      totalGold = 0;
      holes = [];
      escapeLadderShown = false;
      player = null;

      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          const ch = (data[r] && data[r][c]) || '.';
          switch (ch) {
            case '#': grid[r][c] = BRICK; break;
            case 'H': grid[r][c] = LADDER; break;
            case '-': grid[r][c] = BAR; break;
            case 'G': grid[r][c] = GOLD; totalGold++; break;
            case 'S': grid[r][c] = SOLID; break;
            case 'P':
              grid[r][c] = EMPTY;
              player = { x: c * TW, y: r * TH, dir: 1, digTimer: 0, dead: false, falling: false };
              break;
            case 'E':
              grid[r][c] = EMPTY;
              guards.push({ x: c * TW, y: r * TH, dir: 1, falling: false, trapped: 0, trappedR: 0, trappedC: 0, hasGold: false });
              break;
            default: grid[r][c] = EMPTY;
          }
        }
      }
      if (!player) {
        player = { x: 2 * TW, y: 12 * TH, dir: 1, digTimer: 0, dead: false, falling: false };
      }
    }

    function getTile(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return SOLID;
      return grid[r][c];
    }

    function isSolid(tile) { return tile === BRICK || tile === SOLID; }
    function isLadder(tile) { return tile === LADDER || tile === ESCAPE_LADDER; }

    function hasSupport(px, py) {
      const c = Math.round(px / TW);
      const r = Math.round(py / TH);
      if (r >= ROWS - 1) return true;
      const below = getTile(r + 1, c);
      if (isSolid(below)) return true;
      const cur = getTile(r, c);
      if (isLadder(cur)) return true;
      if (cur === BAR) return true;
      if (isLadder(below)) return true;
      return false;
    }

    function updatePlayer(dt) {
      if (player.dead) return;
      if (player.digTimer > 0) { player.digTimer -= dt * 1000; return; }

      const pr = Math.round(player.y / TH);
      const pc = Math.round(player.x / TW);
      const curTile = getTile(pr, pc);
      const onLad = isLadder(curTile);
      const onBar = curTile === BAR;
      const support = hasSupport(player.x, player.y);

      if (!support && !onLad && !onBar) {
        player.falling = true;
        player.y += PLAYER_SPEED * 1.5 * dt;
        if (hasSupport(player.x, player.y)) {
          player.y = Math.round(player.y / TH) * TH;
          player.falling = false;
        }
        return;
      }
      player.falling = false;

      const spd = PLAYER_SPEED * dt;

      if (keys['ArrowLeft']) {
        player.dir = -1;
        const nx = player.x - spd;
        const nc = Math.round(nx / TW);
        if (nc >= 0 && !isSolid(getTile(pr, nc))) player.x = nx;
      }
      if (keys['ArrowRight']) {
        player.dir = 1;
        const nx = player.x + spd;
        const nc = Math.round(nx / TW);
        if (nc < COLS && !isSolid(getTile(pr, nc))) player.x = nx;
      }
      if (keys['ArrowUp'] && onLad) {
        const ny = player.y - spd;
        const nr = Math.round(ny / TH);
        if (nr >= 0 && !isSolid(getTile(nr, pc))) {
          player.y = ny;
          player.x = pc * TW;
        }
      }
      if (keys['ArrowDown']) {
        const belowTile = getTile(pr + 1, pc);
        if (onLad || isLadder(belowTile)) {
          const ny = player.y + spd;
          const nr = Math.round(ny / TH);
          if (nr < ROWS && !isSolid(getTile(nr, pc))) {
            player.y = ny;
            player.x = pc * TW;
          }
        }
      }

      player.x = Math.max(0, Math.min((COLS - 1) * TW, player.x));
      player.y = Math.max(0, Math.min((ROWS - 1) * TH, player.y));

      const gr = Math.round(player.y / TH);
      const gc = Math.round(player.x / TW);
      if (getTile(gr, gc) === GOLD) {
        grid[gr][gc] = EMPTY;
        goldCount++;
        score += 100;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        if (goldCount >= totalGold) showEscapeLadder();
      }

      if (goldCount >= totalGold && gr <= 0) { levelComplete(); return; }

      if (keys['z'] || keys['Z']) { keys['z'] = keys['Z'] = false; digHole(pc - 1, pr + 1); }
      if (keys['x'] || keys['X']) { keys['x'] = keys['X'] = false; digHole(pc + 1, pr + 1); }
    }

    function digHole(c, r) {
      if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;
      if (getTile(r, c) !== BRICK) return;
      grid[r][c] = EMPTY;
      holes.push({ r, c, timer: HOLE_DURATION });
      player.digTimer = HOLE_DIG_TIME;
    }

    function showEscapeLadder() {
      if (escapeLadderShown) return;
      escapeLadderShown = true;
      let col = 12;
      for (let c = 0; c < COLS; c++) {
        if (isLadder(getTile(2, c)) || isLadder(getTile(3, c))) { col = c; break; }
      }
      for (let r = 0; r < 4; r++) {
        if (!isSolid(getTile(r, col))) grid[r][col] = ESCAPE_LADDER;
      }
    }

    function levelComplete() {
      level++;
      score += 500 + level * 100;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
      if (level >= LEVELS.length) {
        score += 2000;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = 'Score: ' + score + ' -- All levels cleared! Press any key';
        return;
      }
      parseLevel(level);
    }

    function updateGuards(dt) {
      for (const g of guards) {
        if (g.trapped > 0) {
          g.trapped -= dt * 1000;
          if (g.trapped <= 0) {
            g.trapped = 0;
            g.y = g.trappedR * TH - TH;
            if (g.y < 0) g.y = 0;
            if (g.hasGold) {
              if (getTile(g.trappedR - 1, g.trappedC) === EMPTY) grid[g.trappedR - 1][g.trappedC] = GOLD;
              g.hasGold = false;
            }
          }
          continue;
        }

        const gr = Math.round(g.y / TH);
        const gc = Math.round(g.x / TW);
        const curTile = getTile(gr, gc);
        const onLad = isLadder(curTile);
        const onBar = curTile === BAR;
        const support = hasSupport(g.x, g.y);

        if (!support && !onLad && !onBar) {
          g.falling = true;
          g.y += GUARD_SPEED * 1.8 * dt;
          const nr = Math.round(g.y / TH);
          const nc = Math.round(g.x / TW);
          for (const hole of holes) {
            if (hole.r === nr && hole.c === nc) {
              g.trapped = GUARD_TRAPPED_TIME;
              g.trappedR = nr; g.trappedC = nc;
              g.y = nr * TH; g.x = nc * TW;
              g.falling = false;
              break;
            }
          }
          if (hasSupport(g.x, g.y) && g.trapped <= 0) {
            g.y = Math.round(g.y / TH) * TH;
            g.falling = false;
          }
          continue;
        }
        g.falling = false;

        const pr = Math.round(player.y / TH);
        const pc = Math.round(player.x / TW);
        const spd = GUARD_SPEED * dt;
        let mx = 0, my = 0;

        if (gr === pr) {
          mx = gc < pc ? 1 : gc > pc ? -1 : 0;
        } else if (pr < gr) {
          if (onLad) { my = -1; }
          else {
            let best = -1, bd = COLS + 1;
            for (let c2 = 0; c2 < COLS; c2++) {
              if (isLadder(getTile(gr, c2)) && Math.abs(c2 - gc) < bd) { bd = Math.abs(c2 - gc); best = c2; }
            }
            if (best === -1) {
              for (let c2 = 0; c2 < COLS; c2++) {
                if (isLadder(getTile(gr - 1, c2)) && Math.abs(c2 - gc) < bd) { bd = Math.abs(c2 - gc); best = c2; }
              }
            }
            if (best >= 0) { mx = gc < best ? 1 : gc > best ? -1 : 0; if (mx === 0) my = -1; }
            else { mx = gc < pc ? 1 : gc > pc ? -1 : 0; }
          }
        } else {
          const belowTile = getTile(gr + 1, gc);
          if (onLad || isLadder(belowTile)) { my = 1; }
          else {
            let best = -1, bd = COLS + 1;
            for (let c2 = 0; c2 < COLS; c2++) {
              if ((isLadder(getTile(gr + 1, c2)) || isLadder(getTile(gr, c2))) && Math.abs(c2 - gc) < bd) {
                bd = Math.abs(c2 - gc); best = c2;
              }
            }
            if (best >= 0) { mx = gc < best ? 1 : gc > best ? -1 : 0; if (mx === 0) my = 1; }
            else { mx = gc < pc ? 1 : gc > pc ? -1 : 0; }
          }
        }

        if (my < 0 && onLad) {
          const ny = g.y - spd;
          const nr = Math.round(ny / TH);
          if (nr >= 0 && !isSolid(getTile(nr, gc))) { g.y = ny; g.x = gc * TW; }
        } else if (my > 0) {
          if (onLad || isLadder(getTile(gr + 1, gc))) {
            const ny = g.y + spd;
            const nr = Math.round(ny / TH);
            if (nr < ROWS && !isSolid(getTile(nr, gc))) { g.y = ny; g.x = gc * TW; }
          }
        }
        if (mx !== 0) {
          const nx = g.x + mx * spd;
          const nc = Math.round(nx / TW);
          if (nc >= 0 && nc < COLS && !isSolid(getTile(gr, nc))) { g.x = nx; g.dir = mx; }
        }

        g.x = Math.max(0, Math.min((COLS - 1) * TW, g.x));
        g.y = Math.max(0, Math.min((ROWS - 1) * TH, g.y));

        const ggr = Math.round(g.y / TH), ggc = Math.round(g.x / TW);
        if (!g.hasGold && getTile(ggr, ggc) === GOLD) { grid[ggr][ggc] = EMPTY; g.hasGold = true; }
      }
    }

    function checkCollisions() {
      if (player.dead) return;
      for (const g of guards) {
        if (g.trapped > 0) continue;
        if (Math.abs(player.x - g.x) < TW * 0.7 && Math.abs(player.y - g.y) < TH * 0.7) {
          playerDie();
          return;
        }
      }
    }

    function playerDie() {
      player.dead = true;
      lives--;
      if (lives <= 0) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = 'Score: ' + score + ' -- Press any key to restart';
      } else {
        setTimeout(() => { parseLevel(level); player.dead = false; }, 500);
      }
    }

    function updateHoles(dt) {
      for (let i = holes.length - 1; i >= 0; i--) {
        holes[i].timer -= dt * 1000;
        if (holes[i].timer <= 0) {
          const h = holes[i];
          grid[h.r][h.c] = BRICK;
          const pr = Math.round(player.y / TH), pc = Math.round(player.x / TW);
          if (pr === h.r && pc === h.c) playerDie();
          for (const g of guards) {
            const gr = Math.round(g.y / TH), gc = Math.round(g.x / TW);
            if (gr === h.r && gc === h.c && g.trapped > 0) {
              g.trapped = 0;
              g.y = 0;
              g.x = Math.floor(Math.random() * COLS) * TW;
              if (g.hasGold) {
                if (getTile(h.r - 1, h.c) === EMPTY) grid[h.r - 1][h.c] = GOLD;
                g.hasGold = false;
              }
            }
          }
          holes.splice(i, 1);
        }
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const tile = grid[r][c];
          const x = c * TW, y = r * TH;

          if (tile === BRICK) {
            ctx.fillStyle = '#6b4226';
            ctx.fillRect(x, y, TW, TH);
            ctx.strokeStyle = '#4a2d16';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, TW - 1, TH - 1);
            ctx.beginPath(); ctx.moveTo(x, y + TH / 2); ctx.lineTo(x + TW, y + TH / 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x + TW / 2, y); ctx.lineTo(x + TW / 2, y + TH / 2); ctx.stroke();
          } else if (tile === SOLID) {
            ctx.fillStyle = '#3a3a5a';
            ctx.fillRect(x, y, TW, TH);
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, TW - 1, TH - 1);
          } else if (tile === LADDER || tile === ESCAPE_LADDER) {
            const lc = tile === ESCAPE_LADDER ? '#4f4' : '#a87532';
            ctx.strokeStyle = lc;
            ctx.lineWidth = 2;
            if (tile === ESCAPE_LADDER) { ctx.shadowColor = '#4f4'; ctx.shadowBlur = 8; }
            ctx.beginPath(); ctx.moveTo(x + 3, y); ctx.lineTo(x + 3, y + TH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x + TW - 3, y); ctx.lineTo(x + TW - 3, y + TH); ctx.stroke();
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 3; i++) {
              const yy = y + 4 + i * (TH / 3);
              ctx.beginPath(); ctx.moveTo(x + 3, yy); ctx.lineTo(x + TW - 3, yy); ctx.stroke();
            }
            ctx.shadowBlur = 0;
          } else if (tile === BAR) {
            ctx.strokeStyle = '#8888cc';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x, y + TH / 3); ctx.lineTo(x + TW, y + TH / 3); ctx.stroke();
          } else if (tile === GOLD) {
            ctx.fillStyle = '#ea4';
            ctx.shadowColor = '#ea4';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(x + TW / 2, y + 4);
            ctx.lineTo(x + TW - 4, y + TH / 2);
            ctx.lineTo(x + TW / 2, y + TH - 4);
            ctx.lineTo(x + 4, y + TH / 2);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
      }

      for (const h of holes) {
        if (h.timer < 1000 && Math.floor(h.timer / 150) % 2 === 0) {
          ctx.fillStyle = 'rgba(107, 66, 38, 0.5)';
          ctx.fillRect(h.c * TW, h.r * TH, TW, TH);
        }
      }

      for (const g of guards) {
        drawChar(g.x, g.y, '#f44', g.dir, g.trapped > 0);
        if (g.hasGold) {
          ctx.fillStyle = '#ea4';
          ctx.shadowColor = '#ea4';
          ctx.shadowBlur = 6;
          ctx.beginPath(); ctx.arc(g.x + TW / 2, g.y + 3, 3, 0, Math.PI * 2); ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      if (!player.dead) drawChar(player.x, player.y, '#4cf', player.dir, false);

      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Level ' + (level + 1) + '/' + LEVELS.length, 5, 12);
      ctx.fillText('Lives: ' + lives, 5, 24);
      ctx.fillText('Gold: ' + goldCount + '/' + totalGold, W - 80, 12);

      if (goldCount >= totalGold) {
        ctx.fillStyle = '#4f4';
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 8;
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('ESCAPE! Reach the top!', W / 2, 12);
        ctx.shadowBlur = 0;
      }
      ctx.textAlign = 'left';
    }

    function drawChar(x, y, color, dir, trapped) {
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      const cx = x + TW / 2;
      if (trapped) {
        ctx.beginPath(); ctx.arc(cx, y + 4, 4, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        ctx.fillRect(cx - 2, y + 3, 1.5, 1.5);
        ctx.fillRect(cx + 1, y + 3, 1.5, 1.5);
      } else {
        ctx.beginPath(); ctx.arc(cx, y + 5, 4, 0, Math.PI * 2); ctx.fill();
        ctx.fillRect(cx - 2, y + 9, 4, 8);
        ctx.fillRect(cx - 6, y + 10, 4, 2);
        ctx.fillRect(cx + 2, y + 10, 4, 2);
        ctx.fillRect(cx - 4, y + 17, 3, 6);
        ctx.fillRect(cx + 1, y + 17, 3, 6);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        if (dir > 0) {
          ctx.fillRect(cx, y + 4, 1.5, 1.5);
          ctx.fillRect(cx + 2, y + 4, 1.5, 1.5);
        } else {
          ctx.fillRect(cx - 3, y + 4, 1.5, 1.5);
          ctx.fillRect(cx - 1, y + 4, 1.5, 1.5);
        }
      }
      ctx.shadowBlur = 0;
    }

    function update(dt) {
      updatePlayer(dt);
      updateGuards(dt);
      updateHoles(dt);
      checkCollisions();
    }

    function loop(ts) {
      if (gameState !== 'playing') return;
      if (!lastTime) lastTime = ts;
      let dt = (ts - lastTime) / 1000;
      lastTime = ts;
      if (dt > 0.05) dt = 0.05;
      update(dt);
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function init() {
      score = 0;
      level = 0;
      lives = 3;
      scoreEl.textContent = '0';
      lastTime = null;
      if (animFrame) cancelAnimationFrame(animFrame);
      parseLevel(0);
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LODE RUNNER';
      overlayText.innerHTML = 'Arrows: move &nbsp; Z/X: dig left/right<br>Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = null;
      animFrame = requestAnimationFrame(loop);
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState === 'playing') keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => { keys[e.key] = false; });

    init();
  </script>
  <script>
    const kpMap = {
      ArrowUp: 'kp-up',
      ArrowDown: 'kp-down',
      ArrowLeft: 'kp-left',
      ArrowRight: 'kp-right'
    };
    document.addEventListener('keydown', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.add('active');
    });
    document.addEventListener('keyup', (e) => {
      if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.remove('active');
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lode Runner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #ea4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 170, 68, 0.4); }
    h1 { color: #ea4; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 170, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ea4; }
    canvas {
      border: 2px solid #ea4;
      box-shadow: 0 0 20px rgba(238, 170, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ea4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>LODE RUNNER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">LODE RUNNER</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid dimensions
    const COLS = 25;
    const ROWS = 16;
    const TW = W / COLS;  // 20
    const TH = H / ROWS;  // 25

    // Tile types
    const EMPTY = 0;
    const BRICK = 1;
    const LADDER = 2;
    const BAR = 3;
    const GOLD = 4;
    const SOLID = 5; // indestructible
    const ESCAPE_LADDER = 6; // appears after all gold collected

    let score, best = 0, gameState;
    let level, grid, player, guards, goldCount, totalGold;
    let holes; // {r, c, timer, originalTile}
    let keys = {};
    let animFrame;
    let lastTime;
    let levelCompleteTimer;
    let lives;
    let escapeLadderShown;

    // Movement speed (pixels per second)
    const PLAYER_SPEED = 100;
    const GUARD_SPEED = 70;
    const HOLE_DURATION = 4000; // ms before hole refills
    const HOLE_DIG_TIME = 300; // ms to dig
    const GUARD_TRAPPED_TIME = 3000; // ms guard stays trapped

    // ---- LEVELS ----
    // Legend: . = empty, # = brick, H = ladder, - = bar, G = gold, S = solid, P = player start, E = guard start
    // Each level is an array of 16 strings of 25 characters
    const LEVELS = [
      // Level 1: Introduction - simple layout, 1 guard, easy gold
      [
        ".........................",
        ".........................",
        ".........................",
        "..G........G........G....",
        "#####H###########H######",
        ".....H...........H......",
        ".....H..G........H......",
        ".....H#######....H......",
        "..G..H......H....H......",
        "#####H......H....H..G...",
        ".....H......H####H#####.",
        ".....H..G...H....H......",
        "..P..H......H.E..H......",
        "#####H######H####H#####.",
        ".....H...........H......",
        "SSSSSSSSSSSSSSSSSSSSSSSSS"
      ],
      // Level 2: More bars and gold, 2 guards
      [
        ".........................",
        ".........................",
        ".G.......G..........G....",
        "##H####---####H##---##H.",
        "..H...........H.......H.",
        "..H..G........H..G....H.",
        "..H#####.E..###H..###.H.",
        "..H.....######........H.",
        "..H..G................H.",
        "..H####..###H####.###.H.",
        "..H..........H........H.",
        "..H....G.....H..G.....H.",
        "..HP..####...H..####EH..",
        "..H#########.H########..",
        "..H..........H..........",
        "SSSSSSSSSSSSSSSSSSSSSSSSS"
      ],
      // Level 3: Vertical challenge, 2 guards
      [
        ".........................",
        "..G..........G...........",
        "######H###..####H#######",
        "......H.........H.......",
        "......H..G......H.......",
        "..#####H#####...H.......",
        "..G....H..E.....H..G....",
        "..######..####..H.####..",
        "..........H.....H.H.....",
        "....G.....H.....H.H.G...",
        "..######..H######.H####.",
        "..........H........H....",
        "..E..G....H...P....H.G..",
        "..######..H...#####H###.",
        "..........H..............",
        "SSSSSSSSSSSSSSSSSSSSSSSSS"
      ],
      // Level 4: Bar traversal heavy, 3 guards
      [
        ".........................",
        ".G...G...G...G...G.......",
        "##H####H#####H####H####.",
        "..H....H.....H....H.....",
        "..H----H-----H----H---.",
        "..H....H.....H....H.....",
        "..H.G..H.....H.G..H.....",
        "###H###H..##.H..#H####..",
        "...H...H..E..H...H..G...",
        "...H---H-----H---H-###..",
        "...H...H.....H...H......",
        ".E.H...H..G..H...H..E...",
        "##.H.###H#####H###H.##..",
        "...H....H..P..H...H.....",
        "...H....H.....H...H.....",
        "SSSSSSSSSSSSSSSSSSSSSSSSS"
      ],
      // Level 5: The gauntlet, 4 guards
      [
        ".........................",
        ".G.G.G.G.G.G.G.G.G.G.G..",
        "##H####H#####H####H####.",
        "..H....H..E..H....H.....",
        "..H----H-----H----H---.",
        "..H....H.....H....H.....",
        "##H.#..H..#..H.#..H.##..",
        "..H.G..H..G..H.G..H.G...",
        "..H-#--H--#--H-#--H-#...",
        "..H....H.....H....H.....",
        "##H.E..H..##.H.E..H###..",
        "..H....H.....H....H.....",
        "..H.P.....E..H....H.....",
        "##H#########.H####H###..",
        "..H..........H....H.....",
        "SSSSSSSSSSSSSSSSSSSSSSSSS"
      ]
    ];

    function parseLevel(idx) {
      const data = LEVELS[idx];
      grid = [];
      guards = [];
      goldCount = 0;
      totalGold = 0;
      holes = [];
      escapeLadderShown = false;
      player = null;

      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          const ch = (data[r] && data[r][c]) || '.';
          switch (ch) {
            case '#': grid[r][c] = BRICK; break;
            case 'H': grid[r][c] = LADDER; break;
            case '-': grid[r][c] = BAR; break;
            case 'G':
              grid[r][c] = GOLD;
              totalGold++;
              break;
            case 'S': grid[r][c] = SOLID; break;
            case 'P':
              grid[r][c] = EMPTY;
              player = { x: c * TW, y: r * TH, onLadder: false, onBar: false, falling: false, dir: 1, digTimer: 0, dead: false };
              break;
            case 'E':
              grid[r][c] = EMPTY;
              guards.push({ x: c * TW, y: r * TH, onLadder: false, onBar: false, falling: false, trapped: 0, trappedR: 0, trappedC: 0, dir: 1, hasGold: false });
              break;
            default: grid[r][c] = EMPTY;
          }
        }
      }

      if (!player) {
        player = { x: 2 * TW, y: 12 * TH, onLadder: false, onBar: false, falling: false, dir: 1, digTimer: 0, dead: false };
      }
    }

    function getTile(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return SOLID;
      return grid[r][c];
    }

    function isSolidTile(tile) {
      return tile === BRICK || tile === SOLID;
    }

    function canStandOn(r, c) {
      // Can stand if:
      // 1. Tile below is solid (brick/solid)
      // 2. Currently on a ladder
      // 3. Currently on a bar (can hang)
      // 4. At bottom of screen
      if (r >= ROWS - 1) return true;
      const below = getTile(r + 1, c);
      if (isSolidTile(below)) return true;
      return false;
    }

    function isOnLadder(px, py) {
      const c = Math.round(px / TW);
      const r = Math.round(py / TH);
      const tile = getTile(r, c);
      return tile === LADDER || tile === ESCAPE_LADDER;
    }

    function isOnBar(px, py) {
      const c = Math.round(px / TW);
      const r = Math.round(py / TH);
      return getTile(r, c) === BAR;
    }

    function hasSupport(px, py) {
      const c = Math.round(px / TW);
      const r = Math.round(py / TH);
      if (r >= ROWS - 1) return true;
      const below = getTile(r + 1, c);
      if (isSolidTile(below)) return true;
      // Check if on a ladder
      const cur = getTile(r, c);
      if (cur === LADDER || cur === ESCAPE_LADDER) return true;
      // Check if on a bar
      if (cur === BAR) return true;
      // Check if ladder below (can stand at top of ladder)
      if (below === LADDER || below === ESCAPE_LADDER) return true;
      return false;
    }

    function entityGridPos(entity) {
      return {
        r: Math.round(entity.y / TH),
        c: Math.round(entity.x / TW)
      };
    }

    function snapToGrid(entity) {
      entity.x = Math.round(entity.x / TW) * TW;
      entity.y = Math.round(entity.y / TH) * TH;
    }

    // ---- PLAYER MOVEMENT ----
    function updatePlayer(dt) {
      if (player.dead) return;
      if (player.digTimer > 0) {
        player.digTimer -= dt * 1000;
        return;
      }

      const pr = Math.round(player.y / TH);
      const pc = Math.round(player.x / TW);
      const onLad = isOnLadder(player.x, player.y);
      const onB = isOnBar(player.x, player.y);
      const support = hasSupport(player.x, player.y);

      // Gravity: fall if no support and not on ladder/bar
      if (!support && !onLad && !onB) {
        player.falling = true;
        player.y += PLAYER_SPEED * 1.5 * dt;
        // Snap when landing
        const newR = Math.round(player.y / TH);
        const newC = Math.round(player.x / TW);
        if (hasSupport(player.x, player.y)) {
          player.y = Math.round(player.y / TH) * TH;
          player.falling = false;
        }
        return;
      }
      player.falling = false;

      const speed = PLAYER_SPEED * dt;

      // Left/Right movement
      if (keys['ArrowLeft']) {
        player.dir = -1;
        const newX = player.x - speed;
        const nc = Math.round(newX / TW);
        const nr = Math.round(player.y / TH);
        if (nc >= 0 && !isSolidTile(getTile(nr, nc))) {
          player.x = newX;
          // If moving off a bar/ladder, snap Y
          if (!isOnBar(player.x, player.y) && !isOnLadder(player.x, player.y) && onB) {
            // Still keep going
          }
        }
      }
      if (keys['ArrowRight']) {
        player.dir = 1;
        const newX = player.x + speed;
        const nc = Math.round(newX / TW);
        const nr = Math.round(player.y / TH);
        if (nc < COLS && !isSolidTile(getTile(nr, nc))) {
          player.x = newX;
        }
      }

      // Up (climb ladder)
      if (keys['ArrowUp']) {
        if (onLad) {
          const newY = player.y - speed;
          const nr = Math.round(newY / TH);
          if (nr >= 0 && !isSolidTile(getTile(nr, Math.round(player.x / TW)))) {
            player.y = newY;
            player.x = Math.round(player.x / TW) * TW; // snap X on ladder
          }
        }
      }

      // Down (descend ladder or through bar)
      if (keys['ArrowDown']) {
        const belowTile = getTile(pr + 1, pc);
        if (onLad || belowTile === LADDER || belowTile === ESCAPE_LADDER) {
          const newY = player.y + speed;
          const nr = Math.round(newY / TH);
          if (nr < ROWS && !isSolidTile(getTile(nr, Math.round(player.x / TW)))) {
            player.y = newY;
            player.x = Math.round(player.x / TW) * TW;
          }
        }
      }

      // Clamp position
      player.x = Math.max(0, Math.min((COLS - 1) * TW, player.x));
      player.y = Math.max(0, Math.min((ROWS - 1) * TH, player.y));

      // Collect gold
      const gr = Math.round(player.y / TH);
      const gc = Math.round(player.x / TW);
      if (getTile(gr, gc) === GOLD) {
        grid[gr][gc] = EMPTY;
        goldCount++;
        score += 100;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        // Check if all gold collected
        if (goldCount >= totalGold) {
          showEscapeLadder();
        }
      }

      // Check level complete: player reaches top row after all gold
      if (goldCount >= totalGold && gr <= 0) {
        levelComplete();
        return;
      }

      // Dig holes (Z = dig left, X = dig right)
      if (keys['z'] || keys['Z']) {
        keys['z'] = false;
        keys['Z'] = false;
        digHole(pc - 1, pr + 1);
      }
      if (keys['x'] || keys['X']) {
        keys['x'] = false;
        keys['X'] = false;
        digHole(pc + 1, pr + 1);
      }
    }

    function digHole(c, r) {
      if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;
      const tile = getTile(r, c);
      if (tile !== BRICK) return;
      // Can't dig if something is on top
      const aboveTile = getTile(r - 1, c);
      // Check no guard or player is standing there
      // Just check the tile is brick and diggable
      grid[r][c] = EMPTY;
      holes.push({ r, c, timer: HOLE_DURATION, originalTile: BRICK });
      player.digTimer = HOLE_DIG_TIME;
    }

    function showEscapeLadder() {
      if (escapeLadderShown) return;
      escapeLadderShown = true;
      // Add escape ladder at top - find a column that makes sense
      // Use the first ladder column we can find, or column 12
      let escapeCol = 12;
      for (let c = 0; c < COLS; c++) {
        if (getTile(1, c) === LADDER) { escapeCol = c; break; }
      }
      // Place escape ladder from row 0 to row 3 (or first solid row)
      for (let r = 0; r < 4; r++) {
        if (!isSolidTile(getTile(r, escapeCol))) {
          grid[r][escapeCol] = ESCAPE_LADDER;
        }
      }
    }

    function levelComplete() {
      level++;
      score += 500 + level * 100; // level bonus
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      if (level >= LEVELS.length) {
        // Game won!
        score += 2000;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = `Score: ${score} -- All levels cleared! Press any key`;
        return;
      }
      parseLevel(level);
    }

    // ---- GUARD AI ----
    function updateGuards(dt) {
      for (const g of guards) {
        if (g.trapped > 0) {
          g.trapped -= dt * 1000;
          if (g.trapped <= 0) {
            // Climb out of hole
            g.trapped = 0;
            g.y = g.trappedR * TH - TH;
            if (g.y < 0) g.y = 0;
            // If guard had gold, drop it
            if (g.hasGold) {
              const tr = g.trappedR;
              const tc = g.trappedC;
              // Drop gold near hole
              if (getTile(tr - 1, tc) === EMPTY) {
                grid[tr - 1][tc] = GOLD;
              }
              g.hasGold = false;
            }
          }
          continue;
        }

        const gr = Math.round(g.y / TH);
        const gc = Math.round(g.x / TW);
        const onLad = isOnLadder(g.x, g.y);
        const onB = isOnBar(g.x, g.y);
        const support = hasSupport(g.x, g.y);

        // Gravity
        if (!support && !onLad && !onB) {
          g.falling = true;
          g.y += GUARD_SPEED * 1.8 * dt;
          // Check if fell into a hole
          const nr = Math.round(g.y / TH);
          const nc = Math.round(g.x / TW);
          // Check if this position is a hole
          for (const hole of holes) {
            if (hole.r === nr && hole.c === nc) {
              // Guard fell into hole - trap it
              g.trapped = GUARD_TRAPPED_TIME;
              g.trappedR = nr;
              g.trappedC = nc;
              g.y = nr * TH;
              g.x = nc * TW;
              g.falling = false;
              break;
            }
          }
          if (hasSupport(g.x, g.y) && g.trapped <= 0) {
            g.y = Math.round(g.y / TH) * TH;
            g.falling = false;
          }
          continue;
        }
        g.falling = false;

        // Simple chase AI
        const pr = Math.round(player.y / TH);
        const pc = Math.round(player.x / TW);
        const speed = GUARD_SPEED * dt;

        // Decide direction
        let moveX = 0, moveY = 0;

        // If on same row, move horizontally toward player
        if (Math.abs(gr - pr) <= 0) {
          if (gc < pc) moveX = 1;
          else if (gc > pc) moveX = -1;
        } else {
          // Try to get to same row: look for ladders
          if (pr < gr) {
            // Player is above - try to go up
            if (onLad) {
              moveY = -1;
            } else {
              // Move toward nearest ladder going up
              let bestLadCol = -1;
              let bestDist = COLS + 1;
              for (let c2 = 0; c2 < COLS; c2++) {
                if ((getTile(gr, c2) === LADDER || getTile(gr, c2) === ESCAPE_LADDER) && Math.abs(c2 - gc) < bestDist) {
                  bestDist = Math.abs(c2 - gc);
                  bestLadCol = c2;
                }
              }
              // Also check ladders on the row above accessible from current row
              if (bestLadCol === -1) {
                for (let c2 = 0; c2 < COLS; c2++) {
                  if ((getTile(gr - 1, c2) === LADDER || getTile(gr - 1, c2) === ESCAPE_LADDER) && Math.abs(c2 - gc) < bestDist) {
                    bestDist = Math.abs(c2 - gc);
                    bestLadCol = c2;
                  }
                }
              }
              if (bestLadCol >= 0) {
                if (gc < bestLadCol) moveX = 1;
                else if (gc > bestLadCol) moveX = -1;
                else moveY = -1; // on the ladder column
              } else {
                // No ladder found, just chase horizontally
                if (gc < pc) moveX = 1;
                else if (gc > pc) moveX = -1;
              }
            }
          } else {
            // Player is below - try to go down
            const belowTile = getTile(gr + 1, gc);
            if (onLad || belowTile === LADDER || belowTile === ESCAPE_LADDER) {
              moveY = 1;
            } else {
              // Move toward nearest ladder/hole going down
              let bestLadCol = -1;
              let bestDist = COLS + 1;
              for (let c2 = 0; c2 < COLS; c2++) {
                const bTile = getTile(gr + 1, c2);
                if ((bTile === LADDER || bTile === ESCAPE_LADDER || getTile(gr, c2) === LADDER || getTile(gr, c2) === ESCAPE_LADDER) && Math.abs(c2 - gc) < bestDist) {
                  bestDist = Math.abs(c2 - gc);
                  bestLadCol = c2;
                }
              }
              // Also try edges where they can fall
              if (bestLadCol === -1) {
                for (let c2 = 0; c2 < COLS; c2++) {
                  if (!isSolidTile(getTile(gr + 1, c2)) && getTile(gr + 1, c2) !== LADDER && Math.abs(c2 - gc) < bestDist) {
                    bestDist = Math.abs(c2 - gc);
                    bestLadCol = c2;
                  }
                }
              }
              if (bestLadCol >= 0) {
                if (gc < bestLadCol) moveX = 1;
                else if (gc > bestLadCol) moveX = -1;
                else moveY = 1;
              } else {
                if (gc < pc) moveX = 1;
                else if (gc > pc) moveX = -1;
              }
            }
          }
        }

        // Apply movement
        if (moveY < 0 && onLad) {
          const newY = g.y - speed;
          const nr = Math.round(newY / TH);
          if (nr >= 0 && !isSolidTile(getTile(nr, gc))) {
            g.y = newY;
            g.x = gc * TW; // snap X
          }
        } else if (moveY > 0) {
          const belowTile = getTile(gr + 1, gc);
          if (onLad || belowTile === LADDER || belowTile === ESCAPE_LADDER) {
            const newY = g.y + speed;
            const nr = Math.round(newY / TH);
            if (nr < ROWS && !isSolidTile(getTile(nr, gc))) {
              g.y = newY;
              g.x = gc * TW;
            }
          }
        }

        if (moveX !== 0) {
          const newX = g.x + moveX * speed;
          const nc = Math.round(newX / TW);
          if (nc >= 0 && nc < COLS && !isSolidTile(getTile(gr, nc))) {
            g.x = newX;
            g.dir = moveX;
          }
        }

        // Clamp
        g.x = Math.max(0, Math.min((COLS - 1) * TW, g.x));
        g.y = Math.max(0, Math.min((ROWS - 1) * TH, g.y));

        // Guard picks up gold
        const ggr = Math.round(g.y / TH);
        const ggc = Math.round(g.x / TW);
        if (!g.hasGold && getTile(ggr, ggc) === GOLD) {
          grid[ggr][ggc] = EMPTY;
          g.hasGold = true;
        }
      }
    }

    function checkCollisions() {
      if (player.dead) return;
      const pr = Math.round(player.y / TH);
      const pc = Math.round(player.x / TW);

      for (const g of guards) {
        if (g.trapped > 0) continue;
        const gr = Math.round(g.y / TH);
        const gc = Math.round(g.x / TW);

        const dx = Math.abs(player.x - g.x);
        const dy = Math.abs(player.y - g.y);
        if (dx < TW * 0.7 && dy < TH * 0.7) {
          playerDie();
          return;
        }
      }
    }

    function playerDie() {
      player.dead = true;
      lives--;
      if (lives <= 0) {
        gameState = 'over';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = `Score: ${score} -- Press any key to restart`;
      } else {
        // Respawn on same level
        setTimeout(() => {
          parseLevel(level);
          player.dead = false;
        }, 500);
      }
    }

    function updateHoles(dt) {
      for (let i = holes.length - 1; i >= 0; i--) {
        holes[i].timer -= dt * 1000;
        if (holes[i].timer <= 0) {
          const h = holes[i];
          // Refill the hole
          grid[h.r][h.c] = h.originalTile;
          // Check if player or guard is in the hole when it refills
          const pr = Math.round(player.y / TH);
          const pc = Math.round(player.x / TW);
          if (pr === h.r && pc === h.c) {
            playerDie();
          }
          for (const g of guards) {
            const gr = Math.round(g.y / TH);
            const gc = Math.round(g.x / TW);
            if (gr === h.r && gc === h.c && g.trapped > 0) {
              // Guard gets killed when hole refills on them, respawn at top
              g.trapped = 0;
              g.y = 0;
              g.x = Math.floor(Math.random() * COLS) * TW;
              if (g.hasGold) {
                // Drop gold at hole location above
                if (getTile(h.r - 1, h.c) === EMPTY) {
                  grid[h.r - 1][h.c] = GOLD;
                }
                g.hasGold = false;
              }
            }
          }
          holes.splice(i, 1);
        }
      }
    }

    // ---- DRAWING ----
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const tile = grid[r][c];
          const x = c * TW;
          const y = r * TH;

          switch (tile) {
            case BRICK:
              ctx.fillStyle = '#6b4226';
              ctx.fillRect(x, y, TW, TH);
              // Brick lines
              ctx.strokeStyle = '#4a2d16';
              ctx.lineWidth = 1;
              ctx.strokeRect(x + 0.5, y + 0.5, TW - 1, TH - 1);
              // Horizontal mortar line
              ctx.beginPath();
              ctx.moveTo(x, y + TH / 2);
              ctx.lineTo(x + TW, y + TH / 2);
              ctx.stroke();
              // Vertical mortar offset
              ctx.beginPath();
              ctx.moveTo(x + TW / 2, y);
              ctx.lineTo(x + TW / 2, y + TH / 2);
              ctx.stroke();
              break;

            case SOLID:
              ctx.fillStyle = '#3a3a5a';
              ctx.fillRect(x, y, TW, TH);
              ctx.strokeStyle = '#2a2a4a';
              ctx.lineWidth = 1;
              ctx.strokeRect(x + 0.5, y + 0.5, TW - 1, TH - 1);
              break;

            case LADDER:
            case ESCAPE_LADDER:
              const ladColor = tile === ESCAPE_LADDER ? '#4f4' : '#a87532';
              ctx.strokeStyle = ladColor;
              ctx.lineWidth = 2;
              if (tile === ESCAPE_LADDER) {
                ctx.shadowColor = '#4f4';
                ctx.shadowBlur = 8;
              }
              // Side rails
              ctx.beginPath();
              ctx.moveTo(x + 3, y);
              ctx.lineTo(x + 3, y + TH);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x + TW - 3, y);
              ctx.lineTo(x + TW - 3, y + TH);
              ctx.stroke();
              // Rungs
              ctx.lineWidth = 1.5;
              for (let ry = 0; ry < 3; ry++) {
                const yy = y + 4 + ry * (TH / 3);
                ctx.beginPath();
                ctx.moveTo(x + 3, yy);
                ctx.lineTo(x + TW - 3, yy);
                ctx.stroke();
              }
              ctx.shadowBlur = 0;
              break;

            case BAR:
              ctx.strokeStyle = '#8888cc';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(x, y + TH / 3);
              ctx.lineTo(x + TW, y + TH / 3);
              ctx.stroke();
              break;

            case GOLD:
              ctx.fillStyle = '#ea4';
              ctx.shadowColor = '#ea4';
              ctx.shadowBlur = 10;
              // Draw a nugget/diamond shape
              ctx.beginPath();
              ctx.moveTo(x + TW / 2, y + 4);
              ctx.lineTo(x + TW - 4, y + TH / 2);
              ctx.lineTo(x + TW / 2, y + TH - 4);
              ctx.lineTo(x + 4, y + TH / 2);
              ctx.closePath();
              ctx.fill();
              ctx.shadowBlur = 0;
              break;
          }
        }
      }

      // Draw holes (flashing bricks about to refill)
      for (const h of holes) {
        if (h.timer < 1000) {
          // Flashing warning
          if (Math.floor(h.timer / 150) % 2 === 0) {
            ctx.fillStyle = 'rgba(107, 66, 38, 0.5)';
            ctx.fillRect(h.c * TW, h.r * TH, TW, TH);
          }
        }
      }

      // Draw guards
      for (const g of guards) {
        if (g.trapped > 0) {
          drawCharacter(g.x, g.y, '#f44', g.dir, true);
        } else {
          drawCharacter(g.x, g.y, '#f44', g.dir, false);
        }
        // Draw gold indicator on guard
        if (g.hasGold) {
          ctx.fillStyle = '#ea4';
          ctx.shadowColor = '#ea4';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(g.x + TW / 2, g.y + 3, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // Draw player
      if (!player.dead) {
        drawCharacter(player.x, player.y, '#4cf', player.dir, false);
      }

      // Draw HUD info
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`Level ${level + 1}/${LEVELS.length}`, 5, 12);
      ctx.fillText(`Lives: ${lives}`, 5, 24);
      ctx.fillText(`Gold: ${goldCount}/${totalGold}`, W - 80, 12);

      if (goldCount >= totalGold) {
        ctx.fillStyle = '#4f4';
        ctx.shadowColor = '#4f4';
        ctx.shadowBlur = 8;
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('ESCAPE! Reach the top!', W / 2, 12);
        ctx.shadowBlur = 0;
      }

      ctx.textAlign = 'left';
    }

    function drawCharacter(x, y, color, dir, trapped) {
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;

      const cx = x + TW / 2;
      const cy = y + TH / 2;

      if (trapped) {
        // Only show head poking out
        ctx.beginPath();
        ctx.arc(cx, y + 4, 4, 0, Math.PI * 2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(cx - 2, y + 3, 1.5, 1.5);
        ctx.fillRect(cx + 1, y + 3, 1.5, 1.5);
      } else {
        // Head
        ctx.beginPath();
        ctx.arc(cx, y + 5, 4, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.fillRect(cx - 2, y + 9, 4, 8);

        // Arms
        ctx.fillRect(cx - 6, y + 10, 4, 2);
        ctx.fillRect(cx + 2, y + 10, 4, 2);

        // Legs
        ctx.fillRect(cx - 4, y + 17, 3, 6);
        ctx.fillRect(cx + 1, y + 17, 3, 6);

        // Eyes
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        if (dir > 0) {
          ctx.fillRect(cx, y + 4, 1.5, 1.5);
          ctx.fillRect(cx + 2, y + 4, 1.5, 1.5);
        } else {
          ctx.fillRect(cx - 3, y + 4, 1.5, 1.5);
          ctx.fillRect(cx - 1, y + 4, 1.5, 1.5);
        }
      }

      ctx.shadowBlur = 0;
    }

    // ---- GAME LOOP ----
    function update(dt) {
      updatePlayer(dt);
      updateGuards(dt);
      updateHoles(dt);
      checkCollisions();

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerDead: player.dead,
        guards: guards.map(g => ({ x: g.x, y: g.y, trapped: g.trapped > 0 })),
        goldRemaining: totalGold - goldCount,
        level: level,
        lives: lives
      };
    }

    function loop(timestamp) {
      if (gameState !== 'playing') return;

      if (!lastTime) lastTime = timestamp;
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      // Cap dt to prevent large jumps
      if (dt > 0.05) dt = 0.05;

      update(dt);
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    function init() {
      score = 0;
      level = 0;
      lives = 3;
      scoreEl.textContent = '0';
      lastTime = null;
      if (animFrame) cancelAnimationFrame(animFrame);
      parseLevel(0);
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'LODE RUNNER';
      overlayText.innerHTML = 'Arrows: move &nbsp; Z/X: dig left/right<br>Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = null;
      animFrame = requestAnimationFrame(loop);
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        keys[e.key] = true;
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Q*bert</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #e64; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 102, 68, 0.5); }
    h1 { color: #e64; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 102, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e64; }
    canvas {
      border: 2px solid #e64;
      box-shadow: 0 0 20px rgba(238, 102, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e64;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>Q*BERT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="520"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:520px;">
      <h2 id="overlayTitle">Q*BERT</h2>
      <p id="overlayText">Press any key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ── Constants ──────────────────────────────────────────
    const ROWS = 7;
    const CUBE_W = 48;       // width of cube top face
    const CUBE_H = 24;       // height of cube top face (isometric half)
    const CUBE_DEPTH = 28;   // depth of cube sides
    const PYRAMID_TOP_X = W / 2;
    const PYRAMID_TOP_Y = 60;
    const HOP_DURATION = 12;  // frames for a hop animation

    // Colors
    const THEME = '#e64';
    const BG = '#1a1a2e';
    const GRID_COLOR = '#16213e';

    // Cube color schemes per level (start color, target color, intermediate for multi-hop)
    const LEVEL_SCHEMES = [
      { start: '#2a2a4e', target: '#e64',  hops: 1 },  // Level 1: 1 hop
      { start: '#2a2a4e', target: '#4f4',  hops: 1 },  // Level 2
      { start: '#2a2a4e', target: '#ff0',  mid: '#f80', hops: 2 },  // Level 3: 2 hops
      { start: '#2a2a4e', target: '#0ff',  mid: '#08f', hops: 2 },  // Level 4
      { start: '#2a2a4e', target: '#f0f',  hops: 1, revert: true },  // Level 5: enemies revert
      { start: '#2a2a4e', target: '#88f',  mid: '#44a', hops: 2, revert: true },  // Level 6
      { start: '#2a2a4e', target: '#f44',  hops: 1, revert: true },  // Level 7
      { start: '#2a2a4e', target: '#0f8',  mid: '#084', hops: 2, revert: true },  // Level 8
    ];

    // ── Game State ────────────────────────────────────────
    let score, best = 0, gameState;
    let lives, level;
    let cubes;       // 2D array: cubes[row][col] = { hopCount }
    let qbert;       // { row, col, hopAnim, hopFrom, hopTo }
    let enemies;     // array of enemy objects
    let discs;       // flying disc power-ups
    let particles;
    let frameCount;
    let levelComplete;
    let levelCompleteTimer;
    let deathTimer;
    let spawnTimer;
    let levelScheme;

    // ── Cube position helpers ─────────────────────────────
    // Each cube is at grid position (row, col) where row 0 is the top
    // Row r has (r+1) cubes, col goes from 0..r
    function cubeScreenPos(row, col) {
      // Isometric positioning
      const x = PYRAMID_TOP_X + (col - row / 2) * CUBE_W;
      const y = PYRAMID_TOP_Y + row * (CUBE_H + CUBE_DEPTH - 6);
      return { x, y };
    }

    function cubeCenter(row, col) {
      const p = cubeScreenPos(row, col);
      return { x: p.x, y: p.y - 4 };
    }

    function isValidCube(row, col) {
      return row >= 0 && row < ROWS && col >= 0 && col <= row;
    }

    // ── Initialization ────────────────────────────────────
    function init() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'Q*BERT';
      overlayText.textContent = 'Arrow keys to hop diagonally\nPress any key to start';
      initLevel();
      draw();
    }

    function initLevel() {
      levelScheme = LEVEL_SCHEMES[(level - 1) % LEVEL_SCHEMES.length];
      cubes = [];
      for (let r = 0; r < ROWS; r++) {
        cubes[r] = [];
        for (let c = 0; c <= r; c++) {
          cubes[r][c] = { hopCount: 0 };
        }
      }
      qbert = { row: 0, col: 0, hopAnim: 0, hopFrom: null, hopTo: null, onDisc: false };
      enemies = [];
      particles = [];
      frameCount = 0;
      levelComplete = false;
      levelCompleteTimer = 0;
      deathTimer = 0;
      spawnTimer = 0;

      // Flying discs: 2 per level, positioned at edges
      discs = [];
      if (level >= 1) {
        // Left disc - accessible from left edge of row 2 or 3
        discs.push({ row: 2, side: 'left', used: false });
        // Right disc - accessible from right edge of row 2 or 3
        discs.push({ row: 3, side: 'right', used: false });
      }
      if (level >= 3) {
        discs.push({ row: 4, side: 'left', used: false });
        discs.push({ row: 5, side: 'right', used: false });
      }

      levelEl.textContent = level;
    }

    // ── Level checking ────────────────────────────────────
    function getCubeColor(hopCount) {
      const scheme = levelScheme;
      if (scheme.hops === 1) {
        return hopCount >= 1 ? scheme.target : scheme.start;
      } else {
        if (hopCount >= 2) return scheme.target;
        if (hopCount === 1) return scheme.mid || scheme.target;
        return scheme.start;
      }
    }

    function isCubeComplete(hopCount) {
      return hopCount >= levelScheme.hops;
    }

    function checkLevelComplete() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c <= r; c++) {
          if (!isCubeComplete(cubes[r][c].hopCount)) return false;
        }
      }
      return true;
    }

    // ── Movement ──────────────────────────────────────────
    // Arrow key mapping to diagonal grid movement:
    // Up    = up-right on pyramid (row-1, col)
    // Down  = down-left on pyramid (row+1, col)
    // Left  = up-left on pyramid (row-1, col-1)
    // Right = down-right on pyramid (row+1, col+1)
    const MOVE_MAP = {
      'ArrowUp':    { dr: -1, dc: 0 },   // up-right
      'ArrowLeft':  { dr: -1, dc: -1 },  // up-left
      'ArrowDown':  { dr: 1, dc: 0 },    // down-left
      'ArrowRight': { dr: 1, dc: 1 },    // down-right
    };

    function tryMove(key) {
      if (qbert.hopAnim > 0 || deathTimer > 0 || levelComplete) return;

      const move = MOVE_MAP[key];
      if (!move) return;

      const newRow = qbert.row + move.dr;
      const newCol = qbert.col + move.dc;

      // Check if moving onto a disc
      if (!isValidCube(newRow, newCol)) {
        // Check for disc
        const disc = findDisc(qbert.row, qbert.col, move.dr, move.dc);
        if (disc && !disc.used) {
          // Ride disc back to top
          disc.used = true;
          qbert.onDisc = true;
          qbert.hopAnim = HOP_DURATION * 2;
          qbert.hopFrom = cubeCenter(qbert.row, qbert.col);
          qbert.hopTo = cubeCenter(0, 0);
          qbert.row = 0;
          qbert.col = 0;
          // Kill all enemies
          enemies.forEach(e => {
            spawnParticles(cubeCenter(e.row, e.col).x, cubeCenter(e.row, e.col).y, '#f44', 8);
          });
          enemies = [];
          score += 500;
          scoreEl.textContent = score;
          return;
        }
        // Fall off pyramid
        playerDeath();
        return;
      }

      // Valid move
      qbert.hopAnim = HOP_DURATION;
      qbert.hopFrom = cubeCenter(qbert.row, qbert.col);
      qbert.row = newRow;
      qbert.col = newCol;
      qbert.hopTo = cubeCenter(newRow, newCol);

      // Land on cube - change its color
      const cube = cubes[newRow][newCol];
      if (!isCubeComplete(cube.hopCount)) {
        cube.hopCount++;
        score += 25;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
        }
      }
    }

    function findDisc(row, col, dr, dc) {
      // A disc is reachable if the player is on an edge cube and moving off
      for (const disc of discs) {
        if (disc.used) continue;
        if (disc.side === 'left') {
          // Reachable from col=0 of disc.row, moving up-left (dr=-1, dc=-1)
          if (row === disc.row && col === 0 && dr === -1 && dc === -1) return disc;
        } else {
          // Reachable from col=row of disc.row, moving up-right (dr=-1, dc=0)
          if (row === disc.row && col === row && dr === -1 && dc === 0) return disc;
        }
      }
      return null;
    }

    function playerDeath() {
      if (deathTimer > 0) return;
      lives--;
      livesEl.textContent = lives;
      deathTimer = 60;
      spawnParticles(cubeCenter(qbert.row, qbert.col).x, cubeCenter(qbert.row, qbert.col).y, THEME, 15);

      if (lives <= 0) {
        // Short delay then game over
        setTimeout(() => {
          gameState = 'over';
          overlay.style.display = 'flex';
          overlayTitle.textContent = 'GAME OVER';
          overlayText.textContent = `Score: ${score} -- Press any key to restart`;
        }, 500);
      }
    }

    // ── Enemies ───────────────────────────────────────────
    function spawnEnemy() {
      const type = Math.random() < 0.5 + level * 0.05 ? 'coily' : 'redball';
      // Spawn at top, randomly left or right
      const side = Math.random() < 0.5 ? 0 : 1;
      const startRow = 0;
      const startCol = 0;

      const enemy = {
        type,
        row: startRow,
        col: startCol,
        hopAnim: 0,
        hopFrom: null,
        hopTo: null,
        state: 'egg',  // starts as egg, becomes snake at row 2
        moveTimer: 0,
        moveInterval: type === 'coily' ? 30 : 25,
      };

      enemies.push(enemy);
    }

    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        if (e.hopAnim > 0) {
          e.hopAnim--;
          continue;
        }

        e.moveTimer++;
        if (e.moveTimer < e.moveInterval) continue;
        e.moveTimer = 0;

        let dr, dc;

        if (e.type === 'redball' || e.state === 'egg') {
          // Random downward movement
          if (Math.random() < 0.5) {
            dr = 1; dc = 0;   // down-left
          } else {
            dr = 1; dc = 1;   // down-right
          }
        } else {
          // Coily: chase Q*bert
          dr = qbert.row > e.row ? 1 : -1;
          dc = 0;

          if (dr === 1) {
            // Moving down: choose left or right based on Q*bert position
            dc = qbert.col > e.col ? 1 : 0;
          } else {
            // Moving up: choose based on Q*bert
            dc = qbert.col < e.col ? -1 : 0;
          }
        }

        const newRow = e.row + dr;
        const newCol = e.col + dc;

        if (!isValidCube(newRow, newCol)) {
          // Enemy falls off
          if (e.type === 'coily' && e.state !== 'egg') {
            score += 500;
            scoreEl.textContent = score;
            spawnParticles(cubeCenter(e.row, e.col).x, cubeCenter(e.row, e.col).y, '#a4f', 10);
          }
          enemies.splice(i, 1);
          continue;
        }

        e.hopFrom = cubeCenter(e.row, e.col);
        e.row = newRow;
        e.col = newCol;
        e.hopTo = cubeCenter(newRow, newCol);
        e.hopAnim = HOP_DURATION;

        // Coily egg transforms at row 2
        if (e.type === 'coily' && e.state === 'egg' && e.row >= 2) {
          e.state = 'snake';
          e.moveInterval = Math.max(18, 30 - level * 2);
        }

        // Revert cube color if level has revert
        if (levelScheme.revert && e.state === 'snake' && cubes[newRow][newCol].hopCount > 0) {
          cubes[newRow][newCol].hopCount--;
        }

        // Check collision with Q*bert
        if (e.row === qbert.row && e.col === qbert.col && qbert.hopAnim === 0) {
          playerDeath();
        }
      }
    }

    // ── Particles ─────────────────────────────────────────
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
        const speed = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 20 + Math.random() * 15,
          color,
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].vy += 0.1;  // gravity
        particles[i].life--;
        if (particles[i].life <= 0) particles.splice(i, 1);
      }
    }

    // ── Game loop ─────────────────────────────────────────
    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      initLevel();
      loop();
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      // Hop animation
      if (qbert.hopAnim > 0) {
        qbert.hopAnim--;
        if (qbert.hopAnim === 0) {
          qbert.onDisc = false;
          // Check collision with enemies after landing
          for (const e of enemies) {
            if (e.row === qbert.row && e.col === qbert.col && e.hopAnim === 0) {
              playerDeath();
              break;
            }
          }
        }
      }

      // Death recovery
      if (deathTimer > 0) {
        deathTimer--;
        if (deathTimer === 0 && lives > 0) {
          // Reset Q*bert to top
          qbert.row = 0;
          qbert.col = 0;
          qbert.hopAnim = 0;
          qbert.onDisc = false;
          enemies = [];
        }
        return;
      }

      // Level complete check
      if (!levelComplete && checkLevelComplete()) {
        levelComplete = true;
        levelCompleteTimer = 90;
        score += 1000 + level * 250;
        scoreEl.textContent = score;
        // Flash effect
        spawnParticles(W / 2, H / 2, '#ff0', 20);
        spawnParticles(W / 2, H / 2, THEME, 20);
      }

      if (levelComplete) {
        levelCompleteTimer--;
        if (levelCompleteTimer <= 0) {
          level++;
          levelComplete = false;
          initLevel();
        }
        updateParticles();
        return;
      }

      // Enemy spawning
      spawnTimer++;
      const spawnInterval = Math.max(80, 200 - level * 15);
      if (spawnTimer >= spawnInterval && enemies.length < Math.min(3 + level, 6)) {
        spawnEnemy();
        spawnTimer = 0;
      }

      updateEnemies();
      updateParticles();
    }

    // ── Drawing ───────────────────────────────────────────
    function drawCube(row, col) {
      const pos = cubeScreenPos(row, col);
      const x = pos.x;
      const y = pos.y;
      const halfW = CUBE_W / 2;
      const cube = cubes[row][col];
      const color = getCubeColor(cube.hopCount);
      const complete = isCubeComplete(cube.hopCount);

      // Top face
      ctx.fillStyle = color;
      if (complete) {
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
      }
      ctx.beginPath();
      ctx.moveTo(x, y - CUBE_H);           // top
      ctx.lineTo(x + halfW, y);              // right
      ctx.lineTo(x, y + CUBE_H);            // bottom
      ctx.lineTo(x - halfW, y);              // left
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Left face (darker)
      ctx.fillStyle = darkenColor(color, 0.5);
      ctx.beginPath();
      ctx.moveTo(x - halfW, y);             // top-left
      ctx.lineTo(x, y + CUBE_H);            // top-right
      ctx.lineTo(x, y + CUBE_H + CUBE_DEPTH);  // bottom-right
      ctx.lineTo(x - halfW, y + CUBE_DEPTH);    // bottom-left
      ctx.closePath();
      ctx.fill();

      // Right face (slightly darker)
      ctx.fillStyle = darkenColor(color, 0.65);
      ctx.beginPath();
      ctx.moveTo(x + halfW, y);             // top-right
      ctx.lineTo(x, y + CUBE_H);            // top-left
      ctx.lineTo(x, y + CUBE_H + CUBE_DEPTH);  // bottom-left
      ctx.lineTo(x + halfW, y + CUBE_DEPTH);    // bottom-right
      ctx.closePath();
      ctx.fill();

      // Edge highlights
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x - halfW, y);
      ctx.lineTo(x, y - CUBE_H);
      ctx.lineTo(x + halfW, y);
      ctx.stroke();
    }

    function darkenColor(hex, factor) {
      // Parse hex color and darken
      let r, g, b;
      if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      } else {
        r = parseInt(hex.slice(1, 3), 16);
        g = parseInt(hex.slice(3, 5), 16);
        b = parseInt(hex.slice(5, 7), 16);
      }
      r = Math.round(r * factor);
      g = Math.round(g * factor);
      b = Math.round(b * factor);
      return `rgb(${r},${g},${b})`;
    }

    function drawDisc(disc) {
      if (disc.used) return;
      const cubePos = cubeScreenPos(disc.row, disc.side === 'left' ? -1 : disc.row + 1);
      const x = cubePos.x;
      const y = cubePos.y - 5;

      // Spinning disc effect
      const spin = Math.sin(frameCount * 0.1) * 0.3 + 0.7;

      ctx.fillStyle = '#f0f';
      ctx.shadowColor = '#f0f';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.ellipse(x, y, 14, 8 * spin, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff0';
      ctx.beginPath();
      ctx.ellipse(x, y, 7, 4 * spin, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function getHopPosition(from, to, progress) {
      // progress: 0 = at start, 1 = at end
      const x = from.x + (to.x - from.x) * progress;
      const baseY = from.y + (to.y - from.y) * progress;
      // Arc: jump up in the middle
      const arc = -Math.sin(progress * Math.PI) * 30;
      return { x, y: baseY + arc };
    }

    function drawQbert() {
      if (deathTimer > 0) {
        // Flash Q*bert during invulnerability
        if (Math.floor(deathTimer / 4) % 2 === 0) return;
      }

      let pos;
      if (qbert.hopAnim > 0 && qbert.hopFrom && qbert.hopTo) {
        const progress = 1 - qbert.hopAnim / (qbert.onDisc ? HOP_DURATION * 2 : HOP_DURATION);
        pos = getHopPosition(qbert.hopFrom, qbert.hopTo, progress);
      } else {
        pos = cubeCenter(qbert.row, qbert.col);
      }

      const x = pos.x;
      const y = pos.y - 18;

      // Body (round orange character)
      ctx.fillStyle = '#f80';
      ctx.shadowColor = '#f80';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(x, y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 4, y - 3, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 4, y - 3, 4, 0, Math.PI * 2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x - 3, y - 3, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 5, y - 3, 2, 0, Math.PI * 2);
      ctx.fill();

      // Nose / snout
      ctx.fillStyle = '#fa4';
      ctx.beginPath();
      ctx.arc(x, y + 4, 5, 0, Math.PI * 2);
      ctx.fill();

      // Feet
      ctx.fillStyle = '#f60';
      ctx.fillRect(x - 8, y + 10, 5, 4);
      ctx.fillRect(x + 3, y + 10, 5, 4);

      // Speech bubble when hit ("!@#$%!")
      if (deathTimer > 40) {
        ctx.fillStyle = '#fff';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('!@#$%!', x, y - 22);
      }
    }

    function drawEnemy(e) {
      let pos;
      if (e.hopAnim > 0 && e.hopFrom && e.hopTo) {
        const progress = 1 - e.hopAnim / HOP_DURATION;
        pos = getHopPosition(e.hopFrom, e.hopTo, progress);
      } else {
        pos = cubeCenter(e.row, e.col);
      }

      const x = pos.x;
      const y = pos.y - 16;

      if (e.type === 'redball') {
        // Red bouncing ball
        ctx.fillStyle = '#f22';
        ctx.shadowColor = '#f22';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        // Highlight
        ctx.fillStyle = '#f88';
        ctx.beginPath();
        ctx.arc(x - 3, y - 3, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else if (e.type === 'coily') {
        if (e.state === 'egg') {
          // Purple egg
          ctx.fillStyle = '#a4f';
          ctx.shadowColor = '#a4f';
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.ellipse(x, y, 8, 11, 0, 0, Math.PI * 2);
          ctx.fill();
          // Crack lines
          ctx.strokeStyle = '#c8f';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x - 3, y - 2);
          ctx.lineTo(x, y + 2);
          ctx.lineTo(x + 3, y - 1);
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else {
          // Coily snake
          ctx.fillStyle = '#a4f';
          ctx.shadowColor = '#a4f';
          ctx.shadowBlur = 10;

          // Body (coiled)
          ctx.beginPath();
          ctx.arc(x, y + 2, 10, 0, Math.PI * 2);
          ctx.fill();

          // Head
          ctx.fillStyle = '#c6f';
          ctx.beginPath();
          ctx.arc(x, y - 8, 7, 0, Math.PI * 2);
          ctx.fill();

          // Eyes (menacing)
          ctx.fillStyle = '#f00';
          ctx.beginPath();
          ctx.arc(x - 3, y - 9, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + 3, y - 9, 2.5, 0, Math.PI * 2);
          ctx.fill();

          // Pupils
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(x - 3, y - 9, 1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + 3, y - 9, 1, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
        }
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      // Subtle starfield
      ctx.fillStyle = '#ffffff10';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 83) % W);
        const sy = ((i * 251 + 47) % H);
        ctx.fillRect(sx, sy, 1, 1);
      }

      // Draw cubes (back to front for proper overlap)
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c <= r; c++) {
          drawCube(r, c);
        }
      }

      // Draw discs
      discs.forEach(d => drawDisc(d));

      // Draw enemies (behind Q*bert in draw order)
      enemies.forEach(e => drawEnemy(e));

      // Draw Q*bert
      if (gameState === 'playing' || gameState === 'waiting') {
        drawQbert();
      }

      // Draw particles
      particles.forEach(p => {
        const alpha = Math.min(1, p.life / 15);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // Level complete flash
      if (levelComplete) {
        const flash = Math.sin(levelCompleteTimer * 0.3) * 0.3 + 0.2;
        ctx.fillStyle = `rgba(238, 102, 68, ${flash})`;
        ctx.fillRect(0, 0, W, H);

        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 15;
        ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 10);
        ctx.font = '16px Courier New';
        ctx.fillStyle = '#fff';
        ctx.fillText(`+${1000 + level * 250} BONUS`, W / 2, H / 2 + 20);
        ctx.shadowBlur = 0;
      }

      // HUD on canvas: small level indicator and target color
      if (gameState === 'playing' && !levelComplete) {
        // Show target color swatch
        ctx.font = '11px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#888';
        ctx.fillText('Target:', 10, 18);
        ctx.fillStyle = levelScheme.target;
        ctx.shadowColor = levelScheme.target;
        ctx.shadowBlur = 6;
        ctx.fillRect(65, 8, 16, 14);
        ctx.shadowBlur = 0;

        // Progress: count completed cubes
        let total = 0, done = 0;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c <= r; c++) {
            total++;
            if (isCubeComplete(cubes[r][c].hopCount)) done++;
          }
        }
        ctx.fillStyle = '#888';
        ctx.textAlign = 'right';
        ctx.fillText(`${done}/${total}`, W - 10, 18);
      }
    }

    // ── Input handling ────────────────────────────────────
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        tryMove(e.key);
      }
    });

    // Expose game data for ML
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        qbertRow: qbert.row,
        qbertCol: qbert.col,
        enemies: enemies.map(e => ({ type: e.type, state: e.state, row: e.row, col: e.col })),
        level,
        lives,
        cubesRemaining: (() => {
          let count = 0;
          for (let r = 0; r < ROWS; r++)
            for (let c = 0; c <= r; c++)
              if (!isCubeComplete(cubes[r][c].hopCount)) count++;
          return count;
        })(),
      };
    }

    // Override update to also update gameData
    const _origUpdate = update;
    update = function() {
      _origUpdate();
      updateGameData();
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

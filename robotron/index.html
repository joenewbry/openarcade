<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robotron 2084</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #f8f; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255,136,255,0.4); }
    h1 { color: #f8f; font-size: 2rem; text-shadow: 0 0 15px rgba(255,136,255,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f8f; }
    canvas {
      border: 2px solid #f8f;
      box-shadow: 0 0 20px rgba(255,136,255,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f8f;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ROBOTRON 2084</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Wave: <span id="wave">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">ROBOTRON 2084</h2>
      <p id="overlayText">WASD to move / Arrows to fire<br>Press any key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const waveEl = document.getElementById('wave');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;
    let player, bullets, enemies, humans, particles, electrodes;
    let lives, wave, tick, spawnTimers;
    let keys = {};
    let fireDir = { x: 0, y: 0 };
    let fireCooldown = 0;
    let waveTransitionTimer = 0;
    let humansRescuedThisWave = 0;

    // Constants
    const PLAYER_SIZE = 12;
    const PLAYER_SPEED = 3;
    const BULLET_SPEED = 7;
    const BULLET_LIFE = 80;
    const FIRE_RATE = 6; // frames between shots
    const HUMAN_SIZE = 10;
    const GRUNT_SIZE = 10;
    const GRUNT_SPEED_BASE = 0.8;
    const HULK_SIZE = 16;
    const HULK_SPEED = 0.6;
    const BRAIN_SIZE = 11;
    const BRAIN_SPEED = 0.7;
    const SPHEROID_SIZE = 14;
    const SPHEROID_SPEED = 0.5;
    const ENFORCER_SIZE = 9;
    const ENFORCER_SPEED = 1.8;
    const ELECTRODE_SIZE = 8;

    // Human types
    const HUMAN_TYPES = [
      { name: 'Mom', color: '#ff6b9d' },
      { name: 'Dad', color: '#4ecdc4' },
      { name: 'Kid', color: '#ffe66d' }
    ];

    function init() {
      score = 0;
      lives = 3;
      wave = 0;
      tick = 0;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      waveEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'ROBOTRON 2084';
      overlayText.innerHTML = 'WASD to move / Arrows to fire<br>Press any key to start';
      player = { x: W / 2, y: H / 2 };
      bullets = [];
      enemies = [];
      humans = [];
      particles = [];
      electrodes = [];
      keys = {};
      fireDir = { x: 0, y: 0 };
      draw();
    }

    function startWave() {
      wave++;
      waveEl.textContent = wave;
      bullets = [];
      enemies = [];
      humans = [];
      particles = [];
      electrodes = [];
      humansRescuedThisWave = 0;
      spawnTimers = { spheroidSpawn: 0 };

      player.x = W / 2;
      player.y = H / 2;

      // Difficulty scaling
      const diff = Math.min(wave, 20);

      // Spawn grunts
      const gruntCount = 5 + diff * 3;
      for (let i = 0; i < gruntCount; i++) {
        spawnEnemy('grunt');
      }

      // Spawn hulks (from wave 2)
      if (wave >= 2) {
        const hulkCount = Math.min(1 + Math.floor(diff / 2), 8);
        for (let i = 0; i < hulkCount; i++) {
          spawnEnemy('hulk');
        }
      }

      // Spawn brains (from wave 3)
      if (wave >= 3) {
        const brainCount = Math.min(Math.floor(diff / 3), 5);
        for (let i = 0; i < brainCount; i++) {
          spawnEnemy('brain');
        }
      }

      // Spawn spheroids (from wave 4)
      if (wave >= 4) {
        const spheroidCount = Math.min(Math.floor(diff / 4), 4);
        for (let i = 0; i < spheroidCount; i++) {
          spawnEnemy('spheroid');
        }
      }

      // Spawn electrodes (from wave 5)
      if (wave >= 5) {
        const electrodeCount = Math.min(2 + Math.floor(diff / 3), 12);
        for (let i = 0; i < electrodeCount; i++) {
          electrodes.push({
            x: 30 + Math.random() * (W - 60),
            y: 30 + Math.random() * (H - 60),
            pulse: Math.random() * Math.PI * 2
          });
        }
      }

      // Spawn humans
      const humanCount = 3 + Math.min(Math.floor(diff / 2), 7);
      for (let i = 0; i < humanCount; i++) {
        const type = HUMAN_TYPES[Math.floor(Math.random() * HUMAN_TYPES.length)];
        humans.push({
          x: 30 + Math.random() * (W - 60),
          y: 30 + Math.random() * (H - 60),
          vx: (Math.random() - 0.5) * 1.2,
          vy: (Math.random() - 0.5) * 1.2,
          type: type,
          alive: true,
          changeTimer: Math.floor(Math.random() * 120)
        });
      }

      // Show wave intro briefly
      waveTransitionTimer = 90;
      gameState = 'waveIntro';
      overlay.style.display = 'flex';
      overlayTitle.textContent = `WAVE ${wave}`;
      overlayText.textContent = wave >= 5 ? 'Watch for Electrodes!' :
                                wave >= 4 ? 'Spheroids incoming!' :
                                wave >= 3 ? 'Brains hunt humans!' :
                                wave >= 2 ? 'Hulks are indestructible!' :
                                'Save the humans!';
    }

    function getRandomEdgePosition(margin) {
      const side = Math.floor(Math.random() * 4);
      let x, y;
      switch (side) {
        case 0: x = margin + Math.random() * (W - margin * 2); y = margin; break;
        case 1: x = margin + Math.random() * (W - margin * 2); y = H - margin; break;
        case 2: x = margin; y = margin + Math.random() * (H - margin * 2); break;
        case 3: x = W - margin; y = margin + Math.random() * (H - margin * 2); break;
      }
      return { x, y };
    }

    function spawnEnemy(type) {
      // Spawn away from player
      let x, y;
      let attempts = 0;
      do {
        const pos = getRandomEdgePosition(10);
        x = pos.x;
        y = pos.y;
        attempts++;
      } while (dist(x, y, player.x, player.y) < 100 && attempts < 20);

      const enemy = { x, y, type, alive: true };

      switch (type) {
        case 'grunt':
          enemy.speed = GRUNT_SPEED_BASE + Math.random() * 0.3 + wave * 0.05;
          break;
        case 'hulk':
          enemy.speed = HULK_SPEED;
          enemy.pushCooldown = 0;
          break;
        case 'brain':
          enemy.speed = BRAIN_SPEED + wave * 0.02;
          enemy.targetHuman = null;
          enemy.convertTimer = 0;
          break;
        case 'spheroid':
          enemy.speed = SPHEROID_SPEED;
          enemy.angle = Math.random() * Math.PI * 2;
          enemy.spawnTimer = 180 + Math.floor(Math.random() * 180);
          enemy.enforcersSpawned = 0;
          enemy.maxEnforcers = 2 + Math.floor(wave / 3);
          break;
        case 'enforcer':
          enemy.speed = ENFORCER_SPEED;
          enemy.shootTimer = 60 + Math.floor(Math.random() * 60);
          enemy.angle = Math.random() * Math.PI * 2;
          break;
        case 'prog': // converted human (by brain)
          enemy.speed = 1.5 + wave * 0.05;
          break;
      }

      enemies.push(enemy);
    }

    function dist(x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function normalize(x, y) {
      const len = Math.sqrt(x * x + y * y) || 1;
      return { x: x / len, y: y / len };
    }

    function start() {
      overlay.style.display = 'none';
      startWave();
      loop();
    }

    function loop() {
      if (gameState === 'over') return;
      tick++;

      if (gameState === 'waveIntro') {
        waveTransitionTimer--;
        if (waveTransitionTimer <= 0) {
          gameState = 'playing';
          overlay.style.display = 'none';
        }
        draw();
        requestAnimationFrame(loop);
        return;
      }

      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Player movement (WASD)
      let pmx = 0, pmy = 0;
      if (keys['w'] || keys['W']) pmy -= 1;
      if (keys['s'] || keys['S']) pmy += 1;
      if (keys['a'] || keys['A']) pmx -= 1;
      if (keys['d'] || keys['D']) pmx += 1;
      if (pmx !== 0 || pmy !== 0) {
        const pn = normalize(pmx, pmy);
        player.x += pn.x * PLAYER_SPEED;
        player.y += pn.y * PLAYER_SPEED;
      }
      // Clamp to arena
      player.x = Math.max(PLAYER_SIZE, Math.min(W - PLAYER_SIZE, player.x));
      player.y = Math.max(PLAYER_SIZE, Math.min(H - PLAYER_SIZE, player.y));

      // Fire direction (Arrow keys)
      let fx = 0, fy = 0;
      if (keys['ArrowUp']) fy -= 1;
      if (keys['ArrowDown']) fy += 1;
      if (keys['ArrowLeft']) fx -= 1;
      if (keys['ArrowRight']) fx += 1;
      if (fx !== 0 || fy !== 0) {
        fireDir = normalize(fx, fy);
      }

      // Continuous firing
      if (fireCooldown > 0) fireCooldown--;
      if ((fx !== 0 || fy !== 0) && fireCooldown <= 0) {
        fireCooldown = FIRE_RATE;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: fireDir.x * BULLET_SPEED,
          vy: fireDir.y * BULLET_SPEED,
          life: BULLET_LIFE
        });
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        b.life--;
        if (b.x < 0 || b.x > W || b.y < 0 || b.y > H || b.life <= 0) {
          bullets.splice(i, 1);
        }
      }

      // Update enemies
      const liveEnemies = enemies.filter(e => e.alive);

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.alive) { enemies.splice(i, 1); continue; }

        switch (e.type) {
          case 'grunt':
          case 'prog':
            moveToward(e, player.x, player.y, e.speed);
            break;

          case 'hulk':
            moveToward(e, player.x, player.y, e.speed);
            // Hulks push player on contact instead of killing
            if (e.pushCooldown > 0) e.pushCooldown--;
            // Hulks destroy nearby humans
            for (let h = humans.length - 1; h >= 0; h--) {
              if (humans[h].alive && dist(e.x, e.y, humans[h].x, humans[h].y) < HULK_SIZE + HUMAN_SIZE) {
                humans[h].alive = false;
                spawnParticles(humans[h].x, humans[h].y, humans[h].type.color, 6);
              }
            }
            break;

          case 'brain':
            // Find nearest alive human to convert
            let nearestHuman = null;
            let nearestDist = Infinity;
            for (const h of humans) {
              if (!h.alive) continue;
              const d = dist(e.x, e.y, h.x, h.y);
              if (d < nearestDist) { nearestDist = d; nearestHuman = h; }
            }
            if (nearestHuman) {
              moveToward(e, nearestHuman.x, nearestHuman.y, e.speed);
              if (nearestDist < BRAIN_SIZE + HUMAN_SIZE) {
                // Convert human to prog (enemy)
                nearestHuman.alive = false;
                spawnParticles(nearestHuman.x, nearestHuman.y, '#f0f', 8);
                const prog = {
                  x: nearestHuman.x, y: nearestHuman.y,
                  type: 'prog', alive: true,
                  speed: 1.5 + wave * 0.05
                };
                enemies.push(prog);
              }
            } else {
              // No humans left, chase player
              moveToward(e, player.x, player.y, e.speed);
            }
            break;

          case 'spheroid':
            // Float in circles, occasionally spawning enforcers
            e.angle += 0.02;
            e.x += Math.cos(e.angle) * e.speed;
            e.y += Math.sin(e.angle * 0.7) * e.speed;
            // Bounce off walls
            if (e.x < SPHEROID_SIZE) { e.x = SPHEROID_SIZE; e.angle = Math.PI - e.angle; }
            if (e.x > W - SPHEROID_SIZE) { e.x = W - SPHEROID_SIZE; e.angle = Math.PI - e.angle; }
            if (e.y < SPHEROID_SIZE) { e.y = SPHEROID_SIZE; e.angle = -e.angle; }
            if (e.y > H - SPHEROID_SIZE) { e.y = H - SPHEROID_SIZE; e.angle = -e.angle; }
            // Spawn enforcers
            e.spawnTimer--;
            if (e.spawnTimer <= 0 && e.enforcersSpawned < e.maxEnforcers) {
              e.spawnTimer = 120 + Math.floor(Math.random() * 120);
              e.enforcersSpawned++;
              const enf = {
                x: e.x, y: e.y,
                type: 'enforcer', alive: true,
                speed: ENFORCER_SPEED,
                shootTimer: 60 + Math.floor(Math.random() * 60),
                angle: Math.random() * Math.PI * 2
              };
              enemies.push(enf);
            }
            break;

          case 'enforcer':
            // Chase player loosely
            e.angle += (Math.random() - 0.5) * 0.3;
            const toPlayerAngle = Math.atan2(player.y - e.y, player.x - e.x);
            e.angle += (toPlayerAngle - e.angle) * 0.05;
            e.x += Math.cos(e.angle) * e.speed;
            e.y += Math.sin(e.angle) * e.speed;
            e.x = Math.max(ENFORCER_SIZE, Math.min(W - ENFORCER_SIZE, e.x));
            e.y = Math.max(ENFORCER_SIZE, Math.min(H - ENFORCER_SIZE, e.y));
            // Shoot at player
            e.shootTimer--;
            if (e.shootTimer <= 0) {
              e.shootTimer = 40 + Math.floor(Math.random() * 40);
              const dir = normalize(player.x - e.x, player.y - e.y);
              enemies.push({
                x: e.x, y: e.y,
                type: 'enforcerBullet', alive: true,
                vx: dir.x * 3,
                vy: dir.y * 3,
                life: 120
              });
            }
            break;

          case 'enforcerBullet':
            e.x += e.vx;
            e.y += e.vy;
            e.life--;
            if (e.x < 0 || e.x > W || e.y < 0 || e.y > H || e.life <= 0) {
              e.alive = false;
            }
            break;
        }

        // Check collision with player (skip hulk - it pushes instead of killing)
        if (e.alive && e.type !== 'hulk') {
          const hitRadius = e.type === 'enforcerBullet' ? 4 :
                           e.type === 'grunt' || e.type === 'prog' ? GRUNT_SIZE :
                           e.type === 'brain' ? BRAIN_SIZE :
                           e.type === 'spheroid' ? SPHEROID_SIZE :
                           e.type === 'enforcer' ? ENFORCER_SIZE : 8;
          if (dist(e.x, e.y, player.x, player.y) < hitRadius + PLAYER_SIZE - 4) {
            playerDeath();
            return;
          }
        }

        // Hulk pushes player
        if (e.alive && e.type === 'hulk' && e.pushCooldown <= 0) {
          if (dist(e.x, e.y, player.x, player.y) < HULK_SIZE + PLAYER_SIZE - 2) {
            const pushDir = normalize(player.x - e.x, player.y - e.y);
            player.x += pushDir.x * 30;
            player.y += pushDir.y * 30;
            player.x = Math.max(PLAYER_SIZE, Math.min(W - PLAYER_SIZE, player.x));
            player.y = Math.max(PLAYER_SIZE, Math.min(H - PLAYER_SIZE, player.y));
            e.pushCooldown = 30;
            spawnParticles(player.x, player.y, '#fff', 4);
          }
        }
      }

      // Bullet-enemy collisions
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        let bulletHit = false;
        for (let ei = enemies.length - 1; ei >= 0; ei--) {
          const e = enemies[ei];
          if (!e.alive) continue;
          if (e.type === 'hulk') {
            // Hulks are indestructible but bullets bounce off them
            if (dist(b.x, b.y, e.x, e.y) < HULK_SIZE) {
              spawnParticles(b.x, b.y, '#888', 3);
              bulletHit = true;
              break;
            }
            continue;
          }
          if (e.type === 'enforcerBullet') continue; // bullets don't destroy enemy bullets
          const hitR = e.type === 'grunt' || e.type === 'prog' ? GRUNT_SIZE :
                       e.type === 'brain' ? BRAIN_SIZE :
                       e.type === 'spheroid' ? SPHEROID_SIZE :
                       e.type === 'enforcer' ? ENFORCER_SIZE : 8;
          if (dist(b.x, b.y, e.x, e.y) < hitR) {
            e.alive = false;
            bulletHit = true;
            const points = e.type === 'grunt' ? 100 :
                          e.type === 'brain' ? 500 :
                          e.type === 'spheroid' ? 1000 :
                          e.type === 'enforcer' ? 200 :
                          e.type === 'prog' ? 100 : 50;
            score += points * Math.ceil(wave / 3);
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            const eColor = e.type === 'grunt' ? '#f44' :
                          e.type === 'brain' ? '#f0f' :
                          e.type === 'spheroid' ? '#4af' :
                          e.type === 'enforcer' ? '#ff0' :
                          e.type === 'prog' ? '#f80' : '#fff';
            spawnParticles(e.x, e.y, eColor, 10);
            break;
          }
        }
        if (bulletHit) {
          bullets.splice(bi, 1);
        }
      }

      // Electrode collision with player
      for (const el of electrodes) {
        if (dist(player.x, player.y, el.x, el.y) < ELECTRODE_SIZE + PLAYER_SIZE - 4) {
          playerDeath();
          return;
        }
      }

      // Bullet-electrode collisions (bullets destroy electrodes)
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        for (let ei = electrodes.length - 1; ei >= 0; ei--) {
          if (dist(b.x, b.y, electrodes[ei].x, electrodes[ei].y) < ELECTRODE_SIZE) {
            spawnParticles(electrodes[ei].x, electrodes[ei].y, '#0ff', 6);
            electrodes.splice(ei, 1);
            bullets.splice(bi, 1);
            score += 25;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            break;
          }
        }
      }

      // Update humans
      for (const h of humans) {
        if (!h.alive) continue;
        h.changeTimer--;
        if (h.changeTimer <= 0) {
          h.changeTimer = 60 + Math.floor(Math.random() * 120);
          h.vx = (Math.random() - 0.5) * 1.5;
          h.vy = (Math.random() - 0.5) * 1.5;
        }
        h.x += h.vx;
        h.y += h.vy;
        // Bounce off walls
        if (h.x < HUMAN_SIZE) { h.x = HUMAN_SIZE; h.vx = Math.abs(h.vx); }
        if (h.x > W - HUMAN_SIZE) { h.x = W - HUMAN_SIZE; h.vx = -Math.abs(h.vx); }
        if (h.y < HUMAN_SIZE) { h.y = HUMAN_SIZE; h.vy = Math.abs(h.vy); }
        if (h.y > H - HUMAN_SIZE) { h.y = H - HUMAN_SIZE; h.vy = -Math.abs(h.vy); }

        // Player rescues human by touching
        if (dist(player.x, player.y, h.x, h.y) < PLAYER_SIZE + HUMAN_SIZE) {
          h.alive = false;
          humansRescuedThisWave++;
          const rescueBonus = 1000 * Math.ceil(wave / 2) * humansRescuedThisWave;
          score += rescueBonus;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          spawnParticles(h.x, h.y, h.type.color, 12);
          // Show score popup
          particles.push({
            x: h.x, y: h.y - 10,
            vx: 0, vy: -0.8,
            life: 40,
            color: h.type.color,
            text: '+' + rescueBonus
          });
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Check wave complete: all killable enemies dead
      const killableEnemies = enemies.filter(e =>
        e.alive && e.type !== 'enforcerBullet'
      );
      if (killableEnemies.length === 0) {
        startWave();
      }
    }

    function moveToward(entity, tx, ty, speed) {
      const dir = normalize(tx - entity.x, ty - entity.y);
      entity.x += dir.x * speed;
      entity.y += dir.y * speed;
      entity.x = Math.max(5, Math.min(W - 5, entity.x));
      entity.y = Math.max(5, Math.min(H - 5, entity.y));
    }

    function playerDeath() {
      lives--;
      livesEl.textContent = lives;
      spawnParticles(player.x, player.y, '#f8f', 20);

      if (lives <= 0) {
        gameOver();
        return;
      }

      // Respawn player at center, clear nearby enemies
      player.x = W / 2;
      player.y = H / 2;
      // Brief invincibility handled by pushing enemies away
      for (const e of enemies) {
        if (e.alive && dist(e.x, e.y, player.x, player.y) < 80) {
          const push = normalize(e.x - player.x, e.y - player.y);
          e.x = player.x + push.x * 100;
          e.y = player.y + push.y * 100;
          e.x = Math.max(5, Math.min(W - 5, e.x));
          e.y = Math.max(5, Math.min(H - 5, e.y));
        }
      }
      // Remove enforcer bullets
      enemies = enemies.filter(e => e.type !== 'enforcerBullet' || !e.alive);
      bullets = [];
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.innerHTML = `Score: ${score} | Wave: ${wave}<br>Press any key to restart`;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const ang = (Math.PI * 2 / count) * i + Math.random() * 0.5;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.random() * 15,
          color
        });
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Arena border glow
      ctx.strokeStyle = 'rgba(255,136,255,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(3, 3, W - 6, H - 6);

      // Grid lines for arena feel
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x < W; x += 50) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y < H; y += 50) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Electrodes
      for (const el of electrodes) {
        const pulse = Math.sin(tick * 0.1 + el.pulse) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
        ctx.shadowColor = '#0ff';
        ctx.shadowBlur = 8;
        // X shape
        ctx.save();
        ctx.translate(el.x, el.y);
        ctx.rotate(tick * 0.03 + el.pulse);
        ctx.fillRect(-ELECTRODE_SIZE / 2, -2, ELECTRODE_SIZE, 4);
        ctx.fillRect(-2, -ELECTRODE_SIZE / 2, 4, ELECTRODE_SIZE);
        ctx.restore();
        ctx.shadowBlur = 0;
      }

      // Humans
      for (const h of humans) {
        if (!h.alive) continue;
        ctx.fillStyle = h.type.color;
        ctx.shadowColor = h.type.color;
        ctx.shadowBlur = 8;
        // Simple stick figure
        // Head
        ctx.beginPath();
        ctx.arc(h.x, h.y - 5, 3, 0, Math.PI * 2);
        ctx.fill();
        // Body
        ctx.strokeStyle = h.type.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(h.x, h.y - 2);
        ctx.lineTo(h.x, h.y + 4);
        ctx.stroke();
        // Arms
        ctx.beginPath();
        ctx.moveTo(h.x - 4, h.y);
        ctx.lineTo(h.x + 4, h.y);
        ctx.stroke();
        // Legs
        ctx.beginPath();
        ctx.moveTo(h.x, h.y + 4);
        ctx.lineTo(h.x - 3, h.y + 8);
        ctx.moveTo(h.x, h.y + 4);
        ctx.lineTo(h.x + 3, h.y + 8);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Enemies
      for (const e of enemies) {
        if (!e.alive) continue;
        switch (e.type) {
          case 'grunt':
            ctx.fillStyle = '#f44';
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 6;
            ctx.fillRect(e.x - GRUNT_SIZE / 2, e.y - GRUNT_SIZE / 2, GRUNT_SIZE, GRUNT_SIZE);
            ctx.shadowBlur = 0;
            break;

          case 'hulk':
            ctx.fillStyle = '#4a4';
            ctx.shadowColor = '#4a4';
            ctx.shadowBlur = 10;
            // Big blocky shape
            ctx.fillRect(e.x - HULK_SIZE / 2, e.y - HULK_SIZE / 2, HULK_SIZE, HULK_SIZE);
            // Inner detail
            ctx.fillStyle = '#282';
            ctx.fillRect(e.x - HULK_SIZE / 4, e.y - HULK_SIZE / 4, HULK_SIZE / 2, HULK_SIZE / 2);
            ctx.shadowBlur = 0;
            break;

          case 'brain':
            ctx.fillStyle = '#f0f';
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(e.x, e.y, BRAIN_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();
            // Brain detail
            ctx.strokeStyle = '#a0a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(e.x, e.y, BRAIN_SIZE / 3, 0, Math.PI);
            ctx.stroke();
            ctx.shadowBlur = 0;
            break;

          case 'spheroid':
            const sPhase = Math.sin(tick * 0.05) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(68, 170, 255, ${sPhase})`;
            ctx.shadowColor = '#4af';
            ctx.shadowBlur = 12;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, SPHEROID_SIZE / 2, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(e.x, e.y, SPHEROID_SIZE / 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            break;

          case 'enforcer':
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 6;
            // Diamond shape
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - ENFORCER_SIZE / 2);
            ctx.lineTo(e.x + ENFORCER_SIZE / 2, e.y);
            ctx.lineTo(e.x, e.y + ENFORCER_SIZE / 2);
            ctx.lineTo(e.x - ENFORCER_SIZE / 2, e.y);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            break;

          case 'enforcerBullet':
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            break;

          case 'prog':
            ctx.fillStyle = '#f80';
            ctx.shadowColor = '#f80';
            ctx.shadowBlur = 6;
            // Corrupted human shape - angular
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - 8);
            ctx.lineTo(e.x + 6, e.y);
            ctx.lineTo(e.x + 3, e.y + 8);
            ctx.lineTo(e.x - 3, e.y + 8);
            ctx.lineTo(e.x - 6, e.y);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            break;
        }
      }

      // Player
      ctx.fillStyle = '#f8f';
      ctx.shadowColor = '#f8f';
      ctx.shadowBlur = 12;
      // Draw player as a small figure
      ctx.beginPath();
      ctx.arc(player.x, player.y, PLAYER_SIZE / 2, 0, Math.PI * 2);
      ctx.fill();
      // Inner core
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(player.x, player.y, PLAYER_SIZE / 4, 0, Math.PI * 2);
      ctx.fill();
      // Fire direction indicator
      if (fireDir.x !== 0 || fireDir.y !== 0) {
        ctx.strokeStyle = 'rgba(255,136,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(player.x + fireDir.x * 8, player.y + fireDir.y * 8);
        ctx.lineTo(player.x + fireDir.x * 16, player.y + fireDir.y * 16);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;

      // Bullets
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#f8f';
      ctx.shadowBlur = 6;
      for (const b of bullets) {
        ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
      }
      ctx.shadowBlur = 0;

      // Particles
      for (const p of particles) {
        const alpha = Math.min(1, p.life / 15);
        if (p.text) {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.font = 'bold 12px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(p.text, p.x, p.y);
          ctx.globalAlpha = 1;
        } else {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
          ctx.globalAlpha = 1;
        }
      }

      // HUD - lives indicator at bottom
      ctx.fillStyle = '#f8f';
      ctx.shadowColor = '#f8f';
      ctx.shadowBlur = 4;
      for (let i = 0; i < lives; i++) {
        ctx.beginPath();
        ctx.arc(15 + i * 18, H - 12, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    // Input handlers
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd', 'W', 'A', 'S', 'D'].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

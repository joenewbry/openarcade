<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bubble Bobble</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #4ef; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 238, 255, 0.5); }
    h1 { color: #4ef; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 238, 255, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4ef; }
    canvas {
      border: 2px solid #4ef;
      box-shadow: 0 0 20px rgba(68, 238, 255, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4ef;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BUBBLE BOBBLE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="520"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:520px;">
      <h2 id="overlayTitle">BUBBLE BOBBLE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // ---- Constants ----
    const TILE = 24;
    const COLS = W / TILE; // 20
    const ROWS = Math.floor(H / TILE); // 21 (504px used, 16px bottom margin)
    const GRAVITY = 0.35;
    const JUMP_FORCE = -7.5;
    const MOVE_SPEED = 2.8;
    const BUBBLE_SPEED = 5;
    const BUBBLE_FLOAT_SPEED = 0.4;
    const BUBBLE_LIFETIME = 480; // frames before bubble pops on its own
    const BUBBLE_TRAP_TIME = 300; // frames before enemy escapes
    const ENEMY_SPEED = 1.2;
    const PLAYER_W = 20;
    const PLAYER_H = 22;

    // ---- Game State ----
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let level = 1;
    let lives = 3;
    let keys = {};
    let player, enemies, bubbles, particles, platforms, items;
    let levelTransitionTimer = 0;
    let deathTimer = 0;
    let lastTime = 0;

    // ---- Level Definitions ----
    // Each level is an array of platform definitions: [x, y, width] in tile coords
    // Plus enemy spawn points: [x, y, type]
    const LEVEL_DEFS = [
      { // Level 1 - Simple platforms
        platforms: [
          [0, 20, 20],   // floor
          [0, 0, 20],    // ceiling
          [2, 16, 7],
          [11, 16, 7],
          [4, 12, 12],
          [1, 8, 7],
          [12, 8, 7],
          [5, 4, 10],
        ],
        enemies: [
          [3, 15, 0], [15, 15, 0],
          [8, 11, 0],
          [3, 7, 0], [15, 7, 0],
        ]
      },
      { // Level 2 - More platforms, more enemies
        platforms: [
          [0, 20, 20],
          [0, 0, 20],
          [1, 17, 5], [14, 17, 5],
          [6, 14, 8],
          [0, 11, 6], [14, 11, 6],
          [4, 8, 12],
          [1, 5, 7], [12, 5, 7],
        ],
        enemies: [
          [2, 16, 0], [16, 16, 0],
          [8, 13, 1],
          [2, 10, 0], [16, 10, 1],
          [6, 7, 1],
          [3, 4, 0],
        ]
      },
      { // Level 3 - Staircase pattern
        platforms: [
          [0, 20, 20],
          [0, 0, 20],
          [0, 17, 4], [5, 15, 4], [10, 13, 4], [15, 11, 4],
          [0, 9, 4], [5, 7, 4], [10, 5, 4], [15, 3, 4],
          [8, 17, 5],
        ],
        enemies: [
          [1, 16, 0], [7, 14, 1], [12, 12, 0], [17, 10, 1],
          [1, 8, 1], [7, 6, 0], [12, 4, 1], [17, 2, 0],
        ]
      },
      { // Level 4 - Central tower
        platforms: [
          [0, 20, 20],
          [0, 0, 20],
          [8, 17, 4],
          [8, 14, 4],
          [8, 11, 4],
          [8, 8, 4],
          [8, 5, 4],
          [1, 15, 5], [14, 15, 5],
          [1, 10, 5], [14, 10, 5],
          [1, 5, 5], [14, 5, 5],
        ],
        enemies: [
          [2, 14, 1], [16, 14, 1],
          [9, 16, 0], [9, 13, 0], [9, 10, 1],
          [2, 9, 0], [16, 9, 0],
          [2, 4, 1], [16, 4, 1],
          [9, 7, 1],
        ]
      },
      { // Level 5 - Zigzag
        platforms: [
          [0, 20, 20],
          [0, 0, 20],
          [0, 17, 14],
          [6, 14, 14],
          [0, 11, 14],
          [6, 8, 14],
          [0, 5, 14],
          [6, 2, 14],
        ],
        enemies: [
          [2, 16, 0], [8, 16, 1], [12, 16, 0],
          [8, 13, 1], [14, 13, 0], [18, 13, 1],
          [2, 10, 0], [8, 10, 1], [12, 10, 0],
          [10, 7, 1], [16, 7, 0],
          [4, 4, 1], [8, 4, 0],
        ]
      },
    ];

    // ---- Entity classes ----
    function createPlayer(x, y) {
      return {
        x: x, y: y,
        vx: 0, vy: 0,
        w: PLAYER_W, h: PLAYER_H,
        facing: 1, // 1 = right, -1 = left
        onGround: false,
        shootCooldown: 0,
        invincible: 0,
        animFrame: 0,
        animTimer: 0,
      };
    }

    function createEnemy(x, y, type) {
      return {
        x: x * TILE + 2, y: y * TILE - 2,
        vx: ENEMY_SPEED * (Math.random() < 0.5 ? 1 : -1),
        vy: 0,
        w: 18, h: 20,
        type: type, // 0 = normal (green), 1 = fast (purple)
        alive: true,
        trapped: false,
        trapTimer: 0,
        bubbleX: 0, bubbleY: 0,
        onGround: false,
        facing: 1,
        animFrame: 0,
        animTimer: 0,
        angryFlash: 0,
        speed: type === 1 ? ENEMY_SPEED * 1.4 : ENEMY_SPEED,
      };
    }

    function createBubble(x, y, dir) {
      return {
        x: x, y: y,
        vx: BUBBLE_SPEED * dir,
        vy: 0,
        radius: 10,
        age: 0,
        floating: false,
        popping: false,
        popTimer: 0,
      };
    }

    function createItem(x, y, type) {
      return {
        x: x, y: y,
        vy: 0,
        w: 16, h: 16,
        type: type, // 'food1', 'food2', 'food3'
        lifetime: 600,
        onGround: false,
      };
    }

    function createParticle(x, y, color) {
      return {
        x: x, y: y,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4 - 2,
        life: 30 + Math.random() * 20,
        maxLife: 50,
        color: color,
        size: 2 + Math.random() * 3,
      };
    }

    // ---- Build level ----
    function buildLevel(n) {
      const def = LEVEL_DEFS[(n - 1) % LEVEL_DEFS.length];
      const difficultyMult = 1 + Math.floor((n - 1) / LEVEL_DEFS.length) * 0.3;

      // Build solid tile map
      platforms = [];
      for (const [tx, ty, tw] of def.platforms) {
        platforms.push({ x: tx * TILE, y: ty * TILE, w: tw * TILE, h: TILE });
      }

      // Add walls (left and right columns)
      for (let r = 0; r < ROWS + 1; r++) {
        // Left wall - thin
        platforms.push({ x: -TILE, y: r * TILE, w: TILE, h: TILE });
        // Right wall - thin
        platforms.push({ x: W, y: r * TILE, w: TILE, h: TILE });
      }

      enemies = [];
      for (const [ex, ey, etype] of def.enemies) {
        const e = createEnemy(ex, ey, etype);
        e.speed *= difficultyMult;
        enemies.push(e);
      }

      bubbles = [];
      items = [];
      particles = [];
    }

    // ---- Physics helpers ----
    function rectCollide(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x &&
             a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function circRectCollide(cx, cy, cr, rx, ry, rw, rh) {
      const nearX = Math.max(rx, Math.min(cx, rx + rw));
      const nearY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - nearX, dy = cy - nearY;
      return dx * dx + dy * dy <= cr * cr;
    }

    function applyGravity(entity, dt) {
      entity.vy += GRAVITY;
      entity.y += entity.vy;
      entity.x += entity.vx;

      // Wrap horizontally
      if (entity.x > W + 8) entity.x = -entity.w - 4;
      if (entity.x + entity.w < -8) entity.x = W + 4;

      // Platform collision
      entity.onGround = false;
      for (const p of platforms) {
        if (rectCollide(entity, p)) {
          // Determine penetration from each side
          const overlapLeft = (entity.x + entity.w) - p.x;
          const overlapRight = (p.x + p.w) - entity.x;
          const overlapTop = (entity.y + entity.h) - p.y;
          const overlapBottom = (p.y + p.h) - entity.y;

          const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

          if (minOverlap === overlapTop && entity.vy >= 0) {
            entity.y = p.y - entity.h;
            entity.vy = 0;
            entity.onGround = true;
          } else if (minOverlap === overlapBottom && entity.vy < 0) {
            entity.y = p.y + p.h;
            entity.vy = 0;
          } else if (minOverlap === overlapLeft) {
            entity.x = p.x - entity.w;
            if (entity.vx > 0) entity.vx = -entity.vx;
          } else if (minOverlap === overlapRight) {
            entity.x = p.x + p.w;
            if (entity.vx < 0) entity.vx = -entity.vx;
          }
        }
      }
    }

    // ---- Init / Start / GameOver ----
    function init() {
      score = 0;
      level = 1;
      lives = 3;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BUBBLE BOBBLE';
      overlayText.textContent = 'Arrow keys to move, Up to jump, Space to shoot\nPress SPACE to start';
      player = createPlayer(W / 2 - PLAYER_W / 2, H - TILE * 2 - PLAYER_H);
      buildLevel(1);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function nextLevel() {
      level++;
      levelEl.textContent = level;
      // Bonus points for clearing level
      score += 100 * level;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
      // Reset player position
      player.x = W / 2 - PLAYER_W / 2;
      player.y = H - TILE * 2 - PLAYER_H;
      player.vx = 0;
      player.vy = 0;
      buildLevel(level);
      levelTransitionTimer = 90;
    }

    function playerDie() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
        return;
      }
      // Respawn
      player.x = W / 2 - PLAYER_W / 2;
      player.y = H - TILE * 2 - PLAYER_H;
      player.vx = 0;
      player.vy = 0;
      player.invincible = 120;
      deathTimer = 30;
      // Spawn death particles
      for (let i = 0; i < 12; i++) {
        particles.push(createParticle(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#4ef'));
      }
    }

    // ---- Update ----
    function update() {
      if (levelTransitionTimer > 0) {
        levelTransitionTimer--;
        return;
      }
      if (deathTimer > 0) {
        deathTimer--;
        return;
      }

      // ---- Player movement ----
      if (keys['ArrowLeft']) {
        player.vx = -MOVE_SPEED;
        player.facing = -1;
      } else if (keys['ArrowRight']) {
        player.vx = MOVE_SPEED;
        player.facing = 1;
      } else {
        player.vx *= 0.7;
        if (Math.abs(player.vx) < 0.2) player.vx = 0;
      }

      if (keys['ArrowUp'] && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
      }

      applyGravity(player);

      // Player animation
      player.animTimer++;
      if (player.animTimer > 8) {
        player.animTimer = 0;
        player.animFrame = (player.animFrame + 1) % 2;
      }

      if (player.invincible > 0) player.invincible--;
      if (player.shootCooldown > 0) player.shootCooldown--;

      // ---- Shoot bubble ----
      if (keys[' '] && player.shootCooldown <= 0) {
        const bx = player.x + (player.facing > 0 ? PLAYER_W : -4);
        const by = player.y + PLAYER_H / 2 - 5;
        bubbles.push(createBubble(bx, by, player.facing));
        player.shootCooldown = 15;
      }

      // ---- Update bubbles ----
      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        b.age++;

        if (b.popping) {
          b.popTimer++;
          if (b.popTimer > 10) {
            bubbles.splice(i, 1);
          }
          continue;
        }

        if (!b.floating) {
          // Traveling phase
          b.x += b.vx;
          b.vx *= 0.96;
          if (Math.abs(b.vx) < 0.5) {
            b.floating = true;
            b.vx = 0;
          }
          // Bounce off walls
          if (b.x - b.radius < 0) { b.x = b.radius; b.vx = Math.abs(b.vx); }
          if (b.x + b.radius > W) { b.x = W - b.radius; b.vx = -Math.abs(b.vx); }
        } else {
          // Floating phase - drift upward with slight wobble
          b.y -= BUBBLE_FLOAT_SPEED;
          b.x += Math.sin(b.age * 0.05) * 0.3;
          // Bounce off ceiling
          if (b.y - b.radius < TILE) {
            b.y = TILE + b.radius;
            b.x += (Math.random() - 0.5) * 2;
          }
          // Wrap horizontally
          if (b.x < -b.radius) b.x = W + b.radius;
          if (b.x > W + b.radius) b.x = -b.radius;
        }

        // Expire
        if (b.age > BUBBLE_LIFETIME) {
          b.popping = true;
          b.popTimer = 0;
        }
      }

      // ---- Update enemies ----
      let aliveCount = 0;
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e.alive) continue;

        if (e.trapped) {
          // Float in bubble
          e.trapTimer++;
          e.bubbleY -= BUBBLE_FLOAT_SPEED;
          e.bubbleX += Math.sin(e.trapTimer * 0.05) * 0.3;
          if (e.bubbleY - 12 < TILE) {
            e.bubbleY = TILE + 12;
          }
          // Wrap
          if (e.bubbleX < -12) e.bubbleX = W + 12;
          if (e.bubbleX > W + 12) e.bubbleX = -12;

          // Flash when about to escape
          if (e.trapTimer > BUBBLE_TRAP_TIME * 0.7) {
            e.angryFlash = (e.angryFlash + 1) % 10;
          }

          // Escape
          if (e.trapTimer > BUBBLE_TRAP_TIME) {
            e.trapped = false;
            e.x = e.bubbleX - e.w / 2;
            e.y = e.bubbleY - e.h / 2;
            e.vy = 0;
            e.speed *= 1.2; // Faster after escaping
            e.angryFlash = 0;
            // Pop particles
            for (let p = 0; p < 6; p++) {
              particles.push(createParticle(e.bubbleX, e.bubbleY, '#f44'));
            }
          }

          // Check if player pops this trapped enemy
          const dx = (player.x + PLAYER_W / 2) - e.bubbleX;
          const dy = (player.y + PLAYER_H / 2) - e.bubbleY;
          if (Math.sqrt(dx * dx + dy * dy) < 22) {
            // Pop! Score!
            e.alive = false;
            const pts = (e.type + 1) * 100;
            score += pts;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            // Spawn particles
            for (let p = 0; p < 10; p++) {
              particles.push(createParticle(e.bubbleX, e.bubbleY, e.type === 0 ? '#0f8' : '#a4f'));
            }
            // Spawn food item
            const foodTypes = ['food1', 'food2', 'food3'];
            items.push(createItem(e.bubbleX - 8, e.bubbleY - 8, foodTypes[Math.floor(Math.random() * foodTypes.length)]));
            // Show score popup
            particles.push({
              x: e.bubbleX, y: e.bubbleY - 10,
              vx: 0, vy: -1,
              life: 40, maxLife: 40,
              color: '#ff0',
              size: 0,
              text: '+' + pts,
            });
            continue;
          }

          aliveCount++;
          continue;
        }

        // Normal enemy AI
        e.animTimer++;
        if (e.animTimer > 10) {
          e.animTimer = 0;
          e.animFrame = (e.animFrame + 1) % 2;
        }

        // Simple AI: walk, turn at edges or walls, jump occasionally
        e.vx = e.speed * (e.facing);

        applyGravity(e);

        // Turn around at level edges or randomly
        if (e.x <= 2 || e.x + e.w >= W - 2) {
          e.facing = -e.facing;
        }
        // Random direction change
        if (Math.random() < 0.01) {
          e.facing = -e.facing;
        }
        // Random jump
        if (e.onGround && Math.random() < 0.015) {
          e.vy = JUMP_FORCE * 0.8;
        }

        // Check if hit by a bubble (not floating yet = still moving fast)
        for (let j = bubbles.length - 1; j >= 0; j--) {
          const b = bubbles[j];
          if (b.popping || b.floating && b.age > 30) continue; // only active bubbles trap
          if (b.age > 60 && b.floating) continue;
          const dx = (e.x + e.w / 2) - b.x;
          const dy = (e.y + e.h / 2) - b.y;
          if (Math.sqrt(dx * dx + dy * dy) < b.radius + 10) {
            // Trap enemy in bubble
            e.trapped = true;
            e.trapTimer = 0;
            e.bubbleX = e.x + e.w / 2;
            e.bubbleY = e.y + e.h / 2;
            e.angryFlash = 0;
            // Remove the bubble
            bubbles.splice(j, 1);
            // Particles
            for (let p = 0; p < 6; p++) {
              particles.push(createParticle(e.bubbleX, e.bubbleY, '#4ef'));
            }
            break;
          }
        }

        // Check if enemy touches player
        if (!e.trapped && player.invincible <= 0) {
          if (rectCollide(player, e)) {
            playerDie();
            return;
          }
        }

        aliveCount++;
      }

      // ---- Update items ----
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        it.lifetime--;
        if (it.lifetime <= 0) {
          items.splice(i, 1);
          continue;
        }
        // Gravity for items
        it.vy += GRAVITY * 0.5;
        it.y += it.vy;
        // Platform collision for items
        it.onGround = false;
        for (const p of platforms) {
          if (it.x < p.x + p.w && it.x + it.w > p.x &&
              it.y < p.y + p.h && it.y + it.h > p.y) {
            if (it.vy > 0) {
              it.y = p.y - it.h;
              it.vy = 0;
              it.onGround = true;
            }
          }
        }
        // Player pickup
        if (rectCollide(player, it)) {
          let pts = 0;
          if (it.type === 'food1') pts = 50;
          else if (it.type === 'food2') pts = 100;
          else pts = 200;
          score += pts;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          particles.push({
            x: it.x + 8, y: it.y - 5,
            vx: 0, vy: -1,
            life: 30, maxLife: 30,
            color: '#ff0',
            size: 0,
            text: '+' + pts,
          });
          items.splice(i, 1);
        }
      }

      // ---- Update particles ----
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // ---- Check level clear ----
      if (aliveCount === 0 && enemies.length > 0 && levelTransitionTimer <= 0) {
        nextLevel();
      }

      // ---- Update gameData for ML ----
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerFacing: player.facing,
        enemies: enemies.filter(e => e.alive).map(e => ({
          x: e.trapped ? e.bubbleX : e.x,
          y: e.trapped ? e.bubbleY : e.y,
          trapped: e.trapped,
          type: e.type,
        })),
        bubbleCount: bubbles.length,
        level: level,
        lives: lives,
      };
    }

    // ---- Drawing ----
    function drawDragon(x, y, facing, frame, invincible) {
      if (invincible > 0 && Math.floor(invincible / 4) % 2 === 0) return;

      ctx.save();
      ctx.translate(x + PLAYER_W / 2, y + PLAYER_H / 2);
      if (facing < 0) ctx.scale(-1, 1);
      ctx.translate(-PLAYER_W / 2, -PLAYER_H / 2);

      // Body
      ctx.fillStyle = '#4ef';
      ctx.shadowColor = '#4ef';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.ellipse(PLAYER_W / 2, PLAYER_H / 2 + 2, 9, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Belly
      ctx.fillStyle = '#aff';
      ctx.beginPath();
      ctx.ellipse(PLAYER_W / 2 + 1, PLAYER_H / 2 + 4, 5, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Head
      ctx.fillStyle = '#4ef';
      ctx.beginPath();
      ctx.arc(PLAYER_W / 2 + 3, PLAYER_H / 2 - 7, 7, 0, Math.PI * 2);
      ctx.fill();

      // Eye
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(PLAYER_W / 2 + 6, PLAYER_H / 2 - 8, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(PLAYER_W / 2 + 7, PLAYER_H / 2 - 8, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Snout
      ctx.fillStyle = '#3bd';
      ctx.beginPath();
      ctx.ellipse(PLAYER_W / 2 + 9, PLAYER_H / 2 - 5, 3, 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Legs (animate)
      ctx.fillStyle = '#4ef';
      const legOffset = frame === 0 ? 0 : 2;
      ctx.fillRect(PLAYER_W / 2 - 5, PLAYER_H - 4 + legOffset, 4, 4);
      ctx.fillRect(PLAYER_W / 2 + 2, PLAYER_H - 4 - legOffset, 4, 4);

      // Spines on back
      ctx.fillStyle = '#0bc';
      for (let s = 0; s < 3; s++) {
        ctx.beginPath();
        const sx = PLAYER_W / 2 - 6 - s * 2;
        const sy = PLAYER_H / 2 - 4 + s * 4;
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx - 4, sy - 3);
        ctx.lineTo(sx, sy + 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawEnemy(e) {
      if (!e.alive) return;

      if (e.trapped) {
        // Draw bubble with enemy inside
        const bx = e.bubbleX, by = e.bubbleY;

        // Bubble
        ctx.beginPath();
        ctx.arc(bx, by, 14, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(68, 238, 255, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = 'rgba(68, 238, 255, 0.1)';
        ctx.fill();

        // Highlight on bubble
        ctx.beginPath();
        ctx.arc(bx - 4, by - 5, 3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();

        // Enemy inside (small, angry)
        if (e.angryFlash < 5 || e.trapTimer < BUBBLE_TRAP_TIME * 0.7) {
          const col = e.type === 0 ? '#0f8' : '#a4f';
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.arc(bx, by, 6, 0, Math.PI * 2);
          ctx.fill();
          // Angry eyes
          ctx.fillStyle = '#f00';
          ctx.fillRect(bx - 3, by - 3, 2, 2);
          ctx.fillRect(bx + 1, by - 3, 2, 2);
        }
        return;
      }

      ctx.save();
      ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
      if (e.facing < 0) ctx.scale(-1, 1);
      ctx.translate(-e.w / 2, -e.h / 2);

      const col = e.type === 0 ? '#0f8' : '#a4f';
      const colDark = e.type === 0 ? '#0a6' : '#63a';

      // Body
      ctx.fillStyle = col;
      ctx.shadowColor = col;
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.ellipse(e.w / 2, e.h / 2 + 1, 8, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(e.w / 2 + 2, e.h / 2 - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(e.w / 2 + 3, e.h / 2 - 4, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Second eye (peeking from front)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(e.w / 2 - 2, e.h / 2 - 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(e.w / 2 - 1, e.h / 2 - 4, 1.2, 0, Math.PI * 2);
      ctx.fill();

      // Legs
      ctx.fillStyle = colDark;
      const lo = e.animFrame === 0 ? 0 : 2;
      ctx.fillRect(e.w / 2 - 5, e.h - 3 + lo, 3, 3);
      ctx.fillRect(e.w / 2 + 2, e.h - 3 - lo, 3, 3);

      // Type-specific features
      if (e.type === 1) {
        // Horns for fast enemy
        ctx.fillStyle = '#f4a';
        ctx.beginPath();
        ctx.moveTo(e.w / 2 - 3, e.h / 2 - 8);
        ctx.lineTo(e.w / 2 - 5, e.h / 2 - 14);
        ctx.lineTo(e.w / 2 - 1, e.h / 2 - 8);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(e.w / 2 + 3, e.h / 2 - 8);
        ctx.lineTo(e.w / 2 + 5, e.h / 2 - 14);
        ctx.lineTo(e.w / 2 + 7, e.h / 2 - 8);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawBubble(b) {
      if (b.popping) {
        // Pop animation â€” expanding ring
        const alpha = 1 - b.popTimer / 10;
        const r = b.radius + b.popTimer * 3;
        const hue = (b.age * 3) % 360;
        ctx.beginPath();
        ctx.arc(b.x, b.y, r, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(${hue}, 100%, 75%, ${alpha * 0.6})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        return;
      }

      // Rainbow shimmer: hue shifts with bubble age
      const hue = (b.age * 3) % 360;
      const hue2 = (hue + 60) % 360;

      // Main bubble fill
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${b.floating ? 0.1 : 0.18})`;
      ctx.fill();

      // Rainbow stroke
      ctx.strokeStyle = `hsla(${hue}, 100%, 75%, ${b.floating ? 0.5 : 0.85})`;
      if (!b.floating) {
        ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
        ctx.shadowBlur = 10;
      }
      ctx.lineWidth = 1.8;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Shimmer highlight spot (shifts position slowly)
      const shimmerAngle = b.age * 0.04;
      const hx = b.x + Math.cos(shimmerAngle) * b.radius * 0.4 - 2;
      const hy = b.y + Math.sin(shimmerAngle) * b.radius * 0.4 - 2;
      ctx.beginPath();
      ctx.arc(hx, hy, b.radius * 0.25, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${hue2}, 100%, 95%, 0.5)`;
      ctx.fill();

      // Static highlight top-left
      ctx.beginPath();
      ctx.arc(b.x - 3, b.y - 3, b.radius * 0.2, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.fill();
    }

    function drawItem(it) {
      const flash = it.lifetime < 120 && Math.floor(it.lifetime / 8) % 2 === 0;
      if (flash) return;

      ctx.save();
      ctx.translate(it.x + 8, it.y + 8);

      if (it.type === 'food1') {
        // Cherry
        ctx.fillStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.arc(-2, 3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(4, 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#0a4';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-2, -2);
        ctx.quadraticCurveTo(1, -8, 4, -3);
        ctx.stroke();
      } else if (it.type === 'food2') {
        // Banana
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7, 4, -0.3, 0, Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        // Cake
        ctx.fillStyle = '#f8a';
        ctx.shadowColor = '#f8a';
        ctx.shadowBlur = 5;
        ctx.fillRect(-6, -2, 12, 8);
        ctx.fillStyle = '#fcc';
        ctx.fillRect(-6, -2, 12, 3);
        ctx.shadowBlur = 0;
        // Cherry on top
        ctx.fillStyle = '#f22';
        ctx.beginPath();
        ctx.arc(0, -4, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Platform slide-in: during level transition, platforms slide in from bottom
      const slideY = levelTransitionTimer > 0 ? Math.round((levelTransitionTimer / 90) * H) : 0;

      // Draw platforms
      for (const p of platforms) {
        if (p.x < 0 || p.x >= W) continue; // Skip wall platforms for drawing
        const py = p.y + slideY;
        // Main platform color
        ctx.fillStyle = '#16213e';
        ctx.fillRect(p.x, py, p.w, p.h);
        // Top edge highlight
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(p.x, py, p.w, 2);
        // Bottom edge
        ctx.fillStyle = '#0a1a30';
        ctx.fillRect(p.x, py + p.h - 2, p.w, 2);

        // Brick pattern
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 0.5;
        for (let bx = p.x; bx < p.x + p.w; bx += TILE / 2) {
          ctx.beginPath();
          ctx.moveTo(bx, py);
          ctx.lineTo(bx, py + p.h);
          ctx.stroke();
        }
      }

      // Draw left/right walls as glowing borders
      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, 2, H);
      ctx.fillRect(W - 2, 0, 2, H);

      // Draw items
      for (const it of items) {
        drawItem(it);
      }

      // Draw bubbles
      for (const b of bubbles) {
        drawBubble(b);
      }

      // Draw enemies
      for (const e of enemies) {
        drawEnemy(e);
      }

      // Draw player
      drawDragon(player.x, player.y, player.facing, player.animFrame, player.invincible);

      // Draw particles
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        if (p.text) {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.font = 'bold 12px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText(p.text, p.x, p.y);
          ctx.globalAlpha = 1;
        } else {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = alpha;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          ctx.globalAlpha = 1;
        }
      }

      // Level transition message
      if (levelTransitionTimer > 0) {
        ctx.fillStyle = '#4ef';
        ctx.shadowColor = '#4ef';
        ctx.shadowBlur = 15;
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL ' + level, W / 2, H / 2 - 10);
        ctx.shadowBlur = 0;
        ctx.font = '14px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Get ready!', W / 2, H / 2 + 20);
      }

      // Level indicator (small, top)
      if (gameState === 'playing') {
        ctx.fillStyle = 'rgba(68, 238, 255, 0.3)';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LVL ' + level, W / 2, 14);
      }
    }

    // ---- Game Loop ----
    function loop(timestamp) {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Input ----
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2048</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #f84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 68, 0.4); }
    h1 { color: #f84; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f84; }
    canvas {
      border: 2px solid #f84;
      box-shadow: 0 0 20px rgba(255, 136, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>2048</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:480px;">
      <h2 id="overlayTitle">2048</h2>
      <p id="overlayText">Press any arrow key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const GRID = 4;
    const PAD = 12;          // padding around the grid
    const GAP = 10;          // gap between tiles
    const BOARD_Y = 60;      // top offset for the board (leave room for in-canvas score area)
    const BOARD_SIZE = W - PAD * 2;
    const CELL = (BOARD_SIZE - GAP * (GRID + 1)) / GRID;

    // Tile colors - neon palette on dark background
    const TILE_COLORS = {
      2:    { bg: '#1e2a4a', fg: '#8899bb', glow: '#446' },
      4:    { bg: '#1e3050', fg: '#99aacc', glow: '#558' },
      8:    { bg: '#2a2040', fg: '#cc88ff', glow: '#a4f' },
      16:   { bg: '#302050', fg: '#dd77ff', glow: '#b4f' },
      32:   { bg: '#352060', fg: '#ff66cc', glow: '#f4a' },
      64:   { bg: '#402040', fg: '#ff4488', glow: '#f48' },
      128:  { bg: '#403020', fg: '#ffaa44', glow: '#fa4' },
      256:  { bg: '#504020', fg: '#ffcc22', glow: '#fc2' },
      512:  { bg: '#504010', fg: '#ffdd00', glow: '#fd0' },
      1024: { bg: '#553800', fg: '#ffee44', glow: '#fe4' },
      2048: { bg: '#604000', fg: '#ff8844', glow: '#f84' },
      4096: { bg: '#600020', fg: '#ff4466', glow: '#f46' },
      8192: { bg: '#400040', fg: '#ff22ff', glow: '#f2f' },
    };

    function getTileColor(val) {
      if (TILE_COLORS[val]) return TILE_COLORS[val];
      // Fallback for very high values
      return { bg: '#500050', fg: '#ff88ff', glow: '#f8f' };
    }

    let score, best = 0, gameState;
    let grid;
    let moved;   // track whether a move actually changed the board

    // Animation state
    let animating = false;
    let animTiles = [];  // tiles in motion: {fromR, fromC, toR, toC, val, merged, progress}
    let animStartTime = 0;
    const ANIM_DURATION = 100; // ms
    let spawnTile = null;  // {r, c, val, progress} for the newly spawned tile
    let spawnStartTime = 0;
    const SPAWN_DURATION = 120; // ms

    function init() {
      grid = Array.from({ length: GRID }, () => Array(GRID).fill(0));
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = '2048';
      overlayText.textContent = 'Press any arrow key to start';
      animating = false;
      animTiles = [];
      spawnTile = null;

      // Place two initial tiles
      addRandomTile();
      addRandomTile();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      draw();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function addRandomTile() {
      const empty = [];
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c] === 0) empty.push({ r, c });
        }
      }
      if (empty.length === 0) return null;
      const cell = empty[Math.floor(Math.random() * empty.length)];
      const val = Math.random() < 0.9 ? 2 : 4;
      grid[cell.r][cell.c] = val;
      return { r: cell.r, c: cell.c, val };
    }

    function canMove() {
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c] === 0) return true;
          if (c < GRID - 1 && grid[r][c] === grid[r][c + 1]) return true;
          if (r < GRID - 1 && grid[r][c] === grid[r + 1][c]) return true;
        }
      }
      return false;
    }

    // Slide a single row to the left, returning {row, mergeScore, moves}
    // moves: array of {fromIdx, toIdx, val, merged}
    function slideRow(row) {
      const len = row.length;
      let moves = [];
      let result = [];
      let mergeScore = 0;

      // First, collect non-zero values with their original positions
      let nonZero = [];
      for (let i = 0; i < len; i++) {
        if (row[i] !== 0) nonZero.push({ val: row[i], origIdx: i });
      }

      // Process merges
      let i = 0;
      while (i < nonZero.length) {
        if (i + 1 < nonZero.length && nonZero[i].val === nonZero[i + 1].val) {
          const merged = nonZero[i].val * 2;
          const destIdx = result.length;
          result.push(merged);
          mergeScore += merged;
          moves.push({ fromIdx: nonZero[i].origIdx, toIdx: destIdx, val: nonZero[i].val, merged: true });
          moves.push({ fromIdx: nonZero[i + 1].origIdx, toIdx: destIdx, val: nonZero[i + 1].val, merged: true });
          i += 2;
        } else {
          const destIdx = result.length;
          result.push(nonZero[i].val);
          moves.push({ fromIdx: nonZero[i].origIdx, toIdx: destIdx, val: nonZero[i].val, merged: false });
          i++;
        }
      }

      // Pad with zeros
      while (result.length < len) result.push(0);

      return { row: result, mergeScore, moves };
    }

    // Apply a move in the given direction. Returns true if the board changed.
    function doMove(dir) {
      let totalScore = 0;
      let changed = false;
      let allMoves = []; // collect animation data

      if (dir === 'left') {
        for (let r = 0; r < GRID; r++) {
          const { row, mergeScore, moves } = slideRow(grid[r]);
          moves.forEach(m => {
            if (m.fromIdx !== m.toIdx || m.merged) changed = true;
            allMoves.push({ fromR: r, fromC: m.fromIdx, toR: r, toC: m.toIdx, val: m.val, merged: m.merged });
          });
          totalScore += mergeScore;
          grid[r] = row;
        }
      } else if (dir === 'right') {
        for (let r = 0; r < GRID; r++) {
          const reversed = [...grid[r]].reverse();
          const { row, mergeScore, moves } = slideRow(reversed);
          moves.forEach(m => {
            const fromC = GRID - 1 - m.fromIdx;
            const toC = GRID - 1 - m.toIdx;
            if (fromC !== toC || m.merged) changed = true;
            allMoves.push({ fromR: r, fromC: fromC, toR: r, toC: toC, val: m.val, merged: m.merged });
          });
          totalScore += mergeScore;
          grid[r] = row.reverse();
        }
      } else if (dir === 'up') {
        for (let c = 0; c < GRID; c++) {
          const col = [];
          for (let r = 0; r < GRID; r++) col.push(grid[r][c]);
          const { row, mergeScore, moves } = slideRow(col);
          moves.forEach(m => {
            if (m.fromIdx !== m.toIdx || m.merged) changed = true;
            allMoves.push({ fromR: m.fromIdx, fromC: c, toR: m.toIdx, toC: c, val: m.val, merged: m.merged });
          });
          totalScore += mergeScore;
          for (let r = 0; r < GRID; r++) grid[r][c] = row[r];
        }
      } else if (dir === 'down') {
        for (let c = 0; c < GRID; c++) {
          const col = [];
          for (let r = GRID - 1; r >= 0; r--) col.push(grid[r][c]);
          const { row, mergeScore, moves } = slideRow(col);
          moves.forEach(m => {
            const fromR = GRID - 1 - m.fromIdx;
            const toR = GRID - 1 - m.toIdx;
            if (fromR !== toR || m.merged) changed = true;
            allMoves.push({ fromR: fromR, fromC: c, toR: toR, toC: c, val: m.val, merged: m.merged });
          });
          totalScore += mergeScore;
          const reversed = row.reverse();
          for (let r = 0; r < GRID; r++) grid[r][c] = reversed[r];
        }
      }

      if (changed) {
        score += totalScore;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
      }

      return { changed, allMoves };
    }

    function handleMove(dir) {
      if (animating) return;

      const { changed, allMoves } = doMove(dir);
      if (!changed) return;

      // Start slide animation
      animTiles = allMoves;
      animating = true;
      animStartTime = performance.now();

      requestAnimationFrame(animateSlide);
    }

    function animateSlide(now) {
      const elapsed = now - animStartTime;
      const t = Math.min(elapsed / ANIM_DURATION, 1);
      const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // ease in-out quad

      drawAnimFrame(ease);

      if (t < 1) {
        requestAnimationFrame(animateSlide);
      } else {
        // Animation done - spawn new tile
        animating = false;
        animTiles = [];

        const spawned = addRandomTile();
        if (spawned) {
          spawnTile = { r: spawned.r, c: spawned.c, val: spawned.val };
          spawnStartTime = performance.now();
          requestAnimationFrame(animateSpawn);
        } else {
          draw();
          if (!canMove()) gameOver();
        }
      }
    }

    function animateSpawn(now) {
      const elapsed = now - spawnStartTime;
      const t = Math.min(elapsed / SPAWN_DURATION, 1);
      // Overshoot ease for pop effect
      const ease = t < 1 ? 1 - Math.pow(1 - t, 3) : 1;

      draw(ease);

      if (t < 1) {
        requestAnimationFrame(animateSpawn);
      } else {
        spawnTile = null;
        draw();
        if (!canMove()) gameOver();
      }
    }

    // Get pixel position for grid cell
    function cellX(c) {
      return PAD + GAP + c * (CELL + GAP);
    }

    function cellY(r) {
      return BOARD_Y + GAP + r * (CELL + GAP);
    }

    function drawRoundRect(x, y, w, h, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function drawTile(x, y, val, scale) {
      if (val === 0) return;
      scale = scale || 1;

      const tc = getTileColor(val);
      const cx = x + CELL / 2;
      const cy = y + CELL / 2;
      const sz = CELL * scale;
      const tx = cx - sz / 2;
      const ty = cy - sz / 2;

      // Glow for higher values
      const glowIntensity = Math.min(Math.log2(val) - 1, 11);
      if (glowIntensity > 3) {
        ctx.shadowColor = tc.glow;
        ctx.shadowBlur = glowIntensity * 2;
      }

      // Background
      drawRoundRect(tx, ty, sz, sz, 6 * scale);
      ctx.fillStyle = tc.bg;
      ctx.fill();

      // Border
      ctx.strokeStyle = tc.glow;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Number
      const text = String(val);
      let fontSize;
      if (val < 100) fontSize = 32 * scale;
      else if (val < 1000) fontSize = 26 * scale;
      else if (val < 10000) fontSize = 20 * scale;
      else fontSize = 16 * scale;

      ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Text glow
      if (glowIntensity > 2) {
        ctx.shadowColor = tc.glow;
        ctx.shadowBlur = 8;
      }
      ctx.fillStyle = tc.fg;
      ctx.fillText(text, cx, cy + 1);
      ctx.shadowBlur = 0;
    }

    function drawBoard() {
      // Board background
      drawRoundRect(PAD, BOARD_Y, BOARD_SIZE, BOARD_SIZE + GAP, 8);
      ctx.fillStyle = '#0d1525';
      ctx.fill();
      ctx.strokeStyle = '#1a2a45';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Empty cell slots
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          const x = cellX(c);
          const y = cellY(r);
          drawRoundRect(x, y, CELL, CELL, 6);
          ctx.fillStyle = '#141e35';
          ctx.fill();
        }
      }
    }

    function drawAnimFrame(t) {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // In-canvas title area
      drawCanvasHeader();

      // Board background + empty slots
      drawBoard();

      // Track which destination cells have a merged tile (draw merged value on top)
      const mergedAt = {};
      animTiles.forEach(m => {
        if (m.merged) {
          const key = m.toR + ',' + m.toC;
          // The merged value is double the tile value
          mergedAt[key] = m.val * 2;
        }
      });

      // Draw moving tiles
      animTiles.forEach(m => {
        const fromX = cellX(m.fromC);
        const fromY = cellY(m.fromR);
        const toX = cellX(m.toC);
        const toY = cellY(m.toR);

        const x = fromX + (toX - fromX) * t;
        const y = fromY + (toY - fromY) * t;

        // If this tile merges, show original value while sliding
        drawTile(x, y, m.val, 1);
      });

      // For merged cells, draw the merged value on top at full t (it pops in)
      if (t >= 0.8) {
        const popT = (t - 0.8) / 0.2;
        const popScale = 1 + 0.15 * Math.sin(popT * Math.PI);
        for (const key in mergedAt) {
          const [r, c] = key.split(',').map(Number);
          drawTile(cellX(c), cellY(r), mergedAt[key], popScale);
        }
      }
    }

    function drawCanvasHeader() {
      // "2048" label at top of canvas
      ctx.font = "bold 28px 'Courier New', monospace";
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f84';
      ctx.shadowColor = '#f84';
      ctx.shadowBlur = 10;
      ctx.fillText('2048', PAD, 30);
      ctx.shadowBlur = 0;

      // Score display on canvas
      ctx.font = "16px 'Courier New', monospace";
      ctx.textAlign = 'right';
      ctx.fillStyle = '#888';
      ctx.fillText('SCORE', W - PAD, 20);
      ctx.font = "bold 20px 'Courier New', monospace";
      ctx.fillStyle = '#f84';
      ctx.fillText(String(score), W - PAD, 42);
    }

    function draw(spawnProgress) {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // In-canvas header
      drawCanvasHeader();

      // Board background + empty slots
      drawBoard();

      // Draw all tiles from grid
      for (let r = 0; r < GRID; r++) {
        for (let c = 0; c < GRID; c++) {
          if (grid[r][c] === 0) continue;

          // Check if this is the spawn tile
          if (spawnTile && spawnTile.r === r && spawnTile.c === c && spawnProgress !== undefined && spawnProgress < 1) {
            const scale = spawnProgress * 1.0;
            drawTile(cellX(c), cellY(r), grid[r][c], Math.max(0.01, scale));
          } else {
            drawTile(cellX(c), cellY(r), grid[r][c], 1);
          }
        }
      }
    }

    // Expose game data for potential ML use
    function updateGameData() {
      window.gameData = {
        grid: grid.map(row => [...row]),
        score: score,
        gameState: gameState
      };
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
          start();
          // Process this first move
          const dirMap = {
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'ArrowLeft': 'left',
            'ArrowRight': 'right'
          };
          handleMove(dirMap[e.key]);
          updateGameData();
        } else if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        const dirMap = {
          'ArrowUp': 'up',
          'ArrowDown': 'down',
          'ArrowLeft': 'left',
          'ArrowRight': 'right'
        };
        if (dirMap[e.key]) {
          handleMove(dirMap[e.key]);
          updateGameData();
        }
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

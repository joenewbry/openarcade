<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raiden</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f28; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255,34,136,0.4); }
    h1 { color: #f28; font-size: 2rem; text-shadow: 0 0 15px rgba(255,34,136,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f28; }
    canvas {
      border: 2px solid #f28;
      box-shadow: 0 0 20px rgba(255,34,136,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f28;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>RAIDEN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="640"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:640px;">
      <h2 id="overlayTitle">RAIDEN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState, score, best = 0;

    // ── Constants ──────────────────────────────────────────────
    const PLAYER_SPEED = 4;
    const PLAYER_W = 28, PLAYER_H = 32;
    const FIRE_RATE_VULCAN = 6;
    const FIRE_RATE_LASER = 12;
    const FIRE_RATE_MISSILE = 20;
    const BOMB_FLASH_DURATION = 30;
    const MAX_BOMBS = 3;
    const MAX_LIVES = 3;
    const MEDAL_SCORE = 500;
    const STAGE_DURATION = 3600; // frames per stage (~60 seconds at 60fps)

    // Weapon types
    const WEAPON = { VULCAN: 0, LASER: 1, MISSILE: 2 };
    const WEAPON_COLORS = ['#f44', '#48f', '#4f4'];
    const WEAPON_NAMES = ['VULCAN', 'LASER', 'MISSILE'];

    // ── Game state variables ──────────────────────────────────
    let player, bullets, enemies, enemyBullets, particles, powerups, medals;
    let keys, tick, lives, bombs, weaponType, weaponLevel;
    let stage, stageTimer, bossActive, boss;
    let scrollY, groundObjects;
    let bombFlash, invincibleTimer, fireTimer;
    let screenShake, shakeTimer;

    // ── Utility ───────────────────────────────────────────────
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
    function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // ── Initialization ────────────────────────────────────────
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'RAIDEN';
      overlayText.textContent = 'Arrows: Move | Space: Fire | Shift/B: Bomb';
      draw();
    }

    function resetGame() {
      player = { x: W / 2 - PLAYER_W / 2, y: H - 80 };
      bullets = [];
      enemies = [];
      enemyBullets = [];
      particles = [];
      powerups = [];
      medals = [];
      keys = {};
      tick = 0;
      lives = MAX_LIVES;
      bombs = MAX_BOMBS;
      weaponType = WEAPON.VULCAN;
      weaponLevel = 1;
      stage = 1;
      stageTimer = 0;
      bossActive = false;
      boss = null;
      scrollY = 0;
      groundObjects = [];
      bombFlash = 0;
      invincibleTimer = 0;
      fireTimer = 0;
      screenShake = 0;
      shakeTimer = 0;
      score = 0;
      scoreEl.textContent = '0';

      // Seed initial ground objects
      for (let i = 0; i < 12; i++) {
        groundObjects.push(createGroundObject(rand(0, W), rand(0, H)));
      }
    }

    function start() {
      resetGame();
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Stage ${stage} -- Press any key`;
    }

    // ── Main loop ─────────────────────────────────────────────
    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ── Ground objects (scrolling terrain) ─────────────────────
    function createGroundObject(x, y) {
      const type = randInt(0, 3);
      return { x, y, type, w: type === 3 ? 40 : 20 + randInt(0, 15), h: type === 3 ? 40 : 15 + randInt(0, 10) };
    }

    function updateGround() {
      const scrollSpeed = 0.8 + stage * 0.1;
      scrollY += scrollSpeed;

      for (let i = groundObjects.length - 1; i >= 0; i--) {
        groundObjects[i].y += scrollSpeed;
        if (groundObjects[i].y > H + 50) {
          groundObjects.splice(i, 1);
        }
      }

      // Spawn new ground objects at top
      if (Math.random() < 0.02) {
        groundObjects.push(createGroundObject(rand(10, W - 50), -50));
      }
    }

    function drawGround() {
      groundObjects.forEach(g => {
        if (g.type === 3) {
          // Turret (ground enemy drawn separately)
          return;
        }
        // Terrain patches
        ctx.fillStyle = g.type === 0 ? '#16213e' : g.type === 1 ? '#1a2940' : '#0f2035';
        ctx.fillRect(g.x, g.y, g.w, g.h);
        ctx.strokeStyle = '#0f3460';
        ctx.lineWidth = 1;
        ctx.strokeRect(g.x, g.y, g.w, g.h);
      });
    }

    // ── Enemy spawning ────────────────────────────────────────
    // Enemy types: basic, fast, tough, tank, turret, formation
    function spawnEnemy(type, x, y, vx, vy) {
      const e = { type, x, y, vx: vx || 0, vy: vy || 0, hp: 1, maxHp: 1, tick: 0, phase: rand(0, Math.PI * 2) };
      switch (type) {
        case 'basic':
          e.hp = e.maxHp = 1; e.vy = 1.5 + stage * 0.2; e.score = 100;
          e.w = 20; e.h = 20; e.color = '#f80';
          break;
        case 'fast':
          e.hp = e.maxHp = 1; e.vy = 3 + stage * 0.15; e.score = 150;
          e.w = 16; e.h = 16; e.color = '#ff0';
          break;
        case 'zigzag':
          e.hp = e.maxHp = 2; e.vy = 1.2 + stage * 0.1; e.score = 200;
          e.w = 22; e.h = 22; e.color = '#0ff'; e.amplitude = 60 + rand(0, 30);
          break;
        case 'tough':
          e.hp = e.maxHp = 3 + stage; e.vy = 0.8; e.score = 300;
          e.w = 28; e.h = 28; e.color = '#c4f';
          break;
        case 'tank':
          e.hp = e.maxHp = 5 + stage * 2; e.vy = 0.4; e.score = 500;
          e.w = 36; e.h = 28; e.color = '#888'; e.shootTimer = 0;
          break;
        case 'turret':
          e.hp = e.maxHp = 4 + stage; e.vy = 0.8 + stage * 0.1; e.score = 400;
          e.w = 30; e.h = 30; e.color = '#696'; e.shootTimer = 0; e.ground = true;
          break;
      }
      enemies.push(e);
    }

    function spawnFormation() {
      const formations = [
        // V formation
        () => {
          const cx = rand(60, W - 60);
          for (let i = 0; i < 5; i++) {
            spawnEnemy('basic', cx + (i - 2) * 30, -20 - Math.abs(i - 2) * 25);
          }
        },
        // Line
        () => {
          const y = -20;
          const count = 6 + Math.min(stage, 4);
          const spacing = (W - 80) / count;
          for (let i = 0; i < count; i++) {
            spawnEnemy('basic', 40 + i * spacing, y - rand(0, 10));
          }
        },
        // Double zigzag
        () => {
          for (let i = 0; i < 4; i++) {
            spawnEnemy('zigzag', rand(40, W - 60), -20 - i * 40);
          }
        },
        // Tank + escorts
        () => {
          const cx = rand(80, W - 80);
          spawnEnemy('tank', cx - 18, -30);
          spawnEnemy('basic', cx - 50, -10);
          spawnEnemy('basic', cx + 30, -10);
        },
        // Fast swarm
        () => {
          const side = Math.random() > 0.5 ? 0 : W - 20;
          for (let i = 0; i < 4 + stage; i++) {
            const e = { type: 'fast' };
            spawnEnemy('fast', side, -20 - i * 20, side === 0 ? 1.5 : -1.5);
          }
        },
        // Turret pair
        () => {
          spawnEnemy('turret', rand(30, W / 2 - 40), -40);
          spawnEnemy('turret', rand(W / 2 + 10, W - 60), -40);
        }
      ];
      formations[randInt(0, formations.length - 1)]();
    }

    function spawnWave() {
      // Difficulty-based spawn rate
      const spawnInterval = Math.max(40, 120 - stage * 12);

      if (tick % spawnInterval === 0 && !bossActive) {
        if (Math.random() < 0.4) {
          spawnFormation();
        } else {
          const types = ['basic', 'basic', 'fast', 'zigzag'];
          if (stage >= 2) types.push('tough', 'turret');
          if (stage >= 3) types.push('tank');
          const type = types[randInt(0, types.length - 1)];
          spawnEnemy(type, rand(30, W - 50), -30);
        }
      }
    }

    // ── Boss system ───────────────────────────────────────────
    function spawnBoss() {
      bossActive = true;
      const bossHp = 50 + stage * 30;
      boss = {
        x: W / 2 - 50, y: -100, w: 100, h: 60,
        hp: bossHp, maxHp: bossHp,
        phase: 0, pattern: 0, patternTimer: 0,
        entryComplete: false, score: 2000 + stage * 1000,
        shootTimer: 0
      };
    }

    function updateBoss() {
      if (!boss) return;

      // Entry animation
      if (!boss.entryComplete) {
        boss.y += 1.5;
        if (boss.y >= 40) {
          boss.entryComplete = true;
          boss.y = 40;
        }
        return;
      }

      boss.phase += 0.02;
      boss.patternTimer++;
      boss.shootTimer++;

      // Movement patterns
      const patternDuration = 240;
      if (boss.patternTimer > patternDuration) {
        boss.patternTimer = 0;
        boss.pattern = (boss.pattern + 1) % 3;
      }

      switch (boss.pattern) {
        case 0: // Side to side
          boss.x = W / 2 - boss.w / 2 + Math.sin(boss.phase * 1.5) * (W / 2 - boss.w / 2 - 20);
          break;
        case 1: // Chase player
          const targetX = player.x - boss.w / 2 + PLAYER_W / 2;
          boss.x += (targetX - boss.x) * 0.03;
          break;
        case 2: // Figure eight
          boss.x = W / 2 - boss.w / 2 + Math.sin(boss.phase * 2) * (W / 3);
          boss.y = 40 + Math.sin(boss.phase * 4) * 20;
          break;
      }

      boss.x = clamp(boss.x, 10, W - boss.w - 10);
      boss.y = clamp(boss.y, 10, 120);

      // Shooting patterns
      const fireRate = Math.max(15, 40 - stage * 3);
      if (boss.shootTimer >= fireRate) {
        boss.shootTimer = 0;
        const cx = boss.x + boss.w / 2;
        const cy = boss.y + boss.h;
        const hpRatio = boss.hp / boss.maxHp;

        // More aggressive when damaged
        if (hpRatio < 0.3) {
          // Desperate: aimed spread
          const angle = Math.atan2(player.y - cy, player.x + PLAYER_W / 2 - cx);
          for (let i = -3; i <= 3; i++) {
            const a = angle + i * 0.15;
            enemyBullets.push({ x: cx, y: cy, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3 });
          }
        } else if (hpRatio < 0.6) {
          // Spiral burst
          for (let i = 0; i < 6; i++) {
            const a = boss.phase * 3 + i * Math.PI / 3;
            enemyBullets.push({ x: cx, y: cy, vx: Math.cos(a) * 2.5, vy: Math.sin(a) * 2.5 + 1 });
          }
        } else {
          // Simple aimed shots
          const dx = player.x + PLAYER_W / 2 - cx;
          const dy = player.y - cy;
          const d = Math.sqrt(dx * dx + dy * dy) || 1;
          enemyBullets.push({ x: cx, y: cy, vx: dx / d * 3, vy: dy / d * 3 });
          enemyBullets.push({ x: boss.x + 10, y: cy, vx: 0, vy: 2.5 });
          enemyBullets.push({ x: boss.x + boss.w - 10, y: cy, vx: 0, vy: 2.5 });
        }
      }
    }

    // ── Player weapons ────────────────────────────────────────
    function fireWeapon() {
      const cx = player.x + PLAYER_W / 2;
      const cy = player.y;
      const lvl = weaponLevel;

      switch (weaponType) {
        case WEAPON.VULCAN:
          if (fireTimer % FIRE_RATE_VULCAN === 0) {
            bullets.push({ x: cx, y: cy, vx: 0, vy: -8, dmg: 1, type: 'vulcan' });
            if (lvl >= 2) {
              bullets.push({ x: cx - 8, y: cy + 4, vx: -0.5, vy: -8, dmg: 1, type: 'vulcan' });
              bullets.push({ x: cx + 8, y: cy + 4, vx: 0.5, vy: -8, dmg: 1, type: 'vulcan' });
            }
            if (lvl >= 3) {
              bullets.push({ x: cx - 14, y: cy + 8, vx: -1.2, vy: -7, dmg: 1, type: 'vulcan' });
              bullets.push({ x: cx + 14, y: cy + 8, vx: 1.2, vy: -7, dmg: 1, type: 'vulcan' });
            }
          }
          break;

        case WEAPON.LASER:
          if (fireTimer % FIRE_RATE_LASER === 0) {
            bullets.push({ x: cx, y: cy, vx: 0, vy: -10, dmg: 3, type: 'laser', w: 4 + lvl * 2, h: 20 + lvl * 5 });
            if (lvl >= 3) {
              bullets.push({ x: cx - 12, y: cy + 5, vx: 0, vy: -9, dmg: 2, type: 'laser', w: 3, h: 16 });
              bullets.push({ x: cx + 12, y: cy + 5, vx: 0, vy: -9, dmg: 2, type: 'laser', w: 3, h: 16 });
            }
          }
          break;

        case WEAPON.MISSILE:
          if (fireTimer % FIRE_RATE_MISSILE === 0) {
            // Find nearest enemy for homing
            bullets.push({ x: cx - 6, y: cy, vx: -0.5, vy: -5, dmg: 4, type: 'missile', homing: true });
            bullets.push({ x: cx + 6, y: cy, vx: 0.5, vy: -5, dmg: 4, type: 'missile', homing: true });
            if (lvl >= 2) {
              bullets.push({ x: cx, y: cy - 5, vx: 0, vy: -6, dmg: 5, type: 'missile', homing: true });
            }
            if (lvl >= 3) {
              bullets.push({ x: cx - 14, y: cy + 5, vx: -1, vy: -4, dmg: 4, type: 'missile', homing: true });
              bullets.push({ x: cx + 14, y: cy + 5, vx: 1, vy: -4, dmg: 4, type: 'missile', homing: true });
            }
          }
          break;
      }
    }

    // ── Bomb ──────────────────────────────────────────────────
    function useBomb() {
      if (bombs <= 0) return;
      bombs--;
      bombFlash = BOMB_FLASH_DURATION;
      screenShake = 8;
      shakeTimer = 20;

      // Damage all enemies on screen
      enemies.forEach(e => {
        e.hp -= 10;
        if (e.hp <= 0) {
          addScore(e.score);
          spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 8);
        }
      });
      enemies = enemies.filter(e => e.hp > 0);

      // Damage boss
      if (boss) {
        boss.hp -= 15;
        if (boss.hp <= 0) {
          addScore(boss.score);
          spawnExplosion(boss.x + boss.w / 2, boss.y + boss.h / 2, '#fd0', 25);
          boss = null;
          bossActive = false;
          stageTimer = STAGE_DURATION; // progress to next stage
        }
      }

      // Clear enemy bullets
      enemyBullets = [];

      // Visual effect
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: rand(0, W), y: rand(0, H),
          vx: rand(-3, 3), vy: rand(-3, 3),
          life: 40, maxLife: 40,
          color: '#fff', size: rand(2, 6)
        });
      }
    }

    // ── Powerup system ────────────────────────────────────────
    function spawnPowerup(x, y) {
      const r = Math.random();
      let type;
      if (r < 0.3) type = 'vulcan';
      else if (r < 0.6) type = 'laser';
      else if (r < 0.9) type = 'missile';
      else type = 'bomb';
      powerups.push({ x, y, type, vy: 1.5, w: 20, h: 20, tick: 0 });
    }

    function spawnMedal(x, y) {
      medals.push({ x, y, vy: 1.2, w: 14, h: 14, tick: 0 });
    }

    // ── Particles ─────────────────────────────────────────────
    function spawnExplosion(x, y, color, count) {
      count = count || 10;
      for (let i = 0; i < count; i++) {
        const ang = rand(0, Math.PI * 2);
        const spd = rand(1, 4);
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
          life: 20 + rand(0, 15), maxLife: 35,
          color, size: rand(2, 5)
        });
      }
    }

    function addScore(pts) {
      score += pts;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    // ── Update ────────────────────────────────────────────────
    function update() {
      tick++;
      stageTimer++;

      // Screen shake
      if (shakeTimer > 0) shakeTimer--;
      else screenShake = 0;

      // Bomb flash
      if (bombFlash > 0) bombFlash--;

      // Invincibility
      if (invincibleTimer > 0) invincibleTimer--;

      // Scrolling ground
      updateGround();

      // Player movement
      if (keys['ArrowLeft']) player.x -= PLAYER_SPEED;
      if (keys['ArrowRight']) player.x += PLAYER_SPEED;
      if (keys['ArrowUp']) player.y -= PLAYER_SPEED;
      if (keys['ArrowDown']) player.y += PLAYER_SPEED;
      player.x = clamp(player.x, 0, W - PLAYER_W);
      player.y = clamp(player.y, H / 3, H - PLAYER_H - 10);

      // Firing
      if (keys[' ']) {
        fireTimer++;
        fireWeapon();
      } else {
        fireTimer = 0;
      }

      // Stage progression
      if (!bossActive && stageTimer >= STAGE_DURATION) {
        spawnBoss();
      }

      // Spawn waves
      spawnWave();

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];

        // Homing missiles
        if (b.homing) {
          let closest = null, closestDist = Infinity;
          // Check regular enemies
          enemies.forEach(e => {
            const d = dist(b.x, b.y, e.x + e.w / 2, e.y + e.h / 2);
            if (d < closestDist) { closestDist = d; closest = { x: e.x + e.w / 2, y: e.y + e.h / 2 }; }
          });
          // Check boss
          if (boss) {
            const d = dist(b.x, b.y, boss.x + boss.w / 2, boss.y + boss.h / 2);
            if (d < closestDist) { closestDist = d; closest = { x: boss.x + boss.w / 2, y: boss.y + boss.h / 2 }; }
          }
          if (closest) {
            const angle = Math.atan2(closest.y - b.y, closest.x - b.x);
            const curAngle = Math.atan2(b.vy, b.vx);
            let diff = angle - curAngle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            const turn = clamp(diff, -0.08, 0.08);
            const newAngle = curAngle + turn;
            const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            b.vx = Math.cos(newAngle) * speed;
            b.vy = Math.sin(newAngle) * speed;
          }
        }

        b.x += b.vx;
        b.y += b.vy;
        if (b.y < -30 || b.y > H + 30 || b.x < -30 || b.x > W + 30) {
          bullets.splice(i, 1);
          continue;
        }

        // Hit enemies
        const bw = b.w || 4, bh = b.h || 8;
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (rectCollide(b.x - bw / 2, b.y - bh / 2, bw, bh, e.x, e.y, e.w, e.h)) {
            e.hp -= b.dmg;
            hit = true;
            if (e.hp <= 0) {
              addScore(e.score);
              spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 10);
              // Drop powerup or medal
              if (Math.random() < 0.12) spawnPowerup(e.x + e.w / 2, e.y + e.h / 2);
              else if (Math.random() < 0.2) spawnMedal(e.x + e.w / 2, e.y + e.h / 2);
              enemies.splice(j, 1);
            } else {
              spawnExplosion(b.x, b.y, '#fff', 3);
            }
            break;
          }
        }

        // Hit boss
        if (!hit && boss) {
          if (rectCollide(b.x - bw / 2, b.y - bh / 2, bw, bh, boss.x, boss.y, boss.w, boss.h)) {
            boss.hp -= b.dmg;
            hit = true;
            spawnExplosion(b.x, b.y, '#fff', 3);
            screenShake = 2;
            shakeTimer = 3;
            if (boss.hp <= 0) {
              addScore(boss.score);
              spawnExplosion(boss.x + boss.w / 2, boss.y + boss.h / 2, '#fd0', 30);
              // Drop lots of medals and a powerup
              for (let m = 0; m < 8; m++) {
                spawnMedal(boss.x + rand(0, boss.w), boss.y + rand(0, boss.h));
              }
              spawnPowerup(boss.x + boss.w / 2, boss.y + boss.h / 2);
              boss = null;
              bossActive = false;
              // Advance stage
              stage++;
              stageTimer = 0;
            }
          }
        }

        if (hit) {
          bullets.splice(i, 1);
        }
      }

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.tick++;

        // Movement
        switch (e.type) {
          case 'basic':
            e.y += e.vy;
            e.x += Math.sin(e.tick * 0.03 + e.phase) * 0.8;
            break;
          case 'fast':
            e.y += e.vy;
            e.x += e.vx;
            break;
          case 'zigzag':
            e.y += e.vy;
            e.x += Math.sin(e.tick * 0.05 + e.phase) * 2;
            break;
          case 'tough':
            e.y += e.vy;
            e.x += Math.sin(e.tick * 0.02 + e.phase) * 1.5;
            break;
          case 'tank':
            e.y += e.vy;
            e.shootTimer++;
            if (e.shootTimer > 60) {
              e.shootTimer = 0;
              const dx = player.x + PLAYER_W / 2 - (e.x + e.w / 2);
              const dy = player.y - (e.y + e.h);
              const d = Math.sqrt(dx * dx + dy * dy) || 1;
              enemyBullets.push({ x: e.x + e.w / 2, y: e.y + e.h, vx: dx / d * 2.5, vy: dy / d * 2.5 });
            }
            break;
          case 'turret':
            e.y += e.vy;
            e.shootTimer++;
            if (e.shootTimer > 45) {
              e.shootTimer = 0;
              // Spread shot
              const angle = Math.atan2(player.y - e.y, player.x + PLAYER_W / 2 - (e.x + e.w / 2));
              for (let s = -1; s <= 1; s++) {
                const a = angle + s * 0.3;
                enemyBullets.push({ x: e.x + e.w / 2, y: e.y + e.h, vx: Math.cos(a) * 2.5, vy: Math.sin(a) * 2.5 });
              }
            }
            break;
        }

        // Remove offscreen
        if (e.y > H + 50 || e.x < -80 || e.x > W + 80) {
          enemies.splice(i, 1);
          continue;
        }

        // Collision with player
        if (invincibleTimer <= 0 && rectCollide(player.x, player.y, PLAYER_W, PLAYER_H, e.x, e.y, e.w, e.h)) {
          playerHit();
          e.hp -= 5;
          if (e.hp <= 0) {
            addScore(e.score);
            spawnExplosion(e.x + e.w / 2, e.y + e.h / 2, e.color, 10);
            enemies.splice(i, 1);
          }
        }
      }

      // Update boss
      updateBoss();

      // Boss collision with player
      if (boss && invincibleTimer <= 0 && boss.entryComplete) {
        if (rectCollide(player.x, player.y, PLAYER_W, PLAYER_H, boss.x, boss.y, boss.w, boss.h)) {
          playerHit();
        }
      }

      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.y > H + 10 || b.y < -10 || b.x < -10 || b.x > W + 10) {
          enemyBullets.splice(i, 1);
          continue;
        }
        // Hit player
        if (invincibleTimer <= 0 && rectCollide(b.x - 3, b.y - 3, 6, 6, player.x, player.y, PLAYER_W, PLAYER_H)) {
          enemyBullets.splice(i, 1);
          playerHit();
        }
      }

      // Update powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.y += p.vy;
        p.tick++;
        if (p.y > H + 20) { powerups.splice(i, 1); continue; }
        if (rectCollide(player.x - 5, player.y - 5, PLAYER_W + 10, PLAYER_H + 10, p.x - p.w / 2, p.y - p.h / 2, p.w, p.h)) {
          if (p.type === 'bomb') {
            bombs = Math.min(bombs + 1, MAX_BOMBS + 2);
          } else {
            const newWeapon = p.type === 'vulcan' ? WEAPON.VULCAN : p.type === 'laser' ? WEAPON.LASER : WEAPON.MISSILE;
            if (newWeapon === weaponType) {
              weaponLevel = Math.min(weaponLevel + 1, 3);
            } else {
              weaponType = newWeapon;
              weaponLevel = 1;
            }
          }
          addScore(50);
          powerups.splice(i, 1);
        }
      }

      // Update medals
      for (let i = medals.length - 1; i >= 0; i--) {
        const m = medals[i];
        m.y += m.vy;
        m.tick++;
        if (m.y > H + 20) { medals.splice(i, 1); continue; }
        if (rectCollide(player.x - 5, player.y - 5, PLAYER_W + 10, PLAYER_H + 10, m.x - m.w / 2, m.y - m.h / 2, m.w, m.h)) {
          addScore(MEDAL_SCORE);
          // Gold sparkle
          for (let s = 0; s < 6; s++) {
            particles.push({
              x: m.x, y: m.y,
              vx: rand(-2, 2), vy: rand(-2, 2),
              life: 15, maxLife: 15,
              color: '#fd0', size: 3
            });
          }
          medals.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function playerHit() {
      lives--;
      invincibleTimer = 120;
      screenShake = 6;
      shakeTimer = 15;
      spawnExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#f28', 15);
      if (weaponLevel > 1) weaponLevel--;

      if (lives <= 0) {
        gameOver();
      }
    }

    // ── Drawing ───────────────────────────────────────────────
    function draw() {
      ctx.save();

      // Screen shake
      if (shakeTimer > 0) {
        ctx.translate(rand(-screenShake, screenShake), rand(-screenShake, screenShake));
      }

      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(-10, -10, W + 20, H + 20);

      // Scrolling stars
      ctx.fillStyle = '#ffffff10';
      for (let i = 0; i < 80; i++) {
        const sx = ((i * 137 + 83) % W);
        const sy = ((i * 251 + 47 + (scrollY * (0.3 + (i % 3) * 0.2))) % H);
        const sz = i % 3 === 0 ? 2 : 1;
        ctx.fillRect(sx, sy, sz, sz);
      }

      // Ground
      drawGround();

      // Powerups
      powerups.forEach(p => {
        const pulse = Math.sin(p.tick * 0.1) * 0.3 + 0.7;
        let color;
        switch (p.type) {
          case 'vulcan': color = '#f44'; break;
          case 'laser': color = '#48f'; break;
          case 'missile': color = '#4f4'; break;
          case 'bomb': color = '#fd0'; break;
        }
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 10 * pulse;
        ctx.fillRect(p.x - p.w / 2, p.y - p.h / 2, p.w, p.h);
        // Letter
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.type === 'bomb' ? 'B' : p.type[0].toUpperCase(), p.x, p.y);
      });

      // Medals
      medals.forEach(m => {
        const pulse = Math.sin(m.tick * 0.15) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(255, 220, 0, ${pulse})`;
        ctx.shadowColor = '#fd0';
        ctx.shadowBlur = 8;
        // Diamond shape
        ctx.beginPath();
        ctx.moveTo(m.x, m.y - m.h / 2);
        ctx.lineTo(m.x + m.w / 2, m.y);
        ctx.lineTo(m.x, m.y + m.h / 2);
        ctx.lineTo(m.x - m.w / 2, m.y);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Enemies
      enemies.forEach(e => {
        drawEnemy(e);
      });

      // Boss
      if (boss) {
        drawBossSprite();
      }

      // Player bullets
      bullets.forEach(b => {
        switch (b.type) {
          case 'vulcan':
            ctx.fillStyle = '#f44';
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 6;
            ctx.fillRect(b.x - 2, b.y - 4, 4, 8);
            break;
          case 'laser':
            ctx.fillStyle = '#48f';
            ctx.shadowColor = '#48f';
            ctx.shadowBlur = 12;
            const lw = b.w || 4, lh = b.h || 20;
            ctx.fillRect(b.x - lw / 2, b.y - lh / 2, lw, lh);
            break;
          case 'missile':
            ctx.fillStyle = '#4f4';
            ctx.shadowColor = '#4f4';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y - 5);
            ctx.lineTo(b.x + 3, b.y + 4);
            ctx.lineTo(b.x - 3, b.y + 4);
            ctx.closePath();
            ctx.fill();
            // Exhaust
            ctx.fillStyle = '#fd0';
            ctx.fillRect(b.x - 1, b.y + 4, 2, 3);
            break;
        }
        ctx.shadowBlur = 0;
      });

      // Enemy bullets
      ctx.fillStyle = '#f84';
      ctx.shadowColor = '#f84';
      ctx.shadowBlur = 6;
      enemyBullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Player
      if (invincibleTimer <= 0 || Math.floor(invincibleTimer / 4) % 2 === 0) {
        drawPlayer();
      }

      // Particles
      particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;

      // Bomb flash overlay
      if (bombFlash > 0) {
        const flashAlpha = bombFlash / BOMB_FLASH_DURATION * 0.6;
        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
        ctx.fillRect(-10, -10, W + 20, H + 20);
      }

      // HUD
      drawHUD();

      ctx.restore();
    }

    function drawPlayer() {
      const px = player.x, py = player.y;
      ctx.fillStyle = '#f28';
      ctx.shadowColor = '#f28';
      ctx.shadowBlur = 12;

      // Main body
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2, py - 6);
      ctx.lineTo(px + PLAYER_W - 2, py + PLAYER_H - 4);
      ctx.lineTo(px + PLAYER_W, py + PLAYER_H);
      ctx.lineTo(px, py + PLAYER_H);
      ctx.lineTo(px + 2, py + PLAYER_H - 4);
      ctx.closePath();
      ctx.fill();

      // Cockpit
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.ellipse(px + PLAYER_W / 2, py + 6, 3, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.fillStyle = '#d14';
      ctx.fillRect(px - 4, py + PLAYER_H - 10, 8, 6);
      ctx.fillRect(px + PLAYER_W - 4, py + PLAYER_H - 10, 8, 6);

      // Engine glow
      if (keys[' '] || keys['ArrowUp']) {
        ctx.fillStyle = '#fd0';
        ctx.shadowColor = '#fd0';
        ctx.shadowBlur = 8;
        const flicker = rand(3, 8);
        ctx.fillRect(px + PLAYER_W / 2 - 3, py + PLAYER_H, 6, flicker);
      }
      ctx.shadowBlur = 0;
    }

    function drawEnemy(e) {
      switch (e.type) {
        case 'basic':
          ctx.fillStyle = e.color;
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 6;
          // Simple diamond ship
          ctx.beginPath();
          ctx.moveTo(e.x + e.w / 2, e.y);
          ctx.lineTo(e.x + e.w, e.y + e.h / 2);
          ctx.lineTo(e.x + e.w / 2, e.y + e.h);
          ctx.lineTo(e.x, e.y + e.h / 2);
          ctx.closePath();
          ctx.fill();
          break;

        case 'fast':
          ctx.fillStyle = e.color;
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.moveTo(e.x + e.w / 2, e.y);
          ctx.lineTo(e.x + e.w, e.y + e.h);
          ctx.lineTo(e.x, e.y + e.h);
          ctx.closePath();
          ctx.fill();
          break;

        case 'zigzag':
          ctx.fillStyle = e.color;
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#1a1a2e';
          ctx.shadowBlur = 0;
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 4, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'tough':
          const hpPct = e.hp / e.maxHp;
          ctx.fillStyle = hpPct > 0.5 ? e.color : '#f4a';
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 8;
          ctx.fillRect(e.x + 2, e.y + 2, e.w - 4, e.h - 4);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1;
          ctx.strokeRect(e.x + 2, e.y + 2, e.w - 4, e.h - 4);
          // HP bar
          ctx.fillStyle = '#400';
          ctx.fillRect(e.x, e.y - 5, e.w, 3);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(e.x, e.y - 5, e.w * hpPct, 3);
          break;

        case 'tank':
          const thpPct = e.hp / e.maxHp;
          ctx.fillStyle = e.color;
          ctx.shadowColor = '#aaa';
          ctx.shadowBlur = 6;
          // Tank body
          ctx.fillRect(e.x, e.y + 6, e.w, e.h - 6);
          ctx.fillRect(e.x + 4, e.y, e.w - 8, e.h);
          // Turret
          ctx.fillStyle = '#aaa';
          ctx.fillRect(e.x + e.w / 2 - 4, e.y + e.h - 4, 8, 8);
          // HP bar
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#400';
          ctx.fillRect(e.x, e.y - 6, e.w, 3);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(e.x, e.y - 6, e.w * thpPct, 3);
          break;

        case 'turret':
          ctx.fillStyle = e.color;
          ctx.shadowColor = e.color;
          ctx.shadowBlur = 6;
          // Base
          ctx.fillRect(e.x + 2, e.y + e.h / 2, e.w - 4, e.h / 2);
          // Dome
          ctx.beginPath();
          ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2 - 2, Math.PI, 0);
          ctx.fill();
          // Gun barrel
          ctx.fillStyle = '#888';
          ctx.shadowBlur = 0;
          const gunAngle = Math.atan2(player.y - (e.y + e.h / 2), player.x + PLAYER_W / 2 - (e.x + e.w / 2));
          ctx.save();
          ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
          ctx.rotate(gunAngle);
          ctx.fillRect(0, -2, 18, 4);
          ctx.restore();
          // HP bar
          const turHpPct = e.hp / e.maxHp;
          ctx.fillStyle = '#400';
          ctx.fillRect(e.x, e.y - 6, e.w, 3);
          ctx.fillStyle = '#0f0';
          ctx.fillRect(e.x, e.y - 6, e.w * turHpPct, 3);
          break;
      }
      ctx.shadowBlur = 0;
    }

    function drawBossSprite() {
      if (!boss) return;
      const b = boss;
      const hpPct = b.hp / b.maxHp;

      // Damage color
      const r = Math.round(200 + (1 - hpPct) * 55);
      const g = Math.round(50 * hpPct);
      const bl = Math.round(80 * hpPct);
      ctx.fillStyle = `rgb(${r},${g},${bl})`;
      ctx.shadowColor = '#f28';
      ctx.shadowBlur = 15;

      // Main hull
      ctx.beginPath();
      ctx.moveTo(b.x + b.w / 2, b.y);
      ctx.lineTo(b.x + b.w + 10, b.y + b.h * 0.6);
      ctx.lineTo(b.x + b.w, b.y + b.h);
      ctx.lineTo(b.x, b.y + b.h);
      ctx.lineTo(b.x - 10, b.y + b.h * 0.6);
      ctx.closePath();
      ctx.fill();

      // Center core
      ctx.fillStyle = '#f28';
      ctx.shadowBlur = 20;
      const pulse = Math.sin(tick * 0.08) * 0.3 + 0.7;
      ctx.globalAlpha = pulse;
      ctx.beginPath();
      ctx.arc(b.x + b.w / 2, b.y + b.h * 0.45, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Side engines
      ctx.fillStyle = '#888';
      ctx.shadowBlur = 0;
      ctx.fillRect(b.x - 8, b.y + 10, 12, 30);
      ctx.fillRect(b.x + b.w - 4, b.y + 10, 12, 30);

      // Engine glow
      ctx.fillStyle = '#f84';
      ctx.shadowColor = '#f84';
      ctx.shadowBlur = 8;
      ctx.fillRect(b.x - 6, b.y + b.h, 8, rand(4, 10));
      ctx.fillRect(b.x + b.w - 2, b.y + b.h, 8, rand(4, 10));

      // HP bar
      ctx.shadowBlur = 0;
      const barW = b.w + 20;
      const barX = b.x - 10;
      ctx.fillStyle = '#400';
      ctx.fillRect(barX, b.y - 12, barW, 6);
      const hpColor = hpPct > 0.5 ? '#0f0' : hpPct > 0.25 ? '#ff0' : '#f00';
      ctx.fillStyle = hpColor;
      ctx.fillRect(barX, b.y - 12, barW * hpPct, 6);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, b.y - 12, barW, 6);

      // Boss label
      ctx.fillStyle = '#f28';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`STAGE ${stage} BOSS`, b.x + b.w / 2, b.y - 16);
    }

    function drawHUD() {
      // Lives
      ctx.fillStyle = '#f28';
      ctx.shadowColor = '#f28';
      ctx.shadowBlur = 4;
      for (let i = 0; i < lives; i++) {
        const lx = 10 + i * 22, ly = H - 25;
        ctx.beginPath();
        ctx.moveTo(lx + 6, ly);
        ctx.lineTo(lx + 12, ly + 10);
        ctx.lineTo(lx, ly + 10);
        ctx.closePath();
        ctx.fill();
      }

      // Bombs
      ctx.fillStyle = '#fd0';
      ctx.shadowColor = '#fd0';
      for (let i = 0; i < bombs; i++) {
        const bx = 10 + i * 18, by = H - 45;
        ctx.beginPath();
        ctx.arc(bx + 6, by + 5, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(bx + 4, by - 2, 4, 4);
      }
      ctx.shadowBlur = 0;

      // Weapon indicator
      const wColor = WEAPON_COLORS[weaponType];
      ctx.fillStyle = wColor;
      ctx.shadowColor = wColor;
      ctx.shadowBlur = 6;
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`${WEAPON_NAMES[weaponType]} Lv${weaponLevel}`, W - 10, H - 28);
      ctx.shadowBlur = 0;

      // Stage indicator
      ctx.fillStyle = '#aaa';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'right';
      ctx.fillText(`Stage ${stage}`, W - 10, H - 12);

      // Boss warning
      if (bossActive && boss && !boss.entryComplete) {
        const warnAlpha = Math.sin(tick * 0.15) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 34, 136, ${warnAlpha})`;
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('WARNING', W / 2, H / 2 - 40);
        ctx.font = '14px Courier New';
        ctx.fillText('BOSS APPROACHING', W / 2, H / 2 - 15);
      }
    }

    // ── Input handling ────────────────────────────────────────
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift', 'b', 'B'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') { start(); }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === 'Shift' || e.key === 'b' || e.key === 'B') {
          useBomb();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phoenix</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f62; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255,102,34,0.5); }
    h1 { color: #f62; font-size: 2rem; text-shadow: 0 0 15px rgba(255,102,34,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f62; }
    canvas {
      border: 2px solid #f62;
      box-shadow: 0 0 20px rgba(255,102,34,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f62;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .overlay .wave-info { color: #f92; font-size: 1.1rem; margin-top: 12px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PHOENIX</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Shield: <span id="shields">3</span></div>
    <div>Wave: <span id="wave">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:600px;">
      <h2 id="overlayTitle">PHOENIX</h2>
      <p id="overlayText">Press SPACE to start</p>
      <p class="wave-info" id="overlayWave"></p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const shieldsEl = document.getElementById('shields');
    const waveEl = document.getElementById('wave');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlayWave = document.getElementById('overlayWave');

    // -- Constants --
    const PLAYER_W = 36, PLAYER_H = 20, PLAYER_SPEED = 5;
    const BULLET_W = 3, BULLET_H = 12, BULLET_SPEED = 8;
    const MAX_BULLETS = 3;
    const SHIELD_DURATION = 90; // frames of invincibility
    const STAR_COUNT = 100;

    // -- Global state for recorder --
    let gameState, score;
    let best = 0, lives, shieldUses, shieldActive, shieldTimer;
    let player, bullets, enemyBullets, enemies, particles, stars;
    let keys = {};
    let tick, wave, cycle, animFrame;
    let waveIntroTimer, shootCooldown;

    // -- Star field --
    function makeStars() {
      stars = [];
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          speed: 0.2 + Math.random() * 0.8,
          brightness: 0.3 + Math.random() * 0.7,
          size: Math.random() < 0.1 ? 2 : 1
        });
      }
    }

    function updateStars() {
      for (const s of stars) {
        s.y += s.speed;
        if (s.y > H) {
          s.y = 0;
          s.x = Math.random() * W;
        }
      }
    }

    function drawStars() {
      for (const s of stars) {
        const twinkle = (Math.sin(tick * 0.03 + s.x * 0.1) * 0.3 + 0.7) * s.brightness;
        const alpha = Math.round(twinkle * 255).toString(16).padStart(2, '0');
        ctx.fillStyle = '#ffffff' + alpha;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }
    }

    // -- Particles --
    function spawnExplosion(x, y, color, count) {
      count = count || 12;
      for (let i = 0; i < count; i++) {
        const ang = (Math.PI * 2 / count) * i + Math.random() * 0.5;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 20 + Math.random() * 15,
          maxLife: 35,
          color
        });
      }
    }

    function spawnSpark(x, y) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 8 + Math.random() * 5,
          maxLife: 13,
          color: '#fff'
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = Math.max(0, p.life / p.maxLife);
        const a = Math.round(alpha * 255).toString(16).padStart(2, '0');
        ctx.fillStyle = p.color + a;
        const sz = 2 + alpha * 2;
        ctx.fillRect(p.x - sz / 2, p.y - sz / 2, sz, sz);
      }
    }

    // -- Enemy Types --
    // Wave 1-2: Small birds
    // Wave 3-4: Phoenix birds (larger, multi-hit, regenerate)
    // Wave 5: Boss mothership with rotating shield

    function makeSmallBird(x, y, row, col) {
      return {
        type: 'smallBird',
        x, y, baseX: x, baseY: y,
        row, col,
        alive: true,
        hp: 1, maxHp: 1,
        points: 10,
        phase: Math.random() * Math.PI * 2,
        swooping: false, swoopTime: 0,
        swoopStartX: 0, swoopStartY: 0,
        swoopTargetX: 0,
        w: 28, h: 20,
        wingFrame: 0
      };
    }

    function makeLargeBird(x, y, row, col) {
      return {
        type: 'largeBird',
        x, y, baseX: x, baseY: y,
        row, col,
        alive: true,
        hp: 3, maxHp: 3,
        points: 30,
        phase: Math.random() * Math.PI * 2,
        swooping: false, swoopTime: 0,
        swoopStartX: 0, swoopStartY: 0,
        swoopTargetX: 0,
        w: 40, h: 28,
        wingFrame: 0,
        regenTimer: 0,    // counts up when damaged
        regenDelay: 180,   // frames before regen kicks in
        lastHitTick: 0
      };
    }

    function makePhoenixBird(x, y, row, col) {
      return {
        type: 'phoenixBird',
        x, y, baseX: x, baseY: y,
        row, col,
        alive: true,
        hp: 5, maxHp: 5,
        points: 50,
        phase: Math.random() * Math.PI * 2,
        swooping: false, swoopTime: 0,
        swoopStartX: 0, swoopStartY: 0,
        swoopTargetX: 0,
        w: 44, h: 32,
        wingFrame: 0,
        regenTimer: 0,
        regenDelay: 120,   // faster regen
        lastHitTick: 0,
        flameTimer: 0
      };
    }

    function makeBoss() {
      return {
        type: 'boss',
        x: W / 2, y: 80,
        alive: true,
        hp: 40, maxHp: 40,
        points: 500,
        w: 100, h: 60,
        shieldAngle: 0,
        shieldSegments: 16,
        shieldHp: [], // each segment has HP
        phase: 0,
        moveDir: 1,
        shootTimer: 0,
        alienX: 0, alienY: 0,  // alien position inside
        alienVisible: false
      };
    }

    // -- Wave Definitions --
    function getWaveEnemies(waveNum) {
      const w = ((waveNum - 1) % 5) + 1; // 1-5 repeating
      const c = Math.floor((waveNum - 1) / 5); // cycle number
      const hpMult = 1 + c * 0.5; // more HP each cycle
      const enems = [];

      if (w === 1) {
        // Wave 1: 3 rows of small birds in formation
        for (let row = 0; row < 3; row++) {
          const count = 8;
          const spacing = 52;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeSmallBird(startX + col * spacing, 60 + row * 40, row, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            enems.push(e);
          }
        }
      } else if (w === 2) {
        // Wave 2: small birds in V-formations that swoop more aggressively
        for (let row = 0; row < 4; row++) {
          const count = 7 + (row < 2 ? 0 : 1);
          const spacing = 52;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeSmallBird(startX + col * spacing, 50 + row * 38, row, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            e.points = 15;
            enems.push(e);
          }
        }
      } else if (w === 3) {
        // Wave 3: Large phoenix birds (2 rows) + small birds (2 rows)
        for (let row = 0; row < 2; row++) {
          const count = 5;
          const spacing = 80;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeLargeBird(startX + col * spacing, 50 + row * 50, row, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            enems.push(e);
          }
        }
        for (let row = 0; row < 2; row++) {
          const count = 7;
          const spacing = 56;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeSmallBird(startX + col * spacing, 160 + row * 38, row + 2, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            enems.push(e);
          }
        }
      } else if (w === 4) {
        // Wave 4: Phoenix birds that regenerate, flanked by large birds
        for (let row = 0; row < 2; row++) {
          const count = 4;
          const spacing = 90;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makePhoenixBird(startX + col * spacing, 50 + row * 55, row, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            enems.push(e);
          }
        }
        for (let row = 0; row < 2; row++) {
          const count = 6;
          const spacing = 64;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeLargeBird(startX + col * spacing, 170 + row * 45, row + 2, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            enems.push(e);
          }
        }
      } else if (w === 5) {
        // Wave 5: Boss mothership
        const boss = makeBoss();
        boss.hp = Math.ceil(boss.hp * hpMult);
        boss.maxHp = boss.hp;
        // Initialize shield segments
        boss.shieldHp = [];
        for (let i = 0; i < boss.shieldSegments; i++) {
          boss.shieldHp.push(Math.ceil(3 * hpMult));
        }
        enems.push(boss);
        // Add some escort small birds
        for (let row = 0; row < 2; row++) {
          const count = 5;
          const spacing = 56;
          const startX = (W - (count - 1) * spacing) / 2;
          for (let col = 0; col < count; col++) {
            const e = makeSmallBird(startX + col * spacing, 180 + row * 36, row, col);
            e.hp = Math.ceil(e.hp * hpMult);
            e.maxHp = e.hp;
            e.points = 20;
            enems.push(e);
          }
        }
      }
      return enems;
    }

    // -- Wave names --
    const WAVE_NAMES = [
      'Bird Scouts',
      'The Flock Attacks',
      'Phoenix Rising',
      'Firestorm',
      'The Mothership'
    ];

    const WAVE_INTROS = [
      'Small birds in formation',
      'Aggressive swoop attacks',
      'NEW: Phoenix birds - take multiple hits, can regenerate!',
      'NEW: Greater phoenixes - regenerate fast, destroy quickly!',
      'BOSS: Blast through the rotating shield!'
    ];

    // -- Init / Start --
    function init() {
      score = 0;
      lives = 3;
      shieldUses = 3;
      shieldActive = false;
      shieldTimer = 0;
      wave = 0;
      cycle = 0;
      tick = 0;
      shootCooldown = 0;
      player = { x: W / 2 - PLAYER_W / 2, y: H - 60 };
      bullets = [];
      enemyBullets = [];
      enemies = [];
      particles = [];
      keys = {};
      makeStars();
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      shieldsEl.textContent = '3';
      waveEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PHOENIX';
      overlayText.textContent = 'Press SPACE to start';
      overlayWave.textContent = 'Left/Right: Move | Space: Fire | Shift: Shield';
      drawFrame();
    }

    function startGame() {
      overlay.style.display = 'none';
      overlayWave.textContent = '';
      nextWave();
      cancelAnimationFrame(animFrame);
      loop();
    }

    function nextWave() {
      wave++;
      waveEl.textContent = wave;
      cycle = Math.floor((wave - 1) / 5);
      enemies = getWaveEnemies(wave);
      enemyBullets = [];

      // Show wave intro
      gameState = 'waveIntro';
      overlay.style.display = 'flex';
      const waveType = ((wave - 1) % 5);
      overlayTitle.textContent = `WAVE ${wave}`;
      overlayText.textContent = WAVE_NAMES[waveType];
      overlayWave.textContent = WAVE_INTROS[waveType];
      waveIntroTimer = 120;
    }

    // -- Game Loop --
    function loop() {
      if (gameState === 'over') return;
      tick++;

      if (gameState === 'waveIntro') {
        waveIntroTimer--;
        updateStars();
        if (waveIntroTimer <= 0) {
          gameState = 'playing';
          overlay.style.display = 'none';
        }
        drawFrame();
        animFrame = requestAnimationFrame(loop);
        return;
      }

      update();
      drawFrame();
      animFrame = requestAnimationFrame(loop);
    }

    // -- Update --
    function update() {
      updateStars();

      // Player movement
      if (keys['ArrowLeft'] || keys['a']) player.x = Math.max(0, player.x - PLAYER_SPEED);
      if (keys['ArrowRight'] || keys['d']) player.x = Math.min(W - PLAYER_W, player.x + PLAYER_SPEED);

      // Shield cooldown
      if (shieldActive) {
        shieldTimer--;
        if (shieldTimer <= 0) {
          shieldActive = false;
        }
      }

      // Shoot cooldown
      if (shootCooldown > 0) shootCooldown--;

      // Auto-fire when holding space
      if (keys[' '] && shootCooldown <= 0 && bullets.length < MAX_BULLETS) {
        bullets.push({ x: player.x + PLAYER_W / 2, y: player.y });
        shootCooldown = 8;
      }

      // Update player bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= BULLET_SPEED;
        if (bullets[i].y < -BULLET_H) {
          bullets.splice(i, 1);
          continue;
        }
      }

      // Check if all enemies dead
      const aliveEnemies = enemies.filter(e => e.alive);
      if (aliveEnemies.length === 0) {
        nextWave();
        return;
      }

      // Formation movement for non-boss enemies
      const formEnemies = aliveEnemies.filter(e => e.type !== 'boss');
      const formSway = Math.sin(tick * 0.015) * 40;

      // Update enemies
      for (const e of enemies) {
        if (!e.alive) continue;

        if (e.type === 'boss') {
          updateBoss(e);
          continue;
        }

        // Wing animation
        e.wingFrame = (e.wingFrame || 0) + 0.08;

        // Formation sway
        if (!e.swooping) {
          e.x = e.baseX + formSway + Math.sin(tick * 0.03 + e.phase) * 10;
          e.y = e.baseY + Math.sin(tick * 0.02 + e.phase * 2) * 5;
        }

        // Regeneration for phoenix types
        if ((e.type === 'largeBird' || e.type === 'phoenixBird') && e.hp < e.maxHp) {
          if (tick - e.lastHitTick > e.regenDelay) {
            e.regenTimer++;
            if (e.regenTimer >= 30) {
              e.hp++;
              e.regenTimer = 0;
            }
          }
        }

        // Swooping behavior
        if (!e.swooping) {
          // Random chance to swoop
          let swoopChance = 0.001;
          if (e.type === 'smallBird') swoopChance = 0.002 + cycle * 0.001;
          if (e.type === 'largeBird') swoopChance = 0.0015 + cycle * 0.0008;
          if (e.type === 'phoenixBird') swoopChance = 0.001 + cycle * 0.0005;

          if (Math.random() < swoopChance) {
            e.swooping = true;
            e.swoopTime = 0;
            e.swoopStartX = e.x;
            e.swoopStartY = e.y;
            e.swoopTargetX = player.x + PLAYER_W / 2;
          }
        }

        if (e.swooping) {
          e.swoopTime++;
          const t = e.swoopTime;
          const totalTime = e.type === 'smallBird' ? 120 : 150;

          if (t < totalTime / 2) {
            // Dive toward player
            const progress = t / (totalTime / 2);
            e.x = e.swoopStartX + (e.swoopTargetX - e.swoopStartX) * progress;
            e.y = e.swoopStartY + (H + 30 - e.swoopStartY) * progress;
          } else if (t < totalTime) {
            // Loop back up
            const progress = (t - totalTime / 2) / (totalTime / 2);
            e.x = e.swoopTargetX + (e.baseX + formSway - e.swoopTargetX) * progress;
            e.y = (H + 30) - (H + 30 - e.baseY) * progress;
          } else {
            e.swooping = false;
            e.x = e.baseX + formSway;
            e.y = e.baseY;
          }

          // Shoot while swooping
          if (t % 30 === 15 && Math.random() < 0.5) {
            const dx = player.x + PLAYER_W / 2 - e.x;
            const dy = player.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const speed = 3 + cycle * 0.5;
            enemyBullets.push({
              x: e.x, y: e.y + e.h / 2,
              vx: dx / dist * speed,
              vy: dy / dist * speed
            });
          }
        } else {
          // Random shooting while in formation
          let shootChance = 0.003 + cycle * 0.001;
          if (e.type === 'phoenixBird') shootChance *= 1.5;
          if (Math.random() < shootChance) {
            enemyBullets.push({
              x: e.x, y: e.y + e.h,
              vx: (Math.random() - 0.5) * 1,
              vy: 3 + cycle * 0.3 + Math.random()
            });
          }
        }
      }

      // Bullet-enemy collision
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        let hit = false;

        for (const e of enemies) {
          if (!e.alive) continue;

          if (e.type === 'boss') {
            hit = checkBossHit(e, b, i);
            if (hit) break;
            continue;
          }

          // AABB collision
          if (b.x >= e.x - e.w / 2 && b.x <= e.x + e.w / 2 &&
              b.y >= e.y - e.h / 2 && b.y <= e.y + e.h / 2) {
            e.hp--;
            e.lastHitTick = tick;
            e.regenTimer = 0;
            bullets.splice(i, 1);
            if (e.hp <= 0) {
              e.alive = false;
              score += e.points;
              scoreEl.textContent = score;
              if (score > best) { best = score; }
              spawnExplosion(e.x, e.y, getEnemyColor(e), e.type === 'phoenixBird' ? 20 : 12);
            } else {
              spawnSpark(e.x, e.y);
            }
            hit = true;
            break;
          }
        }
      }

      // Enemy bullets vs player
      if (!shieldActive) {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          b.x += b.vx;
          b.y += b.vy;
          if (b.y > H + 10 || b.y < -10 || b.x < -10 || b.x > W + 10) {
            enemyBullets.splice(i, 1);
            continue;
          }
          if (b.x >= player.x && b.x <= player.x + PLAYER_W &&
              b.y >= player.y && b.y <= player.y + PLAYER_H) {
            enemyBullets.splice(i, 1);
            playerHit();
            if (gameState === 'over') return;
          }
        }
      } else {
        // Shield deflects bullets
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          b.x += b.vx;
          b.y += b.vy;
          if (b.y > H + 10 || b.y < -10 || b.x < -10 || b.x > W + 10) {
            enemyBullets.splice(i, 1);
            continue;
          }
          // Deflect if near player
          const dx = b.x - (player.x + PLAYER_W / 2);
          const dy = b.y - (player.y + PLAYER_H / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 30) {
            spawnSpark(b.x, b.y);
            enemyBullets.splice(i, 1);
          }
        }
      }

      // Enemy-player collision (swooping birds)
      if (!shieldActive) {
        for (const e of enemies) {
          if (!e.alive || e.type === 'boss') continue;
          const ex = e.x - e.w / 2;
          const ey = e.y - e.h / 2;
          if (ex < player.x + PLAYER_W && ex + e.w > player.x &&
              ey < player.y + PLAYER_H && ey + e.h > player.y) {
            e.alive = false;
            score += Math.floor(e.points / 2);
            scoreEl.textContent = score;
            spawnExplosion(e.x, e.y, getEnemyColor(e), 8);
            playerHit();
            if (gameState === 'over') return;
          }
        }
      }

      // Update particles
      updateParticles();

      // Update gameData for ML
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        shieldActive,
        shieldUses,
        enemyCount: aliveEnemies.length,
        wave,
        cycle
      };
    }

    // -- Boss Logic --
    function updateBoss(boss) {
      boss.phase += 0.01;
      boss.shieldAngle += 0.02 + cycle * 0.005;

      // Move side to side
      boss.x = W / 2 + Math.sin(boss.phase) * (W / 3 - boss.w / 2);
      boss.y = 80 + Math.sin(boss.phase * 0.7) * 20;

      // Shoot periodically
      boss.shootTimer++;
      const shootInterval = Math.max(30, 60 - cycle * 10);
      if (boss.shootTimer >= shootInterval) {
        boss.shootTimer = 0;
        // Aimed shot
        const dx = player.x + PLAYER_W / 2 - boss.x;
        const dy = player.y - boss.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const speed = 3.5 + cycle * 0.5;
        enemyBullets.push({
          x: boss.x, y: boss.y + boss.h / 2,
          vx: dx / dist * speed,
          vy: dy / dist * speed
        });
        // Spread shots
        if (boss.shootTimer === 0) {
          for (let a = -0.3; a <= 0.3; a += 0.3) {
            enemyBullets.push({
              x: boss.x, y: boss.y + boss.h / 2,
              vx: (dx / dist * speed) + a * speed,
              vy: dy / dist * speed
            });
          }
        }
      }

      // Check if shield is fully destroyed
      boss.alienVisible = boss.shieldHp.every(hp => hp <= 0);
    }

    function checkBossHit(boss, bullet, bulletIdx) {
      // Check shield segments first
      const bx = bullet.x - boss.x;
      const by = bullet.y - boss.y;
      const shieldRadius = 55 + cycle * 2;

      // Check if bullet is in shield ring zone
      const dist = Math.sqrt(bx * bx + by * by);
      if (dist >= shieldRadius - 12 && dist <= shieldRadius + 12) {
        // Which segment?
        let angle = Math.atan2(by, bx) - boss.shieldAngle;
        angle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        const segIdx = Math.floor(angle / (Math.PI * 2 / boss.shieldSegments));

        if (segIdx >= 0 && segIdx < boss.shieldSegments && boss.shieldHp[segIdx] > 0) {
          boss.shieldHp[segIdx]--;
          bullets.splice(bulletIdx, 1);
          spawnSpark(bullet.x, bullet.y);
          return true;
        }
      }

      // Check direct hit on boss body (only if gap in shield)
      const hitDist = Math.sqrt(bx * bx + by * by);
      if (hitDist < 35) {
        // Check if there is a gap in the shield at this angle
        let angle = Math.atan2(by, bx) - boss.shieldAngle;
        angle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        const segIdx = Math.floor(angle / (Math.PI * 2 / boss.shieldSegments));
        const adjacent1 = (segIdx + 1) % boss.shieldSegments;
        const adjacent2 = (segIdx - 1 + boss.shieldSegments) % boss.shieldSegments;

        // Only hit if this segment and at least one neighbor are destroyed
        if (boss.shieldHp[segIdx] <= 0 || boss.shieldHp[adjacent1] <= 0 || boss.shieldHp[adjacent2] <= 0) {
          boss.hp--;
          bullets.splice(bulletIdx, 1);
          spawnSpark(boss.x + bx * 0.5, boss.y + by * 0.5);
          score += 5;
          scoreEl.textContent = score;
          if (score > best) best = score;
          if (boss.hp <= 0) {
            boss.alive = false;
            score += boss.points;
            scoreEl.textContent = score;
            if (score > best) best = score;
            spawnExplosion(boss.x, boss.y, '#f92', 30);
            spawnExplosion(boss.x - 30, boss.y + 10, '#ff0', 15);
            spawnExplosion(boss.x + 30, boss.y - 10, '#f44', 15);
          }
          return true;
        }
      }

      return false;
    }

    function playerHit() {
      lives--;
      livesEl.textContent = lives;
      spawnExplosion(player.x + PLAYER_W / 2, player.y, '#f62', 15);
      if (lives <= 0) {
        gameOver();
      } else {
        // Brief invincibility
        shieldActive = true;
        shieldTimer = 60;
      }
    }

    function activateShield() {
      if (shieldUses > 0 && !shieldActive) {
        shieldUses--;
        shieldsEl.textContent = shieldUses;
        shieldActive = true;
        shieldTimer = SHIELD_DURATION;
      }
    }

    function getEnemyColor(e) {
      switch (e.type) {
        case 'smallBird': return '#f92';
        case 'largeBird': return '#f44';
        case 'phoenixBird': return '#f62';
        case 'boss': return '#fa0';
        default: return '#f62';
      }
    }

    function gameOver() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
      overlayWave.textContent = `Reached Wave ${wave}`;
    }

    // -- Drawing --
    function drawFrame() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Stars
      drawStars();

      // Enemies
      for (const e of enemies) {
        if (!e.alive) continue;
        if (e.type === 'smallBird') drawSmallBird(e);
        else if (e.type === 'largeBird') drawLargeBird(e);
        else if (e.type === 'phoenixBird') drawPhoenixBird(e);
        else if (e.type === 'boss') drawBoss(e);
      }

      // Enemy bullets
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      for (const b of enemyBullets) {
        ctx.fillStyle = '#f44';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Player bullets
      ctx.fillStyle = '#f92';
      ctx.shadowColor = '#f92';
      ctx.shadowBlur = 8;
      for (const b of bullets) {
        ctx.fillRect(b.x - BULLET_W / 2, b.y, BULLET_W, BULLET_H);
      }
      ctx.shadowBlur = 0;

      // Player
      drawPlayer();

      // Particles
      drawParticles();

      // Shield indicator on canvas
      if (shieldActive) {
        const alpha = (Math.sin(tick * 0.2) * 0.3 + 0.5);
        ctx.strokeStyle = `rgba(255,102,34,${alpha})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#f62';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, 25, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    function drawPlayer() {
      const px = player.x, py = player.y;
      ctx.fillStyle = '#f62';
      ctx.shadowColor = '#f62';
      ctx.shadowBlur = 12;

      // Ship body - pointed triangle
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2, py - 8);
      ctx.lineTo(px, py + PLAYER_H);
      ctx.lineTo(px + PLAYER_W, py + PLAYER_H);
      ctx.closePath();
      ctx.fill();

      // Cockpit
      ctx.fillStyle = '#fa0';
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2, py);
      ctx.lineTo(px + PLAYER_W / 2 - 5, py + 10);
      ctx.lineTo(px + PLAYER_W / 2 + 5, py + 10);
      ctx.closePath();
      ctx.fill();

      // Engine glow
      const flicker = 0.7 + Math.random() * 0.3;
      ctx.fillStyle = `rgba(255,200,50,${flicker})`;
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2 - 6, py + PLAYER_H);
      ctx.lineTo(px + PLAYER_W / 2, py + PLAYER_H + 6 + Math.random() * 4);
      ctx.lineTo(px + PLAYER_W / 2 + 6, py + PLAYER_H);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawSmallBird(e) {
      const x = e.x, y = e.y;
      const wing = Math.sin(e.wingFrame * 3) * 0.4;

      ctx.fillStyle = '#f92';
      ctx.shadowColor = '#f92';
      ctx.shadowBlur = 6;

      // Body
      ctx.beginPath();
      ctx.ellipse(x, y, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.beginPath();
      ctx.moveTo(x - 6, y);
      ctx.lineTo(x - 14, y - 8 + wing * 10);
      ctx.lineTo(x - 10, y + 2);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x + 6, y);
      ctx.lineTo(x + 14, y - 8 + wing * 10);
      ctx.lineTo(x + 10, y + 2);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(x - 4, y - 2, 2, 2);
      ctx.fillRect(x + 2, y - 2, 2, 2);

      // Beak
      ctx.fillStyle = '#ff0';
      ctx.fillRect(x - 1, y + 3, 2, 2);

      ctx.shadowBlur = 0;
    }

    function drawLargeBird(e) {
      const x = e.x, y = e.y;
      const wing = Math.sin(e.wingFrame * 2.5) * 0.5;
      const hpRatio = e.hp / e.maxHp;

      // Color shifts from bright to dim based on HP
      const r = 255;
      const g = Math.floor(60 + hpRatio * 30);
      const b = Math.floor(20 + (1 - hpRatio) * 40);
      const color = `rgb(${r},${g},${b})`;

      ctx.fillStyle = color;
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 8;

      // Body (larger)
      ctx.beginPath();
      ctx.ellipse(x, y, 12, 9, 0, 0, Math.PI * 2);
      ctx.fill();

      // Wings (larger, flapping)
      ctx.beginPath();
      ctx.moveTo(x - 10, y);
      ctx.lineTo(x - 20, y - 12 + wing * 14);
      ctx.lineTo(x - 16, y + 4);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x + 10, y);
      ctx.lineTo(x + 20, y - 12 + wing * 14);
      ctx.lineTo(x + 16, y + 4);
      ctx.closePath();
      ctx.fill();

      // Tail feathers
      ctx.beginPath();
      ctx.moveTo(x - 4, y + 8);
      ctx.lineTo(x, y + 14);
      ctx.lineTo(x + 4, y + 8);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#ff0';
      ctx.beginPath();
      ctx.arc(x - 5, y - 2, 2, 0, Math.PI * 2);
      ctx.arc(x + 5, y - 2, 2, 0, Math.PI * 2);
      ctx.fill();

      // Regen indicator
      if (e.hp < e.maxHp && tick - e.lastHitTick > e.regenDelay) {
        const pulse = Math.sin(tick * 0.1) * 0.3 + 0.5;
        ctx.strokeStyle = `rgba(100,255,100,${pulse})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, 16, 0, Math.PI * 2);
        ctx.stroke();
      }

      // HP bar for multi-hit enemies
      if (e.hp < e.maxHp) {
        const barW = 24;
        ctx.fillStyle = '#400';
        ctx.fillRect(x - barW / 2, y - 16, barW, 3);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(x - barW / 2, y - 16, barW * hpRatio, 3);
      }

      ctx.shadowBlur = 0;
    }

    function drawPhoenixBird(e) {
      const x = e.x, y = e.y;
      const wing = Math.sin(e.wingFrame * 2) * 0.6;
      const hpRatio = e.hp / e.maxHp;

      // Fiery color palette
      const flame = Math.sin(tick * 0.15 + e.phase) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255,${Math.floor(60 + flame * 100)},${Math.floor(flame * 30)},1)`;
      ctx.shadowColor = '#f62';
      ctx.shadowBlur = 12;

      // Large body
      ctx.beginPath();
      ctx.ellipse(x, y, 15, 11, 0, 0, Math.PI * 2);
      ctx.fill();

      // Grand wings
      ctx.beginPath();
      ctx.moveTo(x - 12, y - 2);
      ctx.lineTo(x - 22, y - 16 + wing * 16);
      ctx.lineTo(x - 18, y - 6 + wing * 8);
      ctx.lineTo(x - 24, y - 10 + wing * 12);
      ctx.lineTo(x - 14, y + 4);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x + 12, y - 2);
      ctx.lineTo(x + 22, y - 16 + wing * 16);
      ctx.lineTo(x + 18, y - 6 + wing * 8);
      ctx.lineTo(x + 24, y - 10 + wing * 12);
      ctx.lineTo(x + 14, y + 4);
      ctx.closePath();
      ctx.fill();

      // Tail plume (fiery)
      ctx.fillStyle = `rgba(255,${Math.floor(150 + flame * 80)},0,${0.6 + flame * 0.4})`;
      ctx.beginPath();
      ctx.moveTo(x - 5, y + 10);
      ctx.lineTo(x - 8, y + 20 + Math.sin(tick * 0.08 + e.phase) * 4);
      ctx.lineTo(x, y + 16);
      ctx.lineTo(x + 8, y + 20 + Math.sin(tick * 0.08 + e.phase + 1) * 4);
      ctx.lineTo(x + 5, y + 10);
      ctx.closePath();
      ctx.fill();

      // Head crest
      ctx.fillStyle = '#fa0';
      ctx.beginPath();
      ctx.moveTo(x, y - 10);
      ctx.lineTo(x - 3, y - 16);
      ctx.lineTo(x + 3, y - 16);
      ctx.closePath();
      ctx.fill();

      // Eyes (glowing)
      ctx.fillStyle = '#ff0';
      ctx.shadowColor = '#ff0';
      ctx.shadowBlur = 5;
      ctx.beginPath();
      ctx.arc(x - 6, y - 3, 2.5, 0, Math.PI * 2);
      ctx.arc(x + 6, y - 3, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Regen indicator
      if (e.hp < e.maxHp && tick - e.lastHitTick > e.regenDelay) {
        const pulse = Math.sin(tick * 0.15) * 0.4 + 0.6;
        ctx.strokeStyle = `rgba(255,200,0,${pulse})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 22, 0, Math.PI * 2);
        ctx.stroke();
        // Fire particles when regenerating
        if (tick % 4 === 0) {
          particles.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 16,
            vx: (Math.random() - 0.5) * 1,
            vy: -1 - Math.random() * 2,
            life: 10 + Math.random() * 8,
            maxLife: 18,
            color: '#fa0'
          });
        }
      }

      // HP bar
      if (e.maxHp > 1) {
        const barW = 30;
        ctx.fillStyle = '#400';
        ctx.fillRect(x - barW / 2, y - 22, barW, 3);
        ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : hpRatio > 0.25 ? '#ff0' : '#f44';
        ctx.fillRect(x - barW / 2, y - 22, barW * hpRatio, 3);
      }

      ctx.shadowBlur = 0;
    }

    function drawBoss(boss) {
      const bx = boss.x, by = boss.y;
      const hpRatio = boss.hp / boss.maxHp;

      // -- Rotating shield --
      const shieldRadius = 55 + cycle * 2;
      const segAngle = (Math.PI * 2) / boss.shieldSegments;

      for (let i = 0; i < boss.shieldSegments; i++) {
        if (boss.shieldHp[i] <= 0) continue;

        const a1 = boss.shieldAngle + i * segAngle;
        const a2 = a1 + segAngle * 0.85; // gap between segments

        const maxSegHp = Math.ceil(3 * (1 + cycle * 0.5));
        const segRatio = boss.shieldHp[i] / maxSegHp;
        const r = Math.floor(100 + segRatio * 155);
        const g = Math.floor(segRatio * 150);
        const b = Math.floor(segRatio * 60);

        ctx.strokeStyle = `rgb(${r},${g},${b})`;
        ctx.lineWidth = 6;
        ctx.shadowColor = `rgba(${r},${g},${b},0.8)`;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(bx, by, shieldRadius, a1, a2);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;

      // -- Mothership body --
      const pulse = Math.sin(tick * 0.04) * 0.2 + 0.8;

      // Main saucer
      ctx.fillStyle = `rgba(80,40,120,${pulse})`;
      ctx.shadowColor = '#a4f';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.ellipse(bx, by, boss.w / 2, boss.h / 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Dome
      ctx.fillStyle = `rgba(120,60,180,${pulse})`;
      ctx.beginPath();
      ctx.ellipse(bx, by - 8, 30, 20, 0, Math.PI, 0);
      ctx.fill();

      // Lights around rim
      for (let i = 0; i < 8; i++) {
        const la = (Math.PI * 2 / 8) * i + tick * 0.05;
        const lx = bx + Math.cos(la) * (boss.w / 2 - 5);
        const ly = by + Math.sin(la) * (boss.h / 3 - 3);
        const blink = Math.sin(tick * 0.12 + i * 0.8) > 0;
        ctx.fillStyle = blink ? '#f62' : '#631';
        ctx.beginPath();
        ctx.arc(lx, ly, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Alien inside (visible when shield breached)
      if (boss.alienVisible) {
        const aGlow = Math.sin(tick * 0.08) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(0,255,0,${aGlow})`;
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 10;
        // Alien head
        ctx.beginPath();
        ctx.ellipse(bx, by - 5, 10, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(bx - 4, by - 7, 3, 4, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(bx + 4, by - 7, 3, 4, 0.2, 0, Math.PI * 2);
        ctx.fill();
      }

      // HP bar
      const barW = 80;
      ctx.fillStyle = '#400';
      ctx.fillRect(bx - barW / 2, by - boss.h / 2 - 14, barW, 5);
      ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : hpRatio > 0.25 ? '#ff0' : '#f44';
      ctx.fillRect(bx - barW / 2, by - boss.h / 2 - 14, barW * hpRatio, 5);

      ctx.shadowBlur = 0;
    }

    // -- Input --
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Shift'].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        startGame();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      keys[e.key] = true;

      if (gameState === 'playing') {
        if (e.key === ' ' && shootCooldown <= 0 && bullets.length < MAX_BULLETS) {
          bullets.push({ x: player.x + PLAYER_W / 2, y: player.y });
          shootCooldown = 8;
        }
        if (e.key === 'Shift') {
          activateShield();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Competitive Minesweeper</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f84; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 68, 0.5); }
    h1 { color: #f84; font-size: 1.4rem; text-shadow: 0 0 15px rgba(255, 136, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f84; }
    canvas {
      border: 2px solid #f84;
      box-shadow: 0 0 20px rgba(255, 136, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    canvas.no-cursor { cursor: default; }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f84;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 136, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>COMPETITIVE MINESWEEPER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">COMPETITIVE MINESWEEPER</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let best = parseInt(localStorage.getItem('compMinesweeper_best') || '0');
    bestEl.textContent = best;

    // Board config
    const COLS = 10, ROWS = 10, MINES = 15;
    const CELL = 18;
    const GAP = 2;
    const BOARD_W = COLS * (CELL + GAP) + GAP;
    const BOARD_H = ROWS * (CELL + GAP) + GAP;
    const BOARD_LEFT_X = 14;
    const BOARD_RIGHT_X = W - BOARD_W - 14;
    const BOARD_Y = 62;

    // Timer
    const TOTAL_TIME = 120;
    let timeLeft = TOTAL_TIME;
    let lastTick = 0;
    let countdown = 0;
    let countdownStart = 0;

    // Boards
    let playerBoard = null;
    let aiBoard = null;
    let playerCellsLeft = 0;
    let aiCellsLeft = 0;
    let playerMineHits = 0;
    let aiMineHits = 0;
    let playerFlags = 0;
    let aiFlags = 0;

    // AI
    let aiTimer = 0;
    let aiDelay = 0;
    let aiFirstMove = true;

    // Number colors (standard minesweeper)
    const NUM_COLORS = [
      '', '#4488ff', '#44aa44', '#ee4444', '#8844aa',
      '#aa4422', '#44aaaa', '#222222', '#888888'
    ];

    // ------ Board creation ------
    function createBoard() {
      const board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = [];
        for (let c = 0; c < COLS; c++) {
          board[r][c] = {
            mine: false,
            revealed: false,
            flagged: false,
            adjacent: 0,
            exploded: false
          };
        }
      }
      return board;
    }

    function placeMines(board, excludeR, excludeC) {
      let placed = 0;
      while (placed < MINES) {
        const r = Math.floor(Math.random() * ROWS);
        const c = Math.floor(Math.random() * COLS);
        if (board[r][c].mine) continue;
        if (Math.abs(r - excludeR) <= 1 && Math.abs(c - excludeC) <= 1) continue;
        board[r][c].mine = true;
        placed++;
      }
      // Calculate adjacency
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c].mine) continue;
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr, nc = c + dc;
              if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc].mine) count++;
            }
          }
          board[r][c].adjacent = count;
        }
      }
    }

    function countUnrevealed(board) {
      let count = 0;
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (!board[r][c].revealed && !board[r][c].mine) count++;
      return count;
    }

    function countFlags(board) {
      let count = 0;
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (board[r][c].flagged) count++;
      return count;
    }

    // ------ Reveal logic ------
    function revealCell(board, r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return 0;
      const cell = board[r][c];
      if (cell.revealed || cell.flagged) return 0;

      cell.revealed = true;
      let cleared = cell.mine ? 0 : 1;

      if (cell.mine) {
        cell.exploded = true;
        return -1;
      }

      // Cascade for 0-cells
      if (cell.adjacent === 0) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const result = revealCell(board, r + dr, c + dc);
            if (result > 0) cleared += result;
          }
        }
      }
      return cleared;
    }

    // ------ Drawing ------
    function drawRaisedCell(cx, cy, baseColor) {
      ctx.fillStyle = '#2a2a4e';
      ctx.fillRect(cx, cy, CELL, CELL);
      ctx.fillStyle = '#3a3a6e';
      ctx.fillRect(cx, cy, CELL, 2);
      ctx.fillRect(cx, cy, 2, CELL);
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(cx, cy + CELL - 2, CELL, 2);
      ctx.fillRect(cx + CELL - 2, cy, 2, CELL);
      ctx.fillStyle = baseColor;
      ctx.fillRect(cx + 2, cy + 2, CELL - 4, CELL - 4);
    }

    function drawBoard(board, bx, by, label, cellsLeft, flags, mineHits, isPlayer) {
      const themeColor = isPlayer ? '#f84' : '#e66';
      const dimColor = isPlayer ? 'rgba(255,136,68,0.25)' : 'rgba(230,102,102,0.25)';

      // Label
      ctx.save();
      ctx.font = 'bold 14px Courier New';
      ctx.fillStyle = themeColor;
      ctx.shadowColor = themeColor;
      ctx.shadowBlur = 8;
      ctx.textAlign = 'center';
      ctx.fillText(label, bx + BOARD_W / 2, by - 30);
      ctx.shadowBlur = 0;

      // Stats line
      ctx.font = '11px Courier New';
      ctx.fillStyle = '#aaa';
      ctx.fillText('Left:' + cellsLeft + ' Flags:' + flags + '/' + MINES + ' Hits:' + mineHits, bx + BOARD_W / 2, by - 14);
      ctx.restore();

      // Board background
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(bx - 1, by - 1, BOARD_W + 2, BOARD_H + 2);

      // Cells
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          const cx = bx + GAP + c * (CELL + GAP);
          const cy = by + GAP + r * (CELL + GAP);

          if (cell.revealed) {
            if (cell.exploded) {
              ctx.fillStyle = '#ff2222';
              ctx.fillRect(cx, cy, CELL, CELL);
              ctx.fillStyle = '#111';
              ctx.font = 'bold 13px Courier New';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('\u2738', cx + CELL / 2, cy + CELL / 2 + 1);
            } else if (cell.mine) {
              // Revealed mine at end of game (not exploded)
              ctx.fillStyle = '#333';
              ctx.fillRect(cx, cy, CELL, CELL);
              ctx.fillStyle = '#999';
              ctx.font = 'bold 12px Courier New';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('\u2738', cx + CELL / 2, cy + CELL / 2 + 1);
            } else {
              ctx.fillStyle = '#1a1a2e';
              ctx.fillRect(cx, cy, CELL, CELL);
              ctx.strokeStyle = '#2a2a4e';
              ctx.strokeRect(cx + 0.5, cy + 0.5, CELL - 1, CELL - 1);

              if (cell.adjacent > 0) {
                ctx.fillStyle = NUM_COLORS[cell.adjacent] || '#888';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(String(cell.adjacent), cx + CELL / 2, cy + CELL / 2 + 1);
              }
            }
          } else if (cell.flagged) {
            drawRaisedCell(cx, cy, dimColor);
            ctx.fillStyle = '#ff4444';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('\u2691', cx + CELL / 2, cy + CELL / 2 + 1);
          } else {
            drawRaisedCell(cx, cy, dimColor);
          }
        }
      }
    }

    function drawTimer() {
      const centerX = W / 2;
      const timerY = 38;

      ctx.save();
      ctx.font = 'bold 24px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const mins = Math.floor(Math.max(0, timeLeft) / 60);
      const secs = Math.floor(Math.max(0, timeLeft) % 60);
      const timeStr = String(mins) + ':' + String(secs).padStart(2, '0');

      let timerColor = '#f84';
      if (timeLeft <= 10) timerColor = '#ff2222';
      else if (timeLeft <= 30) timerColor = '#ffaa22';

      ctx.fillStyle = timerColor;
      ctx.shadowColor = timerColor;
      ctx.shadowBlur = 12;
      ctx.fillText(timeStr, centerX, timerY);
      ctx.shadowBlur = 0;

      ctx.font = '10px Courier New';
      ctx.fillStyle = '#666';
      ctx.fillText('TIME', centerX, timerY - 18);
      ctx.restore();
    }

    function drawMiddleDivider() {
      const cx = W / 2;
      ctx.save();
      ctx.strokeStyle = '#333';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(cx, BOARD_Y - 35);
      ctx.lineTo(cx, BOARD_Y + BOARD_H + 5);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawCountdown() {
      ctx.save();
      const elapsed = (Date.now() - countdownStart) / 1000;
      const num = 3 - Math.floor(elapsed);
      if (num <= 0) {
        ctx.restore();
        return;
      }

      ctx.fillStyle = 'rgba(26, 26, 46, 0.7)';
      ctx.fillRect(0, 0, W, H);

      ctx.font = 'bold 80px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f84';
      ctx.shadowColor = '#f84';
      ctx.shadowBlur = 30;
      ctx.fillText(String(num), W / 2, H / 2);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'waiting') return;

      drawBoard(playerBoard, BOARD_LEFT_X, BOARD_Y, 'PLAYER', playerCellsLeft, playerFlags, playerMineHits, true);
      drawBoard(aiBoard, BOARD_RIGHT_X, BOARD_Y, 'AI', aiCellsLeft, aiFlags, aiMineHits, false);

      drawMiddleDivider();
      drawTimer();

      // VS label
      ctx.save();
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#555';
      ctx.fillText('VS', W / 2, BOARD_Y + BOARD_H + 16);
      ctx.restore();

      if (countdown > 0) {
        drawCountdown();
      }
    }

    // ------ AI Logic ------
    function aiThink() {
      if (gameState !== 'playing' || countdown > 0) return;
      if (aiCellsLeft <= 0) return;

      // Build probability map
      const prob = [];
      for (let r = 0; r < ROWS; r++) {
        prob[r] = [];
        for (let c = 0; c < COLS; c++) {
          prob[r][c] = -1;
        }
      }

      let totalUnrevealed = 0;
      let totalUnflaggedMines = MINES - countFlags(aiBoard);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!aiBoard[r][c].revealed && !aiBoard[r][c].flagged) {
            totalUnrevealed++;
          }
        }
      }

      const baseProbability = totalUnflaggedMines / Math.max(1, totalUnrevealed);

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!aiBoard[r][c].revealed && !aiBoard[r][c].flagged) {
            prob[r][c] = baseProbability;
          }
        }
      }

      // Constraint-based reasoning from revealed numbers
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!aiBoard[r][c].revealed || aiBoard[r][c].adjacent === 0) continue;

          const adj = aiBoard[r][c].adjacent;
          let flaggedNeighbors = 0;
          let unrevealedNeighbors = [];

          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr, nc = c + dc;
              if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
              if (aiBoard[nr][nc].flagged) flaggedNeighbors++;
              else if (!aiBoard[nr][nc].revealed) {
                unrevealedNeighbors.push({ r: nr, c: nc });
              }
            }
          }

          const remainingMines = adj - flaggedNeighbors;
          if (unrevealedNeighbors.length === 0) continue;

          if (remainingMines === unrevealedNeighbors.length && remainingMines > 0) {
            for (const n of unrevealedNeighbors) {
              prob[n.r][n.c] = 1.0;
            }
          } else if (remainingMines <= 0) {
            for (const n of unrevealedNeighbors) {
              prob[n.r][n.c] = 0;
            }
          } else {
            const localProb = remainingMines / unrevealedNeighbors.length;
            for (const n of unrevealedNeighbors) {
              if (prob[n.r][n.c] < localProb) {
                prob[n.r][n.c] = localProb;
              }
            }
          }
        }
      }

      // Flag cells with probability 1.0
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (prob[r][c] === 1.0 && !aiBoard[r][c].flagged) {
            aiBoard[r][c].flagged = true;
            aiFlags = countFlags(aiBoard);
            return;
          }
        }
      }

      // Find safest cell
      let safest = null;
      let safestProb = 2;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (prob[r][c] >= 0 && prob[r][c] < 1.0 && !aiBoard[r][c].revealed && !aiBoard[r][c].flagged) {
            if (prob[r][c] < safestProb) {
              safestProb = prob[r][c];
              safest = { r, c };
            }
          }
        }
      }

      if (!safest) {
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (!aiBoard[r][c].revealed && !aiBoard[r][c].flagged) {
              safest = { r, c };
              break;
            }
          }
          if (safest) break;
        }
      }

      if (safest) {
        if (aiFirstMove) {
          placeMines(aiBoard, safest.r, safest.c);
          aiFirstMove = false;
        }
        const result = revealCell(aiBoard, safest.r, safest.c);
        if (result === -1) {
          aiMineHits++;
          timeLeft += 5; // Penalty to AI: player gains 5 seconds
        }
        aiCellsLeft = countUnrevealed(aiBoard);
        aiFlags = countFlags(aiBoard);
      }
    }

    // ------ Input ------
    let playerFirstMove = true;

    canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

    canvas.addEventListener('mousedown', function(e) {
      if (gameState === 'waiting') return;
      if (gameState === 'over') return;
      if (countdown > 0) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      // Check if click is on player board
      const relX = mx - BOARD_LEFT_X - GAP;
      const relY = my - BOARD_Y - GAP;

      if (relX < 0 || relY < 0) return;

      const c = Math.floor(relX / (CELL + GAP));
      const r = Math.floor(relY / (CELL + GAP));

      if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;

      const cellLocalX = relX - c * (CELL + GAP);
      const cellLocalY = relY - r * (CELL + GAP);
      if (cellLocalX > CELL || cellLocalY > CELL) return;

      const cell = playerBoard[r][c];
      if (cell.revealed) return;

      if (e.button === 2) {
        cell.flagged = !cell.flagged;
        playerFlags = countFlags(playerBoard);
        draw();
        return;
      }

      if (e.button === 0) {
        if (cell.flagged) return;

        if (playerFirstMove) {
          placeMines(playerBoard, r, c);
          playerFirstMove = false;
        }

        const result = revealCell(playerBoard, r, c);
        if (result === -1) {
          playerMineHits++;
          timeLeft -= 5;
        }
        playerCellsLeft = countUnrevealed(playerBoard);
        playerFlags = countFlags(playerBoard);

        if (playerCellsLeft <= 0) {
          endGame(true);
          return;
        }

        draw();
      }
    });

    // ------ Overlay click ------
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';
    overlay.addEventListener('click', function() {
      if (gameState === 'waiting' || gameState === 'over') {
        startGame();
      }
    });

    // ------ Game flow ------
    function startGame() {
      overlay.style.display = 'none';
      gameState = 'playing';
      score = 0;
      scoreEl.textContent = '0';
      timeLeft = TOTAL_TIME;
      playerMineHits = 0;
      aiMineHits = 0;
      playerFlags = 0;
      aiFlags = 0;
      playerFirstMove = true;
      aiFirstMove = true;

      playerBoard = createBoard();
      aiBoard = createBoard();

      playerCellsLeft = ROWS * COLS - MINES;
      aiCellsLeft = ROWS * COLS - MINES;

      countdown = 3;
      countdownStart = Date.now();
      lastTick = 0;

      aiTimer = 0;
      aiDelay = 400 + Math.random() * 200;

      canvas.classList.remove('no-cursor');
      draw();
    }

    function endGame(playerWon) {
      gameState = 'over';
      canvas.classList.add('no-cursor');

      const cellsCleared = (ROWS * COLS - MINES) - playerCellsLeft;
      const timeBonus = Math.max(0, Math.floor(timeLeft));
      const penaltyLoss = playerMineHits * 10;

      if (playerWon) {
        score = cellsCleared * 10 + timeBonus * 5 - penaltyLoss;
      } else {
        score = cellsCleared * 5 - penaltyLoss;
      }
      score = Math.max(0, score);
      scoreEl.textContent = score;

      if (score > best) {
        best = score;
        bestEl.textContent = best;
        localStorage.setItem('compMinesweeper_best', String(best));
      }

      revealAllMines(playerBoard);
      revealAllMines(aiBoard);
      draw();

      overlayTitle.textContent = playerWon ? 'YOU WIN!' : (aiCellsLeft <= 0 ? 'AI WINS!' : 'TIME UP!');
      overlayText.textContent = 'Score: ' + score + ' | Click to Play Again';
      overlay.style.display = 'flex';
    }

    function revealAllMines(board) {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c].mine && !board[r][c].revealed) {
            board[r][c].revealed = true;
          }
        }
      }
    }

    // ------ Main loop ------
    function gameLoop(timestamp) {
      requestAnimationFrame(gameLoop);

      if (gameState !== 'playing') return;

      if (countdown > 0) {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 3) {
          countdown = 0;
          lastTick = timestamp;
        }
        draw();
        return;
      }

      if (lastTick === 0) lastTick = timestamp;
      const dt = (timestamp - lastTick) / 1000;
      lastTick = timestamp;

      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame(false);
        return;
      }

      aiTimer += dt * 1000;
      if (aiTimer >= aiDelay) {
        aiTimer -= aiDelay;
        aiDelay = 300 + Math.random() * 300;
        aiThink();

        if (aiCellsLeft <= 0) {
          endGame(false);
          return;
        }
      }

      draw();
    }

    // ------ Init ------
    draw();
    requestAnimationFrame(gameLoop);

    // Expose game data for recorder
    window.gameData = {};
    function updateGameData() {
      window.gameData = { gameState, score };
    }
    setInterval(updateGameData, 500);
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

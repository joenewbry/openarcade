<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puzzle Bobble</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #8fd; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 255, 221, 0.5); }
    h1 { color: #8fd; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 255, 221, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8fd; }
    canvas {
      border: 2px solid #8fd;
      box-shadow: 0 0 20px rgba(136, 255, 221, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8fd;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PUZZLE BOBBLE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="560"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:560px;">
      <h2 id="overlayTitle">PUZZLE BOBBLE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Grid Constants ---
    const BUBBLE_R = 15;
    const BUBBLE_D = BUBBLE_R * 2;
    const COLS = 12;          // columns in a non-offset row
    const COLS_ODD = COLS - 1; // columns in an offset (shifted) row
    const ROW_H = BUBBLE_D * 0.866; // vertical spacing for hex packing
    const GRID_LEFT = (W - COLS * BUBBLE_D) / 2 + BUBBLE_R;
    const GRID_TOP = BUBBLE_R + 8;
    const LAUNCHER_X = W / 2;
    const LAUNCHER_Y = H - 44;
    const SHOOT_SPEED = 11;
    const MIN_ANGLE = Math.PI * 0.06;
    const MAX_ANGLE = Math.PI * 0.94;
    const AIM_SPEED = 0.028;
    const DANGER_Y = LAUNCHER_Y - BUBBLE_D * 3;
    const PUSH_FRAMES_START = 1100;
    const PUSH_FRAMES_MIN = 400;

    const COLORS = ['#f44', '#4f4', '#44f', '#ff0', '#f0f', '#f80'];

    // --- Game variables (recorder contract) ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;

    // Game state
    let level;
    // Each row in `rows` is { shifted: bool, cells: [colorIdx|null, ...] }
    // shifted=false means COLS cells (flush left), shifted=true means COLS_ODD cells (offset right by BUBBLE_R)
    let rows;
    let aimAngle, currentColor, nextColor;
    let flyingBubble, popAnims, fallAnims;
    let pushTimer, pushFrames, canShoot;
    let keys = {};

    // --- Grid helpers ---
    function rowCols(r) { return rows[r].shifted ? COLS_ODD : COLS; }

    function cellX(r, c) {
      return GRID_LEFT + c * BUBBLE_D + (rows[r].shifted ? BUBBLE_R : 0);
    }

    function cellY(r) {
      return GRID_TOP + r * ROW_H;
    }

    function hexNeighbors(r, c) {
      const out = [];
      const shifted = rows[r].shifted;
      // Same row left/right
      if (c > 0) out.push([r, c - 1]);
      if (c < rowCols(r) - 1) out.push([r, c + 1]);
      // Rows above (r-1) and below (r+1)
      for (const dr of [-1, 1]) {
        const nr = r + dr;
        if (nr < 0 || nr >= rows.length) continue;
        const nShifted = rows[nr].shifted;
        const nCols = rows[nr].shifted ? COLS_ODD : COLS;
        if (shifted && !nShifted) {
          // Current shifted, neighbor not shifted: neighbors at c and c+1
          if (c >= 0 && c < nCols) out.push([nr, c]);
          if (c + 1 >= 0 && c + 1 < nCols) out.push([nr, c + 1]);
        } else if (!shifted && nShifted) {
          // Current not shifted, neighbor shifted: neighbors at c-1 and c
          if (c - 1 >= 0 && c - 1 < nCols) out.push([nr, c - 1]);
          if (c >= 0 && c < nCols) out.push([nr, c]);
        } else {
          // Same shift state (shouldn't happen in a proper hex grid, but handle it)
          if (c > 0 && c - 1 < nCols) out.push([nr, c - 1]);
          if (c < nCols) out.push([nr, c]);
        }
      }
      return out;
    }

    // BFS to find same-color cluster
    function floodColor(startR, startC, color) {
      const visited = new Set();
      const k = (r, c) => r * 100 + c;
      visited.add(k(startR, startC));
      const queue = [[startR, startC]];
      const result = [[startR, startC]];
      while (queue.length) {
        const [cr, cc] = queue.shift();
        for (const [nr, nc] of hexNeighbors(cr, cc)) {
          const key = k(nr, nc);
          if (visited.has(key)) continue;
          if (nr < 0 || nr >= rows.length) continue;
          if (nc < 0 || nc >= rows[nr].cells.length) continue;
          if (rows[nr].cells[nc] !== color) continue;
          visited.add(key);
          queue.push([nr, nc]);
          result.push([nr, nc]);
        }
      }
      return result;
    }

    // BFS from ceiling to find connected bubbles, return list of NOT connected
    function findFloating() {
      const connected = new Set();
      const queue = [];
      const k = (r, c) => r * 100 + c;
      if (rows.length > 0) {
        for (let c = 0; c < rows[0].cells.length; c++) {
          if (rows[0].cells[c] !== null) {
            connected.add(k(0, c));
            queue.push([0, c]);
          }
        }
      }
      while (queue.length) {
        const [cr, cc] = queue.shift();
        for (const [nr, nc] of hexNeighbors(cr, cc)) {
          const key = k(nr, nc);
          if (connected.has(key)) continue;
          if (nr < 0 || nr >= rows.length) continue;
          if (nc < 0 || nc >= rows[nr].cells.length) continue;
          if (rows[nr].cells[nc] === null) continue;
          connected.add(key);
          queue.push([nr, nc]);
        }
      }
      const floating = [];
      for (let r = 0; r < rows.length; r++) {
        for (let c = 0; c < rows[r].cells.length; c++) {
          if (rows[r].cells[c] !== null && !connected.has(k(r, c))) {
            floating.push([r, c]);
          }
        }
      }
      return floating;
    }

    function gridEmpty() {
      for (let r = 0; r < rows.length; r++)
        for (let c = 0; c < rows[r].cells.length; c++)
          if (rows[r].cells[c] !== null) return false;
      return true;
    }

    function trimRows() {
      while (rows.length > 0 && rows[rows.length - 1].cells.every(v => v === null)) rows.pop();
    }

    function checkGameOver() {
      for (let r = 0; r < rows.length; r++) {
        for (let c = 0; c < rows[r].cells.length; c++) {
          if (rows[r].cells[c] !== null && cellY(r) + BUBBLE_R >= DANGER_Y) {
            gameOver();
            return true;
          }
        }
      }
      return false;
    }

    // --- Init / levels ---
    function init() {
      score = 0;
      level = 1;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      rows = [];
      aimAngle = Math.PI / 2;
      flyingBubble = null;
      popAnims = [];
      fallAnims = [];
      pushTimer = 0;
      pushFrames = PUSH_FRAMES_START;
      canShoot = true;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PUZZLE BOBBLE';
      overlayText.textContent = 'Press SPACE to start';
      buildLevel();
      currentColor = pickColor();
      nextColor = pickColor();
      draw();
    }

    function buildLevel() {
      rows = [];
      const numRows = 3 + Math.min(level, 5);
      const numColors = Math.min(2 + level, COLORS.length);
      for (let r = 0; r < numRows; r++) {
        const shifted = r % 2 === 1;
        const nc = shifted ? COLS_ODD : COLS;
        const cells = [];
        for (let c = 0; c < nc; c++) {
          cells.push(Math.floor(Math.random() * numColors));
        }
        rows.push({ shifted, cells });
      }
    }

    function pickColor() {
      const onGrid = new Set();
      for (let r = 0; r < rows.length; r++)
        for (let c = 0; c < rows[r].cells.length; c++)
          if (rows[r].cells[c] !== null) onGrid.add(rows[r].cells[c]);
      if (onGrid.size === 0) return Math.floor(Math.random() * Math.min(2 + level, COLORS.length));
      const arr = [...onGrid];
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) { best = score; bestEl.textContent = best; }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function advanceLevel() {
      level++;
      levelEl.textContent = level;
      pushFrames = Math.max(PUSH_FRAMES_MIN, PUSH_FRAMES_START - (level - 1) * 80);
      score += level * 100;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
      buildLevel();
      flyingBubble = null;
      popAnims = [];
      fallAnims = [];
      pushTimer = 0;
      canShoot = true;
      currentColor = pickColor();
      nextColor = pickColor();
    }

    // --- Shooting ---
    function shoot() {
      if (!canShoot || flyingBubble) return;
      canShoot = false;
      flyingBubble = {
        x: LAUNCHER_X,
        y: LAUNCHER_Y - BUBBLE_R - 6,
        vx: Math.cos(aimAngle) * SHOOT_SPEED,
        vy: -Math.sin(aimAngle) * SHOOT_SPEED,
        color: currentColor
      };
      currentColor = nextColor;
      nextColor = pickColor();
    }

    // Snap position to nearest empty cell in the grid
    function snapToGrid(bx, by) {
      let bestR = 0, bestC = 0, bestD = Infinity;
      const maxR = Math.max(rows.length + 1, 1);
      for (let r = 0; r < maxR; r++) {
        // For rows beyond the grid, infer shift from alternating pattern
        let shifted, nc;
        if (r < rows.length) {
          shifted = rows[r].shifted;
          nc = rows[r].cells.length;
        } else {
          // Next row alternates from the last row's shift
          shifted = rows.length > 0 ? !rows[rows.length - 1].shifted : false;
          if (r > rows.length) shifted = !shifted; // alternate further
          nc = shifted ? COLS_ODD : COLS;
        }
        for (let c = 0; c < nc; c++) {
          // Only empty cells
          if (r < rows.length && c < rows[r].cells.length && rows[r].cells[c] !== null) continue;
          const px = GRID_LEFT + c * BUBBLE_D + (shifted ? BUBBLE_R : 0);
          const py = GRID_TOP + r * ROW_H;
          const dx = bx - px, dy = by - py;
          const d = dx * dx + dy * dy;
          if (d < bestD) { bestD = d; bestR = r; bestC = c; }
        }
      }
      return { row: bestR, col: bestC };
    }

    // Place bubble and resolve matches/drops
    function placeBubble(bx, by, color) {
      const { row, col } = snapToGrid(bx, by);

      // Extend grid rows if needed
      while (rows.length <= row) {
        const prevShifted = rows.length > 0 ? rows[rows.length - 1].shifted : true;
        const shifted = !prevShifted;
        const nc = shifted ? COLS_ODD : COLS;
        rows.push({ shifted, cells: new Array(nc).fill(null) });
      }

      if (col < 0 || col >= rows[row].cells.length) { canShoot = true; return; }

      // If target cell is occupied, find nearest empty neighbor
      if (rows[row].cells[col] !== null) {
        const adj = hexNeighbors(row, col);
        let bestAdj = null, bestAD = Infinity;
        for (const [ar, ac] of adj) {
          // Extend if needed
          while (rows.length <= ar) {
            const ps = rows.length > 0 ? rows[rows.length - 1].shifted : true;
            const s = !ps;
            rows.push({ shifted: s, cells: new Array(s ? COLS_ODD : COLS).fill(null) });
          }
          if (ac < 0 || ac >= rows[ar].cells.length) continue;
          if (rows[ar].cells[ac] !== null) continue;
          const dx = bx - cellX(ar, ac), dy = by - cellY(ar);
          const d = dx * dx + dy * dy;
          if (d < bestAD) { bestAD = d; bestAdj = [ar, ac]; }
        }
        if (!bestAdj) { canShoot = true; return; }
        return placeBubbleAt(bestAdj[0], bestAdj[1], color);
      }

      placeBubbleAt(row, col, color);
    }

    function placeBubbleAt(r, c, color) {
      rows[r].cells[c] = color;

      // Find same-color cluster
      const cluster = floodColor(r, c, color);
      if (cluster.length >= 3) {
        // Pop them
        for (const [mr, mc] of cluster) {
          popAnims.push({ x: cellX(mr, mc), y: cellY(mr), color: COLORS[rows[mr].cells[mc]], t: 0 });
          rows[mr].cells[mc] = null;
        }
        score += cluster.length * 10;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }

        // Drop floating bubbles
        const floaters = findFloating();
        if (floaters.length > 0) {
          for (const [fr, fc] of floaters) {
            fallAnims.push({ x: cellX(fr, fc), y: cellY(fr), vy: 0, color: COLORS[rows[fr].cells[fc]], t: 0 });
            rows[fr].cells[fc] = null;
          }
          score += floaters.length * 20;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
        }

        trimRows();

        if (gridEmpty()) {
          setTimeout(() => { if (gameState === 'playing') advanceLevel(); }, 400);
        }
      }

      if (gameState === 'playing' && !checkGameOver()) {
        pushTimer = 0;
      }

      canShoot = true;
    }

    // Push a new row from the top
    function pushRow() {
      // New row at top has opposite shift from current row 0
      const shifted = rows.length > 0 ? !rows[0].shifted : false;
      const nc = shifted ? COLS_ODD : COLS;
      const numColors = Math.min(2 + level, COLORS.length);
      const cells = [];
      for (let i = 0; i < nc; i++) cells.push(Math.floor(Math.random() * numColors));
      rows.unshift({ shifted, cells });
      // No need to adjust other rows -- their shift values are stored, not derived
      checkGameOver();
    }

    // --- Update ---
    function update() {
      if (keys['ArrowLeft']) aimAngle = Math.min(MAX_ANGLE, aimAngle + AIM_SPEED);
      if (keys['ArrowRight']) aimAngle = Math.max(MIN_ANGLE, aimAngle - AIM_SPEED);

      // Flying bubble physics
      if (flyingBubble) {
        flyingBubble.x += flyingBubble.vx;
        flyingBubble.y += flyingBubble.vy;

        // Wall bounce
        if (flyingBubble.x - BUBBLE_R < 0) {
          flyingBubble.x = BUBBLE_R;
          flyingBubble.vx = -flyingBubble.vx;
        }
        if (flyingBubble.x + BUBBLE_R > W) {
          flyingBubble.x = W - BUBBLE_R;
          flyingBubble.vx = -flyingBubble.vx;
        }

        // Ceiling
        if (flyingBubble.y - BUBBLE_R <= GRID_TOP) {
          placeBubble(flyingBubble.x, Math.max(flyingBubble.y, GRID_TOP), flyingBubble.color);
          flyingBubble = null;
          return;
        }

        // Hit grid bubbles
        let hit = false;
        for (let r = 0; r < rows.length && !hit; r++) {
          for (let c = 0; c < rows[r].cells.length && !hit; c++) {
            if (rows[r].cells[c] === null) continue;
            const gx = cellX(r, c), gy = cellY(r);
            const dx = flyingBubble.x - gx, dy = flyingBubble.y - gy;
            if (dx * dx + dy * dy < BUBBLE_D * BUBBLE_D * 0.82) {
              placeBubble(flyingBubble.x, flyingBubble.y, flyingBubble.color);
              flyingBubble = null;
              hit = true;
            }
          }
        }
      }

      // Pop animations
      for (let i = popAnims.length - 1; i >= 0; i--) {
        popAnims[i].t++;
        if (popAnims[i].t > 16) popAnims.splice(i, 1);
      }

      // Fall animations
      for (let i = fallAnims.length - 1; i >= 0; i--) {
        fallAnims[i].vy += 0.5;
        fallAnims[i].y += fallAnims[i].vy;
        fallAnims[i].t++;
        if (fallAnims[i].y > H + 40) fallAnims.splice(i, 1);
      }

      // Push timer
      if (!flyingBubble && canShoot && popAnims.length === 0 && fallAnims.length === 0 && !gridEmpty()) {
        pushTimer++;
        if (pushTimer >= pushFrames) {
          pushTimer = 0;
          pushRow();
        }
      }
    }

    // --- Drawing ---
    function drawBubble(x, y, colorVal, alpha) {
      const col = typeof colorVal === 'number' ? COLORS[colorVal] : colorVal;
      ctx.save();
      if (alpha !== undefined) ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(x, y, BUBBLE_R - 1, 0, Math.PI * 2);
      ctx.fillStyle = col;
      ctx.shadowColor = col;
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
      // Specular highlight
      ctx.beginPath();
      ctx.arc(x - 3, y - 4, BUBBLE_R * 0.35, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.fill();
      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Play area background
      ctx.fillStyle = '#12122a';
      ctx.fillRect(0, 0, W, DANGER_Y);

      // Ceiling
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GRID_TOP - BUBBLE_R - 2);
      ctx.lineTo(W, GRID_TOP - BUBBLE_R - 2);
      ctx.stroke();

      // Side walls
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0.5, GRID_TOP - BUBBLE_R - 2);
      ctx.lineTo(0.5, DANGER_Y);
      ctx.moveTo(W - 0.5, GRID_TOP - BUBBLE_R - 2);
      ctx.lineTo(W - 0.5, DANGER_Y);
      ctx.stroke();

      // Danger line
      ctx.strokeStyle = 'rgba(255, 68, 68, 0.25)';
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, DANGER_Y);
      ctx.lineTo(W, DANGER_Y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Grid bubbles
      for (let r = 0; r < rows.length; r++) {
        for (let c = 0; c < rows[r].cells.length; c++) {
          if (rows[r].cells[c] === null) continue;
          drawBubble(cellX(r, c), cellY(r), rows[r].cells[c]);
        }
      }

      // Pop animations
      for (const p of popAnims) {
        const prog = p.t / 16;
        const rad = BUBBLE_R * (1 + prog * 0.6);
        ctx.save();
        ctx.globalAlpha = 1 - prog;
        ctx.beginPath();
        ctx.arc(p.x, p.y, rad, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
        for (let i = 0; i < 4; i++) {
          const a = (Math.PI * 2 / 4) * i + prog * 3;
          const d = rad + prog * 18;
          ctx.save();
          ctx.globalAlpha = (1 - prog) * 0.7;
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(p.x + Math.cos(a) * d, p.y + Math.sin(a) * d, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      // Fall animations
      for (const f of fallAnims) {
        drawBubble(f.x, f.y, f.color, Math.max(0, 1 - f.t / 30));
      }

      // Flying bubble
      if (flyingBubble) {
        drawBubble(flyingBubble.x, flyingBubble.y, flyingBubble.color);
      }

      // Launcher area
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, DANGER_Y, W, H - DANGER_Y);

      // Launcher base
      ctx.fillStyle = '#0f3460';
      ctx.beginPath();
      ctx.arc(LAUNCHER_X, LAUNCHER_Y, 22, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#8fd';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Aim guide with bounce preview
      drawAimGuide();

      // Current bubble
      if (currentColor !== undefined && !flyingBubble) {
        drawBubble(LAUNCHER_X, LAUNCHER_Y - BUBBLE_R - 6, currentColor);
      }

      // Next bubble
      if (nextColor !== undefined) {
        ctx.fillStyle = '#666';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('NEXT', LAUNCHER_X + 58, LAUNCHER_Y - 18);
        drawBubble(LAUNCHER_X + 58, LAUNCHER_Y - 2, nextColor, 0.65);
      }

      // Push timer bar
      if (gameState === 'playing' && !gridEmpty()) {
        const prog = pushTimer / pushFrames;
        const bw = 90, bx = LAUNCHER_X - bw / 2, by = LAUNCHER_Y + 22;
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(bx, by, bw, 4);
        const bc = prog > 0.75 ? '#f44' : '#8fd';
        ctx.fillStyle = bc;
        ctx.shadowColor = bc;
        ctx.shadowBlur = 3;
        ctx.fillRect(bx, by, bw * prog, 4);
        ctx.shadowBlur = 0;
      }
    }

    function drawAimGuide() {
      let sx = LAUNCHER_X, sy = LAUNCHER_Y - BUBBLE_R - 6;
      let svx = Math.cos(aimAngle) * SHOOT_SPEED;
      let svy = -Math.sin(aimAngle) * SHOOT_SPEED;

      ctx.save();
      ctx.fillStyle = 'rgba(136, 255, 221, 0.35)';
      for (let i = 0; i < 55; i++) {
        sx += svx;
        sy += svy;
        if (sx - BUBBLE_R < 0) { sx = BUBBLE_R; svx = -svx; }
        if (sx + BUBBLE_R > W) { sx = W - BUBBLE_R; svx = -svx; }
        if (sy - BUBBLE_R <= GRID_TOP) break;
        // Stop at grid bubble
        let hitGrid = false;
        for (let r = 0; r < rows.length && !hitGrid; r++) {
          for (let c = 0; c < rows[r].cells.length && !hitGrid; c++) {
            if (rows[r].cells[c] === null) continue;
            const dx = sx - cellX(r, c), dy = sy - cellY(r);
            if (dx * dx + dy * dy < BUBBLE_D * BUBBLE_D * 0.82) hitGrid = true;
          }
        }
        if (hitGrid) break;
        if (i % 3 === 0) {
          ctx.beginPath();
          ctx.arc(sx, sy, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();

      // Arrow tip
      const tipDist = 48;
      const tx = LAUNCHER_X + Math.cos(aimAngle) * tipDist;
      const ty = LAUNCHER_Y - Math.sin(aimAngle) * tipDist;
      ctx.save();
      ctx.fillStyle = '#8fd';
      ctx.shadowColor = '#8fd';
      ctx.shadowBlur = 6;
      ctx.translate(tx, ty);
      ctx.rotate(-aimAngle + Math.PI / 2);
      ctx.beginPath();
      ctx.moveTo(0, -7);
      ctx.lineTo(-4, 3);
      ctx.lineTo(4, 3);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Input ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing') {
        if (e.key === ' ' || e.key === 'ArrowUp') {
          shoot();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

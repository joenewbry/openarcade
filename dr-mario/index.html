<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dr. Mario</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }
    .back { color: #f4c; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 204, 0.5); }
    h1 { color: #f4c; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 68, 204, 0.4); }
    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .side-panel {
      width: 130px;
    }
    .panel-box {
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      text-align: center;
    }
    .panel-box label {
      display: block;
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }
    .panel-box .value {
      font-size: 1.4rem;
      color: #f4c;
    }
    #nextCanvas {
      display: block;
      margin: 0 auto;
    }
    canvas#game {
      border: 2px solid #f4c;
      box-shadow: 0 0 20px rgba(255, 68, 204, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f4c;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DR. MARIO</h1>
  </div>
  <div class="game-area">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="280" height="544"></canvas>
      <div class="overlay" id="overlay" style="width:280px;height:544px;">
        <h2 id="overlayTitle">DR. MARIO</h2>
        <p id="overlayText">Press any key to start</p>
      </div>
    </div>
    <div class="side-panel">
      <div class="panel-box">
        <label>NEXT</label>
        <canvas id="nextCanvas" width="100" height="60"></canvas>
      </div>
      <div class="panel-box">
        <label>SCORE</label>
        <div class="value" id="score">0</div>
      </div>
      <div class="panel-box">
        <label>LEVEL</label>
        <div class="value" id="level">0</div>
      </div>
      <div class="panel-box">
        <label>VIRUSES</label>
        <div class="value" id="viruses">0</div>
      </div>
      <div class="panel-box">
        <label>BEST</label>
        <div class="value" id="best">0</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nctx = nextCanvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const virusesEl = document.getElementById('viruses');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid dimensions: 8 columns x 16 rows
    const COLS = 8;
    const ROWS = 16;
    const CELL = 32;
    // Offset to center the 8-col grid (256px) in the 280px canvas
    const OX = Math.floor((canvas.width - COLS * CELL) / 2);
    const OY = Math.floor((canvas.height - ROWS * CELL) / 2);

    const COLORS = ['red', 'yellow', 'blue'];
    const COLOR_HEX = {
      red:    '#f44',
      yellow: '#ff0',
      blue:   '#48f'
    };
    const COLOR_GLOW = {
      red:    '#f00',
      yellow: '#ff0',
      blue:   '#00f'
    };
    const COLOR_DARK = {
      red:    '#a22',
      yellow: '#aa0',
      blue:   '#24a'
    };

    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let level, virusCount, totalViruses;
    let board;       // ROWS x COLS, each cell: null or { color, type: 'virus'|'pill' }
    let pill;        // current falling pill: { cells: [{r,c,color}, {r,c,color}], orientation }
    let nextPill;    // preview
    let timer;
    let dropInterval;
    let clearing = false;
    let clearCells = [];
    let clearPhase = 0;
    let chainCount = 0;
    let levelWon = false;

    // --- Initialization ---

    function init() {
      score = 0;
      level = 0;
      scoreEl.textContent = '0';
      levelEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DR. MARIO';
      overlayText.textContent = 'Press any key to start';
      setupLevel();
      draw();
    }

    function setupLevel() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      clearing = false;
      clearCells = [];
      clearPhase = 0;
      chainCount = 0;
      levelWon = false;

      // Place viruses: level 0 = 4 viruses, each subsequent level adds 4, max 84
      totalViruses = Math.min(84, (level + 1) * 4);
      virusCount = totalViruses;

      // Viruses only placed in bottom 12 rows (rows 4-15) to leave room at top
      const virusRows = ROWS - 4; // rows 4 through 15
      let placed = 0;
      let attempts = 0;
      while (placed < totalViruses && attempts < 5000) {
        attempts++;
        const r = 4 + Math.floor(Math.random() * virusRows);
        const c = Math.floor(Math.random() * COLS);
        if (board[r][c]) continue;

        const color = COLORS[Math.floor(Math.random() * 3)];

        // Check: would placing this virus immediately create a match of 3+ in a row?
        // (we check 3 because placing this one would be the 3rd — we want to avoid any
        //  pre-existing runs of 3+ so the game starts clean)
        if (wouldCreateRun(r, c, color, 3)) continue;

        board[r][c] = { color, type: 'virus' };
        placed++;
      }

      virusCount = placed;
      virusesEl.textContent = virusCount;
      levelEl.textContent = level;

      // Speed scales with level
      dropInterval = Math.max(150, 700 - level * 40);

      // Prepare pills
      nextPill = randomPillColors();
      spawnPill();
    }

    function wouldCreateRun(r, c, color, minLen) {
      // Check horizontal run through (r,c)
      let hCount = 1;
      for (let dc = 1; c + dc < COLS && board[r][c + dc] && board[r][c + dc].color === color; dc++) hCount++;
      for (let dc = 1; c - dc >= 0 && board[r][c - dc] && board[r][c - dc].color === color; dc++) hCount++;
      if (hCount >= minLen) return true;

      // Check vertical run through (r,c)
      let vCount = 1;
      for (let dr = 1; r + dr < ROWS && board[r + dr][c] && board[r + dr][c].color === color; dr++) vCount++;
      for (let dr = 1; r - dr >= 0 && board[r - dr][c] && board[r - dr][c].color === color; dr++) vCount++;
      if (vCount >= minLen) return true;

      return false;
    }

    function randomPillColors() {
      return [
        COLORS[Math.floor(Math.random() * 3)],
        COLORS[Math.floor(Math.random() * 3)]
      ];
    }

    function spawnPill() {
      const colors = nextPill;
      nextPill = randomPillColors();
      drawNext();

      // Pill orientation: 0 = horizontal (left-right), 1 = vertical (top-bottom)
      // Spawn at top center: columns 3,4
      const c = 3;
      const r = 0;
      pill = {
        cells: [
          { r: r, c: c, color: colors[0] },
          { r: r, c: c + 1, color: colors[1] }
        ],
        orientation: 0 // 0=horizontal, 1=vertical
      };

      // Check if spawn position is blocked
      if (isCellOccupied(pill.cells[0].r, pill.cells[0].c) ||
          isCellOccupied(pill.cells[1].r, pill.cells[1].c)) {
        pill = null;
        gameOver();
      }
    }

    function isCellOccupied(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true;
      return board[r][c] !== null;
    }

    // --- Movement ---

    function movePill(dr, dc) {
      if (!pill || clearing) return false;
      const newCells = pill.cells.map(cell => ({
        ...cell,
        r: cell.r + dr,
        c: cell.c + dc
      }));
      if (canPlace(newCells)) {
        pill.cells = newCells;
        return true;
      }
      return false;
    }

    function canPlace(cells) {
      return cells.every(cell =>
        cell.r >= 0 && cell.r < ROWS &&
        cell.c >= 0 && cell.c < COLS &&
        board[cell.r][cell.c] === null
      );
    }

    function rotatePill() {
      if (!pill || clearing) return;
      const pivot = pill.cells[0]; // first half is the pivot
      let newCells;

      if (pill.orientation === 0) {
        // Horizontal -> Vertical: second cell goes above pivot
        newCells = [
          { ...pivot },
          { r: pivot.r - 1, c: pivot.c, color: pill.cells[1].color }
        ];
        if (canPlace(newCells)) {
          pill.cells = newCells;
          pill.orientation = 1;
          return;
        }
        // If blocked above, try pushing down
        newCells = [
          { r: pivot.r + 1, c: pivot.c, color: pivot.color },
          { r: pivot.r, c: pivot.c, color: pill.cells[1].color }
        ];
        if (canPlace(newCells)) {
          pill.cells = newCells;
          pill.orientation = 1;
          return;
        }
      } else {
        // Vertical -> Horizontal: second cell goes to right of pivot
        newCells = [
          { ...pivot },
          { r: pivot.r, c: pivot.c + 1, color: pill.cells[1].color }
        ];
        if (canPlace(newCells)) {
          pill.cells = newCells;
          pill.orientation = 0;
          return;
        }
        // If blocked right, try shifting left
        newCells = [
          { r: pivot.r, c: pivot.c - 1, color: pivot.color },
          { r: pivot.r, c: pivot.c, color: pill.cells[1].color }
        ];
        if (canPlace(newCells)) {
          pill.cells = newCells;
          pill.orientation = 0;
          return;
        }
      }
    }

    function lockPill() {
      if (!pill) return;
      pill.cells.forEach(cell => {
        if (cell.r >= 0 && cell.r < ROWS && cell.c >= 0 && cell.c < COLS) {
          board[cell.r][cell.c] = { color: cell.color, type: 'pill' };
        }
      });
      pill = null;
      chainCount = 0;
      checkMatches();
    }

    // --- Match checking ---

    function checkMatches() {
      const toRemove = new Set();

      // Horizontal matches
      for (let r = 0; r < ROWS; r++) {
        let run = [];
        for (let c = 0; c <= COLS; c++) {
          const cell = c < COLS ? board[r][c] : null;
          if (cell && run.length > 0 && cell.color === board[r][run[0]].color) {
            run.push(c);
          } else {
            if (run.length >= 4) {
              run.forEach(cc => toRemove.add(r + ',' + cc));
            }
            run = cell ? [c] : [];
          }
        }
      }

      // Vertical matches
      for (let c = 0; c < COLS; c++) {
        let run = [];
        for (let r = 0; r <= ROWS; r++) {
          const cell = r < ROWS ? board[r][c] : null;
          if (cell && run.length > 0 && cell.color === board[run[0]][c].color) {
            run.push(r);
          } else {
            if (run.length >= 4) {
              run.forEach(rr => toRemove.add(rr + ',' + c));
            }
            run = cell ? [r] : [];
          }
        }
      }

      if (toRemove.size > 0) {
        clearCells = Array.from(toRemove).map(s => {
          const [r, c] = s.split(',').map(Number);
          return { r, c };
        });

        // Count viruses being cleared
        let virusesCleared = 0;
        clearCells.forEach(({ r, c }) => {
          if (board[r][c] && board[r][c].type === 'virus') virusesCleared++;
        });

        // Score: 100 per virus, doubled for each chain step
        if (virusesCleared > 0) {
          const chainMultiplier = Math.pow(2, chainCount);
          score += virusesCleared * 100 * chainMultiplier;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }
        }

        virusCount -= virusesCleared;
        virusesEl.textContent = Math.max(0, virusCount);

        // Start clear animation
        clearing = true;
        clearPhase = 0;
        animateClear();
      } else {
        // No matches, check win or spawn next pill
        if (virusCount <= 0) {
          winLevel();
        } else {
          spawnPill();
          scheduleTick();
        }
      }
    }

    function animateClear() {
      clearPhase++;
      draw();

      if (clearPhase <= 10) {
        setTimeout(animateClear, 40);
      } else {
        // Remove matched cells
        clearCells.forEach(({ r, c }) => {
          board[r][c] = null;
        });
        clearCells = [];
        clearing = false;
        clearPhase = 0;
        chainCount++;

        // Apply gravity to pill halves
        applyGravity();
      }
    }

    function applyGravity() {
      // Find pill cells that are floating (have empty space below)
      // Only pill-type cells fall, viruses stay in place
      let moved = false;
      // Process from bottom to top so pieces fall correctly
      for (let r = ROWS - 2; r >= 0; r--) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] && board[r][c].type === 'pill') {
            if (r + 1 < ROWS && board[r + 1][c] === null) {
              board[r + 1][c] = board[r][c];
              board[r][c] = null;
              moved = true;
            }
          }
        }
      }

      if (moved) {
        draw();
        setTimeout(() => applyGravity(), 60);
      } else {
        // After gravity settles, check for new matches (chain)
        checkMatches();
      }
    }

    function winLevel() {
      levelWon = true;
      clearing = false;
      clearTimeout(timer);

      // Flash the win, then advance
      overlayTitle.textContent = 'LEVEL CLEAR!';
      overlayText.textContent = `Score: ${score} — Next level...`;
      overlay.style.display = 'flex';

      setTimeout(() => {
        overlay.style.display = 'none';
        level++;
        setupLevel();
        draw();
        drawNext();
        scheduleTick();
      }, 2000);
    }

    function gameOver() {
      gameState = 'over';
      clearTimeout(timer);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} — Press any key to restart`;
    }

    // --- Game loop ---

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      scheduleTick();
    }

    function scheduleTick() {
      clearTimeout(timer);
      if (gameState !== 'playing' || clearing || levelWon) return;
      timer = setTimeout(tick, dropInterval);
    }

    function tick() {
      clearTimeout(timer);
      if (gameState !== 'playing' || !pill || clearing || levelWon) return;

      if (!movePill(1, 0)) {
        lockPill();
        return; // checkMatches will handle spawning or game over
      }
      draw();
      scheduleTick();
    }

    // --- Drawing ---

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawBottle();
      drawGrid();
      drawBoard();
      drawActivePill();
      drawClearAnimation();
    }

    function drawBottle() {
      // Draw the bottle/jar outline
      const bx = OX - 4;
      const by = OY - 4;
      const bw = COLS * CELL + 8;
      const bh = ROWS * CELL + 8;

      // Bottle neck (opening at top center)
      const neckW = CELL * 2 + 12;
      const neckH = 16;
      const neckX = OX + (COLS * CELL - neckW) / 2;
      const neckY = by - neckH;

      ctx.strokeStyle = '#f4c';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#f4c';
      ctx.shadowBlur = 8;

      // Draw bottle body
      ctx.beginPath();
      ctx.rect(bx, by, bw, bh);
      ctx.stroke();

      // Draw bottle neck
      ctx.beginPath();
      ctx.moveTo(neckX, by);
      ctx.lineTo(neckX, neckY);
      ctx.lineTo(neckX + neckW, neckY);
      ctx.lineTo(neckX + neckW, by);
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Fill bottle interior with slightly darker shade
      ctx.fillStyle = 'rgba(10, 10, 30, 0.4)';
      ctx.fillRect(OX, OY, COLS * CELL, ROWS * CELL);
    }

    function drawGrid() {
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(OX + c * CELL, OY);
        ctx.lineTo(OX + c * CELL, OY + ROWS * CELL);
        ctx.stroke();
      }
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(OX, OY + r * CELL);
        ctx.lineTo(OX + COLS * CELL, OY + r * CELL);
        ctx.stroke();
      }
    }

    function drawBoard() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (!cell) continue;

          // Skip cells that are being cleared (they get drawn in the clear animation)
          if (clearing && clearCells.some(cc => cc.r === r && cc.c === c)) continue;

          const px = OX + c * CELL;
          const py = OY + r * CELL;

          if (cell.type === 'virus') {
            drawVirus(px, py, cell.color);
          } else {
            drawPillCell(px, py, cell.color);
          }
        }
      }
    }

    function drawVirus(px, py, color) {
      const cx = px + CELL / 2;
      const cy = py + CELL / 2;
      const hex = COLOR_HEX[color];
      const dark = COLOR_DARK[color];

      // Body
      ctx.fillStyle = hex;
      ctx.shadowColor = COLOR_GLOW[color];
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL * 0.35, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Spiky arms (4 little lines)
      ctx.strokeStyle = hex;
      ctx.lineWidth = 2;
      const armLen = CELL * 0.2;
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * CELL * 0.3, cy + Math.sin(angle) * CELL * 0.3);
        ctx.lineTo(cx + Math.cos(angle) * (CELL * 0.3 + armLen), cy + Math.sin(angle) * (CELL * 0.3 + armLen));
        ctx.stroke();
      }

      // Eyes
      ctx.fillStyle = '#1a1a2e';
      ctx.beginPath();
      ctx.arc(cx - 4, cy - 2, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 4, cy - 2, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx - 3.5, cy - 2, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + 4.5, cy - 2, 1, 0, Math.PI * 2);
      ctx.fill();

      // Mouth
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy + 4, 4, 0, Math.PI);
      ctx.stroke();
    }

    function drawPillCell(px, py, color) {
      const hex = COLOR_HEX[color];

      ctx.fillStyle = hex;
      ctx.shadowColor = COLOR_GLOW[color];
      ctx.shadowBlur = 6;
      // Rounded rectangle pill shape
      const m = 2; // margin
      const rad = 4;
      roundRect(ctx, px + m, py + m, CELL - m * 2, CELL - m * 2, rad);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      roundRect(ctx, px + m, py + m, CELL - m * 2, (CELL - m * 2) * 0.35, rad);
      ctx.fill();
    }

    function roundRect(ctx, x, y, w, h, r) {
      r = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function drawActivePill() {
      if (!pill || clearing) return;

      pill.cells.forEach(cell => {
        if (cell.r < 0) return; // above visible area
        const px = OX + cell.c * CELL;
        const py = OY + cell.r * CELL;
        drawPillCell(px, py, cell.color);
      });

      // Ghost piece (show where pill will land)
      let ghostDr = 0;
      while (true) {
        const testCells = pill.cells.map(cell => ({
          ...cell,
          r: cell.r + ghostDr + 1
        }));
        if (!canPlace(testCells)) break;
        ghostDr++;
      }

      if (ghostDr > 0) {
        ctx.globalAlpha = 0.2;
        pill.cells.forEach(cell => {
          const px = OX + cell.c * CELL;
          const py = OY + (cell.r + ghostDr) * CELL;
          const hex = COLOR_HEX[cell.color];
          ctx.fillStyle = hex;
          const m = 2;
          roundRect(ctx, px + m, py + m, CELL - m * 2, CELL - m * 2, 4);
          ctx.fill();
        });
        ctx.globalAlpha = 1.0;
      }
    }

    function drawClearAnimation() {
      if (!clearing || clearCells.length === 0) return;

      const pulse = Math.sin(clearPhase * 0.8) * 0.5 + 0.5;
      clearCells.forEach(({ r, c }) => {
        const px = OX + c * CELL;
        const py = OY + r * CELL;

        // Flash white
        ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.9})`;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 15;
        ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
        ctx.shadowBlur = 0;
      });
    }

    function drawNext() {
      nctx.fillStyle = '#16213e';
      nctx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

      if (!nextPill) return;

      const size = 24;
      const gap = 2;
      const totalW = size * 2 + gap;
      const sx = (nextCanvas.width - totalW) / 2;
      const sy = (nextCanvas.height - size) / 2;

      for (let i = 0; i < 2; i++) {
        const hex = COLOR_HEX[nextPill[i]];
        nctx.fillStyle = hex;
        nctx.shadowColor = COLOR_GLOW[nextPill[i]];
        nctx.shadowBlur = 6;
        const x = sx + i * (size + gap);
        const m = 2;
        const r = 4;
        // Rounded rect in next canvas
        nctx.beginPath();
        const rx = x + m, ry = sy + m, rw = size - m * 2, rh = size - m * 2;
        const rr = Math.min(r, rw / 2, rh / 2);
        nctx.moveTo(rx + rr, ry);
        nctx.arcTo(rx + rw, ry, rx + rw, ry + rh, rr);
        nctx.arcTo(rx + rw, ry + rh, rx, ry + rh, rr);
        nctx.arcTo(rx, ry + rh, rx, ry, rr);
        nctx.arcTo(rx, ry, rx + rw, ry, rr);
        nctx.closePath();
        nctx.fill();
        nctx.shadowBlur = 0;

        // Highlight
        nctx.fillStyle = 'rgba(255,255,255,0.2)';
        nctx.beginPath();
        nctx.moveTo(rx + rr, ry);
        nctx.arcTo(rx + rw, ry, rx + rw, ry + rh * 0.35, rr);
        nctx.lineTo(rx + rw, ry + rh * 0.35);
        nctx.lineTo(rx, ry + rh * 0.35);
        nctx.arcTo(rx, ry, rx + rw, ry, rr);
        nctx.closePath();
        nctx.fill();
      }
    }

    // --- Input ---

    let softDropping = false;
    const SOFT_DROP_INTERVAL = 50;

    document.addEventListener('keydown', (e) => {
      const gameKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'Z'];
      if (gameKeys.includes(e.key)) e.preventDefault();

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      if (gameState === 'playing' && pill && !clearing && !levelWon) {
        switch (e.key) {
          case 'ArrowLeft':
            movePill(0, -1);
            draw();
            break;
          case 'ArrowRight':
            movePill(0, 1);
            draw();
            break;
          case 'ArrowDown':
            if (!softDropping) {
              softDropping = true;
              clearTimeout(timer);
              fastDrop();
            }
            break;
          case 'ArrowUp':
          case 'z':
          case 'Z':
            rotatePill();
            draw();
            break;
          case ' ':
            // Hard drop
            while (movePill(1, 0)) {
              score += 1;
            }
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              bestEl.textContent = best;
            }
            lockPill();
            draw();
            break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowDown' && softDropping) {
        softDropping = false;
        clearTimeout(timer);
        scheduleTick();
      }
    });

    function fastDrop() {
      clearTimeout(timer);
      if (gameState !== 'playing' || !pill || clearing || levelWon) {
        softDropping = false;
        return;
      }
      if (!movePill(1, 0)) {
        softDropping = false;
        lockPill();
        return;
      }
      score += 1;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      draw();
      if (softDropping) {
        timer = setTimeout(fastDrop, SOFT_DROP_INTERVAL);
      } else {
        scheduleTick();
      }
    }

    // --- Game data for ML ---

    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        level,
        virusCount,
        pillPosition: pill ? pill.cells.map(c => ({ r: c.r, c: c.c })) : null,
        pillColors: pill ? pill.cells.map(c => c.color) : null
      };
    }

    // Wrap draw to also update game data
    const origDraw = draw;
    draw = function() {
      origDraw();
      updateGameData();
    };

    // --- Start ---

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

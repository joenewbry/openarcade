<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battlezone</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4e8; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 238, 136, 0.5); }
    h1 { color: #4e8; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 238, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4e8; }
    canvas {
      border: 2px solid #4e8;
      box-shadow: 0 0 20px rgba(68, 238, 136, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4e8;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BATTLEZONE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BATTLEZONE</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Theme
    const THEME = '#4e8';
    const THEME_DIM = '#295';
    const THEME_BRIGHT = '#6fa';
    const BG = '#1a1a2e';

    // Camera / perspective
    const FOV = 60 * Math.PI / 180;
    const NEAR = 0.1;
    const FAR = 800;
    const HORIZON_Y = H * 0.45;
    const VP_DIST = (W / 2) / Math.tan(FOV / 2);

    // Player
    const MOVE_SPEED = 2.5;
    const ROT_SPEED = 0.035;
    const ARENA_SIZE = 600;
    const BULLET_SPEED = 12;
    const BULLET_LIFE = 80;
    const FIRE_COOLDOWN = 15;

    // Enemy
    const ENEMY_SPEED = 1.0;
    const ENEMY_FIRE_INTERVAL_MIN = 90;
    const ENEMY_FIRE_INTERVAL_MAX = 200;
    const ENEMY_BULLET_SPEED = 6;

    let score, best = 0, gameState;
    let playerX, playerZ, playerAngle;
    let enemies, playerBullets, enemyBullets, particles, obstacles;
    let fireCooldown, tick, difficulty;
    let spawnTimer, spawnInterval;
    let keys = {};

    // Mountains (static horizon decoration)
    const mountains = [];
    for (let i = 0; i < 20; i++) {
      mountains.push({
        angle: (i / 20) * Math.PI * 2,
        height: 20 + Math.random() * 50,
        width: 0.15 + Math.random() * 0.2
      });
    }

    // Obstacles (static cubes in the arena)
    function generateObstacles() {
      obstacles = [];
      for (let i = 0; i < 8; i++) {
        obstacles.push({
          x: (Math.random() - 0.5) * ARENA_SIZE * 1.5,
          z: (Math.random() - 0.5) * ARENA_SIZE * 1.5,
          size: 15 + Math.random() * 20,
          height: 20 + Math.random() * 30
        });
      }
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BATTLEZONE';
      overlayText.textContent = 'Press SPACE to start';
      playerX = 0;
      playerZ = 0;
      playerAngle = 0;
      enemies = [];
      playerBullets = [];
      enemyBullets = [];
      particles = [];
      fireCooldown = 0;
      tick = 0;
      difficulty = 0;
      spawnTimer = 0;
      spawnInterval = 180;
      keys = {};
      generateObstacles();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      spawnEnemy();
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press SPACE to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // Project 3D point to 2D screen
    function project(wx, wy, wz) {
      // Transform to player-relative coordinates
      const dx = wx - playerX;
      const dz = wz - playerZ;
      const cosA = Math.cos(-playerAngle);
      const sinA = Math.sin(-playerAngle);
      const rx = dx * cosA - dz * sinA;
      const rz = dx * sinA + dz * cosA;

      if (rz <= NEAR) return null;

      const sx = W / 2 + (rx * VP_DIST) / rz;
      const sy = HORIZON_Y - (wy * VP_DIST) / rz;
      const scale = VP_DIST / rz;

      return { x: sx, y: sy, z: rz, scale };
    }

    function spawnEnemy() {
      const angle = Math.random() * Math.PI * 2;
      const dist = 200 + Math.random() * 300;
      const ex = playerX + Math.cos(angle) * dist;
      const ez = playerZ + Math.sin(angle) * dist;
      enemies.push({
        x: ex, z: ez,
        angle: Math.atan2(playerZ - ez, playerX - ex),
        alive: true,
        hp: 1 + Math.floor(difficulty / 3),
        fireTimer: ENEMY_FIRE_INTERVAL_MIN + Math.random() * (ENEMY_FIRE_INTERVAL_MAX - ENEMY_FIRE_INTERVAL_MIN),
        moveTimer: 0,
        strafeDir: Math.random() > 0.5 ? 1 : -1,
        strafeTimer: 60 + Math.random() * 120
      });
    }

    function spawnExplosion(x, z, count) {
      for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 0.5 + Math.random() * 3;
        const elev = Math.random() * 3;
        particles.push({
          x, y: 10 + Math.random() * 20, z,
          vx: Math.cos(ang) * spd,
          vy: elev,
          vz: Math.sin(ang) * spd,
          life: 20 + Math.random() * 30,
          maxLife: 50
        });
      }
    }

    function update() {
      tick++;
      difficulty = Math.min(score / 50, 10);

      // Player movement
      if (keys['ArrowUp']) {
        playerX += Math.cos(playerAngle) * MOVE_SPEED;
        playerZ += Math.sin(playerAngle) * MOVE_SPEED;
      }
      if (keys['ArrowDown']) {
        playerX -= Math.cos(playerAngle) * MOVE_SPEED * 0.6;
        playerZ -= Math.sin(playerAngle) * MOVE_SPEED * 0.6;
      }
      if (keys['ArrowLeft']) {
        playerAngle -= ROT_SPEED;
      }
      if (keys['ArrowRight']) {
        playerAngle += ROT_SPEED;
      }

      // Fire cooldown
      if (fireCooldown > 0) fireCooldown--;

      // Spawn enemies
      spawnTimer++;
      const adjInterval = Math.max(60, spawnInterval - difficulty * 12);
      if (spawnTimer >= adjInterval && enemies.filter(e => e.alive).length < 3 + Math.floor(difficulty)) {
        spawnEnemy();
        spawnTimer = 0;
      }

      // Update enemies
      for (const e of enemies) {
        if (!e.alive) continue;

        // Face player
        const toPlayerAngle = Math.atan2(playerZ - e.z, playerX - e.x);
        let angleDiff = toPlayerAngle - e.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        e.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.02 + difficulty * 0.003);

        // Move toward player
        const distToPlayer = Math.sqrt((playerX - e.x) ** 2 + (playerZ - e.z) ** 2);
        const speed = ENEMY_SPEED + difficulty * 0.1;

        if (distToPlayer > 80) {
          e.x += Math.cos(e.angle) * speed;
          e.z += Math.sin(e.angle) * speed;
        } else if (distToPlayer < 50) {
          // Back away if too close
          e.x -= Math.cos(e.angle) * speed * 0.5;
          e.z -= Math.sin(e.angle) * speed * 0.5;
        }

        // Strafe
        e.strafeTimer--;
        if (e.strafeTimer <= 0) {
          e.strafeDir *= -1;
          e.strafeTimer = 60 + Math.random() * 120;
        }
        const strafeAngle = e.angle + Math.PI / 2;
        e.x += Math.cos(strafeAngle) * speed * 0.3 * e.strafeDir;
        e.z += Math.sin(strafeAngle) * speed * 0.3 * e.strafeDir;

        // Enemy fire
        e.fireTimer--;
        if (e.fireTimer <= 0 && distToPlayer < 400) {
          const fireAngle = Math.atan2(playerZ - e.z, playerX - e.x);
          // Add slight inaccuracy
          const spread = (0.1 - difficulty * 0.005) * (Math.random() - 0.5) * 2;
          enemyBullets.push({
            x: e.x, z: e.z, y: 15,
            vx: Math.cos(fireAngle + spread) * ENEMY_BULLET_SPEED,
            vz: Math.sin(fireAngle + spread) * ENEMY_BULLET_SPEED,
            life: 100
          });
          e.fireTimer = Math.max(40, ENEMY_FIRE_INTERVAL_MIN - difficulty * 8) + Math.random() * 60;
        }
      }

      // Update player bullets
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        b.x += b.vx;
        b.z += b.vz;
        b.life--;
        if (b.life <= 0) { playerBullets.splice(i, 1); continue; }

        // Hit enemies
        let hitEnemy = false;
        for (const e of enemies) {
          if (!e.alive) continue;
          const dist = Math.sqrt((b.x - e.x) ** 2 + (b.z - e.z) ** 2);
          if (dist < 18) {
            e.hp--;
            if (e.hp <= 0) {
              e.alive = false;
              score += 100;
              scoreEl.textContent = score;
              if (score > best) {
                best = score;
                bestEl.textContent = best;
              }
              spawnExplosion(e.x, e.z, 20);
            } else {
              spawnExplosion(e.x, e.z, 5);
            }
            playerBullets.splice(i, 1);
            hitEnemy = true;
            break;
          }
        }
        if (hitEnemy) continue;

        // Hit obstacles
        for (const obs of obstacles) {
          const dist = Math.sqrt((b.x - obs.x) ** 2 + (b.z - obs.z) ** 2);
          if (dist < obs.size) {
            playerBullets.splice(i, 1);
            spawnExplosion(b.x, b.z, 3);
            break;
          }
        }
      }

      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.z += b.vz;
        b.life--;
        if (b.life <= 0) { enemyBullets.splice(i, 1); continue; }

        // Hit player
        const dist = Math.sqrt((b.x - playerX) ** 2 + (b.z - playerZ) ** 2);
        if (dist < 12) {
          enemyBullets.splice(i, 1);
          spawnExplosion(playerX, playerZ, 15);
          gameOver();
          return;
        }

        // Hit obstacles
        for (const obs of obstacles) {
          const dist = Math.sqrt((b.x - obs.x) ** 2 + (b.z - obs.z) ** 2);
          if (dist < obs.size) {
            enemyBullets.splice(i, 1);
            break;
          }
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.z += p.vz;
        p.vy -= 0.1; // gravity
        if (p.y < 0) p.y = 0;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Remove dead enemies
      enemies = enemies.filter(e => e.alive || false);

      // Update gameData for ML
      window.gameData = {
        playerX, playerZ, playerAngle,
        enemies: enemies.filter(e => e.alive).map(e => ({ x: e.x, z: e.z })),
        score
      };
    }

    function draw() {
      // Clear
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, HORIZON_Y);
      skyGrad.addColorStop(0, '#0a0a1a');
      skyGrad.addColorStop(1, '#12122a');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, HORIZON_Y);

      // Stars
      ctx.fillStyle = '#ffffff18';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 83) % W);
        const sy = ((i * 97 + 17) % (HORIZON_Y - 20));
        const twinkle = Math.sin(tick * 0.03 + i * 7) > 0.6 ? 2 : 1;
        ctx.fillRect(sx, sy, twinkle, twinkle);
      }

      // Mountains on horizon
      ctx.strokeStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i <= 200; i++) {
        const screenAngle = (i / 200) * Math.PI * 2;
        let relAngle = screenAngle - playerAngle;
        while (relAngle > Math.PI) relAngle -= Math.PI * 2;
        while (relAngle < -Math.PI) relAngle += Math.PI * 2;

        const sx = W / 2 + relAngle * VP_DIST * 0.3;
        if (sx < -50 || sx > W + 50) continue;

        // Mountain heights vary with angle
        let mh = 0;
        for (const m of mountains) {
          let da = screenAngle - m.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          if (Math.abs(da) < m.width) {
            const t = 1 - Math.abs(da) / m.width;
            mh = Math.max(mh, m.height * t);
          }
        }

        const sy = HORIZON_Y - mh;
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Ground grid
      ctx.strokeStyle = THEME_DIM;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 2;
      ctx.lineWidth = 1;

      // Draw horizontal ground lines (receding into distance)
      for (let d = 20; d < FAR; d += 40) {
        const left = project(playerX + Math.cos(playerAngle - FOV / 2) * d, 0,
                              playerZ + Math.sin(playerAngle - FOV / 2) * d);
        const right = project(playerX + Math.cos(playerAngle + FOV / 2) * d, 0,
                               playerZ + Math.sin(playerAngle + FOV / 2) * d);
        if (left && right && left.z > 0 && right.z > 0) {
          const alpha = Math.max(0, 1 - d / FAR);
          ctx.strokeStyle = `rgba(34, 153, 85, ${alpha * 0.4})`;
          ctx.beginPath();
          ctx.moveTo(left.x, left.y);
          ctx.lineTo(right.x, right.y);
          ctx.stroke();
        }
      }

      // Grid lines on the ground
      const gridSpacing = 60;
      const gridRange = 400;
      const cosA = Math.cos(playerAngle);
      const sinA = Math.sin(playerAngle);

      // Perpendicular lines
      for (let offset = -gridRange; offset <= gridRange; offset += gridSpacing) {
        const baseX = playerX + cosA * offset;
        const baseZ = playerZ + sinA * offset;
        const p1 = project(baseX - sinA * gridRange, 0, baseZ + cosA * gridRange);
        const p2 = project(baseX + sinA * gridRange, 0, baseZ - cosA * gridRange);
        if (p1 && p2) {
          const alpha = Math.max(0, 0.3 - Math.abs(offset) / gridRange * 0.3);
          ctx.strokeStyle = `rgba(34, 153, 85, ${alpha})`;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }

      // Parallel lines (along view direction)
      for (let offset = -gridRange; offset <= gridRange; offset += gridSpacing) {
        const baseX = playerX - sinA * offset;
        const baseZ = playerZ + cosA * offset;
        const p1 = project(baseX + cosA * 20, 0, baseZ + sinA * 20);
        const p2 = project(baseX + cosA * gridRange, 0, baseZ + sinA * gridRange);
        if (p1 && p2) {
          const alpha = Math.max(0, 0.3 - Math.abs(offset) / gridRange * 0.3);
          ctx.strokeStyle = `rgba(34, 153, 85, ${alpha})`;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;

      // Collect all 3D objects for depth sorting
      const renderList = [];

      // Obstacles
      for (const obs of obstacles) {
        const p = project(obs.x, 0, obs.z);
        if (p && p.z > 0) {
          renderList.push({ type: 'obstacle', obj: obs, z: p.z, p });
        }
      }

      // Enemies
      for (const e of enemies) {
        if (!e.alive) continue;
        const p = project(e.x, 0, e.z);
        if (p && p.z > 0) {
          renderList.push({ type: 'enemy', obj: e, z: p.z, p });
        }
      }

      // Player bullets
      for (const b of playerBullets) {
        const p = project(b.x, 10, b.z);
        if (p && p.z > 0) {
          renderList.push({ type: 'pbullet', obj: b, z: p.z, p });
        }
      }

      // Enemy bullets
      for (const b of enemyBullets) {
        const p = project(b.x, b.y, b.z);
        if (p && p.z > 0) {
          renderList.push({ type: 'ebullet', obj: b, z: p.z, p });
        }
      }

      // Particles
      for (const pt of particles) {
        const p = project(pt.x, pt.y, pt.z);
        if (p && p.z > 0) {
          renderList.push({ type: 'particle', obj: pt, z: p.z, p });
        }
      }

      // Sort far to near
      renderList.sort((a, b) => b.z - a.z);

      // Render all objects
      for (const item of renderList) {
        switch (item.type) {
          case 'obstacle': drawObstacle(item.obj, item.p); break;
          case 'enemy': drawEnemy(item.obj, item.p); break;
          case 'pbullet': drawPlayerBullet(item.p); break;
          case 'ebullet': drawEnemyBullet(item.p); break;
          case 'particle': drawParticle(item.obj, item.p); break;
        }
      }

      // HUD - Crosshair
      ctx.strokeStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 8;
      ctx.lineWidth = 2;
      const cx = W / 2, cy = HORIZON_Y;
      ctx.beginPath();
      ctx.moveTo(cx - 15, cy); ctx.lineTo(cx - 5, cy);
      ctx.moveTo(cx + 5, cy); ctx.lineTo(cx + 15, cy);
      ctx.moveTo(cx, cy - 15); ctx.lineTo(cx, cy - 5);
      ctx.moveTo(cx, cy + 5); ctx.lineTo(cx, cy + 15);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // HUD - Compass
      drawCompass();

      // HUD - Radar
      drawRadar();

      // HUD - Tank barrel overlay (cockpit frame)
      ctx.strokeStyle = THEME_DIM;
      ctx.lineWidth = 3;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      // Left edge
      ctx.beginPath();
      ctx.moveTo(0, H);
      ctx.lineTo(50, H - 30);
      ctx.lineTo(50, H * 0.7);
      ctx.stroke();
      // Right edge
      ctx.beginPath();
      ctx.moveTo(W, H);
      ctx.lineTo(W - 50, H - 30);
      ctx.lineTo(W - 50, H * 0.7);
      ctx.stroke();
      // Bottom bar
      ctx.beginPath();
      ctx.moveTo(50, H - 30);
      ctx.lineTo(W - 50, H - 30);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Horizon line
      ctx.strokeStyle = THEME_DIM;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(0, HORIZON_Y);
      ctx.lineTo(W, HORIZON_Y);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawObstacle(obs, p) {
      const s = obs.size * p.scale * 0.8;
      const h = obs.height * p.scale * 0.8;
      if (s < 1 || p.x < -100 || p.x > W + 100) return;

      ctx.strokeStyle = THEME_DIM;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 3;
      ctx.lineWidth = 1.5;

      // Bottom face
      const bx = p.x, by = p.y;
      // Top face
      const ty = by - h;

      // Draw wireframe box
      ctx.beginPath();
      // Bottom rect
      ctx.moveTo(bx - s, by);
      ctx.lineTo(bx + s, by);
      ctx.lineTo(bx + s * 0.6, by - s * 0.3);
      ctx.lineTo(bx - s * 0.6, by - s * 0.3);
      ctx.closePath();
      ctx.stroke();

      // Top rect
      ctx.beginPath();
      ctx.moveTo(bx - s, ty);
      ctx.lineTo(bx + s, ty);
      ctx.lineTo(bx + s * 0.6, ty - s * 0.3);
      ctx.lineTo(bx - s * 0.6, ty - s * 0.3);
      ctx.closePath();
      ctx.stroke();

      // Verticals
      ctx.beginPath();
      ctx.moveTo(bx - s, by); ctx.lineTo(bx - s, ty);
      ctx.moveTo(bx + s, by); ctx.lineTo(bx + s, ty);
      ctx.moveTo(bx + s * 0.6, by - s * 0.3); ctx.lineTo(bx + s * 0.6, ty - s * 0.3);
      ctx.moveTo(bx - s * 0.6, by - s * 0.3); ctx.lineTo(bx - s * 0.6, ty - s * 0.3);
      ctx.stroke();

      ctx.shadowBlur = 0;
    }

    function drawEnemy(e, p) {
      const s = p.scale * 15;
      if (s < 2 || p.x < -100 || p.x > W + 100) return;

      ctx.strokeStyle = THEME_BRIGHT;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;

      const ex = p.x, ey = p.y;
      const bodyH = s * 1.5;
      const bodyW = s * 2;
      const turretH = s * 0.8;
      const turretW = s * 1.2;
      const barrelLen = s * 2;

      // Tank body (trapezoid)
      ctx.beginPath();
      ctx.moveTo(ex - bodyW, ey);
      ctx.lineTo(ex + bodyW, ey);
      ctx.lineTo(ex + bodyW * 0.8, ey - bodyH);
      ctx.lineTo(ex - bodyW * 0.8, ey - bodyH);
      ctx.closePath();
      ctx.stroke();

      // Tracks
      ctx.beginPath();
      ctx.moveTo(ex - bodyW * 1.1, ey + s * 0.2);
      ctx.lineTo(ex + bodyW * 1.1, ey + s * 0.2);
      ctx.stroke();

      // Turret
      ctx.beginPath();
      ctx.moveTo(ex - turretW, ey - bodyH);
      ctx.lineTo(ex + turretW, ey - bodyH);
      ctx.lineTo(ex + turretW * 0.7, ey - bodyH - turretH);
      ctx.lineTo(ex - turretW * 0.7, ey - bodyH - turretH);
      ctx.closePath();
      ctx.stroke();

      // Barrel
      const barrelY = ey - bodyH - turretH * 0.5;
      ctx.beginPath();
      ctx.moveTo(ex, barrelY);
      ctx.lineTo(ex, barrelY - barrelLen);
      ctx.stroke();

      // Barrel tip
      ctx.beginPath();
      ctx.moveTo(ex - s * 0.3, barrelY - barrelLen);
      ctx.lineTo(ex + s * 0.3, barrelY - barrelLen);
      ctx.stroke();

      // HP indicator (for multi-hp enemies)
      if (e.hp > 1) {
        ctx.fillStyle = THEME;
        ctx.font = `${Math.max(8, s * 0.6)}px 'Courier New', monospace`;
        ctx.textAlign = 'center';
        ctx.fillText(`HP:${e.hp}`, ex, ey - bodyH - turretH - s * 0.5);
      }

      ctx.shadowBlur = 0;
    }

    function drawPlayerBullet(p) {
      const s = Math.max(2, p.scale * 3);
      ctx.fillStyle = THEME_BRIGHT;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawEnemyBullet(p) {
      const s = Math.max(2, p.scale * 3);
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawParticle(pt, p) {
      const alpha = pt.life / pt.maxLife;
      const s = Math.max(1, p.scale * 2 * alpha);
      ctx.fillStyle = `rgba(68, 238, 136, ${alpha})`;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 4;
      ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);
      ctx.shadowBlur = 0;
    }

    function drawCompass() {
      const cx = W / 2;
      const cy = H - 12;
      const cw = 100;

      ctx.strokeStyle = THEME_DIM;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - cw, cy);
      ctx.lineTo(cx + cw, cy);
      ctx.stroke();

      // Tick marks
      for (let a = 0; a < 360; a += 45) {
        const rad = a * Math.PI / 180;
        let rel = rad - playerAngle;
        while (rel > Math.PI) rel -= Math.PI * 2;
        while (rel < -Math.PI) rel += Math.PI * 2;
        const sx = cx + (rel / (FOV / 2)) * cw;
        if (sx > cx - cw && sx < cx + cw) {
          ctx.strokeStyle = THEME;
          ctx.beginPath();
          ctx.moveTo(sx, cy - 5);
          ctx.lineTo(sx, cy + 5);
          ctx.stroke();
          ctx.fillStyle = THEME;
          ctx.font = "8px 'Courier New', monospace";
          ctx.textAlign = 'center';
          const labels = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
          ctx.fillText(labels[a / 45], sx, cy - 8);
        }
      }
    }

    function drawRadar() {
      const rx = W - 50;
      const ry = 50;
      const rr = 35;

      ctx.strokeStyle = THEME_DIM;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(rx, ry, rr, 0, Math.PI * 2);
      ctx.stroke();

      // Cross
      ctx.beginPath();
      ctx.moveTo(rx - rr, ry); ctx.lineTo(rx + rr, ry);
      ctx.moveTo(rx, ry - rr); ctx.lineTo(rx, ry + rr);
      ctx.stroke();

      // Player dot
      ctx.fillStyle = THEME;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.arc(rx, ry, 2, 0, Math.PI * 2);
      ctx.fill();

      // Player direction line
      ctx.strokeStyle = THEME;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(rx + Math.cos(playerAngle) * 8, ry + Math.sin(playerAngle) * 8);
      ctx.stroke();

      // Enemies on radar
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 4;
      for (const e of enemies) {
        if (!e.alive) continue;
        const dx = e.x - playerX;
        const dz = e.z - playerZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        const angle = Math.atan2(dz, dx);
        const rdist = Math.min(dist / 15, rr - 4);
        const ex = rx + Math.cos(angle) * rdist;
        const ey = ry + Math.sin(angle) * rdist;
        ctx.beginPath();
        ctx.arc(ex, ey, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Radar label
      ctx.fillStyle = THEME_DIM;
      ctx.font = "8px 'Courier New', monospace";
      ctx.textAlign = 'center';
      ctx.fillText('RADAR', rx, ry + rr + 10);
    }

    function shoot() {
      if (fireCooldown > 0) return;
      fireCooldown = FIRE_COOLDOWN;
      playerBullets.push({
        x: playerX + Math.cos(playerAngle) * 10,
        z: playerZ + Math.sin(playerAngle) * 10,
        vx: Math.cos(playerAngle) * BULLET_SPEED,
        vz: Math.sin(playerAngle) * BULLET_SPEED,
        life: BULLET_LIFE
      });
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }

      keys[e.key] = true;
      if (e.key === ' ' && gameState === 'playing') shoot();
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

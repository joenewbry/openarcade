<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jetpack Joyride</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #4ce; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 204, 238, 0.5); }
    h1 { color: #4ce; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 204, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4ce; }
    canvas {
      border: 2px solid #4ce;
      box-shadow: 0 0 20px rgba(68, 204, 238, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4ce;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>JETPACK JOYRIDE</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">JETPACK JOYRIDE</h2>
      <p id="overlayText">Hold SPACE or CLICK to fly â€” Release to fall</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const GRAVITY = 0.4;
    const THRUST = -0.65;
    const MAX_VY = 7;
    const PLAYER_X = 70;
    const PLAYER_W = 20;
    const PLAYER_H = 32;
    const FLOOR_Y = H - 30;
    const CEIL_Y = 30;

    // --- Game state ---
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let player, obstacles, coins, particles, distance, scrollSpeed;
    let thrustOn = false;
    let frameCount, lastObstacleFrame, lastCoinFrame;
    let animFrame;
    let bgOffset = 0;

    // --- Obstacle types ---
    const OBS_ZAPPER = 'zapper';
    const OBS_MISSILE = 'missile';
    const OBS_LASER = 'laser';

    function init() {
      player = { x: PLAYER_X, y: H / 2, vy: 0, w: PLAYER_W, h: PLAYER_H };
      obstacles = [];
      coins = [];
      particles = [];
      distance = 0;
      scrollSpeed = 3;
      frameCount = 0;
      lastObstacleFrame = 0;
      lastCoinFrame = 0;
      thrustOn = false;
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'JETPACK JOYRIDE';
      overlayText.textContent = 'Hold SPACE or CLICK to fly \u2014 Release to fall';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      cancelAnimationFrame(animFrame);
      loop();
    }

    function gameOver() {
      gameState = 'over';
      cancelAnimationFrame(animFrame);
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    // --- Update ---
    function update() {
      frameCount++;
      distance += scrollSpeed;

      // Difficulty scaling: speed increases over time
      scrollSpeed = 3 + Math.min(frameCount / 3000, 3); // 3 -> 6 over ~50 seconds

      // Player physics
      if (thrustOn) {
        player.vy += THRUST;
      } else {
        player.vy += GRAVITY;
      }
      player.vy = Math.max(-MAX_VY, Math.min(MAX_VY, player.vy));
      player.y += player.vy;

      // Clamp to floor/ceiling
      if (player.y - player.h / 2 < CEIL_Y) {
        player.y = CEIL_Y + player.h / 2;
        player.vy = 0;
      }
      if (player.y + player.h / 2 > FLOOR_Y) {
        player.y = FLOOR_Y - player.h / 2;
        player.vy = 0;
      }

      // Thrust particles
      if (thrustOn && frameCount % 2 === 0) {
        spawnThrustParticle();
      }

      // Spawn obstacles
      const obstacleCooldown = Math.max(60, 150 - frameCount / 30);
      if (frameCount - lastObstacleFrame > obstacleCooldown) {
        spawnObstacle();
        lastObstacleFrame = frameCount;
      }

      // Spawn coins
      if (frameCount - lastCoinFrame > 40) {
        if (Math.random() < 0.4) {
          spawnCoinGroup();
        }
        lastCoinFrame = frameCount;
      }

      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        updateObstacle(obs);

        // Remove off-screen or expired obstacles
        let shouldRemove = false;
        if (obs.type === OBS_ZAPPER) {
          shouldRemove = obs.x < -obs.len;
        } else if (obs.type === OBS_MISSILE) {
          shouldRemove = obs.active && obs.x < -50;
        } else if (obs.type === OBS_LASER) {
          shouldRemove = obs.warnTimer <= 0 && obs.fireTimer <= 0 && !obs.active;
        }
        if (shouldRemove) {
          obstacles.splice(i, 1);
          continue;
        }

        // Collision
        if (obs.active !== false && checkCollision(player, obs)) {
          spawnDeathParticles();
          gameOver();
          return;
        }
      }

      // Update coins
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].x -= scrollSpeed;
        if (coins[i].x < -20) {
          coins.splice(i, 1);
          continue;
        }
        // Collect
        const dx = player.x - coins[i].x;
        const dy = player.y - coins[i].y;
        if (Math.sqrt(dx * dx + dy * dy) < 20) {
          score += 5;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          spawnCoinParticles(coins[i].x, coins[i].y);
          coins.splice(i, 1);
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life -= particles[i].decay;
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      // Score from distance
      const newDistScore = Math.floor(distance / 50);
      if (newDistScore > Math.floor((distance - scrollSpeed) / 50)) {
        score++;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
      }

      // Update gameData for ML
      window.gameData = {
        playerY: player.y,
        playerVY: player.vy,
        thrustOn: thrustOn,
        obstacles: obstacles.map(o => ({ type: o.type, x: o.x, y: o.y })),
        coins: coins.map(c => ({ x: c.x, y: c.y })),
        speed: scrollSpeed,
        distance: distance
      };
    }


    // --- Obstacle spawning ---
    function spawnObstacle() {
      const difficulty = Math.min(frameCount / 3600, 1);
      const roll = Math.random();

      if (roll < 0.4) {
        // Zapper: vertical rotating bar
        const y1 = CEIL_Y + 30 + Math.random() * (FLOOR_Y - CEIL_Y - 120);
        const len = 60 + Math.random() * 60;
        obstacles.push({
          type: OBS_ZAPPER,
          x: W + 20,
          y: y1,
          len: len,
          angle: Math.random() * Math.PI,
          rotSpeed: 0.03 + Math.random() * 0.02,
          w: 12,
          h: len
        });
      } else if (roll < 0.7) {
        // Missile: warned then flies from right
        const y = CEIL_Y + 30 + Math.random() * (FLOOR_Y - CEIL_Y - 60);
        obstacles.push({
          type: OBS_MISSILE,
          x: W + 40,
          y: y,
          vx: -(scrollSpeed + 2 + difficulty * 2),
          w: 30,
          h: 12,
          warned: false,
          warnTimer: 60,
          active: false
        });
      } else {
        // Laser: horizontal beam with warning
        const y = CEIL_Y + 40 + Math.random() * (FLOOR_Y - CEIL_Y - 80);
        obstacles.push({
          type: OBS_LASER,
          x: 0,
          y: y,
          w: W,
          h: 8,
          warnTimer: 90,
          fireTimer: 30,
          active: false,
          emitterX: W - 20
        });
      }
    }

    function updateObstacle(obs) {
      if (obs.type === OBS_ZAPPER) {
        obs.x -= scrollSpeed;
        obs.angle += obs.rotSpeed;
      } else if (obs.type === OBS_MISSILE) {
        if (obs.warnTimer > 0) {
          obs.warnTimer--;
          if (obs.warnTimer <= 0) {
            obs.active = true;
            obs.x = W + 10;
          }
        } else {
          obs.x += obs.vx;
        }
      } else if (obs.type === OBS_LASER) {
        if (obs.warnTimer > 0) {
          obs.warnTimer--;
        } else if (obs.fireTimer > 0) {
          obs.active = true;
          obs.fireTimer--;
        } else {
          obs.active = false;
        }
      }
    }

    // --- Collision detection ---
    function checkCollision(p, obs) {
      const px = p.x - p.w / 2;
      const py = p.y - p.h / 2;
      const pw = p.w;
      const ph = p.h;

      if (obs.type === OBS_ZAPPER) {
        // Check collision with rotated bar
        const cx = obs.x;
        const cy = obs.y + obs.len / 2;
        const halfLen = obs.len / 2;
        const barW = 6;

        // Two endpoints of the zapper bar
        const cos = Math.cos(obs.angle);
        const sin = Math.sin(obs.angle);
        const x1 = cx + cos * halfLen;
        const y1 = cy + sin * halfLen;
        const x2 = cx - cos * halfLen;
        const y2 = cy - sin * halfLen;

        // Point-to-line-segment distance from player center
        const dist = pointToSegmentDist(p.x, p.y, x1, y1, x2, y2);
        return dist < (pw / 2 + barW);
      } else if (obs.type === OBS_MISSILE) {
        return rectOverlap(px, py, pw, ph, obs.x - obs.w / 2, obs.y - obs.h / 2, obs.w, obs.h);
      } else if (obs.type === OBS_LASER) {
        return rectOverlap(px, py, pw, ph, obs.x, obs.y - obs.h / 2, obs.w, obs.h);
      }
      return false;
    }

    function rectOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
      return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    function pointToSegmentDist(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const lenSq = dx * dx + dy * dy;
      if (lenSq === 0) return Math.hypot(px - x1, py - y1);
      let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
      t = Math.max(0, Math.min(1, t));
      const projX = x1 + t * dx;
      const projY = y1 + t * dy;
      return Math.hypot(px - projX, py - projY);
    }

    // --- Coin spawning ---
    function spawnCoinGroup() {
      const count = 3 + Math.floor(Math.random() * 5);
      const baseY = CEIL_Y + 40 + Math.random() * (FLOOR_Y - CEIL_Y - 80);
      const pattern = Math.random();

      for (let i = 0; i < count; i++) {
        let cx, cy;
        if (pattern < 0.33) {
          // Horizontal line
          cx = W + 20 + i * 25;
          cy = baseY;
        } else if (pattern < 0.66) {
          // Diagonal
          cx = W + 20 + i * 25;
          cy = baseY + i * 15;
        } else {
          // Arc
          cx = W + 20 + i * 25;
          cy = baseY + Math.sin(i * 0.8) * 40;
        }
        coins.push({ x: cx, y: cy, collected: false });
      }
    }

    // --- Particles ---
    function spawnThrustParticle() {
      // Particles emit from the jetpack nozzle (bottom-left of player)
      particles.push({
        x: player.x - player.w / 2 - 3 + Math.random() * 6,
        y: player.y + player.h / 2 + 2,
        vx: (Math.random() - 0.5) * 1.5,
        vy: 2 + Math.random() * 3,
        life: 1,
        decay: 0.04 + Math.random() * 0.03,
        color: Math.random() < 0.5 ? '#f80' : '#ff0',
        size: 3 + Math.random() * 3
      });
    }

    function spawnCoinParticles(cx, cy) {
      for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          decay: 0.05,
          color: '#fd0',
          size: 2 + Math.random() * 2
        });
      }
    }

    function spawnDeathParticles() {
      for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        particles.push({
          x: player.x, y: player.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          decay: 0.02,
          color: Math.random() < 0.5 ? '#4ce' : '#f44',
          size: 3 + Math.random() * 4
        });
      }
    }

    // --- Drawing ---
    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Scrolling background grid lines
      bgOffset = (bgOffset + scrollSpeed * 0.3) % 40;
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      for (let x = -bgOffset; x < W; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, CEIL_Y);
        ctx.lineTo(x, FLOOR_Y);
        ctx.stroke();
      }
      for (let y = CEIL_Y; y <= FLOOR_Y; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Floor and ceiling
      ctx.fillStyle = '#0f3460';
      ctx.fillRect(0, 0, W, CEIL_Y);
      ctx.fillRect(0, FLOOR_Y, W, H - FLOOR_Y);

      // Floor/ceiling edge glow
      ctx.shadowColor = '#4ce';
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#4ce';
      ctx.fillRect(0, CEIL_Y - 1, W, 2);
      ctx.fillRect(0, FLOOR_Y - 1, W, 2);
      ctx.shadowBlur = 0;

      // Distance indicator on floor
      ctx.fillStyle = '#1a3a6e';
      ctx.font = '10px Courier New';
      const distMarkers = Math.floor(distance / 200);
      for (let i = 0; i < 8; i++) {
        const mx = W - ((distance % 200) / 200 * 200) + i * 200 - 400;
        if (mx > 0 && mx < W) {
          const mDist = (distMarkers - 3 + i) * 200;
          if (mDist >= 0) {
            ctx.fillText(`${mDist}m`, mx, FLOOR_Y + 15);
          }
        }
      }

      // Draw obstacles
      obstacles.forEach(obs => drawObstacle(obs));

      // Draw coins
      coins.forEach(c => drawCoin(c));

      // Draw player
      drawPlayer();

      // Draw particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Score on canvas (distance counter)
      ctx.fillStyle = '#4ce';
      ctx.shadowColor = '#4ce';
      ctx.shadowBlur = 6;
      ctx.font = '14px Courier New';
      ctx.fillText(`${Math.floor(distance)}m`, W - 80, CEIL_Y + 20);
      ctx.shadowBlur = 0;
    }

    function drawPlayer() {
      const px = player.x;
      const py = player.y;

      // Jetpack body
      ctx.fillStyle = '#4ce';
      ctx.shadowColor = '#4ce';
      ctx.shadowBlur = 10;

      // Body rectangle
      ctx.fillRect(px - player.w / 2, py - player.h / 2, player.w, player.h);
      ctx.shadowBlur = 0;

      // Helmet visor
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(px - player.w / 2 + 3, py - player.h / 2 + 3, player.w - 6, 10);
      ctx.fillStyle = '#8ef';
      ctx.fillRect(px - player.w / 2 + 4, py - player.h / 2 + 4, player.w - 8, 8);

      // Jetpack on back
      ctx.fillStyle = '#38a';
      ctx.fillRect(px - player.w / 2 - 6, py - 6, 6, 18);

      // Thrust flame
      if (thrustOn) {
        const flameLen = 10 + Math.random() * 15;
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.moveTo(px - player.w / 2 - 6, py - 2);
        ctx.lineTo(px - player.w / 2 - 6 - flameLen, py + 4);
        ctx.lineTo(px - player.w / 2 - 6, py + 10);
        ctx.closePath();
        ctx.fill();

        // Inner flame
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.beginPath();
        ctx.moveTo(px - player.w / 2 - 6, py);
        ctx.lineTo(px - player.w / 2 - 6 - flameLen * 0.5, py + 4);
        ctx.lineTo(px - player.w / 2 - 6, py + 8);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Legs (simple)
      ctx.fillStyle = '#4ce';
      ctx.fillRect(px - 5, py + player.h / 2, 4, 6);
      ctx.fillRect(px + 1, py + player.h / 2, 4, 6);
    }

    function drawObstacle(obs) {
      if (obs.type === OBS_ZAPPER) {
        const cx = obs.x;
        const cy = obs.y + obs.len / 2;
        const halfLen = obs.len / 2;
        const cos = Math.cos(obs.angle);
        const sin = Math.sin(obs.angle);
        const x1 = cx + cos * halfLen;
        const y1 = cy + sin * halfLen;
        const x2 = cx - cos * halfLen;
        const y2 = cy - sin * halfLen;

        // Zapper bar
        ctx.strokeStyle = '#f44';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 12;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // Endpoints (yellow orbs)
        ctx.fillStyle = '#ff0';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(x1, y1, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x2, y2, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;

        // Electricity effect
        if (frameCount % 4 < 2) {
          ctx.strokeStyle = '#ff8';
          ctx.lineWidth = 1;
          ctx.beginPath();
          const segments = 6;
          for (let s = 0; s <= segments; s++) {
            const t = s / segments;
            const lx = x1 + (x2 - x1) * t + (s > 0 && s < segments ? (Math.random() - 0.5) * 12 : 0);
            const ly = y1 + (y2 - y1) * t + (s > 0 && s < segments ? (Math.random() - 0.5) * 12 : 0);
            if (s === 0) ctx.moveTo(lx, ly);
            else ctx.lineTo(lx, ly);
          }
          ctx.stroke();
          ctx.lineWidth = 1;
        }
      } else if (obs.type === OBS_MISSILE) {
        if (obs.warnTimer > 0) {
          // Warning indicator on right side
          const blink = Math.floor(obs.warnTimer / 5) % 2 === 0;
          if (blink) {
            ctx.fillStyle = '#f44';
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 10;
            ctx.font = 'bold 16px Courier New';
            ctx.fillText('!', W - 15, obs.y + 5);
            // Warning line
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(W - 20, obs.y);
            ctx.lineTo(0, obs.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
          }
        } else {
          // Missile body
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 8;

          // Body (pointing left - direction of travel)
          ctx.beginPath();
          ctx.moveTo(obs.x - obs.w / 2, obs.y);
          ctx.lineTo(obs.x + obs.w / 2, obs.y - obs.h / 2);
          ctx.lineTo(obs.x + obs.w / 2, obs.y + obs.h / 2);
          ctx.closePath();
          ctx.fill();

          // Exhaust (trailing right)
          ctx.fillStyle = '#f80';
          ctx.shadowColor = '#f80';
          const exLen = 5 + Math.random() * 10;
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.w / 2, obs.y - 3);
          ctx.lineTo(obs.x + obs.w / 2 + exLen, obs.y);
          ctx.lineTo(obs.x + obs.w / 2, obs.y + 3);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      } else if (obs.type === OBS_LASER) {
        if (obs.warnTimer > 0) {
          // Warning: thin dashed line and emitter glow
          const blink = Math.floor(obs.warnTimer / 8) % 2 === 0;
          if (blink) {
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(0, obs.y);
            ctx.lineTo(W, obs.y);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          // Emitter nodes
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = obs.warnTimer < 30 ? 12 : 6;
          ctx.beginPath();
          ctx.arc(10, obs.y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(W - 10, obs.y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (obs.active) {
          // Active laser beam
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 20;
          ctx.fillRect(0, obs.y - obs.h / 2, W, obs.h);
          // Inner bright beam
          ctx.fillStyle = '#faa';
          ctx.fillRect(0, obs.y - obs.h / 4, W, obs.h / 2);
          // Emitter nodes
          ctx.fillStyle = '#f44';
          ctx.beginPath();
          ctx.arc(10, obs.y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(W - 10, obs.y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawCoin(c) {
      // Gold coin with glow
      ctx.fillStyle = '#fd0';
      ctx.shadowColor = '#fd0';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      // Coin shape: slightly oval based on animation
      const scaleX = 0.5 + 0.5 * Math.abs(Math.cos(frameCount * 0.06 + c.x * 0.01));
      ctx.ellipse(c.x, c.y, 6 * scaleX, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // Inner highlight
      if (scaleX > 0.3) {
        ctx.fillStyle = '#ff8';
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, 3 * scaleX, 3, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    // --- Input handling ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        if (e.key === ' ' || e.key === 'ArrowUp') thrustOn = true;
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ' || e.key === 'ArrowUp') {
          thrustOn = true;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        thrustOn = false;
      }
    });

    // Mouse/touch controls
    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      if (gameState === 'waiting') {
        start();
        thrustOn = true;
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing') {
        thrustOn = true;
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      thrustOn = false;
    });

    // Also handle mouse leaving canvas
    canvas.addEventListener('mouseleave', (e) => {
      if (gameState === 'playing') {
        thrustOn = false;
      }
    });

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameState === 'waiting') {
        start();
        thrustOn = true;
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState === 'playing') {
        thrustOn = true;
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      thrustOn = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

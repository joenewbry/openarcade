<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rally-X</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #4fd; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 255, 221, 0.5); }
    h1 { color: #4fd; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 255, 221, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4fd; }
    canvas {
      border: 2px solid #4fd;
      box-shadow: 0 0 20px rgba(68, 255, 221, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4fd;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>RALLY-X</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">RALLY-X</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // --- Constants ---
    const TILE = 24;          // maze tile size in world pixels
    const MAZE_COLS = 50;     // maze width in tiles (increased from 40)
    const MAZE_ROWS = 50;     // maze height in tiles (increased from 40)
    const MAZE_W = MAZE_COLS * TILE;
    const MAZE_H = MAZE_ROWS * TILE;
    const CAR_SIZE = 16;
    const CAR_SPEED = 3;      // increased from 2
    const ENEMY_SPEED_BASE = 0.8;  // decreased from 1.4
    const FLAG_SIZE = 10;
    const SMOKE_RADIUS = 12;
    const SMOKE_DURATION = 180;  // frames smoke lasts
    const SMOKE_SLOW_FACTOR = 0.3;
    const FUEL_MAX = 1200;    // increased fuel
    const FUEL_DRAIN = 0.3;   // reduced fuel drain
    const FUEL_SMOKE_COST = 30; // reduced smoke cost
    const SMOKE_MAX = 12;     // increased smoke capacity
    const RADAR_SIZE = 100;
    const RADAR_MARGIN = 8;

    // Direction vectors: 0=up, 1=right, 2=down, 3=left
    const DX = [0, 1, 0, -1];
    const DY = [-1, 0, 1, 0];

    // --- Game state variables ---
    let maze;       // 2D array: 0=wall, 1=path
    let player;     // {x, y, dir, moving}
    let enemies;    // [{x, y, dir, speed}]
    let flags;      // [{x, y, collected}]
    let smokes;     // [{x, y, timer}]
    let fuel;
    let smokeCount;
    let level;
    let flagsLeft;
    let frameCount;
    let keys;
    let cameraX, cameraY;
    let roundBonus;
    let bonusTimer;    // countdown to show bonus
    let showingBonus;

    // --- Maze generation (more open for early levels) ---
    function generateMaze(cols, rows) {
      // Start with all walls
      const m = [];
      for (let r = 0; r < rows; r++) {
        m[r] = [];
        for (let c = 0; c < cols; c++) {
          m[r][c] = 0;
        }
      }

      // Carve paths using randomized DFS on odd cells
      function carve(cx, cy) {
        m[cy][cx] = 1;
        const dirs = [0, 1, 2, 3];
        // Shuffle directions
        for (let i = dirs.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
        }
        for (const d of dirs) {
          const nx = cx + DX[d] * 2;
          const ny = cy + DY[d] * 2;
          if (nx >= 1 && nx < cols - 1 && ny >= 1 && ny < rows - 1 && m[ny][nx] === 0) {
            m[cy + DY[d]][cx + DX[d]] = 1; // carve wall between
            carve(nx, ny);
          }
        }
      }

      carve(1, 1);

      // Add extra passages to make maze more open (especially for early levels)
      const basePassages = Math.floor(cols * rows * 0.12); // increased from 0.08
      const levelMultiplier = Math.max(0.5, 1 - (level - 1) * 0.1); // More open early levels
      const extraPassages = Math.floor(basePassages * levelMultiplier);
      
      for (let i = 0; i < extraPassages; i++) {
        const rx = 1 + Math.floor(Math.random() * (cols - 2));
        const ry = 1 + Math.floor(Math.random() * (rows - 2));
        if (m[ry][rx] === 0) {
          // Check if at least 2 adjacent cells are paths (more lenient for early levels)
          let adj = 0;
          if (ry > 0 && m[ry - 1][rx] === 1) adj++;
          if (ry < rows - 1 && m[ry + 1][rx] === 1) adj++;
          if (rx > 0 && m[ry][rx - 1] === 1) adj++;
          if (rx < cols - 1 && m[ry][rx + 1] === 1) adj++;
          const minAdj = level <= 3 ? 1 : 2; // More lenient for first 3 levels
          if (adj >= minAdj) {
            m[ry][rx] = 1;
          }
        }
      }

      return m;
    }

    // Check if a world-coordinate rectangle is on a path (not colliding with walls)
    function isPassable(wx, wy, size) {
      const margin = 2;
      const x1 = wx + margin;
      const y1 = wy + margin;
      const x2 = wx + size - margin - 1;
      const y2 = wy + size - margin - 1;

      // Check four corners
      const corners = [
        [Math.floor(x1 / TILE), Math.floor(y1 / TILE)],
        [Math.floor(x2 / TILE), Math.floor(y1 / TILE)],
        [Math.floor(x1 / TILE), Math.floor(y2 / TILE)],
        [Math.floor(x2 / TILE), Math.floor(y2 / TILE)]
      ];

      for (const [col, row] of corners) {
        if (col < 0 || col >= MAZE_COLS || row < 0 || row >= MAZE_ROWS) return false;
        if (maze[row][col] === 0) return false;
      }
      return true;
    }

    // Find a random passable cell, returning its center in world coords
    function randomPassablePos() {
      let attempts = 0;
      while (attempts < 1000) {
        const col = 1 + Math.floor(Math.random() * (MAZE_COLS - 2));
        const row = 1 + Math.floor(Math.random() * (MAZE_ROWS - 2));
        if (maze[row][col] === 1) {
          return { x: col * TILE + (TILE - CAR_SIZE) / 2, y: row * TILE + (TILE - CAR_SIZE) / 2 };
        }
        attempts++;
      }
      return { x: TILE + 4, y: TILE + 4 };
    }

    // BFS-based pathfinding for enemies
    function bfsDirection(fromX, fromY, toX, toY) {
      const fc = Math.floor((fromX + CAR_SIZE / 2) / TILE);
      const fr = Math.floor((fromY + CAR_SIZE / 2) / TILE);
      const tc = Math.floor((toX + CAR_SIZE / 2) / TILE);
      const tr = Math.floor((toY + CAR_SIZE / 2) / TILE);

      if (fc === tc && fr === tr) return -1;

      const visited = new Set();
      const queue = [];
      // Each entry: [col, row, firstDir]
      for (let d = 0; d < 4; d++) {
        const nc = fc + DX[d];
        const nr = fr + DY[d];
        if (nc >= 0 && nc < MAZE_COLS && nr >= 0 && nr < MAZE_ROWS && maze[nr][nc] === 1) {
          if (nc === tc && nr === tr) return d;
          const key = nr * MAZE_COLS + nc;
          if (!visited.has(key)) {
            visited.add(key);
            queue.push([nc, nr, d]);
          }
        }
      }

      let idx = 0;
      while (idx < queue.length && idx < 2000) {
        const [c, r, firstDir] = queue[idx++];
        for (let d = 0; d < 4; d++) {
          const nc = c + DX[d];
          const nr = r + DY[d];
          if (nc >= 0 && nc < MAZE_COLS && nr >= 0 && nr < MAZE_ROWS && maze[nr][nc] === 1) {
            if (nc === tc && nr === tr) return firstDir;
            const key = nr * MAZE_COLS + nc;
            if (!visited.has(key)) {
              visited.add(key);
              queue.push([nc, nr, firstDir]);
            }
          }
        }
      }

      // Fallback: random passable direction
      const dirs = [0, 1, 2, 3];
      for (let i = dirs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
      }
      for (const d of dirs) {
        const nc = fc + DX[d];
        const nr = fr + DY[d];
        if (nc >= 0 && nc < MAZE_COLS && nr >= 0 && nr < MAZE_ROWS && maze[nr][nc] === 1) return d;
      }
      return 0;
    }

    // --- Init ---
    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      level = 1;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'RALLY-X';
      overlayText.textContent = 'Arrow keys to steer, Space for smoke\nPress any key to start';
      keys = {};
      setupLevel();
      draw();
    }

    function setupLevel() {
      maze = generateMaze(MAZE_COLS, MAZE_ROWS);
      player = { ...randomPassablePos(), dir: 1, moving: false };

      // Place flags (fewer in early levels)
      const baseFlags = Math.max(6, 8 - Math.floor(level * 0.3));
      const numFlags = baseFlags + Math.floor(level * 1.2);
      flags = [];
      for (let i = 0; i < numFlags; i++) {
        let pos;
        let tooClose = true;
        let attempts = 0;
        while (tooClose && attempts < 100) {
          pos = randomPassablePos();
          tooClose = false;
          // Don't place too close to player
          const dx = pos.x - player.x;
          const dy = pos.y - player.y;
          if (Math.sqrt(dx * dx + dy * dy) < TILE * 8) tooClose = true; // Increased distance
          // Don't place too close to other flags
          for (const f of flags) {
            const fdx = pos.x - f.x;
            const fdy = pos.y - f.y;
            if (Math.sqrt(fdx * fdx + fdy * fdy) < TILE * 4) { tooClose = true; break; }
          }
          attempts++;
        }
        flags.push({ x: pos.x, y: pos.y, collected: false });
      }
      flagsLeft = flags.length;

      // Place enemies (fewer in early levels, slower speed progression)
      const numEnemies = Math.max(1, 2 + Math.floor((level - 1) * 0.8));
      enemies = [];
      for (let i = 0; i < numEnemies; i++) {
        let pos;
        let tooClose = true;
        let attempts = 0;
        while (tooClose && attempts < 100) {
          pos = randomPassablePos();
          const dx = pos.x - player.x;
          const dy = pos.y - player.y;
          const minDistance = level <= 3 ? TILE * 15 : TILE * 12; // Farther start distance for early levels
          tooClose = Math.sqrt(dx * dx + dy * dy) < minDistance;
          attempts++;
        }
        enemies.push({
          x: pos.x, y: pos.y,
          dir: Math.floor(Math.random() * 4),
          speed: ENEMY_SPEED_BASE + Math.max(0, (level - 1) * 0.08 + Math.random() * 0.2), // Slower progression
          moveTimer: 0,
          slowed: 0
        });
      }

      smokes = [];
      fuel = FUEL_MAX;
      smokeCount = SMOKE_MAX;
      frameCount = 0;
      roundBonus = 0;
      bonusTimer = 0;
      showingBonus = false;

      // Initialize camera
      cameraX = player.x + CAR_SIZE / 2 - W / 2;
      cameraY = player.y + CAR_SIZE / 2 - H / 2;
      cameraX = Math.max(0, Math.min(MAZE_W - W, cameraX));
      cameraY = Math.max(0, Math.min(MAZE_H - H, cameraY));
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Level: ${level}\nPress any key to restart`;
    }

    function roundComplete() {
      // Bonus for completing all flags
      roundBonus = 1000 * level;
      score += roundBonus;
      scoreEl.textContent = score;
      if (score > best) { best = score; bestEl.textContent = best; }
      level++;
      setupLevel();
      showingBonus = true;
      bonusTimer = 120;
    }

    // --- Update ---
    function update() {
      frameCount++;

      // Handle bonus display between rounds
      if (showingBonus) {
        bonusTimer--;
        if (bonusTimer <= 0) showingBonus = false;
        return;
      }

      // Player input
      let wantDir = -1;
      if (keys['ArrowUp']) wantDir = 0;
      else if (keys['ArrowRight']) wantDir = 1;
      else if (keys['ArrowDown']) wantDir = 2;
      else if (keys['ArrowLeft']) wantDir = 3;

      // Try to move player in desired direction
      player.moving = false;
      if (wantDir >= 0) {
        const nx = player.x + DX[wantDir] * CAR_SPEED;
        const ny = player.y + DY[wantDir] * CAR_SPEED;
        if (isPassable(nx, ny, CAR_SIZE)) {
          player.x = nx;
          player.y = ny;
          player.dir = wantDir;
          player.moving = true;
        } else {
          // Try continuing in current direction if desired is blocked
          const cx = player.x + DX[player.dir] * CAR_SPEED;
          const cy = player.y + DY[player.dir] * CAR_SPEED;
          if (isPassable(cx, cy, CAR_SIZE)) {
            player.x = cx;
            player.y = cy;
            player.moving = true;
          }
        }
      }

      // Fuel drain
      if (player.moving) {
        fuel -= FUEL_DRAIN;
      } else {
        fuel -= FUEL_DRAIN * 0.2; // idle drain
      }
      if (fuel <= 0) {
        fuel = 0;
        gameOver();
        return;
      }

      // Check flag collection
      const pcx = player.x + CAR_SIZE / 2;
      const pcy = player.y + CAR_SIZE / 2;
      for (const flag of flags) {
        if (flag.collected) continue;
        const dx = pcx - (flag.x + FLAG_SIZE / 2);
        const dy = pcy - (flag.y + FLAG_SIZE / 2);
        if (Math.abs(dx) < (CAR_SIZE + FLAG_SIZE) / 2 && Math.abs(dy) < (CAR_SIZE + FLAG_SIZE) / 2) {
          flag.collected = true;
          flagsLeft--;
          // Special flag: first flag worth less, gets more valuable
          const flagValue = 100 + (flags.length - flagsLeft) * 50;
          score += flagValue;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }

          if (flagsLeft <= 0) {
            roundComplete();
            return;
          }
        }
      }

      // Update smokes
      for (let i = smokes.length - 1; i >= 0; i--) {
        smokes[i].timer--;
        if (smokes[i].timer <= 0) {
          smokes.splice(i, 1);
        }
      }

      // Update enemies
      for (const enemy of enemies) {
        // Check if slowed by smoke
        let speedMult = 1;
        if (enemy.slowed > 0) {
          enemy.slowed--;
          speedMult = SMOKE_SLOW_FACTOR;
        }

        // Check for smoke collision
        for (const smoke of smokes) {
          const sdx = (enemy.x + CAR_SIZE / 2) - smoke.x;
          const sdy = (enemy.y + CAR_SIZE / 2) - smoke.y;
          if (Math.sqrt(sdx * sdx + sdy * sdy) < SMOKE_RADIUS + CAR_SIZE / 2) {
            enemy.slowed = 30; // slowed for 30 frames
            speedMult = SMOKE_SLOW_FACTOR;
          }
        }

        // Pathfind toward player (recalculate every ~30 frames or when stuck)
        enemy.moveTimer++;
        if (enemy.moveTimer >= 20 + Math.floor(Math.random() * 15)) {
          enemy.moveTimer = 0;
          const newDir = bfsDirection(enemy.x, enemy.y, player.x, player.y);
          if (newDir >= 0) enemy.dir = newDir;
        }

        // Move enemy
        const espeed = enemy.speed * speedMult;
        const enx = enemy.x + DX[enemy.dir] * espeed;
        const eny = enemy.y + DY[enemy.dir] * espeed;
        if (isPassable(enx, eny, CAR_SIZE)) {
          enemy.x = enx;
          enemy.y = eny;
        } else {
          // Try alternative directions
          enemy.moveTimer = 999; // force recalc next frame
          const dirs = [0, 1, 2, 3];
          for (let i = dirs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
          }
          for (const d of dirs) {
            const ax = enemy.x + DX[d] * espeed;
            const ay = enemy.y + DY[d] * espeed;
            if (isPassable(ax, ay, CAR_SIZE)) {
              enemy.x = ax;
              enemy.y = ay;
              enemy.dir = d;
              break;
            }
          }
        }

        // Check collision with player
        const edx = (enemy.x + CAR_SIZE / 2) - pcx;
        const edy = (enemy.y + CAR_SIZE / 2) - pcy;
        if (Math.abs(edx) < CAR_SIZE * 0.8 && Math.abs(edy) < CAR_SIZE * 0.8) {
          gameOver();
          return;
        }
      }

      // Update camera
      cameraX = player.x + CAR_SIZE / 2 - W / 2;
      cameraY = player.y + CAR_SIZE / 2 - H / 2;
      cameraX = Math.max(0, Math.min(MAZE_W - W, cameraX));
      cameraY = Math.max(0, Math.min(MAZE_H - H, cameraY));

      // Update gameData for ML
      window.gameData = {
        playerX: player.x, playerY: player.y, playerDir: player.dir,
        fuel: fuel, flagsLeft: flagsLeft, level: level,
        enemies: enemies.map(e => ({ x: e.x, y: e.y }))
      };
    }

    // --- Draw ---
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (gameState === 'waiting') {
        drawMazePreview();
        return;
      }

      ctx.save();
      ctx.translate(-cameraX, -cameraY);

      drawMaze();
      drawFlags();
      drawSmokes();
      drawEnemies();
      drawPlayer();

      ctx.restore();

      // HUD
      drawFuelGauge();
      drawSmokeCounter();
      drawRadar();
      drawLevelIndicator();

      if (showingBonus) {
        drawBonusText();
      }
    }

    function drawMazePreview() {
      // Draw a small portion of maze as preview
      const scale = 2;
      ctx.save();
      ctx.translate(W / 2 - MAZE_COLS * scale / 2, H / 2 - MAZE_ROWS * scale / 2);
      for (let r = 0; r < MAZE_ROWS; r++) {
        for (let c = 0; c < MAZE_COLS; c++) {
          if (maze[r][c] === 0) {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(c * scale, r * scale, scale, scale);
          } else {
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(c * scale, r * scale, scale, scale);
          }
        }
      }
      ctx.restore();
    }

    function drawMaze() {
      // Only draw visible tiles for performance
      const startCol = Math.max(0, Math.floor(cameraX / TILE));
      const endCol = Math.min(MAZE_COLS, Math.ceil((cameraX + W) / TILE) + 1);
      const startRow = Math.max(0, Math.floor(cameraY / TILE));
      const endRow = Math.min(MAZE_ROWS, Math.ceil((cameraY + H) / TILE) + 1);

      for (let r = startRow; r < endRow; r++) {
        for (let c = startCol; c < endCol; c++) {
          const x = c * TILE;
          const y = r * TILE;
          if (maze[r][c] === 0) {
            // Wall
            ctx.fillStyle = '#16213e';
            ctx.fillRect(x, y, TILE, TILE);
            // Wall accent border
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(x, y, TILE, 1);
            ctx.fillRect(x, y, 1, TILE);
          } else {
            // Path
            ctx.fillStyle = '#0d1b2a';
            ctx.fillRect(x, y, TILE, TILE);
            // Subtle grid
            ctx.fillStyle = '#111d30';
            ctx.fillRect(x, y, TILE, 1);
            ctx.fillRect(x, y, 1, TILE);
          }
        }
      }
    }

    function drawPlayer() {
      const x = player.x;
      const y = player.y;
      const cx = x + CAR_SIZE / 2;
      const cy = y + CAR_SIZE / 2;

      // Glow
      ctx.shadowColor = '#4fd';
      ctx.shadowBlur = 14;

      // Car body
      ctx.fillStyle = '#4fd';
      ctx.save();
      ctx.translate(cx, cy);
      // Rotate based on direction
      ctx.rotate(player.dir * Math.PI / 2);

      // Car shape (pointing up)
      ctx.beginPath();
      ctx.moveTo(0, -CAR_SIZE / 2);        // front
      ctx.lineTo(CAR_SIZE / 3, CAR_SIZE / 3);
      ctx.lineTo(-CAR_SIZE / 3, CAR_SIZE / 3);
      ctx.closePath();
      ctx.fill();

      // Body rectangle
      ctx.fillRect(-CAR_SIZE / 3, -CAR_SIZE / 4, CAR_SIZE * 2 / 3, CAR_SIZE / 2);

      ctx.restore();

      // Exhaust puff when moving
      if (player.moving && frameCount % 4 < 2) {
        const ex = cx - DX[player.dir] * CAR_SIZE * 0.6;
        const ey = cy - DY[player.dir] * CAR_SIZE * 0.6;
        ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(ex, ey, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;
    }

    function drawEnemies() {
      for (const enemy of enemies) {
        const cx = enemy.x + CAR_SIZE / 2;
        const cy = enemy.y + CAR_SIZE / 2;

        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 10;
        ctx.fillStyle = enemy.slowed > 0 ? '#a44' : '#f44';

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(enemy.dir * Math.PI / 2);

        // Enemy car shape
        ctx.beginPath();
        ctx.moveTo(0, -CAR_SIZE / 2);
        ctx.lineTo(CAR_SIZE / 3, CAR_SIZE / 3);
        ctx.lineTo(-CAR_SIZE / 3, CAR_SIZE / 3);
        ctx.closePath();
        ctx.fill();
        ctx.fillRect(-CAR_SIZE / 3, -CAR_SIZE / 4, CAR_SIZE * 2 / 3, CAR_SIZE / 2);

        ctx.restore();
        ctx.shadowBlur = 0;
      }
    }

    function drawFlags() {
      for (const flag of flags) {
        if (flag.collected) continue;
        const fx = flag.x + FLAG_SIZE / 2;
        const
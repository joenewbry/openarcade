<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SimCity</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #fa0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 170, 0, 0.5); }
    h1 { color: #fa0; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 170, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #fa0; }
    canvas {
      border: 2px solid #fa0;
      box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fa0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-top: 8px;
      font-size: 0.85rem;
      color: #888;
    }
    .info-bar .zone-info { display: flex; gap: 12px; flex-wrap: wrap; }
    .info-bar .zkey { padding: 1px 5px; border: 1px solid #555; border-radius: 3px; font-size: 0.8rem; color: #aaa; }
    .info-bar .zkey.active { border-color: #fa0; color: #fa0; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SIMCITY</h1>
  </div>
  <div class="score-bar">
    <div>Pop: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">SIMCITY</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>
  <div class="info-bar">
    <div class="zone-info">
      <span><span class="zkey" id="zk1">1</span> Residential $10</span>
      <span><span class="zkey" id="zk2">2</span> Commercial $15</span>
      <span><span class="zkey" id="zk3">3</span> Industrial $15</span>
      <span><span class="zkey" id="zk4">4</span> Road $5</span>
      <span><span class="zkey" id="zk5">5</span> Power $50</span>
      <span><span class="zkey" id="zk6">6</span> Park $20</span>
    </div>
    <div>Click to place | Arrows to scroll</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid
    const GRID = 30;
    const MAP_SIZE = 40; // 40x40 world grid
    const VIEW_COLS = Math.floor(W / GRID); // 20 visible
    const VIEW_ROWS = Math.floor(H / GRID); // 20 visible

    // Zone types
    const ZONE = {
      EMPTY: 0,
      RESIDENTIAL: 1,
      COMMERCIAL: 2,
      INDUSTRIAL: 3,
      ROAD: 4,
      POWER: 5,
      PARK: 6
    };

    const ZONE_NAMES = ['Empty', 'Residential', 'Commercial', 'Industrial', 'Road', 'Power Plant', 'Park'];
    const ZONE_COSTS = [0, 10, 15, 15, 5, 50, 20];
    const ZONE_COLORS = [
      '#1a1a2e',   // empty
      '#0c4',      // residential - green
      '#28f',      // commercial - blue
      '#ec0',      // industrial - yellow
      '#666',      // road - gray
      '#f33',      // power - red
      '#3b3',      // park - bright green
    ];
    const ZONE_GLOW = [
      '',
      '#0c4',
      '#28f',
      '#ec0',
      '#888',
      '#f33',
      '#3b3',
    ];

    // Game state
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let money, population, happiness, tick;
    let map, levelMap, poweredMap;
    let selectedZone, viewX, viewY;
    let mouseX, mouseY;
    let keys = {};
    let scrollSpeed = 3;
    let taxTimer, growthTimer, bankruptTimer;
    let lastTime, animFrame;
    let placeFeedback = []; // Visual feedback for placements
    let particles = [];

    function init() {
      score = 0;
      money = 500;
      population = 0;
      happiness = 50;
      tick = 0;
      taxTimer = 0;
      growthTimer = 0;
      bankruptTimer = 0;
      selectedZone = ZONE.RESIDENTIAL;
      viewX = 10; // Center the view
      viewY = 10;
      mouseX = -1;
      mouseY = -1;
      placeFeedback = [];
      particles = [];

      // Initialize maps
      map = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(ZONE.EMPTY));
      levelMap = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(0));
      poweredMap = Array.from({ length: MAP_SIZE }, () => Array(MAP_SIZE).fill(false));

      // Place some starter roads in center
      const cx = 20, cy = 20;
      for (let i = -3; i <= 3; i++) {
        map[cy][cx + i] = ZONE.ROAD;
        map[cy + i][cx] = ZONE.ROAD;
      }
      // Starter power plant
      map[cy - 1][cx - 1] = ZONE.POWER;
      // Starter residential
      map[cy - 1][cx + 1] = ZONE.RESIDENTIAL;
      map[cy + 1][cx + 1] = ZONE.RESIDENTIAL;
      // Starter commercial
      map[cy + 1][cx - 1] = ZONE.COMMERCIAL;

      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SIMCITY';
      overlayText.textContent = 'Press SPACE to start';
      updateZoneKeyIndicators();
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      loop();
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BANKRUPT';
      overlayText.textContent = `Population: ${score} -- Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      update(dt);
      draw();
      animFrame = requestAnimationFrame(loop);
    }

    // Check if cell is adjacent to a road
    function nearRoad(x, y) {
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      return dirs.some(([dx, dy]) => {
        const nx = x + dx, ny = y + dy;
        return nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE && map[ny][nx] === ZONE.ROAD;
      });
    }

    // Calculate power coverage using flood fill from power plants
    function updatePower() {
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          poweredMap[y][x] = false;

      const POWER_RANGE = 6;
      for (let py = 0; py < MAP_SIZE; py++) {
        for (let px = 0; px < MAP_SIZE; px++) {
          if (map[py][px] === ZONE.POWER) {
            // BFS power spread along roads and zones
            const visited = new Set();
            const queue = [{ x: px, y: py, dist: 0 }];
            visited.add(px + ',' + py);
            poweredMap[py][px] = true;

            while (queue.length > 0) {
              const { x, y, dist } = queue.shift();
              if (dist >= POWER_RANGE) continue;

              const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
              for (const [dx, dy] of dirs) {
                const nx = x + dx, ny = y + dy;
                const key = nx + ',' + ny;
                if (nx < 0 || nx >= MAP_SIZE || ny < 0 || ny >= MAP_SIZE) continue;
                if (visited.has(key)) continue;
                if (map[ny][nx] === ZONE.EMPTY) continue;
                visited.add(key);
                poweredMap[ny][nx] = true;
                queue.push({ x: nx, y: ny, dist: dist + 1 });
              }
            }
          }
        }
      }
    }

    // Calculate happiness based on parks, population density, etc.
    function calcHappiness() {
      let totalHappy = 0;
      let resCount = 0;

      for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
          if (map[y][x] === ZONE.RESIDENTIAL && levelMap[y][x] > 0) {
            resCount++;
            let cellHappy = 40; // Base happiness

            // Nearby parks boost happiness
            for (let dy = -3; dy <= 3; dy++) {
              for (let dx = -3; dx <= 3; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE) {
                  if (map[ny][nx] === ZONE.PARK) cellHappy += 12;
                }
              }
            }

            // Nearby industrial lowers happiness
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE) {
                  if (map[ny][nx] === ZONE.INDUSTRIAL) cellHappy -= 8;
                }
              }
            }

            // Commercial nearby helps
            for (let dy = -3; dy <= 3; dy++) {
              for (let dx = -3; dx <= 3; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < MAP_SIZE && ny >= 0 && ny < MAP_SIZE) {
                  if (map[ny][nx] === ZONE.COMMERCIAL && levelMap[ny][nx] > 0) cellHappy += 5;
                }
              }
            }

            totalHappy += Math.max(0, Math.min(100, cellHappy));
          }
        }
      }

      return resCount > 0 ? Math.round(totalHappy / resCount) : 50;
    }

    // Count zones of a type
    function countZones(type) {
      let c = 0;
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          if (map[y][x] === type) c++;
      return c;
    }

    // Count total jobs (industrial capacity)
    function countJobs() {
      let jobs = 0;
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          if (map[y][x] === ZONE.INDUSTRIAL) jobs += levelMap[y][x] * 8;
      return jobs;
    }

    // Count commercial capacity
    function countCommerce() {
      let comm = 0;
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          if (map[y][x] === ZONE.COMMERCIAL) comm += levelMap[y][x] * 5;
      return comm;
    }

    function update(dt) {
      tick++;

      // Scroll with arrow keys
      if (keys['ArrowLeft']) viewX = Math.max(0, viewX - scrollSpeed * dt * 10);
      if (keys['ArrowRight']) viewX = Math.min(MAP_SIZE - VIEW_COLS, viewX + scrollSpeed * dt * 10);
      if (keys['ArrowUp']) viewY = Math.max(0, viewY - scrollSpeed * dt * 10);
      if (keys['ArrowDown']) viewY = Math.min(MAP_SIZE - VIEW_ROWS, viewY + scrollSpeed * dt * 10);

      // Update power every 30 ticks
      if (tick % 30 === 0) {
        updatePower();
      }

      // Growth tick every 60 frames (~1 second)
      growthTimer++;
      if (growthTimer >= 60) {
        growthTimer = 0;
        doGrowth();
      }

      // Tax collection every 300 frames (~5 seconds)
      taxTimer++;
      if (taxTimer >= 300) {
        taxTimer = 0;
        collectTaxes();
      }

      // Calculate population from residential levels
      let pop = 0;
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          if (map[y][x] === ZONE.RESIDENTIAL)
            pop += levelMap[y][x] * 4;

      population = pop;
      score = pop;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Update happiness
      if (tick % 60 === 0) {
        happiness = calcHappiness();
      }

      // Bankruptcy check
      if (money < 0) {
        bankruptTimer++;
        if (bankruptTimer > 600) { // 10 seconds in the red
          gameOver();
          return;
        }
      } else {
        bankruptTimer = 0;
      }

      // Update place feedback
      for (let i = placeFeedback.length - 1; i >= 0; i--) {
        placeFeedback[i].life--;
        if (placeFeedback[i].life <= 0) placeFeedback.splice(i, 1);
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function doGrowth() {
      const jobs = countJobs();
      const commerce = countCommerce();

      for (let y = 0; y < MAP_SIZE; y++) {
        for (let x = 0; x < MAP_SIZE; x++) {
          const zone = map[y][x];
          if (zone === ZONE.EMPTY || zone === ZONE.ROAD || zone === ZONE.PARK) continue;

          const road = nearRoad(x, y);
          const powered = poweredMap[y][x];

          if (zone === ZONE.RESIDENTIAL) {
            if (road && powered && levelMap[y][x] < 5) {
              // Residential grows if there are jobs and commerce
              const demandMet = jobs >= population * 0.5 && commerce >= population * 0.3;
              const growChance = demandMet ? 0.15 : 0.03;
              const happyBonus = happiness > 60 ? 0.1 : 0;
              if (Math.random() < growChance + happyBonus) {
                levelMap[y][x]++;
                spawnGrowthParticles(x, y, ZONE_COLORS[ZONE.RESIDENTIAL]);
              }
            }
            // Decay without road or power
            if ((!road || !powered) && levelMap[y][x] > 0 && Math.random() < 0.05) {
              levelMap[y][x]--;
            }
          }

          if (zone === ZONE.COMMERCIAL) {
            if (road && powered && levelMap[y][x] < 4) {
              // Commercial grows with population
              const growChance = population > 10 ? 0.12 : 0.02;
              if (Math.random() < growChance) {
                levelMap[y][x]++;
                spawnGrowthParticles(x, y, ZONE_COLORS[ZONE.COMMERCIAL]);
              }
            }
            if ((!road || !powered) && levelMap[y][x] > 0 && Math.random() < 0.05) {
              levelMap[y][x]--;
            }
          }

          if (zone === ZONE.INDUSTRIAL) {
            if (road && powered && levelMap[y][x] < 3) {
              const growChance = population > 5 ? 0.1 : 0.02;
              if (Math.random() < growChance) {
                levelMap[y][x]++;
                spawnGrowthParticles(x, y, ZONE_COLORS[ZONE.INDUSTRIAL]);
              }
            }
            if ((!road || !powered) && levelMap[y][x] > 0 && Math.random() < 0.05) {
              levelMap[y][x]--;
            }
          }

          if (zone === ZONE.POWER) {
            // Power plants always at level 1
            levelMap[y][x] = 1;
          }
        }
      }
    }

    function collectTaxes() {
      // Tax income: $2 per population unit + $1 per commerce level
      const taxIncome = population * 2 + countCommerce() * 1;
      // Maintenance costs: roads, power plants
      const roadCost = countZones(ZONE.ROAD) * 0.5;
      const powerCost = countZones(ZONE.POWER) * 3;
      const net = Math.round(taxIncome - roadCost - powerCost);
      money += net;
    }

    function spawnGrowthParticles(gx, gy, color) {
      const px = (gx - Math.floor(viewX)) * GRID + GRID / 2;
      const py = (gy - Math.floor(viewY)) * GRID + GRID / 2;
      for (let i = 0; i < 4; i++) {
        particles.push({
          x: px, y: py,
          vx: (Math.random() - 0.5) * 2,
          vy: -Math.random() * 2 - 1,
          life: 20 + Math.random() * 10,
          color: color
        });
      }
    }

    function placeZone(gx, gy) {
      if (gameState !== 'playing') return;
      // Convert screen grid to world grid
      const wx = Math.floor(viewX) + gx;
      const wy = Math.floor(viewY) + gy;

      if (wx < 0 || wx >= MAP_SIZE || wy < 0 || wy >= MAP_SIZE) return;
      if (map[wy][wx] !== ZONE.EMPTY) return;

      const cost = ZONE_COSTS[selectedZone];
      if (money < cost) return;

      money -= cost;
      map[wy][wx] = selectedZone;
      levelMap[wy][wx] = (selectedZone === ZONE.ROAD || selectedZone === ZONE.PARK) ? 1 :
                          (selectedZone === ZONE.POWER) ? 1 : 0;

      // Update power immediately when placing power plant
      if (selectedZone === ZONE.POWER) updatePower();

      // Visual feedback
      placeFeedback.push({
        x: gx * GRID + GRID / 2,
        y: gy * GRID + GRID / 2,
        text: '-$' + cost,
        life: 40
      });

      // Particles
      for (let i = 0; i < 6; i++) {
        particles.push({
          x: gx * GRID + GRID / 2,
          y: gy * GRID + GRID / 2,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 15,
          color: ZONE_COLORS[selectedZone]
        });
      }
    }

    function updateZoneKeyIndicators() {
      for (let i = 1; i <= 6; i++) {
        const el = document.getElementById('zk' + i);
        if (i === selectedZone) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      const vx = Math.floor(viewX);
      const vy = Math.floor(viewY);
      const offX = (viewX - vx) * GRID;
      const offY = (viewY - vy) * GRID;

      // Draw grid lines
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= VIEW_COLS; x++) {
        const sx = x * GRID - offX;
        ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
      }
      for (let y = 0; y <= VIEW_ROWS; y++) {
        const sy = y * GRID - offY;
        ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
      }

      // Draw zones
      for (let dy = -1; dy <= VIEW_ROWS + 1; dy++) {
        for (let dx = -1; dx <= VIEW_COLS + 1; dx++) {
          const wx = vx + dx;
          const wy = vy + dy;
          if (wx < 0 || wx >= MAP_SIZE || wy < 0 || wy >= MAP_SIZE) continue;

          const zone = map[wy][wx];
          if (zone === ZONE.EMPTY) continue;

          const sx = dx * GRID - offX;
          const sy = dy * GRID - offY;
          const level = levelMap[wy][wx];
          const powered = poweredMap[wy][wx];

          // Draw zone base
          drawZone(sx, sy, zone, level, powered, wx, wy);
        }
      }

      // Draw cursor / placement preview
      if (gameState === 'playing' && mouseX >= 0 && mouseY >= 0) {
        const gx = Math.floor((mouseX + offX) / GRID);
        const gy = Math.floor((mouseY + offY) / GRID);
        const wx = vx + gx;
        const wy = vy + gy;
        const sx = gx * GRID - offX;
        const sy = gy * GRID - offY;

        if (wx >= 0 && wx < MAP_SIZE && wy >= 0 && wy < MAP_SIZE) {
          const valid = map[wy][wx] === ZONE.EMPTY;
          const affordable = money >= ZONE_COSTS[selectedZone];

          // Preview highlight
          ctx.fillStyle = valid && affordable ? 'rgba(255, 170, 0, 0.15)' : 'rgba(255, 68, 68, 0.15)';
          ctx.fillRect(sx, sy, GRID, GRID);
          ctx.strokeStyle = valid && affordable ? '#fa0' : '#f44';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(sx, sy, GRID, GRID);

          // Zone type preview text
          ctx.fillStyle = valid && affordable ? '#fa0' : '#f44';
          ctx.font = '9px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(ZONE_NAMES[selectedZone] + ' $' + ZONE_COSTS[selectedZone], sx + GRID / 2, sy - 2);

          // Power range preview for power plants
          if (selectedZone === ZONE.POWER && valid && affordable) {
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(sx + GRID / 2, sy + GRID / 2, 6 * GRID, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      // Place feedback (cost text floating up)
      placeFeedback.forEach(f => {
        const alpha = f.life / 40;
        ctx.fillStyle = `rgba(255, 170, 0, ${alpha})`;
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(f.text, f.x, f.y - (40 - f.life) * 0.8);
      });

      // Particles
      particles.forEach(p => {
        const alpha = Math.min(1, p.life / 15);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = alpha;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;

      // HUD - Tool palette on canvas (top area)
      drawHUD();
    }

    function drawZone(sx, sy, zone, level, powered, wx, wy) {
      const color = ZONE_COLORS[zone];
      const pulse = Math.sin(tick * 0.05) * 0.15 + 0.85;

      if (zone === ZONE.ROAD) {
        // Road: flat gray surface with lane markings
        ctx.fillStyle = '#444';
        ctx.fillRect(sx + 1, sy + 1, GRID - 2, GRID - 2);
        // Center line
        ctx.fillStyle = '#666';
        if (wx > 0 && map[wy][wx - 1] === ZONE.ROAD || wx < MAP_SIZE - 1 && map[wy][wx + 1] === ZONE.ROAD) {
          ctx.fillRect(sx + GRID / 2 - 1, sy + GRID / 4, 2, GRID / 2);
        }
        if (wy > 0 && map[wy - 1][wx] === ZONE.ROAD || wy < MAP_SIZE - 1 && map[wy + 1][wx] === ZONE.ROAD) {
          ctx.fillRect(sx + GRID / 4, sy + GRID / 2 - 1, GRID / 2, 2);
        }
        return;
      }

      if (zone === ZONE.PARK) {
        // Park: green area with trees
        ctx.fillStyle = '#1a3a1a';
        ctx.fillRect(sx + 1, sy + 1, GRID - 2, GRID - 2);
        ctx.shadowColor = '#3b3';
        ctx.shadowBlur = 4;
        // Trees
        ctx.fillStyle = '#3b3';
        ctx.beginPath(); ctx.arc(sx + 10, sy + 12, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(sx + 22, sy + 18, 6, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(sx + 14, sy + 24, 4, 0, Math.PI * 2); ctx.fill();
        // Trunks
        ctx.fillStyle = '#654';
        ctx.fillRect(sx + 9, sy + 16, 2, 5);
        ctx.fillRect(sx + 21, sy + 23, 2, 5);
        ctx.shadowBlur = 0;
        return;
      }

      if (zone === ZONE.POWER) {
        // Power plant: red with lightning bolt
        ctx.fillStyle = '#411';
        ctx.fillRect(sx + 1, sy + 1, GRID - 2, GRID - 2);
        ctx.shadowColor = '#f33';
        ctx.shadowBlur = 8 * pulse;
        ctx.fillStyle = '#f33';
        // Building shape
        ctx.fillRect(sx + 4, sy + 8, 10, 18);
        ctx.fillRect(sx + 16, sy + 4, 10, 22);
        // Chimney smoke
        ctx.fillStyle = `rgba(255, 100, 100, ${pulse * 0.6})`;
        ctx.beginPath(); ctx.arc(sx + 21, sy + 2, 3, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        // Lightning icon
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('\u26A1', sx + GRID / 2, sy + GRID / 2);
        return;
      }

      // Building zones (Residential, Commercial, Industrial)
      // Background
      const dimColor = powered ? color : '#333';
      ctx.fillStyle = zone === ZONE.RESIDENTIAL ? '#0a2a0a' :
                      zone === ZONE.COMMERCIAL ? '#0a0a2a' :
                      '#2a2a0a';
      ctx.fillRect(sx + 1, sy + 1, GRID - 2, GRID - 2);

      if (level === 0) {
        // Empty lot - just zone color border
        ctx.strokeStyle = dimColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(sx + 3, sy + 3, GRID - 6, GRID - 6);
        ctx.setLineDash([]);
        // Zone letter
        ctx.fillStyle = `${dimColor}66`;
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const letter = zone === ZONE.RESIDENTIAL ? 'R' : zone === ZONE.COMMERCIAL ? 'C' : 'I';
        ctx.fillText(letter, sx + GRID / 2, sy + GRID / 2);
        return;
      }

      // Building based on level
      ctx.shadowColor = dimColor;
      ctx.shadowBlur = 4;
      ctx.fillStyle = dimColor;

      if (level === 1) {
        // Small house/shop/factory
        ctx.fillRect(sx + 8, sy + 14, 14, 12);
        // Roof
        ctx.beginPath();
        ctx.moveTo(sx + 6, sy + 14);
        ctx.lineTo(sx + 15, sy + 6);
        ctx.lineTo(sx + 24, sy + 14);
        ctx.closePath();
        ctx.fill();
      } else if (level === 2) {
        // Medium building
        ctx.fillRect(sx + 6, sy + 8, 18, 18);
        // Windows
        ctx.fillStyle = powered ? '#ff8' : '#333';
        ctx.fillRect(sx + 9, sy + 11, 3, 3);
        ctx.fillRect(sx + 18, sy + 11, 3, 3);
        ctx.fillRect(sx + 9, sy + 18, 3, 3);
        ctx.fillRect(sx + 18, sy + 18, 3, 3);
      } else if (level === 3) {
        // Tall building
        ctx.fillRect(sx + 7, sy + 3, 16, 23);
        // Windows
        ctx.fillStyle = powered ? '#ff8' : '#333';
        for (let wy = 0; wy < 4; wy++) {
          ctx.fillRect(sx + 10, sy + 5 + wy * 5, 3, 3);
          ctx.fillRect(sx + 17, sy + 5 + wy * 5, 3, 3);
        }
      } else if (level === 4) {
        // High rise
        ctx.fillRect(sx + 5, sy + 2, 12, 24);
        ctx.fillRect(sx + 13, sy + 6, 12, 20);
        ctx.fillStyle = powered ? '#ff8' : '#333';
        for (let wy = 0; wy < 5; wy++) {
          ctx.fillRect(sx + 8, sy + 4 + wy * 4, 2, 2);
          ctx.fillRect(sx + 16, sy + 8 + wy * 4, 2, 2);
        }
      } else {
        // Skyscraper (level 5)
        ctx.fillRect(sx + 6, sy + 1, 18, 25);
        ctx.fillStyle = powered ? '#ff8' : '#333';
        for (let wy = 0; wy < 6; wy++) {
          for (let wx = 0; wx < 3; wx++) {
            ctx.fillRect(sx + 9 + wx * 5, sy + 3 + wy * 4, 2, 2);
          }
        }
        // Antenna
        ctx.fillStyle = dimColor;
        ctx.fillRect(sx + 14, sy - 3, 2, 5);
        // Blinking light
        if (Math.sin(tick * 0.1) > 0) {
          ctx.fillStyle = '#f00';
          ctx.fillRect(sx + 14, sy - 4, 2, 2);
        }
      }
      ctx.shadowBlur = 0;

      // Unpowered indicator
      if (!powered && level > 0) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('!', sx + GRID / 2, sy + GRID - 1);
      }
    }

    function drawHUD() {
      // Semi-transparent HUD bar at top of canvas
      ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
      ctx.fillRect(0, 0, W, 32);
      ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, 32); ctx.lineTo(W, 32); ctx.stroke();

      ctx.font = 'bold 12px Courier New';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';

      // Population
      ctx.fillStyle = '#0c4';
      ctx.shadowColor = '#0c4';
      ctx.shadowBlur = 4;
      ctx.fillText('\u263A ' + population, 10, 16);
      ctx.shadowBlur = 0;

      // Money
      const moneyColor = money < 0 ? '#f44' : '#fa0';
      ctx.fillStyle = moneyColor;
      ctx.shadowColor = moneyColor;
      ctx.shadowBlur = 4;
      ctx.fillText('$' + money, 120, 16);
      ctx.shadowBlur = 0;

      // Happiness
      const happyColor = happiness >= 60 ? '#0c4' : happiness >= 40 ? '#ec0' : '#f44';
      ctx.fillStyle = happyColor;
      ctx.shadowColor = happyColor;
      ctx.shadowBlur = 4;
      ctx.fillText('\u2665 ' + happiness + '%', 240, 16);
      ctx.shadowBlur = 0;

      // Selected tool
      ctx.fillStyle = ZONE_COLORS[selectedZone];
      ctx.shadowColor = ZONE_COLORS[selectedZone];
      ctx.shadowBlur = 4;
      ctx.textAlign = 'right';
      ctx.fillText('[' + ZONE_NAMES[selectedZone].toUpperCase() + ' $' + ZONE_COSTS[selectedZone] + ']', W - 10, 16);
      ctx.shadowBlur = 0;

      // Bankruptcy warning
      if (money < 0) {
        const flash = Math.sin(tick * 0.15) > 0;
        if (flash) {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 10;
          ctx.font = 'bold 14px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('GOING BANKRUPT!', W / 2, 16);
          ctx.shadowBlur = 0;
        }
      }

      // Bottom HUD - resource bars
      ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
      ctx.fillRect(0, H - 24, W, 24);
      ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
      ctx.beginPath(); ctx.moveTo(0, H - 24); ctx.lineTo(W, H - 24); ctx.stroke();

      ctx.font = '10px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      // Jobs bar
      const jobs = countJobs();
      const jobDemand = Math.max(1, Math.floor(population * 0.5));
      const jobRatio = Math.min(1, jobs / jobDemand);
      ctx.fillStyle = '#ec0';
      ctx.fillText('Jobs:', 10, H - 12);
      ctx.fillStyle = '#333';
      ctx.fillRect(55, H - 17, 80, 10);
      ctx.fillStyle = jobRatio > 0.5 ? '#ec0' : '#f44';
      ctx.fillRect(55, H - 17, 80 * jobRatio, 10);

      // Commerce bar
      const comm = countCommerce();
      const commDemand = Math.max(1, Math.floor(population * 0.3));
      const commRatio = Math.min(1, comm / commDemand);
      ctx.fillStyle = '#28f';
      ctx.fillText('Shop:', 155, H - 12);
      ctx.fillStyle = '#333';
      ctx.fillRect(200, H - 17, 80, 10);
      ctx.fillStyle = commRatio > 0.5 ? '#28f' : '#f44';
      ctx.fillRect(200, H - 17, 80 * commRatio, 10);

      // Power coverage
      let poweredCount = 0, totalBuildings = 0;
      for (let y = 0; y < MAP_SIZE; y++)
        for (let x = 0; x < MAP_SIZE; x++)
          if (map[y][x] >= 1 && map[y][x] <= 3) {
            totalBuildings++;
            if (poweredMap[y][x]) poweredCount++;
          }
      const powerRatio = totalBuildings > 0 ? poweredCount / totalBuildings : 1;
      ctx.fillStyle = '#f33';
      ctx.fillText('Pwr:', 300, H - 12);
      ctx.fillStyle = '#333';
      ctx.fillRect(340, H - 17, 80, 10);
      ctx.fillStyle = powerRatio > 0.7 ? '#f33' : '#f44';
      ctx.fillRect(340, H - 17, 80 * powerRatio, 10);

      // Tick counter / time
      const minutes = Math.floor(tick / 3600);
      const seconds = Math.floor((tick % 3600) / 60);
      ctx.fillStyle = '#888';
      ctx.textAlign = 'right';
      ctx.fillText(`Time: ${minutes}:${String(seconds).padStart(2, '0')}`, W - 10, H - 12);
    }

    // Mouse handlers
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('mouseleave', () => {
      mouseX = -1;
      mouseY = -1;
    });

    canvas.addEventListener('click', (e) => {
      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing') return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Ignore clicks on HUD areas
      if (my < 32 || my > H - 24) return;

      const offX = (viewX - Math.floor(viewX)) * GRID;
      const offY = (viewY - Math.floor(viewY)) * GRID;
      const gx = Math.floor((mx + offX) / GRID);
      const gy = Math.floor((my + offY) / GRID);
      placeZone(gx, gy);
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      keys[e.key] = true;

      if (gameState === 'waiting' && e.key === ' ') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case '1': selectedZone = ZONE.RESIDENTIAL; updateZoneKeyIndicators(); break;
          case '2': selectedZone = ZONE.COMMERCIAL; updateZoneKeyIndicators(); break;
          case '3': selectedZone = ZONE.INDUSTRIAL; updateZoneKeyIndicators(); break;
          case '4': selectedZone = ZONE.ROAD; updateZoneKeyIndicators(); break;
          case '5': selectedZone = ZONE.POWER; updateZoneKeyIndicators(); break;
          case '6': selectedZone = ZONE.PARK; updateZoneKeyIndicators(); break;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=2"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Go (Baduk)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #e8d0a0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(232, 208, 160, 0.5); }
    h1 { color: #e8d0a0; font-size: 2rem; text-shadow: 0 0 15px rgba(232, 208, 160, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #e8d0a0; }
    canvas {
      border: 2px solid #e8d0a0;
      box-shadow: 0 0 20px rgba(232, 208, 160, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e8d0a0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; white-space: pre-line; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>GO (BADUK)</h1>
  </div>
  <div class="score-bar">
    <div>Black (You): <span id="score">0</span></div>
    <div>White (AI): <span id="aiScore">6.5</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:600px;">
      <h2 id="overlayTitle">GO (BADUK)</h2>
      <p id="overlayText">Click to Start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const BOARD_SIZE = 9;
    const MARGIN = 45;
    const CELL_SIZE = (W - 2 * MARGIN) / (BOARD_SIZE - 1);
    const STONE_RADIUS = CELL_SIZE * 0.44;
    const KOMI = 6.5;
    const BLACK = 1, WHITE = 2, EMPTY = 0;
    const PASS_BTN = { x: W - 90, y: H - 35, w: 70, h: 28 };

    // Star points for 9x9
    const STAR_POINTS = [[2,2],[2,6],[6,2],[6,6],[4,4]];

    // --- Game State ---
    let gameState = 'waiting';
    let score = 0;
    let board = [];
    let currentPlayer = BLACK;
    let blackCaptures = 0;
    let whiteCaptures = 0;
    let koPoint = null; // {r, c} or null
    let lastMove = null; // {r, c} or 'pass' or null
    let consecutivePasses = 0;
    let moveHistory = [];
    let hoverPos = null;
    let aiThinking = false;
    let boardHistory = []; // for ko detection

    function initBoard() {
      board = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        board[r] = [];
        for (let c = 0; c < BOARD_SIZE; c++) {
          board[r][c] = EMPTY;
        }
      }
    }

    function copyBoard(b) {
      return b.map(row => row.slice());
    }

    function boardToString(b) {
      return b.map(row => row.join('')).join('');
    }

    // --- Liberty / Capture Logic ---
    function getGroup(b, r, c) {
      const color = b[r][c];
      if (color === EMPTY) return { stones: [], liberties: new Set() };
      const visited = new Set();
      const stones = [];
      const liberties = new Set();
      const stack = [[r, c]];
      while (stack.length > 0) {
        const [cr, cc] = stack.pop();
        const key = cr * BOARD_SIZE + cc;
        if (visited.has(key)) continue;
        visited.add(key);
        stones.push([cr, cc]);
        const neighbors = getNeighbors(cr, cc);
        for (const [nr, nc] of neighbors) {
          if (b[nr][nc] === EMPTY) {
            liberties.add(nr * BOARD_SIZE + nc);
          } else if (b[nr][nc] === color && !visited.has(nr * BOARD_SIZE + nc)) {
            stack.push([nr, nc]);
          }
        }
      }
      return { stones, liberties };
    }

    function getNeighbors(r, c) {
      const n = [];
      if (r > 0) n.push([r - 1, c]);
      if (r < BOARD_SIZE - 1) n.push([r + 1, c]);
      if (c > 0) n.push([r, c - 1]);
      if (c < BOARD_SIZE - 1) n.push([r, c + 1]);
      return n;
    }

    function removeGroup(b, stones) {
      for (const [r, c] of stones) {
        b[r][c] = EMPTY;
      }
    }

    // Returns number of captures, or -1 if move is illegal
    function tryPlace(b, r, c, color, checkKo, koP) {
      if (b[r][c] !== EMPTY) return -1;

      // Check ko
      if (checkKo && koP && koP.r === r && koP.c === c) return -1;

      b[r][c] = color;
      const opponent = color === BLACK ? WHITE : BLACK;
      let captured = 0;
      let capturedStones = [];

      // Check opponent captures first
      const neighbors = getNeighbors(r, c);
      const checkedGroups = new Set();
      for (const [nr, nc] of neighbors) {
        if (b[nr][nc] === opponent) {
          const gKey = nr * BOARD_SIZE + nc;
          if (checkedGroups.has(gKey)) continue;
          const group = getGroup(b, nr, nc);
          for (const [sr, sc] of group.stones) checkedGroups.add(sr * BOARD_SIZE + sc);
          if (group.liberties.size === 0) {
            captured += group.stones.length;
            capturedStones = capturedStones.concat(group.stones);
            removeGroup(b, group.stones);
          }
        }
      }

      // Check suicide
      const selfGroup = getGroup(b, r, c);
      if (selfGroup.liberties.size === 0) {
        // Suicide - illegal
        b[r][c] = EMPTY;
        // Restore captured stones
        for (const [sr, sc] of capturedStones) {
          b[sr][sc] = opponent;
        }
        return -1;
      }

      return captured;
    }

    // Full move with ko update. Returns {captures, newKo} or null if illegal
    function makeMove(b, r, c, color, koP) {
      const bCopy = copyBoard(b);
      const captures = tryPlace(bCopy, r, c, color, true, koP);
      if (captures < 0) return null;

      // Determine new ko point
      let newKo = null;
      if (captures === 1) {
        // Check if this creates a ko situation (single stone capture, placing stone has exactly one liberty which is where captured stone was)
        const selfGroup = getGroup(bCopy, r, c);
        if (selfGroup.stones.length === 1 && selfGroup.liberties.size === 1) {
          // The liberty of the placed stone is the ko point
          const libKey = [...selfGroup.liberties][0];
          newKo = { r: Math.floor(libKey / BOARD_SIZE), c: libKey % BOARD_SIZE };
        }
      }

      // Copy result back
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          b[i][j] = bCopy[i][j];
        }
      }

      return { captures, newKo };
    }

    // --- Scoring (Chinese rules / area scoring) ---
    function scoreBoard(b) {
      const territory = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
      const visited = new Set();

      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (b[r][c] !== EMPTY || visited.has(r * BOARD_SIZE + c)) continue;

          // Flood fill empty region
          const region = [];
          const stack = [[r, c]];
          let touchesBlack = false, touchesWhite = false;
          const regionVisited = new Set();

          while (stack.length > 0) {
            const [cr, cc] = stack.pop();
            const key = cr * BOARD_SIZE + cc;
            if (regionVisited.has(key)) continue;
            regionVisited.add(key);
            visited.add(key);

            if (b[cr][cc] === EMPTY) {
              region.push([cr, cc]);
              for (const [nr, nc] of getNeighbors(cr, cc)) {
                if (!regionVisited.has(nr * BOARD_SIZE + nc)) {
                  stack.push([nr, nc]);
                }
              }
            } else if (b[cr][cc] === BLACK) {
              touchesBlack = true;
            } else {
              touchesWhite = true;
            }
          }

          // Assign territory
          if (touchesBlack && !touchesWhite) {
            for (const [er, ec] of region) territory[er][ec] = BLACK;
          } else if (touchesWhite && !touchesBlack) {
            for (const [er, ec] of region) territory[er][ec] = WHITE;
          }
        }
      }

      // Chinese scoring: stones on board + territory
      let blackScore = 0, whiteScore = 0;
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (b[r][c] === BLACK || territory[r][c] === BLACK) blackScore++;
          if (b[r][c] === WHITE || territory[r][c] === WHITE) whiteScore++;
        }
      }

      whiteScore += KOMI;
      return { blackScore, whiteScore, territory };
    }

    // --- Legal moves ---
    // Fast legality check without full board copy (checks liberties heuristically)
    function isLikelyLegal(b, r, c, color, koP) {
      if (b[r][c] !== EMPTY) return false;
      if (koP && koP.r === r && koP.c === c) return false;
      const opponent = color === BLACK ? WHITE : BLACK;
      const neighbors = getNeighbors(r, c);
      // If any neighbor is empty, we have a liberty -> legal
      for (const [nr, nc] of neighbors) {
        if (b[nr][nc] === EMPTY) return true;
      }
      // If any neighboring opponent group has exactly 1 liberty (this spot), it's a capture -> legal
      for (const [nr, nc] of neighbors) {
        if (b[nr][nc] === opponent) {
          const group = getGroup(b, nr, nc);
          if (group.liberties.size === 1) return true;
        }
      }
      // If any neighboring friendly group has >1 liberty, we can connect -> legal
      for (const [nr, nc] of neighbors) {
        if (b[nr][nc] === color) {
          const group = getGroup(b, nr, nc);
          if (group.liberties.size > 1) return true;
        }
      }
      // Otherwise likely suicide
      return false;
    }

    function getLegalMoves(b, color, koP) {
      const moves = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (b[r][c] !== EMPTY) continue;
          if (koP && koP.r === r && koP.c === c) continue;
          if (isLikelyLegal(b, r, c, color, koP)) {
            moves.push([r, c]);
          }
        }
      }
      return moves;
    }

    // Full legality check (used for player moves and expansion)
    function getLegalMovesStrict(b, color, koP) {
      const moves = [];
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (b[r][c] !== EMPTY) continue;
          if (koP && koP.r === r && koP.c === c) continue;
          const testBoard = copyBoard(b);
          const result = tryPlace(testBoard, r, c, color, true, koP);
          if (result >= 0) {
            moves.push([r, c]);
          }
        }
      }
      return moves;
    }

    // --- MCTS AI ---
    class MCTSNode {
      constructor(board, color, koP, parent, move) {
        this.board = board;
        this.color = color; // color to play
        this.koPoint = koP;
        this.parent = parent;
        this.move = move; // the move that led here [r,c] or 'pass'
        this.children = [];
        this.wins = 0;
        this.visits = 0;
        this.untriedMoves = null;
        this.consecutivePasses = 0;
      }

      getUntriedMoves() {
        if (this.untriedMoves === null) {
          this.untriedMoves = getLegalMovesStrict(this.board, this.color, this.koPoint);
          this.untriedMoves.push('pass');
        }
        return this.untriedMoves;
      }

      ucb1(explorationParam = 1.41) {
        if (this.visits === 0) return Infinity;
        return (this.wins / this.visits) + explorationParam * Math.sqrt(Math.log(this.parent.visits) / this.visits);
      }

      bestChild() {
        let best = null, bestScore = -Infinity;
        for (const child of this.children) {
          const s = child.ucb1();
          if (s > bestScore) {
            bestScore = s;
            best = child;
          }
        }
        return best;
      }
    }

    function mctsAI(b, color, koP, simulations) {
      const root = new MCTSNode(copyBoard(b), color, koP, null, null);

      for (let i = 0; i < simulations; i++) {
        // 1. Selection
        let node = root;
        while (node.getUntriedMoves().length === 0 && node.children.length > 0) {
          node = node.bestChild();
        }

        // 2. Expansion
        const untried = node.getUntriedMoves();
        if (untried.length > 0 && node.consecutivePasses < 2) {
          const moveIdx = Math.floor(Math.random() * untried.length);
          const move = untried.splice(moveIdx, 1)[0];

          const newBoard = copyBoard(node.board);
          let newKo = null;
          let newConsecutivePasses = 0;

          if (move === 'pass') {
            newConsecutivePasses = node.consecutivePasses + 1;
          } else {
            const result = makeMove(newBoard, move[0], move[1], node.color, node.koPoint);
            if (result) {
              newKo = result.newKo;
            }
            newConsecutivePasses = 0;
          }

          const nextColor = node.color === BLACK ? WHITE : BLACK;
          const child = new MCTSNode(newBoard, nextColor, newKo, node, move);
          child.consecutivePasses = newConsecutivePasses;
          node.children.push(child);
          node = child;
        }

        // 3. Simulation (random playout)
        const simBoard = copyBoard(node.board);
        let simColor = node.color;
        let simKo = node.koPoint;
        let simPasses = node.consecutivePasses;
        let movesLeft = 81 * 2; // prevent infinite loops

        while (simPasses < 2 && movesLeft > 0) {
          movesLeft--;
          const legal = getLegalMoves(simBoard, simColor, simKo);

          if (legal.length === 0 || Math.random() < 0.1) {
            // Pass
            simPasses++;
            simColor = simColor === BLACK ? WHITE : BLACK;
            simKo = null;
            continue;
          }

          // Random legal move, avoid filling own eyes
          let move = null;
          let attempts = 0;
          while (attempts < 5) {
            const candidate = legal[Math.floor(Math.random() * legal.length)];
            if (!isEye(simBoard, candidate[0], candidate[1], simColor)) {
              move = candidate;
              break;
            }
            attempts++;
          }
          if (!move) {
            // All candidates are eyes or too many attempts, pass
            simPasses++;
            simColor = simColor === BLACK ? WHITE : BLACK;
            simKo = null;
            continue;
          }

          simPasses = 0;
          const result = makeMove(simBoard, move[0], move[1], simColor, simKo);
          simKo = result ? result.newKo : null;
          simColor = simColor === BLACK ? WHITE : BLACK;
        }

        // 4. Score and backpropagate
        const finalScore = scoreBoard(simBoard);
        const aiWins = color === WHITE ?
          (finalScore.whiteScore > finalScore.blackScore ? 1 : 0) :
          (finalScore.blackScore > finalScore.whiteScore ? 1 : 0);

        // Backpropagate
        while (node !== null) {
          node.visits++;
          // The win is from the perspective of the AI color
          // If the node's parent made the move, then the node's color is the opponent
          // We want to count wins for the color that is making the AI's moves
          if (node.parent) {
            // node.parent.color made the move to get to node
            if (node.parent.color === color) {
              node.wins += aiWins;
            } else {
              node.wins += (1 - aiWins);
            }
          } else {
            node.wins += aiWins;
          }
          node = node.parent;
        }
      }

      // Select best move (most visited)
      let bestChild = null, bestVisits = -1;
      for (const child of root.children) {
        if (child.visits > bestVisits) {
          bestVisits = child.visits;
          bestChild = child;
        }
      }

      if (!bestChild) return 'pass';
      return bestChild.move;
    }

    // Check if position is an eye for the given color
    function isEye(b, r, c, color) {
      if (b[r][c] !== EMPTY) return false;
      // All adjacent must be same color
      const neighbors = getNeighbors(r, c);
      for (const [nr, nc] of neighbors) {
        if (b[nr][nc] !== color) return false;
      }
      // Check diagonals - at least 3/4 must be same color (or 1/1 for corners)
      const diags = [];
      if (r > 0 && c > 0) diags.push([r-1, c-1]);
      if (r > 0 && c < BOARD_SIZE-1) diags.push([r-1, c+1]);
      if (r < BOARD_SIZE-1 && c > 0) diags.push([r+1, c-1]);
      if (r < BOARD_SIZE-1 && c < BOARD_SIZE-1) diags.push([r+1, c+1]);

      let sameColor = 0;
      for (const [dr, dc] of diags) {
        if (b[dr][dc] === color) sameColor++;
      }
      // Corner: need all diags same color; edge: allow 1 different; center: allow 1 different
      const needed = diags.length <= 2 ? diags.length : diags.length - 1;
      return sameColor >= needed;
    }

    // --- Drawing ---
    function boardX(c) { return MARGIN + c * CELL_SIZE; }
    function boardY(r) { return MARGIN + r * CELL_SIZE; }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Board wood background
      const boardLeft = MARGIN - CELL_SIZE * 0.55;
      const boardTop = MARGIN - CELL_SIZE * 0.55;
      const boardW = (BOARD_SIZE - 1) * CELL_SIZE + CELL_SIZE * 1.1;
      const boardH = boardW;

      // Wood gradient
      const grad = ctx.createLinearGradient(boardLeft, boardTop, boardLeft + boardW, boardTop + boardH);
      grad.addColorStop(0, '#dcb35c');
      grad.addColorStop(0.5, '#d4a843');
      grad.addColorStop(1, '#c9a23a');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(boardLeft, boardTop, boardW, boardH, 4);
      ctx.fill();

      // Subtle wood grain lines
      ctx.strokeStyle = 'rgba(0,0,0,0.04)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 30; i++) {
        const y = boardTop + (boardH / 30) * i + Math.sin(i * 0.7) * 3;
        ctx.beginPath();
        ctx.moveTo(boardLeft + 2, y);
        ctx.lineTo(boardLeft + boardW - 2, y);
        ctx.stroke();
      }

      // Grid lines
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let i = 0; i < BOARD_SIZE; i++) {
        // Horizontal
        ctx.beginPath();
        ctx.moveTo(boardX(0), boardY(i));
        ctx.lineTo(boardX(BOARD_SIZE - 1), boardY(i));
        ctx.stroke();
        // Vertical
        ctx.beginPath();
        ctx.moveTo(boardX(i), boardY(0));
        ctx.lineTo(boardX(i), boardY(BOARD_SIZE - 1));
        ctx.stroke();
      }

      // Coordinate labels
      ctx.fillStyle = '#888';
      ctx.font = '11px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const letters = 'ABCDEFGHJ'; // I is traditionally skipped in Go
      for (let i = 0; i < BOARD_SIZE; i++) {
        // Top
        ctx.fillText(letters[i], boardX(i), MARGIN - CELL_SIZE * 0.55 - 10);
        // Left
        ctx.fillText(String(BOARD_SIZE - i), MARGIN - CELL_SIZE * 0.55 - 12, boardY(i));
      }

      // Star points (hoshi)
      ctx.fillStyle = '#333';
      for (const [r, c] of STAR_POINTS) {
        ctx.beginPath();
        ctx.arc(boardX(c), boardY(r), 3.5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Stones
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          if (board[r][c] !== EMPTY) {
            drawStone(boardX(c), boardY(r), board[r][c], false);
          }
        }
      }

      // Last move indicator
      if (lastMove && lastMove !== 'pass' && board[lastMove.r] && board[lastMove.r][lastMove.c] !== EMPTY) {
        const lx = boardX(lastMove.c), ly = boardY(lastMove.r);
        const stoneColor = board[lastMove.r][lastMove.c];
        ctx.beginPath();
        ctx.arc(lx, ly, STONE_RADIUS * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = stoneColor === BLACK ? '#f00' : '#f00';
        ctx.fill();
      }

      // Ghost stone on hover
      if (gameState === 'playing' && currentPlayer === BLACK && hoverPos && !aiThinking) {
        const { r, c } = hoverPos;
        if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
          // Quick legality check for hover preview
          if (isLikelyLegal(board, r, c, BLACK, koPoint)) {
            ctx.globalAlpha = 0.4;
            drawStone(boardX(c), boardY(r), BLACK, true);
            ctx.globalAlpha = 1.0;
          }
        }
      }

      // Pass button
      if (gameState === 'playing' && currentPlayer === BLACK && !aiThinking) {
        drawPassButton(false);
      }

      // AI thinking indicator
      if (aiThinking) {
        ctx.fillStyle = '#e8d0a0';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('AI is thinking...', W / 2, H - 8);
      }

      // Captures display
      ctx.fillStyle = '#aaa';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(`Captures: ${blackCaptures}`, 10, H - 8);
      ctx.textAlign = 'right';
      ctx.fillText(`Captures: ${whiteCaptures}`, W - 10, H - 8);

      // Territory markers during game over
      if (gameState === 'over') {
        const scoring = scoreBoard(board);
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === EMPTY) {
              if (scoring.territory[r][c] === BLACK) {
                ctx.fillStyle = 'rgba(17, 17, 17, 0.5)';
                ctx.fillRect(boardX(c) - 6, boardY(r) - 6, 12, 12);
              } else if (scoring.territory[r][c] === WHITE) {
                ctx.fillStyle = 'rgba(240, 240, 240, 0.5)';
                ctx.fillRect(boardX(c) - 6, boardY(r) - 6, 12, 12);
              }
            }
          }
        }
      }
    }

    function drawStone(x, y, color, isGhost) {
      if (color === BLACK) {
        // Black stone with subtle gradient
        const grad = ctx.createRadialGradient(x - STONE_RADIUS * 0.3, y - STONE_RADIUS * 0.3, STONE_RADIUS * 0.1, x, y, STONE_RADIUS);
        grad.addColorStop(0, '#555');
        grad.addColorStop(0.6, '#222');
        grad.addColorStop(1, '#111');
        ctx.beginPath();
        ctx.arc(x, y, STONE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        if (!isGhost) {
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      } else {
        // White stone with gradient and shadow
        if (!isGhost) {
          // Shadow
          ctx.beginPath();
          ctx.arc(x + 2, y + 2, STONE_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.fill();
        }
        const grad = ctx.createRadialGradient(x - STONE_RADIUS * 0.3, y - STONE_RADIUS * 0.3, STONE_RADIUS * 0.1, x, y, STONE_RADIUS);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.8, '#e8e8e8');
        grad.addColorStop(1, '#ccc');
        ctx.beginPath();
        ctx.arc(x, y, STONE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        if (!isGhost) {
          ctx.strokeStyle = '#999';
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    }

    function drawPassButton(hover) {
      const { x, y, w, h } = PASS_BTN;
      ctx.fillStyle = hover ? 'rgba(232, 208, 160, 0.3)' : 'rgba(232, 208, 160, 0.15)';
      ctx.strokeStyle = '#e8d0a0';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.roundRect(x, y, w, h, 4);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#e8d0a0';
      ctx.font = '13px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PASS', x + w / 2, y + h / 2);
    }

    // --- Input ---
    function getIntersection(mx, my) {
      const c = Math.round((mx - MARGIN) / CELL_SIZE);
      const r = Math.round((my - MARGIN) / CELL_SIZE);
      if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) return null;
      // Check distance
      const dx = mx - boardX(c);
      const dy = my - boardY(r);
      if (Math.sqrt(dx * dx + dy * dy) > CELL_SIZE * 0.5) return null;
      return { r, c };
    }

    function isInPassButton(mx, my) {
      const { x, y, w, h } = PASS_BTN;
      return mx >= x && mx <= x + w && my >= y && my <= y + h;
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);
      const pos = getIntersection(mx, my);
      hoverPos = pos;
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('mouseleave', () => {
      hoverPos = null;
      if (gameState === 'playing') draw();
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') {
        startGame();
        return;
      }

      if (gameState === 'over') {
        startGame();
        return;
      }

      if (gameState !== 'playing' || currentPlayer !== BLACK || aiThinking) return;

      // Check pass button
      if (isInPassButton(mx, my)) {
        playerPass();
        return;
      }

      // Place stone
      const pos = getIntersection(mx, my);
      if (!pos) return;

      const { r, c } = pos;
      if (board[r][c] !== EMPTY) return;

      const result = makeMove(board, r, c, BLACK, koPoint);
      if (!result) return; // Illegal move

      blackCaptures += result.captures;
      koPoint = result.newKo;
      lastMove = { r, c };
      consecutivePasses = 0;
      moveHistory.push({ color: BLACK, r, c });

      currentPlayer = WHITE;
      updateScoreDisplay();
      draw();

      // AI turn
      aiThinking = true;
      draw();
      setTimeout(doAIMove, 50);
    });

    function playerPass() {
      consecutivePasses++;
      lastMove = 'pass';
      koPoint = null;
      moveHistory.push({ color: BLACK, pass: true });
      currentPlayer = WHITE;

      if (consecutivePasses >= 2) {
        endGame();
        return;
      }

      updateScoreDisplay();
      draw();
      aiThinking = true;
      draw();
      setTimeout(doAIMove, 50);
    }

    function doAIMove() {
      // Determine simulations based on board state
      const stoneCount = board.flat().filter(x => x !== EMPTY).length;
      const sims = stoneCount < 10 ? 400 : (stoneCount < 30 ? 500 : 600);

      const move = mctsAI(board, WHITE, koPoint, sims);

      if (move === 'pass') {
        consecutivePasses++;
        lastMove = 'pass';
        koPoint = null;
        moveHistory.push({ color: WHITE, pass: true });

        if (consecutivePasses >= 2) {
          aiThinking = false;
          endGame();
          return;
        }
      } else {
        const [r, c] = move;
        const result = makeMove(board, r, c, WHITE, koPoint);
        if (result) {
          whiteCaptures += result.captures;
          koPoint = result.newKo;
          lastMove = { r, c };
          consecutivePasses = 0;
          moveHistory.push({ color: WHITE, r, c });
        } else {
          // If MCTS returned illegal move, just pass
          consecutivePasses++;
          lastMove = 'pass';
          koPoint = null;
          moveHistory.push({ color: WHITE, pass: true });

          if (consecutivePasses >= 2) {
            aiThinking = false;
            endGame();
            return;
          }
        }
      }

      currentPlayer = BLACK;
      aiThinking = false;
      updateScoreDisplay();
      draw();
    }

    function updateScoreDisplay() {
      const scoring = scoreBoard(board);
      scoreEl.textContent = scoring.blackScore;
      aiScoreEl.textContent = scoring.whiteScore.toFixed(1);
      score = scoring.blackScore;
    }

    function endGame() {
      gameState = 'over';
      const scoring = scoreBoard(board);
      const blackFinal = scoring.blackScore;
      const whiteFinal = scoring.whiteScore;

      scoreEl.textContent = blackFinal;
      aiScoreEl.textContent = whiteFinal.toFixed(1);
      score = blackFinal;

      let winner, msg;
      if (blackFinal > whiteFinal) {
        winner = 'Black Wins!';
        msg = `B ${blackFinal} - W ${whiteFinal.toFixed(1)}`;
      } else {
        winner = 'White Wins!';
        msg = `W ${whiteFinal.toFixed(1)} - B ${blackFinal}`;
      }

      overlayTitle.textContent = winner;
      overlayText.innerHTML = msg + '<br>Click to play again';
      overlay.style.display = 'flex';
      overlay.style.background = 'rgba(26, 26, 46, 0.75)';

      draw();
    }

    function startGame() {
      initBoard();
      currentPlayer = BLACK;
      blackCaptures = 0;
      whiteCaptures = 0;
      koPoint = null;
      lastMove = null;
      consecutivePasses = 0;
      moveHistory = [];
      boardHistory = [];
      hoverPos = null;
      aiThinking = false;
      gameState = 'playing';
      score = 0;

      scoreEl.textContent = '0';
      aiScoreEl.textContent = KOMI.toFixed(1);

      overlay.style.display = 'none';
      draw();
    }

    // Initial draw
    initBoard();
    draw();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

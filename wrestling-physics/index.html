<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wrestling Physics</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #f82; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 34, 0.5); }
    h1 { color: #f82; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 136, 34, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f82; }
    .controls-info {
      width: 500px;
      margin-bottom: 8px;
      font-size: 0.7rem;
      color: #666;
      text-align: center;
    }
    canvas {
      border: 2px solid #f82;
      box-shadow: 0 0 20px rgba(255, 136, 34, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f82;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255, 136, 34, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>WRESTLING PHYSICS</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="roundInfo" style="color:#f82;font-size:0.9rem;">Best of 3</div>
    <div>CPU: <span id="aiScore">0</span></div>
  </div>
  <div class="controls-info">
    Q/W=Left Arm Up/Dn &bull; O/P=Right Arm Up/Dn &bull; A/S=Left Leg &bull; K/L=Right Leg
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:400px;">
      <h2 id="overlayTitle">WRESTLING PHYSICS</h2>
      <p id="overlayText">Press any key to start</p>
      <p style="font-size:0.75rem;color:#888;margin-top:12px;">QWOP-style limb controls &mdash; Pin or ring-out your opponent!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 500, H = 400;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const roundInfoEl = document.getElementById('roundInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;
    let aiScoreVal = 0;
    let round = 1;
    const maxRounds = 3;
    let roundTimer = 0;
    let pinTimer = 0;
    let pinTarget = null;
    let matchMessage = '';
    let matchMsgTimer = 0;
    let shakeTimer = 0;
    let shakeX = 0, shakeY = 0;
    let comboText = [];  // floating text effects

    // Ring geometry
    const RING_L = 55, RING_R = 445;
    const MAT_Y = 310;
    const ROPE_YS = [155, 200, 248];
    const GRAVITY = 0.38;
    const FRICTION = 0.93;

    // Input
    const keys = {};
    document.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (gameState === 'waiting') startMatch();
      else if (gameState === 'roundEnd') startRound();
      else if (gameState === 'matchEnd') { score = 0; aiScoreVal = 0; round = 1; scoreEl.textContent = '0'; aiScoreEl.textContent = '0'; startMatch(); }
    });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    // --- RAGDOLL ---
    function pt(x, y, r, mass) { return { x, y, ox: x, oy: y, vx: 0, vy: 0, r: r || 4, mass: mass || 1 }; }

    function createWrestler(x, face, col, outline, trunksCol) {
      const f = face;
      const p = {
        head:  pt(x, MAT_Y - 108, 11, 2.5),
        neck:  pt(x, MAT_Y - 93, 3, 1),
        shlL:  pt(x - 14*f, MAT_Y - 88, 5, 1.5),
        shlR:  pt(x + 14*f, MAT_Y - 88, 5, 1.5),
        elbL:  pt(x - 26*f, MAT_Y - 75, 4, 1),
        elbR:  pt(x + 26*f, MAT_Y - 75, 4, 1),
        hndL:  pt(x - 36*f, MAT_Y - 64, 5, 0.7),
        hndR:  pt(x + 36*f, MAT_Y - 64, 5, 0.7),
        hip:   pt(x, MAT_Y - 52, 7, 4),
        knL:   pt(x - 8*f, MAT_Y - 28, 4, 1.3),
        knR:   pt(x + 8*f, MAT_Y - 28, 4, 1.3),
        ftL:   pt(x - 14*f, MAT_Y - 5, 5, 1.2),
        ftR:   pt(x + 14*f, MAT_Y - 5, 5, 1.2),
      };
      const bones = [
        ['head','neck',15], ['neck','shlL',16], ['neck','shlR',16],
        ['shlL','elbL',18], ['shlR','elbR',18],
        ['elbL','hndL',16], ['elbR','hndR',16],
        ['neck','hip',41],
        ['hip','knL',26], ['hip','knR',26],
        ['knL','ftL',25], ['knR','ftR',25],
        // structural
        ['shlL','shlR',28], ['shlL','hip',44], ['shlR','hip',44], ['head','hip',56],
      ];
      return { pts: p, bones, face: f, col, outline, trunksCol, motors: {aL:0,aR:0,lL:0,lR:0}, grabbing: false };
    }

    let player, ai;

    function startMatch() {
      gameState = 'playing';
      round = 1;
      updateRound();
      overlay.style.display = 'none';
      initRound();
    }

    function startRound() {
      gameState = 'playing';
      overlay.style.display = 'none';
      initRound();
    }

    function initRound() {
      player = createWrestler(170, 1, '#4af', '#28d', '#24a');
      ai = createWrestler(330, -1, '#f55', '#c22', '#c22');
      pinTimer = 0; pinTarget = null; roundTimer = 0;
      matchMessage = ''; matchMsgTimer = 0; comboText = [];
      aiTimer = 0;
      updateRound();
    }

    function updateRound() { roundInfoEl.textContent = `Round ${round}/${maxRounds}`; }

    // --- PHYSICS ENGINE ---
    function applyGrav(w) {
      for (const k in w.pts) { w.pts[k].vy += GRAVITY; }
    }

    function applyMotors(w) {
      const m = w.motors, f = w.face, s = 3.2;
      // Arms swing from shoulder. Up = -1, Down = +1
      if (m.aL) {
        w.pts.elbL.vy += m.aL * s * 1.3;
        w.pts.elbL.vx -= f * s * 0.7;
        w.pts.hndL.vy += m.aL * s * 1.6;
        w.pts.hndL.vx -= f * s * 0.4;
      }
      if (m.aR) {
        w.pts.elbR.vy += m.aR * s * 1.3;
        w.pts.elbR.vx += f * s * 0.7;
        w.pts.hndR.vy += m.aR * s * 1.6;
        w.pts.hndR.vx += f * s * 0.4;
      }
      // Legs: when foot is grounded and pushed down, it propels the body forward
      // Up lifts knee, down stomps/pushes
      if (m.lL) {
        const grounded = w.pts.ftL.y + w.pts.ftL.r >= MAT_Y - 2;
        w.pts.knL.vy += m.lL * s * 0.9;
        w.pts.knL.vx -= f * s * 0.5;
        w.pts.ftL.vy += m.lL * s * 1.3;
        w.pts.ftL.vx -= f * s * 0.3;
        // Ground reaction: pushing down on grounded foot moves body
        if (grounded && m.lL > 0) {
          w.pts.hip.vx += f * 1.8;
          w.pts.hip.vy -= 0.5;
        }
        if (m.lL < 0) { // lifting leg = slight backward lean
          w.pts.hip.vx -= f * 0.3;
        }
      }
      if (m.lR) {
        const grounded = w.pts.ftR.y + w.pts.ftR.r >= MAT_Y - 2;
        w.pts.knR.vy += m.lR * s * 0.9;
        w.pts.knR.vx += f * s * 0.5;
        w.pts.ftR.vy += m.lR * s * 1.3;
        w.pts.ftR.vx += f * s * 0.3;
        if (grounded && m.lR > 0) {
          w.pts.hip.vx += f * 1.8;
          w.pts.hip.vy -= 0.5;
        }
        if (m.lR < 0) {
          w.pts.hip.vx -= f * 0.3;
        }
      }
    }

    function integrate(w) {
      for (const k in w.pts) {
        const p = w.pts[k];
        p.vx *= FRICTION;
        p.vy *= FRICTION;
        p.x += p.vx;
        p.y += p.vy;
      }
    }

    function solveBones(w) {
      for (let it = 0; it < 6; it++) {
        for (const [a, b, len] of w.bones) {
          const pa = w.pts[a], pb = w.pts[b];
          let dx = pb.x - pa.x, dy = pb.y - pa.y;
          const d = Math.sqrt(dx*dx + dy*dy) || 0.01;
          const diff = (d - len) / d;
          const tm = pa.mass + pb.mass;
          const rA = pb.mass / tm, rB = pa.mass / tm;
          pa.x += dx * diff * rA * 0.5;
          pa.y += dy * diff * rA * 0.5;
          pb.x -= dx * diff * rB * 0.5;
          pb.y -= dy * diff * rB * 0.5;
        }
        // Floor
        for (const k in w.pts) {
          const p = w.pts[k];
          if (p.y + p.r > MAT_Y) {
            p.y = MAT_Y - p.r;
            p.vy *= -0.25;
            p.vx *= 0.82;
          }
          // Ceiling
          if (p.y - p.r < 120) {
            p.y = 120 + p.r;
            p.vy = Math.abs(p.vy) * 0.3;
          }
        }
      }
    }

    function pdist(a, b) { const dx = a.x-b.x, dy = a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }

    // Body collision between two wrestlers
    function collide(a, b) {
      const partsA = ['head','shlL','shlR','hip','knL','knR'];
      const partsB = ['head','shlL','shlR','hip','knL','knR'];
      for (const ka of partsA) {
        for (const kb of partsB) {
          const pa = a.pts[ka], pb = b.pts[kb];
          let dx = pb.x - pa.x, dy = pb.y - pa.y;
          const d = Math.sqrt(dx*dx+dy*dy) || 1;
          const minD = pa.r + pb.r + 3;
          if (d < minD) {
            const push = (minD - d) / d * 0.45;
            pa.x -= dx * push * 0.5; pa.y -= dy * push * 0.5;
            pb.x += dx * push * 0.5; pb.y += dy * push * 0.5;
            pa.vx -= dx * push * 0.12; pa.vy -= dy * push * 0.12;
            pb.vx += dx * push * 0.12; pb.vy += dy * push * 0.12;
          }
        }
      }
    }

    // Grab: hands near opponent body parts
    function applyGrab(atk, def) {
      let grabbed = false;
      for (const hk of ['hndL','hndR']) {
        const hand = atk.pts[hk];
        for (const bk of ['head','neck','shlL','shlR','hip']) {
          const bp = def.pts[bk];
          const d = pdist(hand, bp);
          if (d < hand.r + bp.r + 10) {
            grabbed = true;
            const dx = hand.x - bp.x, dy = hand.y - bp.y;
            const dd = Math.sqrt(dx*dx+dy*dy) || 1;
            const f = 0.9;
            bp.vx += (dx/dd) * f;
            bp.vy += (dy/dd) * f;
            hand.vx -= (dx/dd) * f * 0.25;
            hand.vy -= (dy/dd) * f * 0.25;
          }
        }
      }
      atk.grabbing = grabbed;
    }

    // Uprighting force (weak, allows flopping)
    function upright(w) {
      const h = w.pts.head, hip = w.pts.hip;
      if (h.y > hip.y) {
        h.vy -= 1.0;
        hip.vy += 0.4;
      }
      // Try to keep hip above feet center
      const fmx = (w.pts.ftL.x + w.pts.ftR.x) / 2;
      const dx = hip.x - fmx;
      hip.vx -= dx * 0.008;
    }

    function shouldersDown(w) {
      const sl = w.pts.shlL, sr = w.pts.shlR;
      return (MAT_Y - sl.y - sl.r < 14) && (MAT_Y - sr.y - sr.r < 14);
    }

    function isRingOut(w) {
      return w.pts.hip.x < RING_L - 25 || w.pts.hip.x > RING_R + 25;
    }

    // --- AI ---
    let aiTimer = 0;
    let aiAct = { aL: 0, aR: 0, lL: 0, lR: 0 };
    let aiPhase = 'approach'; // approach, attack, recover, flee

    function updateAI() {
      aiTimer++;
      const pH = player.pts.hip, aH = ai.pts.hip;
      const dx = pH.x - aH.x;
      const dist = Math.abs(dx);

      // Decide phase
      if (shouldersDown(ai)) {
        aiPhase = 'recover';
      } else if (aH.x < RING_L + 50 || aH.x > RING_R - 50) {
        aiPhase = 'flee';
      } else if (dist > 60) {
        aiPhase = 'approach';
      } else {
        aiPhase = 'attack';
      }

      if (aiTimer % 6 === 0) {
        switch (aiPhase) {
          case 'approach':
            // Walk toward player: alternate legs like QWOP
            if (aiTimer % 24 < 12) {
              aiAct.lL = -1; aiAct.lR = 1; // lift left, push right
            } else {
              aiAct.lL = 1; aiAct.lR = -1; // push left, lift right
            }
            // Arms up ready to grab
            aiAct.aL = -1; aiAct.aR = -1;
            break;

          case 'attack':
            // Close quarters: pump arms to push opponent down
            if (aiTimer % 12 < 6) {
              aiAct.aL = 1; aiAct.aR = -1;
            } else {
              aiAct.aL = -1; aiAct.aR = 1;
            }
            // Legs: brace and push
            aiAct.lL = (Math.random() > 0.4) ? 1 : -1;
            aiAct.lR = (Math.random() > 0.4) ? 1 : -1;
            // Sometimes lunge
            if (Math.random() < 0.08) {
              aiAct.aL = 1; aiAct.aR = 1; // both arms down = push
              aiAct.lL = 1; aiAct.lR = 1;
            }
            break;

          case 'recover':
            // Flail to get up
            aiAct.aL = (Math.random() > 0.3) ? -1 : 1;
            aiAct.aR = (Math.random() > 0.3) ? -1 : 1;
            aiAct.lL = (Math.random() > 0.3) ? -1 : 1;
            aiAct.lR = (Math.random() > 0.3) ? -1 : 1;
            break;

          case 'flee':
            // Move toward center
            const toCenter = 250 - aH.x;
            if (toCenter > 0) {
              // Need to go right (face is -1 for AI, so this is backward)
              if (aiTimer % 24 < 12) { aiAct.lL = 1; aiAct.lR = -1; }
              else { aiAct.lL = -1; aiAct.lR = 1; }
            } else {
              if (aiTimer % 24 < 12) { aiAct.lL = -1; aiAct.lR = 1; }
              else { aiAct.lL = 1; aiAct.lR = -1; }
            }
            aiAct.aL = -1; aiAct.aR = -1;
            break;
        }

        // Random comedy flail (15% chance)
        if (Math.random() < 0.12 && aiPhase !== 'recover') {
          aiAct.aL = (Math.random() > 0.5) ? -1 : 1;
          aiAct.aR = (Math.random() > 0.5) ? -1 : 1;
          aiAct.lL = (Math.random() > 0.5) ? -1 : 1;
          aiAct.lR = (Math.random() > 0.5) ? -1 : 1;
        }
      }

      ai.motors.aL = aiAct.aL;
      ai.motors.aR = aiAct.aR;
      ai.motors.lL = aiAct.lL;
      ai.motors.lR = aiAct.lR;
    }

    function handleInput() {
      player.motors.aL = keys['q'] ? -1 : (keys['w'] ? 1 : 0);
      player.motors.aR = keys['o'] ? -1 : (keys['p'] ? 1 : 0);
      player.motors.lL = keys['a'] ? -1 : (keys['s'] ? 1 : 0);
      player.motors.lR = keys['k'] ? -1 : (keys['l'] ? 1 : 0);
    }

    // --- DRAWING ---
    function drawRing() {
      // Arena floor/apron
      ctx.fillStyle = '#2a1a14';
      ctx.fillRect(RING_L - 15, MAT_Y, RING_R - RING_L + 30, 80);

      // Mat top surface
      const matGrad = ctx.createLinearGradient(RING_L, MAT_Y - 3, RING_R, MAT_Y - 3);
      matGrad.addColorStop(0, '#5a3828');
      matGrad.addColorStop(0.5, '#6a4430');
      matGrad.addColorStop(1, '#5a3828');
      ctx.fillStyle = matGrad;
      ctx.fillRect(RING_L, MAT_Y - 3, RING_R - RING_L, 6);

      // Center circle on mat
      ctx.strokeStyle = 'rgba(255,136,34,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(250, MAT_Y, 40, Math.PI, 0);
      ctx.stroke();

      // Posts
      ctx.fillStyle = '#777';
      ctx.fillRect(RING_L - 5, 135, 7, MAT_Y - 135);
      ctx.fillRect(RING_R - 2, 135, 7, MAT_Y - 135);

      // Turnbuckle pads
      ctx.fillStyle = '#f82';
      for (const x of [RING_L - 2, RING_R + 2]) {
        ctx.beginPath(); ctx.arc(x, 138, 7, 0, Math.PI * 2); ctx.fill();
      }

      // Ropes with slight sag
      ctx.lineWidth = 2.5;
      for (const ry of ROPE_YS) {
        ctx.strokeStyle = ry === ROPE_YS[0] ? '#f82' : (ry === ROPE_YS[1] ? '#e72' : '#d62');
        ctx.beginPath();
        ctx.moveTo(RING_L - 2, ry);
        ctx.quadraticCurveTo(250, ry + 3, RING_R + 2, ry);
        ctx.stroke();
      }

      // Audience (stylized)
      for (let row = 0; row < 3; row++) {
        for (let i = 0; i < 22; i++) {
          const ax = 12 + i * 23 + row * 8;
          const ay = 50 + row * 22 + Math.sin(i * 1.7 + row) * 5;
          const bright = 15 + Math.floor(Math.random() * 0.3) * 10;
          ctx.fillStyle = `rgb(${bright},${bright},${bright + 8})`;
          ctx.beginPath(); ctx.arc(ax, ay, 5, 0, Math.PI * 2); ctx.fill();
          ctx.fillRect(ax - 3, ay + 5, 6, 7);
        }
      }

      // Spotlight glow
      const spot = ctx.createRadialGradient(250, MAT_Y - 80, 10, 250, MAT_Y - 80, 220);
      spot.addColorStop(0, 'rgba(255,136,34,0.07)');
      spot.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = spot;
      ctx.fillRect(0, 0, W, H);
    }

    function drawLimb(pa, pb, col, thick) {
      ctx.strokeStyle = col;
      ctx.lineWidth = thick;
      ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(pa.x, pa.y); ctx.lineTo(pb.x, pb.y); ctx.stroke();
    }

    function drawWrestler(w) {
      const p = w.pts;
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(p.hip.x, MAT_Y + 2, 20, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Limb pairs: outline then color
      const limbs = [
        [p.neck,p.shlL],[p.neck,p.shlR],[p.shlL,p.elbL],[p.shlR,p.elbR],
        [p.elbL,p.hndL],[p.elbR,p.hndR],[p.neck,p.hip],
        [p.hip,p.knL],[p.hip,p.knR],[p.knL,p.ftL],[p.knR,p.ftR]
      ];
      // Outline
      for (const [a,b] of limbs) drawLimb(a, b, w.outline, 6);
      // Color
      for (const [a,b] of limbs) drawLimb(a, b, w.col, 4);

      // Trunks (shorts)
      ctx.fillStyle = w.trunksCol;
      ctx.beginPath();
      ctx.moveTo(p.shlL.x, p.hip.y - 8);
      ctx.lineTo(p.shlR.x, p.hip.y - 8);
      ctx.lineTo(p.knR.x, p.knR.y - 4);
      ctx.lineTo(p.knL.x, p.knL.y - 4);
      ctx.closePath();
      ctx.fill();

      // Torso fill
      ctx.fillStyle = w.col;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(p.shlL.x, p.shlL.y);
      ctx.lineTo(p.shlR.x, p.shlR.y);
      ctx.lineTo(p.hip.x + 8, p.hip.y);
      ctx.lineTo(p.hip.x - 8, p.hip.y);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Joints
      for (const k in p) {
        const pt = p[k];
        const isHand = (k === 'hndL' || k === 'hndR');
        ctx.fillStyle = isHand ? '#ffe0c0' : w.col;
        ctx.strokeStyle = w.outline;
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      }

      // Boots
      for (const fk of ['ftL','ftR']) {
        ctx.fillStyle = w.col === '#4af' ? '#26c' : '#a11';
        ctx.beginPath(); ctx.arc(p[fk].x, p[fk].y, p[fk].r + 1, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = w.outline; ctx.lineWidth = 1; ctx.stroke();
      }

      // Head: skin color + mask
      ctx.fillStyle = '#ffe0c0';
      ctx.beginPath(); ctx.arc(p.head.x, p.head.y, p.head.r, 0, Math.PI * 2); ctx.fill();
      // Mask top
      ctx.fillStyle = w.col;
      ctx.beginPath();
      ctx.arc(p.head.x, p.head.y - 1, p.head.r - 1, Math.PI + 0.4, -0.4);
      ctx.closePath();
      ctx.fill();
      // Eyes
      const eyeF = w.face;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(p.head.x + eyeF*2 - 2, p.head.y - 1, 2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(p.head.x + eyeF*2 + 3, p.head.y - 1, 2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(p.head.x + eyeF*2 - 1.5, p.head.y - 1, 0.8, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(p.head.x + eyeF*2 + 3.5, p.head.y - 1, 0.8, 0, Math.PI*2); ctx.fill();
      // Mouth (changes with effort)
      const effort = Math.abs(w.motors.aL) + Math.abs(w.motors.aR) + Math.abs(w.motors.lL) + Math.abs(w.motors.lR);
      if (effort > 2) {
        // Yelling
        ctx.fillStyle = '#300';
        ctx.beginPath(); ctx.ellipse(p.head.x + eyeF*2, p.head.y + 4, 3, 2, 0, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.strokeStyle = '#300';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.head.x + eyeF*2 - 2, p.head.y + 4);
        ctx.lineTo(p.head.x + eyeF*2 + 2, p.head.y + 4);
        ctx.stroke();
      }

      // Grab sparks
      if (w.grabbing) {
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 3]);
        for (const hk of ['hndL','hndR']) {
          ctx.beginPath(); ctx.arc(p[hk].x, p[hk].y, p[hk].r + 7, 0, Math.PI*2); ctx.stroke();
        }
        ctx.setLineDash([]);
        // Spark particles
        if (roundTimer % 4 === 0) {
          for (const hk of ['hndL','hndR']) {
            comboText.push({ x: p[hk].x + (Math.random()-0.5)*10, y: p[hk].y - 5, t: 15, txt: '*', col: '#ff0', sz: 10 });
          }
        }
      }
    }

    function drawPin() {
      if (!pinTarget || pinTimer <= 0) return;
      const w = pinTarget === 'ai' ? ai : player;
      const cx = (w.pts.shlL.x + w.pts.shlR.x) / 2;
      const cy = Math.min(w.pts.shlL.y, w.pts.shlR.y) - 30;
      const progress = pinTimer / 180;
      const secs = (pinTimer / 60).toFixed(1);

      // Background
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(cx - 40, cy - 8, 80, 32);

      // Text
      ctx.fillStyle = '#f82';
      ctx.font = 'bold 14px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`PIN ${secs}s`, cx, cy + 6);

      // Bar
      ctx.fillStyle = '#333';
      ctx.fillRect(cx - 35, cy + 12, 70, 6);
      ctx.fillStyle = progress < 0.5 ? '#f82' : (progress < 0.8 ? '#fa2' : '#f22');
      ctx.fillRect(cx - 35, cy + 12, 70 * progress, 6);

      // Flash
      if (Math.floor(pinTimer / 6) % 2 === 0) {
        ctx.strokeStyle = '#f82';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx - 42, cy - 10, 84, 36);
      }

      // Big count numbers
      const count = Math.floor(pinTimer / 60) + 1;
      if (pinTimer % 60 < 20) {
        ctx.fillStyle = `rgba(255,136,34,${1 - (pinTimer % 60)/20})`;
        ctx.font = 'bold 48px Courier New';
        ctx.fillText(count.toString(), 250, 200);
      }
    }

    function drawHUD() {
      // Key guide boxes at bottom
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(3, H - 52, 155, 49);
      ctx.fillRect(W - 158, H - 52, 155, 49);

      ctx.font = '8px Courier New';
      ctx.textAlign = 'left';

      // Player keys with active highlighting
      const plKeys = [
        ['Q', 'W', 'L.Arm', player.motors.aL],
        ['O', 'P', 'R.Arm', player.motors.aR],
        ['A', 'S', 'L.Leg', player.motors.lL],
        ['K', 'L', 'R.Leg', player.motors.lR],
      ];
      ctx.fillStyle = '#4af';
      ctx.fillText('YOU', 8, H - 40);
      for (let i = 0; i < plKeys.length; i++) {
        const [u, d, label, val] = plKeys[i];
        const y = H - 30 + i * 9;
        ctx.fillStyle = val === -1 ? '#4f4' : (val === 1 ? '#f44' : '#555');
        ctx.fillText(`${u}/${d}: ${label}`, 8, y);
      }

      // Right side: scoring info
      ctx.textAlign = 'right';
      ctx.fillStyle = '#f55';
      ctx.fillText('CPU', W - 8, H - 40);
      ctx.fillStyle = '#777';
      ctx.fillText('Pin = 3s shoulders', W - 8, H - 30);
      ctx.fillText('Ring-out = off edge', W - 8, H - 21);
      ctx.fillText('Best of 3 rounds', W - 8, H - 12);
    }

    function drawFloatingText() {
      for (let i = comboText.length - 1; i >= 0; i--) {
        const t = comboText[i];
        t.y -= 0.8;
        t.t--;
        if (t.t <= 0) { comboText.splice(i, 1); continue; }
        ctx.fillStyle = t.col;
        ctx.globalAlpha = Math.min(1, t.t / 10);
        ctx.font = `bold ${t.sz}px Courier New`;
        ctx.textAlign = 'center';
        ctx.fillText(t.txt, t.x, t.y);
        ctx.globalAlpha = 1;
      }
    }

    function drawMsg() {
      if (matchMsgTimer <= 0) return;
      const a = Math.min(1, matchMsgTimer / 30);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = '#f82';
      ctx.font = 'bold 22px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#f82';
      ctx.shadowBlur = 15;
      ctx.fillText(matchMessage, 250, 135);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // --- UPDATE ---
    function update() {
      if (gameState !== 'playing') return;
      roundTimer++;

      handleInput();
      updateAI();

      for (const w of [player, ai]) {
        applyMotors(w);
        applyGrav(w);
        integrate(w);
        solveBones(w);
        upright(w);
      }
      collide(player, ai);
      applyGrab(player, ai);
      applyGrab(ai, player);

      // Pin logic
      const pDown = shouldersDown(player);
      const aDown = shouldersDown(ai);

      if (aDown && !pDown) {
        if (pinTarget === 'ai') pinTimer++;
        else { pinTarget = 'ai'; pinTimer = 1; }
      } else if (pDown && !aDown) {
        if (pinTarget === 'player') pinTimer++;
        else { pinTarget = 'player'; pinTimer = 1; }
      } else {
        pinTimer = Math.max(0, pinTimer - 3);
        if (pinTimer <= 0) pinTarget = null;
      }

      if (pinTimer >= 180) {
        if (pinTarget === 'ai') {
          score++; scoreEl.textContent = score;
          matchMessage = 'PIN! You score!';
          comboText.push({ x: 250, y: 180, t: 60, txt: 'PINFALL!', col: '#f82', sz: 28 });
        } else {
          aiScoreVal++; aiScoreEl.textContent = aiScoreVal;
          matchMessage = 'PIN! CPU scores!';
          comboText.push({ x: 250, y: 180, t: 60, txt: 'PINFALL!', col: '#f55', sz: 28 });
        }
        matchMsgTimer = 90; shakeTimer = 15;
        endRound(); return;
      }

      // Ring out
      if (isRingOut(player)) {
        aiScoreVal++; aiScoreEl.textContent = aiScoreVal;
        matchMessage = 'RING OUT! CPU scores!';
        comboText.push({ x: 250, y: 180, t: 60, txt: 'RING OUT!', col: '#f55', sz: 28 });
        matchMsgTimer = 90; shakeTimer = 20;
        endRound(); return;
      }
      if (isRingOut(ai)) {
        score++; scoreEl.textContent = score;
        matchMessage = 'RING OUT! You score!';
        comboText.push({ x: 250, y: 180, t: 60, txt: 'RING OUT!', col: '#f82', sz: 28 });
        matchMsgTimer = 90; shakeTimer = 20;
        endRound(); return;
      }

      if (matchMsgTimer > 0) matchMsgTimer--;

      // Screen shake
      if (shakeTimer > 0) {
        shakeTimer--;
        shakeX = (Math.random()-0.5) * shakeTimer;
        shakeY = (Math.random()-0.5) * shakeTimer * 0.6;
      } else { shakeX = 0; shakeY = 0; }
    }

    function endRound() {
      pinTimer = 0; pinTarget = null;

      if (round >= maxRounds || score >= 2 || aiScoreVal >= 2) {
        gameState = 'matchEnd';
        overlay.style.display = 'flex';
        if (score > aiScoreVal) {
          overlayTitle.textContent = 'CHAMPION!';
          overlayText.textContent = `You win ${score}-${aiScoreVal}! Press any key to rematch`;
        } else if (aiScoreVal > score) {
          overlayTitle.textContent = 'DEFEATED!';
          overlayText.textContent = `CPU wins ${aiScoreVal}-${score}. Press any key to rematch`;
        } else {
          overlayTitle.textContent = 'DRAW!';
          overlayText.textContent = `${score}-${aiScoreVal}. Press any key to rematch`;
        }
      } else {
        round++;
        gameState = 'roundEnd';
        overlay.style.display = 'flex';
        overlayTitle.textContent = matchMessage;
        overlayText.textContent = `Round ${round} - Press any key`;
      }
    }

    function draw() {
      ctx.save();
      ctx.translate(shakeX, shakeY);

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(-10, -10, W + 20, H + 20);

      drawRing();

      if (player && ai) {
        drawWrestler(player);
        drawWrestler(ai);
        drawPin();
      }

      drawFloatingText();
      drawHUD();
      drawMsg();

      ctx.restore();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function getGameState() {
      return { gameState, score, aiScore: aiScoreVal, round, pinTimer, pinTarget };
    }

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sumo Push</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #f80; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 0, 0.5); }
    h1 { color: #f80; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f80; }
    .controls-info {
      width: 500px;
      margin-bottom: 8px;
      font-size: 0.75rem;
      color: #666;
      text-align: center;
    }
    canvas {
      border: 2px solid #f80;
      box-shadow: 0 0 20px rgba(255, 136, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f80;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SUMO PUSH</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="roundInfo" style="color:#f80;font-size:0.9rem;">Best of 5</div>
    <div>CPU: <span id="aiScore">0</span></div>
  </div>
  <div class="controls-info">
    Arrows=Move | Space=Push | Z=Charge | X=Dodge
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">SUMO PUSH</h2>
      <p id="overlayText">Press any key to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 500, H = 500;
    const CX = W / 2, CY = H / 2;
    const scoreEl = document.getElementById('score');
    const aiScoreEl = document.getElementById('aiScore');
    const roundInfoEl = document.getElementById('roundInfo');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'waiting';
    let score = 0;

    // Ring
    const RING_RADIUS = 190;
    const RING_EDGE_ZONE = 40;

    // Wrestler constants
    const WRESTLER_RADIUS = 28;
    const MAX_SPEED = 2.8;
    const ACCEL = 0.25;
    const FRICTION = 0.92;
    const MAX_STAMINA = 100;
    const STAMINA_REGEN = 0.3;
    const PUSH_COST = 25;
    const PUSH_FORCE = 8;
    const CHARGE_PUSH_FORCE = 16;
    const PUSH_RANGE = 70;
    const DODGE_SPEED = 7;
    const DODGE_COST = 20;
    const DODGE_DURATION = 12;
    const DODGE_COOLDOWN = 30;
    const CHARGE_RATE = 1.5;
    const MAX_CHARGE = 100;
    const PUSH_COOLDOWN = 20;
    const WEIGHT_BASE = 1.0;

    // Game state
    let playerWins = 0;
    let aiWins = 0;
    let currentRound = 1;
    let roundState = 'ready';
    let roundTimer = 0;
    let roundEndTimer = 0;
    let roundMessage = '';

    // Input
    const keys = {};
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','z','Z','x','X'].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;
      if (gameState === 'waiting') { startGame(); return; }
      if (gameState === 'over') { resetMatch(); return; }
    });
    document.addEventListener('keyup', (e) => { keys[e.key] = false; });

    // Particles
    let particles = [];
    let ringPulse = 0;

    function createWrestler(x, y, color, colorGlow) {
      return {
        x, y,
        vx: 0, vy: 0,
        radius: WRESTLER_RADIUS,
        color, colorGlow,
        stamina: MAX_STAMINA,
        charge: 0,
        isCharging: false,
        isPushing: false,
        pushTimer: 0,
        pushDirX: 0, pushDirY: 0,
        isDodging: false,
        dodgeTimer: 0,
        dodgeCooldown: 0,
        dodgeDirX: 0, dodgeDirY: 0,
        weight: WEIGHT_BASE,
        stunTimer: 0,
        flashTimer: 0
      };
    }

    let player, ai;

    function init() {
      player = createWrestler(CX - 60, CY, '#4488ff', 'rgba(68,136,255,0.5)');
      ai = createWrestler(CX + 60, CY, '#f80', 'rgba(255,136,0,0.5)');
      particles = [];
      roundState = 'ready';
      roundTimer = 60;
      roundMessage = 'Round ' + currentRound;
    }

    function startGame() {
      gameState = 'playing';
      overlay.style.display = 'none';
      playerWins = 0;
      aiWins = 0;
      currentRound = 1;
      score = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      init();
    }

    function resetMatch() {
      gameState = 'playing';
      overlay.style.display = 'none';
      playerWins = 0;
      aiWins = 0;
      currentRound = 1;
      score = 0;
      scoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      init();
    }

    // Helpers
    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    function distFromCenter(w) {
      return Math.sqrt((w.x - CX) ** 2 + (w.y - CY) ** 2);
    }
    function normalize(x, y) {
      const len = Math.sqrt(x * x + y * y);
      if (len === 0) return { x: 0, y: 0 };
      return { x: x / len, y: y / len };
    }

    // Particles
    function spawnParticles(x, y, color, count, speed) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = (Math.random() * 0.5 + 0.5) * speed;
        particles.push({
          x, y,
          vx: Math.cos(angle) * spd,
          vy: Math.sin(angle) * spd,
          life: 30 + Math.random() * 20,
          maxLife: 30 + Math.random() * 20,
          color,
          size: 2 + Math.random() * 3
        });
      }
    }

    function spawnImpactParticles(x, y, dirX, dirY, color, count) {
      for (let i = 0; i < count; i++) {
        const spread = (Math.random() - 0.5) * 1.5;
        const spd = 2 + Math.random() * 4;
        particles.push({
          x, y,
          vx: dirX * spd + spread * 2,
          vy: dirY * spd + spread * 2,
          life: 15 + Math.random() * 15,
          maxLife: 15 + Math.random() * 15,
          color,
          size: 3 + Math.random() * 4
        });
      }
    }

    // Edge resistance: closer to edge = less resistance to pushes
    function edgeResistance(wrestler) {
      const d = distFromCenter(wrestler);
      const edgeDist = RING_RADIUS - d;
      if (edgeDist < 0) return 0.2;
      if (edgeDist < RING_EDGE_ZONE) {
        return 0.4 + 0.6 * (edgeDist / RING_EDGE_ZONE);
      }
      return 1.0;
    }

    // Push mechanics
    function applyPush(attacker, defender, force) {
      if (defender.isDodging) {
        // Missed! Attacker stumbles forward
        spawnParticles(defender.x, defender.y, '#fff', 4, 2);
        const dx = defender.x - attacker.x;
        const dy = defender.y - attacker.y;
        const n = normalize(dx, dy);
        attacker.vx += n.x * 3;
        attacker.vy += n.y * 3;
        attacker.stunTimer = 15;
        return;
      }

      const dx = defender.x - attacker.x;
      const dy = defender.y - attacker.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d === 0) return;
      const nx = dx / d;
      const ny = dy / d;

      const resist = edgeResistance(defender);
      const effectiveForce = force / (resist * defender.weight);

      defender.vx += nx * effectiveForce;
      defender.vy += ny * effectiveForce;
      defender.stunTimer = 10;

      // Knockback on attacker
      attacker.vx -= nx * 1.5;
      attacker.vy -= ny * 1.5;

      // Impact effects
      const impactX = (attacker.x + defender.x) / 2;
      const impactY = (attacker.y + defender.y) / 2;
      spawnImpactParticles(impactX, impactY, nx, ny, '#fff', 8);
      spawnParticles(impactX, impactY, attacker.color, 5, 3);

      ringPulse = 10;
    }

    // Movement
    function moveWrestler(w) {
      if (w.isDodging) {
        w.x += w.dodgeDirX * DODGE_SPEED;
        w.y += w.dodgeDirY * DODGE_SPEED;
        w.dodgeTimer--;
        if (w.dodgeTimer <= 0) {
          w.isDodging = false;
          w.dodgeCooldown = DODGE_COOLDOWN;
        }
      } else {
        w.x += w.vx;
        w.y += w.vy;
        w.vx *= FRICTION;
        w.vy *= FRICTION;
      }

      // Stamina regen
      if (!w.isCharging) {
        w.stamina = Math.min(MAX_STAMINA, w.stamina + STAMINA_REGEN);
      }

      // Timers
      if (w.pushTimer > 0) w.pushTimer--;
      if (w.dodgeCooldown > 0) w.dodgeCooldown--;
      if (w.stunTimer > 0) w.stunTimer--;
      if (w.flashTimer > 0) w.flashTimer--;

      // Charge decay
      if (!w.isCharging && w.charge > 0) {
        w.charge = Math.max(0, w.charge - 2);
      }
    }

    // Collision
    function collideWrestlers(a, b) {
      if (a.isDodging || b.isDodging) return;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      const minDist = a.radius + b.radius;
      if (d < minDist && d > 0) {
        const nx = dx / d;
        const ny = dy / d;
        const overlap = minDist - d;
        a.x -= nx * overlap / 2;
        a.y -= ny * overlap / 2;
        b.x += nx * overlap / 2;
        b.y += ny * overlap / 2;

        // Momentum transfer
        const relVx = a.vx - b.vx;
        const relVy = a.vy - b.vy;
        const relDot = relVx * nx + relVy * ny;
        if (relDot > 0) {
          a.vx -= nx * relDot * 0.5;
          a.vy -= ny * relDot * 0.5;
          b.vx += nx * relDot * 0.5;
          b.vy += ny * relDot * 0.5;
        }
      }
    }

    function isOutOfRing(w) {
      return distFromCenter(w) > RING_RADIUS + w.radius * 0.5;
    }

    // Constrain: soft drag near edge
    function constrainToRing(w) {
      const d = distFromCenter(w);
      if (d > RING_RADIUS - w.radius * 0.3 && d > 0) {
        if (d > RING_RADIUS + w.radius) return;
        const nx = (w.x - CX) / d;
        const ny = (w.y - CY) / d;
        const dot = w.vx * nx + w.vy * ny;
        if (dot > 0) {
          const resist = edgeResistance(w);
          w.vx -= nx * dot * (1 - resist) * 0.3;
          w.vy -= ny * dot * (1 - resist) * 0.3;
        }
      }
    }

    // Player input
    function handlePlayerInput() {
      if (player.stunTimer > 0) return;
      if (player.isDodging) return;

      let ax = 0, ay = 0;
      if (keys['ArrowLeft']) ax -= 1;
      if (keys['ArrowRight']) ax += 1;
      if (keys['ArrowUp']) ay -= 1;
      if (keys['ArrowDown']) ay += 1;

      const speedMult = player.isCharging ? 0.4 : 1.0;

      if (ax !== 0 || ay !== 0) {
        const n = normalize(ax, ay);
        player.vx += n.x * ACCEL * speedMult;
        player.vy += n.y * ACCEL * speedMult;
      }

      const spd = Math.sqrt(player.vx ** 2 + player.vy ** 2);
      if (spd > MAX_SPEED * speedMult) {
        player.vx = (player.vx / spd) * MAX_SPEED * speedMult;
        player.vy = (player.vy / spd) * MAX_SPEED * speedMult;
      }

      // Charge (Z)
      if (keys['z'] || keys['Z']) {
        if (player.stamina > 0.5) {
          player.isCharging = true;
          player.charge = Math.min(MAX_CHARGE, player.charge + CHARGE_RATE);
          player.stamina = Math.max(0, player.stamina - 0.4);
        } else {
          player.isCharging = false;
        }
      } else {
        player.isCharging = false;
      }

      // Push (Space)
      if (keys[' '] && player.pushTimer <= 0) {
        const d = dist(player, ai);
        if (d < PUSH_RANGE && player.stamina >= PUSH_COST) {
          const force = player.charge > 50 ? CHARGE_PUSH_FORCE * (player.charge / MAX_CHARGE + 0.5) : PUSH_FORCE;
          applyPush(player, ai, force);
          player.stamina -= PUSH_COST;
          player.pushTimer = PUSH_COOLDOWN;
          player.charge = 0;
          player.isCharging = false;
          player.isPushing = true;
          player.flashTimer = 8;
          const dx = ai.x - player.x;
          const dy = ai.y - player.y;
          const n = normalize(dx, dy);
          player.pushDirX = n.x;
          player.pushDirY = n.y;
          setTimeout(() => { player.isPushing = false; }, 200);
        }
      }

      // Dodge (X)
      if ((keys['x'] || keys['X']) && !player.isDodging && player.dodgeCooldown <= 0 && player.stamina >= DODGE_COST) {
        player.isDodging = true;
        player.dodgeTimer = DODGE_DURATION;
        player.stamina -= DODGE_COST;
        if (ax !== 0 || ay !== 0) {
          const n = normalize(ax, ay);
          player.dodgeDirX = n.x;
          player.dodgeDirY = n.y;
        } else {
          const dx = player.x - ai.x;
          const dy = player.y - ai.y;
          const n = normalize(dx, dy);
          player.dodgeDirX = n.x;
          player.dodgeDirY = n.y;
        }
        spawnParticles(player.x, player.y, player.color, 6, 2);
      }
    }

    // AI
    let aiDecisionTimer = 0;
    let aiTarget = { x: CX, y: CY };
    let aiWantCharge = false;
    let aiWantPush = false;
    let aiWantDodge = false;

    function updateAI() {
      if (ai.stunTimer > 0) return;
      if (ai.isDodging) return;

      aiDecisionTimer--;
      if (aiDecisionTimer <= 0) {
        aiDecisionTimer = 10 + Math.floor(Math.random() * 15);
        makeAIDecision();
      }

      // Move toward target
      const dx = aiTarget.x - ai.x;
      const dy = aiTarget.y - ai.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      const speedMult = ai.isCharging ? 0.4 : 1.0;

      if (d > 5) {
        const n = normalize(dx, dy);
        ai.vx += n.x * ACCEL * speedMult;
        ai.vy += n.y * ACCEL * speedMult;
      }

      const spd = Math.sqrt(ai.vx ** 2 + ai.vy ** 2);
      if (spd > MAX_SPEED * speedMult) {
        ai.vx = (ai.vx / spd) * MAX_SPEED * speedMult;
        ai.vy = (ai.vy / spd) * MAX_SPEED * speedMult;
      }

      // Charging
      if (aiWantCharge && ai.stamina > 15) {
        ai.isCharging = true;
        ai.charge = Math.min(MAX_CHARGE, ai.charge + CHARGE_RATE);
        ai.stamina = Math.max(0, ai.stamina - 0.4);
      } else {
        ai.isCharging = false;
      }

      // Push
      if (aiWantPush && ai.pushTimer <= 0) {
        const dp = dist(ai, player);
        if (dp < PUSH_RANGE && ai.stamina >= PUSH_COST) {
          const force = ai.charge > 50 ? CHARGE_PUSH_FORCE * (ai.charge / MAX_CHARGE + 0.5) : PUSH_FORCE;
          applyPush(ai, player, force);
          ai.stamina -= PUSH_COST;
          ai.pushTimer = PUSH_COOLDOWN;
          ai.charge = 0;
          ai.isCharging = false;
          ai.isPushing = true;
          ai.flashTimer = 8;
          const ndx = player.x - ai.x;
          const ndy = player.y - ai.y;
          const nn = normalize(ndx, ndy);
          ai.pushDirX = nn.x;
          ai.pushDirY = nn.y;
          aiWantPush = false;
          aiWantCharge = false;
          setTimeout(() => { ai.isPushing = false; }, 200);
        }
      }

      // Dodge
      if (aiWantDodge && !ai.isDodging && ai.dodgeCooldown <= 0 && ai.stamina >= DODGE_COST) {
        ai.isDodging = true;
        ai.dodgeTimer = DODGE_DURATION;
        ai.stamina -= DODGE_COST;
        const pdx = ai.x - player.x;
        const pdy = ai.y - player.y;
        const n = normalize(pdx, pdy);
        if (Math.random() < 0.5) {
          ai.dodgeDirX = -n.y;
          ai.dodgeDirY = n.x;
        } else {
          ai.dodgeDirX = n.y;
          ai.dodgeDirY = -n.x;
        }
        aiWantDodge = false;
        spawnParticles(ai.x, ai.y, ai.color, 6, 2);
      }
    }

    function makeAIDecision() {
      const dp = dist(ai, player);
      const aiEdgeDist = RING_RADIUS - distFromCenter(ai);
      const playerEdgeDist = RING_RADIUS - distFromCenter(player);

      aiWantCharge = false;
      aiWantPush = false;
      aiWantDodge = false;

      // If AI near edge, retreat to center
      if (aiEdgeDist < 50) {
        aiTarget.x = CX + (Math.random() - 0.5) * 40;
        aiTarget.y = CY + (Math.random() - 0.5) * 40;
        return;
      }

      // If player near edge, go for the kill
      if (playerEdgeDist < 60 && dp < 120) {
        const pAngle = Math.atan2(player.y - CY, player.x - CX);
        aiTarget.x = player.x - Math.cos(pAngle) * 50;
        aiTarget.y = player.y - Math.sin(pAngle) * 50;
        if (dp < PUSH_RANGE && ai.stamina >= PUSH_COST) {
          aiWantPush = true;
        }
        return;
      }

      // Dodge incoming attacks
      if (player.isCharging && dp < 100) {
        if (Math.random() < 0.6) {
          aiWantDodge = true;
          return;
        }
      }
      if (player.isPushing && dp < PUSH_RANGE + 20) {
        if (Math.random() < 0.5) {
          aiWantDodge = true;
          return;
        }
      }

      // Approach and fight
      if (dp > PUSH_RANGE + 20) {
        const pAngle = Math.atan2(player.y - CY, player.x - CX);
        aiTarget.x = player.x - Math.cos(pAngle) * 40;
        aiTarget.y = player.y - Math.sin(pAngle) * 40;
        if (dp > 100 && ai.stamina > 40) {
          aiWantCharge = true;
        }
      } else {
        if (ai.charge > 60 || (ai.stamina >= PUSH_COST && Math.random() < 0.5)) {
          aiWantPush = true;
        } else if (ai.stamina > 30 && Math.random() < 0.3) {
          aiWantCharge = true;
          const angle = Math.atan2(ai.y - player.y, ai.x - player.x) + (Math.random() < 0.5 ? 0.5 : -0.5);
          aiTarget.x = player.x + Math.cos(angle) * 55;
          aiTarget.y = player.y + Math.sin(angle) * 55;
        } else {
          const angle = Math.atan2(ai.y - player.y, ai.x - player.x) + (Math.random() < 0.5 ? 0.8 : -0.8);
          aiTarget.x = player.x + Math.cos(angle) * 60;
          aiTarget.y = player.y + Math.sin(angle) * 60;
        }
      }
    }

    // Update loop
    function update() {
      if (gameState !== 'playing') return;

      if (roundState === 'ready') {
        roundTimer--;
        if (roundTimer <= 0) {
          roundState = 'fighting';
        }
        return;
      }

      if (roundState === 'roundEnd') {
        roundEndTimer--;
        if (roundEndTimer <= 0) {
          if (playerWins >= 3 || aiWins >= 3) {
            roundState = 'matchEnd';
            gameState = 'over';
            overlay.style.display = 'flex';
            if (playerWins >= 3) {
              overlayTitle.textContent = 'YOU WIN!';
              overlayText.textContent = playerWins + '-' + aiWins + ' | Press any key to restart';
            } else {
              overlayTitle.textContent = 'CPU WINS';
              overlayText.textContent = aiWins + '-' + playerWins + ' | Press any key to restart';
            }
            return;
          }
          currentRound++;
          init();
        }
        // Still update particles during round end
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx; p.y += p.vy;
          p.vx *= 0.95; p.vy *= 0.95;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }
        if (ringPulse > 0) ringPulse--;
        return;
      }

      // Fighting
      handlePlayerInput();
      updateAI();
      moveWrestler(player);
      moveWrestler(ai);
      constrainToRing(player);
      constrainToRing(ai);
      collideWrestlers(player, ai);

      // Check ring out
      if (isOutOfRing(player)) {
        aiWins++;
        aiScoreEl.textContent = aiWins;
        roundMessage = 'CPU scores!';
        roundState = 'roundEnd';
        roundEndTimer = 90;
        spawnParticles(player.x, player.y, player.color, 20, 5);
        ringPulse = 20;
      } else if (isOutOfRing(ai)) {
        playerWins++;
        score = playerWins;
        scoreEl.textContent = playerWins;
        roundMessage = 'You score!';
        roundState = 'roundEnd';
        roundEndTimer = 90;
        spawnParticles(ai.x, ai.y, ai.color, 20, 5);
        ringPulse = 20;
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.95; p.vy *= 0.95;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      if (ringPulse > 0) ringPulse--;
      roundInfoEl.textContent = 'Round ' + currentRound + ' / Best of 5';
      updateGameData();
    }

    // ---- DRAWING ----

    function drawRing() {
      // Outer glow
      const pulseSize = ringPulse > 0 ? Math.sin(ringPulse * 0.5) * 5 : 0;
      const grad = ctx.createRadialGradient(CX, CY, RING_RADIUS - 10 + pulseSize, CX, CY, RING_RADIUS + 30 + pulseSize);
      grad.addColorStop(0, 'rgba(255, 136, 0, 0.15)');
      grad.addColorStop(0.5, 'rgba(255, 136, 0, 0.08)');
      grad.addColorStop(1, 'rgba(255, 136, 0, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(CX, CY, RING_RADIUS + 30 + pulseSize, 0, Math.PI * 2);
      ctx.fill();

      // Ring floor
      const ringGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, RING_RADIUS);
      ringGrad.addColorStop(0, '#3a3020');
      ringGrad.addColorStop(0.7, '#2e2818');
      ringGrad.addColorStop(1, '#252010');
      ctx.fillStyle = ringGrad;
      ctx.beginPath();
      ctx.arc(CX, CY, RING_RADIUS, 0, Math.PI * 2);
      ctx.fill();

      // Ring border (tawara rope)
      ctx.strokeStyle = '#f80';
      ctx.lineWidth = 4;
      ctx.shadowColor = 'rgba(255, 136, 0, 0.6)';
      ctx.shadowBlur = 12 + pulseSize;
      ctx.beginPath();
      ctx.arc(CX, CY, RING_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Inner ring
      ctx.strokeStyle = 'rgba(255, 136, 0, 0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(CX, CY, RING_RADIUS - 8, 0, Math.PI * 2);
      ctx.stroke();

      // Edge danger zone
      ctx.strokeStyle = 'rgba(255, 50, 50, 0.08)';
      ctx.lineWidth = RING_EDGE_ZONE;
      ctx.beginPath();
      ctx.arc(CX, CY, RING_RADIUS - RING_EDGE_ZONE / 2, 0, Math.PI * 2);
      ctx.stroke();

      // Center cross
      ctx.strokeStyle = 'rgba(255, 136, 0, 0.08)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(CX - 30, CY); ctx.lineTo(CX + 30, CY);
      ctx.moveTo(CX, CY - 30); ctx.lineTo(CX, CY + 30);
      ctx.stroke();
    }

    function darkenColor(hex, factor) {
      let r, g, b;
      if (hex.length === 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
      } else {
        r = parseInt(hex.slice(1, 3), 16);
        g = parseInt(hex.slice(3, 5), 16);
        b = parseInt(hex.slice(5, 7), 16);
      }
      return 'rgb(' + Math.floor(r * factor) + ',' + Math.floor(g * factor) + ',' + Math.floor(b * factor) + ')';
    }

    function drawWrestler(w, isPlayer) {
      ctx.save();

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(w.x + 3, w.y + 5, w.radius * 0.9, w.radius * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Dodge transparency
      if (w.isDodging) ctx.globalAlpha = 0.4;

      // Charge glow
      if (w.isCharging && w.charge > 10) {
        const chargeGlow = ctx.createRadialGradient(w.x, w.y, w.radius * 0.5, w.x, w.y, w.radius * 2);
        chargeGlow.addColorStop(0, w.colorGlow);
        chargeGlow.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = chargeGlow;
        ctx.beginPath();
        ctx.arc(w.x, w.y, w.radius * 2 * (w.charge / MAX_CHARGE), 0, Math.PI * 2);
        ctx.fill();
      }

      // Body
      const bodyColor = w.flashTimer > 0 ? '#fff' : w.color;
      const bodyGrad = ctx.createRadialGradient(w.x - 5, w.y - 5, 2, w.x, w.y, w.radius);
      bodyGrad.addColorStop(0, '#fff');
      bodyGrad.addColorStop(0.3, bodyColor);
      bodyGrad.addColorStop(1, darkenColor(w.color, 0.5));
      ctx.fillStyle = bodyGrad;
      ctx.shadowColor = w.colorGlow;
      ctx.shadowBlur = w.isCharging ? 15 + w.charge * 0.1 : 8;
      ctx.beginPath();
      ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner body circle (belly)
      ctx.fillStyle = bodyColor;
      ctx.globalAlpha = w.isDodging ? 0.3 : 0.6;
      ctx.beginPath();
      ctx.arc(w.x, w.y, w.radius * 0.55, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = w.isDodging ? 0.4 : 1;

      // Belt (mawashi)
      const opponent = isPlayer ? ai : player;
      const facing = Math.atan2(opponent.y - w.y, opponent.x - w.x);
      ctx.strokeStyle = w.isCharging ? '#ff0' : (isPlayer ? '#2266cc' : '#cc6600');
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(w.x, w.y, w.radius * 0.7, facing - 1.2, facing + 1.2);
      ctx.stroke();

      // Eyes
      const eyeDist = w.radius * 0.35;
      const eyeSize = 3;
      const ex1 = w.x + Math.cos(facing - 0.3) * eyeDist;
      const ey1 = w.y + Math.sin(facing - 0.3) * eyeDist;
      const ex2 = w.x + Math.cos(facing + 0.3) * eyeDist;
      const ey2 = w.y + Math.sin(facing + 0.3) * eyeDist;
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(ex1, ey1, eyeSize, 0, Math.PI * 2);
      ctx.arc(ex2, ey2, eyeSize, 0, Math.PI * 2);
      ctx.fill();

      // Angry eyebrows when charging
      if (w.isCharging) {
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ex1 - 4, ey1 - 5);
        ctx.lineTo(ex1 + 4, ey1 - 3);
        ctx.moveTo(ex2 - 4, ey2 - 3);
        ctx.lineTo(ex2 + 4, ey2 - 5);
        ctx.stroke();
      }

      // Stun stars
      if (w.stunTimer > 0) {
        const starT = Date.now() * 0.005;
        ctx.fillStyle = '#ff0';
        ctx.font = '12px Courier New';
        for (let i = 0; i < 3; i++) {
          const angle = starT + (i * Math.PI * 2 / 3);
          const sx = w.x + Math.cos(angle) * (w.radius + 8);
          const sy = w.y - w.radius * 0.5 + Math.sin(angle) * 5;
          ctx.fillText('*', sx - 3, sy + 3);
        }
      }

      ctx.globalAlpha = 1;

      // Stamina bar
      const barW = w.radius * 2;
      const barH = 4;
      const barX = w.x - barW / 2;
      const barY = w.y - w.radius - 14;
      ctx.fillStyle = '#222';
      ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, barH);
      const staminaRatio = w.stamina / MAX_STAMINA;
      const staminaColor = staminaRatio > 0.5 ? '#0c0' : (staminaRatio > 0.25 ? '#ff0' : '#f00');
      ctx.fillStyle = staminaColor;
      ctx.fillRect(barX, barY, barW * staminaRatio, barH);

      // Charge bar
      if (w.charge > 0) {
        const cBarY = barY - 7;
        ctx.fillStyle = '#222';
        ctx.fillRect(barX - 1, cBarY - 1, barW + 2, barH + 2);
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, cBarY, barW, barH);
        ctx.fillStyle = '#f80';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 4;
        ctx.fillRect(barX, cBarY, barW * (w.charge / MAX_CHARGE), barH);
        ctx.shadowBlur = 0;
      }

      // Label
      ctx.fillStyle = '#888';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(isPlayer ? 'YOU' : 'CPU', w.x, w.y + w.radius + 16);

      ctx.restore();
    }

    function drawPushIndicator(w) {
      if (w.isPushing) {
        const px = w.x + w.pushDirX * w.radius * 1.8;
        const py = w.y + w.pushDirY * w.radius * 1.8;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(w.x + w.pushDirX * w.radius, w.y + w.pushDirY * w.radius);
        ctx.lineTo(px, py);
        ctx.stroke();
        // Arrowhead
        const aSize = 8;
        const aAngle = Math.atan2(w.pushDirY, w.pushDirX);
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px - Math.cos(aAngle - 0.4) * aSize, py - Math.sin(aAngle - 0.4) * aSize);
        ctx.moveTo(px, py);
        ctx.lineTo(px - Math.cos(aAngle + 0.4) * aSize, py - Math.sin(aAngle + 0.4) * aSize);
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    function drawParticles() {
      for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function drawHUD() {
      // Round countdown
      if (roundState === 'ready') {
        ctx.fillStyle = '#f80';
        ctx.font = 'bold 24px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#f80';
        ctx.shadowBlur = 15;
        ctx.fillText(roundMessage, CX, CY - 70);
        if (roundTimer < 40) {
          const scale = 1 + (40 - roundTimer) * 0.02;
          ctx.font = 'bold ' + Math.floor(42 * scale) + 'px Courier New';
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#fff';
          ctx.fillText('FIGHT!', CX, CY + 10);
        }
        ctx.shadowBlur = 0;
      }

      // Round end message
      if (roundState === 'roundEnd') {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 15;
        ctx.fillText(roundMessage, CX, 55);
        ctx.font = '16px Courier New';
        ctx.fillStyle = '#aaa';
        ctx.shadowBlur = 0;
        ctx.fillText(playerWins + ' - ' + aiWins, CX, 80);
      }

      // Win dots
      const dotY = 16;
      const dotSpacing = 16;
      const dotBaseX = CX;
      for (let i = 0; i < 3; i++) {
        // Player dots (left)
        ctx.beginPath();
        ctx.arc(dotBaseX - 50 + i * dotSpacing, dotY, 5, 0, Math.PI * 2);
        ctx.fillStyle = i < playerWins ? '#4488ff' : '#333';
        if (i < playerWins) { ctx.shadowColor = '#4488ff'; ctx.shadowBlur = 6; }
        ctx.fill();
        ctx.shadowBlur = 0;

        // AI dots (right)
        ctx.beginPath();
        ctx.arc(dotBaseX + 20 + i * dotSpacing, dotY, 5, 0, Math.PI * 2);
        ctx.fillStyle = i < aiWins ? '#f80' : '#333';
        if (i < aiWins) { ctx.shadowColor = '#f80'; ctx.shadowBlur = 6; }
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // VS
      ctx.fillStyle = '#555';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('VS', dotBaseX - 10, dotY + 3);
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Subtle radial bg
      const bgGrad = ctx.createRadialGradient(CX, CY, RING_RADIUS, CX, CY, W * 0.7);
      bgGrad.addColorStop(0, 'rgba(255,136,0,0.03)');
      bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      drawRing();
      drawParticles();

      if (roundState !== 'matchEnd') {
        drawPushIndicator(player);
        drawPushIndicator(ai);
        // Draw the one further from viewer on top? Just draw AI then player
        drawWrestler(ai, false);
        drawWrestler(player, true);
      }

      drawHUD();
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Expose game data
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        gameState,
        score,
        playerWins,
        aiWins,
        currentRound,
        roundState
      };
    }

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

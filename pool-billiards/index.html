<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pool / Billiards</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #0a6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(0, 170, 102, 0.5); }
    h1 { color: #0a6; font-size: 1.8rem; text-shadow: 0 0 15px rgba(0, 170, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #0a6; }
    canvas {
      border: 2px solid #0a6;
      box-shadow: 0 0 20px rgba(0, 170, 102, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #0a6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(0,170,102,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; white-space: pre-line; }
    .ball-rack {
      display: flex;
      gap: 4px;
      margin-top: 8px;
      width: 600px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .ball-indicator {
      width: 20px; height: 20px;
      border-radius: 50%;
      border: 1px solid #555;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: bold;
      color: #fff;
    }
    .ball-indicator.pocketed { opacity: 0.2; }
    .turn-info {
      width: 600px;
      text-align: center;
      margin-top: 8px;
      font-size: 0.9rem;
      color: #aaa;
      min-height: 20px;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>POOL / BILLIARDS</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="turnLabel" style="color:#0a6;">8-BALL</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">8-BALL POOL</h2>
      <p id="overlayText">Click to break</p>
    </div>
  </div>
  <div class="turn-info" id="turnInfo"></div>
  <div class="ball-rack" id="ballRack"></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const turnLabel = document.getElementById('turnLabel');
    const turnInfo = document.getElementById('turnInfo');
    const ballRackEl = document.getElementById('ballRack');

    let gameState = 'waiting';
    let score = 0;

    // Table geometry
    const TABLE_LEFT = 50, TABLE_TOP = 50;
    const TABLE_W = 500, TABLE_H = 300;
    const TABLE_RIGHT = TABLE_LEFT + TABLE_W;
    const TABLE_BOTTOM = TABLE_TOP + TABLE_H;
    const RAIL = 18;
    const PLAY_LEFT = TABLE_LEFT + RAIL;
    const PLAY_TOP = TABLE_TOP + RAIL;
    const PLAY_RIGHT = TABLE_RIGHT - RAIL;
    const PLAY_BOTTOM = TABLE_BOTTOM - RAIL;
    const PLAY_W = PLAY_RIGHT - PLAY_LEFT;
    const PLAY_H = PLAY_BOTTOM - PLAY_TOP;

    const BALL_R = 8;
    const POCKET_R = 15;
    const FRICTION = 0.986;
    const MIN_VEL = 0.06;
    const MAX_POWER = 18;

    // Pocket positions (corners + side midpoints)
    const pockets = [
      { x: PLAY_LEFT + 1, y: PLAY_TOP + 1 },
      { x: (PLAY_LEFT + PLAY_RIGHT) / 2, y: PLAY_TOP - 3 },
      { x: PLAY_RIGHT - 1, y: PLAY_TOP + 1 },
      { x: PLAY_LEFT + 1, y: PLAY_BOTTOM - 1 },
      { x: (PLAY_LEFT + PLAY_RIGHT) / 2, y: PLAY_BOTTOM + 3 },
      { x: PLAY_RIGHT - 1, y: PLAY_BOTTOM - 1 }
    ];

    // Standard ball colors
    const BALL_COLORS = {
      0: '#ffffff',
      1: '#f5d742', 2: '#2255cc', 3: '#dd2222', 4: '#8822bb',
      5: '#ff6600', 6: '#118833', 7: '#882222', 8: '#111111',
      9: '#f5d742', 10: '#2255cc', 11: '#dd2222', 12: '#8822bb',
      13: '#ff6600', 14: '#118833', 15: '#882222'
    };

    let balls = [];
    let cueBall = null;
    let currentPlayer = 1; // 1=human, 2=AI
    let player1Type = null; // 'solids' | 'stripes' | null
    let player2Type = null;
    let player1Score = 0;
    let player2Score = 0;
    let pocketedThisTurn = [];
    let scratchThisTurn = false;
    let ballInHand = false;
    let aiming = false;
    let aimStart = { x: 0, y: 0 };
    let mousePos = { x: 300, y: 200 };
    let shotInProgress = false;
    let firstBallHit = null;
    let foulThisTurn = false;
    let gameOverReason = '';
    let aiThinking = false;
    let breakShot = true;
    let messageTimer = 0;
    let messageText = '';

    function createBall(num, x, y) {
      return {
        num, x, y,
        vx: 0, vy: 0,
        active: true,
        isStripe: num >= 9 && num <= 15,
        isSolid: num >= 1 && num <= 7,
        is8Ball: num === 8,
        isCue: num === 0
      };
    }

    function rackBalls() {
      balls = [];
      const cx = PLAY_LEFT + PLAY_W * 0.73;
      const cy = PLAY_TOP + PLAY_H / 2;
      const d = BALL_R * 2 + 0.8;

      // Standard 8-ball rack: 8 in center, solid+stripe on back corners
      const rackOrder = [1, 9, 2, 10, 8, 3, 11, 14, 6, 13, 4, 12, 7, 15, 5];
      let idx = 0;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col <= row; col++) {
          const bx = cx + row * d * 0.866; // cos(30deg)
          const by = cy + (col - row / 2) * d;
          balls.push(createBall(rackOrder[idx], bx, by));
          idx++;
        }
      }

      cueBall = createBall(0, PLAY_LEFT + PLAY_W * 0.25, cy);
      balls.push(cueBall);
    }

    function init() {
      rackBalls();
      currentPlayer = 1;
      player1Type = null;
      player2Type = null;
      player1Score = 0;
      player2Score = 0;
      score = 0;
      ballInHand = false;
      aiming = false;
      shotInProgress = false;
      firstBallHit = null;
      foulThisTurn = false;
      pocketedThisTurn = [];
      scratchThisTurn = false;
      gameOverReason = '';
      aiThinking = false;
      breakShot = true;
      messageTimer = 0;
      messageText = '';
      gameState = 'waiting';
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      turnLabel.textContent = '8-BALL';
      updateTurnInfo();
      updateBallRack();
      overlay.style.display = 'flex';
      overlayTitle.textContent = '8-BALL POOL';
      overlayText.textContent = 'Click to break';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      updateTurnInfo();
      draw();
    }

    function showMessage(msg, duration) {
      messageText = msg;
      messageTimer = duration || 90;
    }

    function updateTurnInfo() {
      if (gameState !== 'playing') { turnInfo.textContent = ''; return; }
      const p = currentPlayer === 1 ? 'YOUR' : "CPU's";
      const type = currentPlayer === 1 ? player1Type : player2Type;
      let typeStr = '';
      if (type === 'solids') typeStr = ' [Solids 1-7]';
      else if (type === 'stripes') typeStr = ' [Stripes 9-15]';
      else typeStr = ' [Open Table]';

      if (ballInHand && currentPlayer === 1) {
        turnInfo.textContent = p + ' TURN' + typeStr + ' -- Click to place cue ball';
      } else {
        turnInfo.textContent = p + ' TURN' + typeStr;
      }
      turnLabel.textContent = currentPlayer === 1 ? 'YOUR TURN' : 'CPU TURN';
      turnLabel.style.color = currentPlayer === 1 ? '#0a6' : '#f66';
    }

    function updateBallRack() {
      let html = '';
      for (let i = 1; i <= 15; i++) {
        const b = balls.find(b => b.num === i);
        const pocketed = !b || !b.active;
        const col = BALL_COLORS[i];
        const isStripe = i >= 9;
        let style = '';
        if (pocketed) {
          style = 'background:#333;';
        } else if (isStripe) {
          style = `background: linear-gradient(180deg, ${col} 20%, #fff 20%, #fff 80%, ${col} 80%);`;
        } else {
          style = `background:${col};`;
        }
        html += `<div class="ball-indicator${pocketed ? ' pocketed' : ''}" style="${style}">${i}</div>`;
      }
      ballRackEl.innerHTML = html;
    }

    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function activeBallsOfType(type) {
      return balls.filter(b => b.active && !b.isCue && (type === 'solids' ? b.isSolid : b.isStripe));
    }

    function allStopped() {
      return balls.every(b => !b.active || (Math.abs(b.vx) < MIN_VEL && Math.abs(b.vy) < MIN_VEL));
    }

    function inPocket(ball) {
      for (const p of pockets) {
        if (dist(ball, p) < POCKET_R) return true;
      }
      return false;
    }

    // --- Physics ---
    function physics() {
      let moving = false;
      const substeps = 2;

      for (let step = 0; step < substeps; step++) {
        for (const b of balls) {
          if (!b.active) continue;
          if (Math.abs(b.vx) < MIN_VEL && Math.abs(b.vy) < MIN_VEL) {
            b.vx = 0; b.vy = 0; continue;
          }
          moving = true;

          b.x += b.vx / substeps;
          b.y += b.vy / substeps;
          b.vx *= Math.pow(FRICTION, 1 / substeps);
          b.vy *= Math.pow(FRICTION, 1 / substeps);

          // Cushion bounce
          if (b.x - BALL_R < PLAY_LEFT) {
            b.x = PLAY_LEFT + BALL_R;
            b.vx = Math.abs(b.vx) * 0.78;
          }
          if (b.x + BALL_R > PLAY_RIGHT) {
            b.x = PLAY_RIGHT - BALL_R;
            b.vx = -Math.abs(b.vx) * 0.78;
          }
          if (b.y - BALL_R < PLAY_TOP) {
            b.y = PLAY_TOP + BALL_R;
            b.vy = Math.abs(b.vy) * 0.78;
          }
          if (b.y + BALL_R > PLAY_BOTTOM) {
            b.y = PLAY_BOTTOM - BALL_R;
            b.vy = -Math.abs(b.vy) * 0.78;
          }

          // Pocket detection
          if (inPocket(b)) {
            b.active = false;
            b.vx = 0; b.vy = 0;
            if (b.isCue) {
              scratchThisTurn = true;
            } else {
              pocketedThisTurn.push(b.num);
            }
          }
        }

        // Ball-ball collisions
        for (let i = 0; i < balls.length; i++) {
          if (!balls[i].active) continue;
          for (let j = i + 1; j < balls.length; j++) {
            if (!balls[j].active) continue;
            const a = balls[i], b = balls[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const d2 = dx * dx + dy * dy;
            const minD = BALL_R * 2;
            if (d2 < minD * minD && d2 > 0.01) {
              const d = Math.sqrt(d2);

              // Track first hit
              if (firstBallHit === null) {
                if (a.isCue && !b.isCue) firstBallHit = b.num;
                else if (b.isCue && !a.isCue) firstBallHit = a.num;
              }

              const nx = dx / d, ny = dy / d;
              const overlap = minD - d;
              a.x -= nx * overlap / 2;
              a.y -= ny * overlap / 2;
              b.x += nx * overlap / 2;
              b.y += ny * overlap / 2;

              const dvx = a.vx - b.vx;
              const dvy = a.vy - b.vy;
              const dot = dvx * nx + dvy * ny;
              if (dot > 0) {
                a.vx -= dot * nx * 0.96;
                a.vy -= dot * ny * 0.96;
                b.vx += dot * nx * 0.96;
                b.vy += dot * ny * 0.96;
              }
            }
          }
        }
      }

      return moving;
    }

    // --- Turn Result ---
    function processTurnResult() {
      shotInProgress = false;

      let switchPlayer = false;
      let gameOver = false;
      const pType = currentPlayer === 1 ? player1Type : player2Type;

      // Scratch foul
      if (scratchThisTurn) {
        foulThisTurn = true;
        showMessage('SCRATCH!', 120);
        cueBall.active = true;
        cueBall.vx = 0; cueBall.vy = 0;
      }

      // 8-ball pocketed?
      if (pocketedThisTurn.includes(8)) {
        gameOver = true;
        const shooterType = currentPlayer === 1 ? player1Type : player2Type;

        // On break, pocketing 8-ball means re-rack (we'll treat as loss for simplicity)
        if (breakShot) {
          if (currentPlayer === 1) {
            gameOverReason = '8-ball pocketed on break! CPU wins!';
          } else {
            gameOverReason = '8-ball pocketed on break! You win!';
          }
        } else {
          const remaining = shooterType ? activeBallsOfType(shooterType).length : 99;
          if (remaining > 0 || scratchThisTurn) {
            if (currentPlayer === 1) gameOverReason = '8-ball pocketed too early! CPU wins!';
            else gameOverReason = '8-ball pocketed too early! You win!';
          } else {
            if (currentPlayer === 1) {
              gameOverReason = 'You sank the 8-ball! You win!';
              player1Score += 5;
            } else {
              gameOverReason = 'CPU sank the 8-ball! CPU wins!';
              player2Score += 5;
            }
          }
        }
      }

      if (!gameOver) {
        // Assign suits after break, on first legal pocket
        if (!player1Type && !breakShot && pocketedThisTurn.length > 0) {
          const first = pocketedThisTurn.find(n => n !== 8);
          if (first !== undefined) {
            if (first >= 1 && first <= 7) {
              if (currentPlayer === 1) { player1Type = 'solids'; player2Type = 'stripes'; }
              else { player2Type = 'solids'; player1Type = 'stripes'; }
            } else {
              if (currentPlayer === 1) { player1Type = 'stripes'; player2Type = 'solids'; }
              else { player2Type = 'stripes'; player1Type = 'solids'; }
            }
            showMessage(currentPlayer === 1 ?
              'You are ' + player1Type.toUpperCase() + '!' :
              'CPU is ' + player2Type.toUpperCase() + '!', 120);
          }
        }

        // Score
        for (const num of pocketedThisTurn) {
          if (num === 8) continue;
          if (currentPlayer === 1) player1Score++;
          else player2Score++;
        }

        // Decide turn switch
        if (foulThisTurn) {
          switchPlayer = true;
        } else if (breakShot) {
          // Break: continue if you pocketed something, otherwise switch
          switchPlayer = (pocketedThisTurn.length === 0);
        } else if (pocketedThisTurn.length === 0) {
          switchPlayer = true;
        } else if (pType) {
          // Only keep turn if at least one correct ball pocketed
          const hitOwn = pocketedThisTurn.some(n => {
            if (pType === 'solids') return n >= 1 && n <= 7;
            return n >= 9 && n <= 15;
          });
          if (!hitOwn) switchPlayer = true;
        }
        // If open table and pocketed something (non-break), keep turn
      }

      breakShot = false;

      score = player1Score;
      scoreEl.textContent = player1Score;
      bestEl.textContent = player2Score;

      if (gameOver) {
        endGame();
        return;
      }

      if (switchPlayer) {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        if (foulThisTurn) {
          ballInHand = true;
        }
      }

      pocketedThisTurn = [];
      scratchThisTurn = false;
      firstBallHit = null;
      foulThisTurn = false;

      updateTurnInfo();
      updateBallRack();

      if (currentPlayer === 2 && gameState === 'playing') {
        aiThinking = true;
        setTimeout(doAITurn, 700);
      }
    }

    function endGame() {
      gameState = 'over';
      overlay.style.display = 'flex';
      const won = gameOverReason.toLowerCase().includes('you win');
      overlayTitle.textContent = won ? 'YOU WIN!' : 'GAME OVER';
      overlayText.textContent = gameOverReason + '\nClick to play again';
      score = player1Score;
      scoreEl.textContent = player1Score;
      bestEl.textContent = player2Score;
      updateBallRack();
    }

    // --- AI ---
    function getValidTargets() {
      const aiType = player2Type;
      return balls.filter(b => {
        if (!b.active || b.isCue) return false;
        if (!aiType) return !b.is8Ball;
        if (aiType === 'solids') {
          return activeBallsOfType('solids').length === 0 ? b.is8Ball : b.isSolid;
        } else {
          return activeBallsOfType('stripes').length === 0 ? b.is8Ball : b.isStripe;
        }
      });
    }

    function isPathClear(x1, y1, x2, y2, excludeNums) {
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len < 1) return true;
      const nx = dx / len, ny = dy / len;
      for (const b of balls) {
        if (!b.active || excludeNums.includes(b.num)) continue;
        const t = Math.max(0, Math.min(len, (b.x - x1) * nx + (b.y - y1) * ny));
        const cx = x1 + nx * t, cy = y1 + ny * t;
        if (dist(b, { x: cx, y: cy }) < BALL_R * 2.1) return false;
      }
      return true;
    }

    function findBestAIShot() {
      const targets = getValidTargets();
      let best = null, bestScore = -Infinity;

      for (const target of targets) {
        for (const pocket of pockets) {
          const dx = target.x - pocket.x;
          const dy = target.y - pocket.y;
          const pDist = Math.sqrt(dx * dx + dy * dy);
          if (pDist < 1) continue;

          // Ghost ball: where cue must contact to send target toward pocket
          const ghostX = target.x + (dx / pDist) * BALL_R * 2;
          const ghostY = target.y + (dy / pDist) * BALL_R * 2;

          // Check ghost ball is on the playing surface
          if (ghostX < PLAY_LEFT + BALL_R || ghostX > PLAY_RIGHT - BALL_R) continue;
          if (ghostY < PLAY_TOP + BALL_R || ghostY > PLAY_BOTTOM - BALL_R) continue;

          // Path checks
          if (!isPathClear(cueBall.x, cueBall.y, ghostX, ghostY, [0, target.num])) continue;
          if (!isPathClear(target.x, target.y, pocket.x, pocket.y, [target.num, 0])) continue;

          const shotDx = ghostX - cueBall.x;
          const shotDy = ghostY - cueBall.y;
          const shotDist = Math.sqrt(shotDx * shotDx + shotDy * shotDy);

          // Cut angle penalty
          const aimAngle = Math.atan2(shotDy, shotDx);
          const pocketAngle = Math.atan2(pocket.y - target.y, pocket.x - target.x);
          const incidence = Math.atan2(target.y - ghostY, target.x - ghostX);
          let cutAngle = Math.abs(incidence - pocketAngle);
          if (cutAngle > Math.PI) cutAngle = 2 * Math.PI - cutAngle;

          let shotScore = 100;
          shotScore -= shotDist * 0.08;
          shotScore -= pDist * 0.1;
          shotScore -= cutAngle * 25;
          if (cutAngle < 0.25) shotScore += 15;
          if (shotDist > 350) shotScore -= 20;

          // Add slight randomness for variety
          shotScore += (Math.random() - 0.5) * 8;

          if (shotScore > bestScore) {
            bestScore = shotScore;
            const power = Math.min(MAX_POWER * 0.85, Math.max(4, shotDist * 0.03 + pDist * 0.02 + 4));
            best = {
              angle: Math.atan2(shotDy, shotDx),
              power: power + (Math.random() - 0.5) * 1.5, // slight power variance
              target, pocket, ghostX, ghostY
            };
          }
        }
      }
      return best;
    }

    function doAITurn() {
      if (gameState !== 'playing') return;

      // Ball-in-hand placement
      if (ballInHand) {
        let bestPos = null, bestEval = -Infinity;
        for (let i = 0; i < 50; i++) {
          const tx = PLAY_LEFT + BALL_R + Math.random() * (PLAY_W - BALL_R * 2);
          const ty = PLAY_TOP + BALL_R + Math.random() * (PLAY_H - BALL_R * 2);
          let overlap = false;
          for (const b of balls) {
            if (!b.active || b.isCue) continue;
            if (dist({ x: tx, y: ty }, b) < BALL_R * 2.5) { overlap = true; break; }
          }
          if (overlap) continue;

          // Evaluate: can we make a shot from here?
          const oldX = cueBall.x, oldY = cueBall.y;
          cueBall.x = tx; cueBall.y = ty;
          const testShot = findBestAIShot();
          cueBall.x = oldX; cueBall.y = oldY;

          const ev = testShot ? 50 + (100 - Math.abs(testShot.power - 8) * 2) : 0;
          if (ev > bestEval) { bestEval = ev; bestPos = { x: tx, y: ty }; }
        }
        if (bestPos) {
          cueBall.x = bestPos.x; cueBall.y = bestPos.y;
        } else {
          cueBall.x = PLAY_LEFT + PLAY_W * 0.25;
          cueBall.y = PLAY_TOP + PLAY_H / 2;
        }
        cueBall.active = true;
        ballInHand = false;
      }

      const shot = findBestAIShot();
      const delay = 500 + Math.random() * 400;

      if (shot) {
        setTimeout(() => {
          if (gameState !== 'playing') return;
          cueBall.vx = Math.cos(shot.angle) * shot.power;
          cueBall.vy = Math.sin(shot.angle) * shot.power;
          shotInProgress = true;
          firstBallHit = null;
          pocketedThisTurn = [];
          scratchThisTurn = false;
          foulThisTurn = false;
          aiThinking = false;
        }, delay);
      } else {
        // No clear shot - safety/random
        const targets = getValidTargets();
        setTimeout(() => {
          if (gameState !== 'playing') return;
          let angle, power;
          if (targets.length > 0) {
            const t = targets[Math.floor(Math.random() * targets.length)];
            angle = Math.atan2(t.y - cueBall.y, t.x - cueBall.x);
            power = 4 + Math.random() * 4;
          } else {
            angle = Math.random() * Math.PI * 2;
            power = 4 + Math.random() * 4;
          }
          cueBall.vx = Math.cos(angle) * power;
          cueBall.vy = Math.sin(angle) * power;
          shotInProgress = true;
          firstBallHit = null;
          pocketedThisTurn = [];
          scratchThisTurn = false;
          foulThisTurn = false;
          aiThinking = false;
        }, delay);
      }
    }

    // --- Drawing ---
    function drawTable() {
      // Outer border (wood)
      ctx.fillStyle = '#4a2808';
      const bdr = 12;
      ctx.fillRect(TABLE_LEFT - bdr, TABLE_TOP - bdr, TABLE_W + bdr * 2, TABLE_H + bdr * 2);

      // Wood grain
      ctx.fillStyle = '#5c3410';
      ctx.fillRect(TABLE_LEFT - bdr + 2, TABLE_TOP - bdr + 2, TABLE_W + bdr * 2 - 4, TABLE_H + bdr * 2 - 4);

      // Inner wood bevel
      ctx.fillStyle = '#6b3d15';
      ctx.fillRect(TABLE_LEFT - 2, TABLE_TOP - 2, TABLE_W + 4, TABLE_H + 4);

      // Rail surface
      ctx.fillStyle = '#0a5535';
      ctx.fillRect(TABLE_LEFT, TABLE_TOP, TABLE_W, TABLE_H);

      // Playing felt
      ctx.fillStyle = '#0c8855';
      ctx.fillRect(PLAY_LEFT, PLAY_TOP, PLAY_W, PLAY_H);

      // Subtle felt texture
      ctx.save();
      ctx.globalAlpha = 0.04;
      for (let i = 0; i < 300; i++) {
        ctx.fillStyle = Math.random() > 0.5 ? '#000' : '#fff';
        ctx.fillRect(
          PLAY_LEFT + Math.random() * PLAY_W,
          PLAY_TOP + Math.random() * PLAY_H, 1, 1
        );
      }
      ctx.restore();

      // Head string
      const headX = PLAY_LEFT + PLAY_W * 0.25;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 5]);
      ctx.beginPath();
      ctx.moveTo(headX, PLAY_TOP);
      ctx.lineTo(headX, PLAY_BOTTOM);
      ctx.stroke();
      ctx.setLineDash([]);

      // Foot spot
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.beginPath();
      ctx.arc(PLAY_LEFT + PLAY_W * 0.73, PLAY_TOP + PLAY_H / 2, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // Pockets
      for (const p of pockets) {
        // Pocket hole
        ctx.save();
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#0a0a0a';
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Pocket rim
        ctx.strokeStyle = '#3a2010';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_R + 1, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Cushion edge glow
      ctx.strokeStyle = '#0a7040';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(PLAY_LEFT, PLAY_TOP, PLAY_W, PLAY_H);

      // Diamond sights
      ctx.fillStyle = '#c8a050';
      for (let i = 1; i <= 3; i++) {
        const dx = PLAY_LEFT + (PLAY_W / 4) * i;
        drawDiamond(dx, TABLE_TOP + RAIL / 2, 2.5);
        drawDiamond(dx, TABLE_BOTTOM - RAIL / 2, 2.5);
      }
      for (let i = 1; i <= 2; i++) {
        const dy = PLAY_TOP + (PLAY_H / 3) * i;
        drawDiamond(TABLE_LEFT + RAIL / 2, dy, 2.5);
        drawDiamond(TABLE_RIGHT - RAIL / 2, dy, 2.5);
      }
    }

    function drawDiamond(x, y, s) {
      ctx.beginPath();
      ctx.moveTo(x, y - s); ctx.lineTo(x + s, y);
      ctx.lineTo(x, y + s); ctx.lineTo(x - s, y);
      ctx.closePath(); ctx.fill();
    }

    function lighten(hex, amt) {
      let r = parseInt(hex.slice(1, 3), 16) + amt;
      let g = parseInt(hex.slice(3, 5), 16) + amt;
      let b = parseInt(hex.slice(5, 7), 16) + amt;
      r = Math.min(255, Math.max(0, r));
      g = Math.min(255, Math.max(0, g));
      b = Math.min(255, Math.max(0, b));
      return `rgb(${r},${g},${b})`;
    }

    function drawBall(ball) {
      if (!ball.active) return;
      const { x, y, num } = ball;
      const color = BALL_COLORS[num];

      ctx.save();

      // Drop shadow
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 5;
      ctx.shadowOffsetX = 1.5;
      ctx.shadowOffsetY = 1.5;

      if (ball.isCue) {
        // White cue ball
        const g = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        g.addColorStop(0, '#fff');
        g.addColorStop(1, '#ccc');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      } else if (ball.is8Ball) {
        const g = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        g.addColorStop(0, '#444');
        g.addColorStop(1, '#000');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      } else if (ball.isStripe) {
        // White base
        const g = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        g.addColorStop(0, '#fff');
        g.addColorStop(1, '#ddd');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();

        // Colored band
        ctx.save();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R - 0.5, 0, Math.PI * 2);
        ctx.clip();
        ctx.fillStyle = color;
        const bw = BALL_R * 1.1;
        ctx.fillRect(x - BALL_R, y - bw / 2, BALL_R * 2, bw);
        ctx.restore();
      } else {
        // Solid
        const g = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        g.addColorStop(0, lighten(color, 50));
        g.addColorStop(1, color);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // Number circle (except cue)
      if (!ball.isCue) {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, BALL_R * 0.42, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#111';
        ctx.font = `bold ${BALL_R * 0.65}px 'Courier New'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num + '', x, y + 0.3);
      }

      // Gloss highlight
      ctx.fillStyle = 'rgba(255,255,255,0.22)';
      ctx.beginPath();
      ctx.arc(x - BALL_R * 0.3, y - BALL_R * 0.3, BALL_R * 0.28, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawAimGuide() {
      if (!cueBall.active || shotInProgress || aiThinking || currentPlayer === 2 || ballInHand) return;

      const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);
      const dirX = Math.cos(angle), dirY = Math.sin(angle);

      // Find first ball hit
      let hitBall = null, hitDist = Infinity;
      for (const b of balls) {
        if (!b.active || b.isCue) continue;
        const ocx = b.x - cueBall.x, ocy = b.y - cueBall.y;
        const proj = ocx * dirX + ocy * dirY;
        if (proj < BALL_R) continue;
        const perpSq = (ocx * ocx + ocy * ocy) - proj * proj;
        const minD = BALL_R * 2;
        if (perpSq < minD * minD) {
          const t = proj - Math.sqrt(minD * minD - perpSq);
          if (t > 0 && t < hitDist) { hitDist = t; hitBall = b; }
        }
      }

      // Also check cushion hit distance
      let cushionDist = Infinity;
      // Right
      if (dirX > 0) cushionDist = Math.min(cushionDist, (PLAY_RIGHT - BALL_R - cueBall.x) / dirX);
      // Left
      if (dirX < 0) cushionDist = Math.min(cushionDist, (PLAY_LEFT + BALL_R - cueBall.x) / dirX);
      // Bottom
      if (dirY > 0) cushionDist = Math.min(cushionDist, (PLAY_BOTTOM - BALL_R - cueBall.y) / dirY);
      // Top
      if (dirY < 0) cushionDist = Math.min(cushionDist, (PLAY_TOP + BALL_R - cueBall.y) / dirY);

      const guideDist = hitBall ? hitDist : Math.min(cushionDist, 300);

      ctx.save();
      ctx.shadowColor = 'rgba(0,170,102,0.3)';
      ctx.shadowBlur = 4;

      // Aim line (dotted)
      ctx.strokeStyle = 'rgba(0,170,102,0.35)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(cueBall.x, cueBall.y);
      ctx.lineTo(cueBall.x + dirX * guideDist, cueBall.y + dirY * guideDist);
      ctx.stroke();
      ctx.setLineDash([]);

      if (hitBall) {
        const contactX = cueBall.x + dirX * hitDist;
        const contactY = cueBall.y + dirY * hitDist;

        // Ghost cue ball
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(contactX, contactY, BALL_R, 0, Math.PI * 2);
        ctx.stroke();

        // Predicted object ball path
        const hitAngle = Math.atan2(hitBall.y - contactY, hitBall.x - contactX);
        ctx.strokeStyle = 'rgba(255,200,50,0.35)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(hitBall.x, hitBall.y);
        ctx.lineTo(hitBall.x + Math.cos(hitAngle) * 100, hitBall.y + Math.sin(hitAngle) * 100);
        ctx.stroke();
        ctx.setLineDash([]);

        // Highlight target ball
        ctx.strokeStyle = 'rgba(0,170,102,0.3)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(hitBall.x, hitBall.y, BALL_R + 2, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawCueStick() {
      if (!cueBall.active || shotInProgress || aiThinking || currentPlayer === 2 || ballInHand) return;

      const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);
      let pullBack = 0;
      let power = 0;

      if (aiming) {
        const dx = aimStart.x - mousePos.x;
        const dy = aimStart.y - mousePos.y;
        const pullDist = Math.sqrt(dx * dx + dy * dy);
        power = Math.min(MAX_POWER, pullDist * 0.12);
        pullBack = Math.min(70, pullDist * 0.4);
      }

      const gapFromBall = BALL_R + 4 + pullBack;
      const stickLen = 150;
      const sx = cueBall.x - Math.cos(angle) * gapFromBall;
      const sy = cueBall.y - Math.sin(angle) * gapFromBall;
      const ex = sx - Math.cos(angle) * stickLen;
      const ey = sy - Math.sin(angle) * stickLen;

      // Shadow
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(sx + 2, sy + 2); ctx.lineTo(ex + 2, ey + 2);
      ctx.stroke();

      // Cue body (butt)
      ctx.strokeStyle = '#6b4020';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(sx - Math.cos(angle) * 50, sy - Math.sin(angle) * 50);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      // Cue shaft
      ctx.strokeStyle = '#c8a050';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - Math.cos(angle) * 50, sy - Math.sin(angle) * 50);
      ctx.stroke();

      // Ferrule (white tip area)
      ctx.strokeStyle = '#f0ece0';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + Math.cos(angle) * 4, sy + Math.sin(angle) * 4);
      ctx.stroke();

      // Tip
      ctx.fillStyle = '#4a90cc';
      ctx.beginPath();
      ctx.arc(sx + Math.cos(angle) * 2, sy + Math.sin(angle) * 2, 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Power meter
      if (aiming && power > 0) {
        const meterX = 18, meterY = TABLE_TOP + 5;
        const meterW = 10, meterH = TABLE_H - 10;
        const pct = power / MAX_POWER;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(meterX - 1, meterY - 1, meterW + 2, meterH + 2);
        ctx.fillStyle = '#222';
        ctx.fillRect(meterX, meterY, meterW, meterH);

        const pColor = pct < 0.4 ? '#0a6' : pct < 0.7 ? '#fa0' : '#f33';
        const fillH = meterH * pct;
        ctx.fillStyle = pColor;
        ctx.fillRect(meterX, meterY + meterH - fillH, meterW, fillH);

        // Glow
        ctx.save();
        ctx.shadowColor = pColor;
        ctx.shadowBlur = 8;
        ctx.fillRect(meterX, meterY + meterH - fillH, meterW, fillH);
        ctx.restore();

        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.strokeRect(meterX, meterY, meterW, meterH);

        ctx.fillStyle = '#888';
        ctx.font = '7px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PWR', meterX + meterW / 2, meterY - 3);
      }
    }

    function drawMessage() {
      if (messageTimer <= 0) return;
      messageTimer--;
      ctx.save();
      ctx.shadowColor = '#0a6';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#0a6';
      ctx.font = 'bold 18px Courier New';
      ctx.textAlign = 'center';
      ctx.globalAlpha = Math.min(1, messageTimer / 20);
      ctx.fillText(messageText, W / 2, TABLE_TOP - 18);
      ctx.restore();
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawTable();

      // Draw object balls
      for (const b of balls) {
        if (!b.isCue) drawBall(b);
      }
      // Draw cue ball on top
      if (cueBall.active) drawBall(cueBall);

      if (gameState === 'playing') {
        if (ballInHand && currentPlayer === 1 && !shotInProgress) {
          // Show ghost cue ball at mouse
          const mx = Math.max(PLAY_LEFT + BALL_R, Math.min(PLAY_RIGHT - BALL_R, mousePos.x));
          const my = Math.max(PLAY_TOP + BALL_R, Math.min(PLAY_BOTTOM - BALL_R, mousePos.y));
          ctx.save();
          ctx.globalAlpha = 0.4;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.arc(mx, my, BALL_R, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 0.2;
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(mx, my, BALL_R, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        } else {
          drawAimGuide();
          drawCueStick();
        }
      }

      // AI thinking
      if (aiThinking) {
        ctx.save();
        ctx.shadowColor = '#f66';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#f66';
        ctx.font = '13px Courier New';
        ctx.textAlign = 'center';
        const dots = '.'.repeat(Math.floor(Date.now() / 300) % 4);
        ctx.fillText('CPU thinking' + dots, W / 2, H - 8);
        ctx.restore();
      }

      drawMessage();

      // Player type indicators in corners
      if (player1Type) {
        ctx.save();
        ctx.font = '9px Courier New';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#0a6';
        ctx.shadowColor = '#0a6';
        ctx.shadowBlur = 4;
        const p1Rem = activeBallsOfType(player1Type).length;
        ctx.fillText('YOU: ' + player1Type.toUpperCase() + ' (' + p1Rem + ' left)', TABLE_LEFT, H - 8);
        ctx.textAlign = 'right';
        ctx.fillStyle = '#f66';
        ctx.shadowColor = '#f66';
        const p2Rem = activeBallsOfType(player2Type).length;
        ctx.fillText('CPU: ' + player2Type.toUpperCase() + ' (' + p2Rem + ' left)', TABLE_RIGHT, H - 8);
        ctx.restore();
      }
    }

    // --- Game Loop ---
    function gameLoop() {
      if (gameState === 'playing' && shotInProgress) {
        const moving = physics();
        if (!moving) {
          processTurnResult();
        }
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    // --- Input ---
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mousePos.x = (e.clientX - rect.left) * (W / rect.width);
      mousePos.y = (e.clientY - rect.top) * (H / rect.height);
    });

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
      if (gameState !== 'playing' || currentPlayer !== 1 || shotInProgress || aiThinking) return;

      // Ball-in-hand placement
      if (ballInHand) {
        const px = Math.max(PLAY_LEFT + BALL_R, Math.min(PLAY_RIGHT - BALL_R, mx));
        const py = Math.max(PLAY_TOP + BALL_R, Math.min(PLAY_BOTTOM - BALL_R, my));
        let ok = true;
        for (const b of balls) {
          if (!b.active || b.isCue) continue;
          if (dist({ x: px, y: py }, b) < BALL_R * 2.5) { ok = false; break; }
        }
        if (ok) {
          cueBall.x = px; cueBall.y = py;
          cueBall.active = true;
          ballInHand = false;
          updateTurnInfo();
        }
        return;
      }

      if (!cueBall.active) return;
      aiming = true;
      aimStart.x = mx;
      aimStart.y = my;
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!aiming || currentPlayer !== 1) { aiming = false; return; }

      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      const dx = aimStart.x - mx, dy = aimStart.y - my;
      const pullDist = Math.sqrt(dx * dx + dy * dy);
      const power = Math.min(MAX_POWER, pullDist * 0.12);

      aiming = false;
      if (power < 0.5) return;

      const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);
      cueBall.vx = Math.cos(angle) * power;
      cueBall.vy = Math.sin(angle) * power;

      shotInProgress = true;
      firstBallHit = null;
      pocketedThisTurn = [];
      scratchThisTurn = false;
      foulThisTurn = false;
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

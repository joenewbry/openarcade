<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pool / Billiards</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #0a6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(0, 170, 102, 0.5); }
    h1 { color: #0a6; font-size: 1.8rem; text-shadow: 0 0 15px rgba(0, 170, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #0a6; }
    canvas {
      border: 2px solid #0a6;
      box-shadow: 0 0 20px rgba(0, 170, 102, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #0a6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px rgba(0,170,102,0.5); }
    .overlay p { font-size: 1rem; color: #aaa; }
    .ball-rack {
      display: flex;
      gap: 4px;
      margin-top: 8px;
      width: 600px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .ball-indicator {
      width: 18px; height: 18px;
      border-radius: 50%;
      border: 1px solid #555;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      font-weight: bold;
      color: #fff;
    }
    .ball-indicator.pocketed { opacity: 0.25; }
    .turn-info {
      width: 600px;
      text-align: center;
      margin-top: 6px;
      font-size: 0.9rem;
      color: #aaa;
      min-height: 20px;
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>POOL / BILLIARDS</h1>
  </div>
  <div class="score-bar">
    <div>You: <span id="score">0</span></div>
    <div id="turnLabel" style="color:#0a6;">8-BALL</div>
    <div>CPU: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">8-BALL POOL</h2>
      <p id="overlayText">Click to start</p>
    </div>
  </div>
  <div class="turn-info" id="turnInfo"></div>
  <div class="ball-rack" id="ballRack"></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const turnLabel = document.getElementById('turnLabel');
    const turnInfo = document.getElementById('turnInfo');
    const ballRackEl = document.getElementById('ballRack');

    let gameState = 'waiting';
    let score = 0;

    // Table dimensions
    const TABLE_LEFT = 50, TABLE_TOP = 50;
    const TABLE_W = 500, TABLE_H = 300;
    const TABLE_RIGHT = TABLE_LEFT + TABLE_W;
    const TABLE_BOTTOM = TABLE_TOP + TABLE_H;
    const RAIL = 18;
    const PLAY_LEFT = TABLE_LEFT + RAIL;
    const PLAY_TOP = TABLE_TOP + RAIL;
    const PLAY_RIGHT = TABLE_RIGHT - RAIL;
    const PLAY_BOTTOM = TABLE_BOTTOM - RAIL;
    const PLAY_W = PLAY_RIGHT - PLAY_LEFT;
    const PLAY_H = PLAY_BOTTOM - PLAY_TOP;

    const BALL_R = 8;
    const POCKET_R = 14;
    const FRICTION = 0.985;
    const MIN_VEL = 0.08;
    const MAX_POWER = 18;

    // Pocket positions
    const pockets = [
      { x: PLAY_LEFT + 2, y: PLAY_TOP + 2 },
      { x: (PLAY_LEFT + PLAY_RIGHT) / 2, y: PLAY_TOP - 2 },
      { x: PLAY_RIGHT - 2, y: PLAY_TOP + 2 },
      { x: PLAY_LEFT + 2, y: PLAY_BOTTOM - 2 },
      { x: (PLAY_LEFT + PLAY_RIGHT) / 2, y: PLAY_BOTTOM + 2 },
      { x: PLAY_RIGHT - 2, y: PLAY_BOTTOM - 2 }
    ];

    // Ball colors
    const BALL_COLORS = {
      0: '#ffffff',  // cue
      1: '#f5d742',  // yellow
      2: '#2255cc',  // blue
      3: '#dd2222',  // red
      4: '#7722aa',  // purple
      5: '#ff6600',  // orange
      6: '#118833',  // green
      7: '#882222',  // maroon
      8: '#111111',  // black
      9: '#f5d742',  // yellow stripe
      10: '#2255cc', // blue stripe
      11: '#dd2222', // red stripe
      12: '#7722aa', // purple stripe
      13: '#ff6600', // orange stripe
      14: '#118833', // green stripe
      15: '#882222'  // maroon stripe
    };

    let balls = [];
    let cueBall = null;
    let currentPlayer = 1; // 1 = human, 2 = AI
    let player1Type = null; // 'solids' or 'stripes' or null
    let player2Type = null;
    let player1Score = 0;
    let player2Score = 0;
    let pocketedThisTurn = [];
    let scratchThisTurn = false;
    let ballInHand = false;
    let placingBall = false;
    let aiming = false;
    let aimStart = { x: 0, y: 0 };
    let mousePos = { x: 0, y: 0 };
    let shotInProgress = false;
    let firstBallHit = null;
    let foulThisTurn = false;
    let gameOverReason = '';
    let aiThinking = false;
    let aiShot = null;
    let breakShot = true;

    function createBall(num, x, y) {
      return {
        num: num,
        x: x, y: y,
        vx: 0, vy: 0,
        active: true,
        isStripe: num >= 9 && num <= 15,
        isSolid: num >= 1 && num <= 7,
        is8Ball: num === 8,
        isCue: num === 0
      };
    }

    function rackBalls() {
      balls = [];
      const cx = PLAY_LEFT + PLAY_W * 0.73;
      const cy = PLAY_TOP + PLAY_H / 2;
      const d = BALL_R * 2 + 0.5;

      // Triangle rack - 8-ball in center
      const rackOrder = [1, 9, 2, 10, 8, 11, 3, 12, 6, 14, 4, 13, 7, 15, 5];
      let idx = 0;
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col <= row; col++) {
          const bx = cx + row * d * Math.cos(Math.PI / 6);
          const by = cy + (col - row / 2) * d;
          balls.push(createBall(rackOrder[idx], bx, by));
          idx++;
        }
      }

      // Cue ball
      cueBall = createBall(0, PLAY_LEFT + PLAY_W * 0.25, cy);
      balls.push(cueBall);
    }

    function init() {
      rackBalls();
      currentPlayer = 1;
      player1Type = null;
      player2Type = null;
      player1Score = 0;
      player2Score = 0;
      score = 0;
      ballInHand = false;
      placingBall = false;
      aiming = false;
      shotInProgress = false;
      firstBallHit = null;
      foulThisTurn = false;
      pocketedThisTurn = [];
      scratchThisTurn = false;
      gameOverReason = '';
      aiThinking = false;
      aiShot = null;
      breakShot = true;
      gameState = 'waiting';
      scoreEl.textContent = '0';
      bestEl.textContent = '0';
      turnLabel.textContent = '8-BALL';
      updateTurnInfo();
      updateBallRack();
      overlay.style.display = 'flex';
      overlayTitle.textContent = '8-BALL POOL';
      overlayText.textContent = 'Click to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      updateTurnInfo();
      updateBallRack();
      draw();
    }

    function updateTurnInfo() {
      if (gameState !== 'playing') { turnInfo.textContent = ''; return; }
      let p = currentPlayer === 1 ? 'YOUR' : "CPU's";
      let type = currentPlayer === 1 ? player1Type : player2Type;
      let typeStr = type ? (type === 'solids' ? ' (Solids 1-7)' : ' (Stripes 9-15)') : '';
      if (ballInHand && currentPlayer === 1) {
        turnInfo.textContent = p + ' TURN' + typeStr + ' — Click to place cue ball';
      } else if (placingBall && currentPlayer === 1) {
        turnInfo.textContent = p + ' TURN' + typeStr + ' — Place cue ball anywhere';
      } else {
        turnInfo.textContent = p + ' TURN' + typeStr;
      }
      turnLabel.textContent = currentPlayer === 1 ? 'YOUR TURN' : 'CPU TURN';
      turnLabel.style.color = currentPlayer === 1 ? '#0a6' : '#f66';
    }

    function updateBallRack() {
      let html = '';
      for (let i = 1; i <= 15; i++) {
        const b = balls.find(b => b.num === i);
        const pocketed = !b || !b.active;
        const col = BALL_COLORS[i];
        const isStripe = i >= 9;
        let style = `background:${pocketed ? '#333' : col};`;
        if (isStripe && !pocketed) {
          style = `background: linear-gradient(180deg, ${col} 25%, #fff 25%, #fff 75%, ${col} 75%);`;
        }
        html += `<div class="ball-indicator${pocketed ? ' pocketed' : ''}" style="${style}">${i}</div>`;
      }
      ballRackEl.innerHTML = html;
    }

    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function allBallsStopped() {
      return balls.every(b => !b.active || (Math.abs(b.vx) < MIN_VEL && Math.abs(b.vy) < MIN_VEL));
    }

    function activeBallsOfType(type) {
      return balls.filter(b => b.active && (type === 'solids' ? b.isSolid : b.isStripe));
    }

    function checkPocket(ball) {
      for (const p of pockets) {
        if (dist(ball, p) < POCKET_R) {
          return true;
        }
      }
      return false;
    }

    function physics() {
      let moving = false;

      for (const b of balls) {
        if (!b.active) continue;
        if (Math.abs(b.vx) < MIN_VEL && Math.abs(b.vy) < MIN_VEL) {
          b.vx = 0; b.vy = 0;
          continue;
        }
        moving = true;

        b.x += b.vx;
        b.y += b.vy;
        b.vx *= FRICTION;
        b.vy *= FRICTION;

        // Cushion bouncing
        if (b.x - BALL_R < PLAY_LEFT) {
          b.x = PLAY_LEFT + BALL_R;
          b.vx = Math.abs(b.vx) * 0.8;
        }
        if (b.x + BALL_R > PLAY_RIGHT) {
          b.x = PLAY_RIGHT - BALL_R;
          b.vx = -Math.abs(b.vx) * 0.8;
        }
        if (b.y - BALL_R < PLAY_TOP) {
          b.y = PLAY_TOP + BALL_R;
          b.vy = Math.abs(b.vy) * 0.8;
        }
        if (b.y + BALL_R > PLAY_BOTTOM) {
          b.y = PLAY_BOTTOM - BALL_R;
          b.vy = -Math.abs(b.vy) * 0.8;
        }

        // Check pocket
        if (checkPocket(b)) {
          b.active = false;
          b.vx = 0; b.vy = 0;
          if (b.isCue) {
            scratchThisTurn = true;
          } else {
            pocketedThisTurn.push(b.num);
          }
        }
      }

      // Ball-ball collisions
      for (let i = 0; i < balls.length; i++) {
        if (!balls[i].active) continue;
        for (let j = i + 1; j < balls.length; j++) {
          if (!balls[j].active) continue;
          const a = balls[i], b = balls[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < BALL_R * 2 && d > 0) {
            // Track first ball hit by cue
            if (firstBallHit === null) {
              if (a.isCue) firstBallHit = b.num;
              else if (b.isCue) firstBallHit = a.num;
            }

            const nx = dx / d, ny = dy / d;
            const overlap = BALL_R * 2 - d;
            a.x -= nx * overlap / 2;
            a.y -= ny * overlap / 2;
            b.x += nx * overlap / 2;
            b.y += ny * overlap / 2;

            const dvx = a.vx - b.vx;
            const dvy = a.vy - b.vy;
            const dot = dvx * nx + dvy * ny;
            if (dot > 0) {
              a.vx -= dot * nx * 0.95;
              a.vy -= dot * ny * 0.95;
              b.vx += dot * nx * 0.95;
              b.vy += dot * ny * 0.95;
            }
          }
        }
      }

      return moving;
    }

    function processTurnResult() {
      shotInProgress = false;
      let switchTurn = false;
      let gameOver = false;

      const pType = currentPlayer === 1 ? player1Type : player2Type;

      // Check for scratch
      if (scratchThisTurn) {
        foulThisTurn = true;
        // Respawn cue ball
        cueBall.active = true;
        cueBall.vx = 0; cueBall.vy = 0;
        switchTurn = true;
      }

      // Check if 8-ball was pocketed
      if (pocketedThisTurn.includes(8)) {
        gameOver = true;
        const shooterType = currentPlayer === 1 ? player1Type : player2Type;
        const remaining = shooterType ? activeBallsOfType(shooterType).length : 99;
        if (remaining > 0 || scratchThisTurn) {
          // Pocketed 8-ball early or scratched on 8-ball = loss
          if (currentPlayer === 1) {
            gameOverReason = 'You pocketed the 8-ball too early! CPU wins!';
          } else {
            gameOverReason = 'CPU pocketed the 8-ball too early! You win!';
          }
        } else {
          // Legal 8-ball pocket = win
          if (currentPlayer === 1) {
            gameOverReason = 'You pocketed the 8-ball! You win!';
            player1Score += 5;
          } else {
            gameOverReason = 'CPU pocketed the 8-ball! CPU wins!';
            player2Score += 5;
          }
        }
      }

      if (!gameOver) {
        // Assign types on first legal pocket (after break)
        if (!player1Type && pocketedThisTurn.length > 0 && !breakShot) {
          const firstPocketed = pocketedThisTurn[0];
          if (firstPocketed !== 8) {
            const pocketedBall = balls.find(b => b.num === firstPocketed);
            if (firstPocketed >= 1 && firstPocketed <= 7) {
              if (currentPlayer === 1) { player1Type = 'solids'; player2Type = 'stripes'; }
              else { player2Type = 'solids'; player1Type = 'stripes'; }
            } else if (firstPocketed >= 9 && firstPocketed <= 15) {
              if (currentPlayer === 1) { player1Type = 'stripes'; player2Type = 'solids'; }
              else { player2Type = 'stripes'; player1Type = 'solids'; }
            }
          }
        }

        // Count pocketed balls for score
        for (const num of pocketedThisTurn) {
          if (num === 8) continue;
          if (currentPlayer === 1) player1Score++;
          else player2Score++;
        }

        // Determine if turn switches
        if (foulThisTurn) {
          switchTurn = true;
        } else if (pocketedThisTurn.length === 0) {
          switchTurn = true;
        } else if (pType) {
          // Check if any pocketed ball was the right type
          const rightType = pocketedThisTurn.some(n => {
            if (pType === 'solids') return n >= 1 && n <= 7;
            return n >= 9 && n <= 15;
          });
          if (!rightType) switchTurn = true;
        }

        if (breakShot) {
          breakShot = false;
          if (pocketedThisTurn.length === 0) switchTurn = true;
          else switchTurn = false;
        }
      }

      // Update scores
      score = player1Score;
      scoreEl.textContent = player1Score;
      bestEl.textContent = player2Score;

      if (gameOver) {
        endGame();
        return;
      }

      if (switchTurn) {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        if (foulThisTurn) {
          ballInHand = true;
          placingBall = true;
        }
      }

      // Reset turn tracking
      pocketedThisTurn = [];
      scratchThisTurn = false;
      firstBallHit = null;
      foulThisTurn = false;

      updateTurnInfo();
      updateBallRack();

      if (currentPlayer === 2 && gameState === 'playing') {
        aiThinking = true;
        setTimeout(doAITurn, 800);
      }
    }

    function endGame() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = gameOverReason.includes('You win') ? 'YOU WIN!' : 'GAME OVER';
      overlayText.textContent = gameOverReason + '\nClick to play again';
      updateBallRack();
    }

    // AI
    function doAITurn() {
      if (gameState !== 'playing') return;

      if (ballInHand) {
        // Place cue ball in a good position
        cueBall.x = PLAY_LEFT + PLAY_W * 0.25;
        cueBall.y = PLAY_TOP + PLAY_H / 2;
        // Try to find a position with a clear shot
        let bestPos = { x: cueBall.x, y: cueBall.y };
        let bestScore = -1;
        for (let attempt = 0; attempt < 30; attempt++) {
          const tx = PLAY_LEFT + BALL_R + Math.random() * (PLAY_W - BALL_R * 2);
          const ty = PLAY_TOP + BALL_R + Math.random() * (PLAY_H - BALL_R * 2);
          // Check no overlap
          let overlap = false;
          for (const b of balls) {
            if (!b.active || b.isCue) continue;
            if (dist({ x: tx, y: ty }, b) < BALL_R * 2.5) { overlap = true; break; }
          }
          if (overlap) continue;

          const shotScore = evaluatePosition(tx, ty);
          if (shotScore > bestScore) {
            bestScore = shotScore;
            bestPos = { x: tx, y: ty };
          }
        }
        cueBall.x = bestPos.x;
        cueBall.y = bestPos.y;
        cueBall.active = true;
        ballInHand = false;
        placingBall = false;
      }

      // Find best shot
      const shot = findBestAIShot();
      if (shot) {
        aiShot = shot;
        setTimeout(() => {
          executeAIShot(shot);
          aiThinking = false;
          aiShot = null;
        }, 600);
      } else {
        // No good shot, just hit something
        const targetBalls = getValidTargets();
        if (targetBalls.length > 0) {
          const target = targetBalls[Math.floor(Math.random() * targetBalls.length)];
          const angle = Math.atan2(target.y - cueBall.y, target.x - cueBall.x);
          const power = 5 + Math.random() * 5;
          setTimeout(() => {
            cueBall.vx = Math.cos(angle) * power;
            cueBall.vy = Math.sin(angle) * power;
            shotInProgress = true;
            firstBallHit = null;
            pocketedThisTurn = [];
            scratchThisTurn = false;
            foulThisTurn = false;
            aiThinking = false;
            aiShot = null;
          }, 600);
        } else {
          // Just shoot randomly
          const angle = Math.random() * Math.PI * 2;
          setTimeout(() => {
            cueBall.vx = Math.cos(angle) * 6;
            cueBall.vy = Math.sin(angle) * 6;
            shotInProgress = true;
            firstBallHit = null;
            pocketedThisTurn = [];
            scratchThisTurn = false;
            foulThisTurn = false;
            aiThinking = false;
            aiShot = null;
          }, 600);
        }
      }
    }

    function getValidTargets() {
      const aiType = player2Type;
      return balls.filter(b => {
        if (!b.active || b.isCue) return false;
        if (!aiType) return !b.is8Ball; // Open table, any ball except 8
        if (aiType === 'solids') {
          const remaining = activeBallsOfType('solids');
          if (remaining.length === 0) return b.is8Ball;
          return b.isSolid;
        } else {
          const remaining = activeBallsOfType('stripes');
          if (remaining.length === 0) return b.is8Ball;
          return b.isStripe;
        }
      });
    }

    function evaluatePosition(cx, cy) {
      const targets = getValidTargets();
      let bestScore = 0;
      for (const target of targets) {
        for (const pocket of pockets) {
          const d1 = dist({ x: cx, y: cy }, target);
          const d2 = dist(target, pocket);
          if (d1 < BALL_R * 3) continue; // too close
          // Check if path is clear
          const angle1 = Math.atan2(target.y - cy, target.x - cx);
          const angle2 = Math.atan2(pocket.y - target.y, pocket.x - target.x);
          const angleDiff = Math.abs(angle1 - angle2);
          const score = 1 / (d1 + d2) * 1000 - angleDiff * 10;
          if (score > bestScore) bestScore = score;
        }
      }
      return bestScore;
    }

    function findBestAIShot() {
      const targets = getValidTargets();
      let bestShot = null;
      let bestScore = -Infinity;

      for (const target of targets) {
        for (const pocket of pockets) {
          // Calculate ghost ball position (where cue ball needs to be to pocket target)
          const dx = target.x - pocket.x;
          const dy = target.y - pocket.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < 1) continue;

          const ghostX = target.x + (dx / d) * BALL_R * 2;
          const ghostY = target.y + (dy / d) * BALL_R * 2;

          // Check if path from cue to ghost is clear
          const pathClear = isPathClear(cueBall.x, cueBall.y, ghostX, ghostY, [target.num]);
          if (!pathClear) continue;

          // Check if path from target to pocket is clear
          const pocketPathClear = isPathClear(target.x, target.y, pocket.x, pocket.y, [0]);
          if (!pocketPathClear) continue;

          // Calculate shot angle and power
          const shotDx = ghostX - cueBall.x;
          const shotDy = ghostY - cueBall.y;
          const shotDist = Math.sqrt(shotDx * shotDx + shotDy * shotDy);
          const pocketDist = dist(target, pocket);

          // Score this shot - prefer closer, straighter shots
          const cutAngle = Math.abs(Math.atan2(dy, dx) - Math.atan2(shotDy, shotDx));
          let shotScore = 100 - shotDist * 0.1 - pocketDist * 0.15 - cutAngle * 20;

          // Bonus for side pockets on straight shots
          if (cutAngle < 0.3) shotScore += 20;

          // Penalty for very long shots
          if (shotDist > 350) shotScore -= 30;

          if (shotScore > bestScore) {
            bestScore = shotScore;
            const power = Math.min(MAX_POWER, Math.max(4, shotDist * 0.035 + pocketDist * 0.02 + 3));
            bestShot = {
              angle: Math.atan2(shotDy, shotDx),
              power: power,
              targetBall: target,
              pocket: pocket,
              ghostX: ghostX,
              ghostY: ghostY
            };
          }
        }
      }

      return bestShot;
    }

    function isPathClear(x1, y1, x2, y2, excludeNums) {
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len < 1) return true;
      const nx = dx / len, ny = dy / len;

      for (const b of balls) {
        if (!b.active || b.isCue || excludeNums.includes(b.num)) continue;
        // Distance from ball center to line
        const t = Math.max(0, Math.min(len, (b.x - x1) * nx + (b.y - y1) * ny));
        const closestX = x1 + nx * t;
        const closestY = y1 + ny * t;
        const d = dist(b, { x: closestX, y: closestY });
        if (d < BALL_R * 2.2) return false;
      }
      return true;
    }

    function executeAIShot(shot) {
      cueBall.vx = Math.cos(shot.angle) * shot.power;
      cueBall.vy = Math.sin(shot.angle) * shot.power;
      shotInProgress = true;
      firstBallHit = null;
      pocketedThisTurn = [];
      scratchThisTurn = false;
      foulThisTurn = false;
    }

    // Drawing
    function drawTable() {
      // Outer wood border
      ctx.fillStyle = '#5a3210';
      ctx.fillRect(TABLE_LEFT - 10, TABLE_TOP - 10, TABLE_W + 20, TABLE_H + 20);

      // Wood grain effect
      ctx.fillStyle = '#6b3d15';
      ctx.fillRect(TABLE_LEFT - 8, TABLE_TOP - 8, TABLE_W + 16, TABLE_H + 16);

      // Rail (darker green)
      ctx.fillStyle = '#0a5030';
      ctx.fillRect(TABLE_LEFT, TABLE_TOP, TABLE_W, TABLE_H);

      // Felt (playing surface)
      ctx.fillStyle = '#0a8050';
      ctx.fillRect(PLAY_LEFT, PLAY_TOP, PLAY_W, PLAY_H);

      // Felt texture (subtle dots)
      ctx.fillStyle = 'rgba(0,0,0,0.03)';
      for (let i = 0; i < 200; i++) {
        const x = PLAY_LEFT + Math.random() * PLAY_W;
        const y = PLAY_TOP + Math.random() * PLAY_H;
        ctx.fillRect(x, y, 1, 1);
      }

      // Head string line
      const headLine = PLAY_LEFT + PLAY_W * 0.25;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(headLine, PLAY_TOP);
      ctx.lineTo(headLine, PLAY_BOTTOM);
      ctx.stroke();
      ctx.setLineDash([]);

      // Foot spot
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.beginPath();
      ctx.arc(PLAY_LEFT + PLAY_W * 0.73, PLAY_TOP + PLAY_H / 2, 3, 0, Math.PI * 2);
      ctx.fill();

      // Center spot
      ctx.beginPath();
      ctx.arc(PLAY_LEFT + PLAY_W / 2, PLAY_TOP + PLAY_H / 2, 3, 0, Math.PI * 2);
      ctx.fill();

      // Draw pockets
      for (const p of pockets) {
        ctx.save();
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 8;
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Pocket edge
        ctx.strokeStyle = '#3a2008';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_R + 1, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Rail cushion edges
      ctx.strokeStyle = '#0a6040';
      ctx.lineWidth = 2;
      ctx.strokeRect(PLAY_LEFT, PLAY_TOP, PLAY_W, PLAY_H);

      // Diamond markers on rails
      ctx.fillStyle = '#c8a050';
      const diamondSize = 3;
      // Top and bottom rails
      for (let i = 1; i < 4; i++) {
        const dx = PLAY_LEFT + (PLAY_W / 4) * i;
        // Top
        drawDiamond(dx, TABLE_TOP + RAIL / 2, diamondSize);
        // Bottom
        drawDiamond(dx, TABLE_BOTTOM - RAIL / 2, diamondSize);
      }
      // Left and right rails
      for (let i = 1; i < 3; i++) {
        const dy = PLAY_TOP + (PLAY_H / 3) * i;
        // Left
        drawDiamond(TABLE_LEFT + RAIL / 2, dy, diamondSize);
        // Right
        drawDiamond(TABLE_RIGHT - RAIL / 2, dy, diamondSize);
      }
    }

    function drawDiamond(x, y, s) {
      ctx.beginPath();
      ctx.moveTo(x, y - s);
      ctx.lineTo(x + s, y);
      ctx.lineTo(x, y + s);
      ctx.lineTo(x - s, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawBall(ball) {
      if (!ball.active) return;

      const x = ball.x, y = ball.y;
      const color = BALL_COLORS[ball.num];

      ctx.save();

      // Shadow
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      if (ball.isCue) {
        // Cue ball - white with subtle shading
        const grad = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#d0d0d0');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      } else if (ball.isStripe) {
        // Stripe ball - white with colored band
        const grad = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#e8e8e8');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();

        // Colored stripe band
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.clip();
        ctx.fillStyle = color;
        ctx.fillRect(x - BALL_R, y - BALL_R * 0.5, BALL_R * 2, BALL_R * 1);
        ctx.restore();
      } else if (ball.is8Ball) {
        // 8-ball - solid black
        const grad = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        grad.addColorStop(0, '#333');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Solid ball
        const grad = ctx.createRadialGradient(x - 2, y - 2, 1, x, y, BALL_R);
        grad.addColorStop(0, lightenColor(color, 40));
        grad.addColorStop(1, color);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, BALL_R, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // Number circle
      if (!ball.isCue) {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, BALL_R * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.font = `bold ${BALL_R * 0.7}px 'Courier New'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(ball.num.toString(), x, y + 0.5);
      }

      // Highlight/gloss
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      ctx.arc(x - BALL_R * 0.3, y - BALL_R * 0.3, BALL_R * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    function lightenColor(hex, amount) {
      const r = Math.min(255, parseInt(hex.slice(1, 3), 16) + amount);
      const g = Math.min(255, parseInt(hex.slice(3, 5), 16) + amount);
      const b = Math.min(255, parseInt(hex.slice(5, 7), 16) + amount);
      return `rgb(${r},${g},${b})`;
    }

    function drawCueStick() {
      if (!cueBall.active) return;
      if (shotInProgress || aiThinking) return;
      if (currentPlayer === 2) return;
      if (ballInHand || placingBall) return;

      if (aiming) {
        const dx = aimStart.x - mousePos.x;
        const dy = aimStart.y - mousePos.y;
        const pullDist = Math.sqrt(dx * dx + dy * dy);
        const power = Math.min(MAX_POWER, pullDist * 0.15);
        const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);

        // Aim guide line
        const guideLen = 200;
        ctx.save();
        ctx.shadowColor = 'rgba(0,170,102,0.3)';
        ctx.shadowBlur = 6;
        ctx.strokeStyle = 'rgba(0,170,102,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(cueBall.x, cueBall.y);
        ctx.lineTo(cueBall.x + Math.cos(angle) * guideLen, cueBall.y + Math.sin(angle) * guideLen);
        ctx.stroke();
        ctx.setLineDash([]);

        // Ghost ball prediction
        const aimDirX = Math.cos(angle);
        const aimDirY = Math.sin(angle);
        let hitBall = null;
        let hitDist = Infinity;
        for (const b of balls) {
          if (!b.active || b.isCue) continue;
          // Ray-circle intersection
          const ocx = b.x - cueBall.x;
          const ocy = b.y - cueBall.y;
          const proj = ocx * aimDirX + ocy * aimDirY;
          if (proj < 0) continue;
          const perpSq = (ocx * ocx + ocy * ocy) - proj * proj;
          const minD = BALL_R * 2;
          if (perpSq < minD * minD) {
            const t = proj - Math.sqrt(minD * minD - perpSq);
            if (t > 0 && t < hitDist) {
              hitDist = t;
              hitBall = b;
            }
          }
        }

        if (hitBall) {
          const contactX = cueBall.x + aimDirX * hitDist;
          const contactY = cueBall.y + aimDirY * hitDist;

          // Ghost cue ball
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(contactX, contactY, BALL_R, 0, Math.PI * 2);
          ctx.stroke();

          // Predicted target ball path
          const hitAngle = Math.atan2(hitBall.y - contactY, hitBall.x - contactX);
          ctx.strokeStyle = 'rgba(255,200,50,0.4)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(hitBall.x, hitBall.y);
          ctx.lineTo(hitBall.x + Math.cos(hitAngle) * 120, hitBall.y + Math.sin(hitAngle) * 120);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.restore();

        // Cue stick drawn pulled back
        const pullBack = Math.min(60, pullDist * 0.3);
        const stickStartX = cueBall.x - Math.cos(angle) * (BALL_R + 5 + pullBack);
        const stickStartY = cueBall.y - Math.sin(angle) * (BALL_R + 5 + pullBack);
        const stickEndX = stickStartX - Math.cos(angle) * 140;
        const stickEndY = stickStartY - Math.sin(angle) * 140;

        // Cue stick shadow
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(stickStartX + 2, stickStartY + 2);
        ctx.lineTo(stickEndX + 2, stickEndY + 2);
        ctx.stroke();

        // Cue stick body
        ctx.strokeStyle = '#c8a050';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickEndX, stickEndY);
        ctx.stroke();

        // Cue tip
        ctx.strokeStyle = '#e8d8a0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickStartX - Math.cos(angle) * 15, stickStartY - Math.sin(angle) * 15);
        ctx.stroke();

        // Ferrule
        ctx.strokeStyle = '#f5f5f0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickStartX + Math.cos(angle) * 3, stickStartY + Math.sin(angle) * 3);
        ctx.stroke();

        // Power meter
        const powerPct = power / MAX_POWER;
        const meterX = 20, meterY = TABLE_TOP;
        const meterW = 12, meterH = TABLE_H;
        ctx.fillStyle = '#222';
        ctx.fillRect(meterX, meterY, meterW, meterH);
        const pColor = powerPct < 0.5 ? '#0a6' : powerPct < 0.8 ? '#f90' : '#f33';
        ctx.fillStyle = pColor;
        ctx.fillRect(meterX, meterY + meterH * (1 - powerPct), meterW, meterH * powerPct);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(meterX, meterY, meterW, meterH);
        ctx.fillStyle = '#aaa';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('PWR', meterX + meterW / 2, meterY - 4);

      } else if (!aiming && cueBall.active) {
        // Idle cue stick follows mouse
        const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);
        const stickStartX = cueBall.x - Math.cos(angle) * (BALL_R + 5);
        const stickStartY = cueBall.y - Math.sin(angle) * (BALL_R + 5);
        const stickEndX = stickStartX - Math.cos(angle) * 140;
        const stickEndY = stickStartY - Math.sin(angle) * 140;

        // Guide line
        ctx.save();
        ctx.strokeStyle = 'rgba(0,170,102,0.2)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(cueBall.x, cueBall.y);
        ctx.lineTo(cueBall.x + Math.cos(angle) * 150, cueBall.y + Math.sin(angle) * 150);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(stickStartX + 2, stickStartY + 2);
        ctx.lineTo(stickEndX + 2, stickEndY + 2);
        ctx.stroke();

        ctx.strokeStyle = '#c8a050';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickEndX, stickEndY);
        ctx.stroke();

        ctx.strokeStyle = '#e8d8a0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickStartX - Math.cos(angle) * 15, stickStartY - Math.sin(angle) * 15);
        ctx.stroke();

        ctx.strokeStyle = '#f5f5f0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(stickStartX, stickStartY);
        ctx.lineTo(stickStartX + Math.cos(angle) * 3, stickStartY + Math.sin(angle) * 3);
        ctx.stroke();
      }
    }

    function drawBallInHandIndicator() {
      if (!ballInHand || currentPlayer !== 1) return;

      // Draw cue ball at mouse position (preview)
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.arc(mousePos.x, mousePos.y, BALL_R, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawTable();

      // Draw balls (non-cue first, then cue on top)
      for (const b of balls) {
        if (!b.isCue) drawBall(b);
      }
      drawBall(cueBall);

      if (gameState === 'playing') {
        if (ballInHand && currentPlayer === 1) {
          drawBallInHandIndicator();
        } else {
          drawCueStick();
        }
      }

      // AI thinking indicator
      if (aiThinking && currentPlayer === 2) {
        ctx.save();
        ctx.shadowColor = '#f66';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#f66';
        ctx.font = '14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('CPU is thinking...', W / 2, H - 5);
        ctx.restore();
      }
    }

    // Game loop
    function gameLoop() {
      if (gameState === 'playing') {
        if (shotInProgress) {
          const moving = physics();
          if (!moving) {
            processTurnResult();
          }
        }
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Input handling
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      mousePos.x = (e.clientX - rect.left) * scaleX;
      mousePos.y = (e.clientY - rect.top) * scaleY;
    });

    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'waiting') {
        start();
        return;
      }
      if (gameState === 'over') {
        init();
        return;
      }
      if (gameState !== 'playing') return;
      if (currentPlayer !== 1) return;
      if (shotInProgress) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      if (ballInHand) {
        // Place cue ball
        const px = Math.max(PLAY_LEFT + BALL_R, Math.min(PLAY_RIGHT - BALL_R, mx));
        const py = Math.max(PLAY_TOP + BALL_R, Math.min(PLAY_BOTTOM - BALL_R, my));

        // Check no overlap with other balls
        let overlap = false;
        for (const b of balls) {
          if (!b.active || b.isCue) continue;
          if (dist({ x: px, y: py }, b) < BALL_R * 2.5) {
            overlap = true;
            break;
          }
        }
        if (!overlap) {
          cueBall.x = px;
          cueBall.y = py;
          cueBall.active = true;
          ballInHand = false;
          placingBall = false;
          updateTurnInfo();
        }
        return;
      }

      if (!cueBall.active) return;

      // Start aiming
      aiming = true;
      aimStart.x = mx;
      aimStart.y = my;
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!aiming) return;
      if (currentPlayer !== 1) return;

      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      const dx = aimStart.x - mx;
      const dy = aimStart.y - my;
      const pullDist = Math.sqrt(dx * dx + dy * dy);
      const power = Math.min(MAX_POWER, pullDist * 0.15);

      aiming = false;

      if (power < 0.5) return; // Too weak, cancel

      const angle = Math.atan2(cueBall.y - mousePos.y, cueBall.x - mousePos.x);
      cueBall.vx = Math.cos(angle) * power;
      cueBall.vy = Math.sin(angle) * power;

      shotInProgress = true;
      firstBallHit = null;
      pocketedThisTurn = [];
      scratchThisTurn = false;
      foulThisTurn = false;
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    init();
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sokoban</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #f08; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 0, 136, 0.4); }
    h1 { color: #f08; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 0, 136, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f08; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: #888;
    }
    .info-bar span { color: #f08; }
    canvas {
      border: 2px solid #f08;
      box-shadow: 0 0 20px rgba(255, 0, 136, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f08;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SOKOBAN</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="info-bar">
    <div>Level: <span id="levelNum">1</span></div>
    <div>Moves: <span id="moveCount">0</span></div>
    <div><span style="color:#666">Z</span>=Undo <span style="color:#666">R</span>=Reset</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:400px;">
      <h2 id="overlayTitle">SOKOBAN</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelNumEl = document.getElementById('levelNum');
    const moveCountEl = document.getElementById('moveCount');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Sokoban level format:
    // # = wall, @ = player, $ = box, . = target, * = box on target, + = player on target, space = floor
    const LEVELS = [
      // Level 1 - Tutorial (1 box, 4 moves)
      [
        '#####',
        '#   #',
        '#@$ #',
        '#  .#',
        '#####'
      ],
      // Level 2 - Two boxes (8 moves)
      [
        '#####',
        '#  .#',
        '# $ #',
        '#@$ #',
        '#  .#',
        '#####'
      ],
      // Level 3 - Two boxes with wall (11 moves)
      [
        '######',
        '#    #',
        '# @$ #',
        '# #  #',
        '# .$.#',
        '#    #',
        '######'
      ],
      // Level 4 - Two boxes, planning needed (16 moves)
      [
        '######',
        '#    #',
        '# #@ #',
        '# $* #',
        '# .* #',
        '#    #',
        '######'
      ],
      // Level 5 - Three boxes (9 moves)
      [
        '#######',
        '#  . .#',
        '#  $$ #',
        '## @# #',
        ' # $  #',
        ' # .  #',
        ' ######'
      ],
      // Level 6 - Three boxes corridor (9 moves)
      [
        '#######',
        '#     #',
        '#.$ # #',
        '#.$ @ #',
        '#.$   #',
        '#   ###',
        '#####  '
      ],
      // Level 7 - Three boxes winding (52 moves)
      [
        '  ##### ',
        '  #   # ',
        '###$# ##',
        '# $  . #',
        '#   .# #',
        '##$#.  #',
        ' # @ ###',
        ' #   #  ',
        ' #####  '
      ],
      // Level 8 - Microban classic (33 moves)
      [
        '####  ',
        '# .#  ',
        '#  ###',
        '#*@  #',
        '#  $ #',
        '#  ###',
        '####  '
      ],
      // Level 9 - Five boxes (37 moves)
      [
        '  ##### ',
        '###   # ',
        '#.$ $ ##',
        '# .#$  #',
        '#. @ $ #',
        '##  .  #',
        ' ######'
      ],
      // Level 10 - The challenge (44 moves)
      [
        '########',
        '#   #  #',
        '# $  $ #',
        '## .#  #',
        ' #.@.$ #',
        ' # .#$ #',
        ' #     #',
        ' #######'
      ]
    ];

    // Game state
    let currentLevel = 0;
    let grid = [];       // 2D array of cell types
    let playerR, playerC;
    let moves = 0;
    let totalMoves = 0;
    let levelsCompleted = 0;
    let history = [];    // undo stack

    // Cell types
    const FLOOR = 0;
    const WALL = 1;
    const TARGET = 2;
    const BOX = 3;
    const BOX_ON_TARGET = 4;
    const PLAYER = 5;
    const PLAYER_ON_TARGET = 6;

    function parseLevel(levelData) {
      const rows = levelData.length;
      let maxCols = 0;
      for (let r = 0; r < rows; r++) {
        if (levelData[r].length > maxCols) maxCols = levelData[r].length;
      }
      grid = [];
      playerR = -1;
      playerC = -1;
      for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < maxCols; c++) {
          const ch = c < levelData[r].length ? levelData[r][c] : ' ';
          switch (ch) {
            case '#': grid[r][c] = WALL; break;
            case '$': grid[r][c] = BOX; break;
            case '.': grid[r][c] = TARGET; break;
            case '*': grid[r][c] = BOX_ON_TARGET; break;
            case '@': grid[r][c] = PLAYER; playerR = r; playerC = c; break;
            case '+': grid[r][c] = PLAYER_ON_TARGET; playerR = r; playerC = c; break;
            default:  grid[r][c] = FLOOR; break;
          }
        }
      }
      moves = 0;
      history = [];
    }

    function loadLevel(n) {
      currentLevel = n;
      parseLevel(LEVELS[n]);
      levelNumEl.textContent = n + 1;
      moveCountEl.textContent = '0';
    }

    function init() {
      score = 0;
      totalMoves = 0;
      levelsCompleted = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SOKOBAN';
      overlayText.innerHTML = 'Push boxes onto targets!<br>Press SPACE to start';
      loadLevel(0);
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      draw();
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.innerHTML = 'All levels complete! Score: ' + score + '<br>Press any key to restart';
    }

    function levelComplete() {
      levelsCompleted++;
      // Score: bonus points per level (higher bonus for fewer moves)
      const bonus = Math.max(10, 1000 - moves * 5);
      score += bonus;
      totalMoves += moves;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      if (currentLevel + 1 < LEVELS.length) {
        // Show brief level transition then load next
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'LEVEL ' + (currentLevel + 1) + ' CLEAR!';
        overlayText.innerHTML = 'Moves: ' + moves + ' | Bonus: +' + bonus + '<br>Press any key for next level';
        // Stay in playing state so recorder keeps going
        // We'll use a sub-state via a flag
        levelTransition = true;
      } else {
        gameOver();
      }
    }

    let levelTransition = false;

    function nextLevel() {
      levelTransition = false;
      loadLevel(currentLevel + 1);
      overlay.style.display = 'none';
      draw();
    }

    // Check if level is solved (all targets have boxes)
    function checkWin() {
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[r].length; c++) {
          if (grid[r][c] === TARGET || grid[r][c] === PLAYER_ON_TARGET) {
            return false; // A target without a box
          }
        }
      }
      return true;
    }

    // Try to move player in direction (dr, dc)
    function tryMove(dr, dc) {
      if (gameState !== 'playing' || levelTransition) return;

      const newR = playerR + dr;
      const newC = playerC + dc;

      // Bounds check
      if (newR < 0 || newR >= grid.length || newC < 0 || newC >= grid[newR].length) return;

      const target = grid[newR][newC];

      // Wall
      if (target === WALL) return;

      // Box or box on target - try to push
      if (target === BOX || target === BOX_ON_TARGET) {
        const behindR = newR + dr;
        const behindC = newC + dc;

        // Bounds check for push destination
        if (behindR < 0 || behindR >= grid.length || behindC < 0 || behindC >= grid[behindR].length) return;

        const behind = grid[behindR][behindC];
        // Can only push into floor or target
        if (behind !== FLOOR && behind !== TARGET) return;

        // Save state for undo
        history.push({
          playerR: playerR,
          playerC: playerC,
          grid: grid.map(row => row.slice()),
          moves: moves
        });

        // Move box
        grid[behindR][behindC] = (behind === TARGET) ? BOX_ON_TARGET : BOX;

        // Move player to where box was
        grid[newR][newC] = (target === BOX_ON_TARGET) ? PLAYER_ON_TARGET : PLAYER;

        // Clear old player position
        grid[playerR][playerC] = (grid[playerR][playerC] === PLAYER_ON_TARGET) ? TARGET : FLOOR;

        playerR = newR;
        playerC = newC;
        moves++;
        moveCountEl.textContent = moves;
        draw();

        if (checkWin()) {
          levelComplete();
        }
        return;
      }

      // Floor or target - just move
      if (target === FLOOR || target === TARGET) {
        // Save state for undo
        history.push({
          playerR: playerR,
          playerC: playerC,
          grid: grid.map(row => row.slice()),
          moves: moves
        });

        grid[newR][newC] = (target === TARGET) ? PLAYER_ON_TARGET : PLAYER;
        grid[playerR][playerC] = (grid[playerR][playerC] === PLAYER_ON_TARGET) ? TARGET : FLOOR;

        playerR = newR;
        playerC = newC;
        moves++;
        moveCountEl.textContent = moves;
        draw();
      }
    }

    function undo() {
      if (history.length === 0) return;
      const state = history.pop();
      grid = state.grid;
      playerR = state.playerR;
      playerC = state.playerC;
      moves = state.moves;
      moveCountEl.textContent = moves;
      draw();
    }

    function resetLevel() {
      loadLevel(currentLevel);
      draw();
    }

    // Drawing
    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      if (grid.length === 0) return;

      const rows = grid.length;
      let cols = 0;
      for (let r = 0; r < rows; r++) {
        if (grid[r].length > cols) cols = grid[r].length;
      }

      // Calculate cell size to fit canvas with padding
      const padding = 16;
      const cellW = Math.floor((W - padding * 2) / cols);
      const cellH = Math.floor((H - padding * 2) / rows);
      const cellSize = Math.min(cellW, cellH, 48);

      // Center the grid
      const gridW = cols * cellSize;
      const gridH = rows * cellSize;
      const offsetX = Math.floor((W - gridW) / 2);
      const offsetY = Math.floor((H - gridH) / 2);

      // Draw grid
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < grid[r].length; c++) {
          const x = offsetX + c * cellSize;
          const y = offsetY + r * cellSize;
          const cell = grid[r][c];

          // Floor / background
          if (cell === WALL) {
            ctx.fillStyle = '#2a2a4e';
            ctx.fillRect(x, y, cellSize, cellSize);
            ctx.strokeStyle = '#3a3a5e';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, cellSize - 1, cellSize - 1);
          } else {
            // Dark floor
            ctx.fillStyle = '#10101e';
            ctx.fillRect(x, y, cellSize, cellSize);
            // Subtle grid lines
            ctx.strokeStyle = '#16213e';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(x + 0.5, y + 0.5, cellSize - 1, cellSize - 1);
          }

          const cx = x + cellSize / 2;
          const cy = y + cellSize / 2;
          const pad = Math.floor(cellSize * 0.12);
          const innerSize = cellSize - pad * 2;

          // Target marker (draw under boxes/player)
          if (cell === TARGET || cell === BOX_ON_TARGET || cell === PLAYER_ON_TARGET) {
            ctx.strokeStyle = '#f08';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#f08';
            ctx.shadowBlur = 6;
            // Diamond shape
            ctx.beginPath();
            ctx.moveTo(cx, cy - innerSize * 0.3);
            ctx.lineTo(cx + innerSize * 0.3, cy);
            ctx.lineTo(cx, cy + innerSize * 0.3);
            ctx.lineTo(cx - innerSize * 0.3, cy);
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Box
          if (cell === BOX || cell === BOX_ON_TARGET) {
            const onTarget = cell === BOX_ON_TARGET;
            ctx.fillStyle = onTarget ? '#f08' : '#c66';
            ctx.shadowColor = onTarget ? '#f08' : '#c66';
            ctx.shadowBlur = onTarget ? 14 : 6;
            ctx.fillRect(x + pad, y + pad, innerSize, innerSize);
            // Box detail - cross lines
            ctx.strokeStyle = onTarget ? '#fff' : '#944';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x + pad, y + pad);
            ctx.lineTo(x + pad + innerSize, y + pad + innerSize);
            ctx.moveTo(x + pad + innerSize, y + pad);
            ctx.lineTo(x + pad, y + pad + innerSize);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Player
          if (cell === PLAYER || cell === PLAYER_ON_TARGET) {
            ctx.shadowColor = '#f08';
            ctx.shadowBlur = 16;
            // Body circle
            ctx.fillStyle = '#f08';
            ctx.beginPath();
            ctx.arc(cx, cy, innerSize * 0.35, 0, Math.PI * 2);
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#1a1a2e';
            ctx.shadowBlur = 0;
            const eyeOff = innerSize * 0.12;
            const eyeR = innerSize * 0.07;
            ctx.beginPath();
            ctx.arc(cx - eyeOff, cy - innerSize * 0.06, eyeR, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + eyeOff, cy - innerSize * 0.06, eyeR, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
      }

      // Level and move count on canvas
      ctx.fillStyle = '#888';
      ctx.font = '12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Lv.' + (currentLevel + 1), 8, H - 8);
      ctx.textAlign = 'right';
      ctx.fillText('Moves: ' + moves, W - 8, H - 8);
      ctx.textAlign = 'left';

      // Update gameData for ML
      window.gameData = {
        level: currentLevel + 1,
        moves: moves,
        playerR: playerR,
        playerC: playerC,
        levelsCompleted: levelsCompleted,
        score: score
      };
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (levelTransition) {
          nextLevel();
          return;
        }

        switch (e.key) {
          case 'ArrowUp':    tryMove(-1, 0); break;
          case 'ArrowDown':  tryMove(1, 0);  break;
          case 'ArrowLeft':  tryMove(0, -1); break;
          case 'ArrowRight': tryMove(0, 1);  break;
          case 'z':
          case 'Z':          undo(); break;
          case 'r':
          case 'R':          resetLevel(); break;
        }
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

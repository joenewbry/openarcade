<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 450px;
    }
    .back { color: #4ae; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(68, 170, 238, 0.5); }
    h1 { color: #4ae; font-size: 2rem; text-shadow: 0 0 15px rgba(68, 170, 238, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 450px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #4ae; }
    canvas {
      border: 2px solid #4ae;
      box-shadow: 0 0 20px rgba(68, 170, 238, 0.4);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #4ae;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SUDOKU</h1>
  </div>
  <div class="score-bar">
    <div>Time: <span id="timer">0:00</span></div>
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="450" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:450px;height:500px;">
      <h2 id="overlayTitle">SUDOKU</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid geometry
    const GRID_SIZE = 450;
    const CELL = GRID_SIZE / 9; // 50px per cell
    const GRID_TOP = 0;
    const NUM_PAD_TOP = GRID_SIZE + 5;
    const NUM_PAD_H = H - GRID_SIZE;

    // Theme colors
    const THEME = '#4ae';
    const THEME_DIM = 'rgba(68, 170, 238, 0.15)';
    const THEME_MED = 'rgba(68, 170, 238, 0.25)';
    const THEME_GLOW = 'rgba(68, 170, 238, 0.6)';
    const ERROR_COLOR = '#f44';
    const LOCKED_COLOR = '#888';
    const PLAYER_COLOR = '#4ae';
    const BG = '#1a1a2e';
    const GRID_LINE = '#0f3460';
    const GRID_LINE_THICK = '#4ae';
    const CELL_BG = '#16213e';

    let score, best = 0, gameState;
    let puzzle, solution, board, locked;
    let selRow = -1, selCol = -1;
    let startTime = 0, elapsed = 0, timerInterval = null;
    let difficulty = 40; // number of cells to remove

    // --- Sudoku Generator ---

    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function isValid(board, row, col, num) {
      for (let i = 0; i < 9; i++) {
        if (board[row][i] === num) return false;
        if (board[i][col] === num) return false;
      }
      const br = Math.floor(row / 3) * 3;
      const bc = Math.floor(col / 3) * 3;
      for (let r = br; r < br + 3; r++) {
        for (let c = bc; c < bc + 3; c++) {
          if (board[r][c] === num) return false;
        }
      }
      return true;
    }

    function solveSudoku(board) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) {
            const nums = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            for (const n of nums) {
              if (isValid(board, r, c, n)) {
                board[r][c] = n;
                if (solveSudoku(board)) return true;
                board[r][c] = 0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    function countSolutions(board, limit) {
      let count = 0;
      function solve(b) {
        if (count >= limit) return;
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (b[r][c] === 0) {
              for (let n = 1; n <= 9; n++) {
                if (isValid(b, r, c, n)) {
                  b[r][c] = n;
                  solve(b);
                  b[r][c] = 0;
                }
              }
              return;
            }
          }
        }
        count++;
      }
      solve(board);
      return count;
    }

    function generatePuzzle(removals) {
      // Create a fully solved grid
      const solved = Array.from({ length: 9 }, () => Array(9).fill(0));
      solveSudoku(solved);

      // Copy as puzzle
      const puz = solved.map(r => [...r]);

      // Remove cells while ensuring unique solution
      const cells = [];
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          cells.push([r, c]);
        }
      }
      shuffleArray(cells);

      let removed = 0;
      for (const [r, c] of cells) {
        if (removed >= removals) break;
        const backup = puz[r][c];
        puz[r][c] = 0;
        const test = puz.map(row => [...row]);
        if (countSolutions(test, 2) === 1) {
          removed++;
        } else {
          puz[r][c] = backup;
        }
      }

      return { puzzle: puz, solution: solved };
    }

    // --- Game Logic ---

    function hasConflict(row, col, num) {
      if (num === 0) return false;
      // Check row
      for (let c = 0; c < 9; c++) {
        if (c !== col && board[row][c] === num) return true;
      }
      // Check column
      for (let r = 0; r < 9; r++) {
        if (r !== row && board[r][col] === num) return true;
      }
      // Check box
      const br = Math.floor(row / 3) * 3;
      const bc = Math.floor(col / 3) * 3;
      for (let r = br; r < br + 3; r++) {
        for (let c = bc; c < bc + 3; c++) {
          if ((r !== row || c !== col) && board[r][c] === num) return true;
        }
      }
      return false;
    }

    function isBoardComplete() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) return false;
          if (hasConflict(r, c, board[r][c])) return false;
        }
      }
      return true;
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return min + ':' + (sec < 10 ? '0' : '') + sec;
    }

    function calculateScore(elapsedMs) {
      // Base score 10000, lose points for time, minimum 100
      const seconds = Math.floor(elapsedMs / 1000);
      return Math.max(100, 10000 - seconds * 10);
    }

    function updateTimer() {
      if (gameState !== 'playing') return;
      elapsed = Date.now() - startTime;
      timerEl.textContent = formatTime(elapsed);
    }

    // --- Init / State Machine ---

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      selRow = -1;
      selCol = -1;
      elapsed = 0;
      timerEl.textContent = '0:00';
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SUDOKU';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      // Generate a new puzzle
      const result = generatePuzzle(difficulty);
      puzzle = result.puzzle;
      solution = result.solution;
      board = puzzle.map(r => [...r]);
      locked = puzzle.map(r => r.map(v => v !== 0));
      selRow = 4;
      selCol = 4;

      gameState = 'playing';
      overlay.style.display = 'none';
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 200);
      draw();
    }

    function gameOver(won) {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      gameState = 'over';

      if (won) {
        score = calculateScore(elapsed);
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        overlayTitle.textContent = 'COMPLETE!';
        overlayText.textContent = `Time: ${formatTime(elapsed)} | Score: ${score} -- Press any key for new game`;
      } else {
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = 'Press any key to restart';
      }
      overlay.style.display = 'flex';
    }

    // --- Drawing ---

    function draw() {
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, W, H);

      drawGrid();
      drawNumbers();
      drawNumberPad();
    }

    function drawGrid() {
      // Cell backgrounds for highlighting
      if (selRow >= 0 && selCol >= 0 && gameState === 'playing') {
        const selBox_r = Math.floor(selRow / 3) * 3;
        const selBox_c = Math.floor(selCol / 3) * 3;

        // Highlight row, column, and box
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            const inRow = r === selRow;
            const inCol = c === selCol;
            const inBox = r >= selBox_r && r < selBox_r + 3 && c >= selBox_c && c < selBox_c + 3;

            if (inRow || inCol || inBox) {
              ctx.fillStyle = THEME_DIM;
              ctx.fillRect(c * CELL, GRID_TOP + r * CELL, CELL, CELL);
            }
          }
        }

        // Highlight selected cell
        ctx.fillStyle = THEME_MED;
        ctx.fillRect(selCol * CELL, GRID_TOP + selRow * CELL, CELL, CELL);

        // Highlight all cells with the same number as selected
        const selNum = board[selRow][selCol];
        if (selNum !== 0) {
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (board[r][c] === selNum && (r !== selRow || c !== selCol)) {
                ctx.fillStyle = THEME_DIM;
                ctx.fillRect(c * CELL, GRID_TOP + r * CELL, CELL, CELL);
              }
            }
          }
        }
      }

      // Thin grid lines
      ctx.strokeStyle = GRID_LINE;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 9; i++) {
        if (i % 3 === 0) continue; // skip thick lines for now
        // Vertical
        ctx.beginPath();
        ctx.moveTo(i * CELL, GRID_TOP);
        ctx.lineTo(i * CELL, GRID_TOP + GRID_SIZE);
        ctx.stroke();
        // Horizontal
        ctx.beginPath();
        ctx.moveTo(0, GRID_TOP + i * CELL);
        ctx.lineTo(GRID_SIZE, GRID_TOP + i * CELL);
        ctx.stroke();
      }

      // Thick lines for 3x3 boxes (with neon glow)
      ctx.strokeStyle = GRID_LINE_THICK;
      ctx.lineWidth = 2;
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      for (let i = 0; i <= 3; i++) {
        // Vertical
        ctx.beginPath();
        ctx.moveTo(i * 3 * CELL, GRID_TOP);
        ctx.lineTo(i * 3 * CELL, GRID_TOP + GRID_SIZE);
        ctx.stroke();
        // Horizontal
        ctx.beginPath();
        ctx.moveTo(0, GRID_TOP + i * 3 * CELL);
        ctx.lineTo(GRID_SIZE, GRID_TOP + i * 3 * CELL);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;

      // Selection border (bright glow)
      if (selRow >= 0 && selCol >= 0 && gameState === 'playing') {
        ctx.strokeStyle = THEME;
        ctx.lineWidth = 3;
        ctx.shadowColor = THEME;
        ctx.shadowBlur = 12;
        ctx.strokeRect(selCol * CELL + 1, GRID_TOP + selRow * CELL + 1, CELL - 2, CELL - 2);
        ctx.shadowBlur = 0;
      }
    }

    function drawNumbers() {
      if (!board) return;

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 24px Courier New';

      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const num = board[r][c];
          if (num === 0) continue;

          const x = c * CELL + CELL / 2;
          const y = GRID_TOP + r * CELL + CELL / 2;

          if (locked[r][c]) {
            // Pre-filled: dimmer color
            ctx.fillStyle = LOCKED_COLOR;
            ctx.shadowBlur = 0;
          } else if (hasConflict(r, c, num)) {
            // Error: red with glow
            ctx.fillStyle = ERROR_COLOR;
            ctx.shadowColor = ERROR_COLOR;
            ctx.shadowBlur = 10;
          } else {
            // Player-entered: theme color with glow
            ctx.fillStyle = PLAYER_COLOR;
            ctx.shadowColor = THEME;
            ctx.shadowBlur = 8;
          }

          ctx.fillText(num.toString(), x, y);
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawNumberPad() {
      // Draw a row of 1-9 buttons below the grid, plus a clear button
      const padY = NUM_PAD_TOP;
      const count_btns = 10;
      const gap = 4;
      const totalGap = gap * (count_btns + 1);
      const btnW = (GRID_SIZE - totalGap) / count_btns;
      const btnH = NUM_PAD_H - 10;

      ctx.font = 'bold 18px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i < count_btns; i++) {
        const x = gap + i * (btnW + gap);
        const label = i < 9 ? (i + 1).toString() : 'X';

        // Check if this number is fully placed (all 9 instances on board)
        let count = 0;
        if (i < 9 && board) {
          const num = i + 1;
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (board[r][c] === num) count++;
            }
          }
        }
        const depleted = count >= 9;

        // Background
        ctx.fillStyle = depleted ? '#111' : CELL_BG;
        ctx.fillRect(x, padY, btnW, btnH);

        // Border
        ctx.strokeStyle = depleted ? '#333' : GRID_LINE;
        ctx.lineWidth = 1;
        ctx.strokeRect(x, padY, btnW, btnH);

        // Label
        if (depleted) {
          ctx.fillStyle = '#333';
        } else if (i === 9) {
          ctx.fillStyle = ERROR_COLOR;
        } else {
          ctx.fillStyle = THEME;
          ctx.shadowColor = THEME;
          ctx.shadowBlur = 6;
        }
        ctx.fillText(label, x + btnW / 2, padY + btnH / 2);
        ctx.shadowBlur = 0;
      }
    }

    // --- Input Handling ---

    function getGridCell(mx, my) {
      if (my < GRID_TOP || my >= GRID_TOP + GRID_SIZE) return null;
      if (mx < 0 || mx >= GRID_SIZE) return null;
      const col = Math.floor(mx / CELL);
      const row = Math.floor((my - GRID_TOP) / CELL);
      if (row < 0 || row > 8 || col < 0 || col > 8) return null;
      return { row, col };
    }

    function getNumPadValue(mx, my) {
      if (my < NUM_PAD_TOP || my >= H) return null;
      const count_btns = 10;
      const gap = 4;
      const totalGap = gap * (count_btns + 1);
      const btnW = (GRID_SIZE - totalGap) / count_btns;
      for (let i = 0; i < count_btns; i++) {
        const x = gap + i * (btnW + gap);
        if (mx >= x && mx <= x + btnW) {
          return i < 9 ? i + 1 : 0; // 0 means clear
        }
      }
      return null;
    }

    function placeNumber(num) {
      if (selRow < 0 || selCol < 0) return;
      if (locked[selRow][selCol]) return;

      board[selRow][selCol] = num;
      draw();

      // Check for completion
      if (num !== 0 && isBoardComplete()) {
        gameOver(true);
      }
    }

    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing') return;
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (W / rect.width);
      const my = (e.clientY - rect.top) * (H / rect.height);

      // Check grid
      const cell = getGridCell(mx, my);
      if (cell) {
        selRow = cell.row;
        selCol = cell.col;
        draw();
        return;
      }

      // Check number pad
      const num = getNumPadValue(mx, my);
      if (num !== null) {
        placeNumber(num);
        return;
      }
    });

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ' || e.key === 'Enter') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        switch (e.key) {
          case 'ArrowUp':
            if (selRow > 0) selRow--;
            draw();
            break;
          case 'ArrowDown':
            if (selRow < 8) selRow++;
            draw();
            break;
          case 'ArrowLeft':
            if (selCol > 0) selCol--;
            draw();
            break;
          case 'ArrowRight':
            if (selCol < 8) selCol++;
            draw();
            break;
          case '1': case '2': case '3': case '4': case '5':
          case '6': case '7': case '8': case '9':
            placeNumber(parseInt(e.key));
            break;
          case 'Backspace':
          case 'Delete':
            placeNumber(0);
            break;
        }
      }
    });

    // Expose game data for ML pipeline
    window.gameData = {
      get board() { return board; },
      get solution() { return solution; },
      get selectedCell() { return { row: selRow, col: selCol }; },
      get elapsed() { return elapsed; }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kart Racer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f44; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 68, 0.5); }
    h1 { color: #f44; font-size: 1.6rem; text-shadow: 0 0 15px rgba(255, 68, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f44; }
    canvas {
      border: 2px solid #f44;
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f44;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>KART RACER</h1>
  </div>
  <div class="score-bar">
    <div>Lap: <span id="lap">0/3</span> | Pos: <span id="pos">-</span></div>
    <div>Item: <span id="item">None</span> | Score: <span id="score">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">KART RACER</h2>
      <p id="overlayText">Click to Start<br><br>Arrow Keys: Steer/Accel/Brake<br>Space: Use Item | Z: Drift</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const lapEl = document.getElementById('lap');
    const posEl = document.getElementById('pos');
    const itemEl = document.getElementById('item');
    const scoreEl = document.getElementById('score');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let gameState = 'menu';
    let score = 0;

    // Track definitions - each track is a series of waypoints forming a closed loop
    const tracks = [
      { // Track 1: Classic Oval-ish
        name: 'Mushroom Circuit',
        bg: '#2a5e2a',
        waypoints: [
          {x:300,y:420},{x:160,y:400},{x:80,y:340},{x:60,y:260},{x:80,y:180},
          {x:140,y:120},{x:220,y:80},{x:320,y:70},{x:420,y:80},{x:490,y:120},
          {x:530,y:200},{x:540,y:300},{x:520,y:370},{x:460,y:420},{x:380,y:430}
        ],
        trackWidth: 52,
        itemBoxes: [0,3,6,9,12]
      },
      { // Track 2: Figure-8
        name: 'Shell Speedway',
        bg: '#3a3a1e',
        waypoints: [
          {x:300,y:440},{x:180,y:410},{x:100,y:350},{x:80,y:270},{x:120,y:200},
          {x:200,y:160},{x:300,y:200},{x:400,y:250},{x:480,y:200},{x:520,y:140},
          {x:500,y:80},{x:420,y:60},{x:340,y:80},{x:300,y:140},{x:260,y:200},
          {x:200,y:280},{x:160,y:350},{x:200,y:410},{x:300,y:440}
        ],
        trackWidth: 46,
        itemBoxes: [0,4,8,12,16]
      },
      { // Track 3: Technical
        name: 'Rainbow Road',
        bg: '#1a1a3e',
        waypoints: [
          {x:300,y:450},{x:150,y:430},{x:60,y:380},{x:40,y:300},{x:60,y:220},
          {x:120,y:160},{x:200,y:120},{x:260,y:80},{x:340,y:60},{x:440,y:70},
          {x:520,y:110},{x:560,y:180},{x:540,y:260},{x:480,y:310},{x:400,y:330},
          {x:350,y:360},{x:400,y:400},{x:480,y:420},{x:520,y:440},{x:460,y:460},
          {x:380,y:460}
        ],
        trackWidth: 40,
        itemBoxes: [0,4,8,12,16,19]
      }
    ];

    let currentTrack = 0;
    let raceNum = 0;

    // Kart definitions
    const kartDefs = [
      { name: 'Player', color: '#f44', weight: 1.0, maxSpeed: 3.8, accel: 0.06, handling: 0.045 },
      { name: 'Luigi', color: '#4f4', weight: 1.1, maxSpeed: 3.6, accel: 0.055, handling: 0.05 },
      { name: 'Toad', color: '#44f', weight: 0.8, maxSpeed: 4.0, accel: 0.07, handling: 0.04 },
      { name: 'Bowser', color: '#fa0', weight: 1.4, maxSpeed: 3.4, accel: 0.045, handling: 0.055 }
    ];

    // Game objects
    let karts = [];
    let shells = [];
    let bananas = [];
    let itemBoxes = [];
    let particles = [];
    let countdownTimer = 0;
    let raceFinished = false;
      raceEndTimer = 0;
    let raceEndTimer = 0;
    let finishOrder = [];
    let keys = {};

    // Input
    document.addEventListener('keydown', e => { keys[e.key] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    overlay.addEventListener('click', () => {
      if (gameState === 'menu') {
        startGrandPrix();
      } else if (gameState === 'results') {
        startGrandPrix();
      } else if (gameState === 'raceEnd') {
        nextRace();
      }
    });
    overlay.style.pointerEvents = 'auto';
    overlay.style.cursor = 'pointer';

    // Track helper functions
    function getTrackPoint(track, t) {
      const wp = track.waypoints;
      const n = wp.length;
      const idx = ((t % n) + n) % n;
      const i = Math.floor(idx);
      const f = idx - i;
      const p0 = wp[i % n];
      const p1 = wp[(i + 1) % n];
      return { x: p0.x + (p1.x - p0.x) * f, y: p0.y + (p1.y - p0.y) * f };
    }

    function getTrackDir(track, t) {
      const wp = track.waypoints;
      const n = wp.length;
      const i = Math.floor(((t % n) + n) % n);
      const p0 = wp[i % n];
      const p1 = wp[(i + 1) % n];
      const dx = p1.x - p0.x;
      const dy = p1.y - p0.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      return { x: dx / len, y: dy / len };
    }

    function closestTrackParam(track, px, py) {
      const wp = track.waypoints;
      const n = wp.length;
      let bestT = 0, bestDist = Infinity;
      for (let i = 0; i < n; i++) {
        for (let f = 0; f < 1; f += 0.1) {
          const p = getTrackPoint(track, i + f);
          const dx = px - p.x, dy = py - p.y;
          const d = dx * dx + dy * dy;
          if (d < bestDist) { bestDist = d; bestT = i + f; }
        }
      }
      // Refine
      for (let f = -0.1; f <= 0.1; f += 0.02) {
        const t = bestT + f;
        const p = getTrackPoint(track, t);
        const dx = px - p.x, dy = py - p.y;
        const d = dx * dx + dy * dy;
        if (d < bestDist) { bestDist = d; bestT = t; }
      }
      return { t: bestT, dist: Math.sqrt(bestDist) };
    }

    function isOnTrack(track, px, py) {
      const info = closestTrackParam(track, px, py);
      return info.dist < track.trackWidth;
    }

    function dist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
    function angleDiff(a, b) { let d = b - a; while (d > Math.PI) d -= 2 * Math.PI; while (d < -Math.PI) d += 2 * Math.PI; return d; }

    // Kart class
    function createKart(def, index, track) {
      const startT = -index * 0.6;
      const sp = getTrackPoint(track, startT);
      const sd = getTrackDir(track, startT);
      const angle = Math.atan2(sd.y, sd.x);
      return {
        x: sp.x, y: sp.y, angle: angle,
        speed: 0, def: def, index: index,
        isPlayer: index === 0,
        lap: 0, trackParam: startT, lastCheckpoint: -1,
        item: null, itemName: 'None',
        drifting: false, driftDir: 0, driftTimer: 0, driftBoost: 0,
        boostTimer: 0, starTimer: 0, spinTimer: 0, invincTimer: 0,
        finished: false, finishTime: 0,
        aiTargetT: startT + 2, aiItemTimer: 0, aiDriftTimer: 0,
        // Smoothed values for AI
        steerSmooth: 0
      };
    }

    function startGrandPrix() {
      score = 0;
      raceNum = 0;
      currentTrack = 0;
      scoreEl.textContent = '0';
      startRace();
    }

    function startRace() {
      const track = tracks[currentTrack];
      karts = kartDefs.map((d, i) => createKart(d, i, track));
      shells = [];
      bananas = [];
      particles = [];
      finishOrder = [];
      raceFinished = false;
      raceEndTimer = 0;
      countdownTimer = 180; // 3 seconds

      // Place item boxes
      itemBoxes = [];
      track.itemBoxes.forEach(idx => {
        const p = getTrackPoint(track, idx + 0.5);
        // Place 3 boxes across the track
        const d = getTrackDir(track, idx + 0.5);
        const nx = -d.y, ny = d.x;
        for (let s = -1; s <= 1; s++) {
          itemBoxes.push({
            x: p.x + nx * s * 20,
            y: p.y + ny * s * 20,
            active: true,
            respawnTimer: 0,
            baseX: p.x + nx * s * 20,
            baseY: p.y + ny * s * 20
          });
        }
      });

      overlay.style.display = 'none';
      gameState = 'countdown';
    }

    function nextRace() {
      raceNum++;
      currentTrack = (currentTrack + 1) % tracks.length;
      if (raceNum >= 3) {
        // Grand Prix over
        gameState = 'results';
        overlay.style.display = 'flex';
        overlayTitle.textContent = 'GRAND PRIX COMPLETE!';
        overlayText.textContent = 'Total Score: ' + score + '\n\nClick to Play Again';
        return;
      }
      startRace();
    }

    // Items
    const ITEMS = ['Mushroom', 'Shell', 'Banana', 'Star'];

    function giveRandomItem(kart) {
      // Better items for karts in worse positions
      const pos = getPosition(kart);
      let weights;
      if (pos <= 1) weights = [3, 3, 3, 1]; // Leader gets balanced
      else if (pos === 2) weights = [3, 2, 2, 2];
      else weights = [4, 2, 1, 3]; // Trailing gets boosts and stars
      const total = weights.reduce((a, b) => a + b);
      let r = Math.random() * total;
      for (let i = 0; i < ITEMS.length; i++) {
        r -= weights[i];
        if (r <= 0) { kart.item = i; kart.itemName = ITEMS[i]; return; }
      }
      kart.item = 0; kart.itemName = 'Mushroom';
    }

    function useItem(kart) {
      if (kart.item === null) return;
      const item = kart.item;
      kart.item = null;
      kart.itemName = 'None';

      switch (item) {
        case 0: // Mushroom - speed boost
          kart.boostTimer = 30;
          spawnParticles(kart.x, kart.y, '#ff0', 8);
          break;
        case 1: // Shell - fire forward
          shells.push({
            x: kart.x + Math.cos(kart.angle) * 20,
            y: kart.y + Math.sin(kart.angle) * 20,
            vx: Math.cos(kart.angle) * 6,
            vy: Math.sin(kart.angle) * 6,
            owner: kart.index, life: 180,
            bounces: 3
          });
          break;
        case 2: // Banana - drop behind
          bananas.push({
            x: kart.x - Math.cos(kart.angle) * 25,
            y: kart.y - Math.sin(kart.angle) * 25,
            owner: kart.index
          });
          break;
        case 3: // Star - invincibility
          kart.starTimer = 180;
          kart.invincTimer = 180;
          break;
      }
    }

    function getPosition(kart) {
      let pos = 1;
      const progress = kart.lap * tracks[currentTrack].waypoints.length + kart.trackParam;
      for (const other of karts) {
        if (other === kart) continue;
        const op = other.lap * tracks[currentTrack].waypoints.length + other.trackParam;
        if (op > progress) pos++;
      }
      return pos;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * 2 + 1;
        particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 20 + Math.random() * 20, color, size: 2 + Math.random() * 3 });
      }
    }

    // Update
    function update() {
      if (gameState === 'countdown') {
        countdownTimer--;
        if (countdownTimer <= 0) gameState = 'racing';
        return;
      }
      if (gameState !== 'racing') return;

      const track = tracks[currentTrack];
      const numWP = track.waypoints.length;

      // Update karts
      for (const kart of karts) {
        if (kart.finished) continue;

        // Timers
        if (kart.boostTimer > 0) kart.boostTimer--;
        if (kart.starTimer > 0) kart.starTimer--;
        if (kart.invincTimer > 0) kart.invincTimer--;
        if (kart.spinTimer > 0) { kart.spinTimer--; kart.angle += 0.3; kart.speed *= 0.95; continue; }

        let accelInput = 0, steerInput = 0, driftInput = false, useItemInput = false;

        if (kart.isPlayer) {
          // Player input
          if (keys['ArrowUp'] || keys['w']) accelInput = 1;
          if (keys['ArrowDown'] || keys['s']) accelInput = -0.5;
          if (keys['ArrowLeft'] || keys['a']) steerInput = -1;
          if (keys['ArrowRight'] || keys['d']) steerInput = 1;
          if (keys['z'] || keys['Z']) driftInput = true;
          if (keys[' ']) { useItemInput = true; keys[' '] = false; }
        } else {
          // AI
          const ai = updateAI(kart, track);
          accelInput = ai.accel;
          steerInput = ai.steer;
          driftInput = ai.drift;
          useItemInput = ai.useItem;
        }

        // Use item
        if (useItemInput && kart.item !== null) useItem(kart);

        // Acceleration
        let maxSpd = kart.def.maxSpeed;
        if (kart.boostTimer > 0) maxSpd *= 1.5;
        if (kart.starTimer > 0) maxSpd *= 1.3;
        if (kart.driftBoost > 0) { maxSpd *= 1.3; kart.driftBoost--; }

        // Off-track slowdown
        if (!isOnTrack(track, kart.x, kart.y)) {
          maxSpd *= 0.5;
          kart.speed *= 0.98;
        }

        if (accelInput > 0) {
          kart.speed += kart.def.accel * accelInput;
        } else if (accelInput < 0) {
          kart.speed += accelInput * 0.04;
        } else {
          kart.speed *= 0.99;
        }
        kart.speed = Math.max(-1, Math.min(maxSpd, kart.speed));

        // Steering
        let turnRate = kart.def.handling;
        if (kart.drifting) turnRate *= 1.4;
        if (Math.abs(kart.speed) < 0.5) turnRate *= Math.abs(kart.speed) / 0.5;

        kart.angle += steerInput * turnRate * (kart.speed > 0 ? 1 : -1);

        // Drifting
        if (driftInput && Math.abs(kart.speed) > 2 && steerInput !== 0) {
          if (!kart.drifting) {
            kart.drifting = true;
            kart.driftDir = steerInput > 0 ? 1 : -1;
            kart.driftTimer = 0;
          }
          kart.driftTimer++;
          kart.angle += kart.driftDir * 0.015;
          // Drift particles
          if (kart.driftTimer % 3 === 0) {
            const driftColor = kart.driftTimer > 60 ? '#f0f' : kart.driftTimer > 30 ? '#fa0' : '#48f';
            spawnParticles(kart.x - Math.cos(kart.angle) * 10, kart.y - Math.sin(kart.angle) * 10, driftColor, 1);
          }
        } else {
          if (kart.drifting && kart.driftTimer > 20) {
            // Release drift boost
            kart.driftBoost = kart.driftTimer > 60 ? 45 : kart.driftTimer > 30 ? 25 : 12;
            spawnParticles(kart.x, kart.y, '#ff0', 6);
          }
          kart.drifting = false;
          kart.driftTimer = 0;
        }

        // Move
        kart.x += Math.cos(kart.angle) * kart.speed;
        kart.y += Math.sin(kart.angle) * kart.speed;

        // Boundary
        kart.x = Math.max(10, Math.min(W - 10, kart.x));
        kart.y = Math.max(10, Math.min(H - 10, kart.y));

        // Track progress
        const info = closestTrackParam(track, kart.x, kart.y);
        const prevParam = kart.trackParam;
        const newParam = info.t;

        // Detect lap crossing (wrap around)
        const dParam = newParam - prevParam;
        if (dParam < -numWP / 2) {
          // Crossed finish line forward
          kart.lap++;
          if (kart.lap >= 3) {
            kart.finished = true;
            kart.finishTime = performance.now();
            finishOrder.push(kart.index);
            if (kart.isPlayer) {
              const pos = finishOrder.length;
              const points = [10, 7, 4, 2][pos - 1] || 1;
              score += points;
              scoreEl.textContent = score;
            }
          }
        } else if (dParam > numWP / 2) {
          // Went backwards past start
          kart.lap = Math.max(0, kart.lap - 1);
        }
        kart.trackParam = newParam;

        // Boost particles
        if (kart.boostTimer > 0 || kart.driftBoost > 0) {
          spawnParticles(kart.x - Math.cos(kart.angle) * 12, kart.y - Math.sin(kart.angle) * 12, '#f80', 1);
        }
        // Star effect
        if (kart.starTimer > 0 && Math.random() < 0.3) {
          const colors = ['#f00', '#ff0', '#0f0', '#0ff', '#f0f'];
          spawnParticles(kart.x, kart.y, colors[Math.floor(Math.random() * 5)], 1);
        }

        // Item box collision
        for (const box of itemBoxes) {
          if (!box.active) continue;
          if (dist(kart, box) < 18 && kart.item === null) {
            box.active = false;
            box.respawnTimer = 180;
            giveRandomItem(kart);
            if (kart.isPlayer) itemEl.textContent = kart.itemName;
            spawnParticles(box.x, box.y, '#ff0', 6);
          }
        }

        // Banana collision
        for (let i = bananas.length - 1; i >= 0; i--) {
          if (dist(kart, bananas[i]) < 16 && bananas[i].owner !== kart.index && kart.invincTimer <= 0) {
            kart.spinTimer = 30;
            kart.speed *= 0.3;
            spawnParticles(kart.x, kart.y, '#ff0', 10);
            bananas.splice(i, 1);
          } else if (kart.starTimer > 0 && dist(kart, bananas[i]) < 16) {
            bananas.splice(i, 1);
          }
        }
      }

      // Kart-kart collision
      for (let i = 0; i < karts.length; i++) {
        for (let j = i + 1; j < karts.length; j++) {
          const a = karts[i], b = karts[j];
          if (a.finished || b.finished) continue;
          const d = dist(a, b);
          if (d < 20) {
            const nx = (b.x - a.x) / (d || 1);
            const ny = (b.y - a.y) / (d || 1);
            const overlap = 20 - d;
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;

            // Star collision
            if (a.starTimer > 0 && b.invincTimer <= 0) { b.spinTimer = 30; b.speed *= 0.2; }
            if (b.starTimer > 0 && a.invincTimer <= 0) { a.spinTimer = 30; a.speed *= 0.2; }

            // Weight-based bump
            const totalW = a.def.weight + b.def.weight;
            const bumpA = b.def.weight / totalW;
            const bumpB = a.def.weight / totalW;
            a.speed -= bumpA * 0.3;
            b.speed -= bumpB * 0.3;
          }
        }
      }

      // Update shells
      for (let i = shells.length - 1; i >= 0; i--) {
        const s = shells[i];
        s.x += s.vx;
        s.y += s.vy;
        s.life--;

        // Bounce off boundaries
        if (s.x < 5 || s.x > W - 5) { s.vx *= -1; s.bounces--; }
        if (s.y < 5 || s.y > H - 5) { s.vy *= -1; s.bounces--; }

        if (s.life <= 0 || s.bounces <= 0) { shells.splice(i, 1); continue; }

        // Hit karts
        for (const kart of karts) {
          if (kart.finished || kart.index === s.owner) continue;
          if (dist(kart, s) < 18) {
            if (kart.invincTimer > 0 || kart.starTimer > 0) {
              // Destroy shell
              shells.splice(i, 1);
              spawnParticles(s.x, s.y, '#0f0', 8);
              break;
            }
            kart.spinTimer = 40;
            kart.speed *= 0.1;
            spawnParticles(kart.x, kart.y, '#f44', 12);
            shells.splice(i, 1);
            break;
          }
        }
      }

      // Respawn item boxes
      for (const box of itemBoxes) {
        if (!box.active) {
          box.respawnTimer--;
          if (box.respawnTimer <= 0) box.active = true;
        }
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.95;
        p.vy *= 0.95;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update player HUD
      const player = karts[0];
      if (player) {
        lapEl.textContent = Math.min(player.lap + 1, 3) + '/3';
        posEl.textContent = getPosition(player) + getSuffix(getPosition(player));
        itemEl.textContent = player.itemName;
      }

      // Check race end
      if (finishOrder.length >= 4 || (finishOrder.length > 0 && karts.every(k => k.finished || k.lap >= 3))) {
        endRace();
      }
      // Auto-finish remaining after leader finishes + delay
      if (finishOrder.length > 0 && !raceFinished) {
        raceEndTimer++;
        if (raceEndTimer > 300) { // 5 seconds after first finish
          endRace();
        }
      }
    }

    function getSuffix(n) {
      if (n === 1) return 'st';
      if (n === 2) return 'nd';
      if (n === 3) return 'rd';
      return 'th';
    }

    function endRace() {
      if (raceFinished) return;
      raceFinished = true;
      // Fill remaining positions
      for (const kart of karts) {
        if (!kart.finished) {
          kart.finished = true;
          finishOrder.push(kart.index);
          if (kart.isPlayer) {
            const pos = finishOrder.indexOf(kart.index) + 1;
            const points = [10, 7, 4, 2][pos - 1] || 1;
            score += points;
            scoreEl.textContent = score;
          }
        }
      }

      gameState = 'raceEnd';
      const playerPos = finishOrder.indexOf(0) + 1;

      let resultText = tracks[currentTrack].name + '\n\n';
      finishOrder.forEach((idx, i) => {
        resultText += (i + 1) + getSuffix(i + 1) + ': ' + kartDefs[idx].name + '\n';
      });
      resultText += '\nRace ' + (raceNum + 1) + '/3 | Total Score: ' + score;
      if (raceNum < 2) resultText += '\n\nClick for Next Race';
      else resultText += '\n\nClick to See Results';

      overlay.style.display = 'flex';
      overlayTitle.textContent = playerPos + getSuffix(playerPos) + ' Place!';
      overlayText.innerHTML = resultText.replace(/\n/g, '<br>');
    }

    // AI
    function updateAI(kart, track) {
      const numWP = track.waypoints.length;
      let accel = 1, steer = 0, drift = false, useItemFlag = false;

      // Look ahead on track
      const lookAhead = 2.5 + kart.speed * 0.5;
      const targetT = kart.trackParam + lookAhead;
      const targetPt = getTrackPoint(track, targetT);

      // Angle to target
      const toTarget = Math.atan2(targetPt.y - kart.y, targetPt.x - kart.x);
      let angleDelta = angleDiff(kart.angle, toTarget);

      // Smoother steering
      kart.steerSmooth += (angleDelta * 8 - kart.steerSmooth) * 0.15;
      steer = Math.max(-1, Math.min(1, kart.steerSmooth));

      // Check for sharp turns ahead - look further
      const farLook = kart.trackParam + lookAhead * 2;
      const farPt = getTrackPoint(track, farLook);
      const farAngle = Math.atan2(farPt.y - kart.y, farPt.x - kart.x);
      const farDelta = Math.abs(angleDiff(kart.angle, farAngle));

      // Brake for sharp turns
      if (farDelta > 0.8 && kart.speed > 2.5) {
        accel = -0.3;
      }

      // AI drifting on sharp turns
      if (Math.abs(angleDelta) > 0.4 && kart.speed > 2) {
        kart.aiDriftTimer++;
        if (kart.aiDriftTimer > 10) drift = true;
      } else {
        kart.aiDriftTimer = 0;
      }

      // Avoid bananas
      for (const banana of bananas) {
        const d = dist(kart, banana);
        if (d < 60) {
          const bAngle = Math.atan2(banana.y - kart.y, banana.x - kart.x);
          const bDelta = angleDiff(kart.angle, bAngle);
          if (Math.abs(bDelta) < 0.5) {
            steer -= Math.sign(bDelta) * 0.5;
          }
        }
      }

      // Item usage AI
      if (kart.item !== null) {
        kart.aiItemTimer++;
        if (kart.aiItemTimer > 60 + Math.random() * 120) {
          // Use mushroom anytime
          if (kart.item === 0) useItemFlag = true;
          // Use shell when someone is ahead and roughly in front
          if (kart.item === 1) {
            for (const other of karts) {
              if (other === kart || other.finished) continue;
              const d = dist(kart, other);
              if (d < 150) {
                const a = Math.atan2(other.y - kart.y, other.x - kart.x);
                if (Math.abs(angleDiff(kart.angle, a)) < 0.5) { useItemFlag = true; break; }
              }
            }
            if (!useItemFlag && kart.aiItemTimer > 180) useItemFlag = true;
          }
          // Drop banana
          if (kart.item === 2) useItemFlag = true;
          // Star: use when in combat or behind
          if (kart.item === 3) {
            if (getPosition(kart) > 1 || kart.aiItemTimer > 120) useItemFlag = true;
          }
          if (useItemFlag) kart.aiItemTimer = 0;
        }
      } else {
        kart.aiItemTimer = 0;
      }

      // Steer clamp
      steer = Math.max(-1, Math.min(1, steer));

      return { accel, steer, drift, useItem: useItemFlag };
    }

    // Drawing
    function draw() {
      const track = tracks[currentTrack];
      // Background
      ctx.fillStyle = track.bg;
      ctx.fillRect(0, 0, W, H);

      // Draw grass pattern
      ctx.globalAlpha = 0.15;
      for (let i = 0; i < 200; i++) {
        const gx = (i * 137.5) % W;
        const gy = (i * 97.3) % H;
        ctx.fillStyle = '#0a0';
        ctx.fillRect(gx, gy, 2, 4);
      }
      ctx.globalAlpha = 1;

      // Draw track
      drawTrack(track);

      // Draw start/finish line
      const sfp = getTrackPoint(track, 0);
      const sfd = getTrackDir(track, 0);
      ctx.save();
      ctx.translate(sfp.x, sfp.y);
      ctx.rotate(Math.atan2(sfd.y, sfd.x));
      ctx.fillStyle = '#fff';
      const tw = track.trackWidth;
      for (let r = -tw; r < tw; r += 6) {
        for (let c = -4; c < 4; c += 6) {
          if (((Math.floor(r / 6) + Math.floor(c / 6)) % 2) === 0) {
            ctx.fillStyle = '#fff';
          } else {
            ctx.fillStyle = '#111';
          }
          ctx.fillRect(c, r, 6, 6);
        }
      }
      ctx.restore();

      // Draw item boxes
      const time = performance.now() / 1000;
      for (const box of itemBoxes) {
        if (!box.active) continue;
        const bob = Math.sin(time * 3 + box.x) * 3;
        ctx.save();
        ctx.translate(box.x, box.y + bob);
        ctx.rotate(time * 2);
        // ? block
        ctx.fillStyle = '#fc0';
        ctx.fillRect(-8, -8, 16, 16);
        ctx.strokeStyle = '#a80';
        ctx.lineWidth = 2;
        ctx.strokeRect(-8, -8, 16, 16);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', 0, 1);
        ctx.restore();
      }

      // Draw bananas
      for (const banana of bananas) {
        ctx.save();
        ctx.translate(banana.x, banana.y);
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(-4, 0, 5, 0.3, Math.PI - 0.3);
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#ff0';
        ctx.stroke();
        ctx.fillStyle = '#a80';
        ctx.beginPath();
        ctx.arc(-4, -2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Draw shells
      for (const shell of shells) {
        ctx.save();
        ctx.translate(shell.x, shell.y);
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#080';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#8f8';
        ctx.beginPath();
        ctx.arc(-1, -1, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Draw karts (sorted by y for pseudo-depth)
      const sortedKarts = [...karts].sort((a, b) => a.y - b.y);
      for (const kart of sortedKarts) {
        drawKart(kart);
      }

      // Draw particles
      for (const p of particles) {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
      ctx.globalAlpha = 1;

      // Countdown
      if (gameState === 'countdown') {
        const sec = Math.ceil(countdownTimer / 60);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, W, H);
        ctx.font = 'bold 80px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = sec > 0 ? '#f44' : '#0f0';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.fillText(sec > 0 ? sec : 'GO!', W / 2, H / 2);
        ctx.shadowBlur = 0;

        // Track name
        ctx.font = '20px Courier New';
        ctx.fillStyle = '#fff';
        ctx.fillText(tracks[currentTrack].name, W / 2, H / 2 - 60);
        ctx.fillText('Race ' + (raceNum + 1) + '/3', W / 2, H / 2 + 60);
      }

      // Mini-map
      drawMiniMap(track);

      // Item display
      if (karts[0] && karts[0].item !== null) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(W - 70, 10, 60, 60);
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 2;
        ctx.strokeRect(W - 70, 10, 60, 60);
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.fillText(karts[0].itemName, W - 40, 45);

        // Item icon
        ctx.font = '24px Courier New';
        const icons = ['üçÑ', 'üê¢', 'üçå', '‚≠ê'];
        if (karts[0].item < icons.length) {
          ctx.fillText(icons[karts[0].item], W - 40, 32);
        }
      }
    }

    function drawTrack(track) {
      const wp = track.waypoints;
      const n = wp.length;
      const tw = track.trackWidth;

      // Draw track border (outer)
      ctx.beginPath();
      for (let t = 0; t < n; t += 0.2) {
        const p = getTrackPoint(track, t);
        const d = getTrackDir(track, t);
        const nx = -d.y, ny = d.x;
        const px = p.x + nx * (tw + 4), py = p.y + ny * (tw + 4);
        if (t === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 3;
      ctx.stroke();

      // Draw track surface
      ctx.beginPath();
      for (let t = 0; t < n; t += 0.15) {
        const p = getTrackPoint(track, t);
        const d = getTrackDir(track, t);
        const nx = -d.y, ny = d.x;
        const px = p.x + nx * tw, py = p.y + ny * tw;
        if (t === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      // Go back on the other side
      for (let t = n; t >= 0; t -= 0.15) {
        const p = getTrackPoint(track, t);
        const d = getTrackDir(track, t);
        const nx = -d.y, ny = d.x;
        const px = p.x - nx * tw, py = p.y - ny * tw;
        ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = '#555';
      ctx.fill();

      // Track center line (dashed)
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      for (let t = 0; t < n; t += 0.2) {
        const p = getTrackPoint(track, t);
        if (t === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.setLineDash([]);

      // Inner border
      ctx.beginPath();
      for (let t = 0; t < n; t += 0.2) {
        const p = getTrackPoint(track, t);
        const d = getTrackDir(track, t);
        const nx = -d.y, ny = d.x;
        const px = p.x - nx * (tw + 4), py = p.y - ny * (tw + 4);
        if (t === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 3;
      ctx.stroke();

      // Rumble strips on borders
      for (let t = 0; t < n; t += 0.4) {
        const p = getTrackPoint(track, t);
        const d = getTrackDir(track, t);
        const nx = -d.y, ny = d.x;
        const isRed = Math.floor(t * 3) % 2 === 0;
        ctx.fillStyle = isRed ? '#f44' : '#fff';
        // Outer rumble
        ctx.fillRect(p.x + nx * tw - 2, p.y + ny * tw - 2, 4, 4);
        // Inner rumble
        ctx.fillRect(p.x - nx * tw - 2, p.y - ny * tw - 2, 4, 4);
      }
    }

    function drawKart(kart) {
      ctx.save();
      ctx.translate(kart.x, kart.y);

      if (kart.spinTimer > 0) {
        // Spin visual handled by angle change in update
      }

      ctx.rotate(kart.angle);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(2, 2, 12, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Star rainbow effect
      let bodyColor = kart.def.color;
      if (kart.starTimer > 0) {
        const hue = (performance.now() / 20) % 360;
        bodyColor = `hsl(${hue}, 100%, 60%)`;
      }

      // Kart body
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.lineTo(-10, -8);
      ctx.lineTo(-12, -6);
      ctx.lineTo(-12, 6);
      ctx.lineTo(-10, 8);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Windshield
      ctx.fillStyle = '#8cf';
      ctx.fillRect(2, -4, 5, 8);

      // Wheels
      ctx.fillStyle = '#222';
      ctx.fillRect(-10, -10, 6, 3);
      ctx.fillRect(-10, 7, 6, 3);
      ctx.fillRect(6, -10, 6, 3);
      ctx.fillRect(6, 7, 6, 3);

      // Boost flame
      if (kart.boostTimer > 0 || kart.driftBoost > 0) {
        ctx.fillStyle = '#f80';
        ctx.beginPath();
        ctx.moveTo(-12, -3);
        ctx.lineTo(-20 - Math.random() * 8, 0);
        ctx.lineTo(-12, 3);
        ctx.fill();
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.moveTo(-12, -2);
        ctx.lineTo(-16 - Math.random() * 5, 0);
        ctx.lineTo(-12, 2);
        ctx.fill();
      }

      // Drift sparks
      if (kart.drifting) {
        const sparkColor = kart.driftTimer > 60 ? '#f0f' : kart.driftTimer > 30 ? '#fa0' : '#48f';
        ctx.fillStyle = sparkColor;
        for (let i = 0; i < 3; i++) {
          const sx = -10 + Math.random() * 4 - 2;
          const sy = (kart.driftDir > 0 ? 8 : -8) + Math.random() * 4 - 2;
          ctx.fillRect(sx, sy, 2, 2);
        }
      }

      ctx.restore();

      // Name label
      if (!kart.isPlayer) {
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.7;
        ctx.fillText(kart.def.name, kart.x, kart.y - 18);
        ctx.globalAlpha = 1;
      } else {
        ctx.font = 'bold 9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ff0';
        ctx.fillText('YOU', kart.x, kart.y - 18);
      }
    }

    function drawMiniMap(track) {
      const mx = 10, my = H - 90, mw = 80, mh = 70;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(mx, my, mw, mh);
      ctx.strokeStyle = '#f44';
      ctx.lineWidth = 1;
      ctx.strokeRect(mx, my, mw, mh);

      const wp = track.waypoints;
      // Find bounds
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of wp) {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
      }
      const sx = (mw - 10) / (maxX - minX || 1);
      const sy = (mh - 10) / (maxY - minY || 1);
      const s = Math.min(sx, sy);
      const ox = mx + 5 + (mw - 10 - (maxX - minX) * s) / 2;
      const oy = my + 5 + (mh - 10 - (maxY - minY) * s) / 2;

      // Draw track on mini map
      ctx.beginPath();
      for (let i = 0; i < wp.length; i++) {
        const px = ox + (wp[i].x - minX) * s;
        const py = oy + (wp[i].y - minY) * s;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw kart positions
      for (const kart of karts) {
        const px = ox + (kart.x - minX) * s;
        const py = oy + (kart.y - minY) * s;
        ctx.fillStyle = kart.def.color;
        ctx.beginPath();
        ctx.arc(px, py, kart.isPlayer ? 3 : 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Main loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

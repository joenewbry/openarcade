<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Building Race</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f94; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 153, 68, 0.5); }
    h1 { color: #f94; font-size: 1.4rem; text-shadow: 0 0 15px rgba(255, 153, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #f94; }
    canvas {
      border: 2px solid #f94;
      box-shadow: 0 0 20px rgba(255, 153, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f94;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 153, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .highlight { color: #f94; font-size: 1.1rem; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BRIDGE BUILDING RACE</h1>
  </div>
  <div class="score-bar">
    <div>Level: <span id="level">1</span> | Budget: <span id="budget">0</span></div>
    <div>You: <span id="playerScore">0</span> | AI: <span id="aiScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BRIDGE BUILDING RACE</h2>
      <p id="overlayText">Click to Start</p>
      <p class="highlight" id="overlayDetail"></p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const levelEl = document.getElementById('level');
    const budgetEl = document.getElementById('budget');
    const playerScoreEl = document.getElementById('playerScore');
    const aiScoreEl = document.getElementById('aiScore');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlayDetail = document.getElementById('overlayDetail');

    let gameState; // 'waiting','building','testing','levelComplete','gameOver'
    let score = 0;
    let aiTotalScore = 0;
    let playerTotalScore = 0;
    let currentLevel = 0;

    // Split screen: left = player (0..299), right = AI (300..599)
    const SPLIT = 300;
    const HALF_W = 300;
    const GROUND_Y = 300;
    const GRAVITY = 0.35;
    const SUB_STEPS = 4;
    const BEAM_BREAK_FORCE = 280;

    // Level definitions: gap width, budget, truck weight
    const LEVELS = [
      { gap: 80,  budget: 500, truckWeight: 12, name: 'Easy Creek' },
      { gap: 110, budget: 600, truckWeight: 14, name: 'River Crossing' },
      { gap: 140, budget: 700, truckWeight: 16, name: 'Canyon Pass' },
      { gap: 170, budget: 850, truckWeight: 18, name: 'Deep Gorge' },
      { gap: 200, budget: 1000, truckWeight: 20, name: 'Grand Chasm' }
    ];

    // Node / beam structures for player and AI
    let playerNodes, playerBeams, playerBudgetUsed;
    let aiNodes, aiBeams, aiBudgetUsed;
    let selectedNode = null;
    let hoverNode = null;
    let currentBudget = 0;

    // Physics sim state
    let simPlayer, simAI;
    let truckPlayer, truckAI;
    let testPhase = ''; // 'simulating', 'done'
    let testTimer = 0;
    let playerBridgeFailed, aiBridgeFailed;
    let playerTruckDist, aiTruckDist;

    // Level geometry
    let gapLeft, gapRight, gapDepth;

    // ==============================
    // NODE / BEAM HELPERS
    // ==============================
    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function createNode(x, y, fixed) {
      return { x, y, ox: x, oy: y, vx: 0, vy: 0, fixed: !!fixed };
    }

    function createBeam(n1, n2) {
      const len = dist(n1, n2);
      return { n1, n2, restLength: len, broken: false, stress: 0 };
    }

    function beamLength(b) {
      return dist(b.n1, b.n2);
    }

    function totalBeamCost(beams) {
      let total = 0;
      for (const b of beams) total += b.restLength;
      return Math.round(total);
    }

    // ==============================
    // LEVEL SETUP
    // ==============================
    function initLevel(levelIdx) {
      currentLevel = levelIdx;
      const lvl = LEVELS[levelIdx];
      currentBudget = lvl.budget;
      gapLeft = Math.round((HALF_W - lvl.gap) / 2);
      gapRight = gapLeft + lvl.gap;
      gapDepth = 90;

      // Create anchor nodes on each side for player
      playerNodes = [];
      playerBeams = [];
      playerBudgetUsed = 0;

      // Left side anchors
      const anchorSpacing = 20;
      for (let i = 0; i <= 2; i++) {
        playerNodes.push(createNode(gapLeft - i * anchorSpacing, GROUND_Y, true));
      }
      playerNodes.push(createNode(gapLeft, GROUND_Y - 30, true));

      // Right side anchors
      for (let i = 0; i <= 2; i++) {
        playerNodes.push(createNode(gapRight + i * anchorSpacing, GROUND_Y, true));
      }
      playerNodes.push(createNode(gapRight, GROUND_Y - 30, true));

      // AI gets same anchors
      aiNodes = playerNodes.map(n => createNode(n.x, n.y, n.fixed));
      aiBeams = [];
      aiBudgetUsed = 0;

      selectedNode = null;
      hoverNode = null;
      testPhase = '';

      levelEl.textContent = levelIdx + 1;
      budgetEl.textContent = currentBudget;
    }

    // ==============================
    // AI BRIDGE BUILDER
    // ==============================
    function aiBuild() {
      const lvl = LEVELS[currentLevel];
      const budget = lvl.budget;

      // AI builds triangular truss across the gap
      const numSegments = Math.max(3, Math.ceil(lvl.gap / 30));
      const segWidth = lvl.gap / numSegments;
      const trussHeight = Math.min(35, segWidth * 0.9);

      // Bottom chord nodes across gap
      const bottomNodes = [];
      const topNodes = [];

      for (let i = 0; i <= numSegments; i++) {
        const x = gapLeft + i * segWidth;
        const bottomNode = findOrCreateAINode(x, GROUND_Y);
        bottomNodes.push(bottomNode);
        if (i > 0 && i < numSegments) {
          const topNode = findOrCreateAINode(x, GROUND_Y - trussHeight);
          topNodes.push(topNode);
        } else {
          topNodes.push(null);
        }
      }

      let beamCost = 0;
      const maxBudget = budget * 0.95;

      // Bottom chord
      for (let i = 0; i < numSegments; i++) {
        const cost = dist(bottomNodes[i], bottomNodes[i + 1]);
        if (beamCost + cost <= maxBudget) {
          addAIBeam(bottomNodes[i], bottomNodes[i + 1]);
          beamCost += cost;
        }
      }

      // Diagonals and verticals for triangle pattern
      for (let i = 0; i < numSegments; i++) {
        // Rising diagonal
        if (topNodes[i + 1]) {
          const cost = dist(bottomNodes[i], topNodes[i + 1]);
          if (beamCost + cost <= maxBudget) {
            addAIBeam(bottomNodes[i], topNodes[i + 1]);
            beamCost += cost;
          }
        }
        // Falling diagonal
        if (topNodes[i]) {
          const cost = dist(topNodes[i], bottomNodes[i + 1]);
          if (beamCost + cost <= maxBudget) {
            addAIBeam(topNodes[i], bottomNodes[i + 1]);
            beamCost += cost;
          }
        }
        // Top chord
        if (topNodes[i] && topNodes[i + 1]) {
          const cost = dist(topNodes[i], topNodes[i + 1]);
          if (beamCost + cost <= maxBudget) {
            addAIBeam(topNodes[i], topNodes[i + 1]);
            beamCost += cost;
          }
        }
      }

      // Connect anchors to first/last bottom chord nodes
      const leftAnchors = aiNodes.filter(n => n.fixed && n.x <= gapLeft);
      const rightAnchors = aiNodes.filter(n => n.fixed && n.x >= gapRight);
      for (const a of leftAnchors) {
        if (a !== bottomNodes[0]) {
          const cost = dist(a, bottomNodes[0]);
          if (beamCost + cost <= maxBudget) {
            addAIBeam(a, bottomNodes[0]);
            beamCost += cost;
          }
        }
        // Connect to first top node if exists
        if (topNodes[1]) {
          const cost = dist(a, topNodes[1]);
          if (beamCost + cost <= maxBudget && a.y < GROUND_Y) {
            addAIBeam(a, topNodes[1]);
            beamCost += cost;
          }
        }
      }
      for (const a of rightAnchors) {
        if (a !== bottomNodes[numSegments]) {
          const cost = dist(a, bottomNodes[numSegments]);
          if (beamCost + cost <= maxBudget) {
            addAIBeam(a, bottomNodes[numSegments]);
            beamCost += cost;
          }
        }
        if (topNodes[numSegments - 1]) {
          const cost = dist(a, topNodes[numSegments - 1]);
          if (beamCost + cost <= maxBudget && a.y < GROUND_Y) {
            addAIBeam(a, topNodes[numSegments - 1]);
            beamCost += cost;
          }
        }
      }

      aiBudgetUsed = totalBeamCost(aiBeams);
    }

    function findOrCreateAINode(x, y) {
      for (const n of aiNodes) {
        if (Math.abs(n.x - x) < 1 && Math.abs(n.y - y) < 1) return n;
      }
      const n = createNode(x, y, false);
      // Fix nodes at ground level on solid ground
      if (Math.abs(y - GROUND_Y) < 1 && (x <= gapLeft || x >= gapRight)) {
        n.fixed = true;
      }
      aiNodes.push(n);
      return n;
    }

    function addAIBeam(n1, n2) {
      // Check duplicate
      for (const b of aiBeams) {
        if ((b.n1 === n1 && b.n2 === n2) || (b.n1 === n2 && b.n2 === n1)) return;
      }
      aiBeams.push(createBeam(n1, n2));
    }

    // ==============================
    // PHYSICS SIMULATION
    // ==============================
    function cloneForSim(nodes, beams) {
      const simNodes = nodes.map(n => ({
        x: n.x, y: n.y, ox: n.x, oy: n.y,
        vx: 0, vy: 0, fixed: n.fixed,
        mass: 1
      }));
      const simBeams = beams.map(b => ({
        i1: nodes.indexOf(b.n1),
        i2: nodes.indexOf(b.n2),
        restLength: b.restLength,
        broken: false,
        stress: 0
      }));
      return { nodes: simNodes, beams: simBeams };
    }

    function createTruck(startX) {
      const lvl = LEVELS[currentLevel];
      return {
        x: startX - 20,
        y: GROUND_Y - 12,
        width: 28,
        height: 12,
        vx: 0.6,
        vy: 0,
        weight: lvl.truckWeight,
        onGround: true,
        fallen: false,
        maxX: startX - 20,
        wheelBase: 20
      };
    }

    function simStep(sim, truck) {
      const nodes = sim.nodes;
      const beams = sim.beams;
      const dt = 1.0 / SUB_STEPS;

      for (let sub = 0; sub < SUB_STEPS; sub++) {
        // Apply gravity to non-fixed nodes
        for (const n of nodes) {
          if (!n.fixed) {
            n.vy += GRAVITY * dt;
          }
        }

        // Beam constraints (Verlet-like spring)
        for (const b of beams) {
          if (b.broken) continue;
          const n1 = nodes[b.i1];
          const n2 = nodes[b.i2];
          const dx = n2.x - n1.x;
          const dy = n2.y - n1.y;
          const d = Math.sqrt(dx * dx + dy * dy) || 0.01;
          const diff = d - b.restLength;
          const force = diff * 0.4;
          const nx = dx / d;
          const ny = dy / d;

          b.stress = Math.abs(diff) / b.restLength;

          if (Math.abs(force) > BEAM_BREAK_FORCE * dt) {
            b.broken = true;
            continue;
          }

          if (!n1.fixed) {
            n1.vx += nx * force * dt;
            n1.vy += ny * force * dt;
          }
          if (!n2.fixed) {
            n2.vx -= nx * force * dt;
            n2.vy -= ny * force * dt;
          }
        }

        // Apply truck weight to nearby bridge nodes
        if (truck && !truck.fallen) {
          const truckCenterX = truck.x + truck.width / 2;
          // Find the two closest non-fixed nodes beneath truck
          let closestBelow = [];
          for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            if (n.fixed) continue;
            const horizDist = Math.abs(n.x - truckCenterX);
            if (horizDist < truck.wheelBase) {
              closestBelow.push({ node: n, dist: horizDist });
            }
          }
          closestBelow.sort((a, b) => a.dist - b.dist);
          const weightNodes = closestBelow.slice(0, 4);
          if (weightNodes.length > 0) {
            const weightPer = (truck.weight * dt) / weightNodes.length;
            for (const wn of weightNodes) {
              wn.node.vy += weightPer * dt;
            }
          }
        }

        // Integrate positions
        for (const n of nodes) {
          if (n.fixed) continue;
          n.vx *= 0.98;
          n.vy *= 0.98;
          n.x += n.vx * dt;
          n.y += n.vy * dt;

          // Cliff walls collision
          if (n.y > GROUND_Y && (n.x <= gapLeft || n.x >= gapRight)) {
            n.y = GROUND_Y;
            n.vy = 0;
          }
        }
      }

      // Truck movement
      if (truck && !truck.fallen) {
        truck.x += truck.vx;

        // Find surface height at truck position
        const frontX = truck.x + truck.width;
        const backX = truck.x;

        // On solid ground?
        if (frontX <= gapLeft || backX >= gapRight) {
          truck.y = GROUND_Y - truck.height;
          truck.vy = 0;
          truck.onGround = true;
        } else {
          // Find bridge surface under truck
          let supportY = GROUND_Y + gapDepth;
          let hasSupport = false;
          for (const b of beams) {
            if (b.broken) continue;
            const n1 = nodes[b.i1];
            const n2 = nodes[b.i2];
            // Check if beam spans under truck
            const bMinX = Math.min(n1.x, n2.x);
            const bMaxX = Math.max(n1.x, n2.x);
            const truckMidX = truck.x + truck.width / 2;
            if (bMinX <= truckMidX && bMaxX >= truckMidX && Math.abs(n1.y - n2.y) < 40) {
              const t = (truckMidX - n1.x) / ((n2.x - n1.x) || 0.01);
              if (t >= -0.1 && t <= 1.1) {
                const beamY = n1.y + t * (n2.y - n1.y);
                if (beamY < supportY && beamY >= GROUND_Y - 60) {
                  supportY = beamY;
                  hasSupport = true;
                }
              }
            }
          }

          if (hasSupport && supportY - truck.height < truck.y + 8) {
            truck.y = supportY - truck.height;
            truck.vy = 0;
            truck.onGround = true;
          } else {
            truck.vy += GRAVITY;
            truck.y += truck.vy;
            truck.onGround = false;
          }

          if (truck.y > GROUND_Y + gapDepth) {
            truck.fallen = true;
          }
        }

        truck.maxX = Math.max(truck.maxX, truck.x);

        // Check if crossed
        if (truck.x > gapRight + 30) {
          truck.vx = 0;
        }
      }
    }

    // ==============================
    // PLAYER INPUT
    // ==============================
    function getNodeAt(x, y, nodes, radius) {
      radius = radius || 12;
      for (const n of nodes) {
        if (dist({ x, y }, n) < radius) return n;
      }
      return null;
    }

    function canvasToLocal(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (W / rect.width),
        y: (e.clientY - rect.top) * (H / rect.height)
      };
    }

    canvas.addEventListener('mousemove', function(e) {
      if (gameState !== 'building') return;
      const pos = canvasToLocal(e);
      // Only allow interaction on player side (left half)
      if (pos.x >= SPLIT) { hoverNode = null; return; }
      hoverNode = getNodeAt(pos.x, pos.y, playerNodes, 14);
    });

    canvas.addEventListener('mousedown', function(e) {
      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'levelComplete' || gameState === 'gameOver') {
        handleOverlayClick();
        return;
      }
      if (gameState !== 'building') return;

      const pos = canvasToLocal(e);

      // Check test button
      if (pos.x >= 105 && pos.x <= 195 && pos.y >= 365 && pos.y <= 390) {
        if (playerBeams.length > 0) {
          startTest();
        }
        return;
      }

      // Check undo button
      if (pos.x >= 210 && pos.x <= 280 && pos.y >= 365 && pos.y <= 390) {
        if (playerBeams.length > 0) {
          const removed = playerBeams.pop();
          playerBudgetUsed = totalBeamCost(playerBeams);
          // Remove orphaned free nodes
          cleanOrphanNodes(playerNodes, playerBeams);
          budgetEl.textContent = currentBudget - playerBudgetUsed;
        }
        return;
      }

      if (pos.x >= SPLIT) return;

      const clicked = getNodeAt(pos.x, pos.y, playerNodes, 14);
      if (clicked) {
        if (selectedNode && selectedNode !== clicked) {
          // Check if beam already exists
          let exists = false;
          for (const b of playerBeams) {
            if ((b.n1 === selectedNode && b.n2 === clicked) ||
                (b.n1 === clicked && b.n2 === selectedNode)) {
              exists = true;
              break;
            }
          }
          if (!exists) {
            const len = dist(selectedNode, clicked);
            if (playerBudgetUsed + len <= currentBudget) {
              playerBeams.push(createBeam(selectedNode, clicked));
              playerBudgetUsed = totalBeamCost(playerBeams);
              budgetEl.textContent = currentBudget - Math.round(playerBudgetUsed);
            }
          }
          selectedNode = null;
        } else {
          selectedNode = clicked;
        }
      } else {
        // Create new node at click position, but only over the gap
        if (pos.x > gapLeft - 10 && pos.x < gapRight + 10 &&
            pos.y > GROUND_Y - 70 && pos.y < GROUND_Y + 20) {
          const newNode = createNode(pos.x, pos.y, false);
          // Fix if on solid ground
          if (Math.abs(pos.y - GROUND_Y) < 8 && (pos.x <= gapLeft || pos.x >= gapRight)) {
            newNode.fixed = true;
            newNode.y = GROUND_Y;
          }
          playerNodes.push(newNode);
          if (selectedNode) {
            const len = dist(selectedNode, newNode);
            if (playerBudgetUsed + len <= currentBudget) {
              playerBeams.push(createBeam(selectedNode, newNode));
              playerBudgetUsed = totalBeamCost(playerBeams);
              budgetEl.textContent = currentBudget - Math.round(playerBudgetUsed);
            }
            selectedNode = newNode;
          } else {
            selectedNode = newNode;
          }
        } else {
          selectedNode = null;
        }
      }
    });

    function cleanOrphanNodes(nodes, beams) {
      // Don't remove fixed/anchor nodes
      for (let i = nodes.length - 1; i >= 0; i--) {
        if (nodes[i].fixed) continue;
        let used = false;
        for (const b of beams) {
          if (b.n1 === nodes[i] || b.n2 === nodes[i]) { used = true; break; }
        }
        if (!used) nodes.splice(i, 1);
      }
    }

    // ==============================
    // TEST PHASE
    // ==============================
    function startTest() {
      // AI builds its bridge now
      aiBuild();

      // Clone for physics
      simPlayer = cloneForSim(playerNodes, playerBeams);
      simAI = cloneForSim(aiNodes, aiBeams);

      truckPlayer = createTruck(10);
      truckAI = createTruck(10);
      playerBridgeFailed = false;
      aiBridgeFailed = false;
      playerTruckDist = 0;
      aiTruckDist = 0;
      testTimer = 0;
      testPhase = 'simulating';
      gameState = 'testing';
    }

    // ==============================
    // SCORING
    // ==============================
    function calcScore(truckDist, budgetUsed, crossed) {
      const budgetRemain = currentBudget - budgetUsed;
      const distScore = Math.round(truckDist);
      const bonus = crossed ? 500 : 0;
      return Math.max(0, Math.round(budgetRemain * 0.5) + distScore + bonus);
    }

    // ==============================
    // GAME FLOW
    // ==============================
    function startGame() {
      gameState = 'building';
      overlay.style.display = 'none';
      playerTotalScore = 0;
      aiTotalScore = 0;
      playerScoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      initLevel(0);
    }

    function handleOverlayClick() {
      if (gameState === 'levelComplete') {
        if (currentLevel < LEVELS.length - 1) {
          initLevel(currentLevel + 1);
          gameState = 'building';
          overlay.style.display = 'none';
        } else {
          showGameOver();
        }
      } else if (gameState === 'gameOver') {
        startGame();
      }
    }

    function showLevelComplete(pScore, aScore) {
      const crossed = truckPlayer.x > gapRight + 10;
      const aiCrossed = truckAI.x > gapRight + 10;
      playerTotalScore += pScore;
      aiTotalScore += aScore;
      playerScoreEl.textContent = playerTotalScore;
      aiScoreEl.textContent = aiTotalScore;
      gameState = 'levelComplete';
      overlay.style.display = 'flex';
      overlayTitle.textContent = crossed ? 'BRIDGE HELD!' : 'BRIDGE COLLAPSED!';
      overlayText.innerHTML = 'You: ' + pScore + ' pts' + (crossed ? ' [CROSSED]' : '') +
        '<br>AI: ' + aScore + ' pts' + (aiCrossed ? ' [CROSSED]' : '') +
        '<br><br>' + (currentLevel < LEVELS.length - 1 ? 'Click for next level' : 'Click for final results');
      overlayDetail.textContent = 'Level ' + (currentLevel + 1) + ' / ' + LEVELS.length;
    }

    function showGameOver() {
      gameState = 'gameOver';
      overlay.style.display = 'flex';
      const winner = playerTotalScore >= aiTotalScore ? 'YOU WIN!' : 'AI WINS!';
      overlayTitle.textContent = winner;
      overlayText.innerHTML = 'Final Score<br>You: ' + playerTotalScore + ' | AI: ' + aiTotalScore;
      overlayDetail.textContent = 'Click to play again';
      score = playerTotalScore;
    }

    // ==============================
    // DRAWING
    // ==============================
    function drawGround(offsetX) {
      ctx.save();
      ctx.beginPath();
      // Left cliff
      ctx.rect(offsetX, GROUND_Y, gapLeft, H - GROUND_Y);
      ctx.fillStyle = '#3a2a1a';
      ctx.fill();
      // Right cliff
      ctx.beginPath();
      ctx.rect(offsetX + gapRight, GROUND_Y, HALF_W - gapRight, H - GROUND_Y);
      ctx.fill();
      // Cliff faces
      ctx.fillStyle = '#5a4030';
      ctx.fillRect(offsetX + gapLeft - 3, GROUND_Y, 3, gapDepth);
      ctx.fillRect(offsetX + gapRight, GROUND_Y, 3, gapDepth);
      // Ground surface
      ctx.fillStyle = '#4a7a3a';
      ctx.fillRect(offsetX, GROUND_Y - 3, gapLeft, 6);
      ctx.fillRect(offsetX + gapRight, GROUND_Y - 3, HALF_W - gapRight, 6);
      // Abyss bottom
      ctx.fillStyle = '#1a1018';
      ctx.fillRect(offsetX + gapLeft, GROUND_Y + gapDepth - 5, gapRight - gapLeft, 10);
      // Water in gap
      ctx.fillStyle = 'rgba(40, 80, 140, 0.4)';
      ctx.fillRect(offsetX + gapLeft, GROUND_Y + gapDepth - 12, gapRight - gapLeft, 15);
      ctx.restore();
    }

    function drawNodes(nodes, offsetX, isPlayer) {
      for (const n of nodes) {
        ctx.beginPath();
        ctx.arc(offsetX + n.x, n.y, n.fixed ? 5 : 4, 0, Math.PI * 2);
        if (n.fixed) {
          ctx.fillStyle = '#888';
        } else {
          ctx.fillStyle = isPlayer ? '#f94' : '#4af';
        }
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Highlight selected
        if (isPlayer && n === selectedNode) {
          ctx.beginPath();
          ctx.arc(offsetX + n.x, n.y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff0';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        // Highlight hover
        if (isPlayer && n === hoverNode && n !== selectedNode) {
          ctx.beginPath();
          ctx.arc(offsetX + n.x, n.y, 8, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(255,153,68,0.5)';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      }
    }

    function drawBeams(beams, nodes, offsetX, color) {
      for (const b of beams) {
        if (b.broken) continue;
        ctx.beginPath();
        ctx.moveTo(offsetX + b.n1.x, b.n1.y);
        ctx.lineTo(offsetX + b.n2.x, b.n2.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.stroke();
      }
    }

    function drawSimBeams(sim, offsetX, baseColor) {
      for (const b of sim.beams) {
        if (b.broken) continue;
        const n1 = sim.nodes[b.i1];
        const n2 = sim.nodes[b.i2];
        // Color by stress
        let r = 255, g = 153, bl = 68;
        if (b.stress > 0.05) {
          r = Math.min(255, 150 + b.stress * 800);
          g = Math.max(0, 153 - b.stress * 600);
          bl = Math.max(0, 68 - b.stress * 400);
        }
        ctx.beginPath();
        ctx.moveTo(offsetX + n1.x, n1.y);
        ctx.lineTo(offsetX + n2.x, n2.y);
        ctx.strokeStyle = 'rgb(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(bl) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      // Draw broken beams faintly
      for (const b of sim.beams) {
        if (!b.broken) continue;
        const n1 = sim.nodes[b.i1];
        const n2 = sim.nodes[b.i2];
        ctx.beginPath();
        ctx.moveTo(offsetX + n1.x, n1.y);
        ctx.lineTo(offsetX + n2.x, n2.y);
        ctx.strokeStyle = 'rgba(255,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawSimNodes(sim, offsetX) {
      for (const n of sim.nodes) {
        ctx.beginPath();
        ctx.arc(offsetX + n.x, n.y, n.fixed ? 4 : 3, 0, Math.PI * 2);
        ctx.fillStyle = n.fixed ? '#888' : '#ddd';
        ctx.fill();
      }
    }

    function drawTruck(truck, offsetX, color) {
      if (!truck) return;
      const tx = offsetX + truck.x;
      const ty = truck.y;
      // Body
      ctx.fillStyle = color;
      ctx.fillRect(tx, ty, truck.width, truck.height);
      // Cab
      ctx.fillStyle = color;
      ctx.fillRect(tx + truck.width - 10, ty - 6, 10, 6);
      // Wheels
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(tx + 5, ty + truck.height, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(tx + truck.width - 5, ty + truck.height, 3, 0, Math.PI * 2);
      ctx.fill();
      // Weight label
      ctx.fillStyle = '#fff';
      ctx.font = '7px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(LEVELS[currentLevel].truckWeight + 't', tx + truck.width / 2, ty + 9);
    }

    function drawPreviewLine() {
      if (gameState !== 'building' || !selectedNode) return;
      if (hoverNode && hoverNode !== selectedNode) {
        ctx.beginPath();
        ctx.moveTo(selectedNode.x, selectedNode.y);
        ctx.lineTo(hoverNode.x, hoverNode.y);
        ctx.strokeStyle = 'rgba(255,153,68,0.4)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
        // Show cost preview
        const previewLen = Math.round(dist(selectedNode, hoverNode));
        const midX = (selectedNode.x + hoverNode.x) / 2;
        const midY = (selectedNode.y + hoverNode.y) / 2;
        ctx.fillStyle = 'rgba(255,153,68,0.7)';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('-' + previewLen, midX, midY - 6);
      }
    }

    function drawButton(x, y, w, h, text, highlight) {
      ctx.fillStyle = highlight ? '#f94' : 'rgba(255,153,68,0.2)';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = '#f94';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = highlight ? '#1a1a2e' : '#f94';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x + w / 2, y + h / 2);
    }

    function drawHUD(offsetX, label, budgetUsed, isPlayer) {
      ctx.fillStyle = isPlayer ? '#f94' : '#4af';
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(label, offsetX + 8, 16);
      ctx.font = '10px Courier New';
      ctx.fillStyle = '#aaa';
      ctx.fillText('Used: ' + Math.round(budgetUsed) + '/' + currentBudget, offsetX + 8, 30);

      if (gameState === 'testing') {
        const truck = isPlayer ? truckPlayer : truckAI;
        const sim = isPlayer ? simPlayer : simAI;
        if (truck) {
          const progress = Math.min(100, Math.round((truck.maxX - 10) / (gapRight + 30) * 100));
          ctx.fillStyle = truck.fallen ? '#f44' : '#4f4';
          ctx.fillText(truck.fallen ? 'FALLEN' : 'Progress: ' + progress + '%', offsetX + 8, 44);
        }
      }
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Divider
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(SPLIT, 0);
      ctx.lineTo(SPLIT, H);
      ctx.stroke();

      if (gameState === 'building') {
        // Player side
        drawGround(0);
        drawBeams(playerBeams, playerNodes, 0, '#f94');
        drawPreviewLine();
        drawNodes(playerNodes, 0, true);
        drawHUD(0, 'YOU - ' + LEVELS[currentLevel].name, playerBudgetUsed, true);

        // Buttons
        drawButton(105, 365, 90, 25, 'TEST', playerBeams.length > 0);
        drawButton(210, 365, 70, 25, 'UNDO', playerBeams.length > 0);

        // AI side (show building progress bar while player builds)
        drawGround(SPLIT);
        drawHUD(SPLIT, 'AI - Building...', 0, false);
        // Show "AI will build on test" text
        ctx.fillStyle = '#4af';
        ctx.font = '10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('AI builds when you click TEST', SPLIT + HALF_W / 2, GROUND_Y - 30);

        // Instructions
        ctx.fillStyle = '#666';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Click nodes to connect | Click empty to create node', HALF_W / 2, H - 8);

      } else if (gameState === 'testing') {
        // Player sim
        drawGround(0);
        drawSimBeams(simPlayer, 0, '#f94');
        drawSimNodes(simPlayer, 0);
        drawTruck(truckPlayer, 0, '#f94');
        drawHUD(0, 'YOU', playerBudgetUsed, true);

        // AI sim
        drawGround(SPLIT);
        drawSimBeams(simAI, SPLIT, '#4af');
        drawSimNodes(simAI, SPLIT);
        drawTruck(truckAI, SPLIT, '#4af');
        drawHUD(SPLIT, 'AI', aiBudgetUsed, false);
      }
    }

    // ==============================
    // GAME LOOP
    // ==============================
    function update() {
      if (gameState === 'testing' && testPhase === 'simulating') {
        testTimer++;

        // Run physics
        simStep(simPlayer, truckPlayer);
        simStep(simAI, truckAI);

        // Check completion (truck crossed, fell, or timeout)
        const playerDone = truckPlayer.fallen || truckPlayer.x > gapRight + 40 || testTimer > 600;
        const aiDone = truckAI.fallen || truckAI.x > gapRight + 40 || testTimer > 600;

        if (playerDone && aiDone) {
          testPhase = 'done';
          const playerCrossed = truckPlayer.x > gapRight + 10;
          const aiCrossed = truckAI.x > gapRight + 10;
          playerTruckDist = truckPlayer.maxX;
          aiTruckDist = truckAI.maxX;

          const pScore = calcScore(playerTruckDist, playerBudgetUsed, playerCrossed);
          const aScore = calcScore(aiTruckDist, aiBudgetUsed, aiCrossed);

          setTimeout(() => showLevelComplete(pScore, aScore), 800);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Init
    gameState = 'waiting';
    overlay.style.display = 'flex';
    overlayTitle.textContent = 'BRIDGE BUILDING RACE';
    overlayText.innerHTML = 'Build bridges under budget<br>Race your truck across vs AI';
    overlayDetail.textContent = 'Click to Start';

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

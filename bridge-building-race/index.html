<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Building Race</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f94; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 153, 68, 0.5); }
    h1 { color: #f94; font-size: 1.4rem; text-shadow: 0 0 15px rgba(255, 153, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1rem;
    }
    .score-bar span { color: #f94; }
    canvas {
      border: 2px solid #f94;
      box-shadow: 0 0 20px rgba(255, 153, 68, 0.2);
      display: block;
      cursor: crosshair;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f94;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 153, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .highlight { color: #f94; font-size: 1.1rem; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BRIDGE BUILDING RACE</h1>
  </div>
  <div class="score-bar">
    <div>Level: <span id="level">1</span> | Budget: <span id="budget">0</span></div>
    <div>You: <span id="playerScore">0</span> | AI: <span id="aiScore">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="400"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:400px;">
      <h2 id="overlayTitle">BRIDGE BUILDING RACE</h2>
      <p id="overlayText">Click to Start</p>
      <p class="highlight" id="overlayDetail"></p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 400;
    const levelEl = document.getElementById('level');
    const budgetEl = document.getElementById('budget');
    const playerScoreEl = document.getElementById('playerScore');
    const aiScoreEl = document.getElementById('aiScore');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const overlayDetail = document.getElementById('overlayDetail');

    let gameState; // 'waiting','building','testing','levelComplete','gameOver'
    let score = 0;
    let aiTotalScore = 0;
    let playerTotalScore = 0;
    let currentLevel = 0;

    // Split screen layout
    const SPLIT = 300;
    const HALF_W = 300;
    const GROUND_Y = 280;
    const GRAVITY = 0.25;
    const SUB_STEPS = 6;
    const BEAM_STRENGTH = 3.5; // max stress ratio before break

    // Level definitions
    const LEVELS = [
      { gap: 80,  budget: 400, truckWeight: 8,  name: 'Easy Creek' },
      { gap: 110, budget: 520, truckWeight: 10, name: 'River Crossing' },
      { gap: 140, budget: 660, truckWeight: 12, name: 'Canyon Pass' },
      { gap: 170, budget: 820, truckWeight: 14, name: 'Deep Gorge' },
      { gap: 200, budget: 1000, truckWeight: 16, name: 'Grand Chasm' }
    ];

    // Player state
    let playerNodes, playerBeams, playerBudgetUsed;
    let aiNodes, aiBeams, aiBudgetUsed;
    let selectedNode = null;
    let hoverNode = null;
    let mousePos = { x: 0, y: 0 };
    let currentBudget = 0;

    // Physics sim state
    let simPlayer, simAI;
    let truckPlayer, truckAI;
    let testPhase = '';
    let testTimer = 0;
    let playerTruckDist, aiTruckDist;

    // Level geometry
    let gapLeft, gapRight;
    const GAP_DEPTH = 85;

    // Particles for visual flair
    let particles = [];

    // ==============================
    // UTILITIES
    // ==============================
    function dist(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function createNode(x, y, fixed) {
      return { x, y, ox: x, oy: y, vx: 0, vy: 0, fixed: !!fixed };
    }

    function createBeam(n1, n2) {
      const len = dist(n1, n2);
      return { n1, n2, restLength: len, broken: false, stress: 0 };
    }

    function totalBeamCost(beams) {
      let total = 0;
      for (const b of beams) total += b.restLength;
      return Math.round(total);
    }

    function addParticle(x, y, color) {
      particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 3 - 1,
        life: 30 + Math.random() * 20,
        color
      });
    }

    // ==============================
    // LEVEL SETUP
    // ==============================
    function initLevel(levelIdx) {
      currentLevel = levelIdx;
      const lvl = LEVELS[levelIdx];
      currentBudget = lvl.budget;
      gapLeft = Math.round((HALF_W - lvl.gap) / 2);
      gapRight = gapLeft + lvl.gap;

      // Create anchor nodes for player
      playerNodes = [];
      playerBeams = [];
      playerBudgetUsed = 0;

      createAnchors(playerNodes, lvl.gap);

      // AI gets same starting anchors
      aiNodes = [];
      aiBeams = [];
      aiBudgetUsed = 0;
      createAnchors(aiNodes, lvl.gap);

      selectedNode = null;
      hoverNode = null;
      testPhase = '';
      particles = [];

      levelEl.textContent = levelIdx + 1;
      budgetEl.textContent = currentBudget;
    }

    function createAnchors(nodes, gap) {
      // Left side: 3 anchors on ground + 1 elevated
      const spacing = 18;
      for (let i = 0; i <= 2; i++) {
        nodes.push(createNode(gapLeft - i * spacing, GROUND_Y, true));
      }
      nodes.push(createNode(gapLeft, GROUND_Y - 28, true));

      // Right side: 3 anchors on ground + 1 elevated
      for (let i = 0; i <= 2; i++) {
        nodes.push(createNode(gapRight + i * spacing, GROUND_Y, true));
      }
      nodes.push(createNode(gapRight, GROUND_Y - 28, true));
    }

    // ==============================
    // AI BRIDGE BUILDER
    // ==============================
    function aiBuild() {
      const lvl = LEVELS[currentLevel];
      const budget = lvl.budget;

      // AI builds optimized triangular truss
      const numSeg = Math.max(3, Math.ceil(lvl.gap / 28));
      const segW = lvl.gap / numSeg;
      const trussH = Math.min(32, segW * 0.85);

      // Create bottom and top chord nodes
      const bottom = [];
      const top = [];

      for (let i = 0; i <= numSeg; i++) {
        const x = gapLeft + i * segW;
        bottom.push(findOrAddAINode(x, GROUND_Y));
      }
      for (let i = 1; i < numSeg; i++) {
        const x = gapLeft + i * segW;
        top.push(findOrAddAINode(x, GROUND_Y - trussH));
      }

      let cost = 0;
      const maxB = budget * 0.93;

      function tryBeam(n1, n2) {
        if (!n1 || !n2) return;
        for (const b of aiBeams) {
          if ((b.n1 === n1 && b.n2 === n2) || (b.n1 === n2 && b.n2 === n1)) return;
        }
        const c = dist(n1, n2);
        if (cost + c <= maxB) {
          aiBeams.push(createBeam(n1, n2));
          cost += c;
        }
      }

      // Bottom chord (road deck)
      for (let i = 0; i < numSeg; i++) tryBeam(bottom[i], bottom[i + 1]);

      // Top chord
      for (let i = 0; i < top.length - 1; i++) tryBeam(top[i], top[i + 1]);

      // Diagonals: Warren truss pattern (alternating V shapes)
      for (let i = 0; i < numSeg; i++) {
        if (i < top.length) {
          tryBeam(bottom[i], top[i]); // left side of V
          tryBeam(top[i], bottom[i + 1]); // right side of V
        }
      }

      // Connect anchors to first/last road nodes
      const leftAnchors = aiNodes.filter(n => n.fixed && n.x <= gapLeft);
      const rightAnchors = aiNodes.filter(n => n.fixed && n.x >= gapRight);

      for (const a of leftAnchors) {
        tryBeam(a, bottom[0]);
        if (a.y < GROUND_Y && top.length > 0) tryBeam(a, top[0]);
      }
      for (const a of rightAnchors) {
        tryBeam(a, bottom[numSeg]);
        if (a.y < GROUND_Y && top.length > 0) tryBeam(a, top[top.length - 1]);
      }

      aiBudgetUsed = totalBeamCost(aiBeams);
    }

    function findOrAddAINode(x, y) {
      for (const n of aiNodes) {
        if (Math.abs(n.x - x) < 1 && Math.abs(n.y - y) < 1) return n;
      }
      const n = createNode(x, y, false);
      if (Math.abs(y - GROUND_Y) < 2 && (x <= gapLeft + 1 || x >= gapRight - 1)) {
        n.fixed = true;
      }
      aiNodes.push(n);
      return n;
    }

    // ==============================
    // PHYSICS SIMULATION
    // ==============================
    function cloneForSim(nodes, beams) {
      const simNodes = nodes.map(n => ({
        x: n.x, y: n.y, ox: n.x, oy: n.y,
        vx: 0, vy: 0, fixed: n.fixed
      }));
      const simBeams = beams.map(b => ({
        i1: nodes.indexOf(b.n1),
        i2: nodes.indexOf(b.n2),
        restLength: b.restLength,
        broken: false,
        stress: 0
      }));
      return { nodes: simNodes, beams: simBeams };
    }

    function createTruck(startX) {
      return {
        x: startX,
        y: GROUND_Y - 14,
        width: 30,
        height: 14,
        vx: 0,
        vy: 0,
        weight: LEVELS[currentLevel].truckWeight,
        onBridge: false,
        fallen: false,
        crossed: false,
        maxX: startX
      };
    }

    function simStep(sim, truck) {
      const nodes = sim.nodes;
      const beams = sim.beams;
      const dt = 1.0 / SUB_STEPS;

      for (let sub = 0; sub < SUB_STEPS; sub++) {
        // Gravity
        for (const n of nodes) {
          if (!n.fixed) {
            n.vy += GRAVITY * dt;
          }
        }

        // Beam constraints (spring-like)
        for (const b of beams) {
          if (b.broken) continue;
          const n1 = nodes[b.i1];
          const n2 = nodes[b.i2];
          const dx = n2.x - n1.x;
          const dy = n2.y - n1.y;
          const d = Math.sqrt(dx * dx + dy * dy) || 0.001;
          const stretch = (d - b.restLength) / b.restLength;
          b.stress = Math.abs(stretch);

          // Break if overstressed
          if (b.stress > BEAM_STRENGTH) {
            b.broken = true;
            // Spawn particles at break point
            const mx = (n1.x + n2.x) / 2;
            const my = (n1.y + n2.y) / 2;
            for (let p = 0; p < 5; p++) addParticle(mx, my, '#f94');
            continue;
          }

          const force = stretch * 0.5;
          const fx = (dx / d) * force;
          const fy = (dy / d) * force;

          if (!n1.fixed) { n1.vx += fx * dt; n1.vy += fy * dt; }
          if (!n2.fixed) { n2.vx -= fx * dt; n2.vy -= fy * dt; }
        }

        // Truck load on bridge nodes
        if (truck && !truck.fallen && !truck.crossed) {
          const cx = truck.x + truck.width / 2;
          let totalW = 0;
          let loadNodes = [];
          for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            if (n.fixed && n.y >= GROUND_Y) continue;
            const hd = Math.abs(n.x - cx);
            if (hd < truck.width * 0.8 && n.y <= GROUND_Y + 10) {
              const w = 1.0 / (hd + 5);
              loadNodes.push({ node: n, w });
              totalW += w;
            }
          }
          if (totalW > 0) {
            for (const ln of loadNodes) {
              if (!ln.node.fixed) {
                ln.node.vy += (truck.weight * dt * (ln.w / totalW)) * 0.03;
              }
            }
          }
        }

        // Integrate
        for (const n of nodes) {
          if (n.fixed) continue;
          n.vx *= 0.97;
          n.vy *= 0.97;
          n.x += n.vx * dt;
          n.y += n.vy * dt;

          // Floor collision on solid ground
          if (n.y > GROUND_Y && (n.x <= gapLeft || n.x >= gapRight)) {
            n.y = GROUND_Y;
            n.vy = 0;
            if (Math.abs(n.vx) < 0.1) n.vx = 0;
          }
          // Clamp to not go too far down
          if (n.y > GROUND_Y + GAP_DEPTH + 20) {
            n.y = GROUND_Y + GAP_DEPTH + 20;
            n.vy = 0;
          }
        }
      }

      // === Truck physics (outside sub-steps for stability) ===
      if (truck && !truck.fallen && !truck.crossed) {
        // Accelerate truck forward
        truck.vx = Math.min(truck.vx + 0.015, 1.0);
        truck.x += truck.vx;

        // Find support surface under truck
        const frontX = truck.x + truck.width;
        const backX = truck.x;
        const midX = truck.x + truck.width / 2;

        // On solid ground
        if (frontX <= gapLeft || backX >= gapRight) {
          truck.y = GROUND_Y - truck.height;
          truck.vy = 0;
          truck.onBridge = false;
          if (backX >= gapRight + 20) {
            truck.crossed = true;
            truck.vx = 0;
          }
        } else {
          // Over gap - find bridge support
          let bestY = GROUND_Y + GAP_DEPTH + 50;
          let foundSupport = false;

          for (const b of beams) {
            if (b.broken) continue;
            const n1 = nodes[b.i1];
            const n2 = nodes[b.i2];
            const minBX = Math.min(n1.x, n2.x);
            const maxBX = Math.max(n1.x, n2.x);

            // Check front and back wheel + middle
            for (const checkX of [backX + 4, midX, frontX - 4]) {
              if (checkX >= minBX - 2 && checkX <= maxBX + 2) {
                const span = n2.x - n1.x;
                if (Math.abs(span) < 1) continue;
                const t = Math.max(0, Math.min(1, (checkX - n1.x) / span));
                const beamY = n1.y + t * (n2.y - n1.y);
                if (beamY < bestY && beamY >= GROUND_Y - 60 && beamY <= GROUND_Y + 30) {
                  bestY = beamY;
                  foundSupport = true;
                }
              }
            }
          }

          // Also check if partially on solid ground
          if (backX < gapLeft) {
            bestY = Math.min(bestY, GROUND_Y);
            foundSupport = true;
          }
          if (frontX > gapRight) {
            bestY = Math.min(bestY, GROUND_Y);
            foundSupport = true;
          }

          if (foundSupport && bestY - truck.height <= truck.y + 5) {
            truck.y = bestY - truck.height;
            truck.vy = 0;
            truck.onBridge = true;
          } else {
            // Falling
            truck.vy += GRAVITY * 1.5;
            truck.y += truck.vy;
            truck.onBridge = false;
          }

          if (truck.y > GROUND_Y + GAP_DEPTH) {
            truck.fallen = true;
            for (let p = 0; p < 12; p++) addParticle(truck.x + truck.width / 2, truck.y, '#f44');
          }
        }

        truck.maxX = Math.max(truck.maxX, truck.x);
      }
    }

    // ==============================
    // PLAYER INPUT
    // ==============================
    function getNodeAt(x, y, nodes, radius) {
      radius = radius || 12;
      let best = null, bestD = radius;
      for (const n of nodes) {
        const d = dist({ x, y }, n);
        if (d < bestD) { bestD = d; best = n; }
      }
      return best;
    }

    function canvasToLocal(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (W / rect.width),
        y: (e.clientY - rect.top) * (H / rect.height)
      };
    }

    canvas.addEventListener('mousemove', function(e) {
      const pos = canvasToLocal(e);
      mousePos = pos;
      if (gameState !== 'building') { hoverNode = null; return; }
      if (pos.x >= SPLIT) { hoverNode = null; return; }
      hoverNode = getNodeAt(pos.x, pos.y, playerNodes, 14);
    });

    canvas.addEventListener('mousedown', function(e) {
      if (gameState === 'waiting') {
        startGame();
        return;
      }
      if (gameState === 'levelComplete' || gameState === 'gameOver') {
        handleOverlayClick();
        return;
      }
      if (gameState !== 'building') return;

      const pos = canvasToLocal(e);

      // TEST button
      if (pos.x >= 110 && pos.x <= 200 && pos.y >= 360 && pos.y <= 388) {
        if (playerBeams.length > 0) {
          startTest();
        }
        return;
      }

      // UNDO button
      if (pos.x >= 210 && pos.x <= 280 && pos.y >= 360 && pos.y <= 388) {
        if (playerBeams.length > 0) {
          playerBeams.pop();
          playerBudgetUsed = totalBeamCost(playerBeams);
          cleanOrphanNodes(playerNodes, playerBeams);
          budgetEl.textContent = currentBudget - playerBudgetUsed;
        }
        return;
      }

      // CLEAR button
      if (pos.x >= 15 && pos.x <= 95 && pos.y >= 360 && pos.y <= 388) {
        playerBeams = [];
        playerBudgetUsed = 0;
        cleanOrphanNodes(playerNodes, playerBeams);
        budgetEl.textContent = currentBudget;
        selectedNode = null;
        return;
      }

      // Only interact on player side
      if (pos.x >= SPLIT) return;

      const clicked = getNodeAt(pos.x, pos.y, playerNodes, 14);
      if (clicked) {
        if (selectedNode && selectedNode !== clicked) {
          // Try to connect
          let exists = false;
          for (const b of playerBeams) {
            if ((b.n1 === selectedNode && b.n2 === clicked) ||
                (b.n1 === clicked && b.n2 === selectedNode)) {
              exists = true; break;
            }
          }
          if (!exists) {
            const len = dist(selectedNode, clicked);
            if (playerBudgetUsed + len <= currentBudget) {
              playerBeams.push(createBeam(selectedNode, clicked));
              playerBudgetUsed = totalBeamCost(playerBeams);
              budgetEl.textContent = currentBudget - Math.round(playerBudgetUsed);
            }
          }
          selectedNode = null;
        } else if (selectedNode === clicked) {
          selectedNode = null; // deselect
        } else {
          selectedNode = clicked;
        }
      } else {
        // Create new node in buildable area
        const buildMinX = gapLeft - 5;
        const buildMaxX = gapRight + 5;
        const buildMinY = GROUND_Y - 65;
        const buildMaxY = GROUND_Y + 8;
        if (pos.x >= buildMinX && pos.x <= buildMaxX &&
            pos.y >= buildMinY && pos.y <= buildMaxY) {
          const newNode = createNode(pos.x, pos.y, false);
          // Snap to ground if close and on solid surface
          if (Math.abs(pos.y - GROUND_Y) < 8 && (pos.x <= gapLeft + 2 || pos.x >= gapRight - 2)) {
            newNode.y = GROUND_Y;
            newNode.fixed = true;
          }
          playerNodes.push(newNode);
          if (selectedNode) {
            const len = dist(selectedNode, newNode);
            if (playerBudgetUsed + len <= currentBudget) {
              playerBeams.push(createBeam(selectedNode, newNode));
              playerBudgetUsed = totalBeamCost(playerBeams);
              budgetEl.textContent = currentBudget - Math.round(playerBudgetUsed);
            }
          }
          selectedNode = newNode;
        } else {
          selectedNode = null;
        }
      }
    });

    // Right-click to deselect
    canvas.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      selectedNode = null;
    });

    function cleanOrphanNodes(nodes, beams) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        if (nodes[i].fixed) continue;
        let used = false;
        for (const b of beams) {
          if (b.n1 === nodes[i] || b.n2 === nodes[i]) { used = true; break; }
        }
        if (!used) nodes.splice(i, 1);
      }
    }

    // ==============================
    // TEST PHASE
    // ==============================
    function startTest() {
      aiBuild();
      simPlayer = cloneForSim(playerNodes, playerBeams);
      simAI = cloneForSim(aiNodes, aiBeams);
      truckPlayer = createTruck(5);
      truckAI = createTruck(5);
      testTimer = 0;
      testPhase = 'simulating';
      gameState = 'testing';
    }

    // ==============================
    // SCORING
    // ==============================
    function calcScore(truck, budgetUsed) {
      const budgetRemain = currentBudget - budgetUsed;
      const distPercent = Math.min(1, (truck.maxX - 5) / (gapRight + 25));
      const distScore = Math.round(distPercent * 300);
      const bonus = truck.crossed ? 500 : 0;
      return Math.max(0, Math.round(budgetRemain * 0.3) + distScore + bonus);
    }

    // ==============================
    // GAME FLOW
    // ==============================
    function startGame() {
      gameState = 'building';
      overlay.style.display = 'none';
      playerTotalScore = 0;
      aiTotalScore = 0;
      playerScoreEl.textContent = '0';
      aiScoreEl.textContent = '0';
      initLevel(0);
    }

    function handleOverlayClick() {
      if (gameState === 'levelComplete') {
        if (currentLevel < LEVELS.length - 1) {
          initLevel(currentLevel + 1);
          gameState = 'building';
          overlay.style.display = 'none';
        } else {
          showGameOver();
        }
      } else if (gameState === 'gameOver') {
        startGame();
      }
    }

    function showLevelComplete(pScore, aScore) {
      playerTotalScore += pScore;
      aiTotalScore += aScore;
      playerScoreEl.textContent = playerTotalScore;
      aiScoreEl.textContent = aiTotalScore;
      gameState = 'levelComplete';
      overlay.style.display = 'flex';
      const pCrossed = truckPlayer.crossed;
      const aCrossed = truckAI.crossed;
      overlayTitle.textContent = pCrossed ? 'BRIDGE HELD!' : 'BRIDGE COLLAPSED!';
      overlayText.innerHTML =
        'You: ' + pScore + ' pts' + (pCrossed ? ' [CROSSED]' : ' [FELL]') +
        '<br>AI: ' + aScore + ' pts' + (aCrossed ? ' [CROSSED]' : ' [FELL]') +
        '<br><br>' + (currentLevel < LEVELS.length - 1 ? 'Click for next level' : 'Click for final results');
      overlayDetail.textContent = LEVELS[currentLevel].name + ' complete';
    }

    function showGameOver() {
      gameState = 'gameOver';
      overlay.style.display = 'flex';
      const winner = playerTotalScore >= aiTotalScore ? 'YOU WIN!' : 'AI WINS!';
      overlayTitle.textContent = winner;
      overlayText.innerHTML = 'Final Score<br>You: ' + playerTotalScore + ' | AI: ' + aiTotalScore;
      overlayDetail.textContent = 'Click to play again';
      score = playerTotalScore;
    }

    // ==============================
    // DRAWING
    // ==============================
    function drawSky(ox) {
      // Gradient sky
      const grad = ctx.createLinearGradient(ox, 0, ox, GROUND_Y);
      grad.addColorStop(0, '#0a0a1a');
      grad.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = grad;
      ctx.fillRect(ox, 0, HALF_W, GROUND_Y);
    }

    function drawGround(ox) {
      // Left cliff
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(ox, GROUND_Y, gapLeft, H - GROUND_Y);
      // Right cliff
      ctx.fillRect(ox + gapRight, GROUND_Y, HALF_W - gapRight, H - GROUND_Y);
      // Cliff faces (side walls of gap)
      ctx.fillStyle = '#5a4030';
      ctx.fillRect(ox + gapLeft, GROUND_Y, 2, GAP_DEPTH);
      ctx.fillRect(ox + gapRight - 2, GROUND_Y, 2, GAP_DEPTH);
      // Grass
      ctx.fillStyle = '#4a7a3a';
      ctx.fillRect(ox, GROUND_Y - 3, gapLeft + 1, 5);
      ctx.fillRect(ox + gapRight - 1, GROUND_Y - 3, HALF_W - gapRight + 1, 5);
      // Water at bottom
      const waterY = GROUND_Y + GAP_DEPTH - 10;
      ctx.fillStyle = 'rgba(30, 70, 130, 0.5)';
      ctx.fillRect(ox + gapLeft, waterY, gapRight - gapLeft, 15);
      // Depth darkness
      ctx.fillStyle = '#0a0810';
      ctx.fillRect(ox + gapLeft, GROUND_Y + GAP_DEPTH + 5, gapRight - gapLeft, H);
      // Anchor markers (small orange/blue triangles)
    }

    function drawAnchors(nodes, ox, color) {
      ctx.fillStyle = color;
      for (const n of nodes) {
        if (!n.fixed) continue;
        ctx.beginPath();
        ctx.arc(ox + n.x, n.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        // Pin cross
        ctx.beginPath();
        ctx.moveTo(ox + n.x - 3, n.y);
        ctx.lineTo(ox + n.x + 3, n.y);
        ctx.moveTo(ox + n.x, n.y - 3);
        ctx.lineTo(ox + n.x, n.y + 3);
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawBuildBeams(beams, ox, color) {
      for (const b of beams) {
        ctx.beginPath();
        ctx.moveTo(ox + b.n1.x, b.n1.y);
        ctx.lineTo(ox + b.n2.x, b.n2.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.stroke();
        // Length label
        const mx = ox + (b.n1.x + b.n2.x) / 2;
        const my = (b.n1.y + b.n2.y) / 2;
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(b.restLength), mx, my - 4);
      }
    }

    function drawBuildNodes(nodes, ox, isPlayer) {
      for (const n of nodes) {
        if (n.fixed) continue;
        ctx.beginPath();
        ctx.arc(ox + n.x, n.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = isPlayer ? '#f94' : '#4af';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      // Selected glow
      if (isPlayer && selectedNode) {
        ctx.beginPath();
        ctx.arc(ox + selectedNode.x, selectedNode.y, 10, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      // Hover glow
      if (isPlayer && hoverNode && hoverNode !== selectedNode) {
        ctx.beginPath();
        ctx.arc(ox + hoverNode.x, hoverNode.y, 9, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,153,68,0.5)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }

    function drawPreviewLine() {
      if (!selectedNode || gameState !== 'building') return;
      const targetNode = hoverNode;
      const tx = targetNode ? targetNode.x : mousePos.x;
      const ty = targetNode ? targetNode.y : mousePos.y;
      if (mousePos.x >= SPLIT) return;

      ctx.beginPath();
      ctx.moveTo(selectedNode.x, selectedNode.y);
      ctx.lineTo(tx, ty);
      ctx.strokeStyle = 'rgba(255,153,68,0.35)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Cost preview
      const previewLen = Math.round(dist(selectedNode, { x: tx, y: ty }));
      const mx = (selectedNode.x + tx) / 2;
      const my = (selectedNode.y + ty) / 2;
      const overBudget = playerBudgetUsed + previewLen > currentBudget;
      ctx.fillStyle = overBudget ? '#f44' : 'rgba(255,153,68,0.7)';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText((overBudget ? 'OVER ' : '-') + previewLen, mx, my - 7);
    }

    function drawSimBeams(sim, ox) {
      // Active beams colored by stress
      for (const b of sim.beams) {
        if (b.broken) continue;
        const n1 = sim.nodes[b.i1];
        const n2 = sim.nodes[b.i2];
        const stress = Math.min(1, b.stress / BEAM_STRENGTH);
        // Green -> Yellow -> Red
        let r, g;
        if (stress < 0.5) {
          r = Math.round(255 * stress * 2);
          g = 200;
        } else {
          r = 255;
          g = Math.round(200 * (1 - (stress - 0.5) * 2));
        }
        ctx.beginPath();
        ctx.moveTo(ox + n1.x, n1.y);
        ctx.lineTo(ox + n2.x, n2.y);
        ctx.strokeStyle = 'rgb(' + r + ',' + g + ',40)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      // Broken beams
      for (const b of sim.beams) {
        if (!b.broken) continue;
        const n1 = sim.nodes[b.i1];
        const n2 = sim.nodes[b.i2];
        ctx.beginPath();
        ctx.moveTo(ox + n1.x, n1.y);
        ctx.lineTo(ox + n2.x, n2.y);
        ctx.strokeStyle = 'rgba(255,60,60,0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawSimNodes(sim, ox) {
      for (const n of sim.nodes) {
        ctx.beginPath();
        ctx.arc(ox + n.x, n.y, n.fixed ? 5 : 3, 0, Math.PI * 2);
        ctx.fillStyle = n.fixed ? '#888' : '#ccc';
        ctx.fill();
      }
    }

    function drawTruck(truck, ox, color) {
      if (!truck) return;
      const tx = ox + truck.x;
      const ty = truck.y;
      if (ty > H + 20) return; // off screen

      ctx.save();
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(tx + 2, ty + 2, truck.width, truck.height);

      // Body
      ctx.fillStyle = color;
      ctx.fillRect(tx, ty, truck.width, truck.height);

      // Cab (slightly darker)
      ctx.fillStyle = shadeColor(color, -30);
      ctx.fillRect(tx + truck.width - 11, ty - 7, 11, 7);

      // Windshield
      ctx.fillStyle = 'rgba(150,200,255,0.5)';
      ctx.fillRect(tx + truck.width - 10, ty - 6, 3, 5);

      // Wheels
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(tx + 6, ty + truck.height + 1, 3.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(tx + truck.width - 6, ty + truck.height + 1, 3.5, 0, Math.PI * 2);
      ctx.fill();

      // Hub caps
      ctx.fillStyle = '#555';
      ctx.beginPath();
      ctx.arc(tx + 6, ty + truck.height + 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(tx + truck.width - 6, ty + truck.height + 1, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Weight label
      ctx.fillStyle = '#000';
      ctx.font = 'bold 7px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(truck.weight + 't', tx + truck.width / 2 - 3, ty + truck.height - 3);

      ctx.restore();
    }

    function shadeColor(hex, amount) {
      let r = parseInt(hex.slice(1, 3) || 'ff', 16);
      let g = parseInt(hex.slice(3, 5) || '99', 16);
      let b = parseInt(hex.slice(5, 7) || '44', 16);
      // Handle shorthand
      if (hex === '#f94') { r = 255; g = 153; b = 68; }
      if (hex === '#4af') { r = 68; g = 170; b = 255; }
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      return 'rgb(' + r + ',' + g + ',' + b + ')';
    }

    function drawButton(x, y, w, h, text, enabled) {
      ctx.fillStyle = enabled ? 'rgba(255,153,68,0.15)' : 'rgba(80,80,80,0.1)';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = enabled ? '#f94' : '#555';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = enabled ? '#f94' : '#666';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x + w / 2, y + h / 2);
    }

    function drawHUD(ox, label, budgetUsed, color, side) {
      ctx.fillStyle = color;
      ctx.font = 'bold 12px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText(label, ox + 8, 16);

      ctx.font = '10px Courier New';
      const remain = currentBudget - Math.round(budgetUsed);
      ctx.fillStyle = remain < 50 ? '#f44' : '#aaa';
      ctx.fillText('Budget: ' + remain + '/' + currentBudget, ox + 8, 30);

      if (gameState === 'testing') {
        const truck = side === 'player' ? truckPlayer : truckAI;
        if (truck) {
          const progress = Math.min(100, Math.max(0,
            Math.round(((truck.maxX - 5) / (gapRight + 25)) * 100)));
          ctx.fillStyle = truck.fallen ? '#f44' : truck.crossed ? '#4f4' : '#ff4';
          const status = truck.fallen ? 'FELL!' : truck.crossed ? 'CROSSED!' : progress + '%';
          ctx.fillText('Truck: ' + status, ox + 8, 44);
        }
      }
    }

    function drawBuildZone(ox) {
      // Faint outline showing where player can build
      ctx.strokeStyle = 'rgba(255,153,68,0.1)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.strokeRect(ox + gapLeft - 5, GROUND_Y - 65, gapRight - gapLeft + 10, 73);
      ctx.setLineDash([]);
    }

    function drawParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) { particles.splice(i, 1); continue; }
        ctx.globalAlpha = p.life / 50;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
      }
      ctx.globalAlpha = 1;
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Divider line
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(SPLIT, 0);
      ctx.lineTo(SPLIT, H);
      ctx.stroke();

      // Divider label
      ctx.fillStyle = '#444';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.translate(SPLIT, H / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('VS', 0, -4);
      ctx.restore();

      if (gameState === 'building') {
        // ---- PLAYER SIDE ----
        drawSky(0);
        drawGround(0);
        drawBuildZone(0);
        drawBuildBeams(playerBeams, 0, '#f94');
        drawPreviewLine();
        drawAnchors(playerNodes, 0, '#f94');
        drawBuildNodes(playerNodes, 0, true);
        drawHUD(0, 'YOU - ' + LEVELS[currentLevel].name, playerBudgetUsed, '#f94', 'player');

        // Buttons
        drawButton(15, 360, 80, 28, 'CLEAR', playerBeams.length > 0);
        drawButton(110, 360, 90, 28, 'TEST!', playerBeams.length > 0);
        drawButton(210, 360, 70, 28, 'UNDO', playerBeams.length > 0);

        // ---- AI SIDE (placeholder during build) ----
        drawSky(SPLIT);
        drawGround(SPLIT);
        drawAnchors(aiNodes, SPLIT, '#4af');
        drawHUD(SPLIT, 'AI', 0, '#4af', 'ai');

        // AI waiting text
        ctx.fillStyle = '#4af';
        ctx.font = '11px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('AI builds on TEST', SPLIT + HALF_W / 2, GROUND_Y - 40);
        ctx.fillStyle = '#555';
        ctx.font = '9px Courier New';
        ctx.fillText('Triangular truss optimizer', SPLIT + HALF_W / 2, GROUND_Y - 25);

        // Instructions
        ctx.fillStyle = '#555';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Click anchors/nodes to connect  |  Click gap area for new node', HALF_W / 2, H - 6);

      } else if (gameState === 'testing') {
        // ---- PLAYER SIM ----
        drawSky(0);
        drawGround(0);
        drawSimBeams(simPlayer, 0);
        drawSimNodes(simPlayer, 0);
        drawTruck(truckPlayer, 0, '#f94');
        drawHUD(0, 'YOU', playerBudgetUsed, '#f94', 'player');

        // ---- AI SIM ----
        drawSky(SPLIT);
        drawGround(SPLIT);
        drawSimBeams(simAI, SPLIT);
        drawSimNodes(simAI, SPLIT);
        drawTruck(truckAI, SPLIT, '#4af');
        drawHUD(SPLIT, 'AI', aiBudgetUsed, '#4af', 'ai');

        drawParticles();
      }
    }

    // ==============================
    // GAME LOOP
    // ==============================
    function update() {
      if (gameState === 'testing' && testPhase === 'simulating') {
        testTimer++;

        simStep(simPlayer, truckPlayer);
        simStep(simAI, truckAI);

        const pDone = truckPlayer.fallen || truckPlayer.crossed || testTimer > 500;
        const aDone = truckAI.fallen || truckAI.crossed || testTimer > 500;

        if (pDone && aDone) {
          testPhase = 'done';
          const pScore = calcScore(truckPlayer, playerBudgetUsed);
          const aScore = calcScore(truckAI, aiBudgetUsed);
          setTimeout(() => showLevelComplete(pScore, aScore), 1000);
        }
      }

      // Update particles even when paused
      if (particles.length > 0 && gameState !== 'testing') {
        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].life--;
          if (particles[i].life <= 0) particles.splice(i, 1);
        }
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ==============================
    // INIT
    // ==============================
    gameState = 'waiting';
    overlay.style.display = 'flex';
    overlayTitle.textContent = 'BRIDGE BUILDING RACE';
    overlayText.innerHTML = 'Physics-based bridge construction<br>Build under budget, then test with a truck!<br><br>5 levels of increasing difficulty<br>Split-screen vs AI engineer';
    overlayDetail.textContent = 'Click to Start';

    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spelunky</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #ea6; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(238, 170, 102, 0.4); }
    h1 { color: #ea6; font-size: 2rem; text-shadow: 0 0 15px rgba(238, 170, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #ea6; }
    .info-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: #aaa;
    }
    .info-bar span { color: #ea6; }
    canvas {
      border: 2px solid #ea6;
      box-shadow: 0 0 20px rgba(238, 170, 102, 0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #ea6;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>SPELUNKY</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="info-bar">
    <div>HP: <span id="hp">4</span></div>
    <div>Bombs: <span id="bombs">4</span></div>
    <div>Ropes: <span id="ropes">4</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">SPELUNKY</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const hpEl = document.getElementById('hp');
    const bombsEl = document.getElementById('bombs');
    const ropesEl = document.getElementById('ropes');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // --- Constants ---
    const TILE = 32;
    const COLS = W / TILE; // 15
    const ROWS = H / TILE; // 15
    const GRAVITY = 0.45;
    const MAX_FALL = 7;
    const PLAYER_SPEED = 2.5;
    const JUMP_FORCE = -7;
    const WHIP_RANGE = 36;
    const WHIP_DURATION = 12;
    const VISIBILITY_RADIUS = 5.5; // tiles
    const INVULN_TIME = 60; // frames of invulnerability after hit

    // Tile types
    const EMPTY = 0, WALL = 1, SPIKE = 2, LADDER = 3, EXIT = 4, ENTRANCE = 5, ARROW_TRAP = 6;

    let score, best = 0, gameState;
    let player, level, grid, enemies, items, projectiles, particles;
    let keys = {};
    let levelNum;
    let lastTime = 0;
    let frameCount = 0;

    // --- Player ---
    function createPlayer(x, y) {
      return {
        x: x * TILE + TILE / 2,
        y: y * TILE + TILE / 2,
        w: 20, h: 26,
        vx: 0, vy: 0,
        hp: 4,
        bombs: 4,
        ropes: 4,
        facing: 1, // 1 right, -1 left
        onGround: false,
        onLadder: false,
        whipTimer: 0,
        invuln: 0,
        stunned: 0,
        dead: false
      };
    }

    // --- Level Generation ---
    function generateLevel(lvl) {
      const g = [];
      for (let r = 0; r < ROWS; r++) {
        g[r] = [];
        for (let c = 0; c < COLS; c++) {
          g[r][c] = EMPTY;
        }
      }

      // Fill borders with walls
      for (let c = 0; c < COLS; c++) {
        g[0][c] = WALL;
        g[ROWS - 1][c] = WALL;
      }
      for (let r = 0; r < ROWS; r++) {
        g[r][0] = WALL;
        g[r][COLS - 1] = WALL;
      }

      // Divide into 4x4 rooms (each room is roughly 3x3 tiles inside)
      // Grid of rooms: 4 columns x 4 rows (inside the borders)
      const ROOM_W = 3;
      const ROOM_H = 3;
      const ROOMS_X = 4;
      const ROOMS_Y = 4;

      // Generate path from top to bottom
      const path = [];
      let px = Math.floor(Math.random() * ROOMS_X);
      path.push({ x: px, y: 0 });

      for (let ry = 0; ry < ROOMS_Y - 1; ry++) {
        // Move left, right, or down
        const dir = Math.random();
        if (dir < 0.33 && px > 0) {
          px--;
          path.push({ x: px, y: ry });
        } else if (dir < 0.66 && px < ROOMS_X - 1) {
          px++;
          path.push({ x: px, y: ry });
        }
        // Always move down eventually
        path.push({ x: px, y: ry + 1 });
      }

      // Mark which rooms are on the path
      const onPath = new Set();
      path.forEach(p => onPath.add(p.x + ',' + p.y));

      // Fill rooms with terrain
      for (let ry = 0; ry < ROOMS_Y; ry++) {
        for (let rx = 0; rx < ROOMS_X; rx++) {
          const baseC = 1 + rx * ROOM_W;
          const baseR = 1 + ry * ROOM_H;
          const isPath = onPath.has(rx + ',' + ry);

          // Generate room template
          fillRoom(g, baseC, baseR, ROOM_W, ROOM_H, isPath, lvl);
        }
      }

      // Ensure path connectivity - clear paths between consecutive path rooms
      for (let i = 0; i < path.length - 1; i++) {
        const a = path[i];
        const b = path[i + 1];
        clearConnection(g, a, b, ROOM_W, ROOM_H);
      }

      // Place entrance at top of first path room
      const startRoom = path[0];
      const entranceC = 1 + startRoom.x * ROOM_W + 1;
      const entranceR = 1 + startRoom.y * ROOM_H;
      g[entranceR][entranceC] = ENTRANCE;
      g[entranceR + 1][entranceC] = EMPTY; // clear space below entrance

      // Place exit at bottom of last path room
      const endRoom = path[path.length - 1];
      const exitC = 1 + endRoom.x * ROOM_W + 1;
      const exitR = 1 + endRoom.y * ROOM_H + ROOM_H - 1;
      g[exitR][exitC] = EXIT;
      // Ensure ground below exit
      if (exitR + 1 < ROWS) g[exitR + 1][exitC] = WALL;
      // Clear space above exit
      if (exitR - 1 > 0) g[exitR - 1][exitC] = EMPTY;

      return {
        grid: g,
        entrance: { x: entranceC, y: entranceR },
        exit: { x: exitC, y: exitR }
      };
    }

    function fillRoom(g, baseC, baseR, rw, rh, isPath, lvl) {
      if (isPath) {
        // Path rooms are mostly open with some platforms
        for (let r = 0; r < rh; r++) {
          for (let c = 0; c < rw; c++) {
            g[baseR + r][baseC + c] = EMPTY;
          }
        }
        // Add a platform or floor section
        if (Math.random() < 0.5) {
          const platR = baseR + 1 + Math.floor(Math.random() * (rh - 2));
          const platStart = baseC + Math.floor(Math.random() * 2);
          const platLen = 1 + Math.floor(Math.random() * 2);
          for (let c = platStart; c < Math.min(platStart + platLen, baseC + rw); c++) {
            if (g[platR][c] === EMPTY) g[platR][c] = WALL;
          }
        }
      } else {
        // Non-path rooms can be filled or have various templates
        const template = Math.random();
        if (template < 0.3) {
          // Mostly solid
          for (let r = 0; r < rh; r++) {
            for (let c = 0; c < rw; c++) {
              g[baseR + r][baseC + c] = WALL;
            }
          }
        } else if (template < 0.6) {
          // Open with floor
          for (let r = 0; r < rh; r++) {
            for (let c = 0; c < rw; c++) {
              g[baseR + r][baseC + c] = r === rh - 1 ? WALL : EMPTY;
            }
          }
        } else {
          // Platform room
          for (let r = 0; r < rh; r++) {
            for (let c = 0; c < rw; c++) {
              if (r === rh - 1 || (r === 1 && c !== 1)) {
                g[baseR + r][baseC + c] = WALL;
              } else {
                g[baseR + r][baseC + c] = EMPTY;
              }
            }
          }
        }
      }

      // Add traps based on level difficulty
      const trapChance = Math.min(0.08 + lvl * 0.02, 0.2);
      for (let r = 0; r < rh; r++) {
        for (let c = 0; c < rw; c++) {
          const gr = baseR + r;
          const gc = baseC + c;
          if (g[gr][gc] === EMPTY && gr + 1 < ROWS && g[gr + 1][gc] === WALL) {
            // Can place spike on floor
            if (Math.random() < trapChance * 0.5) {
              g[gr][gc] = SPIKE;
            }
          }
          if (g[gr][gc] === WALL && gc + 1 < COLS && g[gr][gc + 1] === EMPTY) {
            if (Math.random() < trapChance * 0.3) {
              g[gr][gc] = ARROW_TRAP;
            }
          }
        }
      }

      // Add ladders occasionally
      if (Math.random() < 0.3) {
        const lc = baseC + Math.floor(Math.random() * rw);
        for (let r = 0; r < rh; r++) {
          if (g[baseR + r][lc] === EMPTY) {
            g[baseR + r][lc] = LADDER;
          }
        }
      }
    }

    function clearConnection(g, a, b, rw, rh) {
      const ac = 1 + a.x * rw + 1;
      const ar = 1 + a.y * rh + 1;
      const bc = 1 + b.x * rw + 1;
      const br = 1 + b.y * rh + 1;

      if (a.y === b.y) {
        // Horizontal connection
        const minC = Math.min(ac, bc);
        const maxC = Math.max(ac, bc);
        const row = ar;
        for (let c = minC; c <= maxC; c++) {
          g[row][c] = EMPTY;
          if (row - 1 >= 0 && g[row - 1][c] === WALL) g[row - 1][c] = EMPTY;
        }
      } else {
        // Vertical connection
        const minR = Math.min(ar, br);
        const maxR = Math.max(ar, br);
        const col = ac;
        for (let r = minR; r <= maxR; r++) {
          g[r][col] = EMPTY;
          // Place ladders for vertical connections
          if (r > minR && r < maxR) g[r][col] = LADDER;
        }
      }
    }

    // --- Enemy spawning ---
    function spawnEnemies(lvl, g) {
      const ens = [];
      const count = Math.min(3 + lvl, 10);
      let placed = 0;
      let attempts = 0;

      while (placed < count && attempts < 200) {
        attempts++;
        const c = 2 + Math.floor(Math.random() * (COLS - 4));
        const r = 2 + Math.floor(Math.random() * (ROWS - 4));

        // Don't spawn near entrance
        if (level && Math.abs(c - level.entrance.x) < 3 && Math.abs(r - level.entrance.y) < 3) continue;

        if (g[r][c] === EMPTY) {
          const type = Math.random();
          if (type < 0.4 && r + 1 < ROWS && g[r + 1][c] === WALL) {
            // Snake - ground patrol
            ens.push({
              type: 'snake',
              x: c * TILE + TILE / 2,
              y: r * TILE + TILE / 2,
              w: 20, h: 12,
              vx: (Math.random() < 0.5 ? 1 : -1) * 1.2,
              vy: 0,
              hp: 1,
              dead: false
            });
            placed++;
          } else if (type < 0.7) {
            // Bat - flies toward player
            ens.push({
              type: 'bat',
              x: c * TILE + TILE / 2,
              y: r * TILE + TILE / 2,
              w: 18, h: 14,
              vx: 0, vy: 0,
              hp: 1,
              dead: false,
              wingPhase: Math.random() * Math.PI * 2,
              active: false
            });
            placed++;
          } else if (r - 1 >= 0 && g[r - 1][c] === WALL) {
            // Spider - drops from ceiling
            ens.push({
              type: 'spider',
              x: c * TILE + TILE / 2,
              y: r * TILE + TILE / 2,
              w: 16, h: 16,
              vx: 0, vy: 0,
              hp: 1,
              dead: false,
              dropping: false,
              homeY: r * TILE + TILE / 2
            });
            placed++;
          }
        }
      }
      return ens;
    }

    // --- Item spawning ---
    function spawnItems(lvl, g) {
      const its = [];
      const goldCount = 4 + Math.floor(Math.random() * (3 + lvl));
      let placed = 0;
      let attempts = 0;

      while (placed < goldCount && attempts < 200) {
        attempts++;
        const c = 2 + Math.floor(Math.random() * (COLS - 4));
        const r = 2 + Math.floor(Math.random() * (ROWS - 4));

        if (g[r][c] === EMPTY && r + 1 < ROWS && g[r + 1][c] === WALL) {
          const type = Math.random();
          if (type < 0.5) {
            its.push({ type: 'gold', x: c * TILE + TILE / 2, y: r * TILE + TILE / 2 + 4, value: 100, collected: false });
          } else if (type < 0.8) {
            its.push({ type: 'gem', x: c * TILE + TILE / 2, y: r * TILE + TILE / 2 + 4, value: 500, collected: false });
          } else {
            its.push({ type: 'chest', x: c * TILE + TILE / 2, y: r * TILE + TILE / 2, value: 1000, collected: false });
          }
          placed++;
        }
      }
      return its;
    }

    // --- Particles ---
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5 - 2,
          life: 20 + Math.random() * 20,
          color,
          size: 2 + Math.random() * 3
        });
      }
    }

    // --- Collision helpers ---
    function tileAt(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return WALL;
      return grid[r][c];
    }

    function isSolid(tile) {
      return tile === WALL || tile === ARROW_TRAP;
    }

    function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax - aw / 2 < bx + bw / 2 &&
             ax + aw / 2 > bx - bw / 2 &&
             ay - ah / 2 < by + bh / 2 &&
             ay + ah / 2 > by - bh / 2;
    }

    function worldCollides(x, y, w, h) {
      const left = Math.floor((x - w / 2) / TILE);
      const right = Math.floor((x + w / 2 - 1) / TILE);
      const top = Math.floor((y - h / 2) / TILE);
      const bottom = Math.floor((y + h / 2 - 1) / TILE);

      for (let r = top; r <= bottom; r++) {
        for (let c = left; c <= right; c++) {
          if (isSolid(tileAt(r, c))) return true;
        }
      }
      return false;
    }

    // --- Init ---
    function init() {
      score = 0;
      levelNum = 1;
      scoreEl.textContent = '0';
      levelEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'SPELUNKY';
      overlayText.textContent = 'Press SPACE to start\n\nArrows: Move  Space: Whip\nB: Bomb  R: Rope';
      keys = {};
      particles = [];
      projectiles = [];
      initLevel(1);
      draw();
    }

    function initLevel(lvl) {
      levelNum = lvl;
      levelEl.textContent = lvl;
      level = generateLevel(lvl);
      grid = level.grid;
      player = createPlayer(level.entrance.x, level.entrance.y);
      enemies = spawnEnemies(lvl, grid);
      items = spawnItems(lvl, grid);
      projectiles = [];
      particles = [];
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Level: ${levelNum}\nPress any key to restart`;
    }

    function nextLevel() {
      // Save player state before regenerating level
      const prevHP = player.hp;
      const prevBombs = player.bombs;
      const prevRopes = player.ropes;

      initLevel(levelNum + 1);

      // Bonus score for completing a level
      score += 500 * levelNum;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Carry over player state
      player.hp = Math.min(prevHP + 1, 4); // heal 1 HP
      player.bombs = prevBombs;
      player.ropes = prevRopes;
      hpEl.textContent = player.hp;
      bombsEl.textContent = player.bombs;
      ropesEl.textContent = player.ropes;
    }

    // --- Main loop ---
    function loop(timestamp) {
      if (gameState !== 'playing') return;

      const dt = Math.min((timestamp - lastTime) / 16.667, 2); // normalize to ~60fps, cap at 2
      lastTime = timestamp;

      update(dt);
      draw();
      frameCount++;
      requestAnimationFrame(loop);
    }

    // --- Update ---
    function update(dt) {
      if (player.dead) return;

      // Player invulnerability timer
      if (player.invuln > 0) player.invuln--;
      if (player.stunned > 0) player.stunned--;

      // Whip timer
      if (player.whipTimer > 0) player.whipTimer--;

      // --- Player movement ---
      const onLadderTile = tileAt(Math.floor(player.y / TILE), Math.floor(player.x / TILE)) === LADDER;
      const onLadderTileBelow = tileAt(Math.floor((player.y + player.h / 2) / TILE), Math.floor(player.x / TILE)) === LADDER;

      if (player.stunned <= 0) {
        // Horizontal movement
        if (keys['ArrowLeft']) {
          player.vx = -PLAYER_SPEED;
          player.facing = -1;
        } else if (keys['ArrowRight']) {
          player.vx = PLAYER_SPEED;
          player.facing = 1;
        } else {
          player.vx = 0;
        }

        // Ladder climbing
        if ((keys['ArrowUp'] || keys['ArrowDown']) && (onLadderTile || onLadderTileBelow)) {
          player.onLadder = true;
        }

        if (player.onLadder) {
          if (keys['ArrowUp']) {
            player.vy = -PLAYER_SPEED;
          } else if (keys['ArrowDown']) {
            player.vy = PLAYER_SPEED;
          } else {
            player.vy = 0;
          }
          if (!onLadderTile && !onLadderTileBelow) {
            player.onLadder = false;
          }
        }

        // Jumping
        if (keys['ArrowUp'] && player.onGround && !player.onLadder) {
          player.vy = JUMP_FORCE;
          player.onGround = false;
        }
      }

      // Apply gravity (unless on ladder)
      if (!player.onLadder) {
        player.vy += GRAVITY * dt;
        if (player.vy > MAX_FALL) player.vy = MAX_FALL;
      }

      // Move X
      const newX = player.x + player.vx * dt;
      if (!worldCollides(newX, player.y, player.w, player.h)) {
        player.x = newX;
      } else {
        player.vx = 0;
      }

      // Move Y
      const newY = player.y + player.vy * dt;
      if (!worldCollides(player.x, newY, player.w, player.h)) {
        player.y = newY;
        player.onGround = false;
      } else {
        if (player.vy > 0) {
          // Landing
          player.onGround = true;
          // Fall damage
          if (player.vy > 6 && player.invuln <= 0) {
            hurtPlayer(1);
          }
        }
        player.vy = 0;
      }

      // Spike check
      const playerTileR = Math.floor((player.y + player.h / 2 - 2) / TILE);
      const playerTileC = Math.floor(player.x / TILE);
      if (tileAt(playerTileR, playerTileC) === SPIKE && player.invuln <= 0) {
        hurtPlayer(4); // spikes are deadly
      }

      // Arrow trap trigger
      checkArrowTraps();

      // Exit check
      if (tileAt(Math.floor(player.y / TILE), Math.floor(player.x / TILE)) === EXIT) {
        spawnParticles(player.x, player.y, '#ea6', 20);
        nextLevel();
        return;
      }

      // --- Whip attack ---
      if (player.whipTimer === WHIP_DURATION - 1) {
        const whipX = player.x + player.facing * WHIP_RANGE;
        const whipY = player.y;
        enemies.forEach(e => {
          if (!e.dead && rectCollide(whipX, whipY, 24, 24, e.x, e.y, e.w, e.h)) {
            e.dead = true;
            score += 50;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            spawnParticles(e.x, e.y, '#f44', 8);
          }
        });
      }

      // --- Update enemies ---
      enemies.forEach(e => {
        if (e.dead) return;

        if (e.type === 'snake') {
          e.x += e.vx * dt;
          // Turn at walls
          const checkC = Math.floor((e.x + (e.vx > 0 ? e.w / 2 : -e.w / 2)) / TILE);
          const checkR = Math.floor(e.y / TILE);
          if (isSolid(tileAt(checkR, checkC)) || !isSolid(tileAt(checkR + 1, checkC))) {
            e.vx = -e.vx;
          }
        }

        if (e.type === 'bat') {
          const dist = Math.sqrt((player.x - e.x) ** 2 + (player.y - e.y) ** 2);
          if (dist < VISIBILITY_RADIUS * TILE || e.active) {
            e.active = true;
            const angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.vx = Math.cos(angle) * 2;
            e.vy = Math.sin(angle) * 1.5 + Math.sin(e.wingPhase) * 0.8;
            e.wingPhase += 0.15;
          }
          e.x += e.vx * dt;
          e.y += e.vy * dt;
        }

        if (e.type === 'spider') {
          const dist = Math.abs(player.x - e.x);
          if (dist < TILE * 2 && player.y > e.y && !e.dropping) {
            e.dropping = true;
          }
          if (e.dropping) {
            e.vy += GRAVITY * 0.5 * dt;
            if (e.vy > 4) e.vy = 4;
            e.y += e.vy * dt;
            // Check if hit ground
            const gr = Math.floor((e.y + e.h / 2) / TILE);
            const gc = Math.floor(e.x / TILE);
            if (isSolid(tileAt(gr, gc))) {
              e.vy = 0;
              e.y = gr * TILE - e.h / 2;
              // Bounce around on ground
              if (!e.grounded) {
                e.grounded = true;
                e.vx = (Math.random() < 0.5 ? 1 : -1) * 1.5;
              }
            }
          }
          if (e.grounded) {
            e.x += e.vx * dt;
            const checkC = Math.floor((e.x + (e.vx > 0 ? e.w / 2 : -e.w / 2)) / TILE);
            const checkR = Math.floor(e.y / TILE);
            if (isSolid(tileAt(checkR, checkC))) {
              e.vx = -e.vx;
            }
          }
        }

        // Enemy-player collision
        if (player.invuln <= 0 && rectCollide(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          // Player can stomp enemies by landing on them
          if (player.vy > 0 && player.y < e.y - e.h / 3) {
            e.dead = true;
            player.vy = JUMP_FORCE * 0.6;
            score += 50;
            scoreEl.textContent = score;
            if (score > best) { best = score; bestEl.textContent = best; }
            spawnParticles(e.x, e.y, '#f44', 8);
          } else {
            hurtPlayer(1);
            // Knockback
            player.vx = (player.x < e.x ? -3 : 3);
            player.vy = -3;
            player.stunned = 15;
          }
        }
      });

      // --- Update projectiles ---
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;

        // Hit wall
        const pr = Math.floor(p.y / TILE);
        const pc = Math.floor(p.x / TILE);
        if (isSolid(tileAt(pr, pc))) {
          projectiles.splice(i, 1);
          continue;
        }

        // Hit player
        if (p.hostile && player.invuln <= 0 &&
            rectCollide(player.x, player.y, player.w, player.h, p.x, p.y, 6, 6)) {
          hurtPlayer(1);
          projectiles.splice(i, 1);
          continue;
        }

        // Out of bounds
        if (p.x < 0 || p.x > W || p.y < 0 || p.y > H) {
          projectiles.splice(i, 1);
        }
      }

      // --- Update items ---
      items.forEach(item => {
        if (item.collected) return;
        if (rectCollide(player.x, player.y, player.w, player.h, item.x, item.y, 16, 16)) {
          item.collected = true;
          score += item.value;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          const color = item.type === 'gold' ? '#fd0' : item.type === 'gem' ? '#4af' : '#ea6';
          spawnParticles(item.x, item.y, color, 10);
        }
      });

      // --- Update particles ---
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // --- Update bombs ---
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        if (p.type === 'bomb') {
          p.vy += GRAVITY * 0.5 * dt;
          p.timer--;
          if (p.timer <= 0) {
            // Explode! Destroy nearby tiles
            const br = Math.floor(p.y / TILE);
            const bc = Math.floor(p.x / TILE);
            for (let dr = -2; dr <= 2; dr++) {
              for (let dc = -2; dc <= 2; dc++) {
                if (dr * dr + dc * dc <= 5) {
                  const tr = br + dr;
                  const tc = bc + dc;
                  if (tr > 0 && tr < ROWS - 1 && tc > 0 && tc < COLS - 1) {
                    if (grid[tr][tc] === WALL || grid[tr][tc] === ARROW_TRAP) {
                      grid[tr][tc] = EMPTY;
                    }
                  }
                }
              }
            }
            // Damage enemies in blast radius
            enemies.forEach(e => {
              if (!e.dead) {
                const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
                if (dist < TILE * 2.5) {
                  e.dead = true;
                  score += 50;
                  scoreEl.textContent = score;
                  if (score > best) { best = score; bestEl.textContent = best; }
                }
              }
            });
            // Damage player if too close
            const pdist = Math.sqrt((player.x - p.x) ** 2 + (player.y - p.y) ** 2);
            if (pdist < TILE * 2 && player.invuln <= 0) {
              hurtPlayer(2);
            }
            spawnParticles(p.x, p.y, '#f80', 25);
            spawnParticles(p.x, p.y, '#ff0', 15);
            projectiles.splice(i, 1);
          }
        }
      }

      // Update HUD
      hpEl.textContent = player.hp;
      bombsEl.textContent = player.bombs;
      ropesEl.textContent = player.ropes;
    }

    function hurtPlayer(dmg) {
      if (player.invuln > 0) return;
      player.hp -= dmg;
      player.invuln = INVULN_TIME;
      spawnParticles(player.x, player.y, '#f44', 6);
      if (player.hp <= 0) {
        player.hp = 0;
        player.dead = true;
        spawnParticles(player.x, player.y, '#f44', 20);
        setTimeout(gameOver, 500);
      }
    }

    function checkArrowTraps() {
      // Arrow traps fire when player is in line
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] === ARROW_TRAP) {
            const trapY = r * TILE + TILE / 2;
            const trapX = c * TILE + TILE / 2;
            // Check if player is roughly at same height
            if (Math.abs(player.y - trapY) < TILE) {
              // Check if player is to the right and close enough
              const dir = (c + 1 < COLS && !isSolid(tileAt(r, c + 1))) ? 1 : -1;
              const dx = player.x - trapX;
              if (Math.sign(dx) === dir && Math.abs(dx) < TILE * 5) {
                // Fire arrow (only once)
                grid[r][c] = WALL; // trap used up
                projectiles.push({
                  x: trapX + dir * TILE / 2,
                  y: trapY,
                  vx: dir * 6,
                  vy: 0,
                  hostile: true,
                  type: 'arrow'
                });
              }
            }
          }
        }
      }
    }

    function placeBomb() {
      if (player.bombs <= 0) return;
      player.bombs--;
      projectiles.push({
        x: player.x,
        y: player.y - 10,
        vx: player.facing * 3,
        vy: -3,
        type: 'bomb',
        timer: 90, // ~1.5 seconds
        hostile: false
      });
    }

    function placeRope() {
      if (player.ropes <= 0) return;
      player.ropes--;
      // Place ladder tiles going upward from player position
      const pc = Math.floor(player.x / TILE);
      let pr = Math.floor(player.y / TILE);
      for (let i = 0; i < 6; i++) {
        pr--;
        if (pr <= 0) break;
        if (grid[pr][pc] === WALL) break;
        grid[pr][pc] = LADDER;
      }
    }

    // --- Drawing ---
    function draw() {
      ctx.fillStyle = '#0a0a18';
      ctx.fillRect(0, 0, W, H);

      // Calculate visibility
      const playerTileX = player ? player.x / TILE : COLS / 2;
      const playerTileY = player ? player.y / TILE : ROWS / 2;

      // Draw tiles
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const tile = grid[r][c];
          const tx = c * TILE;
          const ty = r * TILE;

          // Distance-based visibility
          const dist = Math.sqrt((c + 0.5 - playerTileX) ** 2 + (r + 0.5 - playerTileY) ** 2);
          if (gameState === 'playing' && dist > VISIBILITY_RADIUS + 1) continue;

          let alpha = 1;
          if (gameState === 'playing') {
            alpha = Math.max(0, 1 - Math.max(0, dist - VISIBILITY_RADIUS) / 1.5);
          }

          ctx.globalAlpha = alpha;

          if (tile === WALL) {
            ctx.fillStyle = '#3a2a1a';
            ctx.fillRect(tx, ty, TILE, TILE);
            // Brick pattern
            ctx.strokeStyle = '#2a1a0a';
            ctx.lineWidth = 1;
            ctx.strokeRect(tx + 1, ty + 1, TILE - 2, TILE - 2);
            ctx.beginPath();
            ctx.moveTo(tx + TILE / 2, ty);
            ctx.lineTo(tx + TILE / 2, ty + TILE / 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tx, ty + TILE / 2);
            ctx.lineTo(tx + TILE, ty + TILE / 2);
            ctx.stroke();
          } else if (tile === SPIKE) {
            // Spikes
            ctx.fillStyle = '#888';
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(tx + 4 + i * 10, ty + TILE);
              ctx.lineTo(tx + 9 + i * 10, ty + TILE - 14);
              ctx.lineTo(tx + 14 + i * 10, ty + TILE);
              ctx.fill();
            }
          } else if (tile === LADDER) {
            ctx.strokeStyle = '#864';
            ctx.lineWidth = 2;
            // Rails
            ctx.beginPath();
            ctx.moveTo(tx + 8, ty);
            ctx.lineTo(tx + 8, ty + TILE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tx + TILE - 8, ty);
            ctx.lineTo(tx + TILE - 8, ty + TILE);
            ctx.stroke();
            // Rungs
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(tx + 8, ty + 6 + i * 10);
              ctx.lineTo(tx + TILE - 8, ty + 6 + i * 10);
              ctx.stroke();
            }
          } else if (tile === EXIT) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(tx, ty, TILE, TILE);
            ctx.shadowColor = '#ea6';
            ctx.shadowBlur = 15;
            ctx.strokeStyle = '#ea6';
            ctx.lineWidth = 2;
            ctx.strokeRect(tx + 4, ty + 2, TILE - 8, TILE - 4);
            // Door handle
            ctx.fillStyle = '#ea6';
            ctx.beginPath();
            ctx.arc(tx + TILE - 10, ty + TILE / 2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          } else if (tile === ENTRANCE) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(tx, ty, TILE, TILE);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(tx + 4, ty + 2, TILE - 8, TILE - 4);
          } else if (tile === ARROW_TRAP) {
            ctx.fillStyle = '#3a2a1a';
            ctx.fillRect(tx, ty, TILE, TILE);
            // Arrow indicator
            ctx.fillStyle = '#a44';
            ctx.beginPath();
            ctx.moveTo(tx + TILE - 4, ty + TILE / 2 - 4);
            ctx.lineTo(tx + TILE, ty + TILE / 2);
            ctx.lineTo(tx + TILE - 4, ty + TILE / 2 + 4);
            ctx.fill();
          }
        }
      }

      ctx.globalAlpha = 1;

      // Draw darkness overlay (fog of war)
      if (gameState === 'playing' && player) {
        const gradient = ctx.createRadialGradient(
          player.x, player.y, TILE * 2,
          player.x, player.y, TILE * (VISIBILITY_RADIUS + 1.5)
        );
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.85)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, W, H);
      }

      // Draw items
      items.forEach(item => {
        if (item.collected) return;
        const dist = Math.sqrt(((item.x / TILE) - playerTileX) ** 2 + ((item.y / TILE) - playerTileY) ** 2);
        if (gameState === 'playing' && dist > VISIBILITY_RADIUS + 1) return;

        ctx.shadowBlur = 8;
        if (item.type === 'gold') {
          ctx.fillStyle = '#fd0';
          ctx.shadowColor = '#fd0';
          ctx.beginPath();
          ctx.arc(item.x, item.y, 5, 0, Math.PI * 2);
          ctx.fill();
        } else if (item.type === 'gem') {
          ctx.fillStyle = '#4af';
          ctx.shadowColor = '#4af';
          // Diamond shape
          ctx.beginPath();
          ctx.moveTo(item.x, item.y - 7);
          ctx.lineTo(item.x + 6, item.y);
          ctx.lineTo(item.x, item.y + 7);
          ctx.lineTo(item.x - 6, item.y);
          ctx.closePath();
          ctx.fill();
        } else if (item.type === 'chest') {
          ctx.fillStyle = '#ea6';
          ctx.shadowColor = '#ea6';
          ctx.fillRect(item.x - 8, item.y - 6, 16, 12);
          ctx.fillStyle = '#864';
          ctx.fillRect(item.x - 8, item.y - 1, 16, 2);
          ctx.fillStyle = '#fd0';
          ctx.fillRect(item.x - 2, item.y - 4, 4, 4);
        }
        ctx.shadowBlur = 0;
      });

      // Draw enemies
      enemies.forEach(e => {
        if (e.dead) return;
        const dist = Math.sqrt(((e.x / TILE) - playerTileX) ** 2 + ((e.y / TILE) - playerTileY) ** 2);
        if (gameState === 'playing' && dist > VISIBILITY_RADIUS + 1) return;

        ctx.shadowBlur = 6;
        if (e.type === 'snake') {
          ctx.fillStyle = '#0a4';
          ctx.shadowColor = '#0a4';
          // Body
          ctx.beginPath();
          ctx.ellipse(e.x, e.y, e.w / 2, e.h / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          // Eyes
          ctx.fillStyle = '#f00';
          ctx.fillRect(e.x + (e.vx > 0 ? 5 : -8), e.y - 4, 3, 3);
          // Tongue
          ctx.strokeStyle = '#f44';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(e.x + (e.vx > 0 ? e.w / 2 : -e.w / 2), e.y);
          ctx.lineTo(e.x + (e.vx > 0 ? e.w / 2 + 6 : -e.w / 2 - 6), e.y - 2);
          ctx.stroke();
        } else if (e.type === 'bat') {
          ctx.fillStyle = '#808';
          ctx.shadowColor = '#808';
          // Body
          ctx.beginPath();
          ctx.ellipse(e.x, e.y, 6, 5, 0, 0, Math.PI * 2);
          ctx.fill();
          // Wings
          const wingOff = Math.sin(e.wingPhase) * 4;
          ctx.beginPath();
          ctx.moveTo(e.x - 4, e.y);
          ctx.lineTo(e.x - 12, e.y - 6 + wingOff);
          ctx.lineTo(e.x - 8, e.y + 2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(e.x + 4, e.y);
          ctx.lineTo(e.x + 12, e.y - 6 - wingOff);
          ctx.lineTo(e.x + 8, e.y + 2);
          ctx.fill();
          // Eyes
          ctx.fillStyle = '#f00';
          ctx.fillRect(e.x - 3, e.y - 3, 2, 2);
          ctx.fillRect(e.x + 1, e.y - 3, 2, 2);
        } else if (e.type === 'spider') {
          ctx.fillStyle = '#640';
          ctx.shadowColor = '#640';
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.w / 2, 0, Math.PI * 2);
          ctx.fill();
          // Legs
          ctx.strokeStyle = '#640';
          ctx.lineWidth = 1.5;
          for (let i = -1; i <= 1; i += 2) {
            for (let j = 0; j < 3; j++) {
              ctx.beginPath();
              ctx.moveTo(e.x + i * 4, e.y + (j - 1) * 4);
              ctx.lineTo(e.x + i * 12, e.y + (j - 1) * 6 + 4);
              ctx.stroke();
            }
          }
          // Eyes
          ctx.fillStyle = '#f44';
          ctx.fillRect(e.x - 4, e.y - 4, 3, 3);
          ctx.fillRect(e.x + 1, e.y - 4, 3, 3);
          // Web line if not yet dropped
          if (!e.dropping) {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - e.h / 2);
            ctx.lineTo(e.x, e.homeY - TILE);
            ctx.stroke();
          }
        }
        ctx.shadowBlur = 0;
      });

      // Draw projectiles
      projectiles.forEach(p => {
        if (p.type === 'arrow') {
          ctx.fillStyle = '#a66';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 4;
          const dir = p.vx > 0 ? 1 : -1;
          ctx.beginPath();
          ctx.moveTo(p.x + dir * 8, p.y);
          ctx.lineTo(p.x - dir * 6, p.y - 3);
          ctx.lineTo(p.x - dir * 6, p.y + 3);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;
        } else if (p.type === 'bomb') {
          ctx.fillStyle = '#444';
          ctx.shadowColor = '#f80';
          ctx.shadowBlur = p.timer < 30 ? 12 : 4;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
          ctx.fill();
          // Fuse
          ctx.strokeStyle = p.timer % 6 < 3 ? '#f80' : '#ff0';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x + 4, p.y - 4);
          ctx.lineTo(p.x + 7, p.y - 8);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
      });

      // Draw player
      if (player && !player.dead) {
        // Blink when invulnerable
        if (player.invuln > 0 && Math.floor(player.invuln / 4) % 2 === 0) {
          // Skip drawing (blink effect)
        } else {
          ctx.shadowColor = '#ea6';
          ctx.shadowBlur = 8;

          // Body
          ctx.fillStyle = '#ea6';
          ctx.fillRect(player.x - player.w / 2, player.y - player.h / 2, player.w, player.h);

          // Head (slightly darker)
          ctx.fillStyle = '#d95';
          ctx.fillRect(player.x - player.w / 2 + 2, player.y - player.h / 2, player.w - 4, 10);

          // Hat
          ctx.fillStyle = '#864';
          ctx.fillRect(player.x - player.w / 2 - 2, player.y - player.h / 2 - 4, player.w + 4, 6);

          // Eyes
          ctx.fillStyle = '#fff';
          const eyeX = player.x + player.facing * 3;
          ctx.fillRect(eyeX - 2, player.y - player.h / 2 + 3, 4, 3);
          ctx.fillStyle = '#000';
          ctx.fillRect(eyeX - 1 + player.facing, player.y - player.h / 2 + 4, 2, 2);

          // Whip
          if (player.whipTimer > 0) {
            ctx.strokeStyle = '#864';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ea6';
            ctx.shadowBlur = 6;
            const whipProgress = 1 - player.whipTimer / WHIP_DURATION;
            const whipLen = WHIP_RANGE * whipProgress;
            ctx.beginPath();
            ctx.moveTo(player.x + player.facing * player.w / 2, player.y);
            ctx.lineTo(player.x + player.facing * (player.w / 2 + whipLen), player.y - 4 + Math.sin(whipProgress * Math.PI) * 8);
            ctx.stroke();
          }

          ctx.shadowBlur = 0;
        }
      }

      // Draw particles
      particles.forEach(p => {
        ctx.globalAlpha = p.life / 40;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // HUD on canvas
      if (gameState === 'playing') {
        // Mini HP bar at top
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(8, 8, 80, 14);
        ctx.fillStyle = player.hp > 1 ? '#0c0' : '#f44';
        ctx.fillRect(10, 10, (player.hp / 4) * 76, 10);
        ctx.strokeStyle = '#ea6';
        ctx.lineWidth = 1;
        ctx.strokeRect(8, 8, 80, 14);
      }
    }

    // --- Keyboard ---
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'b', 'B', 'r', 'R'].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        if (e.key === ' ' && player.whipTimer <= 0 && player.stunned <= 0) {
          player.whipTimer = WHIP_DURATION;
        }
        if (e.key === 'b' || e.key === 'B') {
          placeBomb();
        }
        if (e.key === 'r' || e.key === 'R') {
          placeRope();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Expose game data for ML
    window.gameData = {};
    function updateGameData() {
      if (!player) return;
      window.gameData = {
        playerX: player.x,
        playerY: player.y,
        playerHP: player.hp,
        bombs: player.bombs,
        ropes: player.ropes,
        level: levelNum,
        enemies: enemies.filter(e => !e.dead).map(e => ({ type: e.type, x: e.x, y: e.y })),
        items: items.filter(i => !i.collected).map(i => ({ type: i.type, x: i.x, y: i.y }))
      };
    }

    // Update gameData periodically
    setInterval(updateGameData, 250);

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

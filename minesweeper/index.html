<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minesweeper</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 400px;
    }
    .back { color: #8f0; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136, 255, 0, 0.4); }
    h1 { color: #8f0; font-size: 2rem; text-shadow: 0 0 15px rgba(136, 255, 0, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 400px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8f0; }
    canvas {
      border: 2px solid #8f0;
      box-shadow: 0 0 20px rgba(136, 255, 0, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8f0;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>MINESWEEPER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="400" height="440"></canvas>
    <div class="overlay" id="overlay" style="width:400px;height:440px;">
      <h2 id="overlayTitle">MINESWEEPER</h2>
      <p id="overlayText">Click anywhere to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const COLS = 16;
    const ROWS = 16;
    const CELL = 25; // 25px per cell => 400px total
    const HEADER_H = 40; // header area at top of canvas
    const MINES = 40;

    // Number colors (1-8) - bright enough to read on dark background
    const NUM_COLORS = [
      null,       // 0 unused
      '#48f',     // 1 blue
      '#0c0',     // 2 green
      '#f44',     // 3 red
      '#88f',     // 4 purple-blue
      '#c44',     // 5 dark red
      '#0cc',     // 6 teal
      '#c8c',     // 7 pink
      '#aaa'      // 8 gray
    ];

    let score, best = 0, gameState;
    let grid;        // 2D: { mine, revealed, flagged, adjacent }
    let minesPlaced; // whether mines have been placed (first click safety)
    let startTime;
    let revealedCount;
    let flagCount;
    let gameWon;
    let timerInterval;

    // Prevent context menu on canvas
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'MINESWEEPER';
      overlayText.textContent = 'Click anywhere to start';
      minesPlaced = false;
      revealedCount = 0;
      flagCount = 0;
      gameWon = false;
      startTime = 0;
      clearInterval(timerInterval);

      // Create empty grid
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = { mine: false, revealed: false, flagged: false, adjacent: 0 };
        }
      }

      draw();
    }

    function placeMines(safeR, safeC) {
      // Place mines avoiding the safe cell and its neighbors
      let placed = 0;
      while (placed < MINES) {
        const r = Math.floor(Math.random() * ROWS);
        const c = Math.floor(Math.random() * COLS);
        if (grid[r][c].mine) continue;
        // Safe zone: the clicked cell and all 8 neighbors
        if (Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1) continue;
        grid[r][c].mine = true;
        placed++;
      }

      // Calculate adjacent counts
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c].mine) continue;
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr, nc = c + dc;
              if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && grid[nr][nc].mine) {
                count++;
              }
            }
          }
          grid[r][c].adjacent = count;
        }
      }
      minesPlaced = true;
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      startTime = Date.now();
      timerInterval = setInterval(() => {
        if (gameState === 'playing') draw();
      }, 1000);
    }

    function revealCell(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
      const cell = grid[r][c];
      if (cell.revealed || cell.flagged) return;

      cell.revealed = true;
      revealedCount++;

      if (cell.mine) {
        // Game over - hit a mine
        gameOver(false);
        return;
      }

      // Update score for each revealed cell
      score = revealedCount;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }

      // Flood fill if no adjacent mines
      if (cell.adjacent === 0) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            revealCell(r + dr, c + dc);
          }
        }
      }

      // Check win condition
      if (revealedCount === ROWS * COLS - MINES) {
        gameOver(true);
      }
    }

    function gameOver(won) {
      clearInterval(timerInterval);
      gameWon = won;
      gameState = 'over';

      if (won) {
        // Time bonus: faster = more points. Base is revealed cells + time bonus.
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const timeBonus = Math.max(0, 500 - elapsed * 2);
        score = revealedCount + timeBonus;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
      }

      // Reveal all mines
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c].mine) {
            grid[r][c].revealed = true;
          }
        }
      }

      draw();

      overlay.style.display = 'flex';
      if (won) {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        overlayTitle.textContent = 'YOU WIN!';
        overlayText.textContent = `Score: ${score} (${elapsed}s) \u2014 Press any key to play again`;
      } else {
        overlayTitle.textContent = 'GAME OVER';
        overlayText.textContent = `Score: ${score} \u2014 Press any key to restart`;
      }
    }

    function getGridPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const c = Math.floor(x / CELL);
      const r = Math.floor((y - HEADER_H) / CELL);
      return { r, c, x, y };
    }

    // Mouse handlers
    canvas.addEventListener('mousedown', (e) => {
      if (gameState === 'waiting') {
        start();
        // Fall through to handle the click as a game action
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState !== 'playing') return;

      const { r, c } = getGridPos(e);
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;

      if (e.button === 0) {
        // Left click - reveal
        if (grid[r][c].flagged) return; // Can't reveal flagged cells

        if (!minesPlaced) {
          placeMines(r, c);
        }

        revealCell(r, c);
        draw();
        updateGameData();
      } else if (e.button === 2) {
        // Right click - flag/unflag
        if (grid[r][c].revealed) return;
        grid[r][c].flagged = !grid[r][c].flagged;
        flagCount += grid[r][c].flagged ? 1 : -1;
        draw();
        updateGameData();
      }
    });

    // Keyboard handler for state transitions
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Draw header area
      drawHeader();

      // Draw grid
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          drawCell(r, c);
        }
      }

      // Draw grid lines
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, HEADER_H + r * CELL);
        ctx.lineTo(W, HEADER_H + r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * CELL, HEADER_H);
        ctx.lineTo(c * CELL, H);
        ctx.stroke();
      }
    }

    function drawHeader() {
      // Timer
      const elapsed = gameState === 'playing' ? Math.floor((Date.now() - startTime) / 1000) : 0;

      ctx.fillStyle = '#8f0';
      ctx.shadowColor = '#8f0';
      ctx.shadowBlur = 6;
      ctx.font = '16px Courier New';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('\u23F1 ' + String(elapsed).padStart(3, '0'), 8, HEADER_H / 2);

      // Mine counter (mines remaining = MINES - flagCount)
      const remaining = MINES - flagCount;
      ctx.textAlign = 'right';
      ctx.fillText('\u2739 ' + String(remaining).padStart(2, '0'), W - 8, HEADER_H / 2);

      // Center: cells revealed / total non-mine cells
      const totalSafe = ROWS * COLS - MINES;
      ctx.textAlign = 'center';
      ctx.fillText(revealedCount + '/' + totalSafe, W / 2, HEADER_H / 2);

      ctx.shadowBlur = 0;

      // Header separator line
      ctx.strokeStyle = '#8f0';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.moveTo(0, HEADER_H - 1);
      ctx.lineTo(W, HEADER_H - 1);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawCell(r, c) {
      const cell = grid[r][c];
      const x = c * CELL;
      const y = HEADER_H + r * CELL;

      if (!cell.revealed) {
        // Unrevealed cell - slightly raised appearance
        ctx.fillStyle = '#1e2d4a';
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);

        // Highlight edge (top + left) for raised effect
        ctx.fillStyle = '#2a3f5f';
        ctx.fillRect(x + 1, y + 1, CELL - 2, 2);
        ctx.fillRect(x + 1, y + 1, 2, CELL - 2);

        // Shadow edge (bottom + right) for raised effect
        ctx.fillStyle = '#121d32';
        ctx.fillRect(x + 1, y + CELL - 3, CELL - 2, 2);
        ctx.fillRect(x + CELL - 3, y + 1, 2, CELL - 2);

        // Draw flag
        if (cell.flagged) {
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 6;
          ctx.font = '14px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('\u2691', x + CELL / 2, y + CELL / 2);
          ctx.shadowBlur = 0;
        }
      } else {
        // Revealed cell
        ctx.fillStyle = '#141e30';
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);

        if (cell.mine) {
          // Draw mine as a filled circle
          ctx.fillStyle = '#f44';
          ctx.shadowColor = '#f44';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(x + CELL / 2, y + CELL / 2, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Mine inner dot
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(x + CELL / 2, y + CELL / 2, 2, 0, Math.PI * 2);
          ctx.fill();
        } else if (cell.adjacent > 0) {
          // Draw number
          ctx.fillStyle = NUM_COLORS[cell.adjacent];
          ctx.shadowColor = NUM_COLORS[cell.adjacent];
          ctx.shadowBlur = 4;
          ctx.font = 'bold 15px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(cell.adjacent), x + CELL / 2, y + CELL / 2 + 1);
          ctx.shadowBlur = 0;
        }
      }
    }

    // Expose game data for potential ML extraction
    window.gameData = {};
    function updateGameData() {
      window.gameData = {
        revealedCount,
        flagCount,
        minesRemaining: MINES - flagCount,
        totalCells: ROWS * COLS,
        totalMines: MINES,
        gameWon,
        grid: grid.map(row => row.map(cell => ({
          mine: cell.mine,
          revealed: cell.revealed,
          flagged: cell.flagged,
          adjacent: cell.adjacent
        })))
      };
    }

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advance Wars Online</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #e44; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(228, 68, 68, 0.5); }
    h1 { color: #e44; font-size: 1.4rem; text-shadow: 0 0 15px rgba(228, 68, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 0.95rem;
    }
    .score-bar span { color: #e44; }
    .score-bar .blue { color: #4af; }
    canvas {
      border: 2px solid #e44;
      box-shadow: 0 0 20px rgba(228, 68, 68, 0.2);
      display: block;
      cursor: pointer;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #e44;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(228, 68, 68, 0.6); }
    .overlay p { font-size: 1rem; color: #aaa; margin: 4px 0; }
    .overlay .start { color: #e44; font-size: 1.1rem; margin-top: 12px; }
    #info-bar {
      width: 600px;
      margin-top: 8px;
      font-size: 0.85rem;
      color: #888;
      min-height: 20px;
    }
    #info-bar span { color: #e44; }
    #info-bar .blue { color: #4af; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>ADVANCE WARS ONLINE</h1>
  </div>
  <div class="score-bar">
    <div>Turn: <span id="turnNum">1</span> | <span id="playerLabel">RED</span> Gold: <span id="gold">0</span></div>
    <div>Score: <span id="score">0</span> | Cities: <span id="cities">0</span>/<span id="totalCities">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:500px;">
      <h2 id="overlayTitle">ADVANCE WARS ONLINE</h2>
      <p>Turn-based tactical combat</p>
      <p>Capture cities, build armies, destroy the enemy</p>
      <p class="start" id="overlayText">Click to Deploy</p>
    </div>
  </div>
  <div id="info-bar"></div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 500;
    const scoreEl = document.getElementById('score');
    const turnEl = document.getElementById('turnNum');
    const goldEl = document.getElementById('gold');
    const citiesEl = document.getElementById('cities');
    const totalCitiesEl = document.getElementById('totalCities');
    const playerLabelEl = document.getElementById('playerLabel');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const infoBar = document.getElementById('info-bar');

    const COLS = 16, ROWS = 12;
    const TILE = Math.min(Math.floor(W / COLS), Math.floor(H / ROWS));
    const OX = Math.floor((W - COLS * TILE) / 2);
    const OY = Math.floor((H - ROWS * TILE) / 2);

    const T = { PLAIN: 0, FOREST: 1, MOUNTAIN: 2, ROAD: 3, CITY: 4, FACTORY: 5, HQ: 6, RIVER: 7 };
    const TERRAIN_NAMES = ['Plain','Forest','Mountain','Road','City','Factory','HQ','River'];
    const TERRAIN_DEF = [0, 1, 3, 0, 2, 1, 3, 0];
    const TERRAIN_MOVE = [1, 2, 99, 0.5, 1, 1, 1, 99];
    const TERRAIN_INF_MOVE = [1, 1, 2, 0.5, 1, 1, 1, 2];

    const U = { INFANTRY: 0, TANK: 1, ARTILLERY: 2, ANTIAIR: 3 };
    const UNIT_NAMES = ['Infantry','Tank','Artillery','Anti-Air'];
    const UNIT_COST = [1000, 3000, 2500, 2500];
    const UNIT_HP = [10, 10, 10, 10];
    const UNIT_ATK = [5, 8, 9, 7];
    const UNIT_MOVE = [3, 5, 4, 5];
    const UNIT_RANGE_MIN = [1, 1, 2, 1];
    const UNIT_RANGE_MAX = [1, 1, 3, 1];
    const UNIT_IS_VEHICLE = [false, true, true, true];

    const P = { RED: 0, BLUE: 1 };

    let gameState = 'menu';
    let score = 0;
    let map = [];
    let tileOwner = [];
    let units = [];
    let currentPlayer = P.RED;
    let turn = 1;
    let gold = [5000, 5000];
    let selectedUnit = null;
    let movableTiles = [];
    let attackableTiles = [];
    let phase = 'select';
    let fogMap = [];
    let lastAction = '';
    let productionFactory = null;
    let aiThinking = false;
    let unitsMoved = new Set();
    let unitsDestroyed = [0, 0];
    let damageFlashes = [];

    function generateMap() {
      map = []; tileOwner = [];
      for (let y = 0; y < ROWS; y++) {
        map[y] = []; tileOwner[y] = [];
        for (let x = 0; x < COLS; x++) {
          map[y][x] = T.PLAIN; tileOwner[y][x] = -1;
        }
      }
      for (let x = 0; x < COLS; x++) { map[5][x] = T.ROAD; map[6][x] = T.ROAD; }
      for (let y = 0; y < ROWS; y++) { map[y][4] = T.ROAD; map[y][11] = T.ROAD; }
      for (let y = 2; y < 10; y++) { map[y][7] = T.RIVER; map[y][8] = T.RIVER; }
      map[5][7] = T.ROAD; map[5][8] = T.ROAD; map[6][7] = T.ROAD; map[6][8] = T.ROAD;
      [[1,1],[1,2],[2,2],[3,1],[0,5],[1,6],[2,5],[9,0],[10,1],[10,2],
       [1,13],[1,14],[2,13],[3,14],[0,10],[1,9],[2,10],[9,15],[10,14],[10,13],
       [4,3],[7,3],[4,12],[7,12],[9,5],[9,10]].forEach(([y,x])=>{if(y<ROWS&&x<COLS)map[y][x]=T.FOREST;});
      [[3,3],[3,5],[8,3],[8,5],[3,10],[3,12],[8,10],[8,12],[5,2],[6,13]].forEach(([y,x])=>{if(y<ROWS&&x<COLS)map[y][x]=T.MOUNTAIN;});
      map[5][0] = T.HQ; tileOwner[5][0] = P.RED;
      map[6][15] = T.HQ; tileOwner[6][15] = P.BLUE;
      map[2][1] = T.FACTORY; tileOwner[2][1] = P.RED;
      map[8][1] = T.FACTORY; tileOwner[8][1] = P.RED;
      map[2][14] = T.FACTORY; tileOwner[2][14] = P.BLUE;
      map[8][14] = T.FACTORY; tileOwner[8][14] = P.BLUE;
      map[5][5] = T.FACTORY; tileOwner[5][5] = -1;
      map[6][10] = T.FACTORY; tileOwner[6][10] = -1;
      [[1,3],[4,1],[6,3],[9,2],[0,0],[11,1]].forEach(([y,x])=>{map[y][x]=T.CITY;tileOwner[y][x]=P.RED;});
      [[1,12],[4,14],[6,12],[9,13],[0,15],[11,14]].forEach(([y,x])=>{map[y][x]=T.CITY;tileOwner[y][x]=P.BLUE;});
      [[3,6],[8,6],[3,9],[8,9],[5,9],[6,6],[0,7],[11,8]].forEach(([y,x])=>{map[y][x]=T.CITY;tileOwner[y][x]=-1;});
    }

    function createUnit(type, player, x, y) {
      return { type, player, x, y, hp: UNIT_HP[type], moved: false, attacked: false, id: Math.random().toString(36).substr(2,9) };
    }

    function spawnStartingUnits() {
      units = [];
      units.push(createUnit(U.INFANTRY, P.RED, 1, 5));
      units.push(createUnit(U.INFANTRY, P.RED, 1, 6));
      units.push(createUnit(U.INFANTRY, P.RED, 2, 4));
      units.push(createUnit(U.TANK, P.RED, 0, 6));
      units.push(createUnit(U.TANK, P.RED, 2, 6));
      units.push(createUnit(U.INFANTRY, P.BLUE, 14, 5));
      units.push(createUnit(U.INFANTRY, P.BLUE, 14, 6));
      units.push(createUnit(U.INFANTRY, P.BLUE, 13, 7));
      units.push(createUnit(U.TANK, P.BLUE, 15, 5));
      units.push(createUnit(U.TANK, P.BLUE, 13, 5));
    }

    function unitAt(x, y) { return units.find(u => u.x === x && u.y === y && u.hp > 0); }

    function getMoveCost(x, y, unitType) {
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return 999;
      const t = map[y][x];
      if (t === T.RIVER) return UNIT_IS_VEHICLE[unitType] ? 999 : 2;
      if (t === T.MOUNTAIN && UNIT_IS_VEHICLE[unitType]) return 999;
      return UNIT_IS_VEHICLE[unitType] ? TERRAIN_MOVE[t] : TERRAIN_INF_MOVE[t];
    }

    function getReachableTiles(unit) {
      const tiles = {};
      const key = (x,y) => x+','+y;
      const open = [[unit.x, unit.y, UNIT_MOVE[unit.type]]];
      tiles[key(unit.x, unit.y)] = UNIT_MOVE[unit.type];
      while (open.length > 0) {
        const [cx, cy, rem] = open.shift();
        for (const [dx,dy] of [[0,-1],[0,1],[-1,0],[1,0]]) {
          const nx = cx+dx, ny = cy+dy;
          if (nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const cost = getMoveCost(nx, ny, unit.type);
          const nr = rem - cost;
          if (nr < 0) continue;
          const k = key(nx, ny);
          if (tiles[k] !== undefined && tiles[k] >= nr) continue;
          const blocker = unitAt(nx, ny);
          if (blocker && blocker.player !== unit.player) continue;
          tiles[k] = nr;
          open.push([nx, ny, nr]);
        }
      }
      const result = [];
      for (const k in tiles) {
        const [x,y] = k.split(',').map(Number);
        const occ = unitAt(x, y);
        if (!occ || (occ.x === unit.x && occ.y === unit.y)) result.push({x,y});
      }
      return result;
    }

    function getAttackTargets(unit, fromX, fromY) {
      const targets = [];
      const minR = UNIT_RANGE_MIN[unit.type], maxR = UNIT_RANGE_MAX[unit.type];
      for (let dy = -maxR; dy <= maxR; dy++) {
        for (let dx = -maxR; dx <= maxR; dx++) {
          const dist = Math.abs(dx)+Math.abs(dy);
          if (dist < minR || dist > maxR) continue;
          const nx = fromX+dx, ny = fromY+dy;
          if (nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const target = unitAt(nx, ny);
          if (target && target.player !== unit.player) targets.push({x:nx,y:ny,unit:target});
        }
      }
      return targets;
    }

    function calcDamage(attacker, defender) {
      const atkPower = UNIT_ATK[attacker.type] * (attacker.hp / UNIT_HP[attacker.type]);
      const defBonus = TERRAIN_DEF[map[defender.y][defender.x]];
      const def = 1 + defBonus * 0.1;
      let dmg = Math.round(atkPower / def * (0.9 + Math.random()*0.2));
      if (attacker.type===U.TANK && defender.type===U.INFANTRY) dmg = Math.round(dmg*1.3);
      if (attacker.type===U.ARTILLERY) dmg = Math.round(dmg*1.1);
      if (attacker.type===U.ANTIAIR && defender.type===U.INFANTRY) dmg = Math.round(dmg*1.2);
      return Math.max(1, Math.min(dmg, defender.hp));
    }

    function doAttack(attacker, defender) {
      const dmg = calcDamage(attacker, defender);
      defender.hp -= dmg;
      damageFlashes.push({x:defender.x, y:defender.y, dmg, t:30, color:'#f44'});
      let counterDmg = 0;
      if (defender.hp > 0 && UNIT_RANGE_MIN[attacker.type] === 1) {
        const dist = Math.abs(attacker.x-defender.x)+Math.abs(attacker.y-defender.y);
        if (dist >= UNIT_RANGE_MIN[defender.type] && dist <= UNIT_RANGE_MAX[defender.type]) {
          counterDmg = calcDamage(defender, attacker);
          counterDmg = Math.max(1, Math.round(counterDmg*0.7));
          attacker.hp -= counterDmg;
          damageFlashes.push({x:attacker.x, y:attacker.y, dmg:counterDmg, t:30, color:'#fa4'});
        }
      }
      if (defender.hp <= 0) { unitsDestroyed[attacker.player]++; units = units.filter(u=>u!==defender); }
      if (attacker.hp <= 0) { unitsDestroyed[defender.player]++; units = units.filter(u=>u!==attacker); }
      attacker.attacked = true; attacker.moved = true;
      return {dmg, counterDmg};
    }

    function processCapturesForPlayer(player) {
      units.forEach(u => {
        if (u.player !== player || u.hp <= 0 || u.type !== U.INFANTRY) return;
        const t = map[u.y][u.x];
        if ((t===T.CITY||t===T.FACTORY||t===T.HQ) && tileOwner[u.y][u.x] !== player) {
          tileOwner[u.y][u.x] = player;
          lastAction = UNIT_NAMES[u.type]+' captured '+TERRAIN_NAMES[t]+'!';
        }
      });
    }

    function updateFog() {
      fogMap = [];
      for (let y = 0; y < ROWS; y++) { fogMap[y] = []; for (let x = 0; x < COLS; x++) fogMap[y][x] = false; }
      for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
        if (tileOwner[y][x] === P.RED) revealAround(x, y, 2);
      }
      units.forEach(u => {
        if (u.player === P.RED && u.hp > 0) {
          revealAround(u.x, u.y, map[u.y][u.x]===T.MOUNTAIN ? 4 : 3);
        }
      });
    }

    function revealAround(cx, cy, r) {
      for (let dy = -r; dy <= r; dy++) for (let dx = -r; dx <= r; dx++) {
        if (Math.abs(dx)+Math.abs(dy) > r) continue;
        const nx = cx+dx, ny = cy+dy;
        if (nx>=0&&nx<COLS&&ny>=0&&ny<ROWS) fogMap[ny][nx] = true;
      }
    }

    function collectIncome(player) {
      let income = 1000;
      for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
        if (tileOwner[y][x] === player) {
          if (map[y][x]===T.CITY) income += 500;
          if (map[y][x]===T.FACTORY) income += 500;
          if (map[y][x]===T.HQ) income += 1000;
        }
      }
      gold[player] += income;
      return income;
    }

    function updateScore() {
      let s = unitsDestroyed[P.RED] * 100;
      let rc = 0, tc = 0;
      for (let y = 0; y < ROWS; y++) for (let x = 0; x < COLS; x++) {
        if (map[y][x]===T.CITY||map[y][x]===T.FACTORY) { tc++; if (tileOwner[y][x]===P.RED) rc++; }
      }
      s += rc * 50;
      score = s;
      scoreEl.textContent = score;
      citiesEl.textContent = rc;
      totalCitiesEl.textContent = tc;
    }

    function startTurn(player) {
      currentPlayer = player;
      unitsMoved.clear();
      selectedUnit = null; movableTiles = []; attackableTiles = [];
      phase = 'select'; productionFactory = null;
      units.forEach(u => { if (u.player===player) { u.moved=false; u.attacked=false; } });
      processCapturesForPlayer(player);
      const income = collectIncome(player);
      updateFog(); updateScore(); updateUI();
      if (player === P.RED) {
        lastAction = 'Your turn! Income: +'+income+' gold';
      } else {
        lastAction = 'AI is thinking...';
        aiThinking = true;
        setTimeout(aiTurn, 600);
      }
    }

    function endTurn() {
      if (currentPlayer === P.RED) { startTurn(P.BLUE); }
      else { turn++; turnEl.textContent = turn; startTurn(P.RED); }
    }

    function checkVictory() {
      if (tileOwner[5][0] === P.BLUE) return P.BLUE;
      if (tileOwner[6][15] === P.RED) return P.RED;
      const redU = units.filter(u=>u.player===P.RED&&u.hp>0);
      const blueU = units.filter(u=>u.player===P.BLUE&&u.hp>0);
      // Check no units AND no production capability
      if (redU.length===0 && turn>1) {
        let canProduce = false;
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          if (map[y][x]===T.FACTORY && tileOwner[y][x]===P.RED && gold[P.RED]>=1000) canProduce=true;
        }
        if (!canProduce) return P.BLUE;
      }
      if (blueU.length===0 && turn>1) {
        let canProduce = false;
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          if (map[y][x]===T.FACTORY && tileOwner[y][x]===P.BLUE && gold[P.BLUE]>=1000) canProduce=true;
        }
        if (!canProduce) return P.RED;
      }
      return -1;
    }

    function updateUI() {
      goldEl.textContent = gold[P.RED];
      playerLabelEl.textContent = currentPlayer===P.RED?'RED':'BLUE';
      playerLabelEl.style.color = currentPlayer===P.RED?'#e44':'#4af';
    }

    const TERRAIN_COLORS = {
      [T.PLAIN]:'#4a7a3a', [T.FOREST]:'#2d5a1e', [T.MOUNTAIN]:'#7a6b5a',
      [T.ROAD]:'#8a8070', [T.CITY]:'#6a6a7a', [T.FACTORY]:'#5a5a6a',
      [T.HQ]:'#8a7a4a', [T.RIVER]:'#3a5a8a'
    };

    function drawTile(x, y) {
      const px = OX+x*TILE, py = OY+y*TILE, t = map[y][x];
      const visible = fogMap[y]&&fogMap[y][x];
      ctx.fillStyle = visible ? TERRAIN_COLORS[t] : '#2a2a3e';
      ctx.fillRect(px, py, TILE, TILE);
      if (!visible) { ctx.strokeStyle='#333348'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,TILE,TILE); return; }
      ctx.save();
      if (t===T.FOREST) {
        ctx.fillStyle='#1a4a10';
        ctx.beginPath(); ctx.arc(px+TILE*0.3,py+TILE*0.5,TILE*0.2,0,Math.PI*2);
        ctx.arc(px+TILE*0.65,py+TILE*0.4,TILE*0.22,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#2d6a1e';
        ctx.beginPath(); ctx.arc(px+TILE*0.5,py+TILE*0.55,TILE*0.18,0,Math.PI*2); ctx.fill();
      } else if (t===T.MOUNTAIN) {
        ctx.fillStyle='#9a8a7a';
        ctx.beginPath(); ctx.moveTo(px+TILE*0.2,py+TILE*0.8);
        ctx.lineTo(px+TILE*0.5,py+TILE*0.15); ctx.lineTo(px+TILE*0.8,py+TILE*0.8); ctx.fill();
        ctx.fillStyle='#ccc';
        ctx.beginPath(); ctx.moveTo(px+TILE*0.4,py+TILE*0.3);
        ctx.lineTo(px+TILE*0.5,py+TILE*0.15); ctx.lineTo(px+TILE*0.6,py+TILE*0.3); ctx.fill();
      } else if (t===T.CITY||t===T.FACTORY||t===T.HQ) {
        const owner = tileOwner[y][x];
        let bColor = '#888';
        if (owner===P.RED) bColor='#c44'; else if (owner===P.BLUE) bColor='#44c';
        if (t===T.HQ) {
          ctx.fillStyle=bColor; ctx.fillRect(px+4,py+4,TILE-8,TILE-8);
          ctx.fillStyle='#fff'; ctx.font='bold '+Math.floor(TILE*0.35)+'px Courier New';
          ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('HQ',px+TILE/2,py+TILE/2);
        } else if (t===T.FACTORY) {
          ctx.fillStyle=bColor; ctx.fillRect(px+3,py+TILE*0.3,TILE-6,TILE*0.55);
          ctx.fillRect(px+TILE*0.6,py+2,TILE*0.15,TILE*0.35);
          ctx.fillStyle='#555'; ctx.fillRect(px+5,py+TILE*0.45,TILE-10,2);
        } else {
          ctx.fillStyle=bColor;
          ctx.fillRect(px+TILE*0.15,py+TILE*0.25,TILE*0.3,TILE*0.6);
          ctx.fillRect(px+TILE*0.5,py+TILE*0.35,TILE*0.35,TILE*0.5);
          ctx.fillStyle='#ff8';
          ctx.fillRect(px+TILE*0.25,py+TILE*0.35,3,3);
          ctx.fillRect(px+TILE*0.25,py+TILE*0.55,3,3);
          ctx.fillRect(px+TILE*0.58,py+TILE*0.45,3,3);
        }
      } else if (t===T.RIVER) {
        for (let i=0;i<3;i++) {
          const wy=py+TILE*(0.2+i*0.3);
          ctx.beginPath(); ctx.moveTo(px,wy);
          ctx.quadraticCurveTo(px+TILE*0.5,wy-3,px+TILE,wy);
          ctx.strokeStyle='#5a7aaa'; ctx.lineWidth=1.5; ctx.stroke();
        }
      } else if (t===T.ROAD) {
        ctx.fillStyle='#9a9080'; ctx.fillRect(px+2,py+2,TILE-4,TILE-4);
        ctx.strokeStyle='#aaa090'; ctx.lineWidth=1; ctx.setLineDash([3,3]);
        ctx.beginPath(); ctx.moveTo(px+TILE/2,py); ctx.lineTo(px+TILE/2,py+TILE); ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=0.5; ctx.strokeRect(px,py,TILE,TILE);
    }

    function drawUnit(unit) {
      if (!fogMap[unit.y]||!fogMap[unit.y][unit.x]) { if (unit.player===P.BLUE) return; }
      const px=OX+unit.x*TILE, py=OY+unit.y*TILE;
      const cx=px+TILE/2, cy=py+TILE/2;
      const isRed = unit.player===P.RED;
      const baseColor = isRed?'#e44':'#48f';
      const darkColor = isRed?'#a22':'#26a';
      ctx.fillStyle = unit.moved?darkColor:baseColor;
      const r = TILE*0.35;
      if (unit.type===U.INFANTRY) {
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.stroke();
        ctx.fillStyle='#fff';
        ctx.beginPath(); ctx.arc(cx,cy-r*0.3,r*0.25,0,Math.PI*2); ctx.fill();
        ctx.fillRect(cx-1,cy-r*0.05,2,r*0.5);
      } else if (unit.type===U.TANK) {
        const w=TILE*0.65, h=TILE*0.45;
        ctx.beginPath(); ctx.roundRect(cx-w/2,cy-h/2,w,h,4); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.stroke();
        ctx.fillStyle=isRed?'#c33':'#36d';
        ctx.beginPath(); ctx.arc(cx,cy,r*0.4,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#fff'; ctx.fillRect(cx,cy-1.5,TILE*0.25,3);
      } else if (unit.type===U.ARTILLERY) {
        ctx.beginPath(); ctx.moveTo(cx,cy-r); ctx.lineTo(cx+r,cy);
        ctx.lineTo(cx,cy+r); ctx.lineTo(cx-r,cy); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.stroke();
        ctx.fillStyle='#fff'; ctx.save(); ctx.translate(cx,cy);
        ctx.rotate(-Math.PI/4); ctx.fillRect(0,-1.5,TILE*0.3,3); ctx.restore();
      } else if (unit.type===U.ANTIAIR) {
        ctx.beginPath(); ctx.moveTo(cx,cy-r);
        ctx.lineTo(cx+r*0.95,cy-r*0.3); ctx.lineTo(cx+r*0.6,cy+r*0.9);
        ctx.lineTo(cx-r*0.6,cy+r*0.9); ctx.lineTo(cx-r*0.95,cy-r*0.3);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.stroke();
        ctx.fillStyle='#fff';
        ctx.fillRect(cx-3,cy-r*0.6,2,r*0.8);
        ctx.fillRect(cx+1,cy-r*0.6,2,r*0.8);
      }
      if (unit.hp < UNIT_HP[unit.type]) {
        const barW=TILE*0.7, barH=3, barX=cx-barW/2, barY=py+TILE-6;
        ctx.fillStyle='#333'; ctx.fillRect(barX,barY,barW,barH);
        const pct = unit.hp/UNIT_HP[unit.type];
        ctx.fillStyle = pct>0.5?'#4c4':pct>0.25?'#cc4':'#c44';
        ctx.fillRect(barX,barY,barW*pct,barH);
      }
      ctx.fillStyle='#fff'; ctx.font='bold '+Math.floor(TILE*0.28)+'px Courier New';
      ctx.textAlign='center'; ctx.textBaseline='bottom';
      ctx.fillText(unit.hp.toString(),cx,py+TILE-1);
    }

    function drawHighlights() {
      movableTiles.forEach(({x,y})=>{
        const px=OX+x*TILE, py2=OY+y*TILE;
        ctx.fillStyle='rgba(68,170,255,0.25)'; ctx.fillRect(px,py2,TILE,TILE);
        ctx.strokeStyle='rgba(68,170,255,0.5)'; ctx.lineWidth=1; ctx.strokeRect(px+1,py2+1,TILE-2,TILE-2);
      });
      attackableTiles.forEach(({x,y})=>{
        const px=OX+x*TILE, py2=OY+y*TILE;
        ctx.fillStyle='rgba(228,68,68,0.3)'; ctx.fillRect(px,py2,TILE,TILE);
        ctx.strokeStyle='rgba(228,68,68,0.7)'; ctx.lineWidth=1.5; ctx.strokeRect(px+1,py2+1,TILE-2,TILE-2);
      });
      if (selectedUnit) {
        const px=OX+selectedUnit.x*TILE, py2=OY+selectedUnit.y*TILE;
        ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(px,py2,TILE,TILE);
      }
    }

    function drawDamageFlashes() {
      damageFlashes = damageFlashes.filter(f=>{
        f.t--;
        if (f.t<=0) return false;
        const px=OX+f.x*TILE+TILE/2, py=OY+f.y*TILE+TILE/2-10+(30-f.t)*0.5;
        const alpha = f.t/30;
        ctx.fillStyle=f.color; ctx.globalAlpha=alpha;
        ctx.font='bold 14px Courier New'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText('-'+f.dmg, px, py);
        ctx.globalAlpha=1;
        return true;
      });
    }

    function drawProductionMenu() {
      if (phase!=='production'||!productionFactory) return;
      const menuX=W/2-130, menuY=H/2-85, menuW=260, menuH=170;
      ctx.fillStyle='rgba(20,20,40,0.95)'; ctx.strokeStyle='#e44'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.roundRect(menuX,menuY,menuW,menuH,8); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#e44'; ctx.font='bold 14px Courier New'; ctx.textAlign='center';
      ctx.fillText('PRODUCE UNIT',W/2,menuY+20);
      ctx.fillStyle='#aaa'; ctx.font='11px Courier New';
      ctx.fillText('Gold: '+gold[P.RED],W/2,menuY+35);
      const types=[U.INFANTRY,U.TANK,U.ARTILLERY,U.ANTIAIR];
      const occupied = unitAt(productionFactory.x, productionFactory.y);
      types.forEach((type,i)=>{
        const bx=menuX+10, by=menuY+45+i*28, bw=menuW-20, bh=24;
        const canAfford = gold[P.RED]>=UNIT_COST[type];
        ctx.fillStyle=(canAfford&&!occupied)?'rgba(228,68,68,0.2)':'rgba(100,100,100,0.15)';
        ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,4); ctx.fill();
        ctx.strokeStyle=(canAfford&&!occupied)?'#e44':'#555'; ctx.lineWidth=1; ctx.stroke();
        ctx.fillStyle=(canAfford&&!occupied)?'#eee':'#666';
        ctx.font='12px Courier New'; ctx.textAlign='left';
        ctx.fillText(UNIT_NAMES[type],bx+10,by+16);
        ctx.textAlign='right'; ctx.fillText(UNIT_COST[type]+'g',bx+bw-10,by+16);
      });
      ctx.fillStyle='#888'; ctx.font='10px Courier New'; ctx.textAlign='center';
      ctx.fillText('[Right-click or ESC to cancel]',W/2,menuY+menuH-8);
    }

    function drawEndTurnButton() {
      if (currentPlayer!==P.RED||gameState!=='playing'||phase==='production') return;
      const bx=W-95, by=H-30, bw=85, bh=24;
      ctx.fillStyle='rgba(228,68,68,0.3)'; ctx.strokeStyle='#e44'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,4); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#e44'; ctx.font='bold 11px Courier New';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('END TURN',bx+bw/2,by+bh/2);
    }

    function drawMiniStatus() {
      // Show unit counts at bottom left
      if (gameState!=='playing') return;
      const redU = units.filter(u=>u.player===P.RED&&u.hp>0).length;
      const blueU = units.filter(u=>u.player===P.BLUE&&u.hp>0).length;
      ctx.fillStyle='rgba(20,20,40,0.7)';
      ctx.fillRect(2,H-28,145,26);
      ctx.font='10px Courier New'; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.fillStyle='#e44'; ctx.fillText('RED:'+redU+' units',8,H-15);
      ctx.fillStyle='#4af'; ctx.fillText('BLU:'+blueU+' units',78,H-15);
    }

    function drawHoverInfo() {
      if (gameState!=='playing'||currentPlayer!==P.RED) return;
      // Get mouse position and show tile info
      if (hoverTile) {
        const t = map[hoverTile.y][hoverTile.x];
        const def = TERRAIN_DEF[t];
        let info = TERRAIN_NAMES[t];
        if (def > 0) info += ' DEF+'+def;
        const owner = tileOwner[hoverTile.y][hoverTile.x];
        if (owner===P.RED) info+=' (RED)';
        else if (owner===P.BLUE) info+=' (BLUE)';
        else if ((t===T.CITY||t===T.FACTORY)&&owner===-1) info+=' (Neutral)';
        ctx.fillStyle='rgba(20,20,40,0.8)';
        ctx.fillRect(2,2,info.length*7+10,18);
        ctx.fillStyle='#ccc'; ctx.font='11px Courier New';
        ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.fillText(info,7,5);
      }
    }

    let hoverTile = null;
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const tx=Math.floor((mx-OX)/TILE), ty=Math.floor((my-OY)/TILE);
      if (tx>=0&&tx<COLS&&ty>=0&&ty<ROWS) hoverTile={x:tx,y:ty};
      else hoverTile=null;
    });

    function render() {
      ctx.fillStyle='#1a1a2e'; ctx.fillRect(0,0,W,H);
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) drawTile(x,y);
      drawHighlights();
      units.forEach(u=>{ if(u.hp>0) drawUnit(u); });
      drawDamageFlashes();
      drawProductionMenu();
      drawEndTurnButton();
      drawMiniStatus();
      drawHoverInfo();
      let info = lastAction;
      if (selectedUnit) {
        const u = selectedUnit;
        info = UNIT_NAMES[u.type]+' HP:'+u.hp+'/'+UNIT_HP[u.type]+' ATK:'+UNIT_ATK[u.type]+' MOV:'+UNIT_MOVE[u.type];
        if (UNIT_RANGE_MAX[u.type]>1) info+=' RNG:'+UNIT_RANGE_MIN[u.type]+'-'+UNIT_RANGE_MAX[u.type];
      }
      infoBar.innerHTML = info;
    }

    canvas.addEventListener('click', (e)=>{
      if (gameState==='menu') {
        gameState='playing'; overlay.style.display='none'; initGame(); return;
      }
      if (gameState==='gameover') {
        gameState='menu'; overlay.style.display='flex';
        overlayTitle.textContent='ADVANCE WARS ONLINE';
        overlayTitle.style.color='#e44';
        overlayText.textContent='Click to Deploy'; return;
      }
      if (gameState!=='playing'||currentPlayer!==P.RED) return;
      const tile = getTileFromMouse(e);
      if (!tile) return;
      const rect = canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      if (mx>=W-95&&mx<=W-10&&my>=H-30&&my<=H-6&&phase!=='production') { endTurn(); return; }
      if (phase==='production'&&productionFactory) {
        const menuX=W/2-130, menuY=H/2-85;
        const types=[U.INFANTRY,U.TANK,U.ARTILLERY,U.ANTIAIR];
        for (let i=0;i<types.length;i++) {
          const by=menuY+45+i*28;
          if (my>=by&&my<=by+24&&mx>=menuX+10&&mx<=menuX+250) {
            const type=types[i];
            const occupied=unitAt(productionFactory.x,productionFactory.y);
            if (gold[P.RED]>=UNIT_COST[type]&&!occupied) {
              gold[P.RED]-=UNIT_COST[type];
              const nu=createUnit(type,P.RED,productionFactory.x,productionFactory.y);
              nu.moved=true; nu.attacked=true; units.push(nu);
              lastAction='Produced '+UNIT_NAMES[type]+'!';
              productionFactory=null; phase='select'; updateUI();
            }
            return;
          }
        }
        return;
      }
      handlePlayerClick(tile.x, tile.y);
    });

    canvas.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      if (phase==='production') { phase='select'; productionFactory=null; return; }
      selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select';
    });

    document.addEventListener('keydown', (e)=>{
      if (e.key==='Escape') {
        if (phase==='production') { phase='select'; productionFactory=null; }
        else { selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select'; }
      }
      if ((e.key==='e'||e.key==='E')&&gameState==='playing'&&currentPlayer===P.RED&&phase!=='production') endTurn();
    });

    function getTileFromMouse(e) {
      const rect=canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      const tx=Math.floor((mx-OX)/TILE), ty=Math.floor((my-OY)/TILE);
      if (tx<0||tx>=COLS||ty<0||ty>=ROWS) return null;
      return {x:tx,y:ty};
    }

    function handlePlayerClick(tx, ty) {
      const clicked = unitAt(tx, ty);
      if (phase==='select') {
        if (map[ty][tx]===T.FACTORY&&tileOwner[ty][tx]===P.RED) {
          productionFactory={x:tx,y:ty}; phase='production';
          selectedUnit=null; movableTiles=[]; attackableTiles=[]; return;
        }
        if (clicked&&clicked.player===P.RED&&!clicked.moved) {
          selectedUnit=clicked; movableTiles=getReachableTiles(clicked); attackableTiles=[];
          phase='move'; return;
        }
        if (clicked&&clicked.player===P.RED&&clicked.moved&&!clicked.attacked) {
          const targets=getAttackTargets(clicked,clicked.x,clicked.y);
          if (targets.length>0) { selectedUnit=clicked; movableTiles=[]; attackableTiles=targets; phase='attack'; return; }
        }
        // Show info for enemy unit
        if (clicked && clicked.player===P.BLUE && fogMap[ty][tx]) {
          lastAction = 'Enemy '+UNIT_NAMES[clicked.type]+' HP:'+clicked.hp+'/'+UNIT_HP[clicked.type];
        }
      }
      if (phase==='move'&&selectedUnit) {
        const directTargets = getAttackTargets(selectedUnit, selectedUnit.x, selectedUnit.y);
        const directTarget = directTargets.find(t=>t.x===tx&&t.y===ty);
        const movable = movableTiles.find(t=>t.x===tx&&t.y===ty);
        if (movable) {
          selectedUnit.x=tx; selectedUnit.y=ty; selectedUnit.moved=true;
          const targets=getAttackTargets(selectedUnit,tx,ty);
          if (targets.length>0) {
            attackableTiles=targets; movableTiles=[]; phase='attack';
            lastAction='Select target to attack or right-click to skip';
          } else {
            selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select';
            lastAction='Unit moved.';
          }
          updateFog();
          return;
        }
        if (directTarget) {
          const result=doAttack(selectedUnit,directTarget.unit);
          lastAction='Attack! '+result.dmg+' damage'+(result.counterDmg?', '+result.counterDmg+' counter!':'');
          selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select';
          updateScore(); updateFog();
          const vic=checkVictory(); if (vic>=0) doVictory(vic);
          return;
        }
        // Click another own unit to switch selection
        if (clicked&&clicked.player===P.RED&&!clicked.moved&&clicked!==selectedUnit) {
          selectedUnit=clicked; movableTiles=getReachableTiles(clicked); attackableTiles=[];
          phase='move'; return;
        }
        selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select'; return;
      }
      if (phase==='attack'&&selectedUnit) {
        const target=attackableTiles.find(t=>t.x===tx&&t.y===ty);
        if (target) {
          const result=doAttack(selectedUnit,target.unit);
          lastAction='Attack! '+result.dmg+' damage'+(result.counterDmg?', '+result.counterDmg+' counter!':'');
          selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select';
          updateScore(); updateFog();
          const vic=checkVictory(); if (vic>=0) doVictory(vic);
          return;
        }
        selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select'; return;
      }
    }

    // ===== AI =====
    function aiTurn() {
      aiThinking = true;
      const aiUnits = units.filter(u=>u.player===P.BLUE&&u.hp>0);
      const priority = [U.ARTILLERY, U.ANTIAIR, U.TANK, U.INFANTRY];
      aiUnits.sort((a,b)=>priority.indexOf(a.type)-priority.indexOf(b.type));
      let moveIndex = 0;
      function doNextAiAction() {
        if (moveIndex >= aiUnits.length) { aiProduce(); aiThinking=false; endTurn(); return; }
        const unit = aiUnits[moveIndex]; moveIndex++;
        if (unit.hp<=0) { doNextAiAction(); return; }
        aiMoveUnit(unit); updateFog(); updateScore();
        const vic=checkVictory(); if (vic>=0) { doVictory(vic); return; }
        setTimeout(doNextAiAction, 150);
      }
      setTimeout(doNextAiAction, 300);
    }

    function aiMoveUnit(unit) {
      const reachable = getReachableTiles(unit);
      let bestScore=-Infinity, bestPos=null, bestTarget=null;
      for (const pos of reachable) {
        let posScore=0;
        const origX=unit.x, origY=unit.y;
        unit.x=pos.x; unit.y=pos.y;
        const targets=getAttackTargets(unit,pos.x,pos.y);
        let bestAtkScore=0, bestAtkTarget=null;
        for (const t of targets) {
          let as = calcDamage(unit,t.unit)*10;
          if (t.unit.hp<=calcDamage(unit,t.unit)) as+=50;
          as+=(UNIT_HP[t.unit.type]-t.unit.hp)*2;
          as+=UNIT_COST[t.unit.type]/100;
          if (as>bestAtkScore) { bestAtkScore=as; bestAtkTarget=t; }
        }
        posScore+=bestAtkScore;
        posScore+=TERRAIN_DEF[map[pos.y][pos.x]]*3;
        if (unit.type===U.INFANTRY) {
          const t=map[pos.y][pos.x];
          if ((t===T.CITY||t===T.FACTORY||t===T.HQ)&&tileOwner[pos.y][pos.x]!==P.BLUE) {
            posScore+=(t===T.HQ)?200:(t===T.FACTORY)?80:40;
          }
        }
        const distHQ = Math.abs(pos.x-0)+Math.abs(pos.y-5);
        posScore+=Math.max(0,20-distHQ)*0.5;
        let nearestCity=999;
        for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
          if ((map[y][x]===T.CITY||map[y][x]===T.FACTORY)&&tileOwner[y][x]!==P.BLUE) {
            nearestCity=Math.min(nearestCity,Math.abs(pos.x-x)+Math.abs(pos.y-y));
          }
        }
        posScore+=Math.max(0,15-nearestCity)*(unit.type===U.INFANTRY?2:0.5);
        let nearestEnemy=999;
        units.forEach(u=>{ if(u.player===P.RED&&u.hp>0) nearestEnemy=Math.min(nearestEnemy,Math.abs(pos.x-u.x)+Math.abs(pos.y-u.y)); });
        if (unit.type===U.TANK||unit.type===U.ANTIAIR) posScore+=Math.max(0,12-nearestEnemy)*1.5;
        if (unit.type===U.ARTILLERY) {
          if (nearestEnemy>=2&&nearestEnemy<=4) posScore+=10;
          if (nearestEnemy<=1) posScore-=15;
        }
        units.forEach(u=>{ if(u!==unit&&u.player===P.BLUE&&u.hp>0) { if(Math.abs(pos.x-u.x)+Math.abs(pos.y-u.y)<=1) posScore-=3; }});
        let threat=0;
        units.forEach(u=>{ if(u.player===P.RED&&u.hp>0) {
          const d=Math.abs(pos.x-u.x)+Math.abs(pos.y-u.y);
          if (d<=UNIT_RANGE_MAX[u.type]+UNIT_MOVE[u.type]) threat+=UNIT_ATK[u.type]*(u.hp/UNIT_HP[u.type]);
        }});
        posScore-=threat*(unit.hp<=3?0.5:0.1);
        unit.x=origX; unit.y=origY;
        if (posScore>bestScore) { bestScore=posScore; bestPos=pos; bestTarget=bestAtkTarget; }
      }
      if (bestPos) {
        unit.x=bestPos.x; unit.y=bestPos.y; unit.moved=true;
        if (bestTarget) doAttack(unit, bestTarget.unit);
      } else { unit.moved=true; }
    }

    function aiProduce() {
      const factories=[];
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
        if (map[y][x]===T.FACTORY&&tileOwner[y][x]===P.BLUE&&!unitAt(x,y)) factories.push({x,y});
      }
      const aiU=units.filter(u=>u.player===P.BLUE&&u.hp>0);
      const inf=aiU.filter(u=>u.type===U.INFANTRY).length;
      const tanks=aiU.filter(u=>u.type===U.TANK).length;
      const arty=aiU.filter(u=>u.type===U.ARTILLERY).length;
      const aa=aiU.filter(u=>u.type===U.ANTIAIR).length;
      let uncaptured=0;
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
        if ((map[y][x]===T.CITY||map[y][x]===T.FACTORY)&&tileOwner[y][x]!==P.BLUE) uncaptured++;
      }
      for (const fac of factories) {
        if (gold[P.BLUE]<1000) break;
        let type;
        if (inf<2||(uncaptured>3&&inf<4)) type=U.INFANTRY;
        else if (tanks<2&&gold[P.BLUE]>=3000) type=U.TANK;
        else if (arty<1&&gold[P.BLUE]>=2500) type=U.ARTILLERY;
        else if (aa<1&&gold[P.BLUE]>=2500) type=U.ANTIAIR;
        else if (gold[P.BLUE]>=3000&&Math.random()>0.4) type=U.TANK;
        else if (gold[P.BLUE]>=2500&&Math.random()>0.5) type=Math.random()>0.5?U.ARTILLERY:U.ANTIAIR;
        else type=U.INFANTRY;
        if (gold[P.BLUE]>=UNIT_COST[type]) {
          gold[P.BLUE]-=UNIT_COST[type];
          const nu=createUnit(type,P.BLUE,fac.x,fac.y);
          nu.moved=true; nu.attacked=true; units.push(nu);
        }
      }
    }

    function doVictory(winner) {
      gameState='gameover'; overlay.style.display='flex';
      if (winner===P.RED) {
        overlayTitle.textContent='VICTORY!'; overlayTitle.style.color='#e44';
        overlayText.textContent='Score: '+score+' | Click to play again';
      } else {
        overlayTitle.textContent='DEFEAT'; overlayTitle.style.color='#4af';
        overlayText.textContent='Score: '+score+' | Click to try again';
      }
    }

    function initGame() {
      generateMap(); spawnStartingUnits();
      currentPlayer=P.RED; turn=1; gold=[5000,5000]; score=0; unitsDestroyed=[0,0];
      selectedUnit=null; movableTiles=[]; attackableTiles=[]; phase='select';
      productionFactory=null; aiThinking=false; unitsMoved.clear(); damageFlashes=[];
      let tc=0;
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
        if (map[y][x]===T.CITY||map[y][x]===T.FACTORY) tc++;
      }
      totalCitiesEl.textContent=tc;
      updateFog(); updateScore(); startTurn(P.RED);
    }

    function gameLoop() { render(); requestAnimationFrame(gameLoop); }
    gameLoop();
  </script>
  <script src="../recorder.js?v=2"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bejeweled</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f8a; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 136, 170, 0.5); }
    h1 { color: #f8a; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 136, 170, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f8a; }
    canvas {
      border: 2px solid #f8a;
      box-shadow: 0 0 20px rgba(255, 136, 170, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f8a;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>BEJEWELED</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Time: <span id="timer">60</span>s</div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="480"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:480px;">
      <h2 id="overlayTitle">BEJEWELED</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const timerEl = document.getElementById('timer');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid constants
    const COLS = 8;
    const ROWS = 8;
    const CELL = W / COLS; // 60px
    const GEM_RADIUS = CELL * 0.38;

    // Gem types and their colors
    const GEM_COLORS = [
      { fill: '#ff4444', glow: '#ff4444', name: 'ruby' },      // Red
      { fill: '#44ff44', glow: '#44ff44', name: 'emerald' },    // Green
      { fill: '#4488ff', glow: '#4488ff', name: 'sapphire' },   // Blue
      { fill: '#ffff44', glow: '#ffff44', name: 'topaz' },      // Yellow
      { fill: '#ff44ff', glow: '#ff44ff', name: 'amethyst' },   // Purple
      { fill: '#44ffff', glow: '#44ffff', name: 'diamond' },    // Cyan
      { fill: '#ff8844', glow: '#ff8844', name: 'amber' }       // Orange
    ];
    const NUM_TYPES = GEM_COLORS.length;

    // Gem shapes (drawn procedurally)
    const GEM_SHAPES = ['diamond', 'circle', 'square', 'triangle', 'hexagon', 'star', 'pentagon'];

    // Game state
    let gameState = 'waiting';
    let score = 0;
    let best = 0;
    let grid = [];         // 2D array [row][col] of gem type indices
    let cursorR = 0, cursorC = 0;  // keyboard cursor
    let selectedR = -1, selectedC = -1;  // selected gem for swap
    let mouseSelectedR = -1, mouseSelectedC = -1; // mouse-selected gem
    let animating = false; // true during swap/fall/match animations
    let timeLeft = 60;
    let timerInterval = null;
    let chainMultiplier = 1;
    let comboText = '';
    let comboTimer = 0;
    let hintTimer = 0;
    let hintGems = null;

    // Animation state
    let swapAnim = null;   // { r1, c1, r2, c2, progress, reverting }
    let fallingGems = [];  // [{ col, fromRow, toRow, type, progress }]
    let matchedCells = []; // [{ r, c, progress }] for match explosion
    let sparkles = [];     // particle effects

    // ---- Grid logic ----

    function randomType() {
      return Math.floor(Math.random() * NUM_TYPES);
    }

    function createGrid() {
      grid = [];
      for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
          let type;
          do {
            type = randomType();
          } while (
            (c >= 2 && grid[r][c-1] === type && grid[r][c-2] === type) ||
            (r >= 2 && grid[r-1][c] === type && grid[r-2][c] === type)
          );
          grid[r][c] = type;
        }
      }
      // Ensure at least one valid move
      if (!hasValidMove()) {
        createGrid();
      }
    }

    function findMatches() {
      let matched = new Set();

      // Horizontal matches
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS - 2; c++) {
          if (grid[r][c] !== -1 && grid[r][c] === grid[r][c+1] && grid[r][c] === grid[r][c+2]) {
            let len = 3;
            while (c + len < COLS && grid[r][c+len] === grid[r][c]) len++;
            for (let i = 0; i < len; i++) matched.add(r * COLS + (c + i));
          }
        }
      }

      // Vertical matches
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS - 2; r++) {
          if (grid[r][c] !== -1 && grid[r][c] === grid[r+1][c] && grid[r][c] === grid[r+2][c]) {
            let len = 3;
            while (r + len < ROWS && grid[r+len][c] === grid[r][c]) len++;
            for (let i = 0; i < len; i++) matched.add((r + i) * COLS + c);
          }
        }
      }

      return matched;
    }

    function removeMatches(matched) {
      let count = matched.size;
      matched.forEach(pos => {
        let r = Math.floor(pos / COLS);
        let c = pos % COLS;
        // Add sparkle particles
        addSparkles(c * CELL + CELL / 2, r * CELL + CELL / 2, GEM_COLORS[grid[r][c]].fill);
        grid[r][c] = -1;
      });
      return count;
    }

    function dropGems() {
      let dropped = false;
      for (let c = 0; c < COLS; c++) {
        let writeRow = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (grid[r][c] !== -1) {
            if (writeRow !== r) {
              grid[writeRow][c] = grid[r][c];
              grid[r][c] = -1;
              dropped = true;
            }
            writeRow--;
          }
        }
        // Fill empty spaces at top
        for (let r = writeRow; r >= 0; r--) {
          grid[r][c] = randomType();
          dropped = true;
        }
      }
      return dropped;
    }

    function hasValidMove() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          // Try swap right
          if (c < COLS - 1) {
            swap(r, c, r, c + 1);
            if (findMatches().size > 0) { swap(r, c, r, c + 1); return true; }
            swap(r, c, r, c + 1);
          }
          // Try swap down
          if (r < ROWS - 1) {
            swap(r, c, r + 1, c);
            if (findMatches().size > 0) { swap(r, c, r + 1, c); return true; }
            swap(r, c, r + 1, c);
          }
        }
      }
      return false;
    }

    function findHintMove() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (c < COLS - 1) {
            swap(r, c, r, c + 1);
            if (findMatches().size > 0) { swap(r, c, r, c + 1); return [{r, c}, {r, c: c+1}]; }
            swap(r, c, r, c + 1);
          }
          if (r < ROWS - 1) {
            swap(r, c, r + 1, c);
            if (findMatches().size > 0) { swap(r, c, r + 1, c); return [{r, c}, {r: r+1, c}]; }
            swap(r, c, r + 1, c);
          }
        }
      }
      return null;
    }

    function swap(r1, c1, r2, c2) {
      let tmp = grid[r1][c1];
      grid[r1][c1] = grid[r2][c2];
      grid[r2][c2] = tmp;
    }

    function isAdjacent(r1, c1, r2, c2) {
      return (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
    }

    function reshuffleBoard() {
      // Flatten, shuffle, repopulate, ensure no instant matches and has valid moves
      let flat = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          flat.push(grid[r][c]);
        }
      }
      // Shuffle
      for (let i = flat.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [flat[i], flat[j]] = [flat[j], flat[i]];
      }
      // Place back
      let idx = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = flat[idx++];
        }
      }
      // If still has matches or no valid moves, just regenerate
      if (findMatches().size > 0 || !hasValidMove()) {
        createGrid();
      }
      comboText = 'RESHUFFLE!';
      comboTimer = 90;
    }

    // ---- Sparkle particles ----

    function addSparkles(x, y, color) {
      for (let i = 0; i < 6; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = 1.5 + Math.random() * 3;
        sparkles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 20 + Math.random() * 15,
          maxLife: 35,
          color,
          size: 2 + Math.random() * 3
        });
      }
    }

    function updateSparkles() {
      for (let i = sparkles.length - 1; i >= 0; i--) {
        let s = sparkles[i];
        s.x += s.vx;
        s.y += s.vy;
        s.vy += 0.1;
        s.life--;
        if (s.life <= 0) sparkles.splice(i, 1);
      }
    }

    // ---- Animation & game loop ----

    let pendingChainProcess = false;
    let chainDelay = 0;

    function processChains() {
      let matched = findMatches();
      if (matched.size > 0) {
        let count = removeMatches(matched);
        let points = count * 10 * chainMultiplier;
        score += points;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
        }
        if (chainMultiplier > 1) {
          comboText = `${chainMultiplier}x CHAIN! +${points}`;
        } else {
          comboText = `+${points}`;
        }
        comboTimer = 60;
        chainMultiplier++;
        // Delay before drop
        chainDelay = 12;
        pendingChainProcess = true;
      } else {
        // No more matches
        chainMultiplier = 1;
        animating = false;
        pendingChainProcess = false;
        // Check for valid moves
        if (!hasValidMove()) {
          reshuffleBoard();
        }
        hintTimer = 0;
        hintGems = null;
      }
    }

    function trySwap(r1, c1, r2, c2) {
      if (animating) return;
      if (!isAdjacent(r1, c1, r2, c2)) return;

      animating = true;
      chainMultiplier = 1;
      hintGems = null;
      hintTimer = 0;

      // Do the swap
      swap(r1, c1, r2, c2);

      // Check if this creates a match
      let matched = findMatches();
      if (matched.size === 0) {
        // Invalid swap - revert
        swap(r1, c1, r2, c2);
        animating = false;
        comboText = 'No match!';
        comboTimer = 40;
        return;
      }

      // Valid swap - process chain
      processChains();
    }

    function update() {
      if (gameState !== 'playing') return;

      // Update combo text timer
      if (comboTimer > 0) comboTimer--;

      // Update sparkles
      updateSparkles();

      // Handle chain processing delay
      if (pendingChainProcess) {
        chainDelay--;
        if (chainDelay <= 0) {
          dropGems();
          // Small delay then check for more matches
          pendingChainProcess = false;
          setTimeout(() => {
            if (gameState === 'playing') {
              processChains();
            }
          }, 150);
        }
        return;
      }

      // Hint system - show hint after 5 seconds of no input
      if (!animating) {
        hintTimer++;
        if (hintTimer > 300 && !hintGems) { // ~5 seconds at 60fps
          hintGems = findHintMove();
        }
      }
    }

    // ---- Drawing ----

    function drawGemShape(x, y, radius, shapeIdx, color) {
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;

      switch (GEM_SHAPES[shapeIdx]) {
        case 'diamond':
          ctx.beginPath();
          ctx.moveTo(x, y - radius);
          ctx.lineTo(x + radius * 0.7, y);
          ctx.lineTo(x, y + radius);
          ctx.lineTo(x - radius * 0.7, y);
          ctx.closePath();
          ctx.fill();
          // Inner highlight
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          ctx.moveTo(x, y - radius * 0.5);
          ctx.lineTo(x + radius * 0.35, y);
          ctx.lineTo(x, y + radius * 0.3);
          ctx.lineTo(x - radius * 0.35, y);
          ctx.closePath();
          ctx.fill();
          break;

        case 'circle':
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
          // Inner highlight
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          ctx.beginPath();
          ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.4, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'square':
          let s = radius * 0.8;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(Math.PI / 4);
          ctx.fillRect(-s, -s, s * 2, s * 2);
          // Inner highlight
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(-s * 0.5, -s * 0.5, s, s);
          ctx.restore();
          break;

        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(x, y - radius);
          ctx.lineTo(x + radius * 0.9, y + radius * 0.7);
          ctx.lineTo(x - radius * 0.9, y + radius * 0.7);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          ctx.moveTo(x, y - radius * 0.35);
          ctx.lineTo(x + radius * 0.35, y + radius * 0.3);
          ctx.lineTo(x - radius * 0.35, y + radius * 0.3);
          ctx.closePath();
          ctx.fill();
          break;

        case 'hexagon':
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            let angle = (Math.PI / 3) * i - Math.PI / 6;
            let hx = x + radius * Math.cos(angle);
            let hy = y + radius * Math.sin(angle);
            if (i === 0) ctx.moveTo(hx, hy);
            else ctx.lineTo(hx, hy);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            let angle = (Math.PI / 3) * i - Math.PI / 6;
            let hx = x + radius * 0.5 * Math.cos(angle);
            let hy = y + radius * 0.5 * Math.sin(angle);
            if (i === 0) ctx.moveTo(hx, hy);
            else ctx.lineTo(hx, hy);
          }
          ctx.closePath();
          ctx.fill();
          break;

        case 'star':
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            let outerAngle = (Math.PI * 2 / 5) * i - Math.PI / 2;
            let innerAngle = outerAngle + Math.PI / 5;
            ctx.lineTo(x + radius * Math.cos(outerAngle), y + radius * Math.sin(outerAngle));
            ctx.lineTo(x + radius * 0.45 * Math.cos(innerAngle), y + radius * 0.45 * Math.sin(innerAngle));
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          ctx.arc(x, y, radius * 0.25, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'pentagon':
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            let angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
            let px = x + radius * Math.cos(angle);
            let py = y + radius * Math.sin(angle);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            let angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
            let px = x + radius * 0.5 * Math.cos(angle);
            let py = y + radius * 0.5 * Math.sin(angle);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();
          break;
      }
    }

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      // Grid lines
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * CELL);
        ctx.lineTo(W, r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * CELL, 0);
        ctx.lineTo(c * CELL, H);
        ctx.stroke();
      }

      // Draw gems
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r][c] === -1) continue;

          let gemType = grid[r][c];
          let gem = GEM_COLORS[gemType];
          let cx = c * CELL + CELL / 2;
          let cy = r * CELL + CELL / 2;

          // Hint glow
          let isHint = hintGems && ((hintGems[0].r === r && hintGems[0].c === c) || (hintGems[1].r === r && hintGems[1].c === c));
          if (isHint) {
            let pulse = 0.3 + 0.3 * Math.sin(Date.now() / 300);
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 15 * pulse;
          }

          // Selection highlight
          let isSelected = (selectedR === r && selectedC === c) || (mouseSelectedR === r && mouseSelectedC === c);
          if (isSelected) {
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 18;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(c * CELL + 2, r * CELL + 2, CELL - 4, CELL - 4);
          }

          // Gem glow
          ctx.shadowColor = gem.glow;
          ctx.shadowBlur = isSelected ? 16 : 8;

          drawGemShape(cx, cy, GEM_RADIUS, gemType, gem.fill);

          ctx.shadowBlur = 0;
        }
      }

      // Cursor (keyboard)
      if (gameState === 'playing') {
        let pulse = 0.5 + 0.5 * Math.sin(Date.now() / 200);
        ctx.strokeStyle = `rgba(255, 136, 170, ${0.5 + 0.5 * pulse})`;
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f8a';
        ctx.shadowBlur = 8 * pulse;
        ctx.strokeRect(cursorC * CELL + 3, cursorR * CELL + 3, CELL - 6, CELL - 6);
        ctx.shadowBlur = 0;
      }

      // Sparkle particles
      sparkles.forEach(s => {
        let alpha = s.life / s.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = s.color;
        ctx.shadowColor = s.color;
        ctx.shadowBlur = 6;
        ctx.fillRect(s.x - s.size / 2, s.y - s.size / 2, s.size, s.size);
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      // Combo text
      if (comboTimer > 0 && comboText) {
        let alpha = Math.min(1, comboTimer / 20);
        ctx.globalAlpha = alpha;
        ctx.font = 'bold 28px Courier New';
        ctx.fillStyle = '#f8a';
        ctx.shadowColor = '#f8a';
        ctx.shadowBlur = 15;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(comboText, W / 2, H / 2);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
      }

      // Timer bar at bottom
      if (gameState === 'playing') {
        let barWidth = (timeLeft / 60) * W;
        let timerColor = timeLeft > 15 ? '#f8a' : (timeLeft > 5 ? '#f80' : '#f44');
        ctx.fillStyle = 'rgba(255,136,170,0.1)';
        ctx.fillRect(0, H - 6, W, 6);
        ctx.fillStyle = timerColor;
        ctx.shadowColor = timerColor;
        ctx.shadowBlur = 8;
        ctx.fillRect(0, H - 6, barWidth, 6);
        ctx.shadowBlur = 0;
      }
    }

    // ---- Game state management ----

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      timeLeft = 60;
      timerEl.textContent = '60';
      cursorR = 0;
      cursorC = 0;
      selectedR = -1;
      selectedC = -1;
      mouseSelectedR = -1;
      mouseSelectedC = -1;
      animating = false;
      pendingChainProcess = false;
      chainMultiplier = 1;
      comboText = '';
      comboTimer = 0;
      hintTimer = 0;
      hintGems = null;
      sparkles = [];
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      createGrid();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'BEJEWELED';
      overlayText.textContent = 'Press SPACE to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      timerInterval = setInterval(() => {
        if (gameState !== 'playing') return;
        timeLeft--;
        timerEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          gameOver();
        }
      }, 1000);
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} â€” Press any key to restart`;
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Input handling ----

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        if (e.key === ' ') {
          start();
        }
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing' && !animating) {
        switch (e.key) {
          case 'ArrowUp':
            cursorR = Math.max(0, cursorR - 1);
            hintTimer = 0; hintGems = null;
            break;
          case 'ArrowDown':
            cursorR = Math.min(ROWS - 1, cursorR + 1);
            hintTimer = 0; hintGems = null;
            break;
          case 'ArrowLeft':
            cursorC = Math.max(0, cursorC - 1);
            hintTimer = 0; hintGems = null;
            break;
          case 'ArrowRight':
            cursorC = Math.min(COLS - 1, cursorC + 1);
            hintTimer = 0; hintGems = null;
            break;
          case ' ':
            if (selectedR === -1) {
              // Select current gem
              selectedR = cursorR;
              selectedC = cursorC;
              mouseSelectedR = -1;
              mouseSelectedC = -1;
            } else {
              // Try to swap with selected
              if (cursorR === selectedR && cursorC === selectedC) {
                // Deselect
                selectedR = -1;
                selectedC = -1;
              } else {
                trySwap(selectedR, selectedC, cursorR, cursorC);
                selectedR = -1;
                selectedC = -1;
              }
            }
            hintTimer = 0; hintGems = null;
            break;
        }
      }
    });

    // Mouse / click support
    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing' || animating) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Scale for CSS vs canvas pixel differences
      const scaleX = W / rect.width;
      const scaleY = H / rect.height;
      const cx = mx * scaleX;
      const cy = my * scaleY;

      const clickC = Math.floor(cx / CELL);
      const clickR = Math.floor(cy / CELL);

      if (clickR < 0 || clickR >= ROWS || clickC < 0 || clickC >= COLS) return;

      hintTimer = 0;
      hintGems = null;

      if (mouseSelectedR === -1) {
        // No mouse selection yet - select this gem
        mouseSelectedR = clickR;
        mouseSelectedC = clickC;
        selectedR = -1;
        selectedC = -1;
      } else {
        if (mouseSelectedR === clickR && mouseSelectedC === clickC) {
          // Clicked same gem - deselect
          mouseSelectedR = -1;
          mouseSelectedC = -1;
        } else if (isAdjacent(mouseSelectedR, mouseSelectedC, clickR, clickC)) {
          // Adjacent - try swap
          trySwap(mouseSelectedR, mouseSelectedC, clickR, clickC);
          mouseSelectedR = -1;
          mouseSelectedC = -1;
        } else {
          // Not adjacent - select new gem instead
          mouseSelectedR = clickR;
          mouseSelectedC = clickC;
        }
      }
    });

    // Expose game data for ML
    window.gameData = {
      get grid() { return grid; },
      get cursorR() { return cursorR; },
      get cursorC() { return cursorC; },
      get selectedR() { return selectedR; },
      get selectedC() { return selectedC; },
      get timeLeft() { return timeLeft; },
      get chainMultiplier() { return chainMultiplier; }
    };

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=1"></script>
</body>
</html>

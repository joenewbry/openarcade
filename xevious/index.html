<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xevious</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #8e4; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(136,238,68,0.4); }
    h1 { color: #8e4; font-size: 2rem; text-shadow: 0 0 15px rgba(136,238,68,0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #8e4; }
    canvas {
      border: 2px solid #8e4;
      box-shadow: 0 0 20px rgba(136,238,68,0.4);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #8e4;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>XEVIOUS</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="480" height="640"></canvas>
    <div class="overlay" id="overlay" style="width:480px;height:640px;">
      <h2 id="overlayTitle">XEVIOUS</h2>
      <p id="overlayText">Press SPACE to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;
    let lives;
    let player;
    let bullets, bombs, enemyBullets;
    let airEnemies, groundTargets;
    let particles, explosions;
    let terrainFeatures;
    let scrollY;
    let tick;
    let keys = {};
    let boss, bossActive;
    let spawnTimer, bossSpawned;
    let difficultyLevel;
    let invincibleTimer;

    // Constants
    const PLAYER_W = 28, PLAYER_H = 32;
    const PLAYER_SPEED = 4;
    const BULLET_SPEED = 8;
    const BOMB_SPEED = 3;
    const RETICLE_DIST = 100;
    const SCROLL_SPEED = 1.5;

    // Terrain generation seed
    let terrainSeed = 0;
    function seededRandom() {
      terrainSeed = (terrainSeed * 9301 + 49297) % 233280;
      return terrainSeed / 233280;
    }

    function init() {
      score = 0;
      lives = 3;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'XEVIOUS';
      overlayText.textContent = 'Press SPACE to start';
      player = { x: W / 2 - PLAYER_W / 2, y: H - 80 };
      bullets = [];
      bombs = [];
      enemyBullets = [];
      airEnemies = [];
      groundTargets = [];
      particles = [];
      explosions = [];
      scrollY = 0;
      tick = 0;
      spawnTimer = 0;
      bossSpawned = false;
      bossActive = false;
      boss = null;
      difficultyLevel = 0;
      invincibleTimer = 0;
      terrainSeed = Math.floor(Math.random() * 100000);
      generateTerrain();
      draw();
    }

    function generateTerrain() {
      terrainFeatures = [];
      // Generate terrain chunks spanning a long distance
      for (let ty = -2000; ty < H + 500; ty += 60) {
        const saved = terrainSeed;
        terrainSeed = Math.abs(ty * 137 + 5381);
        const r = seededRandom();
        if (r < 0.15) {
          // River segment
          terrainFeatures.push({
            type: 'river',
            x: seededRandom() * (W - 120) + 20,
            y: ty,
            w: 60 + seededRandom() * 80,
            h: 50 + seededRandom() * 40
          });
        } else if (r < 0.35) {
          // Forest patch
          terrainFeatures.push({
            type: 'forest',
            x: seededRandom() * (W - 80) + 10,
            y: ty,
            w: 40 + seededRandom() * 60,
            h: 30 + seededRandom() * 40
          });
        } else if (r < 0.42) {
          // Runway / base plate
          terrainFeatures.push({
            type: 'base',
            x: seededRandom() * (W - 100) + 30,
            y: ty,
            w: 60 + seededRandom() * 50,
            h: 80 + seededRandom() * 40
          });
        } else if (r < 0.48) {
          // Road
          terrainFeatures.push({
            type: 'road',
            x: seededRandom() * (W - 60) + 20,
            y: ty,
            w: 20 + seededRandom() * 20,
            h: 100 + seededRandom() * 80
          });
        }
        terrainSeed = saved;
      }
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      invincibleTimer = 90;
      loop();
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} — Press SPACE to restart`;
    }

    // ── Spawning ──────────────────────────────────────────────

    function spawnAirEnemies() {
      const r = Math.random();
      if (r < 0.3) {
        // Torkan: flies straight down
        airEnemies.push({
          type: 'torkan',
          x: Math.random() * (W - 30) + 15,
          y: -30,
          vx: 0,
          vy: 2 + difficultyLevel * 0.3,
          hp: 1,
          points: 30,
          shootTimer: 60 + Math.floor(Math.random() * 60),
          color: '#4cf'
        });
      } else if (r < 0.55) {
        // Zoshi: sine wave pattern
        const startX = Math.random() * (W - 40) + 20;
        airEnemies.push({
          type: 'zoshi',
          x: startX,
          y: -25,
          baseX: startX,
          vx: 0,
          vy: 1.8 + difficultyLevel * 0.2,
          amplitude: 60 + Math.random() * 40,
          freq: 0.03 + Math.random() * 0.02,
          phase: Math.random() * Math.PI * 2,
          hp: 1,
          points: 50,
          shootTimer: 40 + Math.floor(Math.random() * 50),
          color: '#f84'
        });
      } else if (r < 0.75) {
        // Kapi: flies in from the side, curves across
        const fromLeft = Math.random() > 0.5;
        airEnemies.push({
          type: 'kapi',
          x: fromLeft ? -20 : W + 20,
          y: Math.random() * (H * 0.4) + 30,
          vx: (fromLeft ? 3 : -3) + (fromLeft ? 1 : -1) * difficultyLevel * 0.2,
          vy: 0.5 + Math.random() * 1,
          hp: 1,
          points: 40,
          shootTimer: 30 + Math.floor(Math.random() * 40),
          color: '#ff0'
        });
      } else if (r < 0.9) {
        // Zakato: formation of 3 flying in V
        const cx = Math.random() * (W - 80) + 40;
        for (let i = -1; i <= 1; i++) {
          airEnemies.push({
            type: 'zakato',
            x: cx + i * 30,
            y: -30 - Math.abs(i) * 20,
            vx: 0,
            vy: 2.2 + difficultyLevel * 0.2,
            hp: 1,
            points: 20,
            shootTimer: 50 + Math.floor(Math.random() * 40),
            color: '#f4f'
          });
        }
      } else {
        // Giddo Spario: fast diagonal
        airEnemies.push({
          type: 'giddo',
          x: Math.random() > 0.5 ? -15 : W + 15,
          y: -20,
          vx: (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2),
          vy: 3 + difficultyLevel * 0.3,
          hp: 2,
          points: 70,
          shootTimer: 25 + Math.floor(Math.random() * 30),
          color: '#f44'
        });
      }
    }

    function spawnGroundTarget() {
      const r = Math.random();
      const gx = Math.random() * (W - 60) + 30;
      const gy = -40;
      if (r < 0.35) {
        // Derota: stationary turret, shoots at player
        groundTargets.push({
          type: 'turret',
          x: gx, y: gy,
          hp: 1, points: 100,
          shootTimer: 80 + Math.floor(Math.random() * 60),
          angle: 0,
          color: '#a86'
        });
      } else if (r < 0.6) {
        // Logram: tank, moves horizontally
        groundTargets.push({
          type: 'tank',
          x: gx, y: gy,
          hp: 2, points: 150,
          vx: (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random() * 0.5),
          shootTimer: 70 + Math.floor(Math.random() * 50),
          color: '#886'
        });
      } else if (r < 0.8) {
        // Barra: ground base, takes multiple hits
        groundTargets.push({
          type: 'gbase',
          x: gx, y: gy,
          hp: 3, points: 300,
          shootTimer: 100,
          color: '#a66'
        });
      } else {
        // Sol Citadel: hidden target, revealed by bombing nearby
        groundTargets.push({
          type: 'hidden',
          x: gx, y: gy,
          hp: 1, points: 500,
          hidden: true,
          revealed: false,
          revealRadius: 60,
          color: '#ff8'
        });
      }
    }

    function spawnBoss() {
      bossActive = true;
      boss = {
        x: W / 2,
        y: -80,
        hp: 40,
        maxHp: 40,
        radius: 50,
        phase: 0,
        shootTimer: 0,
        spinAngle: 0,
        state: 'entering', // entering, fighting, dying
        points: 5000,
        flashTimer: 0,
        deathTimer: 0
      };
    }

    // ── Update ──────────────────────────────────────────────

    function update() {
      tick++;
      if (invincibleTimer > 0) invincibleTimer--;

      // Scroll terrain
      scrollY += SCROLL_SPEED;

      // Difficulty ramps over time
      difficultyLevel = Math.min(tick / 3600, 5);

      // Player movement
      if (keys['ArrowLeft'] || keys['a']) player.x -= PLAYER_SPEED;
      if (keys['ArrowRight'] || keys['d']) player.x += PLAYER_SPEED;
      if (keys['ArrowUp'] || keys['w']) player.y -= PLAYER_SPEED;
      if (keys['ArrowDown'] || keys['s']) player.y += PLAYER_SPEED;
      player.x = Math.max(0, Math.min(W - PLAYER_W, player.x));
      player.y = Math.max(40, Math.min(H - PLAYER_H - 10, player.y));

      // Auto-fire when holding space (continuous fire)
      if (keys[' '] && tick % 8 === 0) {
        fireBullet();
        fireBomb();
      }
      if (keys['z'] && tick % 8 === 0) {
        fireBullet();
      }
      if (keys['x'] && tick % 15 === 0) {
        fireBomb();
      }

      // Spawn enemies
      spawnTimer++;
      const spawnRate = Math.max(30, 80 - difficultyLevel * 8);
      if (spawnTimer >= spawnRate) {
        spawnTimer = 0;
        spawnAirEnemies();
        if (Math.random() < 0.4 + difficultyLevel * 0.05) {
          spawnGroundTarget();
        }
      }

      // Boss spawn at score thresholds
      if (!bossSpawned && score >= 3000) {
        bossSpawned = true;
        spawnBoss();
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= BULLET_SPEED;
        if (bullets[i].y < -10) {
          bullets.splice(i, 1);
        }
      }

      // Update bombs
      for (let i = bombs.length - 1; i >= 0; i--) {
        const b = bombs[i];
        b.y -= BOMB_SPEED;
        b.shadow += 0.3;
        b.scale = Math.max(0.3, b.scale - 0.008);
        // Check if bomb reached target
        if (b.y <= b.targetY) {
          // Bomb explodes
          spawnGroundExplosion(b.x, b.y);
          // Check ground targets
          hitGroundTargets(b.x, b.y);
          // Reveal hidden targets
          revealHidden(b.x, b.y);
          bombs.splice(i, 1);
        }
      }

      // Update air enemies
      for (let i = airEnemies.length - 1; i >= 0; i--) {
        const e = airEnemies[i];
        switch (e.type) {
          case 'torkan':
            e.x += e.vx;
            e.y += e.vy;
            break;
          case 'zoshi':
            e.y += e.vy;
            e.x = e.baseX + Math.sin(e.y * e.freq + e.phase) * e.amplitude;
            break;
          case 'kapi':
            e.x += e.vx;
            e.y += e.vy;
            break;
          case 'zakato':
            e.x += e.vx;
            e.y += e.vy;
            break;
          case 'giddo':
            e.x += e.vx;
            e.y += e.vy;
            break;
        }

        // Shooting
        e.shootTimer--;
        if (e.shootTimer <= 0 && e.y > 0 && e.y < H - 100) {
          e.shootTimer = 50 + Math.floor(Math.random() * 40) - difficultyLevel * 5;
          const dx = player.x + PLAYER_W / 2 - e.x;
          const dy = player.y + PLAYER_H / 2 - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const speed = 3 + difficultyLevel * 0.3;
          enemyBullets.push({
            x: e.x, y: e.y,
            vx: (dx / dist) * speed,
            vy: (dy / dist) * speed
          });
        }

        // Remove off-screen
        if (e.y > H + 40 || e.x < -60 || e.x > W + 60) {
          airEnemies.splice(i, 1);
          continue;
        }

        // Bullet collision with air enemies
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (Math.abs(b.x - e.x) < 16 && Math.abs(b.y - e.y) < 16) {
            e.hp--;
            bullets.splice(j, 1);
            if (e.hp <= 0) {
              addScore(e.points);
              spawnAirExplosion(e.x, e.y, e.color);
              airEnemies.splice(i, 1);
            }
            break;
          }
        }
      }

      // Update ground targets (scroll with terrain)
      for (let i = groundTargets.length - 1; i >= 0; i--) {
        const g = groundTargets[i];
        g.y += SCROLL_SPEED;

        // Tank movement
        if (g.type === 'tank' && g.vx) {
          g.x += g.vx;
          if (g.x < 20 || g.x > W - 50) g.vx *= -1;
        }

        // Turret and base shooting
        if (g.type !== 'hidden' || g.revealed) {
          if (g.shootTimer !== undefined) {
            g.shootTimer--;
            if (g.shootTimer <= 0 && g.y > 30 && g.y < H - 80) {
              g.shootTimer = 80 + Math.floor(Math.random() * 40) - difficultyLevel * 5;
              const dx = player.x + PLAYER_W / 2 - g.x;
              const dy = player.y + PLAYER_H / 2 - g.y;
              const dist = Math.sqrt(dx * dx + dy * dy) || 1;
              const speed = 2.5 + difficultyLevel * 0.2;
              enemyBullets.push({
                x: g.x, y: g.y,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                ground: true
              });
              g.angle = Math.atan2(dy, dx);
            }
          }
        }

        // Remove off-screen
        if (g.y > H + 60) {
          groundTargets.splice(i, 1);
        }
      }

      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < -10 || b.x > W + 10 || b.y < -10 || b.y > H + 10) {
          enemyBullets.splice(i, 1);
          continue;
        }
        // Player collision
        if (invincibleTimer <= 0 &&
            b.x > player.x + 4 && b.x < player.x + PLAYER_W - 4 &&
            b.y > player.y + 4 && b.y < player.y + PLAYER_H - 4) {
          enemyBullets.splice(i, 1);
          playerHit();
          break;
        }
      }

      // Air enemy collision with player
      if (invincibleTimer <= 0) {
        for (let i = airEnemies.length - 1; i >= 0; i--) {
          const e = airEnemies[i];
          if (Math.abs(e.x - (player.x + PLAYER_W / 2)) < 20 &&
              Math.abs(e.y - (player.y + PLAYER_H / 2)) < 20) {
            spawnAirExplosion(e.x, e.y, e.color);
            airEnemies.splice(i, 1);
            playerHit();
            break;
          }
        }
      }

      // Boss update
      if (bossActive && boss) {
        updateBoss();
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      }

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].life--;
        explosions[i].radius += 1.5;
        if (explosions[i].life <= 0) explosions.splice(i, 1);
      }
    }

    function updateBoss() {
      const b = boss;
      b.spinAngle += 0.02;
      b.phase += 0.01;

      if (b.state === 'entering') {
        b.y += 1;
        if (b.y >= 100) {
          b.state = 'fighting';
        }
      } else if (b.state === 'fighting') {
        // Orbit movement
        b.x = W / 2 + Math.sin(b.phase) * 150;
        b.y = 100 + Math.sin(b.phase * 0.7) * 50;

        // Shooting patterns
        b.shootTimer++;
        if (b.shootTimer % 30 === 0) {
          // Ring shot
          for (let a = 0; a < 8; a++) {
            const ang = (Math.PI * 2 / 8) * a + b.spinAngle;
            enemyBullets.push({
              x: b.x, y: b.y,
              vx: Math.cos(ang) * 2.5,
              vy: Math.sin(ang) * 2.5
            });
          }
        }
        if (b.shootTimer % 50 === 0) {
          // Aimed shot
          const dx = player.x + PLAYER_W / 2 - b.x;
          const dy = player.y + PLAYER_H / 2 - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          for (let s = -1; s <= 1; s++) {
            const angle = Math.atan2(dy, dx) + s * 0.2;
            enemyBullets.push({
              x: b.x, y: b.y,
              vx: Math.cos(angle) * 3.5,
              vy: Math.sin(angle) * 3.5
            });
          }
        }

        // Player bullets hit boss
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bul = bullets[j];
          const dx = bul.x - b.x;
          const dy = bul.y - b.y;
          if (dx * dx + dy * dy < b.radius * b.radius) {
            b.hp--;
            b.flashTimer = 4;
            bullets.splice(j, 1);
            spawnSpark(b.x + (Math.random() - 0.5) * 40, b.y + (Math.random() - 0.5) * 40);
            if (b.hp <= 0) {
              b.state = 'dying';
              b.deathTimer = 60;
            }
          }
        }

        // Bombs hit boss (check ground collision area)
        // Boss is also vulnerable to bombs at its center
        // (handled in hitGroundTargets implicitly, but add explicit here)

        // Player collision with boss
        if (invincibleTimer <= 0) {
          const dx = player.x + PLAYER_W / 2 - b.x;
          const dy = player.y + PLAYER_H / 2 - b.y;
          if (dx * dx + dy * dy < (b.radius + 12) * (b.radius + 12)) {
            playerHit();
          }
        }
      } else if (b.state === 'dying') {
        b.deathTimer--;
        if (b.deathTimer % 5 === 0) {
          spawnAirExplosion(
            b.x + (Math.random() - 0.5) * 80,
            b.y + (Math.random() - 0.5) * 80,
            Math.random() > 0.5 ? '#f84' : '#ff0'
          );
        }
        if (b.deathTimer <= 0) {
          addScore(b.points);
          bossActive = false;
          boss = null;
          // Big explosion
          for (let k = 0; k < 30; k++) {
            const ang = Math.random() * Math.PI * 2;
            const spd = 1 + Math.random() * 4;
            particles.push({
              x: b.x, y: b.y,
              vx: Math.cos(ang) * spd,
              vy: Math.sin(ang) * spd,
              life: 30 + Math.random() * 30,
              color: ['#f84', '#ff0', '#8e4', '#fff'][Math.floor(Math.random() * 4)]
            });
          }
        }
      }
    }

    function fireBullet() {
      if (bullets.length < 6) {
        bullets.push({ x: player.x + PLAYER_W / 2 - 2, y: player.y - 4 });
        bullets.push({ x: player.x + PLAYER_W / 2 + 2, y: player.y - 4 });
      }
    }

    function fireBomb() {
      if (bombs.length < 2) {
        bombs.push({
          x: player.x + PLAYER_W / 2,
          y: player.y,
          targetY: player.y - RETICLE_DIST,
          shadow: 0,
          scale: 1
        });
      }
    }

    function hitGroundTargets(bx, by) {
      for (let i = groundTargets.length - 1; i >= 0; i--) {
        const g = groundTargets[i];
        if (g.type === 'hidden' && !g.revealed) continue;
        const dx = bx - g.x;
        const dy = by - g.y;
        if (Math.abs(dx) < 25 && Math.abs(dy) < 25) {
          g.hp--;
          if (g.hp <= 0) {
            addScore(g.points);
            spawnGroundExplosion(g.x, g.y);
            groundTargets.splice(i, 1);
          }
        }
      }
      // Boss ground hit
      if (bossActive && boss && boss.state === 'fighting') {
        const dx = bx - boss.x;
        const dy = by - boss.y;
        if (dx * dx + dy * dy < boss.radius * boss.radius * 1.5) {
          boss.hp -= 3;
          boss.flashTimer = 6;
          spawnSpark(bx, by);
          if (boss.hp <= 0) {
            boss.state = 'dying';
            boss.deathTimer = 60;
          }
        }
      }
    }

    function revealHidden(bx, by) {
      for (const g of groundTargets) {
        if (g.type === 'hidden' && !g.revealed) {
          const dx = bx - g.x;
          const dy = by - g.y;
          if (Math.sqrt(dx * dx + dy * dy) < g.revealRadius) {
            g.revealed = true;
            g.hidden = false;
          }
        }
      }
    }

    function playerHit() {
      lives--;
      livesEl.textContent = lives;
      spawnAirExplosion(player.x + PLAYER_W / 2, player.y + PLAYER_H / 2, '#8e4');
      if (lives <= 0) {
        gameOver();
      } else {
        invincibleTimer = 120;
        player.x = W / 2 - PLAYER_W / 2;
        player.y = H - 80;
      }
    }

    function addScore(pts) {
      score += pts;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function spawnAirExplosion(x, y, color) {
      for (let i = 0; i < 10; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = 1 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: 15 + Math.random() * 10,
          color: color || '#fff'
        });
      }
    }

    function spawnGroundExplosion(x, y) {
      explosions.push({
        x, y,
        radius: 5,
        life: 15,
        maxLife: 15
      });
    }

    function spawnSpark(x, y) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 8 + Math.random() * 5,
          color: '#fff'
        });
      }
    }

    // ── Drawing ──────────────────────────────────────────────

    function draw() {
      // Background
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      drawTerrain();
      drawGroundTargets();
      drawExplosions();
      drawBombs();
      drawPlayer();
      drawBullets();
      drawAirEnemies();
      drawEnemyBullets();
      drawBoss();
      drawParticles();
      drawReticle();
    }

    function drawTerrain() {
      // Procedural scrolling terrain
      const baseOffset = scrollY % 200;

      // Draw terrain grid lines for visual scrolling
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      for (let y = baseOffset % 80; y < H; y += 80) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Draw terrain features (offset by scroll)
      terrainFeatures.forEach(f => {
        const sy = f.y + (scrollY % 2400);
        // Wrap around
        const fy = ((sy % (H + 2500)) + (H + 2500)) % (H + 2500) - 500;
        if (fy < -100 || fy > H + 100) return;

        switch (f.type) {
          case 'river':
            ctx.fillStyle = '#0a2a4e';
            ctx.shadowColor = '#0af';
            ctx.shadowBlur = 4;
            // Wavy river
            ctx.beginPath();
            ctx.moveTo(f.x, fy);
            for (let rx = 0; rx <= f.w; rx += 10) {
              ctx.lineTo(f.x + rx, fy + Math.sin((rx + scrollY * 2) * 0.05) * 4);
            }
            for (let rx = f.w; rx >= 0; rx -= 10) {
              ctx.lineTo(f.x + rx, fy + f.h + Math.sin((rx + scrollY * 2) * 0.05) * 4);
            }
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            break;
          case 'forest':
            ctx.fillStyle = '#0a3020';
            ctx.fillRect(f.x, fy, f.w, f.h);
            // Tree dots
            ctx.fillStyle = '#1a5030';
            for (let tx = f.x + 6; tx < f.x + f.w - 6; tx += 10) {
              for (let tyy = fy + 6; tyy < fy + f.h - 6; tyy += 10) {
                ctx.beginPath();
                ctx.arc(tx + Math.sin(tx * 0.3) * 2, tyy, 4, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            break;
          case 'base':
            ctx.fillStyle = '#1a2030';
            ctx.fillRect(f.x, fy, f.w, f.h);
            ctx.strokeStyle = '#2a3040';
            ctx.lineWidth = 1;
            ctx.strokeRect(f.x + 4, fy + 4, f.w - 8, f.h - 8);
            // Runway stripe
            ctx.fillStyle = '#2a3040';
            ctx.fillRect(f.x + f.w / 2 - 3, fy + 5, 6, f.h - 10);
            break;
          case 'road':
            ctx.fillStyle = '#1a2030';
            ctx.fillRect(f.x, fy, f.w, f.h);
            // Center line dashes
            ctx.fillStyle = '#2a3040';
            for (let ry = fy; ry < fy + f.h; ry += 12) {
              ctx.fillRect(f.x + f.w / 2 - 1, ry, 2, 6);
            }
            break;
        }
      });
    }

    function drawGroundTargets() {
      groundTargets.forEach(g => {
        if (g.type === 'hidden' && !g.revealed) {
          // Draw subtle shimmer hint
          if (tick % 60 < 10) {
            ctx.fillStyle = 'rgba(255, 255, 136, 0.08)';
            ctx.beginPath();
            ctx.arc(g.x, g.y, 12, 0, Math.PI * 2);
            ctx.fill();
          }
          return;
        }

        ctx.shadowColor = g.color;
        ctx.shadowBlur = 6;

        switch (g.type) {
          case 'turret':
            // Base circle
            ctx.fillStyle = '#3a3020';
            ctx.beginPath();
            ctx.arc(g.x, g.y, 14, 0, Math.PI * 2);
            ctx.fill();
            // Gun barrel
            ctx.strokeStyle = g.color;
            ctx.lineWidth = 3;
            const angle = g.angle || 0;
            ctx.beginPath();
            ctx.moveTo(g.x, g.y);
            ctx.lineTo(g.x + Math.cos(angle) * 16, g.y + Math.sin(angle) * 16);
            ctx.stroke();
            // Center
            ctx.fillStyle = g.color;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'tank':
            // Tank body
            ctx.fillStyle = '#3a3820';
            ctx.fillRect(g.x - 14, g.y - 8, 28, 16);
            // Turret
            ctx.fillStyle = g.color;
            ctx.fillRect(g.x - 6, g.y - 5, 12, 10);
            // Barrel
            ctx.fillRect(g.x + 6, g.y - 2, 12, 4);
            // Treads
            ctx.fillStyle = '#2a2818';
            ctx.fillRect(g.x - 14, g.y - 10, 28, 3);
            ctx.fillRect(g.x - 14, g.y + 7, 28, 3);
            break;
          case 'gbase':
            // Large base structure
            ctx.fillStyle = '#2a2030';
            ctx.fillRect(g.x - 20, g.y - 15, 40, 30);
            ctx.strokeStyle = g.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(g.x - 20, g.y - 15, 40, 30);
            // Health indicator
            ctx.fillStyle = g.color;
            for (let h = 0; h < g.hp; h++) {
              ctx.fillRect(g.x - 12 + h * 10, g.y - 2, 6, 4);
            }
            break;
          case 'hidden':
            // Revealed special target - pulsing
            const pulse = Math.sin(tick * 0.1) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 136, ${pulse})`;
            ctx.beginPath();
            ctx.arc(g.x, g.y, 10 + Math.sin(tick * 0.08) * 3, 0, Math.PI * 2);
            ctx.fill();
            // Inner
            ctx.fillStyle = '#ff8';
            ctx.beginPath();
            ctx.arc(g.x, g.y, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
        }
        ctx.shadowBlur = 0;
      });
    }

    function drawExplosions() {
      explosions.forEach(e => {
        const alpha = e.life / e.maxLife;
        ctx.strokeStyle = `rgba(255, 160, 40, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#f84';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = `rgba(255, 200, 80, ${alpha * 0.3})`;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    function drawBombs() {
      bombs.forEach(b => {
        // Shadow on ground
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(b.x, b.targetY, 6 + b.shadow, 3 + b.shadow * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Bomb
        ctx.fillStyle = '#8e4';
        ctx.shadowColor = '#8e4';
        ctx.shadowBlur = 6;
        const sz = 4 * b.scale;
        ctx.beginPath();
        ctx.arc(b.x, b.y, sz, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    function drawReticle() {
      if (gameState !== 'playing') return;
      // Targeting reticle ahead of player
      const rx = player.x + PLAYER_W / 2;
      const ry = player.y - RETICLE_DIST;
      const pulse = Math.sin(tick * 0.12) * 2;

      ctx.strokeStyle = 'rgba(136, 238, 68, 0.6)';
      ctx.lineWidth = 1;
      // Outer circle
      ctx.beginPath();
      ctx.arc(rx, ry, 12 + pulse, 0, Math.PI * 2);
      ctx.stroke();
      // Cross hairs
      ctx.beginPath();
      ctx.moveTo(rx - 18, ry);
      ctx.lineTo(rx - 8, ry);
      ctx.moveTo(rx + 8, ry);
      ctx.lineTo(rx + 18, ry);
      ctx.moveTo(rx, ry - 18);
      ctx.lineTo(rx, ry - 8);
      ctx.moveTo(rx, ry + 8);
      ctx.lineTo(rx, ry + 18);
      ctx.stroke();
      // Center dot
      ctx.fillStyle = 'rgba(136, 238, 68, 0.8)';
      ctx.beginPath();
      ctx.arc(rx, ry, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawPlayer() {
      if (gameState !== 'playing' && gameState !== 'waiting') return;
      // Blink when invincible
      if (invincibleTimer > 0 && Math.floor(tick / 4) % 2 === 0) return;

      const px = player.x, py = player.y;

      // Engine glow
      ctx.fillStyle = 'rgba(136, 238, 68, 0.3)';
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2 - 4, py + PLAYER_H);
      ctx.lineTo(px + PLAYER_W / 2, py + PLAYER_H + 8 + Math.random() * 4);
      ctx.lineTo(px + PLAYER_W / 2 + 4, py + PLAYER_H);
      ctx.fill();

      // Ship body
      ctx.fillStyle = '#8e4';
      ctx.shadowColor = '#8e4';
      ctx.shadowBlur = 10;

      // Main fuselage
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2, py);
      ctx.lineTo(px + PLAYER_W / 2 + 5, py + 8);
      ctx.lineTo(px + PLAYER_W / 2 + 4, py + PLAYER_H - 4);
      ctx.lineTo(px + PLAYER_W / 2 - 4, py + PLAYER_H - 4);
      ctx.lineTo(px + PLAYER_W / 2 - 5, py + 8);
      ctx.closePath();
      ctx.fill();

      // Wings
      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2 - 4, py + 12);
      ctx.lineTo(px, py + PLAYER_H - 2);
      ctx.lineTo(px + 4, py + PLAYER_H);
      ctx.lineTo(px + PLAYER_W / 2 - 3, py + PLAYER_H - 6);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(px + PLAYER_W / 2 + 4, py + 12);
      ctx.lineTo(px + PLAYER_W, py + PLAYER_H - 2);
      ctx.lineTo(px + PLAYER_W - 4, py + PLAYER_H);
      ctx.lineTo(px + PLAYER_W / 2 + 3, py + PLAYER_H - 6);
      ctx.closePath();
      ctx.fill();

      // Cockpit
      ctx.fillStyle = '#cfe';
      ctx.beginPath();
      ctx.arc(px + PLAYER_W / 2, py + 10, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawBullets() {
      ctx.fillStyle = '#8e4';
      ctx.shadowColor = '#8e4';
      ctx.shadowBlur = 8;
      bullets.forEach(b => {
        ctx.fillRect(b.x - 1, b.y, 2, 8);
      });
      ctx.shadowBlur = 0;
    }

    function drawAirEnemies() {
      airEnemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.shadowColor = e.color;
        ctx.shadowBlur = 8;

        switch (e.type) {
          case 'torkan':
            // Simple diamond
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - 12);
            ctx.lineTo(e.x + 12, e.y);
            ctx.lineTo(e.x, e.y + 12);
            ctx.lineTo(e.x - 12, e.y);
            ctx.closePath();
            ctx.fill();
            // Center eye
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'zoshi':
            // Oval swooper
            ctx.beginPath();
            ctx.ellipse(e.x, e.y, 14, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tail
            ctx.fillRect(e.x - 2, e.y + 6, 4, 8);
            // Eyes
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(e.x - 6, e.y - 3, 4, 3);
            ctx.fillRect(e.x + 2, e.y - 3, 4, 3);
            break;
          case 'kapi':
            // Arrow shape flying sideways
            ctx.beginPath();
            ctx.moveTo(e.x + (e.vx > 0 ? 14 : -14), e.y);
            ctx.lineTo(e.x + (e.vx > 0 ? -10 : 10), e.y - 10);
            ctx.lineTo(e.x + (e.vx > 0 ? -6 : 6), e.y);
            ctx.lineTo(e.x + (e.vx > 0 ? -10 : 10), e.y + 10);
            ctx.closePath();
            ctx.fill();
            break;
          case 'zakato':
            // Small circle
            ctx.beginPath();
            ctx.arc(e.x, e.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'giddo':
            // Large hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const a = (Math.PI * 2 / 6) * i - Math.PI / 2;
              const r = 14;
              if (i === 0) ctx.moveTo(e.x + Math.cos(a) * r, e.y + Math.sin(a) * r);
              else ctx.lineTo(e.x + Math.cos(a) * r, e.y + Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
            // Inner
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const a = (Math.PI * 2 / 6) * i;
              const r = 6;
              if (i === 0) ctx.moveTo(e.x + Math.cos(a) * r, e.y + Math.sin(a) * r);
              else ctx.lineTo(e.x + Math.cos(a) * r, e.y + Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
            break;
        }
        ctx.shadowBlur = 0;
      });
    }

    function drawEnemyBullets() {
      ctx.fillStyle = '#f44';
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 6;
      enemyBullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;
    }

    function drawBoss() {
      if (!bossActive || !boss) return;
      const b = boss;

      // Flash on hit
      if (b.flashTimer > 0) {
        b.flashTimer--;
        ctx.fillStyle = '#fff';
      } else {
        ctx.fillStyle = '#8a6';
      }

      ctx.shadowColor = '#8e4';
      ctx.shadowBlur = 20;

      // Andor Genesis: large spinning fortress
      ctx.save();
      ctx.translate(b.x, b.y);

      // Outer spinning ring
      ctx.rotate(b.spinAngle);
      ctx.strokeStyle = b.flashTimer > 0 ? '#fff' : '#8e4';
      ctx.lineWidth = 3;
      // Octagonal shape
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const a = (Math.PI * 2 / 8) * i;
        const r = b.radius;
        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.fillStyle = b.flashTimer > 0 ? 'rgba(255,255,255,0.3)' : 'rgba(136,238,68,0.15)';
      ctx.fill();

      // Inner structure
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const a = (Math.PI * 2 / 8) * i + Math.PI / 8;
        const r = b.radius * 0.6;
        if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
      }
      ctx.closePath();
      ctx.strokeStyle = b.flashTimer > 0 ? '#fff' : '#ad8';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = b.flashTimer > 0 ? 'rgba(255,255,255,0.4)' : 'rgba(100,180,60,0.25)';
      ctx.fill();

      // Turret nodes
      for (let i = 0; i < 4; i++) {
        const a = (Math.PI * 2 / 4) * i;
        const nx = Math.cos(a) * b.radius * 0.75;
        const ny = Math.sin(a) * b.radius * 0.75;
        ctx.fillStyle = b.flashTimer > 0 ? '#fff' : '#f44';
        ctx.beginPath();
        ctx.arc(nx, ny, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Core
      const corePulse = Math.sin(tick * 0.08) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(255, 136, 68, ${corePulse})`;
      ctx.shadowColor = '#f84';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Health bar above boss
      ctx.shadowBlur = 0;
      const hbW = 80;
      const hbX = b.x - hbW / 2;
      const hbY = b.y - b.radius - 15;
      ctx.fillStyle = '#400';
      ctx.fillRect(hbX, hbY, hbW, 5);
      ctx.fillStyle = '#8e4';
      ctx.fillRect(hbX, hbY, hbW * (b.hp / b.maxHp), 5);
      ctx.shadowBlur = 0;
    }

    function drawParticles() {
      particles.forEach(p => {
        const alpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.min(1, alpha);
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      });
      ctx.globalAlpha = 1;
    }

    // ── Input ──────────────────────────────────────────────

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') {
        if (e.key === ' ') { start(); return; }
      }

      if (gameState === 'over') {
        if (e.key === ' ') { init(); return; }
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Duck Hunt</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 500px;
    }
    .back { color: #f66; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 102, 102, 0.4); }
    h1 { color: #f66; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 102, 102, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 500px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f66; }
    canvas {
      border: 2px solid #f66;
      box-shadow: 0 0 20px rgba(255, 102, 102, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f66;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>DUCK HUNT</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="500" height="500"></canvas>
    <div class="overlay" id="overlay" style="width:500px;height:500px;">
      <h2 id="overlayTitle">DUCK HUNT</h2>
      <p id="overlayText">Click to start</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    let score, best = 0, gameState;

    // Game constants
    const GRASS_HEIGHT = 60;
    const PLAY_AREA_TOP = 40;
    const PLAY_AREA_BOTTOM = H - GRASS_HEIGHT;
    const MAX_MISSES = 3;
    const SHOTS_PER_DUCK = 3;
    const HIT_RADIUS = 30;
    const BANG_DURATION = 15;
    const FALL_SPEED = 4;
    const DUCK_FALL_ROTATE_SPEED = 0.15;

    // Game state variables
    let round, misses, shotsLeft, totalDucksThisRound;
    let ducks, bangEffects, mouseX, mouseY;
    let roundStartTimer, roundTransition;
    let combo, comboTimer;
    let grassTufts;

    // Duck patterns
    const PATTERNS = ['diagonal', 'wavy', 'swoop', 'zigzag'];

    function generateGrass() {
      grassTufts = [];
      for (let i = 0; i < 60; i++) {
        grassTufts.push({
          x: Math.random() * W,
          h: 10 + Math.random() * 25,
          w: 2 + Math.random() * 3,
          shade: Math.random() * 0.3
        });
      }
    }

    function createDuck(roundNum) {
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const pattern = PATTERNS[Math.floor(Math.random() * PATTERNS.length)];
      const baseSpeed = 1.5 + roundNum * 0.3;
      const speed = baseSpeed * (0.8 + Math.random() * 0.4);
      const size = Math.max(16, 28 - roundNum * 0.8);

      let x, y, vx, vy;
      if (side === 'left') {
        x = -20;
        vx = speed;
      } else {
        x = W + 20;
        vx = -speed;
      }
      y = PLAY_AREA_TOP + Math.random() * (PLAY_AREA_BOTTOM - PLAY_AREA_TOP - 60);
      vy = (Math.random() - 0.5) * speed * 0.5;

      return {
        x, y, vx, vy, size,
        pattern,
        alive: true,
        falling: false,
        fallRotation: 0,
        fallVy: 0,
        wingPhase: Math.random() * Math.PI * 2,
        wingSpeed: 0.15 + Math.random() * 0.1,
        escaped: false,
        time: 0,
        startY: y,
        amplitude: 20 + Math.random() * 30,
        frequency: 0.02 + Math.random() * 0.02,
        swoopPhase: Math.random() < 0.5 ? 0 : Math.PI
      };
    }

    function spawnRound() {
      const duckCount = Math.min(3, 1 + Math.floor((round - 1) / 3));
      totalDucksThisRound = duckCount;
      shotsLeft = duckCount * SHOTS_PER_DUCK;
      ducks = [];
      for (let i = 0; i < duckCount; i++) {
        const duck = createDuck(round);
        // Stagger spawn positions slightly
        duck.x += duck.vx > 0 ? -i * 40 : i * 40;
        ducks.push(duck);
      }
      roundStartTimer = 60; // show round text briefly
    }

    function init() {
      score = 0;
      scoreEl.textContent = '0';
      round = 0;
      misses = 0;
      combo = 0;
      comboTimer = 0;
      ducks = [];
      bangEffects = [];
      mouseX = W / 2;
      mouseY = H / 2;
      roundStartTimer = 0;
      roundTransition = 0;
      generateGrass();
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'DUCK HUNT';
      overlayText.textContent = 'Click to start';
      draw();
    }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      canvas.style.cursor = 'none';
      round = 1;
      spawnRound();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      gameState = 'over';
      canvas.style.cursor = 'default';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} | Round: ${round} â€” Click to restart`;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
      }
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      // Round start countdown
      if (roundStartTimer > 0) {
        roundStartTimer--;
      }

      // Round transition (brief pause between rounds)
      if (roundTransition > 0) {
        roundTransition--;
        if (roundTransition === 0) {
          round++;
          spawnRound();
        }
        return;
      }

      // Combo timer decay
      if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer === 0) combo = 0;
      }

      // Update bang effects
      for (let i = bangEffects.length - 1; i >= 0; i--) {
        bangEffects[i].life--;
        if (bangEffects[i].life <= 0) {
          bangEffects.splice(i, 1);
        }
      }

      // Update ducks
      let allDone = true;
      for (let i = 0; i < ducks.length; i++) {
        const d = ducks[i];

        if (d.falling) {
          // Falling animation
          d.fallVy += 0.2;
          d.y += d.fallVy;
          d.fallRotation += DUCK_FALL_ROTATE_SPEED * (d.vx > 0 ? 1 : -1);
          if (d.y > H + 40) {
            d.escaped = true; // mark as done (but it was hit, not escaped)
          }
          if (!d.escaped) allDone = false;
          continue;
        }

        if (d.escaped) continue;

        d.time++;
        d.wingPhase += d.wingSpeed;

        // Movement based on pattern
        switch (d.pattern) {
          case 'diagonal':
            d.x += d.vx;
            d.y += d.vy;
            // Bounce off top/bottom
            if (d.y < PLAY_AREA_TOP || d.y > PLAY_AREA_BOTTOM - 30) {
              d.vy = -d.vy;
            }
            break;

          case 'wavy':
            d.x += d.vx;
            d.y = d.startY + Math.sin(d.time * d.frequency) * d.amplitude;
            break;

          case 'swoop':
            d.x += d.vx;
            d.y = d.startY + Math.sin(d.time * 0.03 + d.swoopPhase) * d.amplitude * 1.5;
            // Clamp to play area
            d.y = Math.max(PLAY_AREA_TOP, Math.min(PLAY_AREA_BOTTOM - 30, d.y));
            break;

          case 'zigzag':
            d.x += d.vx;
            // Triangular wave
            const period = 80;
            const phase = d.time % period;
            if (phase < period / 2) {
              d.y += Math.abs(d.vx) * 0.6;
            } else {
              d.y -= Math.abs(d.vx) * 0.6;
            }
            // Clamp
            d.y = Math.max(PLAY_AREA_TOP, Math.min(PLAY_AREA_BOTTOM - 30, d.y));
            break;
        }

        // Check if duck escaped off screen
        if (d.x < -50 || d.x > W + 50) {
          d.escaped = true;
          d.alive = false;
        }

        if (!d.escaped && !d.falling) allDone = false;
      }

      // Check if round is over
      if (allDone && roundTransition === 0) {
        // Count misses for this round (alive ducks that escaped)
        let roundMisses = 0;
        for (const d of ducks) {
          if (d.alive && d.escaped) {
            roundMisses++;
          }
        }
        misses += roundMisses;

        if (misses >= MAX_MISSES) {
          gameOver();
          return;
        }

        // Also game over if out of shots and ducks still alive
        // (already handled by escape detection above)

        // Start next round after brief pause
        roundTransition = 45;
      }

      // Update gameData for ML
      window.gameData = {
        mouseX, mouseY,
        round, misses, shotsLeft, combo,
        ducks: ducks.filter(d => d.alive && !d.escaped && !d.falling).map(d => ({ x: d.x, y: d.y, size: d.size }))
      };
    }

    function drawSkyGradient() {
      const grad = ctx.createLinearGradient(0, 0, 0, PLAY_AREA_BOTTOM);
      grad.addColorStop(0, '#0a0a1e');
      grad.addColorStop(0.4, '#1a1a3e');
      grad.addColorStop(0.7, '#1e2a4e');
      grad.addColorStop(1, '#2a3a5e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, PLAY_AREA_BOTTOM);
    }

    function drawStars() {
      // A few subtle stars in the sky
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      const starPositions = [
        [45, 30], [120, 60], [200, 20], [280, 55], [350, 35],
        [420, 50], [470, 25], [80, 90], [310, 80], [450, 85]
      ];
      for (const [sx, sy] of starPositions) {
        ctx.fillRect(sx, sy, 2, 2);
      }
    }

    function drawGrass() {
      // Grass base
      const grassGrad = ctx.createLinearGradient(0, PLAY_AREA_BOTTOM, 0, H);
      grassGrad.addColorStop(0, '#1a4a1a');
      grassGrad.addColorStop(0.3, '#164016');
      grassGrad.addColorStop(1, '#0e300e');
      ctx.fillStyle = grassGrad;
      ctx.fillRect(0, PLAY_AREA_BOTTOM, W, GRASS_HEIGHT);

      // Grass tufts on top edge
      for (const tuft of grassTufts) {
        const green = Math.floor(100 + tuft.shade * 80);
        ctx.fillStyle = `rgb(${Math.floor(green * 0.3)}, ${green}, ${Math.floor(green * 0.2)})`;
        ctx.fillRect(tuft.x, PLAY_AREA_BOTTOM - tuft.h, tuft.w, tuft.h);
      }

      // Bush shapes
      ctx.fillStyle = '#1a5a1a';
      drawBush(60, PLAY_AREA_BOTTOM, 40, 20);
      drawBush(180, PLAY_AREA_BOTTOM, 50, 25);
      drawBush(320, PLAY_AREA_BOTTOM, 35, 18);
      drawBush(440, PLAY_AREA_BOTTOM, 45, 22);
    }

    function drawBush(x, y, w, h) {
      ctx.beginPath();
      ctx.ellipse(x, y, w, h, 0, Math.PI, 0);
      ctx.fill();
    }

    function drawDuck(d) {
      ctx.save();
      ctx.translate(d.x, d.y);

      if (d.falling) {
        ctx.rotate(d.fallRotation);
      }

      const s = d.size;
      const facingRight = d.vx > 0;

      // Wing flap
      const wingAngle = Math.sin(d.wingPhase) * 0.6;

      // Body
      ctx.fillStyle = '#c84';
      ctx.shadowColor = '#f66';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.ellipse(0, 0, s, s * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Head
      const headX = facingRight ? s * 0.7 : -s * 0.7;
      ctx.fillStyle = '#2a6a2a';
      ctx.beginPath();
      ctx.arc(headX, -s * 0.3, s * 0.4, 0, Math.PI * 2);
      ctx.fill();

      // Eye
      const eyeX = facingRight ? headX + s * 0.15 : headX - s * 0.15;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(eyeX, -s * 0.35, s * 0.1, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(eyeX, -s * 0.35, s * 0.05, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      const beakX = facingRight ? headX + s * 0.35 : headX - s * 0.35;
      ctx.fillStyle = '#f80';
      ctx.beginPath();
      if (facingRight) {
        ctx.moveTo(headX + s * 0.2, -s * 0.25);
        ctx.lineTo(beakX + s * 0.15, -s * 0.2);
        ctx.lineTo(headX + s * 0.2, -s * 0.15);
      } else {
        ctx.moveTo(headX - s * 0.2, -s * 0.25);
        ctx.lineTo(beakX - s * 0.15, -s * 0.2);
        ctx.lineTo(headX - s * 0.2, -s * 0.15);
      }
      ctx.closePath();
      ctx.fill();

      // Wings
      ctx.save();
      const wingX = facingRight ? -s * 0.2 : s * 0.2;
      ctx.translate(wingX, -s * 0.2);
      ctx.rotate(wingAngle);
      ctx.fillStyle = '#a63';
      ctx.beginPath();
      ctx.ellipse(0, -s * 0.3, s * 0.5, s * 0.25, facingRight ? -0.3 : 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Tail
      const tailX = facingRight ? -s * 0.8 : s * 0.8;
      ctx.fillStyle = '#a63';
      ctx.beginPath();
      ctx.moveTo(tailX, 0);
      ctx.lineTo(tailX + (facingRight ? -s * 0.3 : s * 0.3), -s * 0.2);
      ctx.lineTo(tailX + (facingRight ? -s * 0.2 : s * 0.2), s * 0.1);
      ctx.closePath();
      ctx.fill();

      // X eyes if dead and falling
      if (d.falling) {
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 2;
        const xSize = s * 0.12;
        ctx.beginPath();
        ctx.moveTo(eyeX - xSize, -s * 0.35 - xSize);
        ctx.lineTo(eyeX + xSize, -s * 0.35 + xSize);
        ctx.moveTo(eyeX + xSize, -s * 0.35 - xSize);
        ctx.lineTo(eyeX - xSize, -s * 0.35 + xSize);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawCrosshair() {
      const size = 15;
      ctx.strokeStyle = '#f66';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#f66';
      ctx.shadowBlur = 6;

      // Outer circle
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, size, 0, Math.PI * 2);
      ctx.stroke();

      // Cross lines
      ctx.beginPath();
      ctx.moveTo(mouseX - size - 5, mouseY);
      ctx.lineTo(mouseX - size * 0.4, mouseY);
      ctx.moveTo(mouseX + size * 0.4, mouseY);
      ctx.lineTo(mouseX + size + 5, mouseY);
      ctx.moveTo(mouseX, mouseY - size - 5);
      ctx.lineTo(mouseX, mouseY - size * 0.4);
      ctx.moveTo(mouseX, mouseY + size * 0.4);
      ctx.lineTo(mouseX, mouseY + size + 5);
      ctx.stroke();

      // Center dot
      ctx.fillStyle = '#f66';
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    function drawBangEffects() {
      for (const b of bangEffects) {
        const alpha = b.life / BANG_DURATION;
        if (b.hit) {
          // Score popup
          ctx.fillStyle = `rgba(255, 102, 102, ${alpha})`;
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.shadowColor = '#f66';
          ctx.shadowBlur = 8;
          ctx.fillText(`+${b.points}`, b.x, b.y - (BANG_DURATION - b.life) * 1.5);
          ctx.shadowBlur = 0;
        } else {
          // BANG text
          ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
          ctx.font = 'bold 20px Courier New';
          ctx.textAlign = 'center';
          ctx.shadowColor = '#ff0';
          ctx.shadowBlur = 10;
          ctx.fillText('BANG!', b.x, b.y - (BANG_DURATION - b.life));
          ctx.shadowBlur = 0;
        }
      }
    }

    function drawHUD() {
      // Round number
      ctx.fillStyle = '#f66';
      ctx.font = '14px Courier New';
      ctx.textAlign = 'left';
      ctx.shadowColor = '#f66';
      ctx.shadowBlur = 4;
      ctx.fillText(`ROUND ${round}`, 10, 20);
      ctx.shadowBlur = 0;

      // Shots remaining (bullet icons)
      ctx.textAlign = 'right';
      ctx.fillStyle = '#f66';
      ctx.font = '14px Courier New';
      const shotText = 'SHOTS: ' + '\u2022'.repeat(shotsLeft);
      ctx.fillText(shotText, W - 10, 20);

      // Misses (X icons)
      ctx.textAlign = 'center';
      ctx.fillStyle = '#888';
      ctx.font = '14px Courier New';
      let missDisplay = '';
      for (let i = 0; i < MAX_MISSES; i++) {
        missDisplay += i < misses ? '\u2717 ' : '\u25CB ';
      }
      ctx.fillText(missDisplay.trim(), W / 2, 20);

      // Combo display
      if (combo > 1 && comboTimer > 0) {
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        ctx.fillText(`${combo}x COMBO!`, W / 2, 38);
        ctx.shadowBlur = 0;
      }

      // Round start announcement
      if (roundStartTimer > 0) {
        const alpha = Math.min(1, roundStartTimer / 30);
        ctx.fillStyle = `rgba(255, 102, 102, ${alpha})`;
        ctx.font = 'bold 28px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#f66';
        ctx.shadowBlur = 15;
        ctx.fillText(`ROUND ${round}`, W / 2, H / 2 - 40);
        const duckText = totalDucksThisRound === 1 ? '1 DUCK' : `${totalDucksThisRound} DUCKS`;
        ctx.font = '18px Courier New';
        ctx.fillText(duckText, W / 2, H / 2 - 10);
        ctx.shadowBlur = 0;
      }

      // Round transition
      if (roundTransition > 0 && gameState === 'playing') {
        const alpha = Math.min(1, roundTransition / 20);
        ctx.fillStyle = `rgba(170, 170, 170, ${alpha})`;
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('Next round...', W / 2, H / 2);
      }
    }

    function draw() {
      // Sky gradient
      drawSkyGradient();
      drawStars();

      // Draw ducks
      for (const d of ducks) {
        if (!d.escaped || d.falling) {
          drawDuck(d);
        }
      }

      // Grass on top (ducks fly behind grass tops)
      drawGrass();

      // Bang effects
      drawBangEffects();

      // HUD
      drawHUD();

      // Crosshair (always on top)
      if (gameState === 'playing') {
        drawCrosshair();
      }
    }

    function shoot(x, y) {
      if (gameState !== 'playing') return;
      if (roundTransition > 0) return;
      if (roundStartTimer > 20) return; // brief grace period at round start
      if (shotsLeft <= 0) return;

      shotsLeft--;

      let hitAny = false;

      // Check hit against all alive ducks
      for (const d of ducks) {
        if (!d.alive || d.falling || d.escaped) continue;

        const dx = x - d.x;
        const dy = y - d.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const hitDist = d.size + HIT_RADIUS * 0.5;

        if (dist < hitDist) {
          // Hit!
          d.falling = true;
          d.fallVy = -3;

          combo++;
          comboTimer = 90;

          let points = 10 * round;
          if (combo > 1) points = Math.floor(points * (1 + combo * 0.5));

          score += points;
          scoreEl.textContent = score;
          if (score > best) {
            best = score;
            bestEl.textContent = best;
          }

          bangEffects.push({ x: d.x, y: d.y, life: BANG_DURATION, hit: true, points });
          hitAny = true;
          break; // Only hit one duck per shot
        }
      }

      if (!hitAny) {
        // Miss effect
        bangEffects.push({ x, y, life: BANG_DURATION, hit: false, points: 0 });
        combo = 0;
        comboTimer = 0;
      }

      // Check if out of shots and ducks remain
      if (shotsLeft <= 0) {
        let aliveDucks = false;
        for (const d of ducks) {
          if (d.alive && !d.falling && !d.escaped) {
            aliveDucks = true;
            break;
          }
        }
        // If out of shots but ducks remain, they'll naturally escape
      }
    }

    // Mouse tracking
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    // Click to shoot
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      mouseX = x;
      mouseY = y;

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }

      if (gameState === 'playing') {
        shoot(x, y);
      }
    });

    // Prevent context menu on right click
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Keyboard handler (space to start, general key handling)
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }

      if (gameState === 'waiting') {
        start();
        return;
      }

      if (gameState === 'over') {
        init();
        return;
      }
    });

    init();
  </script>
  <script src="../recorder.js?v=3"></script>
<script src="../rating.js?v=2"></script>
</body>
</html>

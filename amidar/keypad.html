<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amidar</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 480px;
    }
    .back { color: #f4d; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 221, 0.4); }
    h1 { color: #f4d; font-size: 2rem; text-shadow: 0 0 15px rgba(255, 68, 221, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 480px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f4d; }
    canvas {
      border: 2px solid #f4d;
      box-shadow: 0 0 20px rgba(255, 68, 221, 0.2);
      display: block;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f4d;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.85);
    }
    .overlay h2 { font-size: 1.8rem; margin-bottom: 10px; }
    .overlay p { font-size: 1rem; color: #aaa; }
    .game-row { display: flex; gap: 20px; align-items: flex-start; }
    .keypad { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 20px; }
    .keypad-row { display: flex; gap: 4px; }
    .kp-key {
      width: 44px; height: 44px;
      background: #16213e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; color: #555;
      transition: background 0.06s, border-color 0.06s, color 0.06s, box-shadow 0.06s;
    }
    .kp-key.active {
      background: rgba(255, 68, 221, 0.15);
      border-color: #f4d;
      color: #f4d;
      box-shadow: 0 0 12px rgba(255, 68, 221, 0.4);
    }
    .kp-spacer { width: 44px; height: 44px; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>AMIDAR</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="game-row">
    <div style="position: relative; display: inline-block;">
      <canvas id="game" width="480" height="480"></canvas>
      <div class="overlay" id="overlay" style="width:480px;height:480px;">
        <h2 id="overlayTitle">AMIDAR</h2>
        <p id="overlayText">Press SPACE to start</p>
      </div>
    </div>
    <div class="keypad">
      <div class="keypad-row">
        <div class="kp-spacer"></div>
        <div class="kp-key" id="kp-up">&uarr;</div>
        <div class="kp-spacer"></div>
      </div>
      <div class="keypad-row">
        <div class="kp-key" id="kp-left">&larr;</div>
        <div class="kp-key" id="kp-down">&darr;</div>
        <div class="kp-key" id="kp-right">&rarr;</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // Grid configuration
    const GRID_COLS = 7;
    const GRID_ROWS = 7;
    const MARGIN = 30;
    const CELL_W = (W - 2 * MARGIN) / GRID_COLS;
    const CELL_H = (H - 2 * MARGIN) / GRID_ROWS;
    const NODE_COLS = GRID_COLS + 1;
    const NODE_ROWS = GRID_ROWS + 1;

    // Theme colors
    const THEME = '#f4d';
    const THEME_GLOW = 'rgba(255, 68, 221, 0.6)';
    const FILL_COLOR = 'rgba(255, 68, 221, 0.25)';
    const FILL_PULSE_COLOR = 'rgba(255, 68, 221, 0.4)';
    const TRACED_COLOR = '#f4d';
    const UNTRACED_COLOR = '#16213e';
    const ENEMY_COLOR = '#f44';
    const PLAYER_COLOR = '#0ff';
    const POWERUP_COLOR = '#ff0';

    let score, best = 0, gameState;
    let lives, level;
    let player, enemies, powerup;
    let hEdges, vEdges;
    let filledBoxes;
    let totalBoxes, filledCount;
    let freezeTimer;
    let moveTimer;
    let enemyMoveTimers;
    let frameCount;
    let deathAnimation;
    let levelCompleteAnim;
    let keys = {};

    const PLAYER_SPEED = 6;
    const BASE_ENEMY_SPEED = 12;

    function init() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = '0';
      livesEl.textContent = '3';
      levelEl.textContent = '1';
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'AMIDAR';
      overlayText.textContent = 'Press SPACE to start';
      initLevel();
      draw();
    }

    function initLevel() {
      hEdges = [];
      for (let r = 0; r < NODE_ROWS; r++) {
        hEdges[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
          hEdges[r][c] = false;
        }
      }
      vEdges = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        vEdges[r] = [];
        for (let c = 0; c < NODE_COLS; c++) {
          vEdges[r][c] = false;
        }
      }

      filledBoxes = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        filledBoxes[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
          filledBoxes[r][c] = false;
        }
      }
      totalBoxes = GRID_ROWS * GRID_COLS;
      filledCount = 0;

      player = { col: 0, row: 0, targetCol: 0, targetRow: 0, moveProgress: 0, moving: false };
      moveTimer = 0;

      const numEnemies = Math.min(3 + level, 8);
      enemies = [];
      enemyMoveTimers = [];
      for (let i = 0; i < numEnemies; i++) {
        let ec, er;
        do {
          ec = Math.floor(Math.random() * NODE_COLS);
          er = Math.floor(Math.random() * NODE_ROWS);
        } while (ec === 0 && er === 0);
        const dirs = getValidDirections(er, ec);
        const dir = dirs.length > 0 ? dirs[Math.floor(Math.random() * dirs.length)] : { dr: 0, dc: 1 };
        enemies.push({
          col: ec, row: er,
          targetCol: ec, targetRow: er,
          moveProgress: 0, moving: false,
          dir: dir,
          patternType: i % 3
        });
        enemyMoveTimers.push(0);
      }

      freezeTimer = 0;
      powerup = null;
      frameCount = 0;
      deathAnimation = null;
      levelCompleteAnim = 0;
    }

    function getValidDirections(row, col) {
      const dirs = [];
      if (row > 0) dirs.push({ dr: -1, dc: 0 });
      if (row < GRID_ROWS) dirs.push({ dr: 1, dc: 0 });
      if (col > 0) dirs.push({ dr: 0, dc: -1 });
      if (col < GRID_COLS) dirs.push({ dr: 0, dc: 1 });
      return dirs;
    }

    function nodeX(col) { return MARGIN + col * CELL_W; }
    function nodeY(row) { return MARGIN + row * CELL_H; }

    function start() {
      gameState = 'playing';
      overlay.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function loop() {
      if (gameState !== 'playing') return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function update() {
      frameCount++;

      if (levelCompleteAnim > 0) {
        levelCompleteAnim--;
        if (levelCompleteAnim === 0) {
          level++;
          levelEl.textContent = level;
          score += 500 * level;
          scoreEl.textContent = score;
          if (score > best) { best = score; bestEl.textContent = best; }
          initLevel();
        }
        return;
      }

      if (deathAnimation) {
        deathAnimation.timer--;
        if (deathAnimation.timer <= 0) {
          deathAnimation = null;
          if (lives <= 0) {
            gameOver();
            return;
          }
          player.col = 0; player.row = 0;
          player.targetCol = 0; player.targetRow = 0;
          player.moveProgress = 0; player.moving = false;
        }
        return;
      }

      if (freezeTimer > 0) freezeTimer--;

      if (!powerup && Math.random() < 0.002 && frameCount > 120) {
        let pc, pr;
        do {
          pc = Math.floor(Math.random() * NODE_COLS);
          pr = Math.floor(Math.random() * NODE_ROWS);
        } while (pc === player.col && pr === player.row);
        powerup = { col: pc, row: pr, timer: 600 };
      }
      if (powerup) {
        powerup.timer--;
        if (powerup.timer <= 0) powerup = null;
      }

      updatePlayer();

      if (freezeTimer <= 0) {
        updateEnemies();
      }

      checkCollisions();

      if (powerup && !player.moving && player.col === powerup.col && player.row === powerup.row) {
        freezeTimer = 180;
        score += 50;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        powerup = null;
      }
    }

    function updatePlayer() {
      if (player.moving) {
        player.moveProgress++;
        if (player.moveProgress >= PLAYER_SPEED) {
          const fromCol = player.col;
          const fromRow = player.row;
          player.col = player.targetCol;
          player.row = player.targetRow;
          player.moving = false;
          player.moveProgress = 0;

          traceEdge(fromRow, fromCol, player.row, player.col);
          checkFilledBoxes();
        }
        return;
      }

      let dr = 0, dc = 0;
      if (keys['ArrowUp']) dr = -1;
      else if (keys['ArrowDown']) dr = 1;
      else if (keys['ArrowLeft']) dc = -1;
      else if (keys['ArrowRight']) dc = 1;

      if (dr === 0 && dc === 0) return;

      const newRow = player.row + dr;
      const newCol = player.col + dc;

      if (newRow < 0 || newRow >= NODE_ROWS || newCol < 0 || newCol >= NODE_COLS) return;

      player.targetRow = newRow;
      player.targetCol = newCol;
      player.moving = true;
      player.moveProgress = 0;
    }

    function updateEnemies() {
      const enemySpeed = Math.max(BASE_ENEMY_SPEED - level, 5);

      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];

        if (e.moving) {
          e.moveProgress++;
          if (e.moveProgress >= enemySpeed) {
            e.col = e.targetCol;
            e.row = e.targetRow;
            e.moving = false;
            e.moveProgress = 0;
          }
          continue;
        }

        let dir = e.dir;
        const validDirs = getValidDirections(e.row, e.col);

        if (validDirs.length === 0) continue;

        if (e.patternType === 2) {
          const bestDir = chaseDirection(e.row, e.col, player.row, player.col, validDirs);
          if (Math.random() < 0.7) {
            dir = bestDir;
          } else {
            dir = validDirs[Math.floor(Math.random() * validDirs.length)];
          }
        } else {
          const canContinue = validDirs.some(d => d.dr === dir.dr && d.dc === dir.dc);
          if (!canContinue) {
            const reverse = { dr: -dir.dr, dc: -dir.dc };
            const canReverse = validDirs.some(d => d.dr === reverse.dr && d.dc === reverse.dc);
            if (canReverse && Math.random() < 0.6) {
              dir = reverse;
            } else {
              const perpDirs = validDirs.filter(d => !(d.dr === dir.dr && d.dc === dir.dc));
              dir = perpDirs.length > 0
                ? perpDirs[Math.floor(Math.random() * perpDirs.length)]
                : validDirs[Math.floor(Math.random() * validDirs.length)];
            }
          } else {
            if (validDirs.length > 2 && Math.random() < 0.2) {
              dir = validDirs[Math.floor(Math.random() * validDirs.length)];
            }
          }
        }

        e.dir = dir;
        e.targetRow = e.row + dir.dr;
        e.targetCol = e.col + dir.dc;
        e.moving = true;
        e.moveProgress = 0;
      }
    }

    function chaseDirection(er, ec, pr, pc, validDirs) {
      let bestDist = Infinity;
      let bestDir = validDirs[0];
      for (const d of validDirs) {
        const nr = er + d.dr;
        const nc = ec + d.dc;
        const dist = Math.abs(nr - pr) + Math.abs(nc - pc);
        if (dist < bestDist) {
          bestDist = dist;
          bestDir = d;
        }
      }
      return bestDir;
    }

    function traceEdge(r1, c1, r2, c2) {
      if (r1 === r2) {
        const c = Math.min(c1, c2);
        hEdges[r1][c] = true;
      } else {
        const r = Math.min(r1, r2);
        vEdges[r][c1] = true;
      }
    }

    function checkFilledBoxes() {
      let newFills = 0;
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (!filledBoxes[r][c]) {
            const top = hEdges[r][c];
            const bottom = hEdges[r + 1][c];
            const left = vEdges[r][c];
            const right = vEdges[r][c + 1];
            if (top && bottom && left && right) {
              filledBoxes[r][c] = true;
              filledCount++;
              newFills++;
            }
          }
        }
      }

      if (newFills > 0) {
        score += newFills * 100 * level;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }

        if (filledCount >= totalBoxes) {
          levelCompleteAnim = 90;
        }
      }
    }

    function checkCollisions() {
      if (deathAnimation) return;

      const px = getEntityX(player);
      const py = getEntityY(player);

      for (const e of enemies) {
        const ex = getEntityX(e);
        const ey = getEntityY(e);
        const dist = Math.sqrt((px - ex) ** 2 + (py - ey) ** 2);
        if (dist < 8) {
          lives--;
          livesEl.textContent = lives;
          deathAnimation = { timer: 60, x: px, y: py };
          player.moving = false;
          player.moveProgress = 0;
          return;
        }
      }
    }

    function getEntityX(entity) {
      if (entity.moving) {
        const fromX = nodeX(entity.col);
        const toX = nodeX(entity.targetCol);
        const speed = entity === player ? PLAYER_SPEED : Math.max(BASE_ENEMY_SPEED - level, 5);
        const t = entity.moveProgress / speed;
        return fromX + (toX - fromX) * t;
      }
      return nodeX(entity.col);
    }

    function getEntityY(entity) {
      if (entity.moving) {
        const fromY = nodeY(entity.row);
        const toY = nodeY(entity.targetRow);
        const speed = entity === player ? PLAYER_SPEED : Math.max(BASE_ENEMY_SPEED - level, 5);
        const t = entity.moveProgress / speed;
        return fromY + (toY - fromY) * t;
      }
      return nodeY(entity.row);
    }

    function gameOver() {
      gameState = 'over';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'GAME OVER';
      overlayText.textContent = `Score: ${score} -- Press any key to restart`;
    }

    function draw() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);

      const pulsePhase = Math.sin(frameCount * 0.05) * 0.5 + 0.5;

      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          if (filledBoxes[r][c]) {
            const x = nodeX(c);
            const y = nodeY(r);
            const alpha = 0.2 + pulsePhase * 0.15;
            ctx.fillStyle = `rgba(255, 68, 221, ${alpha})`;
            ctx.fillRect(x, y, CELL_W, CELL_H);
          }
        }
      }

      if (levelCompleteAnim > 0) {
        const flash = Math.sin(levelCompleteAnim * 0.3) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 68, 221, ${flash * 0.3})`;
        ctx.fillRect(0, 0, W, H);
      }

      ctx.lineWidth = 2;

      for (let r = 0; r < NODE_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const x1 = nodeX(c);
          const y1 = nodeY(r);
          const x2 = nodeX(c + 1);

          if (hEdges[r][c]) {
            ctx.strokeStyle = TRACED_COLOR;
            ctx.shadowColor = THEME_GLOW;
            ctx.shadowBlur = 8;
          } else {
            ctx.strokeStyle = UNTRACED_COLOR;
            ctx.shadowBlur = 0;
          }
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y1);
          ctx.stroke();
        }
      }

      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < NODE_COLS; c++) {
          const x1 = nodeX(c);
          const y1 = nodeY(r);
          const y2 = nodeY(r + 1);

          if (vEdges[r][c]) {
            ctx.strokeStyle = TRACED_COLOR;
            ctx.shadowColor = THEME_GLOW;
            ctx.shadowBlur = 8;
          } else {
            ctx.strokeStyle = UNTRACED_COLOR;
            ctx.shadowBlur = 0;
          }
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x1, y2);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;

      for (let r = 0; r < NODE_ROWS; r++) {
        for (let c = 0; c < NODE_COLS; c++) {
          const x = nodeX(c);
          const y = nodeY(r);
          let anyTraced = false;
          if (c > 0 && hEdges[r][c - 1]) anyTraced = true;
          if (c < GRID_COLS && hEdges[r][c]) anyTraced = true;
          if (r > 0 && vEdges[r - 1][c]) anyTraced = true;
          if (r < GRID_ROWS && vEdges[r][c]) anyTraced = true;

          ctx.fillStyle = anyTraced ? TRACED_COLOR : '#2a3a5e';
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (powerup) {
        const px = nodeX(powerup.col);
        const py = nodeY(powerup.row);
        const blink = Math.sin(frameCount * 0.15) > 0;
        if (blink) {
          ctx.fillStyle = POWERUP_COLOR;
          ctx.shadowColor = POWERUP_COLOR;
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(px, py, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#1a1a2e';
          ctx.font = '10px Courier New';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('\u26A1', px, py);
        }
      }

      const frozen = freezeTimer > 0;
      for (const e of enemies) {
        const ex = getEntityX(e);
        const ey = getEntityY(e);

        if (frozen) {
          const blink = Math.sin(frameCount * 0.2) > 0;
          ctx.fillStyle = blink ? '#48f' : '#246';
          ctx.shadowColor = '#48f';
        } else {
          ctx.fillStyle = ENEMY_COLOR;
          ctx.shadowColor = ENEMY_COLOR;
        }
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(ex, ey - 7);
        ctx.lineTo(ex + 7, ey);
        ctx.lineTo(ex, ey + 7);
        ctx.lineTo(ex - 7, ey);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ex - 2, ey - 1, 1.5, 0, Math.PI * 2);
        ctx.arc(ex + 2, ey - 1, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }

      if (deathAnimation) {
        const t = 1 - deathAnimation.timer / 60;
        const radius = 5 + t * 30;
        const alpha = 1 - t;
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = PLAYER_COLOR;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(deathAnimation.x, deathAnimation.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(deathAnimation.x, deathAnimation.y, radius * 0.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
      }

      if (!deathAnimation) {
        const px = getEntityX(player);
        const py = getEntityY(player);

        ctx.fillStyle = PLAYER_COLOR;
        ctx.shadowColor = PLAYER_COLOR;
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(px, py, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(px - 2, py - 2, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      if (freezeTimer > 0) {
        ctx.fillStyle = `rgba(72, 136, 255, ${0.3 + Math.sin(frameCount * 0.1) * 0.15})`;
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('FROZEN', W / 2, H - 8);
      }

      const barY = H - 4;
      const barW = W - 2 * MARGIN;
      const barX = MARGIN;
      ctx.fillStyle = '#16213e';
      ctx.fillRect(barX, barY, barW, 3);
      ctx.fillStyle = TRACED_COLOR;
      ctx.shadowColor = THEME_GLOW;
      ctx.shadowBlur = 6;
      ctx.fillRect(barX, barY, barW * (filledCount / totalBoxes), 3);
      ctx.shadowBlur = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
      keys[e.key] = true;

      if (gameState === 'waiting') { start(); return; }
      if (gameState === 'over') { init(); return; }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    const kpMap = { ArrowUp: 'kp-up', ArrowDown: 'kp-down', ArrowLeft: 'kp-left', ArrowRight: 'kp-right' };
    document.addEventListener('keydown', (e) => { if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.add('active'); });
    document.addEventListener('keyup', (e) => { if (kpMap[e.key]) document.getElementById(kpMap[e.key]).classList.remove('active'); });

    init();
  </script>
</body>
</html>

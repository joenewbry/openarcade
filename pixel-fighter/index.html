<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Fighter</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      width: 600px;
    }
    .back { color: #f44; text-decoration: none; font-size: 1.2rem; }
    .back:hover { text-shadow: 0 0 10px rgba(255, 68, 68, 0.5); }
    h1 { color: #f44; font-size: 1.8rem; text-shadow: 0 0 15px rgba(255, 68, 68, 0.4); }
    .score-bar {
      display: flex;
      justify-content: space-between;
      width: 600px;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }
    .score-bar span { color: #f44; }
    canvas {
      border: 2px solid #f44;
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
      display: block;
      image-rendering: pixelated;
    }
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #f44;
      text-align: center;
      pointer-events: none;
      background: rgba(26, 26, 46, 0.88);
    }
    .overlay h2 { font-size: 2rem; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,68,68,0.6); }
    .overlay p { font-size: 0.95rem; color: #aaa; line-height: 1.6; }
    .overlay .highlight { color: #f44; font-size: 1.1rem; }
  </style>
</head>
<body>
  <div class="header">
    <a href="../" class="back">&larr; Back</a>
    <h1>PIXEL FIGHTER</h1>
  </div>
  <div class="score-bar">
    <div>Score: <span id="score">0</span></div>
    <div>Round: <span id="roundDisp">1</span>/3 | Time: <span id="timerDisp">60</span>s</div>
  </div>
  <div style="position: relative; display: inline-block;">
    <canvas id="game" width="600" height="350"></canvas>
    <div class="overlay" id="overlay" style="width:600px;height:350px;">
      <h2 id="overlayTitle">PIXEL FIGHTER</h2>
      <p id="overlayText">Click to Fight<br><br>
      <span class="highlight">CONTROLS</span><br>
      Arrow Keys = Move / Jump / Crouch<br>
      Z = Punch | X = Kick | C = Special<br>
      S = Block<br><br>
      <span class="highlight">COMBOS</span><br>
      Z-Z-X = Triple Strike (1.5x bonus)<br>
      Z-X-C = Fury Chain (2x bonus)</p>
    </div>
  </div>

  <script src="../recorder.js"></script>
  <script>
    // == Canvas & DOM ==
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = 600, H = 350;
    const scoreEl = document.getElementById('score');
    const roundDispEl = document.getElementById('roundDisp');
    const timerDispEl = document.getElementById('timerDisp');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');

    // == Global Game State ==
    let gameState = 'waiting';
    let score = 0;

    // == Theme Constants ==
    const THEME = '#f44';
    const THEME_RGB = '255,68,68';
    const BG = '#1a1a2e';
    const FLOOR_Y = 280;
    const GRAVITY = 1400;

    // == Move Definitions ==
    // { damage, startup, active, recovery, knockback, hitstun, blockstun, chipDamage }
    const MOVES = {
      jab:         { damage: 6,  startup: 4,  active: 3,  recovery: 6,  knockback: 40,  hitstun: 12, blockstun: 6,  chipDamage: 1, type: 'punch' },
      kick:        { damage: 10, startup: 7,  active: 4,  recovery: 10, knockback: 70,  hitstun: 18, blockstun: 10, chipDamage: 2, type: 'kick' },
      special:     { damage: 22, startup: 14, active: 6,  recovery: 18, knockback: 130, hitstun: 28, blockstun: 16, chipDamage: 4, type: 'special' },
      jumpKick:    { damage: 12, startup: 3,  active: 5,  recovery: 8,  knockback: 60,  hitstun: 16, blockstun: 8,  chipDamage: 2, type: 'kick' },
      crouchPunch: { damage: 7,  startup: 5,  active: 3,  recovery: 7,  knockback: 30,  hitstun: 14, blockstun: 7,  chipDamage: 1, type: 'punch' },
      crouchKick:  { damage: 9,  startup: 6,  active: 4,  recovery: 9,  knockback: 50,  hitstun: 16, blockstun: 9,  chipDamage: 2, type: 'kick' }
    };

    const SPECIAL_COOLDOWN = 180; // frames (3 seconds at 60fps)
    const MAX_HP = 100;
    const ROUND_TIME = 60;
    const MAX_ROUNDS = 3;
    const COMBO_WINDOW = 30; // frames to chain next hit

    // == Fighter Factory ==
    function createFighter(x, facingRight, isAI) {
      return {
        x: x, y: FLOOR_Y, vx: 0, vy: 0,
        w: 36, h: 64,
        hp: MAX_HP,
        facingRight: facingRight,
        isAI: isAI,
        state: 'idle',
        attackMove: null,
        attackFrame: 0,
        stateTimer: 0,
        blocking: false,
        crouching: false,
        grounded: true,
        specialCooldown: 0,
        comboHits: 0,
        comboSequence: [],
        comboTimer: 0,
        comboDamageBonus: 1.0,
        animFrame: 0,
        animTimer: 0,
        walkFrame: 0,
        hitConnected: false,
        wins: 0,
        actionHistory: [],
        patternWeights: { jab: 0, kick: 0, special: 0, block: 0, jump: 0, crouch: 0 }
      };
    }

    // == Particles & Effects ==
    let particles = [];
    let comboTexts = [];
    let screenShake = 0;
    let announceText = '';
    let announceTimer = 0;

    // == Game Variables ==
    let player, ai;
    let roundNum = 1;
    let roundTimer = ROUND_TIME;
    let frameCount = 0;
    let lastTime = 0;
    let dt = 0;
    let playerRoundsWon = 0;
    let aiRoundsWon = 0;

    // == Input ==
    const keys = {};
    const keysJustPressed = {};
    document.addEventListener('keydown', function(e) {
      if (!keys[e.key]) keysJustPressed[e.key] = true;
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.key) !== -1 ||
          ['z','x','c','s','Z','X','C','S'].indexOf(e.key) !== -1) {
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', function(e) { keys[e.key] = false; });

    function justPressed(key) {
      return keysJustPressed[key] || keysJustPressed[key.toLowerCase()] || keysJustPressed[key.toUpperCase()];
    }

    // == Click handler ==
    canvas.parentElement.addEventListener('click', function() {
      if (gameState === 'waiting') {
        startMatch();
      } else if (gameState === 'over') {
        resetMatch();
      }
    });

    // == Match Control ==
    function startMatch() {
      gameState = 'playing';
      overlay.style.display = 'none';
      score = 0;
      scoreEl.textContent = '0';
      roundNum = 1;
      playerRoundsWon = 0;
      aiRoundsWon = 0;
      startRound();
    }

    function startRound() {
      player = createFighter(120, true, false);
      ai = createFighter(W - 156, false, true);
      roundTimer = ROUND_TIME;
      frameCount = 0;
      particles = [];
      comboTexts = [];
      screenShake = 0;
      roundDispEl.textContent = roundNum;
      announce('ROUND ' + roundNum);
    }

    function announce(text) {
      announceText = text;
      announceTimer = 90;
    }

    function endRound() {
      if (gameState !== 'playing') return;
      gameState = 'roundEnd';
      if (player.hp > ai.hp) {
        playerRoundsWon++;
        announce('YOU WIN!');
        score += 200;
      } else if (ai.hp > player.hp) {
        aiRoundsWon++;
        announce('AI WINS!');
      } else {
        announce('DRAW!');
      }
      scoreEl.textContent = score;

      setTimeout(function() {
        if (playerRoundsWon >= 2 || aiRoundsWon >= 2 || roundNum >= MAX_ROUNDS) {
          endMatch();
        } else {
          roundNum++;
          aiAdapt();
          startRound();
          gameState = 'playing';
        }
      }, 2000);
    }

    function endMatch() {
      gameState = 'over';
      var result = playerRoundsWon > aiRoundsWon ? 'VICTORY!' : (playerRoundsWon < aiRoundsWon ? 'DEFEAT' : 'DRAW');
      if (playerRoundsWon > aiRoundsWon) score += 500;
      scoreEl.textContent = score;
      overlay.style.display = 'flex';
      overlayTitle.textContent = result;
      overlayText.innerHTML = 'Final Score: <span class="highlight">' + score + '</span><br>' +
        'Rounds: You ' + playerRoundsWon + ' - ' + aiRoundsWon + ' AI<br><br>Click to Play Again';
    }

    function resetMatch() {
      gameState = 'waiting';
      overlay.style.display = 'flex';
      overlayTitle.textContent = 'PIXEL FIGHTER';
      overlayText.innerHTML = 'Click to Fight<br><br>' +
        '<span class="highlight">CONTROLS</span><br>' +
        'Arrow Keys = Move / Jump / Crouch<br>' +
        'Z = Punch | X = Kick | C = Special<br>' +
        'S = Block<br><br>' +
        '<span class="highlight">COMBOS</span><br>' +
        'Z-Z-X = Triple Strike (1.5x bonus)<br>' +
        'Z-X-C = Fury Chain (2x bonus)';
    }

    // == Hitbox Helpers ==
    function getHurtbox(f) {
      var h = f.crouching ? f.h * 0.6 : f.h;
      var yOff = f.crouching ? f.h - h : 0;
      return { x: f.x, y: f.y - f.h + yOff, w: f.w, h: h };
    }

    function getAttackHitbox(f) {
      if (!f.attackMove) return null;
      var move = MOVES[f.attackMove];
      if (f.attackFrame < move.startup || f.attackFrame >= move.startup + move.active) return null;
      var reach = f.attackMove === 'special' ? 55 : (f.attackMove.indexOf('kick') !== -1 || f.attackMove === 'kick' ? 45 : 35);
      var hbW = reach;
      var hbH = f.crouching ? 20 : (f.attackMove === 'jumpKick' ? 25 : 30);
      var hbX = f.facingRight ? f.x + f.w : f.x - hbW;
      var hbY = f.y - f.h / 2;
      if (f.attackMove === 'crouchPunch' || f.attackMove === 'crouchKick') {
        hbY = f.y - 20;
      }
      if (f.attackMove === 'jumpKick') {
        hbY = f.y - f.h / 2;
      }
      return { x: hbX, y: hbY, w: hbW, h: hbH };
    }

    function rectsOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // == Combo Detection ==
    function checkCombo(fighter) {
      var seq = fighter.comboSequence;
      if (seq.length >= 3) {
        var last3 = seq.slice(-3).join(',');
        if (last3 === 'jab,jab,kick') {
          fighter.comboDamageBonus = 1.5;
          spawnComboText(fighter, 'TRIPLE STRIKE!');
          return;
        }
        if (last3 === 'jab,kick,special') {
          fighter.comboDamageBonus = 2.0;
          spawnComboText(fighter, 'FURY CHAIN!');
          return;
        }
      }
      if (seq.length >= 2) {
        fighter.comboDamageBonus = 1.0 + (seq.length - 1) * 0.15;
      } else {
        fighter.comboDamageBonus = 1.0;
      }
    }

    function spawnComboText(fighter, text) {
      comboTexts.push({ x: fighter.x + fighter.w / 2, y: fighter.y - fighter.h - 20, text: text, timer: 60, color: '#ff0' });
    }

    // == Hit Resolution ==
    function resolveHit(attacker, defender) {
      if (attacker.hitConnected) return;
      var move = MOVES[attacker.attackMove];
      if (!move) return;

      attacker.hitConnected = true;
      var blocked = defender.blocking && defender.state !== 'hitstun';

      if (blocked) {
        var chipDmg = move.chipDamage;
        defender.hp = Math.max(0, defender.hp - chipDmg);
        defender.state = 'blockstun';
        defender.stateTimer = move.blockstun;
        if (!attacker.isAI) score += chipDmg;
        screenShake = 3;
        spawnBlockSparks(defender);
      } else {
        attacker.comboHits++;
        attacker.comboSequence.push(attacker.attackMove);
        attacker.comboTimer = COMBO_WINDOW;
        checkCombo(attacker);

        var dmg = Math.round(move.damage * attacker.comboDamageBonus);
        defender.hp = Math.max(0, defender.hp - dmg);
        defender.state = 'hitstun';
        defender.stateTimer = move.hitstun;

        var kb = move.knockback * (attacker.facingRight ? 1 : -1);
        defender.vx = kb * 3;
        if (move.type === 'special') {
          defender.vy = -200;
          defender.grounded = false;
        }

        if (!attacker.isAI) {
          score += dmg * 2;
          if (attacker.comboHits >= 3) score += attacker.comboHits * 10;
        }
        scoreEl.textContent = score;
        screenShake = move.type === 'special' ? 8 : 5;
        spawnHitSparks(defender, move.type);
      }
    }

    // == Effects ==
    function spawnHitSparks(target, type) {
      var cx = target.x + target.w / 2;
      var cy = target.y - target.h / 2;
      var count = type === 'special' ? 20 : 10;
      var colors = type === 'special' ? ['#ff0','#f80','#f44','#fff'] : ['#fff','#ff0','#f80'];
      for (var i = 0; i < count; i++) {
        var angle = Math.random() * Math.PI * 2;
        var speed = 60 + Math.random() * 180;
        particles.push({
          x: cx + (Math.random() - 0.5) * 10,
          y: cy + (Math.random() - 0.5) * 10,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.3 + Math.random() * 0.3,
          maxLife: 0.3 + Math.random() * 0.3,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: type === 'special' ? 3 + Math.random() * 3 : 2 + Math.random() * 2
        });
      }
    }

    function spawnBlockSparks(target) {
      var cx = target.x + target.w / 2;
      var cy = target.y - target.h / 2;
      for (var i = 0; i < 6; i++) {
        var angle = Math.random() * Math.PI * 2;
        var speed = 40 + Math.random() * 80;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.2, maxLife: 0.2,
          color: '#88f',
          size: 2
        });
      }
    }

    // == Fighter Update ==
    function updateFighter(f, opponent, dtSec) {
      f.animTimer++;
      if (f.animTimer >= 8) { f.animTimer = 0; f.animFrame = (f.animFrame + 1) % 4; }

      if (f.specialCooldown > 0) f.specialCooldown--;
      if (f.comboTimer > 0) {
        f.comboTimer--;
        if (f.comboTimer <= 0) {
          f.comboHits = 0;
          f.comboSequence = [];
          f.comboDamageBonus = 1.0;
        }
      }

      // Face opponent
      if (f.state !== 'hitstun' && f.state !== 'blockstun' && f.state !== 'attack') {
        f.facingRight = f.x < opponent.x;
      }

      // State machine
      switch (f.state) {
        case 'attack':
          f.attackFrame++;
          var mv = MOVES[f.attackMove];
          if (mv && f.attackFrame >= mv.startup + mv.active + mv.recovery) {
            f.state = 'idle';
            f.attackMove = null;
            f.attackFrame = 0;
            f.hitConnected = false;
          }
          if (mv && f.attackFrame >= mv.startup && f.attackFrame < mv.startup + mv.active) {
            var hitbox = getAttackHitbox(f);
            var hurtbox = getHurtbox(opponent);
            if (hitbox && hurtbox && rectsOverlap(hitbox, hurtbox)) {
              resolveHit(f, opponent);
            }
          }
          break;
        case 'hitstun':
          f.stateTimer--;
          if (f.stateTimer <= 0) { f.state = 'idle'; f.vx = 0; }
          break;
        case 'blockstun':
          f.stateTimer--;
          if (f.stateTimer <= 0) { f.state = 'idle'; }
          break;
      }

      // Physics
      if (!f.grounded) {
        f.vy += GRAVITY * dtSec;
        f.y += f.vy * dtSec;
        if (f.y >= FLOOR_Y) {
          f.y = FLOOR_Y;
          f.vy = 0;
          f.grounded = true;
        }
      }

      // Knockback
      if (f.state === 'hitstun' || f.state === 'blockstun') {
        f.x += f.vx * dtSec;
        f.vx *= 0.9;
      }

      // Bounds
      f.x = Math.max(10, Math.min(W - f.w - 10, f.x));

      // Push apart
      var dist = Math.abs(f.x - opponent.x);
      if (dist < f.w + 4 && f.state !== 'hitstun' && opponent.state !== 'hitstun') {
        var push = (f.w + 4 - dist) / 2;
        if (f.x < opponent.x) { f.x -= push; opponent.x += push; }
        else { f.x += push; opponent.x -= push; }
      }
    }

    // == Player Input ==
    function handlePlayerInput() {
      var p = player;
      if (p.state === 'hitstun' || p.state === 'blockstun') return;

      // Block
      p.blocking = keys['s'] || keys['S'];
      if (p.blocking && p.state !== 'attack') {
        p.state = 'idle';
        p.vx = 0;
        p.actionHistory.push('block');
        return;
      }

      // Attacks
      if (p.state !== 'attack') {
        if (!p.grounded && (justPressed('x') || justPressed('X'))) {
          startAttack(p, 'jumpKick');
          p.actionHistory.push('jump');
          return;
        }
        if (p.crouching) {
          if (justPressed('z') || justPressed('Z')) {
            startAttack(p, 'crouchPunch');
            p.actionHistory.push('crouch');
            return;
          }
          if (justPressed('x') || justPressed('X')) {
            startAttack(p, 'crouchKick');
            p.actionHistory.push('crouch');
            return;
          }
        }
        if (justPressed('z') || justPressed('Z')) {
          startAttack(p, 'jab');
          p.actionHistory.push('jab');
          return;
        }
        if (justPressed('x') || justPressed('X')) {
          startAttack(p, 'kick');
          p.actionHistory.push('kick');
          return;
        }
        if ((justPressed('c') || justPressed('C')) && p.specialCooldown <= 0) {
          startAttack(p, 'special');
          p.specialCooldown = SPECIAL_COOLDOWN;
          p.actionHistory.push('special');
          return;
        }
      }

      if (p.state === 'attack') return;

      // Crouch
      p.crouching = !!keys['ArrowDown'];
      if (p.crouching) {
        p.state = 'crouch';
        p.vx = 0;
        return;
      }

      // Jump
      if (keys['ArrowUp'] && p.grounded) {
        p.vy = -520;
        p.grounded = false;
        p.state = 'jump';
        p.actionHistory.push('jump');
        return;
      }

      // Walk
      var moving = false;
      if (keys['ArrowLeft']) { p.vx = -180; moving = true; }
      else if (keys['ArrowRight']) { p.vx = 180; moving = true; }
      else { p.vx = 0; }

      if (moving && p.grounded) {
        p.state = 'walk';
        p.x += p.vx * dt;
      } else if (p.grounded) {
        p.state = 'idle';
      }
      if (!p.grounded) { p.x += p.vx * dt; }
    }

    function startAttack(f, moveName) {
      f.state = 'attack';
      f.attackMove = moveName;
      f.attackFrame = 0;
      f.hitConnected = false;
    }

    // ================================================================
    // == AI BEHAVIOR TREE ==
    // ================================================================
    var aiPersonality = {
      aggression: 0.5,
      reactionSpeed: 12,
      specialPref: 0.15,
      blockPref: 0.3,
      jumpPref: 0.15,
      adaptRate: 0.1
    };
    var aiDecisionTimer = 0;
    var aiCurrentAction = 'idle';

    function aiAdapt() {
      var hist = player.actionHistory;
      if (hist.length < 5) return;
      var counts = { jab: 0, kick: 0, special: 0, block: 0, jump: 0, crouch: 0 };
      var recent = hist.slice(-30);
      for (var i = 0; i < recent.length; i++) {
        if (counts[recent[i]] !== undefined) counts[recent[i]]++;
      }
      var total = recent.length || 1;

      if (counts.jab / total > 0.3) {
        aiPersonality.blockPref = Math.min(0.6, aiPersonality.blockPref + aiPersonality.adaptRate);
        aiPersonality.aggression = Math.max(0.2, aiPersonality.aggression - 0.05);
      }
      if (counts.block / total > 0.25) {
        aiPersonality.specialPref = Math.min(0.35, aiPersonality.specialPref + aiPersonality.adaptRate);
        aiPersonality.aggression = Math.min(0.8, aiPersonality.aggression + 0.1);
      }
      if (counts.jump / total > 0.2) {
        aiPersonality.jumpPref = Math.max(0.05, aiPersonality.jumpPref - 0.05);
      }
      if (counts.special / total > 0.15) {
        aiPersonality.reactionSpeed = Math.max(6, aiPersonality.reactionSpeed - 2);
      }
    }

    function updateAI() {
      var a = ai;
      if (a.state === 'hitstun' || a.state === 'blockstun') return;

      aiDecisionTimer--;
      if (aiDecisionTimer > 0 && aiCurrentAction === 'wait') return;

      var distX = Math.abs(a.x - player.x);
      var playerAttacking = player.state === 'attack';
      var inRange = distX < 80;
      var closeRange = distX < 55;
      var farRange = distX > 200;

      if (aiDecisionTimer <= 0) {
        aiDecisionTimer = aiPersonality.reactionSpeed + Math.floor(Math.random() * 8);
        var r = Math.random();

        // Node 1: React to player attack
        if (playerAttacking && inRange) {
          if (r < aiPersonality.blockPref) aiCurrentAction = 'block';
          else if (r < aiPersonality.blockPref + aiPersonality.jumpPref) aiCurrentAction = 'jumpBack';
          else aiCurrentAction = 'counterAttack';
          return;
        }

        // Node 2: Anti-air
        if (!player.grounded && distX < 120) {
          aiCurrentAction = r < 0.5 ? 'antiAir' : 'block';
          return;
        }

        // Node 3: Close range
        if (closeRange) {
          if (r < aiPersonality.aggression * 0.7) {
            var atkRoll = Math.random();
            if (atkRoll < 0.4) aiCurrentAction = 'jab';
            else if (atkRoll < 0.7) aiCurrentAction = 'kick';
            else if (a.specialCooldown <= 0 && Math.random() < aiPersonality.specialPref * 2) aiCurrentAction = 'special';
            else aiCurrentAction = 'jab';
          } else if (r < aiPersonality.aggression * 0.7 + 0.2) aiCurrentAction = 'block';
          else aiCurrentAction = 'walkBack';
          return;
        }

        // Node 4: In attack range
        if (inRange) {
          if (r < aiPersonality.aggression) {
            var atkRoll2 = Math.random();
            if (atkRoll2 < 0.35) aiCurrentAction = 'jab';
            else if (atkRoll2 < 0.65) aiCurrentAction = 'kick';
            else if (a.specialCooldown <= 0 && atkRoll2 < 0.65 + aiPersonality.specialPref) aiCurrentAction = 'special';
            else aiCurrentAction = 'kick';
          } else {
            aiCurrentAction = r < 0.5 ? 'block' : 'walkBack';
          }
          return;
        }

        // Node 5: Far range
        if (farRange) {
          if (r < 0.6) aiCurrentAction = 'approach';
          else if (r < 0.8) aiCurrentAction = 'jumpForward';
          else aiCurrentAction = 'wait';
          return;
        }

        // Node 6: Mid range
        if (r < aiPersonality.aggression * 0.8) aiCurrentAction = 'approach';
        else if (r < aiPersonality.aggression * 0.8 + 0.15) aiCurrentAction = 'jumpForward';
        else aiCurrentAction = 'wait';
      }

      // Execute current action
      a.blocking = false;
      a.crouching = false;

      switch (aiCurrentAction) {
        case 'approach':
          if (a.state !== 'attack') {
            a.state = 'walk';
            a.vx = a.facingRight ? 160 : -160;
            a.x += a.vx * dt;
          }
          break;
        case 'walkBack':
          if (a.state !== 'attack') {
            a.state = 'walk';
            a.vx = a.facingRight ? -140 : 140;
            a.x += a.vx * dt;
          }
          break;
        case 'block':
          a.blocking = true;
          a.state = 'idle';
          a.vx = 0;
          break;
        case 'jab':
          if (a.state !== 'attack') startAttack(a, 'jab');
          aiCurrentAction = 'wait';
          if (Math.random() < 0.35) {
            setTimeout(function() {
              if (a.state !== 'hitstun' && gameState === 'playing') {
                aiCurrentAction = 'kick';
                aiDecisionTimer = 2;
              }
            }, 250);
          }
          break;
        case 'kick':
          if (a.state !== 'attack') startAttack(a, 'kick');
          aiCurrentAction = 'wait';
          break;
        case 'special':
          if (a.state !== 'attack' && a.specialCooldown <= 0) {
            startAttack(a, 'special');
            a.specialCooldown = SPECIAL_COOLDOWN;
          }
          aiCurrentAction = 'wait';
          break;
        case 'counterAttack':
          if (a.state !== 'attack') startAttack(a, Math.random() < 0.5 ? 'jab' : 'kick');
          aiCurrentAction = 'wait';
          break;
        case 'antiAir':
          if (a.state !== 'attack') startAttack(a, 'kick');
          aiCurrentAction = 'wait';
          break;
        case 'jumpForward':
          if (a.grounded) {
            a.vy = -480;
            a.grounded = false;
            a.state = 'jump';
            a.vx = a.facingRight ? 140 : -140;
          }
          aiCurrentAction = 'wait';
          break;
        case 'jumpBack':
          if (a.grounded) {
            a.vy = -420;
            a.grounded = false;
            a.state = 'jump';
            a.vx = a.facingRight ? -120 : 120;
          }
          aiCurrentAction = 'wait';
          break;
        case 'wait':
          if (a.state !== 'attack') a.state = a.grounded ? 'idle' : 'jump';
          a.vx = 0;
          break;
      }
    }

    // ================================================================
    // == DRAWING ==
    // ================================================================

    function drawArena() {
      var grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#0d0d1a');
      grad.addColorStop(0.7, '#1a1a2e');
      grad.addColorStop(1, '#16213e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Floor
      ctx.fillStyle = '#222244';
      ctx.fillRect(0, FLOOR_Y + 2, W, H - FLOOR_Y);

      // Floor line glow
      ctx.save();
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 8;
      ctx.strokeStyle = THEME;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, FLOOR_Y + 2);
      ctx.lineTo(W, FLOOR_Y + 2);
      ctx.stroke();
      ctx.restore();

      // Grid lines
      ctx.strokeStyle = 'rgba(255,68,68,0.08)';
      ctx.lineWidth = 1;
      for (var x = 0; x < W; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, FLOOR_Y + 2); ctx.lineTo(x, H); ctx.stroke();
      }
      for (var y = FLOOR_Y + 20; y < H; y += 20) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }

      // Background pillars
      ctx.fillStyle = 'rgba(255,68,68,0.04)';
      ctx.fillRect(50, 60, 16, FLOOR_Y - 58);
      ctx.fillRect(W - 66, 60, 16, FLOOR_Y - 58);
    }

    function drawHealthBars() {
      var barW = 200, barH = 16, barY = 16, gap = 10;
      drawHealthBar(gap, barY, barW, barH, player.hp, MAX_HP, '#4f4', 'P1', true);
      drawHealthBar(W - barW - gap, barY, barW, barH, ai.hp, MAX_HP, '#f44', 'AI', false);

      // Round win indicators
      var centerX = W / 2;
      for (var i = 0; i < 2; i++) {
        ctx.fillStyle = i < playerRoundsWon ? '#4f4' : '#333';
        ctx.save();
        if (i < playerRoundsWon) { ctx.shadowColor = '#4f4'; ctx.shadowBlur = 6; }
        ctx.beginPath();
        ctx.arc(centerX - 20 - i * 18, barY + barH / 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      for (var i = 0; i < 2; i++) {
        ctx.fillStyle = i < aiRoundsWon ? '#f44' : '#333';
        ctx.save();
        if (i < aiRoundsWon) { ctx.shadowColor = '#f44'; ctx.shadowBlur = 6; }
        ctx.beginPath();
        ctx.arc(centerX + 20 + i * 18, barY + barH / 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // VS
      ctx.fillStyle = '#666';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('VS', centerX, barY + barH / 2 + 3);

      // Timer
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Courier New';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 6;
      ctx.fillText(Math.max(0, Math.ceil(roundTimer)), centerX, barY + barH + 22);
      ctx.restore();
      ctx.textAlign = 'left';
    }

    function drawHealthBar(x, y, w, h, hp, maxHp, color, label, leftAligned) {
      ctx.fillStyle = '#111';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);

      var ratio = hp / maxHp;
      var fillW = w * ratio;
      var healthColor = ratio > 0.5 ? color : (ratio > 0.25 ? '#ff0' : '#f44');

      ctx.save();
      ctx.shadowColor = healthColor;
      ctx.shadowBlur = 6;
      ctx.fillStyle = healthColor;
      if (leftAligned) {
        ctx.fillRect(x + 1, y + 1, Math.max(0, fillW - 2), h - 2);
      } else {
        ctx.fillRect(x + w - fillW + 1, y + 1, Math.max(0, fillW - 2), h - 2);
      }
      ctx.restore();

      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px Courier New';
      ctx.textAlign = leftAligned ? 'left' : 'right';
      ctx.fillText(label, leftAligned ? x + 4 : x + w - 4, y + h - 4);
      ctx.textAlign = leftAligned ? 'right' : 'left';
      ctx.fillText(Math.ceil(hp), leftAligned ? x + w - 4 : x + 4, y + h - 4);
      ctx.textAlign = 'left';
    }

    // == Pixel Fighter Rendering ==
    function drawFighter(f, color1, color2) {
      ctx.save();
      var cx = f.x + f.w / 2;
      var flip = f.facingRight ? 1 : -1;

      // Ground shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(cx, FLOOR_Y + 3, 18, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      var bodyY = f.y;
      var headY = bodyY - f.h;
      var bobble = 0;
      var legOffset = 0;

      if (f.state === 'walk') {
        f.walkFrame += 0.15;
        bobble = Math.sin(f.walkFrame * 4) * 2;
        legOffset = Math.sin(f.walkFrame * 4) * 8;
      }
      if (f.state === 'crouch' || f.crouching) {
        headY += 16;
      }
      if (f.state === 'hitstun') {
        bobble = Math.sin(frameCount * 0.5) * 3;
      }

      headY += bobble;
      var torsoTop = headY + 14;
      var torsoBot = bodyY - 14;
      var hipY = bodyY - 6;

      // == Legs ==
      ctx.strokeStyle = color1;
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';

      if (f.crouching || f.state === 'crouch') {
        ctx.beginPath();
        ctx.moveTo(cx - 6 * flip, hipY + 8);
        ctx.lineTo(cx - 12 * flip, hipY + 14);
        ctx.lineTo(cx - 6 * flip, hipY + 18);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + 4 * flip, hipY + 8);
        ctx.lineTo(cx + 10 * flip, hipY + 14);
        ctx.lineTo(cx + 4 * flip, hipY + 18);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(cx - 5, hipY);
        ctx.lineTo(cx - 5 - legOffset * flip * 0.5, hipY + 14);
        ctx.lineTo(cx - 5 - legOffset * flip, bodyY + 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + 5, hipY);
        ctx.lineTo(cx + 5 + legOffset * flip * 0.5, hipY + 14);
        ctx.lineTo(cx + 5 + legOffset * flip, bodyY + 4);
        ctx.stroke();
        // Feet
        ctx.fillStyle = color2;
        ctx.fillRect(cx - 8 - legOffset * flip - 2, bodyY + 1, 6, 3);
        ctx.fillRect(cx + 2 + legOffset * flip - 2, bodyY + 1, 6, 3);
      }

      // == Torso ==
      ctx.fillStyle = color1;
      ctx.fillRect(cx - 9, torsoTop, 18, torsoBot - torsoTop + 6);
      ctx.fillStyle = color2;
      ctx.fillRect(cx - 9, hipY - 2, 18, 4);

      // == Arms ==
      var shoulderY = torsoTop + 4;

      if (f.state === 'attack' && f.attackMove) {
        drawAttackArms(f, cx, shoulderY, flip, color1, color2);
      } else if (f.blocking) {
        ctx.strokeStyle = color1;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(cx + 8 * flip, shoulderY);
        ctx.lineTo(cx + 18 * flip, shoulderY + 6);
        ctx.lineTo(cx + 14 * flip, shoulderY - 4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx - 2 * flip, shoulderY);
        ctx.lineTo(cx + 12 * flip, shoulderY + 10);
        ctx.lineTo(cx + 10 * flip, shoulderY);
        ctx.stroke();
        // Block shield
        ctx.strokeStyle = 'rgba(100,100,255,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx + 16 * flip, shoulderY + 4, 12, -Math.PI / 2, Math.PI / 2);
        ctx.stroke();
      } else {
        // Idle fighting stance
        ctx.strokeStyle = color1;
        ctx.lineWidth = 4;
        var armBob = Math.sin(f.animFrame * 0.5 + frameCount * 0.05) * 2;
        // Front arm
        ctx.beginPath();
        ctx.moveTo(cx + 8 * flip, shoulderY);
        ctx.lineTo(cx + 16 * flip, shoulderY - 4 + armBob);
        ctx.lineTo(cx + 20 * flip, shoulderY - 8 + armBob);
        ctx.stroke();
        ctx.fillStyle = color2;
        ctx.fillRect(cx + 18 * flip - 2, shoulderY - 10 + armBob, 5, 5);
        // Back arm
        ctx.strokeStyle = color1;
        ctx.beginPath();
        ctx.moveTo(cx - 4 * flip, shoulderY + 2);
        ctx.lineTo(cx + 6 * flip, shoulderY + 12);
        ctx.stroke();
        ctx.fillStyle = color2;
        ctx.fillRect(cx + 4 * flip - 2, shoulderY + 10, 5, 5);
      }

      // == Head ==
      var headCx = cx + 2 * flip;
      var headCy = headY + 7;
      ctx.fillStyle = color1;
      ctx.beginPath();
      ctx.arc(headCx, headCy, 9, 0, Math.PI * 2);
      ctx.fill();

      // Headband
      ctx.fillStyle = color2;
      ctx.fillRect(headCx - 10, headCy - 3, 20, 3);
      if (!f.facingRight) {
        ctx.fillRect(headCx + 9, headCy - 5, 6, 2);
        ctx.fillRect(headCx + 13, headCy - 7, 4, 2);
      } else {
        ctx.fillRect(headCx - 15, headCy - 5, 6, 2);
        ctx.fillRect(headCx - 17, headCy - 7, 4, 2);
      }

      // Eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(headCx + 2 * flip, headCy - 2, 3, 3);
      ctx.fillRect(headCx + 6 * flip, headCy - 2, 3, 3);
      ctx.fillStyle = '#111';
      ctx.fillRect(headCx + 3 * flip + flip, headCy - 1, 2, 2);
      ctx.fillRect(headCx + 7 * flip + flip, headCy - 1, 2, 2);

      // Hitstun flash
      if (f.state === 'hitstun' && frameCount % 4 < 2) {
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(f.x - 2, headY - 2, f.w + 4, f.h + 4);
      }

      // Special cooldown bar
      if (f.specialCooldown > 0) {
        var cdRatio = f.specialCooldown / SPECIAL_COOLDOWN;
        ctx.fillStyle = 'rgba(255,255,0,0.3)';
        ctx.fillRect(cx - 8, bodyY + 6, 16, 3);
        ctx.fillStyle = '#ff0';
        ctx.fillRect(cx - 8, bodyY + 6, 16 * (1 - cdRatio), 3);
      } else if (!f.isAI) {
        ctx.save();
        ctx.fillStyle = '#0f0';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 4;
        ctx.fillRect(cx - 3, bodyY + 6, 6, 2);
        ctx.restore();
      }

      ctx.restore();
    }

    function drawAttackArms(f, cx, shoulderY, flip, color1, color2) {
      var move = MOVES[f.attackMove];
      var phase = f.attackFrame < move.startup ? 'windup' :
                  (f.attackFrame < move.startup + move.active ? 'active' : 'recovery');
      var ext = 0;
      if (phase === 'windup') ext = -0.3;
      else if (phase === 'active') ext = 1.0;
      else ext = 0.5 * (1 - (f.attackFrame - move.startup - move.active) / move.recovery);

      ctx.strokeStyle = color1;
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';

      switch (f.attackMove) {
        case 'jab':
        case 'crouchPunch':
          ctx.beginPath();
          ctx.moveTo(cx + 8 * flip, shoulderY);
          ctx.lineTo(cx + (8 + 22 * ext) * flip, shoulderY + (phase === 'windup' ? 4 : -2));
          ctx.stroke();
          if (phase === 'active') {
            ctx.fillStyle = '#fff';
            ctx.save(); ctx.shadowColor = '#ff0'; ctx.shadowBlur = 6;
            ctx.fillRect(cx + (6 + 22 * ext) * flip - 2, shoulderY - 4, 6, 6);
            ctx.restore();
          } else {
            ctx.fillStyle = color2;
            ctx.fillRect(cx + (6 + 22 * ext) * flip - 2, shoulderY - 4, 6, 6);
          }
          ctx.strokeStyle = color1;
          ctx.beginPath();
          ctx.moveTo(cx - 4 * flip, shoulderY + 2);
          ctx.lineTo(cx + 4 * flip, shoulderY + 10);
          ctx.stroke();
          break;

        case 'kick':
        case 'crouchKick':
          ctx.beginPath();
          ctx.moveTo(cx + 8 * flip, shoulderY);
          ctx.lineTo(cx + 14 * flip, shoulderY - 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - 4 * flip, shoulderY + 2);
          ctx.lineTo(cx + 4 * flip, shoulderY + 10);
          ctx.stroke();
          if (phase === 'active') {
            var kickY = f.crouching ? shoulderY + 30 : shoulderY + 20;
            ctx.save();
            ctx.strokeStyle = '#fff';
            ctx.shadowColor = '#f80';
            ctx.shadowBlur = 6;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(cx + 6 * flip, kickY);
            ctx.lineTo(cx + (6 + 30 * ext) * flip, kickY + 2);
            ctx.stroke();
            ctx.restore();
          }
          break;

        case 'special':
          if (phase === 'active') {
            ctx.save();
            ctx.strokeStyle = '#ff0';
            ctx.shadowColor = '#f44';
            ctx.shadowBlur = 12;
            ctx.lineWidth = 5;
          }
          ctx.beginPath();
          ctx.moveTo(cx + 6 * flip, shoulderY - 2);
          ctx.lineTo(cx + (6 + 30 * ext) * flip, shoulderY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + 2 * flip, shoulderY + 4);
          ctx.lineTo(cx + (2 + 28 * ext) * flip, shoulderY + 4);
          ctx.stroke();
          if (phase === 'active') {
            ctx.restore();
            var ex = cx + (10 + 30 * ext) * flip;
            var ey = shoulderY + 2;
            ctx.save();
            ctx.fillStyle = 'rgba(255,255,0,0.6)';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(ex, ey, 10 + Math.sin(frameCount * 0.5) * 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,68,68,0.4)';
            ctx.beginPath();
            ctx.arc(ex, ey, 15 + Math.sin(frameCount * 0.3) * 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            for (var i = 0; i < 2; i++) {
              particles.push({
                x: ex + (Math.random() - 0.5) * 14,
                y: ey + (Math.random() - 0.5) * 14,
                vx: (Math.random() - 0.5) * 100,
                vy: (Math.random() - 0.5) * 100 - 40,
                life: 0.15, maxLife: 0.15,
                color: Math.random() < 0.5 ? '#ff0' : '#f44',
                size: 2
              });
            }
          }
          break;

        case 'jumpKick':
          ctx.beginPath();
          ctx.moveTo(cx + 8 * flip, shoulderY);
          ctx.lineTo(cx + 14 * flip, shoulderY - 8);
          ctx.stroke();
          if (phase === 'active') {
            ctx.save();
            ctx.strokeStyle = '#fff';
            ctx.shadowColor = '#f80';
            ctx.shadowBlur = 6;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(cx, shoulderY + 20);
            ctx.lineTo(cx + 28 * ext * flip, shoulderY + 26);
            ctx.stroke();
            ctx.restore();
          }
          break;
      }
    }

    function drawParticles() {
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        var alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.save();
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 4;
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }

    function drawComboTexts() {
      for (var i = 0; i < comboTexts.length; i++) {
        var ct = comboTexts[i];
        var alpha = ct.timer / 60;
        ctx.globalAlpha = alpha;
        ctx.save();
        ctx.fillStyle = ct.color;
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.shadowColor = ct.color;
        ctx.shadowBlur = 8;
        ctx.fillText(ct.text, ct.x, ct.y - (60 - ct.timer) * 0.5);
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      ctx.textAlign = 'left';
    }

    function drawComboCounter() {
      if (player.comboHits >= 2) {
        ctx.save();
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'left';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 8;
        ctx.fillText(player.comboHits + ' HIT COMBO!', 12, H - 20);
        if (player.comboDamageBonus > 1.0) {
          ctx.fillStyle = '#f80';
          ctx.font = '12px Courier New';
          ctx.fillText('x' + player.comboDamageBonus.toFixed(1) + ' DMG', 12, H - 6);
        }
        ctx.restore();
      }
      if (ai.comboHits >= 2) {
        ctx.save();
        ctx.fillStyle = '#f44';
        ctx.font = 'bold 16px Courier New';
        ctx.textAlign = 'right';
        ctx.shadowColor = '#f44';
        ctx.shadowBlur = 8;
        ctx.fillText(ai.comboHits + ' HIT COMBO!', W - 12, H - 20);
        ctx.restore();
      }
      ctx.textAlign = 'left';
    }

    function drawAnnounce() {
      if (announceTimer <= 0) return;
      var alpha = Math.min(1, announceTimer / 20);
      var scale = announceTimer > 70 ? 1 + (90 - announceTimer) * 0.02 : 1;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = THEME;
      ctx.font = 'bold ' + Math.round(32 * scale) + 'px Courier New';
      ctx.textAlign = 'center';
      ctx.shadowColor = THEME;
      ctx.shadowBlur = 20;
      ctx.fillText(announceText, W / 2, H / 2 - 20);
      ctx.restore();
      ctx.textAlign = 'left';
    }

    function drawControlHints() {
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.font = '9px Courier New';
      ctx.textAlign = 'left';
      ctx.fillText('Z=Punch X=Kick C=Special S=Block', 8, H - 2);
    }

    // ================================================================
    // == MAIN LOOP ==
    // ================================================================

    function update(timestamp) {
      requestAnimationFrame(update);
      if (!lastTime) lastTime = timestamp;
      dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      if (gameState === 'playing') {
        frameCount++;

        roundTimer -= dt;
        timerDispEl.textContent = Math.max(0, Math.ceil(roundTimer));

        if (roundTimer <= 0 || player.hp <= 0 || ai.hp <= 0) {
          endRound();
        } else {
          handlePlayerInput();
          updateAI();
          updateFighter(player, ai, dt);
          updateFighter(ai, player, dt);

          // Particles
          for (var i = particles.length - 1; i >= 0; i--) {
            var p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 200 * dt;
            p.life -= dt;
            if (p.life <= 0) particles.splice(i, 1);
          }

          // Combo texts
          for (var i = comboTexts.length - 1; i >= 0; i--) {
            comboTexts[i].timer--;
            if (comboTexts[i].timer <= 0) comboTexts.splice(i, 1);
          }

          if (announceTimer > 0) announceTimer--;
          if (screenShake > 0) screenShake *= 0.85;
          if (screenShake < 0.5) screenShake = 0;
        }
      }

      // == Draw ==
      ctx.save();
      if (screenShake > 0) {
        ctx.translate(
          (Math.random() - 0.5) * screenShake * 2,
          (Math.random() - 0.5) * screenShake * 2
        );
      }

      drawArena();

      if (gameState === 'playing' || gameState === 'roundEnd') {
        drawFighter(player, '#4488ff', '#2266cc');
        drawFighter(ai, '#ff4444', '#cc2222');
        drawParticles();
        drawComboTexts();
        drawHealthBars();
        drawComboCounter();
        drawAnnounce();
        drawControlHints();
      }

      ctx.restore();

      // Clear just-pressed
      for (var k in keysJustPressed) delete keysJustPressed[k];
    }

    // == Start ==
    requestAnimationFrame(update);

    // == Recorder integration ==
    if (typeof Recorder !== 'undefined') {
      try {
        var recorder = new Recorder(canvas, {
          gameStateGetter: function() { return gameState; },
          scoreGetter: function() { return score; }
        });
      } catch(e) {}
    }
  </script>
</body>
</html>
